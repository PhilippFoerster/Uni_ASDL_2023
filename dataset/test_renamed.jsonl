{"func": "int ffgetwavheader(AVFormatContext *s, AVIOContext *pb, AVCodecContext *codec, int size, int bigendian) { int id; uint64t bitrate; if (size < 14) { avprivrequestsample(codec, \"wav header size < 14\"); return AVERRORINVALIDDATA; } codec->codectype = AVMEDIATYPEAUDIO; if (!bigendian) { id = aviorl16(pb); if (id != 0x0165) { codec->channels = aviorl16(pb); codec->samplerate = aviorl32(pb); bitrate = aviorl32(pb) * 8LL; codec->blockalign = aviorl16(pb); } } else { id = aviorb16(pb); codec->channels = aviorb16(pb); codec->samplerate = aviorb32(pb); bitrate = aviorb32(pb) * 8LL; codec->blockalign = aviorb16(pb); } if (size == 14) { /* We're dealing with plain vanilla WAVEFORMAT */ codec->bitspercodedsample = 8; } else { if (!bigendian) { codec->bitspercodedsample = aviorl16(pb); } else { codec->bitspercodedsample = aviorb16(pb); } } if (id == 0xFFFE) { codec->codectag = 0; } else { codec->codectag = id; codec->codecid = ffwavcodecgetid(id, codec->bitspercodedsample); } if (size >= 18 && id != 0x0165) { /* We're obviously dealing with WAVEFORMATEX */ int cbSize = aviorl16(pb); /* cbSize */ if (bigendian) { avprivreportmissingfeature(codec, \"WAVEFORMATEX support for RIFX files\\n\"); return AVERRORPATCHWELCOME; } size -= 18; cbSize = FFMIN(size, cbSize); if (cbSize >= 22 && id == 0xfffe) { /* WAVEFORMATEXTENSIBLE */ parsewaveformatex(pb, codec); cbSize -= 22; size -= 22; } if (cbSize > 0) { avfreep(&codec->extradata); if (ffgetextradata(codec, pb, cbSize) < 0) return AVERROR(ENOMEM); size -= cbSize; } /* It is possible for the chunk to contain garbage at the end */ if (size > 0) avioskip(pb, size); } else if (id == 0x0165 && size >= 32) { int nbstreams, i; size -= 4; avfreep(&codec->extradata); if (ffgetextradata(codec, pb, size) < 0) return AVERROR(ENOMEM); nbstreams = AVRL16(codec->extradata + 4); codec->samplerate = AVRL32(codec->extradata + 12); codec->channels = 0; bitrate = 0; if (size < 8 + nbstreams * 20) return AVERRORINVALIDDATA; for (i = 0; i < nbstreams; i++) codec->channels += codec->extradata[8 + i * 20 + 17]; } if (bitrate > INTMAX) { if (s->errorrecognition & AVEFEXPLODE) { avlog(s, AVLOGERROR, \"The bitrate %\"PRIu64\" is too large.\\n\", bitrate); return AVERRORINVALIDDATA; } else { avlog(s, AVLOGWARNING, \"The bitrate %\"PRIu64\" is too large, resetting to 0.\", bitrate); codec->bitrate = 0; } } else { codec->bitrate = bitrate; } if (codec->samplerate <= 0) { avlog(s, AVLOGERROR, \"Invalid sample rate: %d\\n\", codec->samplerate); return AVERRORINVALIDDATA; } if (codec->codecid == AVCODECIDAACLATM) { /* Channels and samplerate values are those prior to applying SBR * and/or PS. */ codec->channels = 0; codec->samplerate = 0; } /* override bitspercodedsample for G.726 */ if (codec->codecid == AVCODECIDADPCMG726 && codec->samplerate) codec->bitspercodedsample = codec->bitrate / codec->samplerate; return 0; } ", "target": 0}
{"func": "static int xen9pfsconnect(struct XenDevice *xendev) { int i; Xen9pfsDev *xen9pdev = containerof(xendev, Xen9pfsDev, xendev); V9fsState *s = &xen9pdev->state; QemuOpts *fsdev; if (xenstorereadfeint(&xen9pdev->xendev, \"num-rings\", &xen9pdev->numrings) == -1 || xen9pdev->numrings > MAXRINGS || xen9pdev->numrings < 1) { return -1; } xen9pdev->rings = gmalloc0(xen9pdev->numrings * sizeof(Xen9pfsRing)); for (i = 0; i < xen9pdev->numrings; i++) { char *str; int ringorder; xen9pdev->rings[i].priv = xen9pdev; xen9pdev->rings[i].evtchn = -1; xen9pdev->rings[i].localport = -1; str = gstrdupprintf(\"ring-ref%u\", i); if (xenstorereadfeint(&xen9pdev->xendev, str, &xen9pdev->rings[i].ref) == -1) { goto out; } str = gstrdupprintf(\"event-channel-%u\", i); if (xenstorereadfeint(&xen9pdev->xendev, str, &xen9pdev->rings[i].evtchn) == -1) { goto out; } xen9pdev->rings[i].intf = xengnttabmapgrantref( xen9pdev->xendev.gnttabdev, xen9pdev->xendev.dom, xen9pdev->rings[i].ref, PROTREAD | PROTWRITE); if (!xen9pdev->rings[i].intf) { goto out; } ringorder = xen9pdev->rings[i].intf->ringorder; if (ringorder > MAXRINGORDER) { goto out; } xen9pdev->rings[i].ringorder = ringorder; xen9pdev->rings[i].data = xengnttabmapdomaingrantrefs( xen9pdev->xendev.gnttabdev, (1 << ringorder), xen9pdev->xendev.dom, xen9pdev->rings[i].intf->ref, PROTREAD | PROTWRITE); if (!xen9pdev->rings[i].data) { goto out; } xen9pdev->rings[i].ring.in = xen9pdev->rings[i].data; xen9pdev->rings[i].ring.out = xen9pdev->rings[i].data + XENFLEXRINGSIZE(ringorder); xen9pdev->rings[i].bh = qemubhnew(xen9pfsbh, &xen9pdev->rings[i]); xen9pdev->rings[i].outcons = 0; xen9pdev->rings[i].outsize = 0; xen9pdev->rings[i].inprogress = false; xen9pdev->rings[i].evtchndev = xenevtchnopen(NULL, 0); if (xen9pdev->rings[i].evtchndev == NULL) { goto out; } fcntl(xenevtchnfd(xen9pdev->rings[i].evtchndev), FSETFD, FDCLOEXEC); xen9pdev->rings[i].localport = xenevtchnbindinterdomain (xen9pdev->rings[i].evtchndev, xendev->dom, xen9pdev->rings[i].evtchn); if (xen9pdev->rings[i].localport == -1) { xenpvprintf(xendev, 0, \"xenevtchnbindinterdomain failed port=%d\\n\", xen9pdev->rings[i].evtchn); goto out; } xenpvprintf(xendev, 2, \"bind evtchn port %d\\n\", xendev->localport); qemusetfdhandler(xenevtchnfd(xen9pdev->rings[i].evtchndev), xen9pfsevtchnevent, NULL, &xen9pdev->rings[i]); } xen9pdev->securitymodel = xenstorereadbestr(xendev, \"securitymodel\"); xen9pdev->path = xenstorereadbestr(xendev, \"path\"); xen9pdev->id = s->fsconf.fsdevid = gstrdupprintf(\"xen9p%d\", xendev->dev); xen9pdev->tag = s->fsconf.tag = xenstorereadfestr(xendev, \"tag\"); v9fsregistertransport(s, &xen9ptransport); fsdev = qemuoptscreate(qemufindopts(\"fsdev\"), s->fsconf.tag, 1, NULL); qemuoptset(fsdev, \"fsdriver\", \"local\", NULL); qemuoptset(fsdev, \"path\", xen9pdev->path, NULL); qemuoptset(fsdev, \"securitymodel\", xen9pdev->securitymodel, NULL); qemuoptssetid(fsdev, s->fsconf.fsdevid); qemufsdevadd(fsdev); v9fsdevicerealizecommon(s, NULL); return 0; out: xen9pfsfree(xendev); return -1; }", "target": 1}
{"func": "static int subframecountexact(FlacEncodeContext *s, FlacSubframe *sub, int predorder) { int p, porder, psize; int i, partend; int count = 0; /* subframe header */ count += 8; /* subframe */ if (sub->type == FLACSUBFRAMECONSTANT) { count += sub->obits; } else if (sub->type == FLACSUBFRAMEVERBATIM) { count += s->frame.blocksize * sub->obits; } else { /* warm-up samples */ count += predorder * sub->obits; /* LPC coefficients */ if (sub->type == FLACSUBFRAMELPC) count += 4 + 5 + predorder * s->options.lpccoeffprecision; /* rice-encoded block */ count += 2; /* partition order */ porder = sub->rc.porder; psize = s->frame.blocksize >> porder; count += 4; /* residual */ i = predorder; partend = psize; for (p = 0; p < 1 << porder; p++) { int k = sub->rc.params[p]; count += 4; count += ricecountexact(&sub->residual[i], partend - i, k); i = partend; partend = FFMIN(s->frame.blocksize, partend + psize); } } return count; } ", "target": 1}
{"func": "static void ppcspaprinit(QEMUMachineInitArgs *args) { ramaddrt ramsize = args->ramsize; const char *cpumodel = args->cpumodel; const char *kernelfilename = args->kernelfilename; const char *kernelcmdline = args->kernelcmdline; const char *initrdfilename = args->initrdfilename; const char *bootdevice = args->bootorder; PowerPCCPU *cpu; CPUPPCState *env; PCIHostState *phb; int i; MemoryRegion *sysmem = getsystemmemory(); MemoryRegion *ram = gnew(MemoryRegion, 1); hwaddr rmaallocsize; uint32t initrdbase = 0; long kernelsize = 0, initrdsize = 0; long loadlimit, rtaslimit, fwsize; bool kernelle = false; char *filename; msisupported = true; spapr = gmalloc0(sizeof(*spapr)); QLISTINIT(&spapr->phbs); cpuppchypercall = emulatespaprhypercall; /* Allocate RMA if necessary */ rmaallocsize = kvmppcallocrma(\"ppcspapr.rma\", sysmem); if (rmaallocsize == -1) { hwerror(\"qemu: Unable to create RMA\\n\"); exit(1); } if (rmaallocsize && (rmaallocsize < ramsize)) { spapr->rmasize = rmaallocsize; } else { spapr->rmasize = ramsize; /* With KVM, we don't actually know whether KVM supports an * unbounded RMA (PR KVM) or is limited by the hash table size * (HV KVM using VRMA), so we always assume the latter * * In that case, we also limit the initial allocations for RTAS * etc... to 256M since we have no way to know what the VRMA size * is going to be as it depends on the size of the hash table * isn't determined yet. */ if (kvmenabled()) { spapr->vrmaadjust = 1; spapr->rmasize = MIN(spapr->rmasize, 0x10000000); } } /* We place the device tree and RTAS just below either the top of the RMA, * or just below 2GB, whichever is lowere, so that it can be * processed with 32-bit real mode code if necessary */ rtaslimit = MIN(spapr->rmasize, 0x80000000); spapr->rtasaddr = rtaslimit - RTASMAXSIZE; spapr->fdtaddr = spapr->rtasaddr - FDTMAXSIZE; loadlimit = spapr->fdtaddr - FWOVERHEAD; /* We aim for a hash table of size 1/128 the size of RAM. The * normal rule of thumb is 1/64 the size of RAM, but that's much * more than needed for the Linux guests we support. */ spapr->htabshift = 18; /* Minimum architected size */ while (spapr->htabshift <= 46) { if ((1ULL << (spapr->htabshift + 7)) >= ramsize) { break; } spapr->htabshift++; } /* Set up Interrupt Controller before we create the VCPUs */ spapr->icp = xicssysteminit(smpcpus * kvmppcsmtthreads() / smpthreads, XICSIRQS); spapr->nextirq = XICSIRQBASE; /* init CPUs */ if (cpumodel == NULL) { cpumodel = kvmenabled() ? \"host\" : \"POWER7\"; } for (i = 0; i < smpcpus; i++) { cpu = cpuppcinit(cpumodel); if (cpu == NULL) { fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\"); exit(1); } env = &cpu->env; xicscpusetup(spapr->icp, cpu); /* Set time-base frequency to 512 MHz */ cpuppctbinit(env, TIMEBASEFREQ); /* PAPR always has exception vectors in RAM not ROM. To ensure this, * MSR[IP] should never be set. */ env->msrmask &= ~(1 << 6); /* Tell KVM that we're in PAPR mode */ if (kvmenabled()) { kvmppcsetpapr(cpu); } qemuregisterreset(spaprcpureset, cpu); } /* allocate RAM */ spapr->ramlimit = ramsize; if (spapr->ramlimit > rmaallocsize) { ramaddrt nonrmabase = rmaallocsize; ramaddrt nonrmasize = spapr->ramlimit - rmaallocsize; memoryregioninitram(ram, NULL, \"ppcspapr.ram\", nonrmasize); vmstateregisterramglobal(ram); memoryregionaddsubregion(sysmem, nonrmabase, ram); } filename = qemufindfile(QEMUFILETYPEBIOS, \"spapr-rtas.bin\"); spapr->rtassize = loadimagetargphys(filename, spapr->rtasaddr, rtaslimit - spapr->rtasaddr); if (spapr->rtassize < 0) { hwerror(\"qemu: could not load LPAR rtas '%s'\\n\", filename); exit(1); } if (spapr->rtassize > RTASMAXSIZE) { hwerror(\"RTAS too big ! 0x%lx bytes (max is 0x%x)\\n\", spapr->rtassize, RTASMAXSIZE); exit(1); } gfree(filename); /* Set up EPOW events infrastructure */ spapreventsinit(spapr); /* Set up VIO bus */ spapr->viobus = spaprviobusinit(); for (i = 0; i < MAXSERIALPORTS; i++) { if (serialhds[i]) { spaprvtycreate(spapr->viobus, serialhds[i]); } } /* We always have at least the nvram device on VIO */ spaprcreatenvram(spapr); /* Set up PCI */ spaprpcimsiinit(spapr, SPAPRPCIMSIWINDOW); spaprpcirtasinit(); phb = spaprcreatephb(spapr, 0); for (i = 0; i < nbnics; i++) { NICInfo *nd = &ndtable[i]; if (!nd->model) { nd->model = gstrdup(\"ibmveth\"); } if (strcmp(nd->model, \"ibmveth\") == 0) { spaprvlancreate(spapr->viobus, nd); } else { pcinicinitnofail(&ndtable[i], phb->bus, nd->model, NULL); } } for (i = 0; i <= drivegetmaxbus(IFSCSI); i++) { spaprvscsicreate(spapr->viobus); } /* Graphics */ if (spaprvgainit(phb->bus)) { spapr->hasgraphics = true; } if (usbenabled(spapr->hasgraphics)) { pcicreatesimple(phb->bus, -1, \"pci-ohci\"); if (spapr->hasgraphics) { usbdevicecreate(\"keyboard\"); usbdevicecreate(\"mouse\"); } } if (spapr->rmasize < (MINRMASLOF << 20)) { fprintf(stderr, \"qemu: pSeries SLOF firmware requires >= \" \"%ldM guest RMA (Real Mode Area memory)\\n\", MINRMASLOF); exit(1); } if (kernelfilename) { uint64t lowaddr = 0; kernelsize = loadelf(kernelfilename, translatekerneladdress, NULL, NULL, &lowaddr, NULL, 1, ELFMACHINE, 0); if (kernelsize < 0) { kernelsize = loadelf(kernelfilename, translatekerneladdress, NULL, NULL, &lowaddr, NULL, 0, ELFMACHINE, 0); kernelle = kernelsize > 0; } if (kernelsize < 0) { kernelsize = loadimagetargphys(kernelfilename, KERNELLOADADDR, loadlimit - KERNELLOADADDR); } if (kernelsize < 0) { fprintf(stderr, \"qemu: could not load kernel '%s'\\n\", kernelfilename); exit(1); } /* load initrd */ if (initrdfilename) { /* Try to locate the initrd in the gap between the kernel * and the firmware. Add a bit of space just in case */ initrdbase = (KERNELLOADADDR + kernelsize + 0x1ffff) & ~0xffff; initrdsize = loadimagetargphys(initrdfilename, initrdbase, loadlimit - initrdbase); if (initrdsize < 0) { fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\", initrdfilename); exit(1); } } else { initrdbase = 0; initrdsize = 0; } } if (biosname == NULL) { biosname = FWFILENAME; } filename = qemufindfile(QEMUFILETYPEBIOS, biosname); fwsize = loadimagetargphys(filename, 0, FWMAXSIZE); if (fwsize < 0) { hwerror(\"qemu: could not load LPAR rtas '%s'\\n\", filename); exit(1); } gfree(filename); spapr->entrypoint = 0x100; vmstateregister(NULL, 0, &vmstatespapr, spapr); registersavevmlive(NULL, \"spapr/htab\", -1, 1, &savevmhtabhandlers, spapr); /* Prepare the device tree */ spapr->fdtskel = spaprcreatefdtskel(cpumodel, initrdbase, initrdsize, kernelsize, kernelle, bootdevice, kernelcmdline, spapr->epowirq); assert(spapr->fdtskel != NULL); } ", "target": 0}
{"func": "static int mpeg1decodesequence(AVCodecContext *avctx, UINT8 *buf, int bufsize) { Mpeg1Context *s1 = avctx->privdata; MpegEncContext *s = &s1->mpegencctx; int width, height, i, v, j; float aspect; initgetbits(&s->gb, buf, bufsize); width = getbits(&s->gb, 12); height = getbits(&s->gb, 12); s->aspectratioinfo= getbits(&s->gb, 4); if(!s->mpeg2){ aspect= mpeg1aspect[s->aspectratioinfo]; if(aspect!=0.0) avctx->aspectratio= width/(aspect*height); } s->framerateindex = getbits(&s->gb, 4); if (s->framerateindex == 0) return -1; s->bitrate = getbits(&s->gb, 18) * 400; if (getbits1(&s->gb) == 0) /* marker */ return -1; if (width <= 0 || height <= 0 || (width % 2) != 0 || (height % 2) != 0) return -1; if (width != s->width || height != s->height) { /* start new mpeg1 context decoding */ s->outformat = FMTMPEG1; if (s1->mpegencctxallocated) { MPVcommonend(s); } s->width = width; s->height = height; avctx->hasbframes= 1; s->avctx = avctx; avctx->width = width; avctx->height = height; if (s->framerateindex >= 9) { /* at least give a valid frame rate (some old mpeg1 have this) */ avctx->framerate = 25 * FRAMERATEBASE; } else { avctx->framerate = frameratetab[s->framerateindex]; } s->framerate = avctx->framerate; avctx->bitrate = s->bitrate; if (MPVcommoninit(s) < 0) return -1; s1->mpegencctxallocated = 1; } skipbits(&s->gb, 10); /* vbvbuffersize */ skipbits(&s->gb, 1); /* get matrix */ if (getbits1(&s->gb)) { for(i=0;i<64;i++) { v = getbits(&s->gb, 8); j = s->intrascantable.permutated[i]; s->intramatrix[j] = v; s->chromaintramatrix[j] = v; } #ifdef DEBUG dprintf(\"intra matrix present\\n\"); for(i=0;i<64;i++) dprintf(\" %d\", s->intramatrix[s->intrascantable.permutated[i]]); printf(\"\\n\"); #endif } else { for(i=0;i<64;i++) { int j= s->idctpermutation[i]; v = ffmpeg1defaultintramatrix[i]; s->intramatrix[j] = v; s->chromaintramatrix[j] = v; } } if (getbits1(&s->gb)) { for(i=0;i<64;i++) { v = getbits(&s->gb, 8); j = s->intrascantable.permutated[i]; s->intermatrix[j] = v; s->chromaintermatrix[j] = v; } #ifdef DEBUG dprintf(\"non intra matrix present\\n\"); for(i=0;i<64;i++) dprintf(\" %d\", s->intermatrix[s->intrascantable.permutated[i]]); printf(\"\\n\"); #endif } else { for(i=0;i<64;i++) { int j= s->idctpermutation[i]; v = ffmpeg1defaultnonintramatrix[i]; s->intermatrix[j] = v; s->chromaintermatrix[j] = v; } } /* we set mpeg2 parameters so that it emulates mpeg1 */ s->progressivesequence = 1; s->progressiveframe = 1; s->picturestructure = PICTFRAME; s->framepredframedct = 1; s->mpeg2 = 0; avctx->subid = 1; /* indicates mpeg1 */ return 0; } ", "target": 0}
{"func": "static uint32t drcsetunusable(sPAPRDRConnector *drc) { drc->allocationstate = SPAPRDRALLOCATIONSTATEUNUSABLE; if (drc->awaitingrelease) { uint32t drcindex = spaprdrcindex(drc); tracespaprdrcsetallocationstatefinalizing(drcindex); spaprdrcdetach(drc); } return RTASOUTSUCCESS; } ", "target": 0}
{"func": "static void scsireadrequest(SCSIDiskReq *r) { SCSIDiskState *s = DOUPCAST(SCSIDiskState, qdev, r->req.dev); uint32t n; if (r->sectorcount == (uint32t)-1) { DPRINTF(\"Read buflen=%zd\\n\", r->iov.iovlen); r->sectorcount = 0; scsireqdata(&r->req, r->iov.iovlen); return; } DPRINTF(\"Read sectorcount=%d\\n\", r->sectorcount); if (r->sectorcount == 0) { scsicommandcomplete(r, GOOD, NOSENSE); return; } /* No data transfer may already be in progress */ assert(r->req.aiocb == NULL); n = r->sectorcount; if (n > SCSIDMABUFSIZE / 512) n = SCSIDMABUFSIZE / 512; r->iov.iovlen = n * 512; qemuiovecinitexternal(&r->qiov, &r->iov, 1); r->req.aiocb = bdrvaioreadv(s->bs, r->sector, &r->qiov, n, scsireadcomplete, r); if (r->req.aiocb == NULL) { scsireadcomplete(r, -EIO); } } ", "target": 1}
{"func": "static void lm32evrinit(MachineState *machine) { const char *cpumodel = machine->cpumodel; const char *kernelfilename = machine->kernelfilename; LM32CPU *cpu; CPULM32State *env; DriveInfo *dinfo; MemoryRegion *addressspacemem = getsystemmemory(); MemoryRegion *physram = gnew(MemoryRegion, 1); qemuirq irq[32]; ResetInfo *resetinfo; int i; /* memory map */ hwaddr flashbase = 0x04000000; sizet flashsectorsize = 256 * 1024; sizet flashsize = 32 * 1024 * 1024; hwaddr rambase = 0x08000000; sizet ramsize = 64 * 1024 * 1024; hwaddr timer0base = 0x80002000; hwaddr uart0base = 0x80006000; hwaddr timer1base = 0x8000a000; int uart0irq = 0; int timer0irq = 1; int timer1irq = 3; resetinfo = gmalloc0(sizeof(ResetInfo)); if (cpumodel == NULL) { cpumodel = \"lm32-full\"; } cpu = LM32CPU(cpugenericinit(TYPELM32CPU, cpumodel)); if (cpu == NULL) { fprintf(stderr, \"qemu: unable to find CPU '%s'\\n\", cpumodel); exit(1); } env = &cpu->env; resetinfo->cpu = cpu; resetinfo->flashbase = flashbase; memoryregionallocatesystemmemory(physram, NULL, \"lm32evr.sdram\", ramsize); memoryregionaddsubregion(addressspacemem, rambase, physram); dinfo = driveget(IFPFLASH, 0, 0); /* Spansion S29NS128P */ pflashcfi02register(flashbase, NULL, \"lm32evr.flash\", flashsize, dinfo ? blkbylegacydinfo(dinfo) : NULL, flashsectorsize, flashsize / flashsectorsize, 1, 2, 0x01, 0x7e, 0x43, 0x00, 0x555, 0x2aa, 1); /* create irq lines */ env->picstate = lm32picinit(qemuallocateirq(cpuirqhandler, cpu, 0)); for (i = 0; i < 32; i++) { irq[i] = qdevgetgpioin(env->picstate, i); } lm32uartcreate(uart0base, irq[uart0irq], serialhds[0]); sysbuscreatesimple(\"lm32-timer\", timer0base, irq[timer0irq]); sysbuscreatesimple(\"lm32-timer\", timer1base, irq[timer1irq]); /* make sure juart isn't the first chardev */ env->juartstate = lm32juartinit(serialhds[1]); resetinfo->bootstrappc = flashbase; if (kernelfilename) { uint64t entry; int kernelsize; kernelsize = loadelf(kernelfilename, NULL, NULL, &entry, NULL, NULL, 1, EMLATTICEMICO32, 0, 0); resetinfo->bootstrappc = entry; if (kernelsize < 0) { kernelsize = loadimagetargphys(kernelfilename, rambase, ramsize); resetinfo->bootstrappc = rambase; } if (kernelsize < 0) { fprintf(stderr, \"qemu: could not load kernel '%s'\\n\", kernelfilename); exit(1); } } qemuregisterreset(maincpureset, resetinfo); } ", "target": 1}
{"func": "aiowritef(int argc, char **argv) { \tchar *p; \tint count = 0; \tint nriov, i, c; \tint pattern = 0xcd; \tstruct aioctx *ctx = calloc(1, sizeof(struct aioctx)); \tBlockDriverAIOCB *acb; \twhile ((c = getopt(argc, argv, \"CqP:\")) != EOF) { \t\tswitch (c) { \t\tcase 'C': \t\t\tctx->Cflag = 1; \t\t\tbreak; \t\tcase 'q': \t\t\tctx->qflag = 1; \t\t\tbreak; \t\tcase 'P': \t\t\tpattern = atoi(optarg); \t\t\tbreak; \t\tdefault: \t\t\treturn commandusage(&aiowritecmd); \t\t} \t} \tif (optind > argc - 2) \t\treturn commandusage(&aiowritecmd); \tctx->offset = cvtnum(argv[optind]); \tif (ctx->offset < 0) { \t\tprintf(\"non-numeric length argument -- %s\\n\", argv[optind]); \t\treturn 0; \t} \toptind++; \tif (ctx->offset & 0x1ff) { \t\tprintf(\"offset %lld is not sector aligned\\n\", \t\t\t(long long)ctx->offset); \t\treturn 0; \t} \tif (count & 0x1ff) { \t\tprintf(\"count %d is not sector aligned\\n\", \t\t\tcount); \t\treturn 0; \t} \tfor (i = optind; i < argc; i++) { \t sizet len; \t\tlen = cvtnum(argv[optind]); \t\tif (len < 0) { \t\t\tprintf(\"non-numeric length argument -- %s\\n\", argv[i]); \t\t\treturn 0; \t\t} \t\tcount += len; \t} \tnriov = argc - optind; \tqemuiovecinit(&ctx->qiov, nriov); \tctx->buf = p = qemuioalloc(count, pattern); \tfor (i = 0; i < nriov; i++) { \t sizet len; \t\tlen = cvtnum(argv[optind]); \t\tif (len < 0) { \t\t\tprintf(\"non-numeric length argument -- %s\\n\", \t\t\t\targv[optind]); \t\t\treturn 0; \t\t} \t\tqemuiovecadd(&ctx->qiov, p, len); \t\tp += len; \t\toptind++; \t} \tgettimeofday(&ctx->t1, NULL); \tacb = bdrvaiowritev(bs, ctx->offset >> 9, &ctx->qiov, \t\t\t ctx->qiov.size >> 9, aiowritedone, ctx); \tif (!acb) \t\treturn -EIO; \treturn 0; } ", "target": 0}
{"func": "static void vc1invtrans8x8dcc(uint8t *dest, int linesize, DCTELEM *block) { int i; int dc = block[0]; const uint8t *cm; dc = (3 * dc + 1) >> 1; dc = (3 * dc + 16) >> 5; cm = ffcropTbl + MAXNEGCROP + dc; for(i = 0; i < 8; i++){ dest[0] = cm[dest[0]]; dest[1] = cm[dest[1]]; dest[2] = cm[dest[2]]; dest[3] = cm[dest[3]]; dest[4] = cm[dest[4]]; dest[5] = cm[dest[5]]; dest[6] = cm[dest[6]]; dest[7] = cm[dest[7]]; dest += linesize; } } ", "target": 1}
{"func": "static int vmdkparseextents(const char *desc, BlockDriverState *bs, const char *descfilepath) { int ret; char access[11]; char type[11]; char fname[512]; const char *p = desc; int64t sectors = 0; int64t flatoffset; char extentpath[PATHMAX]; BlockDriverState *extentfile; Error *localerr = NULL; while (*p) { /* parse extent line: * RW [size in sectors] FLAT \"file-name.vmdk\" OFFSET * or * RW [size in sectors] SPARSE \"file-name.vmdk\" */ flatoffset = -1; ret = sscanf(p, \"%10s %\" SCNd64 \" %10s \\\"%511[^\\n\\r\\\"]\\\" %\" SCNd64, access, &sectors, type, fname, &flatoffset); if (ret < 4 || strcmp(access, \"RW\")) { goto nextline; } else if (!strcmp(type, \"FLAT\")) { if (ret != 5 || flatoffset < 0) { return -EINVAL; } } else if (ret != 4) { return -EINVAL; } if (sectors <= 0 || (strcmp(type, \"FLAT\") && strcmp(type, \"SPARSE\") && strcmp(type, \"VMFS\") && strcmp(type, \"VMFSSPARSE\")) || (strcmp(access, \"RW\"))) { goto nextline; } pathcombine(extentpath, sizeof(extentpath), descfilepath, fname); ret = bdrvfileopen(&extentfile, extentpath, NULL, bs->openflags, &localerr); if (ret) { qerrorreporterr(localerr); errorfree(localerr); return ret; } /* save to extents array */ if (!strcmp(type, \"FLAT\") || !strcmp(type, \"VMFS\")) { /* FLAT extent */ VmdkExtent *extent; ret = vmdkaddextent(bs, extentfile, true, sectors, 0, 0, 0, 0, sectors, &extent); if (ret < 0) { return ret; } extent->flatstartoffset = flatoffset << 9; } else if (!strcmp(type, \"SPARSE\") || !strcmp(type, \"VMFSSPARSE\")) { /* SPARSE extent and VMFSSPARSE extent are both \"COWD\" sparse file*/ ret = vmdkopensparse(bs, extentfile, bs->openflags); if (ret) { bdrvunref(extentfile); return ret; } } else { fprintf(stderr, \"VMDK: Not supported extent type \\\"%s\\\"\"\".\\n\", type); return -ENOTSUP; } nextline: /* move to next line */ while (*p && *p != '\\n') { p++; } p++; } return 0; } ", "target": 1}
{"func": "static void computerematrixingstrategy(AC3EncodeContext *s) { int nbcoefs; int blk, bnd, i; AC3Block *block, *block0; s->numrematrixingbands = 4; if (s->rematrixing & AC3REMATRIXINGISSTATIC) return; nbcoefs = FFMIN(s->nbcoefs[0], s->nbcoefs[1]); for (blk = 0; blk < AC3MAXBLOCKS; blk++) { block = &s->blocks[blk]; block->newrematrixingstrategy = !blk; for (bnd = 0; bnd < s->numrematrixingbands; bnd++) { /* calculate calculate sum of squared coeffs for one band in one block */ int start = ffac3rematrixbandtab[bnd]; int end = FFMIN(nbcoefs, ffac3rematrixbandtab[bnd+1]); CoefSumType sum[4] = {0,}; for (i = start; i < end; i++) { CoefType lt = block->mdctcoef[0][i]; CoefType rt = block->mdctcoef[1][i]; CoefType md = lt + rt; CoefType sd = lt - rt; sum[0] += lt * lt; sum[1] += rt * rt; sum[2] += md * md; sum[3] += sd * sd; } /* compare sums to determine if rematrixing will be used for this band */ if (FFMIN(sum[2], sum[3]) < FFMIN(sum[0], sum[1])) block->rematrixingflags[bnd] = 1; else block->rematrixingflags[bnd] = 0; /* determine if new rematrixing flags will be sent */ if (blk && block->rematrixingflags[bnd] != block0->rematrixingflags[bnd]) { block->newrematrixingstrategy = 1; } } block0 = block; } } ", "target": 1}
{"func": "void OPPROTO opudivT1T0(void) { uint64t x0; uint32t x1; x0 = T0 | ((uint64t) (env->y) << 32); x1 = T1; x0 = x0 / x1; if (x0 > 0xffffffff) { \tT0 = 0xffffffff; \tT1 = 1; } else { \tT0 = x0; \tT1 = 0; FORCERET();", "target": 1}
{"func": "void cpux86initmmu(CPUX86State *env) { a20enabled = 1; a20mask = 0xffffffff; lastpgstate = -1; cpux86updatecr0(env); } ", "target": 0}
{"func": "int qemucpuself(void *env) { return 1; } ", "target": 0}
{"func": "static void netvhostlinkdown(VhostUserState *s, bool linkdown) { s->nc.linkdown = linkdown; if (s->nc.peer) { s->nc.peer->linkdown = linkdown; } if (s->nc.info->linkstatuschanged) { s->nc.info->linkstatuschanged(&s->nc); } if (s->nc.peer && s->nc.peer->info->linkstatuschanged) { s->nc.peer->info->linkstatuschanged(s->nc.peer); } } ", "target": 0}
{"func": "static int rv34decodemv(RV34DecContext *r, int blocktype) { MpegEncContext *s = &r->s; GetBitContext *gb = &s->gb; int i, j, k, l; int mvpos = s->mbx * 2 + s->mby * 2 * s->b8stride; int nextbt; memset(r->dmv, 0, sizeof(r->dmv)); for(i = 0; i < nummvs[blocktype]; i++){ r->dmv[i][0] = svq3getsegolomb(gb); r->dmv[i][1] = svq3getsegolomb(gb); } switch(blocktype){ case RV34MBTYPEINTRA: case RV34MBTYPEINTRA16x16: ZERO8x2(s->currentpictureptr->f.motionval[0][s->mbx * 2 + s->mby * 2 * s->b8stride], s->b8stride); return 0; case RV34MBSKIP: if(s->picttype == AVPICTURETYPEP){ ZERO8x2(s->currentpictureptr->f.motionval[0][s->mbx * 2 + s->mby * 2 * s->b8stride], s->b8stride); rv34mc1mv (r, blocktype, 0, 0, 0, 2, 2, 0); break; } case RV34MBBDIRECT: //surprisingly, it uses motion scheme from next reference frame /* wait for the current mb row to be finished */ if (HAVETHREADS && (s->avctx->activethreadtype & FFTHREADFRAME)) ffthreadawaitprogress(&s->nextpictureptr->f, s->mby - 1, 0); nextbt = s->nextpictureptr->f.mbtype[s->mbx + s->mby * s->mbstride]; if(ISINTRA(nextbt) || ISSKIP(nextbt)){ ZERO8x2(s->currentpictureptr->f.motionval[0][s->mbx * 2 + s->mby * 2 * s->b8stride], s->b8stride); ZERO8x2(s->currentpictureptr->f.motionval[1][s->mbx * 2 + s->mby * 2 * s->b8stride], s->b8stride); }else for(j = 0; j < 2; j++) for(i = 0; i < 2; i++) for(k = 0; k < 2; k++) for(l = 0; l < 2; l++) s->currentpictureptr->f.motionval[l][mvpos + i + j*s->b8stride][k] = calcaddmv(r, l, s->nextpictureptr->f.motionval[0][mvpos + i + j*s->b8stride][k]); if(!(IS16X8(nextbt) || IS8X16(nextbt) || IS8X8(nextbt))) //we can use whole macroblock MC rv34mc2mv(r, blocktype); else rv34mc2mvskip(r); ZERO8x2(s->currentpictureptr->f.motionval[0][s->mbx * 2 + s->mby * 2 * s->b8stride], s->b8stride); break; case RV34MBP16x16: case RV34MBPMIX16x16: rv34predmv(r, blocktype, 0, 0); rv34mc1mv (r, blocktype, 0, 0, 0, 2, 2, 0); break; case RV34MBBFORWARD: case RV34MBBBACKWARD: r->dmv[1][0] = r->dmv[0][0]; r->dmv[1][1] = r->dmv[0][1]; if(r->rv30) rv34predmvrv3(r, blocktype, blocktype == RV34MBBBACKWARD); else rv34predmvb (r, blocktype, blocktype == RV34MBBBACKWARD); rv34mc1mv (r, blocktype, 0, 0, 0, 2, 2, blocktype == RV34MBBBACKWARD); break; case RV34MBP16x8: case RV34MBP8x16: rv34predmv(r, blocktype, 0, 0); rv34predmv(r, blocktype, 1 + (blocktype == RV34MBP16x8), 1); if(blocktype == RV34MBP16x8){ rv34mc1mv(r, blocktype, 0, 0, 0, 2, 1, 0); rv34mc1mv(r, blocktype, 0, 8, s->b8stride, 2, 1, 0); } if(blocktype == RV34MBP8x16){ rv34mc1mv(r, blocktype, 0, 0, 0, 1, 2, 0); rv34mc1mv(r, blocktype, 8, 0, 1, 1, 2, 0); } break; case RV34MBBBIDIR: rv34predmvb (r, blocktype, 0); rv34predmvb (r, blocktype, 1); rv34mc2mv (r, blocktype); break; case RV34MBP8x8: for(i=0;i< 4;i++){ rv34predmv(r, blocktype, i, i); rv34mc1mv (r, blocktype, (i&1)<<3, (i&2)<<2, (i&1)+(i>>1)*s->b8stride, 1, 1, 0); } break; } return 0; } ", "target": 0}
{"func": "static void mirrorstartjob(BlockDriverState *bs, BlockDriverState *target, const char *replaces, int64t speed, uint32t granularity, int64t bufsize, BlockdevOnError onsourceerror, BlockdevOnError ontargeterror, bool unmap, BlockCompletionFunc *cb, void *opaque, Error **errp, const BlockJobDriver *driver, bool isnonemode, BlockDriverState *base) { MirrorBlockJob *s; if (granularity == 0) { granularity = bdrvgetdefaultbitmapgranularity(target); } assert ((granularity & (granularity - 1)) == 0); if ((onsourceerror == BLOCKDEVONERRORSTOP || onsourceerror == BLOCKDEVONERRORENOSPC) && (!bs->blk || !blkiostatusisenabled(bs->blk))) { errorsetg(errp, QERRINVALIDPARAMETER, \"on-source-error\"); return; } if (bufsize < 0) { errorsetg(errp, \"Invalid parameter 'buf-size'\"); return; } if (bufsize == 0) { bufsize = DEFAULTMIRRORBUFSIZE; } /* We can't support this case as long as the block layer can't handle * multiple BlockBackends per BlockDriverState. */ if (replaces) { replacedbs = bdrvlookupbs(replaces, replaces, errp); if (replacedbs == NULL) { return; } } else { replacedbs = bs; } if (replacedbs->blk && target->blk) { errorsetg(errp, \"Can't create node with two BlockBackends\"); return; } s = blockjobcreate(driver, bs, speed, cb, opaque, errp); if (!s) { return; } s->replaces = gstrdup(replaces); s->onsourceerror = onsourceerror; s->ontargeterror = ontargeterror; s->target = target; s->isnonemode = isnonemode; s->base = base; s->granularity = granularity; s->bufsize = ROUNDUP(bufsize, granularity); s->unmap = unmap; s->dirtybitmap = bdrvcreatedirtybitmap(bs, granularity, NULL, errp); if (!s->dirtybitmap) { gfree(s->replaces); blockjobunref(&s->common); return; } bdrvopblockall(s->target, s->common.blocker); bdrvsetenablewritecache(s->target, true); if (s->target->blk) { blksetonerror(s->target->blk, ontargeterror, ontargeterror); blkiostatusenable(s->target->blk); } s->common.co = qemucoroutinecreate(mirrorrun); tracemirrorstart(bs, s, s->common.co, opaque); qemucoroutineenter(s->common.co, s); }", "target": 1}
{"func": "STARTTEST(qintgetinttest) { QInt *qi; const int value = 123456; qi = qintfromint(value); failunless(qintgetint(qi) == value); QDECREF(qi); } ", "target": 0}
{"func": "static int readcodetable(CLLCContext *ctx, GetBitContext *gb, VLC *vlc) { uint8t symbols[256]; uint8t bits[256]; uint16t codes[256]; int numlens, numcodes, numcodessum, prefix; int i, j, count; prefix = 0; count = 0; numcodessum = 0; numlens = getbits(gb, 5); for (i = 0; i < numlens; i++) { numcodes = getbits(gb, 9); numcodessum += numcodes; if (numcodessum > 256) { avlog(ctx->avctx, AVLOGERROR, \"Too many VLCs (%d) to be read.\\n\", numcodessum); for (j = 0; j < numcodes; j++) { symbols[count] = getbits(gb, 8); bits[count] = i + 1; codes[count] = prefix++; count++; if (prefix > (65535 - 256)/2) { prefix <<= 1; return ffinitvlcsparse(vlc, VLCBITS, count, bits, 1, 1, codes, 2, 2, symbols, 1, 1, 0);", "target": 1}
{"func": "static int cbsh265readnalunit(CodedBitstreamContext *ctx, CodedBitstreamUnit *unit) { BitstreamContext bc; int err; err = bitstreaminit(&bc, unit->data, 8 * unit->datasize); if (err < 0) return err; switch (unit->type) { case HEVCNALVPS: { H265RawVPS *vps; vps = avmallocz(sizeof(*vps)); if (!vps) return AVERROR(ENOMEM); err = cbsh265readvps(ctx, &bc, vps); if (err >= 0) err = cbsh265replacevps(ctx, vps); if (err < 0) { avfree(vps); return err; } unit->content = vps; } break; case HEVCNALSPS: { H265RawSPS *sps; sps = avmallocz(sizeof(*sps)); if (!sps) return AVERROR(ENOMEM); err = cbsh265readsps(ctx, &bc, sps); if (err >= 0) err = cbsh265replacesps(ctx, sps); if (err < 0) { avfree(sps); return err; } unit->content = sps; } break; case HEVCNALPPS: { H265RawPPS *pps; pps = avmallocz(sizeof(*pps)); if (!pps) return AVERROR(ENOMEM); err = cbsh265readpps(ctx, &bc, pps); if (err >= 0) err = cbsh265replacepps(ctx, pps); if (err < 0) { avfree(pps); return err; } unit->content = pps; } break; case HEVCNALTRAILN: case HEVCNALTRAILR: case HEVCNALTSAN: case HEVCNALTSAR: case HEVCNALSTSAN: case HEVCNALSTSAR: case HEVCNALRADLN: case HEVCNALRADLR: case HEVCNALRASLN: case HEVCNALRASLR: case HEVCNALBLAWLP: case HEVCNALBLAWRADL: case HEVCNALBLANLP: case HEVCNALIDRWRADL: case HEVCNALIDRNLP: case HEVCNALCRANUT: { H265RawSlice *slice; int pos, len; slice = avmallocz(sizeof(*slice)); if (!slice) return AVERROR(ENOMEM); err = cbsh265readslicesegmentheader(ctx, &bc, &slice->header); if (err < 0) { avfree(slice); return err; } pos = bitstreamtell(&bc); len = unit->datasize; if (!unit->data[len - 1]) { int z; for (z = 0; z < len && !unit->data[len - z - 1]; z++); avlog(ctx->logctx, AVLOGDEBUG, \"Deleted %d trailing zeroes \" \"from slice data.\\n\", z); len -= z; } slice->datasize = len - pos / 8; slice->data = avmalloc(slice->datasize); if (!slice->data) { avfree(slice); return AVERROR(ENOMEM); } memcpy(slice->data, unit->data + pos / 8, slice->datasize); slice->databitstart = pos % 8; unit->content = slice; } break; case HEVCNALAUD: { H265RawAUD *aud; aud = avmallocz(sizeof(*aud)); if (!aud) return AVERROR(ENOMEM); err = cbsh265readaud(ctx, &bc, aud); if (err < 0) { avfree(aud); return err; } unit->content = aud; } break; default: return AVERROR(ENOSYS); } return 0; } ", "target": 1}
{"func": "static void qpaaudiofini (void *opaque) { (void) opaque; } ", "target": 1}
{"func": "static void usbredirbulkpacket(void *priv, uint32t id, struct usbredirbulkpacketheader *bulkpacket, uint8t *data, int datalen) { USBRedirDevice *dev = priv; uint8t ep = bulkpacket->endpoint; int len = bulkpacket->length; AsyncURB *aurb; DPRINTF(\"bulk-in status %d ep %02X len %d id %u\\n\", bulkpacket->status, ep, len, id); aurb = asyncfind(dev, id); if (!aurb) { free(data); return; } if (aurb->bulkpacket.endpoint != bulkpacket->endpoint || aurb->bulkpacket.streamid != bulkpacket->streamid) { ERROR(\"return bulk packet mismatch, please report this!\\n\"); len = USBRETNAK; } if (aurb->packet) { len = usbredirhandlestatus(dev, bulkpacket->status, len); if (len > 0) { usbredirlogdata(dev, \"bulk data in:\", data, datalen); if (datalen <= aurb->packet->len) { memcpy(aurb->packet->data, data, datalen); } else { ERROR(\"bulk buffer too small (%d > %d)\\n\", datalen, aurb->packet->len); len = USBRETSTALL; } } aurb->packet->len = len; usbpacketcomplete(&dev->dev, aurb->packet); } asyncfree(dev, aurb); free(data); } ", "target": 1}
{"func": "static avcold int hevcinitcontext(AVCodecContext *avctx) { HEVCContext *s = avctx->privdata; int i; s->avctx = avctx; s->HEVClc = avmallocz(sizeof(HEVCLocalContext)); if (!s->HEVClc) goto fail; s->HEVClcList[0] = s->HEVClc; s->sList[0] = s; s->cabacstate = avmalloc(HEVCCONTEXTS); if (!s->cabacstate) goto fail; s->outputframe = avframealloc(); if (!s->outputframe) goto fail; for (i = 0; i < FFARRAYELEMS(s->DPB); i++) { s->DPB[i].frame = avframealloc(); if (!s->DPB[i].frame) goto fail; s->DPB[i].tf.f = s->DPB[i].frame; } s->maxra = INTMAX; s->md5ctx = avmd5alloc(); if (!s->md5ctx) goto fail; ffbswapdspinit(&s->bdsp); s->contextinitialized = 1; s->eos = 0; return 0; fail: hevcdecodefree(avctx); return AVERROR(ENOMEM); }", "target": 1}
{"func": "static int decodepltechunk(AVCodecContext *avctx, PNGDecContext *s, uint32t length) { int n, i, r, g, b; if ((length % 3) != 0 || length > 256 * 3) return AVERRORINVALIDDATA; /* read the palette */ n = length / 3; for (i = 0; i < n; i++) { r = bytestream2getbyte(&s->gb); g = bytestream2getbyte(&s->gb); b = bytestream2getbyte(&s->gb); s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b; } for (; i < 256; i++) s->palette[i] = (0xFFU << 24); s->state |= PNGPLTE; bytestream2skip(&s->gb, 4); /* crc */ return 0; } ", "target": 1}
{"func": "static MemTxResult vtdmemirwrite(void *opaque, hwaddr addr, uint64t value, unsigned size, MemTxAttrs attrs) { int ret = 0; MSIMessage from = {0}, to = {0}; from.address = (uint64t) addr + VTDINTERRUPTADDRFIRST; from.data = (uint32t) value; ret = vtdinterruptremapmsi(opaque, &from, &to); if (ret) { /* TODO: report error */ VTDDPRINTF(GENERAL, \"int remap fail for addr 0x%\"PRIx64 \" data 0x%\"PRIx32, from.address, from.data); /* Drop this interrupt */ return MEMTXERROR; } VTDDPRINTF(IR, \"delivering MSI 0x%\"PRIx64\":0x%\"PRIx32 \" for device sid 0x%04x\", to.address, to.data, sid); if (dmamemorywrite(&addressspacememory, to.address, &to.data, size)) { VTDDPRINTF(GENERAL, \"error: fail to write 0x%\"PRIx64 \" value 0x%\"PRIx32, to.address, to.data); } return MEMTXOK; } ", "target": 1}
{"func": "void stflushtracebuffer(void) { if (tracefileenabled) { flushtracefile(); } /* Discard written trace records */ traceidx = 0; } ", "target": 1}
{"func": "VirtIODevice *virtioblkinit(DeviceState *dev, BlockConf *conf, char **serial) { VirtIOBlock *s; int cylinders, heads, secs; static int virtioblkid; DriveInfo *dinfo; if (!conf->bs) { errorreport(\"virtio-blk-pci: drive property not set\"); return NULL; } if (!bdrvisinserted(conf->bs)) { errorreport(\"Device needs media, but drive is empty\"); return NULL; } if (!*serial) { /* try to fall back to value set with legacy -drive serial=... */ dinfo = drivegetbyblockdev(conf->bs); if (*dinfo->serial) { *serial = strdup(dinfo->serial); } } s = (VirtIOBlock *)virtiocommoninit(\"virtio-blk\", VIRTIOIDBLOCK, sizeof(struct virtioblkconfig), sizeof(VirtIOBlock)); s->vdev.getconfig = virtioblkupdateconfig; s->vdev.getfeatures = virtioblkgetfeatures; s->vdev.reset = virtioblkreset; s->bs = conf->bs; s->conf = conf; s->serial = *serial; s->rq = NULL; s->sectormask = (s->conf->logicalblocksize / BDRVSECTORSIZE) - 1; bdrvguessgeometry(s->bs, &cylinders, &heads, &secs); s->vq = virtioaddqueue(&s->vdev, 128, virtioblkhandleoutput); qemuaddvmchangestatehandler(virtioblkdmarestartcb, s); s->qdev = dev; registersavevm(dev, \"virtio-blk\", virtioblkid++, 2, virtioblksave, virtioblkload, s); bdrvsetdevops(s->bs, &virtioblockops, s); bdrvsetbufferalignment(s->bs, conf->logicalblocksize); bdrviostatusenable(s->bs); addbootdevicepath(conf->bootindex, dev, \"/disk@0,0\"); return &s->vdev; } ", "target": 0}
{"func": "static sizet headerextadd(char *buf, uint32t magic, const void *s, sizet len, sizet buflen) { QCowExtension *extbackingfmt = (QCowExtension*) buf; sizet extlen = sizeof(QCowExtension) + ((len + 7) & ~7); if (buflen < extlen) { return -ENOSPC; } *extbackingfmt = (QCowExtension) { .magic = cputobe32(magic), .len = cputobe32(len), }; memcpy(buf + sizeof(QCowExtension), s, len); return extlen; } ", "target": 1}
{"func": "static int movreadstrf(MOVContext *c, AVIOContext *pb, MOVAtom atom) { AVStream *st; if (c->fc->nbstreams < 1) return 0; if (atom.size <= 40) return 0; st = c->fc->streams[c->fc->nbstreams-1]; if ((uint64t)atom.size > (1<<30)) return AVERRORINVALIDDATA; avfree(st->codec->extradata); st->codec->extradata = avmallocz(atom.size - 40 + FFINPUTBUFFERPADDINGSIZE); if (!st->codec->extradata) return AVERROR(ENOMEM); st->codec->extradatasize = atom.size - 40; avioskip(pb, 40); avioread(pb, st->codec->extradata, atom.size - 40); return 0; } ", "target": 1}
{"func": "static void membegin(MemoryListener *listener) { AddressSpaceDispatch *d = containerof(listener, AddressSpaceDispatch, listener); d->physmap.ptr = PHYSMAPNODENIL; } ", "target": 0}
{"func": "static uint32t tightpalettebuf2rgb(int bpp, const uint8t *buf) { uint32t rgb = 0; if (bpp == 32) { rgb |= ((buf[0] & ~1) | !((buf[4] >> 3) & 1)) << 24; rgb |= ((buf[1] & ~1) | !((buf[4] >> 2) & 1)) << 16; rgb |= ((buf[2] & ~1) | !((buf[4] >> 1) & 1)) << 8; rgb |= ((buf[3] & ~1) | !((buf[4] >> 0) & 1)) << 0; } if (bpp == 16) { rgb |= ((buf[0] & ~1) | !((buf[2] >> 1) & 1)) << 8; rgb |= ((buf[1] & ~1) | !((buf[2] >> 0) & 1)) << 0; } return rgb; } ", "target": 0}
{"func": "int netinittap(const Netdev *netdev, const char *name, NetClientState *peer, Error **errp) { const NetdevTapOptions *tap; int fd, vnethdr = 0, i = 0, queues; /* for the no-fd, no-helper case */ const char *script = NULL; /* suppress wrong \"uninit'd use\" gcc warning */ const char *downscript = NULL; Error *err = NULL; const char *vhostfdname; char ifname[128]; assert(netdev->type == NETCLIENTDRIVERTAP); tap = &netdev->u.tap; queues = tap->hasqueues ? tap->queues : 1; vhostfdname = tap->hasvhostfd ? tap->vhostfd : NULL; /* QEMU vlans does not support multiqueue tap, in this case peer is set. * For -netdev, peer is always NULL. */ if (peer && (tap->hasqueues || tap->hasfds || tap->hasvhostfds)) { errorsetg(errp, \"Multiqueue tap cannot be used with QEMU vlans\"); return -1; } if (tap->hasfd) { if (tap->hasifname || tap->hasscript || tap->hasdownscript || tap->hasvnethdr || tap->hashelper || tap->hasqueues || tap->hasfds || tap->hasvhostfds) { errorsetg(errp, \"ifname=, script=, downscript=, vnethdr=, \" \"helper=, queues=, fds=, and vhostfds= \" \"are invalid with fd=\"); return -1; } fd = monitorfdparam(curmon, tap->fd, &err); if (fd == -1) { errorpropagate(errp, err); return -1; } fcntl(fd, FSETFL, ONONBLOCK); vnethdr = tapprobevnethdr(fd); netinittapone(tap, peer, \"tap\", name, NULL, script, downscript, vhostfdname, vnethdr, fd, &err); if (err) { errorpropagate(errp, err); return -1; } } else if (tap->hasfds) { char **fds = gnew0(char *, MAXTAPQUEUES); char **vhostfds = gnew0(char *, MAXTAPQUEUES); int nfds, nvhosts; if (tap->hasifname || tap->hasscript || tap->hasdownscript || tap->hasvnethdr || tap->hashelper || tap->hasqueues || tap->hasvhostfd) { errorsetg(errp, \"ifname=, script=, downscript=, vnethdr=, \" \"helper=, queues=, and vhostfd= \" \"are invalid with fds=\"); return -1; } nfds = getfds(tap->fds, fds, MAXTAPQUEUES); if (tap->hasvhostfds) { nvhosts = getfds(tap->vhostfds, vhostfds, MAXTAPQUEUES); if (nfds != nvhosts) { errorsetg(errp, \"The number of fds passed does not match \" \"the number of vhostfds passed\"); goto freefail; } } for (i = 0; i < nfds; i++) { fd = monitorfdparam(curmon, fds[i], &err); if (fd == -1) { errorpropagate(errp, err); goto freefail; } fcntl(fd, FSETFL, ONONBLOCK); if (i == 0) { vnethdr = tapprobevnethdr(fd); } else if (vnethdr != tapprobevnethdr(fd)) { errorsetg(errp, \"vnethdr not consistent across given tap fds\"); goto freefail; } netinittapone(tap, peer, \"tap\", name, ifname, script, downscript, tap->hasvhostfds ? vhostfds[i] : NULL, vnethdr, fd, &err); if (err) { errorpropagate(errp, err); goto freefail; } } gfree(fds); gfree(vhostfds); return 0; freefail: for (i = 0; i < nfds; i++) { gfree(fds[i]); gfree(vhostfds[i]); } gfree(fds); gfree(vhostfds); return -1; } else if (tap->hashelper) { if (tap->hasifname || tap->hasscript || tap->hasdownscript || tap->hasvnethdr || tap->hasqueues || tap->hasvhostfds) { errorsetg(errp, \"ifname=, script=, downscript=, vnethdr=, \" \"queues=, and vhostfds= are invalid with helper=\"); return -1; } fd = netbridgerunhelper(tap->helper, tap->hasbr ? tap->br : DEFAULTBRIDGEINTERFACE, errp); if (fd == -1) { return -1; } fcntl(fd, FSETFL, ONONBLOCK); vnethdr = tapprobevnethdr(fd); netinittapone(tap, peer, \"bridge\", name, ifname, script, downscript, vhostfdname, vnethdr, fd, &err); if (err) { errorpropagate(errp, err); close(fd); return -1; } } else { if (tap->hasvhostfds) { errorsetg(errp, \"vhostfds= is invalid if fds= wasn't specified\"); return -1; } script = tap->hasscript ? tap->script : DEFAULTNETWORKSCRIPT; downscript = tap->hasdownscript ? tap->downscript : DEFAULTNETWORKDOWNSCRIPT; if (tap->hasifname) { pstrcpy(ifname, sizeof ifname, tap->ifname); } else { ifname[0] = '\\0'; } for (i = 0; i < queues; i++) { fd = nettapinit(tap, &vnethdr, i >= 1 ? \"no\" : script, ifname, sizeof ifname, queues > 1, errp); if (fd == -1) { return -1; } if (queues > 1 && i == 0 && !tap->hasifname) { if (tapfdgetifname(fd, ifname)) { errorsetg(errp, \"Fail to get ifname\"); close(fd); return -1; } } netinittapone(tap, peer, \"tap\", name, ifname, i >= 1 ? \"no\" : script, i >= 1 ? \"no\" : downscript, vhostfdname, vnethdr, fd, &err); if (err) { errorpropagate(errp, err); close(fd); return -1; } } } return 0; } ", "target": 1}
{"func": "void streamstart(const char *jobid, BlockDriverState *bs, BlockDriverState *base, const char *backingfilestr, int64t speed, BlockdevOnError onerror, BlockCompletionFunc *cb, void *opaque, Error **errp) { StreamBlockJob *s; s = blockjobcreate(jobid, &streamjobdriver, bs, speed, cb, opaque, errp); if (!s) { return; } s->base = base; s->backingfilestr = gstrdup(backingfilestr); s->onerror = onerror; s->common.co = qemucoroutinecreate(streamrun); tracestreamstart(bs, base, s, s->common.co, opaque); qemucoroutineenter(s->common.co, s); } ", "target": 1}
{"func": "int attributealignarg avcodecdecodevideo2(AVCodecContext *avctx, AVFrame *picture, int *gotpictureptr, AVPacket *avpkt) { int ret; *gotpictureptr = 0; if ((avctx->codedwidth || avctx->codedheight) && avimagechecksize(avctx->codedwidth, avctx->codedheight, 0, avctx)) return -1; avctx->pkt = avpkt; applyparamchange(avctx, avpkt); if ((avctx->codec->capabilities & CODECCAPDELAY) || avpkt->size || (avctx->activethreadtype & FFTHREADFRAME)) { if (HAVETHREADS && avctx->activethreadtype & FFTHREADFRAME) ret = ffthreaddecodeframe(avctx, picture, gotpictureptr, avpkt); else { ret = avctx->codec->decode(avctx, picture, gotpictureptr, avpkt); picture->pktdts = avpkt->dts; picture->sampleaspectratio = avctx->sampleaspectratio; picture->width = avctx->width; picture->height = avctx->height; picture->format = avctx->pixfmt; } emmsc(); //needed to avoid an emmsc() call before every return; if (*gotpictureptr) avctx->framenumber++; } else ret = 0; /* many decoders assign whole AVFrames, thus overwriting extendeddata; * make sure it's set correctly */ picture->extendeddata = picture->data; return ret; }", "target": 1}
{"func": "static int omapgpioinit(SysBusDevice *sbd) { DeviceState *dev = DEVICE(sbd); struct omapgpifs *s = OMAP1GPIO(dev); if (!s->clk) { hwerror(\"omap-gpio: clk not connected\\n\"); } qdevinitgpioin(dev, omapgpioset, 16); qdevinitgpioout(dev, s->omap1.handler, 16); sysbusinitirq(sbd, &s->omap1.irq); memoryregioninitio(&s->iomem, OBJECT(s), &omapgpioops, &s->omap1, \"omap.gpio\", 0x1000); sysbusinitmmio(sbd, &s->iomem); return 0; } ", "target": 1}
{"func": "void omapmcbspi2sattach(struct omapmcbsps *s, I2SCodec *slave) { s->codec = slave; slave->rxswallow = qemuallocateirqs(omapmcbspi2sswallow, s, 1)[0]; slave->txstart = qemuallocateirqs(omapmcbspi2sstart, s, 1)[0]; } ", "target": 1}
{"func": "int floatx80eq(floatx80 a, floatx80 b, floatstatus *status) { if ( ( ( extractFloatx80Exp( a ) == 0x7FFF ) && (uint64t) ( extractFloatx80Frac( a )<<1 ) ) || ( ( extractFloatx80Exp( b ) == 0x7FFF ) && (uint64t) ( extractFloatx80Frac( b )<<1 ) ) ) { floatraise(floatflaginvalid, status); return 0; } return ( a.low == b.low ) && ( ( a.high == b.high ) || ( ( a.low == 0 ) && ( (uint16t) ( ( a.high | b.high )<<1 ) == 0 ) ) ); } ", "target": 0}
{"func": "void jsonlexerinit(JSONLexer *lexer, JSONLexerEmitter func) { lexer->emit = func; lexer->state = INSTART; lexer->token = qstringnew(); lexer->x = lexer->y = 0; } ", "target": 0}
{"func": "BlockDriverAIOCB *paiosubmit(BlockDriverState *bs, int fd, int64t sectornum, QEMUIOVector *qiov, int nbsectors, BlockDriverCompletionFunc *cb, void *opaque, int type) { struct qemupaiocb *acb; acb = qemuaioget(&rawaiopool, bs, cb, opaque); if (!acb) return NULL; acb->aiotype = type; acb->aiofildes = fd; acb->evsigno = SIGUSR2; acb->asynccontextid = getasynccontextid(); if (qiov) { acb->aioiov = qiov->iov; acb->aioniov = qiov->niov; } acb->aionbytes = nbsectors * 512; acb->aiooffset = sectornum * 512; acb->next = posixaiostate->firstaio; posixaiostate->firstaio = acb; tracepaiosubmit(acb, opaque, sectornum, nbsectors, type); qemupaiosubmit(acb); return &acb->common; } ", "target": 0}
{"func": "static int cryptoopen(URLContext *h, const char *uri, int flags) { const char *nestedurl; int ret; CryptoContext *c = h->privdata; if (!avstrstart(uri, \"crypto+\", &nestedurl) && !avstrstart(uri, \"crypto:\", &nestedurl)) { avlog(h, AVLOGERROR, \"Unsupported url %s\\n\", uri); ret = AVERROR(EINVAL); goto err; } if (c->keylen < BLOCKSIZE || c->ivlen < BLOCKSIZE) { avlog(h, AVLOGERROR, \"Key or IV not set\\n\"); ret = AVERROR(EINVAL); goto err; } if (flags & AVIOFLAGWRITE) { avlog(h, AVLOGERROR, \"Only decryption is supported currently\\n\"); ret = AVERROR(ENOSYS); goto err; } if ((ret = ffurlopen(&c->hd, nestedurl, AVIOFLAGREAD)) < 0) { avlog(h, AVLOGERROR, \"Unable to open input\\n\"); goto err; } c->aes = avmallocz(avaessize); if (!c->aes) { ret = AVERROR(ENOMEM); goto err; } avaesinit(c->aes, c->key, 128, 1); h->isstreamed = 1; return 0; err: avfree(c->key); avfree(c->iv); return ret; } ", "target": 1}
{"func": "int ffallocentries(AVCodecContext *avctx, int count) { int i; if (avctx->activethreadtype & FFTHREADSLICE) { SliceThreadContext *p = avctx->internal->threadctx; p->threadcount = avctx->threadcount; p->entries = avmalloczarray(count, sizeof(int)); if (!p->entries) { return AVERROR(ENOMEM); } p->entriescount = count; p->progressmutex = avmallocarray(p->threadcount, sizeof(pthreadmutext)); p->progresscond = avmallocarray(p->threadcount, sizeof(pthreadcondt)); for (i = 0; i < p->threadcount; i++) { pthreadmutexinit(&p->progressmutex[i], NULL); pthreadcondinit(&p->progresscond[i], NULL); } } return 0; } ", "target": 1}
{"func": "static int floppyprobedevice(const char *filename) { int fd, ret; int prio = 0; struct floppystruct fdparam; struct stat st; if (strstart(filename, \"/dev/fd\", NULL) && !strstart(filename, \"/dev/fdset/\", NULL)) { prio = 50; } fd = qemuopen(filename, ORDONLY | ONONBLOCK); if (fd < 0) { goto out; } ret = fstat(fd, &st); if (ret == -1 || !SISBLK(st.stmode)) { goto outc; } /* Attempt to detect via a floppy specific ioctl */ ret = ioctl(fd, FDGETPRM, &fdparam); if (ret >= 0) prio = 100; outc: qemuclose(fd); out: return prio; } ", "target": 1}
{"func": "static void sun4uvinit(ramaddrt RAMsize, const char *bootdevices, const char *kernelfilename, const char *kernelcmdline, const char *initrdfilename, const char *cpumodel, const struct hwdef *hwdef) { CPUState *env; char *filename; m48t59t *nvram; int ret, linuxboot; unsigned int i; ramaddrt ramoffset, promoffset; long initrdsize, kernelsize; PCIBus *pcibus, *pcibus2, *pcibus3; QEMUBH *bh; qemuirq *irq; int driveindex; BlockDriverState *hd[MAXIDEBUS * MAXIDEDEVS]; BlockDriverState *fd[MAXFD]; void *fwcfg; ResetData *resetinfo; linuxboot = (kernelfilename != NULL); /* init CPUs */ if (!cpumodel) cpumodel = hwdef->defaultcpumodel; env = cpuinit(cpumodel); if (!env) { fprintf(stderr, \"Unable to find Sparc CPU definition\\n\"); exit(1); } bh = qemubhnew(tickirq, env); env->tick = ptimerinit(bh); ptimersetperiod(env->tick, 1ULL); bh = qemubhnew(stickirq, env); env->stick = ptimerinit(bh); ptimersetperiod(env->stick, 1ULL); bh = qemubhnew(hstickirq, env); env->hstick = ptimerinit(bh); ptimersetperiod(env->hstick, 1ULL); resetinfo = qemumallocz(sizeof(ResetData)); resetinfo->env = env; resetinfo->resetaddr = hwdef->promaddr + 0x40ULL; qemuregisterreset(maincpureset, resetinfo); maincpureset(resetinfo); // Override warm reset address with cold start address env->pc = hwdef->promaddr + 0x20ULL; env->npc = env->pc + 4; /* allocate RAM */ ramoffset = qemuramalloc(RAMsize); cpuregisterphysicalmemory(0, RAMsize, ramoffset); promoffset = qemuramalloc(PROMSIZEMAX); cpuregisterphysicalmemory(hwdef->promaddr, (PROMSIZEMAX + TARGETPAGESIZE) & TARGETPAGEMASK, promoffset | IOMEMROM); if (biosname == NULL) biosname = PROMFILENAME; filename = qemufindfile(QEMUFILETYPEBIOS, biosname); if (filename) { ret = loadelf(filename, hwdef->promaddr - PROMVADDR, NULL, NULL, NULL); if (ret < 0) { ret = loadimagetargphys(filename, hwdef->promaddr, (PROMSIZEMAX + TARGETPAGESIZE) & TARGETPAGEMASK); } qemufree(filename); } else { ret = -1; } if (ret < 0) { fprintf(stderr, \"qemu: could not load prom '%s'\\n\", biosname); exit(1); } kernelsize = 0; initrdsize = 0; if (linuxboot) { /* XXX: put correct offset */ kernelsize = loadelf(kernelfilename, 0, NULL, NULL, NULL); if (kernelsize < 0) kernelsize = loadaout(kernelfilename, KERNELLOADADDR, ramsize - KERNELLOADADDR); if (kernelsize < 0) kernelsize = loadimagetargphys(kernelfilename, KERNELLOADADDR, ramsize - KERNELLOADADDR); if (kernelsize < 0) { fprintf(stderr, \"qemu: could not load kernel '%s'\\n\", kernelfilename); exit(1); } /* load initrd */ if (initrdfilename) { initrdsize = loadimagetargphys(initrdfilename, INITRDLOADADDR, ramsize - INITRDLOADADDR); if (initrdsize < 0) { fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\", initrdfilename); exit(1); } } if (initrdsize > 0) { for (i = 0; i < 64 * TARGETPAGESIZE; i += TARGETPAGESIZE) { if (ldlphys(KERNELLOADADDR + i) == 0x48647253) { // HdrS stlphys(KERNELLOADADDR + i + 16, INITRDLOADADDR); stlphys(KERNELLOADADDR + i + 20, initrdsize); break; } } } } pcibus = pciapbinit(APBSPECIALBASE, APBMEMBASE, NULL, &pcibus2, &pcibus3); isamembase = VGABASE; pcivgainit(pcibus, 0, 0); // XXX Should be pcibus3 pciebusinit(pcibus, -1); i = 0; if (hwdef->consoleserialbase) { serialmminit(hwdef->consoleserialbase, 0, NULL, 115200, serialhds[i], 1); i++; } for(; i < MAXSERIALPORTS; i++) { if (serialhds[i]) { serialinit(serialio[i], NULL/*serialirq[i]*/, 115200, serialhds[i]); } } for(i = 0; i < MAXPARALLELPORTS; i++) { if (parallelhds[i]) { parallelinit(parallelio[i], NULL/*parallelirq[i]*/, parallelhds[i]); } } for(i = 0; i < nbnics; i++) pcinicinit(&ndtable[i], \"ne2kpci\", NULL); irq = qemuallocateirqs(cpusetirq, env, MAXPILS); if (drivegetmaxbus(IFIDE) >= MAXIDEBUS) { fprintf(stderr, \"qemu: too many IDE bus\\n\"); exit(1); } for(i = 0; i < MAXIDEBUS * MAXIDEDEVS; i++) { driveindex = drivegetindex(IFIDE, i / MAXIDEDEVS, i % MAXIDEDEVS); if (driveindex != -1) hd[i] = drivestable[driveindex].bdrv; else hd[i] = NULL; } pcicmd646ideinit(pcibus, hd, 1); /* FIXME: wire up interrupts. */ i8042init(NULL/*1*/, NULL/*12*/, 0x60); for(i = 0; i < MAXFD; i++) { driveindex = drivegetindex(IFFLOPPY, 0, i); if (driveindex != -1) fd[i] = drivestable[driveindex].bdrv; else fd[i] = NULL; } floppycontroller = fdctrlinit(NULL/*6*/, 2, 0, 0x3f0, fd); nvram = m48t59init(NULL/*8*/, 0, 0x0074, NVRAMSIZE, 59); sun4uNVRAMsetparams(nvram, NVRAMSIZE, \"Sun4u\", RAMsize, bootdevices, KERNELLOADADDR, kernelsize, kernelcmdline, INITRDLOADADDR, initrdsize, /* XXX: need an option to load a NVRAM image */ 0, graphicwidth, graphicheight, graphicdepth, (uint8t *)&ndtable[0].macaddr); fwcfg = fwcfginit(BIOSCFGIOPORT, BIOSCFGIOPORT + 1, 0, 0); fwcfgaddi32(fwcfg, FWCFGID, 1); fwcfgaddi64(fwcfg, FWCFGRAMSIZE, (uint64t)ramsize); fwcfgaddi16(fwcfg, FWCFGMACHINEID, hwdef->machineid); fwcfgaddi32(fwcfg, FWCFGKERNELADDR, KERNELLOADADDR); fwcfgaddi32(fwcfg, FWCFGKERNELSIZE, kernelsize); if (kernelcmdline) { fwcfgaddi32(fwcfg, FWCFGKERNELCMDLINE, CMDLINEADDR); pstrcpytargphys(CMDLINEADDR, TARGETPAGESIZE, kernelcmdline); } else { fwcfgaddi32(fwcfg, FWCFGKERNELCMDLINE, 0); } fwcfgaddi32(fwcfg, FWCFGINITRDADDR, INITRDLOADADDR); fwcfgaddi32(fwcfg, FWCFGINITRDSIZE, initrdsize); fwcfgaddi16(fwcfg, FWCFGBOOTDEVICE, bootdevices[0]); qemuregisterbootset(fwcfgbootset, fwcfg); } ", "target": 0}
{"func": "static void fpuinit (CPUMIPSState *env, const mipsdeft *def) { int i; for (i = 0; i < MIPSFPUMAX; i++) env->fpus[i].fcr0 = def->CP1fcr0; memcpy(&env->activefpu, &env->fpus[0], sizeof(env->activefpu)); if (env->usermodeonly) { if (env->CP0Config1 & (1 << CP0C1FP)) env->hflags |= MIPSHFLAGFPU; #ifdef TARGETMIPS64 if (env->activefpu.fcr0 & (1 << FCR0F64)) env->hflags |= MIPSHFLAGF64; #endif } } ", "target": 0}
{"func": "static int bfidecodeframe(AVCodecContext *avctx, void *data, int *datasize, AVPacket *avpkt) { const uint8t *buf = avpkt->data, *bufend = avpkt->data + avpkt->size; int bufsize = avpkt->size; BFIContext *bfi = avctx->privdata; uint8t *dst = bfi->dst; uint8t *src, *dstoffset, colour1, colour2; uint8t *frameend = bfi->dst + avctx->width * avctx->height; uint32t *pal; int i, j, height = avctx->height; if (bfi->frame.data[0]) avctx->releasebuffer(avctx, &bfi->frame); bfi->frame.reference = 1; if (avctx->getbuffer(avctx, &bfi->frame) < 0) { avlog(avctx, AVLOGERROR, \"getbuffer() failed\\n\"); return -1; } /* Set frame parameters and palette, if necessary */ if (!avctx->framenumber) { bfi->frame.picttype = AVPICTURETYPEI; bfi->frame.keyframe = 1; /* Setting the palette */ if (avctx->extradatasize > 768) { avlog(NULL, AVLOGERROR, \"Palette is too large.\\n\"); return -1; } pal = (uint32t *)bfi->frame.data[1]; for (i = 0; i < avctx->extradatasize / 3; i++) { int shift = 16; *pal = 0; for (j = 0; j < 3; j++, shift -= 8) *pal += ((avctx->extradata[i * 3 + j] << 2) | (avctx->extradata[i * 3 + j] >> 4)) << shift; pal++; } bfi->frame.palettehaschanged = 1; } else { bfi->frame.picttype = AVPICTURETYPEP; bfi->frame.keyframe = 0; } buf += 4; // Unpacked size, not required. while (dst != frameend) { static const uint8t lentab[4] = { 0, 2, 0, 1 }; unsigned int byte = *buf++, avuninit(offset); unsigned int code = byte >> 6; unsigned int length = byte & ~0xC0; if (buf >= bufend) { avlog(avctx, AVLOGERROR, \"Input resolution larger than actual frame.\\n\"); return -1; } /* Get length and offset(if required) */ if (length == 0) { if (code == 1) { length = bytestreamgetbyte(&buf); offset = bytestreamgetle16(&buf); } else { length = bytestreamgetle16(&buf); if (code == 2 && length == 0) break; } } else { if (code == 1) offset = bytestreamgetbyte(&buf); } /* Do boundary check */ if (dst + (length << lentab[code]) > frameend) break; switch (code) { case 0: //Normal Chain if (length >= bufend - buf) { avlog(avctx, AVLOGERROR, \"Frame larger than buffer.\\n\"); return -1; } bytestreamgetbuffer(&buf, dst, length); dst += length; break; case 1: //Back Chain dstoffset = dst - offset; length *= 4; //Convert dwords to bytes. if (dstoffset < bfi->dst) break; while (length--) *dst++ = *dstoffset++; break; case 2: //Skip Chain dst += length; break; case 3: //Fill Chain colour1 = bytestreamgetbyte(&buf); colour2 = bytestreamgetbyte(&buf); while (length--) { *dst++ = colour1; *dst++ = colour2; } break; } } src = bfi->dst; dst = bfi->frame.data[0]; while (height--) { memcpy(dst, src, avctx->width); src += avctx->width; dst += bfi->frame.linesize[0]; } *datasize = sizeof(AVFrame); *(AVFrame *)data = bfi->frame; return bufsize; } ", "target": 1}
{"func": "DeviceState *qdevdeviceadd(QemuOpts *opts) { ObjectClass *oc; DeviceClass *dc; const char *driver, *path, *id; DeviceState *dev; BusState *bus = NULL; Error *err = NULL; driver = qemuoptget(opts, \"driver\"); if (!driver) { qerrorreport(QERRMISSINGPARAMETER, \"driver\"); return NULL; } /* find driver */ oc = objectclassbyname(driver); if (!oc) { const char *typename = findtypenamebyalias(driver); if (typename) { driver = typename; oc = objectclassbyname(driver); } } if (!objectclassdynamiccast(oc, TYPEDEVICE)) { qerrorreport(ERRORCLASSGENERICERROR, \"'%s' is not a valid device model name\", driver); return NULL; } if (objectclassisabstract(oc)) { qerrorreport(QERRINVALIDPARAMETERVALUE, \"driver\", \"non-abstract device type\"); return NULL; } dc = DEVICECLASS(oc); if (dc->cannotinstantiatewithdeviceaddyet) { qerrorreport(QERRINVALIDPARAMETERVALUE, \"driver\", \"pluggable device type\"); return NULL; } /* find bus */ path = qemuoptget(opts, \"bus\"); if (path != NULL) { bus = qbusfind(path); if (!bus) { return NULL; } if (!objectdynamiccast(OBJECT(bus), dc->bustype)) { qerrorreport(QERRBADBUSFORDEVICE, driver, objectgettypename(OBJECT(bus))); return NULL; } } else if (dc->bustype != NULL) { bus = qbusfindrecursive(sysbusgetdefault(), NULL, dc->bustype); if (!bus) { qerrorreport(QERRNOBUSFORDEVICE, dc->bustype, driver); return NULL; } } if (qdevhotplug && bus && !bus->allowhotplug) { qerrorreport(QERRBUSNOHOTPLUG, bus->name); return NULL; } /* create device, set properties */ dev = DEVICE(objectnew(driver)); if (bus) { qdevsetparentbus(dev, bus); } id = qemuoptsid(opts); if (id) { dev->id = id; } if (qemuoptforeach(opts, setproperty, dev, 1) != 0) { objectunparent(OBJECT(dev)); objectunref(OBJECT(dev)); return NULL; } if (dev->id) { objectpropertyaddchild(qdevgetperipheral(), dev->id, OBJECT(dev), NULL); } else { static int anoncount; gchar *name = gstrdupprintf(\"device[%d]\", anoncount++); objectpropertyaddchild(qdevgetperipheralanon(), name, OBJECT(dev), NULL); gfree(name); } dev->opts = opts; objectpropertysetbool(OBJECT(dev), true, \"realized\", &err); if (err != NULL) { qerrorreporterr(err); errorfree(err); dev->opts = NULL; objectunparent(OBJECT(dev)); objectunref(OBJECT(dev)); qerrorreport(QERRDEVICEINITFAILED, driver); return NULL; } return dev; } ", "target": 1}
{"func": "void threadpoolsubmit(ThreadPoolFunc *func, void *arg) { threadpoolsubmitaio(func, arg, NULL, NULL); } ", "target": 0}
{"func": "static void pl061registerdevices(void) { sysbusregisterdev(\"pl061\", sizeof(pl061state), pl061initarm); sysbusregisterdev(\"pl061luminary\", sizeof(pl061state), pl061initluminary); } ", "target": 0}
{"func": "int cpuexec(CPUState *cpu) { CPUClass *cc = CPUGETCLASS(cpu); int ret; SyncClocks sc; /* replayinterrupt may need currentcpu */ currentcpu = cpu; if (cpuhandlehalt(cpu)) { return EXCPHALTED; } rcureadlock(); cc->cpuexecenter(cpu); /* Calculate difference between guest clock and host clock. * This delay includes the delay of the last cycle, so * what we have to do is sleep until it is 0. As for the * advance/delay we gain here, we try to fix it next time. */ initdelayparams(&sc, cpu); /* prepare setjmp context for exception handling */ if (sigsetjmp(cpu->jmpenv, 0) != 0) { #if defined(clang) || !QEMUGNUCPREREQ(4, 6) /* Some compilers wrongly smash all local variables after * siglongjmp. There were bug reports for gcc 4.5.0 and clang. * Reload essential local variables here for those compilers. * Newer versions of gcc would complain about this code (-Wclobbered). */ cpu = currentcpu; cc = CPUGETCLASS(cpu); #else /* buggy compiler */ /* Assert that the compiler does not smash local variables. */ gassert(cpu == currentcpu); gassert(cc == CPUGETCLASS(cpu)); #endif /* buggy compiler */ cpu->candoio = 1; tblockreset(); if (qemumutexiothreadlocked()) { qemumutexunlockiothread(); } } /* if an exception is pending, we execute it here */ while (!cpuhandleexception(cpu, &ret)) { TranslationBlock *lasttb = NULL; int tbexit = 0; while (!cpuhandleinterrupt(cpu, &lasttb)) { TranslationBlock *tb = tbfind(cpu, lasttb, tbexit); cpuloopexectb(cpu, tb, &lasttb, &tbexit, &sc); /* Try to align the host and virtual clocks if the guest is in advance */ alignclocks(&sc, cpu); } } cc->cpuexecexit(cpu); rcureadunlock(); /* fail safe : never use currentcpu outside cpuexec() */ currentcpu = NULL; return ret; } ", "target": 1}
{"func": "static void copyirbtoguest(IRB *dest, const IRB *src, PMCW *pmcw) { int i; uint16t stctl = src->scsw.ctrl & SCSWCTRLMASKSTCTL; uint16t actl = src->scsw.ctrl & SCSWCTRLMASKACTL; copyscswtoguest(&dest->scsw, &src->scsw); for (i = 0; i < ARRAYSIZE(dest->esw); i++) { dest->esw[i] = cputobe32(src->esw[i]); } for (i = 0; i < ARRAYSIZE(dest->ecw); i++) { dest->ecw[i] = cputobe32(src->ecw[i]); } /* extended measurements enabled? */ if ((src->scsw.flags & SCSWFLAGSMASKESWF) || !(pmcw->flags & PMCWFLAGSMASKTF) || !(pmcw->chars & PMCWCHARSMASKXMWME)) { return; } /* extended measurements pending? */ if (!(stctl & SCSWSTCTLSTATUSPEND)) { return; } if ((stctl & SCSWSTCTLPRIMARY) || (stctl == SCSWSTCTLSECONDARY) || ((stctl & SCSWSTCTLINTERMEDIATE) && (actl & SCSWACTLSUSP))) { for (i = 0; i < ARRAYSIZE(dest->emw); i++) { dest->emw[i] = cputobe32(src->emw[i]); } } } ", "target": 0}
{"func": "static int processinputpacket(InputStream *ist, const AVPacket *pkt) { int i; int gotoutput; AVPacket avpkt; if (ist->nextdts == AVNOPTSVALUE) ist->nextdts = ist->lastdts; if (pkt == NULL) { /* EOF handling */ avinitpacket(&avpkt); avpkt.data = NULL; avpkt.size = 0; goto handleeof; } else { avpkt = *pkt; } if (pkt->dts != AVNOPTSVALUE) ist->nextdts = ist->lastdts = avrescaleq(pkt->dts, ist->st->timebase, AVTIMEBASEQ); // while we have more to decode or while the decoder did output something on EOF while (ist->decodingneeded && (avpkt.size > 0 || (!pkt && gotoutput))) { int ret = 0; handleeof: ist->lastdts = ist->nextdts; if (avpkt.size && avpkt.size != pkt->size && !(ist->dec->capabilities & CODECCAPSUBFRAMES)) { avlog(NULL, ist->showedmultipacketwarning ? AVLOGVERBOSE : AVLOGWARNING, \"Multiple frames in a packet from stream %d\\n\", pkt->streamindex); ist->showedmultipacketwarning = 1; } switch (ist->decctx->codectype) { case AVMEDIATYPEAUDIO: ret = decodeaudio (ist, &avpkt, &gotoutput); break; case AVMEDIATYPEVIDEO: ret = decodevideo (ist, &avpkt, &gotoutput); if (avpkt.duration) ist->nextdts += avrescaleq(avpkt.duration, ist->st->timebase, AVTIMEBASEQ); else if (ist->st->avgframerate.num) ist->nextdts += avrescaleq(1, avinvq(ist->st->avgframerate), AVTIMEBASEQ); else if (ist->decctx->timebase.num != 0) { int ticks = ist->st->parser ? ist->st->parser->repeatpict + 1 : ist->decctx->ticksperframe; ist->nextdts += avrescaleq(ticks, ist->decctx->timebase, AVTIMEBASEQ); } break; case AVMEDIATYPESUBTITLE: ret = transcodesubtitles(ist, &avpkt, &gotoutput); break; default: return -1; } if (ret < 0) return ret; // touch data and size only if not EOF if (pkt) { avpkt.data += ret; avpkt.size -= ret; } if (!gotoutput) { continue; } } /* handle stream copy */ if (!ist->decodingneeded) { ist->lastdts = ist->nextdts; switch (ist->decctx->codectype) { case AVMEDIATYPEAUDIO: ist->nextdts += ((int64t)AVTIMEBASE * ist->decctx->framesize) / ist->decctx->samplerate; break; case AVMEDIATYPEVIDEO: if (ist->decctx->timebase.num != 0) { int ticks = ist->st->parser ? ist->st->parser->repeatpict + 1 : ist->decctx->ticksperframe; ist->nextdts += ((int64t)AVTIMEBASE * ist->decctx->timebase.num * ticks) / ist->decctx->timebase.den; } break; } } for (i = 0; pkt && i < nboutputstreams; i++) { OutputStream *ost = outputstreams[i]; if (!checkoutputconstraints(ist, ost) || ost->encodingneeded) continue; dostreamcopy(ist, ost, pkt); } return 0; } ", "target": 0}
{"func": "static targetulong disasinsn(DisasContext *s, CPUState *cpu) { CPUX86State *env = cpu->envptr; int b, prefixes; int shift; TCGMemOp ot, aflag, dflag; int modrm, reg, rm, mod, op, opreg, val; targetulong nexteip, tval; int rexw, rexr; targetulong pcstart = s->base.pcnext; s->pcstart = s->pc = pcstart; prefixes = 0; s->override = -1; rexw = -1; rexr = 0; #ifdef TARGETX8664 s->rexx = 0; s->rexb = 0; x8664hregs = 0; #endif s->ripoffset = 0; /* for relative ip address */ s->vexl = 0; s->vexv = 0; if (sigsetjmp(s->jmpbuf, 0) != 0) { genexception(s, EXCP0DGPF, pcstart - s->csbase); return s->pc; } nextbyte: b = x86ldubcode(env, s); /* Collect prefixes. */ switch (b) { case 0xf3: prefixes |= PREFIXREPZ; goto nextbyte; case 0xf2: prefixes |= PREFIXREPNZ; goto nextbyte; case 0xf0: prefixes |= PREFIXLOCK; goto nextbyte; case 0x2e: s->override = RCS; goto nextbyte; case 0x36: s->override = RSS; goto nextbyte; case 0x3e: s->override = RDS; goto nextbyte; case 0x26: s->override = RES; goto nextbyte; case 0x64: s->override = RFS; goto nextbyte; case 0x65: s->override = RGS; goto nextbyte; case 0x66: prefixes |= PREFIXDATA; goto nextbyte; case 0x67: prefixes |= PREFIXADR; goto nextbyte; #ifdef TARGETX8664 case 0x40 ... 0x4f: if (CODE64(s)) { /* REX prefix */ rexw = (b >> 3) & 1; rexr = (b & 0x4) << 1; s->rexx = (b & 0x2) << 2; REXB(s) = (b & 0x1) << 3; x8664hregs = 1; /* select uniform byte register addressing */ goto nextbyte; } break; #endif case 0xc5: /* 2-byte VEX */ case 0xc4: /* 3-byte VEX */ /* VEX prefixes cannot be used except in 32-bit mode. Otherwise the instruction is LES or LDS. */ if (s->code32 && !s->vm86) { static const int ppprefix[4] = { 0, PREFIXDATA, PREFIXREPZ, PREFIXREPNZ }; int vex3, vex2 = x86ldubcode(env, s); if (!CODE64(s) && (vex2 & 0xc0) != 0xc0) { /* 4.1.4.6: In 32-bit mode, bits [7:6] must be 11b, otherwise the instruction is LES or LDS. */ break; } s->pc++; /* 4.1.1-4.1.3: No preceding lock, 66, f2, f3, or rex prefixes. */ if (prefixes & (PREFIXREPZ | PREFIXREPNZ | PREFIXLOCK | PREFIXDATA)) { goto illegalop; } #ifdef TARGETX8664 if (x8664hregs) { goto illegalop; } #endif rexr = (~vex2 >> 4) & 8; if (b == 0xc5) { vex3 = vex2; b = x86ldubcode(env, s); } else { #ifdef TARGETX8664 s->rexx = (~vex2 >> 3) & 8; s->rexb = (~vex2 >> 2) & 8; #endif vex3 = x86ldubcode(env, s); rexw = (vex3 >> 7) & 1; switch (vex2 & 0x1f) { case 0x01: /* Implied 0f leading opcode bytes. */ b = x86ldubcode(env, s) | 0x100; break; case 0x02: /* Implied 0f 38 leading opcode bytes. */ b = 0x138; break; case 0x03: /* Implied 0f 3a leading opcode bytes. */ b = 0x13a; break; default: /* Reserved for future use. */ goto unknownop; } } s->vexv = (~vex3 >> 3) & 0xf; s->vexl = (vex3 >> 2) & 1; prefixes |= ppprefix[vex3 & 3] | PREFIXVEX; } break; } /* Post-process prefixes. */ if (CODE64(s)) { /* In 64-bit mode, the default data size is 32-bit. Select 64-bit data with rexw, and 16-bit data with 0x66; rexw takes precedence over 0x66 if both are present. */ dflag = (rexw > 0 ? MO64 : prefixes & PREFIXDATA ? MO16 : MO32); /* In 64-bit mode, 0x67 selects 32-bit addressing. */ aflag = (prefixes & PREFIXADR ? MO32 : MO64); } else { /* In 16/32-bit mode, 0x66 selects the opposite data size. */ if (s->code32 ^ ((prefixes & PREFIXDATA) != 0)) { dflag = MO32; } else { dflag = MO16; } /* In 16/32-bit mode, 0x67 selects the opposite addressing. */ if (s->code32 ^ ((prefixes & PREFIXADR) != 0)) { aflag = MO32; } else { aflag = MO16; } } s->prefix = prefixes; s->aflag = aflag; s->dflag = dflag; /* now check op code */ reswitch: switch(b) { case 0x0f: /**************************/ /* extended op code */ b = x86ldubcode(env, s) | 0x100; goto reswitch; /**************************/ /* arith & logic */ case 0x00 ... 0x05: case 0x08 ... 0x0d: case 0x10 ... 0x15: case 0x18 ... 0x1d: case 0x20 ... 0x25: case 0x28 ... 0x2d: case 0x30 ... 0x35: case 0x38 ... 0x3d: { int op, f, val; op = (b >> 3) & 7; f = (b >> 1) & 3; ot = mobd(b, dflag); switch(f) { case 0: /* OP Ev, Gv */ modrm = x86ldubcode(env, s); reg = ((modrm >> 3) & 7) | rexr; mod = (modrm >> 6) & 3; rm = (modrm & 7) | REXB(s); if (mod != 3) { genleamodrm(env, s, modrm); opreg = ORTMP0; } else if (op == OPXORL && rm == reg) { xorzero: /* xor reg, reg optimisation */ setccop(s, CCOPCLR); tcggenmovitl(cpuT0, 0); genopmovregv(ot, reg, cpuT0); break; } else { opreg = rm; } genopmovvreg(ot, cpuT1, reg); genop(s, op, ot, opreg); break; case 1: /* OP Gv, Ev */ modrm = x86ldubcode(env, s); mod = (modrm >> 6) & 3; reg = ((modrm >> 3) & 7) | rexr; rm = (modrm & 7) | REXB(s); if (mod != 3) { genleamodrm(env, s, modrm); genopldv(s, ot, cpuT1, cpuA0); } else if (op == OPXORL && rm == reg) { goto xorzero; } else { genopmovvreg(ot, cpuT1, rm); } genop(s, op, ot, reg); break; case 2: /* OP A, Iv */ val = insnget(env, s, ot); tcggenmovitl(cpuT1, val); genop(s, op, ot, OREAX); break; } } break; case 0x82: if (CODE64(s)) goto illegalop; case 0x80: /* GRP1 */ case 0x81: case 0x83: { int val; ot = mobd(b, dflag); modrm = x86ldubcode(env, s); mod = (modrm >> 6) & 3; rm = (modrm & 7) | REXB(s); op = (modrm >> 3) & 7; if (mod != 3) { if (b == 0x83) s->ripoffset = 1; else s->ripoffset = insnconstsize(ot); genleamodrm(env, s, modrm); opreg = ORTMP0; } else { opreg = rm; } switch(b) { default: case 0x80: case 0x81: case 0x82: val = insnget(env, s, ot); break; case 0x83: val = (int8t)insnget(env, s, MO8); break; } tcggenmovitl(cpuT1, val); genop(s, op, ot, opreg); } break; /**************************/ /* inc, dec, and other misc arith */ case 0x40 ... 0x47: /* inc Gv */ ot = dflag; geninc(s, ot, OREAX + (b & 7), 1); break; case 0x48 ... 0x4f: /* dec Gv */ ot = dflag; geninc(s, ot, OREAX + (b & 7), -1); break; case 0xf6: /* GRP3 */ case 0xf7: ot = mobd(b, dflag); modrm = x86ldubcode(env, s); mod = (modrm >> 6) & 3; rm = (modrm & 7) | REXB(s); op = (modrm >> 3) & 7; if (mod != 3) { if (op == 0) { s->ripoffset = insnconstsize(ot); } genleamodrm(env, s, modrm); /* For those below that handle locked memory, don't load here. */ if (!(s->prefix & PREFIXLOCK) || op != 2) { genopldv(s, ot, cpuT0, cpuA0); } } else { genopmovvreg(ot, cpuT0, rm); } switch(op) { case 0: /* test */ val = insnget(env, s, ot); tcggenmovitl(cpuT1, val); genoptestlT0T1cc(); setccop(s, CCOPLOGICB + ot); break; case 2: /* not */ if (s->prefix & PREFIXLOCK) { if (mod == 3) { goto illegalop; } tcggenmovitl(cpuT0, ~0); tcggenatomicxorfetchtl(cpuT0, cpuA0, cpuT0, s->memindex, ot | MOLE); } else { tcggennottl(cpuT0, cpuT0); if (mod != 3) { genopstv(s, ot, cpuT0, cpuA0); } else { genopmovregv(ot, rm, cpuT0); } } break; case 3: /* neg */ if (s->prefix & PREFIXLOCK) { TCGLabel *label1; TCGv a0, t0, t1, t2; if (mod == 3) { goto illegalop; } a0 = tcgtemplocalnew(); t0 = tcgtemplocalnew(); label1 = gennewlabel(); tcggenmovtl(a0, cpuA0); tcggenmovtl(t0, cpuT0); gensetlabel(label1); t1 = tcgtempnew(); t2 = tcgtempnew(); tcggenmovtl(t2, t0); tcggennegtl(t1, t0); tcggenatomiccmpxchgtl(t0, a0, t0, t1, s->memindex, ot | MOLE); tcgtempfree(t1); tcggenbrcondtl(TCGCONDNE, t0, t2, label1); tcgtempfree(t2); tcgtempfree(a0); tcggenmovtl(cpuT0, t0); tcgtempfree(t0); } else { tcggennegtl(cpuT0, cpuT0); if (mod != 3) { genopstv(s, ot, cpuT0, cpuA0); } else { genopmovregv(ot, rm, cpuT0); } } genopupdatenegcc(); setccop(s, CCOPSUBB + ot); break; case 4: /* mul */ switch(ot) { case MO8: genopmovvreg(MO8, cpuT1, REAX); tcggenext8utl(cpuT0, cpuT0); tcggenext8utl(cpuT1, cpuT1); /* XXX: use 32 bit mul which could be faster */ tcggenmultl(cpuT0, cpuT0, cpuT1); genopmovregv(MO16, REAX, cpuT0); tcggenmovtl(cpuccdst, cpuT0); tcggenanditl(cpuccsrc, cpuT0, 0xff00); setccop(s, CCOPMULB); break; case MO16: genopmovvreg(MO16, cpuT1, REAX); tcggenext16utl(cpuT0, cpuT0); tcggenext16utl(cpuT1, cpuT1); /* XXX: use 32 bit mul which could be faster */ tcggenmultl(cpuT0, cpuT0, cpuT1); genopmovregv(MO16, REAX, cpuT0); tcggenmovtl(cpuccdst, cpuT0); tcggenshritl(cpuT0, cpuT0, 16); genopmovregv(MO16, REDX, cpuT0); tcggenmovtl(cpuccsrc, cpuT0); setccop(s, CCOPMULW); break; default: case MO32: tcggentrunctli32(cputmp2i32, cpuT0); tcggentrunctli32(cputmp3i32, cpuregs[REAX]); tcggenmulu2i32(cputmp2i32, cputmp3i32, cputmp2i32, cputmp3i32); tcggenextui32tl(cpuregs[REAX], cputmp2i32); tcggenextui32tl(cpuregs[REDX], cputmp3i32); tcggenmovtl(cpuccdst, cpuregs[REAX]); tcggenmovtl(cpuccsrc, cpuregs[REDX]); setccop(s, CCOPMULL); break; #ifdef TARGETX8664 case MO64: tcggenmulu2i64(cpuregs[REAX], cpuregs[REDX], cpuT0, cpuregs[REAX]); tcggenmovtl(cpuccdst, cpuregs[REAX]); tcggenmovtl(cpuccsrc, cpuregs[REDX]); setccop(s, CCOPMULQ); break; #endif } break; case 5: /* imul */ switch(ot) { case MO8: genopmovvreg(MO8, cpuT1, REAX); tcggenext8stl(cpuT0, cpuT0); tcggenext8stl(cpuT1, cpuT1); /* XXX: use 32 bit mul which could be faster */ tcggenmultl(cpuT0, cpuT0, cpuT1); genopmovregv(MO16, REAX, cpuT0); tcggenmovtl(cpuccdst, cpuT0); tcggenext8stl(cputmp0, cpuT0); tcggensubtl(cpuccsrc, cpuT0, cputmp0); setccop(s, CCOPMULB); break; case MO16: genopmovvreg(MO16, cpuT1, REAX); tcggenext16stl(cpuT0, cpuT0); tcggenext16stl(cpuT1, cpuT1); /* XXX: use 32 bit mul which could be faster */ tcggenmultl(cpuT0, cpuT0, cpuT1); genopmovregv(MO16, REAX, cpuT0); tcggenmovtl(cpuccdst, cpuT0); tcggenext16stl(cputmp0, cpuT0); tcggensubtl(cpuccsrc, cpuT0, cputmp0); tcggenshritl(cpuT0, cpuT0, 16); genopmovregv(MO16, REDX, cpuT0); setccop(s, CCOPMULW); break; default: case MO32: tcggentrunctli32(cputmp2i32, cpuT0); tcggentrunctli32(cputmp3i32, cpuregs[REAX]); tcggenmuls2i32(cputmp2i32, cputmp3i32, cputmp2i32, cputmp3i32); tcggenextui32tl(cpuregs[REAX], cputmp2i32); tcggenextui32tl(cpuregs[REDX], cputmp3i32); tcggensarii32(cputmp2i32, cputmp2i32, 31); tcggenmovtl(cpuccdst, cpuregs[REAX]); tcggensubi32(cputmp2i32, cputmp2i32, cputmp3i32); tcggenextui32tl(cpuccsrc, cputmp2i32); setccop(s, CCOPMULL); break; #ifdef TARGETX8664 case MO64: tcggenmuls2i64(cpuregs[REAX], cpuregs[REDX], cpuT0, cpuregs[REAX]); tcggenmovtl(cpuccdst, cpuregs[REAX]); tcggensaritl(cpuccsrc, cpuregs[REAX], 63); tcggensubtl(cpuccsrc, cpuccsrc, cpuregs[REDX]); setccop(s, CCOPMULQ); break; #endif } break; case 6: /* div */ switch(ot) { case MO8: genhelperdivbAL(cpuenv, cpuT0); break; case MO16: genhelperdivwAX(cpuenv, cpuT0); break; default: case MO32: genhelperdivlEAX(cpuenv, cpuT0); break; #ifdef TARGETX8664 case MO64: genhelperdivqEAX(cpuenv, cpuT0); break; #endif } break; case 7: /* idiv */ switch(ot) { case MO8: genhelperidivbAL(cpuenv, cpuT0); break; case MO16: genhelperidivwAX(cpuenv, cpuT0); break; default: case MO32: genhelperidivlEAX(cpuenv, cpuT0); break; #ifdef TARGETX8664 case MO64: genhelperidivqEAX(cpuenv, cpuT0); break; #endif } break; default: goto unknownop; } break; case 0xfe: /* GRP4 */ case 0xff: /* GRP5 */ ot = mobd(b, dflag); modrm = x86ldubcode(env, s); mod = (modrm >> 6) & 3; rm = (modrm & 7) | REXB(s); op = (modrm >> 3) & 7; if (op >= 2 && b == 0xfe) { goto unknownop; } if (CODE64(s)) { if (op == 2 || op == 4) { /* operand size for jumps is 64 bit */ ot = MO64; } else if (op == 3 || op == 5) { ot = dflag != MO16 ? MO32 + (rexw == 1) : MO16; } else if (op == 6) { /* default push size is 64 bit */ ot = mopushpop(s, dflag); } } if (mod != 3) { genleamodrm(env, s, modrm); if (op >= 2 && op != 3 && op != 5) genopldv(s, ot, cpuT0, cpuA0); } else { genopmovvreg(ot, cpuT0, rm); } switch(op) { case 0: /* inc Ev */ if (mod != 3) opreg = ORTMP0; else opreg = rm; geninc(s, ot, opreg, 1); break; case 1: /* dec Ev */ if (mod != 3) opreg = ORTMP0; else opreg = rm; geninc(s, ot, opreg, -1); break; case 2: /* call Ev */ /* XXX: optimize if memory (no 'and' is necessary) */ if (dflag == MO16) { tcggenext16utl(cpuT0, cpuT0); } nexteip = s->pc - s->csbase; tcggenmovitl(cpuT1, nexteip); genpushv(s, cpuT1); genopjmpv(cpuT0); genbndjmp(s); genjr(s, cpuT0); break; case 3: /* lcall Ev */ genopldv(s, ot, cpuT1, cpuA0); genaddA0im(s, 1 << ot); genopldv(s, MO16, cpuT0, cpuA0); dolcall: if (s->pe && !s->vm86) { tcggentrunctli32(cputmp2i32, cpuT0); genhelperlcallprotected(cpuenv, cputmp2i32, cpuT1, tcgconsti32(dflag - 1), tcgconsttl(s->pc - s->csbase)); } else { tcggentrunctli32(cputmp2i32, cpuT0); genhelperlcallreal(cpuenv, cputmp2i32, cpuT1, tcgconsti32(dflag - 1), tcgconsti32(s->pc - s->csbase)); } tcggenldtl(cputmp4, cpuenv, offsetof(CPUX86State, eip)); genjr(s, cputmp4); break; case 4: /* jmp Ev */ if (dflag == MO16) { tcggenext16utl(cpuT0, cpuT0); } genopjmpv(cpuT0); genbndjmp(s); genjr(s, cpuT0); break; case 5: /* ljmp Ev */ genopldv(s, ot, cpuT1, cpuA0); genaddA0im(s, 1 << ot); genopldv(s, MO16, cpuT0, cpuA0); doljmp: if (s->pe && !s->vm86) { tcggentrunctli32(cputmp2i32, cpuT0); genhelperljmpprotected(cpuenv, cputmp2i32, cpuT1, tcgconsttl(s->pc - s->csbase)); } else { genopmovlsegT0vm(RCS); genopjmpv(cpuT1); } tcggenldtl(cputmp4, cpuenv, offsetof(CPUX86State, eip)); genjr(s, cputmp4); break; case 6: /* push Ev */ genpushv(s, cpuT0); break; default: goto unknownop; } break; case 0x84: /* test Ev, Gv */ case 0x85: ot = mobd(b, dflag); modrm = x86ldubcode(env, s); reg = ((modrm >> 3) & 7) | rexr; genldstmodrm(env, s, modrm, ot, ORTMP0, 0); genopmovvreg(ot, cpuT1, reg); genoptestlT0T1cc(); setccop(s, CCOPLOGICB + ot); break; case 0xa8: /* test eAX, Iv */ case 0xa9: ot = mobd(b, dflag); val = insnget(env, s, ot); genopmovvreg(ot, cpuT0, OREAX); tcggenmovitl(cpuT1, val); genoptestlT0T1cc(); setccop(s, CCOPLOGICB + ot); break; case 0x98: /* CWDE/CBW */ switch (dflag) { #ifdef TARGETX8664 case MO64: genopmovvreg(MO32, cpuT0, REAX); tcggenext32stl(cpuT0, cpuT0); genopmovregv(MO64, REAX, cpuT0); break; #endif case MO32: genopmovvreg(MO16, cpuT0, REAX); tcggenext16stl(cpuT0, cpuT0); genopmovregv(MO32, REAX, cpuT0); break; case MO16: genopmovvreg(MO8, cpuT0, REAX); tcggenext8stl(cpuT0, cpuT0); genopmovregv(MO16, REAX, cpuT0); break; default: tcgabort(); } break; case 0x99: /* CDQ/CWD */ switch (dflag) { #ifdef TARGETX8664 case MO64: genopmovvreg(MO64, cpuT0, REAX); tcggensaritl(cpuT0, cpuT0, 63); genopmovregv(MO64, REDX, cpuT0); break; #endif case MO32: genopmovvreg(MO32, cpuT0, REAX); tcggenext32stl(cpuT0, cpuT0); tcggensaritl(cpuT0, cpuT0, 31); genopmovregv(MO32, REDX, cpuT0); break; case MO16: genopmovvreg(MO16, cpuT0, REAX); tcggenext16stl(cpuT0, cpuT0); tcggensaritl(cpuT0, cpuT0, 15); genopmovregv(MO16, REDX, cpuT0); break; default: tcgabort(); } break; case 0x1af: /* imul Gv, Ev */ case 0x69: /* imul Gv, Ev, I */ case 0x6b: ot = dflag; modrm = x86ldubcode(env, s); reg = ((modrm >> 3) & 7) | rexr; if (b == 0x69) s->ripoffset = insnconstsize(ot); else if (b == 0x6b) s->ripoffset = 1; genldstmodrm(env, s, modrm, ot, ORTMP0, 0); if (b == 0x69) { val = insnget(env, s, ot); tcggenmovitl(cpuT1, val); } else if (b == 0x6b) { val = (int8t)insnget(env, s, MO8); tcggenmovitl(cpuT1, val); } else { genopmovvreg(ot, cpuT1, reg); } switch (ot) { #ifdef TARGETX8664 case MO64: tcggenmuls2i64(cpuregs[reg], cpuT1, cpuT0, cpuT1); tcggenmovtl(cpuccdst, cpuregs[reg]); tcggensaritl(cpuccsrc, cpuccdst, 63); tcggensubtl(cpuccsrc, cpuccsrc, cpuT1); break; #endif case MO32: tcggentrunctli32(cputmp2i32, cpuT0); tcggentrunctli32(cputmp3i32, cpuT1); tcggenmuls2i32(cputmp2i32, cputmp3i32, cputmp2i32, cputmp3i32); tcggenextui32tl(cpuregs[reg], cputmp2i32); tcggensarii32(cputmp2i32, cputmp2i32, 31); tcggenmovtl(cpuccdst, cpuregs[reg]); tcggensubi32(cputmp2i32, cputmp2i32, cputmp3i32); tcggenextui32tl(cpuccsrc, cputmp2i32); break; default: tcggenext16stl(cpuT0, cpuT0); tcggenext16stl(cpuT1, cpuT1); /* XXX: use 32 bit mul which could be faster */ tcggenmultl(cpuT0, cpuT0, cpuT1); tcggenmovtl(cpuccdst, cpuT0); tcggenext16stl(cputmp0, cpuT0); tcggensubtl(cpuccsrc, cpuT0, cputmp0); genopmovregv(ot, reg, cpuT0); break; } setccop(s, CCOPMULB + ot); break; case 0x1c0: case 0x1c1: /* xadd Ev, Gv */ ot = mobd(b, dflag); modrm = x86ldubcode(env, s); reg = ((modrm >> 3) & 7) | rexr; mod = (modrm >> 6) & 3; genopmovvreg(ot, cpuT0, reg); if (mod == 3) { rm = (modrm & 7) | REXB(s); genopmovvreg(ot, cpuT1, rm); tcggenaddtl(cpuT0, cpuT0, cpuT1); genopmovregv(ot, reg, cpuT1); genopmovregv(ot, rm, cpuT0); } else { genleamodrm(env, s, modrm); if (s->prefix & PREFIXLOCK) { tcggenatomicfetchaddtl(cpuT1, cpuA0, cpuT0, s->memindex, ot | MOLE); tcggenaddtl(cpuT0, cpuT0, cpuT1); } else { genopldv(s, ot, cpuT1, cpuA0); tcggenaddtl(cpuT0, cpuT0, cpuT1); genopstv(s, ot, cpuT0, cpuA0); } genopmovregv(ot, reg, cpuT1); } genopupdate2cc(); setccop(s, CCOPADDB + ot); break; case 0x1b0: case 0x1b1: /* cmpxchg Ev, Gv */ { TCGv oldv, newv, cmpv; ot = mobd(b, dflag); modrm = x86ldubcode(env, s); reg = ((modrm >> 3) & 7) | rexr; mod = (modrm >> 6) & 3; oldv = tcgtempnew(); newv = tcgtempnew(); cmpv = tcgtempnew(); genopmovvreg(ot, newv, reg); tcggenmovtl(cmpv, cpuregs[REAX]); if (s->prefix & PREFIXLOCK) { if (mod == 3) { goto illegalop; } genleamodrm(env, s, modrm); tcggenatomiccmpxchgtl(oldv, cpuA0, cmpv, newv, s->memindex, ot | MOLE); genopmovregv(ot, REAX, oldv); } else { if (mod == 3) { rm = (modrm & 7) | REXB(s); genopmovvreg(ot, oldv, rm); } else { genleamodrm(env, s, modrm); genopldv(s, ot, oldv, cpuA0); rm = 0; /* avoid warning */ } genextu(ot, oldv); genextu(ot, cmpv); /* store value = (old == cmp ? new : old); */ tcggenmovcondtl(TCGCONDEQ, newv, oldv, cmpv, newv, oldv); if (mod == 3) { genopmovregv(ot, REAX, oldv); genopmovregv(ot, rm, newv); } else { /* Perform an unconditional store cycle like physical cpu; must be before changing accumulator to ensure idempotency if the store faults and the instruction is restarted */ genopstv(s, ot, newv, cpuA0); genopmovregv(ot, REAX, oldv); } } tcggenmovtl(cpuccsrc, oldv); tcggenmovtl(cpuccsrcT, cmpv); tcggensubtl(cpuccdst, cmpv, oldv); setccop(s, CCOPSUBB + ot); tcgtempfree(oldv); tcgtempfree(newv); tcgtempfree(cmpv); } break; case 0x1c7: /* cmpxchg8b */ modrm = x86ldubcode(env, s); mod = (modrm >> 6) & 3; if ((mod == 3) || ((modrm & 0x38) != 0x8)) goto illegalop; #ifdef TARGETX8664 if (dflag == MO64) { if (!(s->cpuidextfeatures & CPUIDEXTCX16)) goto illegalop; genleamodrm(env, s, modrm); if ((s->prefix & PREFIXLOCK) && parallelcpus) { genhelpercmpxchg16b(cpuenv, cpuA0); } else { genhelpercmpxchg16bunlocked(cpuenv, cpuA0); } } else #endif { if (!(s->cpuidfeatures & CPUIDCX8)) goto illegalop; genleamodrm(env, s, modrm); if ((s->prefix & PREFIXLOCK) && parallelcpus) { genhelpercmpxchg8b(cpuenv, cpuA0); } else { genhelpercmpxchg8bunlocked(cpuenv, cpuA0); } } setccop(s, CCOPEFLAGS); break; /**************************/ /* push/pop */ case 0x50 ... 0x57: /* push */ genopmovvreg(MO32, cpuT0, (b & 7) | REXB(s)); genpushv(s, cpuT0); break; case 0x58 ... 0x5f: /* pop */ ot = genpopT0(s); /* NOTE: order is important for pop %sp */ genpopupdate(s, ot); genopmovregv(ot, (b & 7) | REXB(s), cpuT0); break; case 0x60: /* pusha */ if (CODE64(s)) goto illegalop; genpusha(s); break; case 0x61: /* popa */ if (CODE64(s)) goto illegalop; genpopa(s); break; case 0x68: /* push Iv */ case 0x6a: ot = mopushpop(s, dflag); if (b == 0x68) val = insnget(env, s, ot); else val = (int8t)insnget(env, s, MO8); tcggenmovitl(cpuT0, val); genpushv(s, cpuT0); break; case 0x8f: /* pop Ev */ modrm = x86ldubcode(env, s); mod = (modrm >> 6) & 3; ot = genpopT0(s); if (mod == 3) { /* NOTE: order is important for pop %sp */ genpopupdate(s, ot); rm = (modrm & 7) | REXB(s); genopmovregv(ot, rm, cpuT0); } else { /* NOTE: order is important too for MMU exceptions */ s->poplesphack = 1 << ot; genldstmodrm(env, s, modrm, ot, ORTMP0, 1); s->poplesphack = 0; genpopupdate(s, ot); } break; case 0xc8: /* enter */ { int level; val = x86lduwcode(env, s); level = x86ldubcode(env, s); genenter(s, val, level); } break; case 0xc9: /* leave */ genleave(s); break; case 0x06: /* push es */ case 0x0e: /* push cs */ case 0x16: /* push ss */ case 0x1e: /* push ds */ if (CODE64(s)) goto illegalop; genopmovlT0seg(b >> 3); genpushv(s, cpuT0); break; case 0x1a0: /* push fs */ case 0x1a8: /* push gs */ genopmovlT0seg((b >> 3) & 7); genpushv(s, cpuT0); break; case 0x07: /* pop es */ case 0x17: /* pop ss */ case 0x1f: /* pop ds */ if (CODE64(s)) goto illegalop; reg = b >> 3; ot = genpopT0(s); genmovlsegT0(s, reg); genpopupdate(s, ot); /* Note that reg == RSS in genmovlsegT0 always sets isjmp. */ if (s->base.isjmp) { genjmpim(s->pc - s->csbase); if (reg == RSS) { s->tf = 0; geneobinhibitirq(s, true); } else { geneob(s); } } break; case 0x1a1: /* pop fs */ case 0x1a9: /* pop gs */ ot = genpopT0(s); genmovlsegT0(s, (b >> 3) & 7); genpopupdate(s, ot); if (s->base.isjmp) { genjmpim(s->pc - s->csbase); geneob(s); } break; /**************************/ /* mov */ case 0x88: case 0x89: /* mov Gv, Ev */ ot = mobd(b, dflag); modrm = x86ldubcode(env, s); reg = ((modrm >> 3) & 7) | rexr; /* generate a generic store */ genldstmodrm(env, s, modrm, ot, reg, 1); break; case 0xc6: case 0xc7: /* mov Ev, Iv */ ot = mobd(b, dflag); modrm = x86ldubcode(env, s); mod = (modrm >> 6) & 3; if (mod != 3) { s->ripoffset = insnconstsize(ot); genleamodrm(env, s, modrm); } val = insnget(env, s, ot); tcggenmovitl(cpuT0, val); if (mod != 3) { genopstv(s, ot, cpuT0, cpuA0); } else { genopmovregv(ot, (modrm & 7) | REXB(s), cpuT0); } break; case 0x8a: case 0x8b: /* mov Ev, Gv */ ot = mobd(b, dflag); modrm = x86ldubcode(env, s); reg = ((modrm >> 3) & 7) | rexr; genldstmodrm(env, s, modrm, ot, ORTMP0, 0); genopmovregv(ot, reg, cpuT0); break; case 0x8e: /* mov seg, Gv */ modrm = x86ldubcode(env, s); reg = (modrm >> 3) & 7; if (reg >= 6 || reg == RCS) goto illegalop; genldstmodrm(env, s, modrm, MO16, ORTMP0, 0); genmovlsegT0(s, reg); /* Note that reg == RSS in genmovlsegT0 always sets isjmp. */ if (s->base.isjmp) { genjmpim(s->pc - s->csbase); if (reg == RSS) { s->tf = 0; geneobinhibitirq(s, true); } else { geneob(s); } } break; case 0x8c: /* mov Gv, seg */ modrm = x86ldubcode(env, s); reg = (modrm >> 3) & 7; mod = (modrm >> 6) & 3; if (reg >= 6) goto illegalop; genopmovlT0seg(reg); ot = mod == 3 ? dflag : MO16; genldstmodrm(env, s, modrm, ot, ORTMP0, 1); break; case 0x1b6: /* movzbS Gv, Eb */ case 0x1b7: /* movzwS Gv, Eb */ case 0x1be: /* movsbS Gv, Eb */ case 0x1bf: /* movswS Gv, Eb */ { TCGMemOp dot; TCGMemOp sot; /* dot is the size of destination */ dot = dflag; /* ot is the size of source */ ot = (b & 1) + MO8; /* sot is the sign+size of source */ sot = b & 8 ? MOSIGN | ot : ot; modrm = x86ldubcode(env, s); reg = ((modrm >> 3) & 7) | rexr; mod = (modrm >> 6) & 3; rm = (modrm & 7) | REXB(s); if (mod == 3) { if (sot == MOSB && byteregisxH(rm)) { tcggensextracttl(cpuT0, cpuregs[rm - 4], 8, 8); } else { genopmovvreg(ot, cpuT0, rm); switch (sot) { case MOUB: tcggenext8utl(cpuT0, cpuT0); break; case MOSB: tcggenext8stl(cpuT0, cpuT0); break; case MOUW: tcggenext16utl(cpuT0, cpuT0); break; default: case MOSW: tcggenext16stl(cpuT0, cpuT0); break; } } genopmovregv(dot, reg, cpuT0); } else { genleamodrm(env, s, modrm); genopldv(s, sot, cpuT0, cpuA0); genopmovregv(dot, reg, cpuT0); } } break; case 0x8d: /* lea */ modrm = x86ldubcode(env, s); mod = (modrm >> 6) & 3; if (mod == 3) goto illegalop; reg = ((modrm >> 3) & 7) | rexr; { AddressParts a = genleamodrm0(env, s, modrm); TCGv ea = genleamodrm1(a); genleavseg(s, s->aflag, ea, -1, -1); genopmovregv(dflag, reg, cpuA0); } break; case 0xa0: /* mov EAX, Ov */ case 0xa1: case 0xa2: /* mov Ov, EAX */ case 0xa3: { targetulong offsetaddr; ot = mobd(b, dflag); switch (s->aflag) { #ifdef TARGETX8664 case MO64: offsetaddr = x86ldqcode(env, s); break; #endif default: offsetaddr = insnget(env, s, s->aflag); break; } tcggenmovitl(cpuA0, offsetaddr); genaddA0dsseg(s); if ((b & 2) == 0) { genopldv(s, ot, cpuT0, cpuA0); genopmovregv(ot, REAX, cpuT0); } else { genopmovvreg(ot, cpuT0, REAX); genopstv(s, ot, cpuT0, cpuA0); } } break; case 0xd7: /* xlat */ tcggenmovtl(cpuA0, cpuregs[REBX]); tcggenext8utl(cpuT0, cpuregs[REAX]); tcggenaddtl(cpuA0, cpuA0, cpuT0); genextu(s->aflag, cpuA0); genaddA0dsseg(s); genopldv(s, MO8, cpuT0, cpuA0); genopmovregv(MO8, REAX, cpuT0); break; case 0xb0 ... 0xb7: /* mov R, Ib */ val = insnget(env, s, MO8); tcggenmovitl(cpuT0, val); genopmovregv(MO8, (b & 7) | REXB(s), cpuT0); break; case 0xb8 ... 0xbf: /* mov R, Iv */ #ifdef TARGETX8664 if (dflag == MO64) { uint64t tmp; /* 64 bit case */ tmp = x86ldqcode(env, s); reg = (b & 7) | REXB(s); tcggenmovitl(cpuT0, tmp); genopmovregv(MO64, reg, cpuT0); } else #endif { ot = dflag; val = insnget(env, s, ot); reg = (b & 7) | REXB(s); tcggenmovitl(cpuT0, val); genopmovregv(ot, reg, cpuT0); } break; case 0x91 ... 0x97: /* xchg R, EAX */ doxchgregeax: ot = dflag; reg = (b & 7) | REXB(s); rm = REAX; goto doxchgreg; case 0x86: case 0x87: /* xchg Ev, Gv */ ot = mobd(b, dflag); modrm = x86ldubcode(env, s); reg = ((modrm >> 3) & 7) | rexr; mod = (modrm >> 6) & 3; if (mod == 3) { rm = (modrm & 7) | REXB(s); doxchgreg: genopmovvreg(ot, cpuT0, reg); genopmovvreg(ot, cpuT1, rm); genopmovregv(ot, rm, cpuT0); genopmovregv(ot, reg, cpuT1); } else { genleamodrm(env, s, modrm); genopmovvreg(ot, cpuT0, reg); /* for xchg, lock is implicit */ tcggenatomicxchgtl(cpuT1, cpuA0, cpuT0, s->memindex, ot | MOLE); genopmovregv(ot, reg, cpuT1); } break; case 0xc4: /* les Gv */ /* In CODE64 this is VEX3; see above. */ op = RES; goto dolxx; case 0xc5: /* lds Gv */ /* In CODE64 this is VEX2; see above. */ op = RDS; goto dolxx; case 0x1b2: /* lss Gv */ op = RSS; goto dolxx; case 0x1b4: /* lfs Gv */ op = RFS; goto dolxx; case 0x1b5: /* lgs Gv */ op = RGS; dolxx: ot = dflag != MO16 ? MO32 : MO16; modrm = x86ldubcode(env, s); reg = ((modrm >> 3) & 7) | rexr; mod = (modrm >> 6) & 3; if (mod == 3) goto illegalop; genleamodrm(env, s, modrm); genopldv(s, ot, cpuT1, cpuA0); genaddA0im(s, 1 << ot); /* load the segment first to handle exceptions properly */ genopldv(s, MO16, cpuT0, cpuA0); genmovlsegT0(s, op); /* then put the data */ genopmovregv(ot, reg, cpuT1); if (s->base.isjmp) { genjmpim(s->pc - s->csbase); geneob(s); } break; /************************/ /* shifts */ case 0xc0: case 0xc1: /* shift Ev,Ib */ shift = 2; grp2: { ot = mobd(b, dflag); modrm = x86ldubcode(env, s); mod = (modrm >> 6) & 3; op = (modrm >> 3) & 7; if (mod != 3) { if (shift == 2) { s->ripoffset = 1; } genleamodrm(env, s, modrm); opreg = ORTMP0; } else { opreg = (modrm & 7) | REXB(s); } /* simpler op */ if (shift == 0) { genshift(s, op, ot, opreg, ORECX); } else { if (shift == 2) { shift = x86ldubcode(env, s); } genshifti(s, op, ot, opreg, shift); } } break; case 0xd0: case 0xd1: /* shift Ev,1 */ shift = 1; goto grp2; case 0xd2: case 0xd3: /* shift Ev,cl */ shift = 0; goto grp2; case 0x1a4: /* shld imm */ op = 0; shift = 1; goto doshiftd; case 0x1a5: /* shld cl */ op = 0; shift = 0; goto doshiftd; case 0x1ac: /* shrd imm */ op = 1; shift = 1; goto doshiftd; case 0x1ad: /* shrd cl */ op = 1; shift = 0; doshiftd: ot = dflag; modrm = x86ldubcode(env, s); mod = (modrm >> 6) & 3; rm = (modrm & 7) | REXB(s); reg = ((modrm >> 3) & 7) | rexr; if (mod != 3) { genleamodrm(env, s, modrm); opreg = ORTMP0; } else { opreg = rm; } genopmovvreg(ot, cpuT1, reg); if (shift) { TCGv imm = tcgconsttl(x86ldubcode(env, s)); genshiftdrmT1(s, ot, opreg, op, imm); tcgtempfree(imm); } else { genshiftdrmT1(s, ot, opreg, op, cpuregs[RECX]); } break; /************************/ /* floats */ case 0xd8 ... 0xdf: if (s->flags & (HFEMMASK | HFTSMASK)) { /* if CR0.EM or CR0.TS are set, generate an FPU exception */ /* XXX: what to do if illegal op ? */ genexception(s, EXCP07PREX, pcstart - s->csbase); break; } modrm = x86ldubcode(env, s); mod = (modrm >> 6) & 3; rm = modrm & 7; op = ((b & 7) << 3) | ((modrm >> 3) & 7); if (mod != 3) { /* memory op */ genleamodrm(env, s, modrm); switch(op) { case 0x00 ... 0x07: /* fxxxs */ case 0x10 ... 0x17: /* fixxxl */ case 0x20 ... 0x27: /* fxxxl */ case 0x30 ... 0x37: /* fixxx */ { int op1; op1 = op & 7; switch(op >> 4) { case 0: tcggenqemuldi32(cputmp2i32, cpuA0, s->memindex, MOLEUL); genhelperfldsFT0(cpuenv, cputmp2i32); break; case 1: tcggenqemuldi32(cputmp2i32, cpuA0, s->memindex, MOLEUL); genhelperfildlFT0(cpuenv, cputmp2i32); break; case 2: tcggenqemuldi64(cputmp1i64, cpuA0, s->memindex, MOLEQ); genhelperfldlFT0(cpuenv, cputmp1i64); break; case 3: default: tcggenqemuldi32(cputmp2i32, cpuA0, s->memindex, MOLESW); genhelperfildlFT0(cpuenv, cputmp2i32); break; } genhelperfparithST0FT0(op1); if (op1 == 3) { /* fcomp needs pop */ genhelperfpop(cpuenv); } } break; case 0x08: /* flds */ case 0x0a: /* fsts */ case 0x0b: /* fstps */ case 0x18 ... 0x1b: /* fildl, fisttpl, fistl, fistpl */ case 0x28 ... 0x2b: /* fldl, fisttpll, fstl, fstpl */ case 0x38 ... 0x3b: /* filds, fisttps, fists, fistps */ switch(op & 7) { case 0: switch(op >> 4) { case 0: tcggenqemuldi32(cputmp2i32, cpuA0, s->memindex, MOLEUL); genhelperfldsST0(cpuenv, cputmp2i32); break; case 1: tcggenqemuldi32(cputmp2i32, cpuA0, s->memindex, MOLEUL); genhelperfildlST0(cpuenv, cputmp2i32); break; case 2: tcggenqemuldi64(cputmp1i64, cpuA0, s->memindex, MOLEQ); genhelperfldlST0(cpuenv, cputmp1i64); break; case 3: default: tcggenqemuldi32(cputmp2i32, cpuA0, s->memindex, MOLESW); genhelperfildlST0(cpuenv, cputmp2i32); break; } break; case 1: /* XXX: the corresponding CPUID bit must be tested ! */ switch(op >> 4) { case 1: genhelperfisttlST0(cputmp2i32, cpuenv); tcggenqemusti32(cputmp2i32, cpuA0, s->memindex, MOLEUL); break; case 2: genhelperfisttllST0(cputmp1i64, cpuenv); tcggenqemusti64(cputmp1i64, cpuA0, s->memindex, MOLEQ); break; case 3: default: genhelperfisttST0(cputmp2i32, cpuenv); tcggenqemusti32(cputmp2i32, cpuA0, s->memindex, MOLEUW); break; } genhelperfpop(cpuenv); break; default: switch(op >> 4) { case 0: genhelperfstsST0(cputmp2i32, cpuenv); tcggenqemusti32(cputmp2i32, cpuA0, s->memindex, MOLEUL); break; case 1: genhelperfistlST0(cputmp2i32, cpuenv); tcggenqemusti32(cputmp2i32, cpuA0, s->memindex, MOLEUL); break; case 2: genhelperfstlST0(cputmp1i64, cpuenv); tcggenqemusti64(cputmp1i64, cpuA0, s->memindex, MOLEQ); break; case 3: default: genhelperfistST0(cputmp2i32, cpuenv); tcggenqemusti32(cputmp2i32, cpuA0, s->memindex, MOLEUW); break; } if ((op & 7) == 3) genhelperfpop(cpuenv); break; } break; case 0x0c: /* fldenv mem */ genhelperfldenv(cpuenv, cpuA0, tcgconsti32(dflag - 1)); break; case 0x0d: /* fldcw mem */ tcggenqemuldi32(cputmp2i32, cpuA0, s->memindex, MOLEUW); genhelperfldcw(cpuenv, cputmp2i32); break; case 0x0e: /* fnstenv mem */ genhelperfstenv(cpuenv, cpuA0, tcgconsti32(dflag - 1)); break; case 0x0f: /* fnstcw mem */ genhelperfnstcw(cputmp2i32, cpuenv); tcggenqemusti32(cputmp2i32, cpuA0, s->memindex, MOLEUW); break; case 0x1d: /* fldt mem */ genhelperfldtST0(cpuenv, cpuA0); break; case 0x1f: /* fstpt mem */ genhelperfsttST0(cpuenv, cpuA0); genhelperfpop(cpuenv); break; case 0x2c: /* frstor mem */ genhelperfrstor(cpuenv, cpuA0, tcgconsti32(dflag - 1)); break; case 0x2e: /* fnsave mem */ genhelperfsave(cpuenv, cpuA0, tcgconsti32(dflag - 1)); break; case 0x2f: /* fnstsw mem */ genhelperfnstsw(cputmp2i32, cpuenv); tcggenqemusti32(cputmp2i32, cpuA0, s->memindex, MOLEUW); break; case 0x3c: /* fbld */ genhelperfbldST0(cpuenv, cpuA0); break; case 0x3e: /* fbstp */ genhelperfbstST0(cpuenv, cpuA0); genhelperfpop(cpuenv); break; case 0x3d: /* fildll */ tcggenqemuldi64(cputmp1i64, cpuA0, s->memindex, MOLEQ); genhelperfildllST0(cpuenv, cputmp1i64); break; case 0x3f: /* fistpll */ genhelperfistllST0(cputmp1i64, cpuenv); tcggenqemusti64(cputmp1i64, cpuA0, s->memindex, MOLEQ); genhelperfpop(cpuenv); break; default: goto unknownop; } } else { /* register float ops */ opreg = rm; switch(op) { case 0x08: /* fld sti */ genhelperfpush(cpuenv); genhelperfmovST0STN(cpuenv, tcgconsti32((opreg + 1) & 7)); break; case 0x09: /* fxchg sti */ case 0x29: /* fxchg4 sti, undocumented op */ case 0x39: /* fxchg7 sti, undocumented op */ genhelperfxchgST0STN(cpuenv, tcgconsti32(opreg)); break; case 0x0a: /* grp d9/2 */ switch(rm) { case 0: /* fnop */ /* check exceptions (FreeBSD FPU probe) */ genhelperfwait(cpuenv); break; default: goto unknownop; } break; case 0x0c: /* grp d9/4 */ switch(rm) { case 0: /* fchs */ genhelperfchsST0(cpuenv); break; case 1: /* fabs */ genhelperfabsST0(cpuenv); break; case 4: /* ftst */ genhelperfldzFT0(cpuenv); genhelperfcomST0FT0(cpuenv); break; case 5: /* fxam */ genhelperfxamST0(cpuenv); break; default: goto unknownop; } break; case 0x0d: /* grp d9/5 */ { switch(rm) { case 0: genhelperfpush(cpuenv); genhelperfld1ST0(cpuenv); break; case 1: genhelperfpush(cpuenv); genhelperfldl2tST0(cpuenv); break; case 2: genhelperfpush(cpuenv); genhelperfldl2eST0(cpuenv); break; case 3: genhelperfpush(cpuenv); genhelperfldpiST0(cpuenv); break; case 4: genhelperfpush(cpuenv); genhelperfldlg2ST0(cpuenv); break; case 5: genhelperfpush(cpuenv); genhelperfldln2ST0(cpuenv); break; case 6: genhelperfpush(cpuenv); genhelperfldzST0(cpuenv); break; default: goto unknownop; } } break; case 0x0e: /* grp d9/6 */ switch(rm) { case 0: /* f2xm1 */ genhelperf2xm1(cpuenv); break; case 1: /* fyl2x */ genhelperfyl2x(cpuenv); break; case 2: /* fptan */ genhelperfptan(cpuenv); break; case 3: /* fpatan */ genhelperfpatan(cpuenv); break; case 4: /* fxtract */ genhelperfxtract(cpuenv); break; case 5: /* fprem1 */ genhelperfprem1(cpuenv); break; case 6: /* fdecstp */ genhelperfdecstp(cpuenv); break; default: case 7: /* fincstp */ genhelperfincstp(cpuenv); break; } break; case 0x0f: /* grp d9/7 */ switch(rm) { case 0: /* fprem */ genhelperfprem(cpuenv); break; case 1: /* fyl2xp1 */ genhelperfyl2xp1(cpuenv); break; case 2: /* fsqrt */ genhelperfsqrt(cpuenv); break; case 3: /* fsincos */ genhelperfsincos(cpuenv); break; case 5: /* fscale */ genhelperfscale(cpuenv); break; case 4: /* frndint */ genhelperfrndint(cpuenv); break; case 6: /* fsin */ genhelperfsin(cpuenv); break; default: case 7: /* fcos */ genhelperfcos(cpuenv); break; } break; case 0x00: case 0x01: case 0x04 ... 0x07: /* fxxx st, sti */ case 0x20: case 0x21: case 0x24 ... 0x27: /* fxxx sti, st */ case 0x30: case 0x31: case 0x34 ... 0x37: /* fxxxp sti, st */ { int op1; op1 = op & 7; if (op >= 0x20) { genhelperfparithSTNST0(op1, opreg); if (op >= 0x30) genhelperfpop(cpuenv); } else { genhelperfmovFT0STN(cpuenv, tcgconsti32(opreg)); genhelperfparithST0FT0(op1); } } break; case 0x02: /* fcom */ case 0x22: /* fcom2, undocumented op */ genhelperfmovFT0STN(cpuenv, tcgconsti32(opreg)); genhelperfcomST0FT0(cpuenv); break; case 0x03: /* fcomp */ case 0x23: /* fcomp3, undocumented op */ case 0x32: /* fcomp5, undocumented op */ genhelperfmovFT0STN(cpuenv, tcgconsti32(opreg)); genhelperfcomST0FT0(cpuenv); genhelperfpop(cpuenv); break; case 0x15: /* da/5 */ switch(rm) { case 1: /* fucompp */ genhelperfmovFT0STN(cpuenv, tcgconsti32(1)); genhelperfucomST0FT0(cpuenv); genhelperfpop(cpuenv); genhelperfpop(cpuenv); break; default: goto unknownop; } break; case 0x1c: switch(rm) { case 0: /* feni (287 only, just do nop here) */ break; case 1: /* fdisi (287 only, just do nop here) */ break; case 2: /* fclex */ genhelperfclex(cpuenv); break; case 3: /* fninit */ genhelperfninit(cpuenv); break; case 4: /* fsetpm (287 only, just do nop here) */ break; default: goto unknownop; } break; case 0x1d: /* fucomi */ if (!(s->cpuidfeatures & CPUIDCMOV)) { goto illegalop; } genupdateccop(s); genhelperfmovFT0STN(cpuenv, tcgconsti32(opreg)); genhelperfucomiST0FT0(cpuenv); setccop(s, CCOPEFLAGS); break; case 0x1e: /* fcomi */ if (!(s->cpuidfeatures & CPUIDCMOV)) { goto illegalop; } genupdateccop(s); genhelperfmovFT0STN(cpuenv, tcgconsti32(opreg)); genhelperfcomiST0FT0(cpuenv); setccop(s, CCOPEFLAGS); break; case 0x28: /* ffree sti */ genhelperffreeSTN(cpuenv, tcgconsti32(opreg)); break; case 0x2a: /* fst sti */ genhelperfmovSTNST0(cpuenv, tcgconsti32(opreg)); break; case 0x2b: /* fstp sti */ case 0x0b: /* fstp1 sti, undocumented op */ case 0x3a: /* fstp8 sti, undocumented op */ case 0x3b: /* fstp9 sti, undocumented op */ genhelperfmovSTNST0(cpuenv, tcgconsti32(opreg)); genhelperfpop(cpuenv); break; case 0x2c: /* fucom st(i) */ genhelperfmovFT0STN(cpuenv, tcgconsti32(opreg)); genhelperfucomST0FT0(cpuenv); break; case 0x2d: /* fucomp st(i) */ genhelperfmovFT0STN(cpuenv, tcgconsti32(opreg)); genhelperfucomST0FT0(cpuenv); genhelperfpop(cpuenv); break; case 0x33: /* de/3 */ switch(rm) { case 1: /* fcompp */ genhelperfmovFT0STN(cpuenv, tcgconsti32(1)); genhelperfcomST0FT0(cpuenv); genhelperfpop(cpuenv); genhelperfpop(cpuenv); break; default: goto unknownop; } break; case 0x38: /* ffreep sti, undocumented op */ genhelperffreeSTN(cpuenv, tcgconsti32(opreg)); genhelperfpop(cpuenv); break; case 0x3c: /* df/4 */ switch(rm) { case 0: genhelperfnstsw(cputmp2i32, cpuenv); tcggenextui32tl(cpuT0, cputmp2i32); genopmovregv(MO16, REAX, cpuT0); break; default: goto unknownop; } break; case 0x3d: /* fucomip */ if (!(s->cpuidfeatures & CPUIDCMOV)) { goto illegalop; } genupdateccop(s); genhelperfmovFT0STN(cpuenv, tcgconsti32(opreg)); genhelperfucomiST0FT0(cpuenv); genhelperfpop(cpuenv); setccop(s, CCOPEFLAGS); break; case 0x3e: /* fcomip */ if (!(s->cpuidfeatures & CPUIDCMOV)) { goto illegalop; } genupdateccop(s); genhelperfmovFT0STN(cpuenv, tcgconsti32(opreg)); genhelperfcomiST0FT0(cpuenv); genhelperfpop(cpuenv); setccop(s, CCOPEFLAGS); break; case 0x10 ... 0x13: /* fcmovxx */ case 0x18 ... 0x1b: { int op1; TCGLabel *l1; static const uint8t fcmovcc[8] = { (JCCB << 1), (JCCZ << 1), (JCCBE << 1), (JCCP << 1), }; if (!(s->cpuidfeatures & CPUIDCMOV)) { goto illegalop; } op1 = fcmovcc[op & 3] | (((op >> 3) & 1) ^ 1); l1 = gennewlabel(); genjcc1noeob(s, op1, l1); genhelperfmovST0STN(cpuenv, tcgconsti32(opreg)); gensetlabel(l1); } break; default: goto unknownop; } } break; /************************/ /* string ops */ case 0xa4: /* movsS */ case 0xa5: ot = mobd(b, dflag); if (prefixes & (PREFIXREPZ | PREFIXREPNZ)) { genrepzmovs(s, ot, pcstart - s->csbase, s->pc - s->csbase); } else { genmovs(s, ot); } break; case 0xaa: /* stosS */ case 0xab: ot = mobd(b, dflag); if (prefixes & (PREFIXREPZ | PREFIXREPNZ)) { genrepzstos(s, ot, pcstart - s->csbase, s->pc - s->csbase); } else { genstos(s, ot); } break; case 0xac: /* lodsS */ case 0xad: ot = mobd(b, dflag); if (prefixes & (PREFIXREPZ | PREFIXREPNZ)) { genrepzlods(s, ot, pcstart - s->csbase, s->pc - s->csbase); } else { genlods(s, ot); } break; case 0xae: /* scasS */ case 0xaf: ot = mobd(b, dflag); if (prefixes & PREFIXREPNZ) { genrepzscas(s, ot, pcstart - s->csbase, s->pc - s->csbase, 1); } else if (prefixes & PREFIXREPZ) { genrepzscas(s, ot, pcstart - s->csbase, s->pc - s->csbase, 0); } else { genscas(s, ot); } break; case 0xa6: /* cmpsS */ case 0xa7: ot = mobd(b, dflag); if (prefixes & PREFIXREPNZ) { genrepzcmps(s, ot, pcstart - s->csbase, s->pc - s->csbase, 1); } else if (prefixes & PREFIXREPZ) { genrepzcmps(s, ot, pcstart - s->csbase, s->pc - s->csbase, 0); } else { gencmps(s, ot); } break; case 0x6c: /* insS */ case 0x6d: ot = mobd32(b, dflag); tcggenext16utl(cpuT0, cpuregs[REDX]); gencheckio(s, ot, pcstart - s->csbase, SVMIOIOTYPEMASK | svmisrep(prefixes) | 4); if (prefixes & (PREFIXREPZ | PREFIXREPNZ)) { genrepzins(s, ot, pcstart - s->csbase, s->pc - s->csbase); } else { genins(s, ot); if (s->base.tb->cflags & CFUSEICOUNT) { genjmp(s, s->pc - s->csbase); } } break; case 0x6e: /* outsS */ case 0x6f: ot = mobd32(b, dflag); tcggenext16utl(cpuT0, cpuregs[REDX]); gencheckio(s, ot, pcstart - s->csbase, svmisrep(prefixes) | 4); if (prefixes & (PREFIXREPZ | PREFIXREPNZ)) { genrepzouts(s, ot, pcstart - s->csbase, s->pc - s->csbase); } else { genouts(s, ot); if (s->base.tb->cflags & CFUSEICOUNT) { genjmp(s, s->pc - s->csbase); } } break; /************************/ /* port I/O */ case 0xe4: case 0xe5: ot = mobd32(b, dflag); val = x86ldubcode(env, s); tcggenmovitl(cpuT0, val); gencheckio(s, ot, pcstart - s->csbase, SVMIOIOTYPEMASK | svmisrep(prefixes)); if (s->base.tb->cflags & CFUSEICOUNT) { geniostart(); \t} tcggenmovii32(cputmp2i32, val); genhelperinfunc(ot, cpuT1, cputmp2i32); genopmovregv(ot, REAX, cpuT1); genbptio(s, cputmp2i32, ot); if (s->base.tb->cflags & CFUSEICOUNT) { genioend(); genjmp(s, s->pc - s->csbase); } break; case 0xe6: case 0xe7: ot = mobd32(b, dflag); val = x86ldubcode(env, s); tcggenmovitl(cpuT0, val); gencheckio(s, ot, pcstart - s->csbase, svmisrep(prefixes)); genopmovvreg(ot, cpuT1, REAX); if (s->base.tb->cflags & CFUSEICOUNT) { geniostart(); \t} tcggenmovii32(cputmp2i32, val); tcggentrunctli32(cputmp3i32, cpuT1); genhelperoutfunc(ot, cputmp2i32, cputmp3i32); genbptio(s, cputmp2i32, ot); if (s->base.tb->cflags & CFUSEICOUNT) { genioend(); genjmp(s, s->pc - s->csbase); } break; case 0xec: case 0xed: ot = mobd32(b, dflag); tcggenext16utl(cpuT0, cpuregs[REDX]); gencheckio(s, ot, pcstart - s->csbase, SVMIOIOTYPEMASK | svmisrep(prefixes)); if (s->base.tb->cflags & CFUSEICOUNT) { geniostart(); \t} tcggentrunctli32(cputmp2i32, cpuT0); genhelperinfunc(ot, cpuT1, cputmp2i32); genopmovregv(ot, REAX, cpuT1); genbptio(s, cputmp2i32, ot); if (s->base.tb->cflags & CFUSEICOUNT) { genioend(); genjmp(s, s->pc - s->csbase); } break; case 0xee: case 0xef: ot = mobd32(b, dflag); tcggenext16utl(cpuT0, cpuregs[REDX]); gencheckio(s, ot, pcstart - s->csbase, svmisrep(prefixes)); genopmovvreg(ot, cpuT1, REAX); if (s->base.tb->cflags & CFUSEICOUNT) { geniostart(); \t} tcggentrunctli32(cputmp2i32, cpuT0); tcggentrunctli32(cputmp3i32, cpuT1); genhelperoutfunc(ot, cputmp2i32, cputmp3i32); genbptio(s, cputmp2i32, ot); if (s->base.tb->cflags & CFUSEICOUNT) { genioend(); genjmp(s, s->pc - s->csbase); } break; /************************/ /* control */ case 0xc2: /* ret im */ val = x86ldswcode(env, s); ot = genpopT0(s); genstackupdate(s, val + (1 << ot)); /* Note that genpopT0 uses a zero-extending load. */ genopjmpv(cpuT0); genbndjmp(s); genjr(s, cpuT0); break; case 0xc3: /* ret */ ot = genpopT0(s); genpopupdate(s, ot); /* Note that genpopT0 uses a zero-extending load. */ genopjmpv(cpuT0); genbndjmp(s); genjr(s, cpuT0); break; case 0xca: /* lret im */ val = x86ldswcode(env, s); dolret: if (s->pe && !s->vm86) { genupdateccop(s); genjmpim(pcstart - s->csbase); genhelperlretprotected(cpuenv, tcgconsti32(dflag - 1), tcgconsti32(val)); } else { genstackA0(s); /* pop offset */ genopldv(s, dflag, cpuT0, cpuA0); /* NOTE: keeping EIP updated is not a problem in case of exception */ genopjmpv(cpuT0); /* pop selector */ genaddA0im(s, 1 << dflag); genopldv(s, dflag, cpuT0, cpuA0); genopmovlsegT0vm(RCS); /* add stack offset */ genstackupdate(s, val + (2 << dflag)); } geneob(s); break; case 0xcb: /* lret */ val = 0; goto dolret; case 0xcf: /* iret */ gensvmcheckintercept(s, pcstart, SVMEXITIRET); if (!s->pe) { /* real mode */ genhelperiretreal(cpuenv, tcgconsti32(dflag - 1)); setccop(s, CCOPEFLAGS); } else if (s->vm86) { if (s->iopl != 3) { genexception(s, EXCP0DGPF, pcstart - s->csbase); } else { genhelperiretreal(cpuenv, tcgconsti32(dflag - 1)); setccop(s, CCOPEFLAGS); } } else { genhelperiretprotected(cpuenv, tcgconsti32(dflag - 1), tcgconsti32(s->pc - s->csbase)); setccop(s, CCOPEFLAGS); } geneob(s); break; case 0xe8: /* call im */ { if (dflag != MO16) { tval = (int32t)insnget(env, s, MO32); } else { tval = (int16t)insnget(env, s, MO16); } nexteip = s->pc - s->csbase; tval += nexteip; if (dflag == MO16) { tval &= 0xffff; } else if (!CODE64(s)) { tval &= 0xffffffff; } tcggenmovitl(cpuT0, nexteip); genpushv(s, cpuT0); genbndjmp(s); genjmp(s, tval); } break; case 0x9a: /* lcall im */ { unsigned int selector, offset; if (CODE64(s)) goto illegalop; ot = dflag; offset = insnget(env, s, ot); selector = insnget(env, s, MO16); tcggenmovitl(cpuT0, selector); tcggenmovitl(cpuT1, offset); } goto dolcall; case 0xe9: /* jmp im */ if (dflag != MO16) { tval = (int32t)insnget(env, s, MO32); } else { tval = (int16t)insnget(env, s, MO16); } tval += s->pc - s->csbase; if (dflag == MO16) { tval &= 0xffff; } else if (!CODE64(s)) { tval &= 0xffffffff; } genbndjmp(s); genjmp(s, tval); break; case 0xea: /* ljmp im */ { unsigned int selector, offset; if (CODE64(s)) goto illegalop; ot = dflag; offset = insnget(env, s, ot); selector = insnget(env, s, MO16); tcggenmovitl(cpuT0, selector); tcggenmovitl(cpuT1, offset); } goto doljmp; case 0xeb: /* jmp Jb */ tval = (int8t)insnget(env, s, MO8); tval += s->pc - s->csbase; if (dflag == MO16) { tval &= 0xffff; } genjmp(s, tval); break; case 0x70 ... 0x7f: /* jcc Jb */ tval = (int8t)insnget(env, s, MO8); goto dojcc; case 0x180 ... 0x18f: /* jcc Jv */ if (dflag != MO16) { tval = (int32t)insnget(env, s, MO32); } else { tval = (int16t)insnget(env, s, MO16); } dojcc: nexteip = s->pc - s->csbase; tval += nexteip; if (dflag == MO16) { tval &= 0xffff; } genbndjmp(s); genjcc(s, b, tval, nexteip); break; case 0x190 ... 0x19f: /* setcc Gv */ modrm = x86ldubcode(env, s); gensetcc1(s, b, cpuT0); genldstmodrm(env, s, modrm, MO8, ORTMP0, 1); break; case 0x140 ... 0x14f: /* cmov Gv, Ev */ if (!(s->cpuidfeatures & CPUIDCMOV)) { goto illegalop; } ot = dflag; modrm = x86ldubcode(env, s); reg = ((modrm >> 3) & 7) | rexr; gencmovcc1(env, s, ot, b, modrm, reg); break; /************************/ /* flags */ case 0x9c: /* pushf */ gensvmcheckintercept(s, pcstart, SVMEXITPUSHF); if (s->vm86 && s->iopl != 3) { genexception(s, EXCP0DGPF, pcstart - s->csbase); } else { genupdateccop(s); genhelperreadeflags(cpuT0, cpuenv); genpushv(s, cpuT0); } break; case 0x9d: /* popf */ gensvmcheckintercept(s, pcstart, SVMEXITPOPF); if (s->vm86 && s->iopl != 3) { genexception(s, EXCP0DGPF, pcstart - s->csbase); } else { ot = genpopT0(s); if (s->cpl == 0) { if (dflag != MO16) { genhelperwriteeflags(cpuenv, cpuT0, tcgconsti32((TFMASK | ACMASK | IDMASK | NTMASK | IFMASK | IOPLMASK))); } else { genhelperwriteeflags(cpuenv, cpuT0, tcgconsti32((TFMASK | ACMASK | IDMASK | NTMASK | IFMASK | IOPLMASK) & 0xffff)); } } else { if (s->cpl <= s->iopl) { if (dflag != MO16) { genhelperwriteeflags(cpuenv, cpuT0, tcgconsti32((TFMASK | ACMASK | IDMASK | NTMASK | IFMASK))); } else { genhelperwriteeflags(cpuenv, cpuT0, tcgconsti32((TFMASK | ACMASK | IDMASK | NTMASK | IFMASK) & 0xffff)); } } else { if (dflag != MO16) { genhelperwriteeflags(cpuenv, cpuT0, tcgconsti32((TFMASK | ACMASK | IDMASK | NTMASK))); } else { genhelperwriteeflags(cpuenv, cpuT0, tcgconsti32((TFMASK | ACMASK | IDMASK | NTMASK) & 0xffff)); } } } genpopupdate(s, ot); setccop(s, CCOPEFLAGS); /* abort translation because TF/AC flag may change */ genjmpim(s->pc - s->csbase); geneob(s); } break; case 0x9e: /* sahf */ if (CODE64(s) && !(s->cpuidext3features & CPUIDEXT3LAHFLM)) goto illegalop; genopmovvreg(MO8, cpuT0, RAH); gencomputeeflags(s); tcggenanditl(cpuccsrc, cpuccsrc, CCO); tcggenanditl(cpuT0, cpuT0, CCS | CCZ | CCA | CCP | CCC); tcggenortl(cpuccsrc, cpuccsrc, cpuT0); break; case 0x9f: /* lahf */ if (CODE64(s) && !(s->cpuidext3features & CPUIDEXT3LAHFLM)) goto illegalop; gencomputeeflags(s); /* Note: gencomputeeflags() only gives the condition codes */ tcggenoritl(cpuT0, cpuccsrc, 0x02); genopmovregv(MO8, RAH, cpuT0); break; case 0xf5: /* cmc */ gencomputeeflags(s); tcggenxoritl(cpuccsrc, cpuccsrc, CCC); break; case 0xf8: /* clc */ gencomputeeflags(s); tcggenanditl(cpuccsrc, cpuccsrc, ~CCC); break; case 0xf9: /* stc */ gencomputeeflags(s); tcggenoritl(cpuccsrc, cpuccsrc, CCC); break; case 0xfc: /* cld */ tcggenmovii32(cputmp2i32, 1); tcggensti32(cputmp2i32, cpuenv, offsetof(CPUX86State, df)); break; case 0xfd: /* std */ tcggenmovii32(cputmp2i32, -1); tcggensti32(cputmp2i32, cpuenv, offsetof(CPUX86State, df)); break; /************************/ /* bit operations */ case 0x1ba: /* bt/bts/btr/btc Gv, im */ ot = dflag; modrm = x86ldubcode(env, s); op = (modrm >> 3) & 7; mod = (modrm >> 6) & 3; rm = (modrm & 7) | REXB(s); if (mod != 3) { s->ripoffset = 1; genleamodrm(env, s, modrm); if (!(s->prefix & PREFIXLOCK)) { genopldv(s, ot, cpuT0, cpuA0); } } else { genopmovvreg(ot, cpuT0, rm); } /* load shift */ val = x86ldubcode(env, s); tcggenmovitl(cpuT1, val); if (op < 4) goto unknownop; op -= 4; goto btop; case 0x1a3: /* bt Gv, Ev */ op = 0; goto dobtx; case 0x1ab: /* bts */ op = 1; goto dobtx; case 0x1b3: /* btr */ op = 2; goto dobtx; case 0x1bb: /* btc */ op = 3; dobtx: ot = dflag; modrm = x86ldubcode(env, s); reg = ((modrm >> 3) & 7) | rexr; mod = (modrm >> 6) & 3; rm = (modrm & 7) | REXB(s); genopmovvreg(MO32, cpuT1, reg); if (mod != 3) { AddressParts a = genleamodrm0(env, s, modrm); /* specific case: we need to add a displacement */ genexts(ot, cpuT1); tcggensaritl(cputmp0, cpuT1, 3 + ot); tcggenshlitl(cputmp0, cputmp0, ot); tcggenaddtl(cpuA0, genleamodrm1(a), cputmp0); genleavseg(s, s->aflag, cpuA0, a.defseg, s->override); if (!(s->prefix & PREFIXLOCK)) { genopldv(s, ot, cpuT0, cpuA0); } } else { genopmovvreg(ot, cpuT0, rm); } btop: tcggenanditl(cpuT1, cpuT1, (1 << (3 + ot)) - 1); tcggenmovitl(cputmp0, 1); tcggenshltl(cputmp0, cputmp0, cpuT1); if (s->prefix & PREFIXLOCK) { switch (op) { case 0: /* bt */ /* Needs no atomic ops; we surpressed the normal memory load for LOCK above so do it now. */ genopldv(s, ot, cpuT0, cpuA0); break; case 1: /* bts */ tcggenatomicfetchortl(cpuT0, cpuA0, cputmp0, s->memindex, ot | MOLE); break; case 2: /* btr */ tcggennottl(cputmp0, cputmp0); tcggenatomicfetchandtl(cpuT0, cpuA0, cputmp0, s->memindex, ot | MOLE); break; default: case 3: /* btc */ tcggenatomicfetchxortl(cpuT0, cpuA0, cputmp0, s->memindex, ot | MOLE); break; } tcggenshrtl(cputmp4, cpuT0, cpuT1); } else { tcggenshrtl(cputmp4, cpuT0, cpuT1); switch (op) { case 0: /* bt */ /* Data already loaded; nothing to do. */ break; case 1: /* bts */ tcggenortl(cpuT0, cpuT0, cputmp0); break; case 2: /* btr */ tcggenandctl(cpuT0, cpuT0, cputmp0); break; default: case 3: /* btc */ tcggenxortl(cpuT0, cpuT0, cputmp0); break; } if (op != 0) { if (mod != 3) { genopstv(s, ot, cpuT0, cpuA0); } else { genopmovregv(ot, rm, cpuT0); } } } /* Delay all CC updates until after the store above. Note that C is the result of the test, Z is unchanged, and the others are all undefined. */ switch (s->ccop) { case CCOPMULB ... CCOPMULQ: case CCOPADDB ... CCOPADDQ: case CCOPADCB ... CCOPADCQ: case CCOPSUBB ... CCOPSUBQ: case CCOPSBBB ... CCOPSBBQ: case CCOPLOGICB ... CCOPLOGICQ: case CCOPINCB ... CCOPINCQ: case CCOPDECB ... CCOPDECQ: case CCOPSHLB ... CCOPSHLQ: case CCOPSARB ... CCOPSARQ: case CCOPBMILGB ... CCOPBMILGQ: /* Z was going to be computed from the non-zero status of CCDST. We can get that same Z value (and the new C value) by leaving CCDST alone, setting CCSRC, and using a CCOPSAR of the same width. */ tcggenmovtl(cpuccsrc, cputmp4); setccop(s, ((s->ccop - CCOPMULB) & 3) + CCOPSARB); break; default: /* Otherwise, generate EFLAGS and replace the C bit. */ gencomputeeflags(s); tcggendeposittl(cpuccsrc, cpuccsrc, cputmp4, ctz32(CCC), 1); break; } break; case 0x1bc: /* bsf / tzcnt */ case 0x1bd: /* bsr / lzcnt */ ot = dflag; modrm = x86ldubcode(env, s); reg = ((modrm >> 3) & 7) | rexr; genldstmodrm(env, s, modrm, ot, ORTMP0, 0); genextu(ot, cpuT0); /* Note that lzcnt and tzcnt are in different extensions. */ if ((prefixes & PREFIXREPZ) && (b & 1 ? s->cpuidext3features & CPUIDEXT3ABM : s->cpuid70ebxfeatures & CPUID70EBXBMI1)) { int size = 8 << ot; /* For lzcnt/tzcnt, C bit is defined related to the input. */ tcggenmovtl(cpuccsrc, cpuT0); if (b & 1) { /* For lzcnt, reduce the targetulong result by the number of zeros that we expect to find at the top. */ tcggenclzitl(cpuT0, cpuT0, TARGETLONGBITS); tcggensubitl(cpuT0, cpuT0, TARGETLONGBITS - size); } else { /* For tzcnt, a zero input must return the operand size. */ tcggenctzitl(cpuT0, cpuT0, size); } /* For lzcnt/tzcnt, Z bit is defined related to the result. */ genopupdate1cc(); setccop(s, CCOPBMILGB + ot); } else { /* For bsr/bsf, only the Z bit is defined and it is related to the input and not the result. */ tcggenmovtl(cpuccdst, cpuT0); setccop(s, CCOPLOGICB + ot); /* ??? The manual says that the output is undefined when the input is zero, but real hardware leaves it unchanged, and real programs appear to depend on that. Accomplish this by passing the output as the value to return upon zero. */ if (b & 1) { /* For bsr, return the bit index of the first 1 bit, not the count of leading zeros. */ tcggenxoritl(cpuT1, cpuregs[reg], TARGETLONGBITS - 1); tcggenclztl(cpuT0, cpuT0, cpuT1); tcggenxoritl(cpuT0, cpuT0, TARGETLONGBITS - 1); } else { tcggenctztl(cpuT0, cpuT0, cpuregs[reg]); } } genopmovregv(ot, reg, cpuT0); break; /************************/ /* bcd */ case 0x27: /* daa */ if (CODE64(s)) goto illegalop; genupdateccop(s); genhelperdaa(cpuenv); setccop(s, CCOPEFLAGS); break; case 0x2f: /* das */ if (CODE64(s)) goto illegalop; genupdateccop(s); genhelperdas(cpuenv); setccop(s, CCOPEFLAGS); break; case 0x37: /* aaa */ if (CODE64(s)) goto illegalop; genupdateccop(s); genhelperaaa(cpuenv); setccop(s, CCOPEFLAGS); break; case 0x3f: /* aas */ if (CODE64(s)) goto illegalop; genupdateccop(s); genhelperaas(cpuenv); setccop(s, CCOPEFLAGS); break; case 0xd4: /* aam */ if (CODE64(s)) goto illegalop; val = x86ldubcode(env, s); if (val == 0) { genexception(s, EXCP00DIVZ, pcstart - s->csbase); } else { genhelperaam(cpuenv, tcgconsti32(val)); setccop(s, CCOPLOGICB); } break; case 0xd5: /* aad */ if (CODE64(s)) goto illegalop; val = x86ldubcode(env, s); genhelperaad(cpuenv, tcgconsti32(val)); setccop(s, CCOPLOGICB); break; /************************/ /* misc */ case 0x90: /* nop */ /* XXX: correct lock test for all insn */ if (prefixes & PREFIXLOCK) { goto illegalop; } /* If REXB is set, then this is xchg eax, r8d, not a nop. */ if (REXB(s)) { goto doxchgregeax; } if (prefixes & PREFIXREPZ) { genupdateccop(s); genjmpim(pcstart - s->csbase); genhelperpause(cpuenv, tcgconsti32(s->pc - pcstart)); s->base.isjmp = DISASNORETURN; } break; case 0x9b: /* fwait */ if ((s->flags & (HFMPMASK | HFTSMASK)) == (HFMPMASK | HFTSMASK)) { genexception(s, EXCP07PREX, pcstart - s->csbase); } else { genhelperfwait(cpuenv); } break; case 0xcc: /* int3 */ geninterrupt(s, EXCP03INT3, pcstart - s->csbase, s->pc - s->csbase); break; case 0xcd: /* int N */ val = x86ldubcode(env, s); if (s->vm86 && s->iopl != 3) { genexception(s, EXCP0DGPF, pcstart - s->csbase); } else { geninterrupt(s, val, pcstart - s->csbase, s->pc - s->csbase); } break; case 0xce: /* into */ if (CODE64(s)) goto illegalop; genupdateccop(s); genjmpim(pcstart - s->csbase); genhelperinto(cpuenv, tcgconsti32(s->pc - pcstart)); break; #ifdef WANTICEBP case 0xf1: /* icebp (undocumented, exits to external debugger) */ gensvmcheckintercept(s, pcstart, SVMEXITICEBP); #if 1 gendebug(s, pcstart - s->csbase); #else /* start debug */ tbflush(CPU(x86envgetcpu(env))); qemusetlog(CPULOGINT | CPULOGTBINASM); #endif break; #endif case 0xfa: /* cli */ if (!s->vm86) { if (s->cpl <= s->iopl) { genhelpercli(cpuenv); } else { genexception(s, EXCP0DGPF, pcstart - s->csbase); } } else { if (s->iopl == 3) { genhelpercli(cpuenv); } else { genexception(s, EXCP0DGPF, pcstart - s->csbase); } } break; case 0xfb: /* sti */ if (s->vm86 ? s->iopl == 3 : s->cpl <= s->iopl) { genhelpersti(cpuenv); /* interruptions are enabled only the first insn after sti */ genjmpim(s->pc - s->csbase); geneobinhibitirq(s, true); } else { genexception(s, EXCP0DGPF, pcstart - s->csbase); } break; case 0x62: /* bound */ if (CODE64(s)) goto illegalop; ot = dflag; modrm = x86ldubcode(env, s); reg = (modrm >> 3) & 7; mod = (modrm >> 6) & 3; if (mod == 3) goto illegalop; genopmovvreg(ot, cpuT0, reg); genleamodrm(env, s, modrm); tcggentrunctli32(cputmp2i32, cpuT0); if (ot == MO16) { genhelperboundw(cpuenv, cpuA0, cputmp2i32); } else { genhelperboundl(cpuenv, cpuA0, cputmp2i32); } break; case 0x1c8 ... 0x1cf: /* bswap reg */ reg = (b & 7) | REXB(s); #ifdef TARGETX8664 if (dflag == MO64) { genopmovvreg(MO64, cpuT0, reg); tcggenbswap64i64(cpuT0, cpuT0); genopmovregv(MO64, reg, cpuT0); } else #endif { genopmovvreg(MO32, cpuT0, reg); tcggenext32utl(cpuT0, cpuT0); tcggenbswap32tl(cpuT0, cpuT0); genopmovregv(MO32, reg, cpuT0); } break; case 0xd6: /* salc */ if (CODE64(s)) goto illegalop; gencomputeeflagsc(s, cpuT0); tcggennegtl(cpuT0, cpuT0); genopmovregv(MO8, REAX, cpuT0); break; case 0xe0: /* loopnz */ case 0xe1: /* loopz */ case 0xe2: /* loop */ case 0xe3: /* jecxz */ { TCGLabel *l1, *l2, *l3; tval = (int8t)insnget(env, s, MO8); nexteip = s->pc - s->csbase; tval += nexteip; if (dflag == MO16) { tval &= 0xffff; } l1 = gennewlabel(); l2 = gennewlabel(); l3 = gennewlabel(); b &= 3; switch(b) { case 0: /* loopnz */ case 1: /* loopz */ genopaddregim(s->aflag, RECX, -1); genopjzecx(s->aflag, l3); genjcc1(s, (JCCZ << 1) | (b ^ 1), l1); break; case 2: /* loop */ genopaddregim(s->aflag, RECX, -1); genopjnzecx(s->aflag, l1); break; default: case 3: /* jcxz */ genopjzecx(s->aflag, l1); break; } gensetlabel(l3); genjmpim(nexteip); tcggenbr(l2); gensetlabel(l1); genjmpim(tval); gensetlabel(l2); geneob(s); } break; case 0x130: /* wrmsr */ case 0x132: /* rdmsr */ if (s->cpl != 0) { genexception(s, EXCP0DGPF, pcstart - s->csbase); } else { genupdateccop(s); genjmpim(pcstart - s->csbase); if (b & 2) { genhelperrdmsr(cpuenv); } else { genhelperwrmsr(cpuenv); } } break; case 0x131: /* rdtsc */ genupdateccop(s); genjmpim(pcstart - s->csbase); if (s->base.tb->cflags & CFUSEICOUNT) { geniostart(); \t} genhelperrdtsc(cpuenv); if (s->base.tb->cflags & CFUSEICOUNT) { genioend(); genjmp(s, s->pc - s->csbase); } break; case 0x133: /* rdpmc */ genupdateccop(s); genjmpim(pcstart - s->csbase); genhelperrdpmc(cpuenv); break; case 0x134: /* sysenter */ /* For Intel SYSENTER is valid on 64-bit */ if (CODE64(s) && env->cpuidvendor1 != CPUIDVENDORINTEL1) goto illegalop; if (!s->pe) { genexception(s, EXCP0DGPF, pcstart - s->csbase); } else { genhelpersysenter(cpuenv); geneob(s); } break; case 0x135: /* sysexit */ /* For Intel SYSEXIT is valid on 64-bit */ if (CODE64(s) && env->cpuidvendor1 != CPUIDVENDORINTEL1) goto illegalop; if (!s->pe) { genexception(s, EXCP0DGPF, pcstart - s->csbase); } else { genhelpersysexit(cpuenv, tcgconsti32(dflag - 1)); geneob(s); } break; #ifdef TARGETX8664 case 0x105: /* syscall */ /* XXX: is it usable in real mode ? */ genupdateccop(s); genjmpim(pcstart - s->csbase); genhelpersyscall(cpuenv, tcgconsti32(s->pc - pcstart)); /* TF handling for the syscall insn is different. The TF bit is checked after the syscall insn completes. This allows #DB to not be generated after one has entered CPL0 if TF is set in FMASK. */ geneobworker(s, false, true); break; case 0x107: /* sysret */ if (!s->pe) { genexception(s, EXCP0DGPF, pcstart - s->csbase); } else { genhelpersysret(cpuenv, tcgconsti32(dflag - 1)); /* condition codes are modified only in long mode */ if (s->lma) { setccop(s, CCOPEFLAGS); } /* TF handling for the sysret insn is different. The TF bit is checked after the sysret insn completes. This allows #DB to be generated \"as if\" the syscall insn in userspace has just completed. */ geneobworker(s, false, true); } break; #endif case 0x1a2: /* cpuid */ genupdateccop(s); genjmpim(pcstart - s->csbase); genhelpercpuid(cpuenv); break; case 0xf4: /* hlt */ if (s->cpl != 0) { genexception(s, EXCP0DGPF, pcstart - s->csbase); } else { genupdateccop(s); genjmpim(pcstart - s->csbase); genhelperhlt(cpuenv, tcgconsti32(s->pc - pcstart)); s->base.isjmp = DISASNORETURN; } break; case 0x100: modrm = x86ldubcode(env, s); mod = (modrm >> 6) & 3; op = (modrm >> 3) & 7; switch(op) { case 0: /* sldt */ if (!s->pe || s->vm86) goto illegalop; gensvmcheckintercept(s, pcstart, SVMEXITLDTRREAD); tcggenld32utl(cpuT0, cpuenv, offsetof(CPUX86State, ldt.selector)); ot = mod == 3 ? dflag : MO16; genldstmodrm(env, s, modrm, ot, ORTMP0, 1); break; case 2: /* lldt */ if (!s->pe || s->vm86) goto illegalop; if (s->cpl != 0) { genexception(s, EXCP0DGPF, pcstart - s->csbase); } else { gensvmcheckintercept(s, pcstart, SVMEXITLDTRWRITE); genldstmodrm(env, s, modrm, MO16, ORTMP0, 0); tcggentrunctli32(cputmp2i32, cpuT0); genhelperlldt(cpuenv, cputmp2i32); } break; case 1: /* str */ if (!s->pe || s->vm86) goto illegalop; gensvmcheckintercept(s, pcstart, SVMEXITTRREAD); tcggenld32utl(cpuT0, cpuenv, offsetof(CPUX86State, tr.selector)); ot = mod == 3 ? dflag : MO16; genldstmodrm(env, s, modrm, ot, ORTMP0, 1); break; case 3: /* ltr */ if (!s->pe || s->vm86) goto illegalop; if (s->cpl != 0) { genexception(s, EXCP0DGPF, pcstart - s->csbase); } else { gensvmcheckintercept(s, pcstart, SVMEXITTRWRITE); genldstmodrm(env, s, modrm, MO16, ORTMP0, 0); tcggentrunctli32(cputmp2i32, cpuT0); genhelperltr(cpuenv, cputmp2i32); } break; case 4: /* verr */ case 5: /* verw */ if (!s->pe || s->vm86) goto illegalop; genldstmodrm(env, s, modrm, MO16, ORTMP0, 0); genupdateccop(s); if (op == 4) { genhelperverr(cpuenv, cpuT0); } else { genhelperverw(cpuenv, cpuT0); } setccop(s, CCOPEFLAGS); break; default: goto unknownop; } break; case 0x101: modrm = x86ldubcode(env, s); switch (modrm) { CASEMODRMMEMOP(0): /* sgdt */ gensvmcheckintercept(s, pcstart, SVMEXITGDTRREAD); genleamodrm(env, s, modrm); tcggenld32utl(cpuT0, cpuenv, offsetof(CPUX86State, gdt.limit)); genopstv(s, MO16, cpuT0, cpuA0); genaddA0im(s, 2); tcggenldtl(cpuT0, cpuenv, offsetof(CPUX86State, gdt.base)); if (dflag == MO16) { tcggenanditl(cpuT0, cpuT0, 0xffffff); } genopstv(s, CODE64(s) + MO32, cpuT0, cpuA0); break; case 0xc8: /* monitor */ if (!(s->cpuidextfeatures & CPUIDEXTMONITOR) || s->cpl != 0) { goto illegalop; } genupdateccop(s); genjmpim(pcstart - s->csbase); tcggenmovtl(cpuA0, cpuregs[REAX]); genextu(s->aflag, cpuA0); genaddA0dsseg(s); genhelpermonitor(cpuenv, cpuA0); break; case 0xc9: /* mwait */ if (!(s->cpuidextfeatures & CPUIDEXTMONITOR) || s->cpl != 0) { goto illegalop; } genupdateccop(s); genjmpim(pcstart - s->csbase); genhelpermwait(cpuenv, tcgconsti32(s->pc - pcstart)); geneob(s); break; case 0xca: /* clac */ if (!(s->cpuid70ebxfeatures & CPUID70EBXSMAP) || s->cpl != 0) { goto illegalop; } genhelperclac(cpuenv); genjmpim(s->pc - s->csbase); geneob(s); break; case 0xcb: /* stac */ if (!(s->cpuid70ebxfeatures & CPUID70EBXSMAP) || s->cpl != 0) { goto illegalop; } genhelperstac(cpuenv); genjmpim(s->pc - s->csbase); geneob(s); break; CASEMODRMMEMOP(1): /* sidt */ gensvmcheckintercept(s, pcstart, SVMEXITIDTRREAD); genleamodrm(env, s, modrm); tcggenld32utl(cpuT0, cpuenv, offsetof(CPUX86State, idt.limit)); genopstv(s, MO16, cpuT0, cpuA0); genaddA0im(s, 2); tcggenldtl(cpuT0, cpuenv, offsetof(CPUX86State, idt.base)); if (dflag == MO16) { tcggenanditl(cpuT0, cpuT0, 0xffffff); } genopstv(s, CODE64(s) + MO32, cpuT0, cpuA0); break; case 0xd0: /* xgetbv */ if ((s->cpuidextfeatures & CPUIDEXTXSAVE) == 0 || (s->prefix & (PREFIXLOCK | PREFIXDATA | PREFIXREPZ | PREFIXREPNZ))) { goto illegalop; } tcggentrunctli32(cputmp2i32, cpuregs[RECX]); genhelperxgetbv(cputmp1i64, cpuenv, cputmp2i32); tcggenextri64tl(cpuregs[REAX], cpuregs[REDX], cputmp1i64); break; case 0xd1: /* xsetbv */ if ((s->cpuidextfeatures & CPUIDEXTXSAVE) == 0 || (s->prefix & (PREFIXLOCK | PREFIXDATA | PREFIXREPZ | PREFIXREPNZ))) { goto illegalop; } if (s->cpl != 0) { genexception(s, EXCP0DGPF, pcstart - s->csbase); break; } tcggenconcattli64(cputmp1i64, cpuregs[REAX], cpuregs[REDX]); tcggentrunctli32(cputmp2i32, cpuregs[RECX]); genhelperxsetbv(cpuenv, cputmp2i32, cputmp1i64); /* End TB because translation flags may change. */ genjmpim(s->pc - s->csbase); geneob(s); break; case 0xd8: /* VMRUN */ if (!(s->flags & HFSVMEMASK) || !s->pe) { goto illegalop; } if (s->cpl != 0) { genexception(s, EXCP0DGPF, pcstart - s->csbase); break; } genupdateccop(s); genjmpim(pcstart - s->csbase); genhelpervmrun(cpuenv, tcgconsti32(s->aflag - 1), tcgconsti32(s->pc - pcstart)); tcggenexittb(0); s->base.isjmp = DISASNORETURN; break; case 0xd9: /* VMMCALL */ if (!(s->flags & HFSVMEMASK)) { goto illegalop; } genupdateccop(s); genjmpim(pcstart - s->csbase); genhelpervmmcall(cpuenv); break; case 0xda: /* VMLOAD */ if (!(s->flags & HFSVMEMASK) || !s->pe) { goto illegalop; } if (s->cpl != 0) { genexception(s, EXCP0DGPF, pcstart - s->csbase); break; } genupdateccop(s); genjmpim(pcstart - s->csbase); genhelpervmload(cpuenv, tcgconsti32(s->aflag - 1)); break; case 0xdb: /* VMSAVE */ if (!(s->flags & HFSVMEMASK) || !s->pe) { goto illegalop; } if (s->cpl != 0) { genexception(s, EXCP0DGPF, pcstart - s->csbase); break; } genupdateccop(s); genjmpim(pcstart - s->csbase); genhelpervmsave(cpuenv, tcgconsti32(s->aflag - 1)); break; case 0xdc: /* STGI */ if ((!(s->flags & HFSVMEMASK) && !(s->cpuidext3features & CPUIDEXT3SKINIT)) || !s->pe) { goto illegalop; } if (s->cpl != 0) { genexception(s, EXCP0DGPF, pcstart - s->csbase); break; } genupdateccop(s); genjmpim(pcstart - s->csbase); genhelperstgi(cpuenv); break; case 0xdd: /* CLGI */ if (!(s->flags & HFSVMEMASK) || !s->pe) { goto illegalop; } if (s->cpl != 0) { genexception(s, EXCP0DGPF, pcstart - s->csbase); break; } genupdateccop(s); genjmpim(pcstart - s->csbase); genhelperclgi(cpuenv); break; case 0xde: /* SKINIT */ if ((!(s->flags & HFSVMEMASK) && !(s->cpuidext3features & CPUIDEXT3SKINIT)) || !s->pe) { goto illegalop; } genupdateccop(s); genjmpim(pcstart - s->csbase); genhelperskinit(cpuenv); break; case 0xdf: /* INVLPGA */ if (!(s->flags & HFSVMEMASK) || !s->pe) { goto illegalop; } if (s->cpl != 0) { genexception(s, EXCP0DGPF, pcstart - s->csbase); break; } genupdateccop(s); genjmpim(pcstart - s->csbase); genhelperinvlpga(cpuenv, tcgconsti32(s->aflag - 1)); break; CASEMODRMMEMOP(2): /* lgdt */ if (s->cpl != 0) { genexception(s, EXCP0DGPF, pcstart - s->csbase); break; } gensvmcheckintercept(s, pcstart, SVMEXITGDTRWRITE); genleamodrm(env, s, modrm); genopldv(s, MO16, cpuT1, cpuA0); genaddA0im(s, 2); genopldv(s, CODE64(s) + MO32, cpuT0, cpuA0); if (dflag == MO16) { tcggenanditl(cpuT0, cpuT0, 0xffffff); } tcggensttl(cpuT0, cpuenv, offsetof(CPUX86State, gdt.base)); tcggenst32tl(cpuT1, cpuenv, offsetof(CPUX86State, gdt.limit)); break; CASEMODRMMEMOP(3): /* lidt */ if (s->cpl != 0) { genexception(s, EXCP0DGPF, pcstart - s->csbase); break; } gensvmcheckintercept(s, pcstart, SVMEXITIDTRWRITE); genleamodrm(env, s, modrm); genopldv(s, MO16, cpuT1, cpuA0); genaddA0im(s, 2); genopldv(s, CODE64(s) + MO32, cpuT0, cpuA0); if (dflag == MO16) { tcggenanditl(cpuT0, cpuT0, 0xffffff); } tcggensttl(cpuT0, cpuenv, offsetof(CPUX86State, idt.base)); tcggenst32tl(cpuT1, cpuenv, offsetof(CPUX86State, idt.limit)); break; CASEMODRMOP(4): /* smsw */ gensvmcheckintercept(s, pcstart, SVMEXITREADCR0); tcggenldtl(cpuT0, cpuenv, offsetof(CPUX86State, cr[0])); if (CODE64(s)) { mod = (modrm >> 6) & 3; ot = (mod != 3 ? MO16 : s->dflag); } else { ot = MO16; } genldstmodrm(env, s, modrm, ot, ORTMP0, 1); break; case 0xee: /* rdpkru */ if (prefixes & PREFIXLOCK) { goto illegalop; } tcggentrunctli32(cputmp2i32, cpuregs[RECX]); genhelperrdpkru(cputmp1i64, cpuenv, cputmp2i32); tcggenextri64tl(cpuregs[REAX], cpuregs[REDX], cputmp1i64); break; case 0xef: /* wrpkru */ if (prefixes & PREFIXLOCK) { goto illegalop; } tcggenconcattli64(cputmp1i64, cpuregs[REAX], cpuregs[REDX]); tcggentrunctli32(cputmp2i32, cpuregs[RECX]); genhelperwrpkru(cpuenv, cputmp2i32, cputmp1i64); break; CASEMODRMOP(6): /* lmsw */ if (s->cpl != 0) { genexception(s, EXCP0DGPF, pcstart - s->csbase); break; } gensvmcheckintercept(s, pcstart, SVMEXITWRITECR0); genldstmodrm(env, s, modrm, MO16, ORTMP0, 0); genhelperlmsw(cpuenv, cpuT0); genjmpim(s->pc - s->csbase); geneob(s); break; CASEMODRMMEMOP(7): /* invlpg */ if (s->cpl != 0) { genexception(s, EXCP0DGPF, pcstart - s->csbase); break; } genupdateccop(s); genjmpim(pcstart - s->csbase); genleamodrm(env, s, modrm); genhelperinvlpg(cpuenv, cpuA0); genjmpim(s->pc - s->csbase); geneob(s); break; case 0xf8: /* swapgs */ #ifdef TARGETX8664 if (CODE64(s)) { if (s->cpl != 0) { genexception(s, EXCP0DGPF, pcstart - s->csbase); } else { tcggenmovtl(cpuT0, cpusegbase[RGS]); tcggenldtl(cpusegbase[RGS], cpuenv, offsetof(CPUX86State, kernelgsbase)); tcggensttl(cpuT0, cpuenv, offsetof(CPUX86State, kernelgsbase)); } break; } #endif goto illegalop; case 0xf9: /* rdtscp */ if (!(s->cpuidext2features & CPUIDEXT2RDTSCP)) { goto illegalop; } genupdateccop(s); genjmpim(pcstart - s->csbase); if (s->base.tb->cflags & CFUSEICOUNT) { geniostart(); } genhelperrdtscp(cpuenv); if (s->base.tb->cflags & CFUSEICOUNT) { genioend(); genjmp(s, s->pc - s->csbase); } break; default: goto unknownop; } break; case 0x108: /* invd */ case 0x109: /* wbinvd */ if (s->cpl != 0) { genexception(s, EXCP0DGPF, pcstart - s->csbase); } else { gensvmcheckintercept(s, pcstart, (b & 2) ? SVMEXITINVD : SVMEXITWBINVD); /* nothing to do */ } break; case 0x63: /* arpl or movslS (x8664) */ #ifdef TARGETX8664 if (CODE64(s)) { int dot; /* dot is the size of destination */ dot = dflag; modrm = x86ldubcode(env, s); reg = ((modrm >> 3) & 7) | rexr; mod = (modrm >> 6) & 3; rm = (modrm & 7) | REXB(s); if (mod == 3) { genopmovvreg(MO32, cpuT0, rm); /* sign extend */ if (dot == MO64) { tcggenext32stl(cpuT0, cpuT0); } genopmovregv(dot, reg, cpuT0); } else { genleamodrm(env, s, modrm); genopldv(s, MO32 | MOSIGN, cpuT0, cpuA0); genopmovregv(dot, reg, cpuT0); } } else #endif { TCGLabel *label1; TCGv t0, t1, t2, a0; if (!s->pe || s->vm86) goto illegalop; t0 = tcgtemplocalnew(); t1 = tcgtemplocalnew(); t2 = tcgtemplocalnew(); ot = MO16; modrm = x86ldubcode(env, s); reg = (modrm >> 3) & 7; mod = (modrm >> 6) & 3; rm = modrm & 7; if (mod != 3) { genleamodrm(env, s, modrm); genopldv(s, ot, t0, cpuA0); a0 = tcgtemplocalnew(); tcggenmovtl(a0, cpuA0); } else { genopmovvreg(ot, t0, rm); TCGVUNUSED(a0); } genopmovvreg(ot, t1, reg); tcggenanditl(cputmp0, t0, 3); tcggenanditl(t1, t1, 3); tcggenmovitl(t2, 0); label1 = gennewlabel(); tcggenbrcondtl(TCGCONDGE, cputmp0, t1, label1); tcggenanditl(t0, t0, ~3); tcggenortl(t0, t0, t1); tcggenmovitl(t2, CCZ); gensetlabel(label1); if (mod != 3) { genopstv(s, ot, t0, a0); tcgtempfree(a0); } else { genopmovregv(ot, rm, t0); } gencomputeeflags(s); tcggenanditl(cpuccsrc, cpuccsrc, ~CCZ); tcggenortl(cpuccsrc, cpuccsrc, t2); tcgtempfree(t0); tcgtempfree(t1); tcgtempfree(t2); } break; case 0x102: /* lar */ case 0x103: /* lsl */ { TCGLabel *label1; TCGv t0; if (!s->pe || s->vm86) goto illegalop; ot = dflag != MO16 ? MO32 : MO16; modrm = x86ldubcode(env, s); reg = ((modrm >> 3) & 7) | rexr; genldstmodrm(env, s, modrm, MO16, ORTMP0, 0); t0 = tcgtemplocalnew(); genupdateccop(s); if (b == 0x102) { genhelperlar(t0, cpuenv, cpuT0); } else { genhelperlsl(t0, cpuenv, cpuT0); } tcggenanditl(cputmp0, cpuccsrc, CCZ); label1 = gennewlabel(); tcggenbrconditl(TCGCONDEQ, cputmp0, 0, label1); genopmovregv(ot, reg, t0); gensetlabel(label1); setccop(s, CCOPEFLAGS); tcgtempfree(t0); } break; case 0x118: modrm = x86ldubcode(env, s); mod = (modrm >> 6) & 3; op = (modrm >> 3) & 7; switch(op) { case 0: /* prefetchnta */ case 1: /* prefetchnt0 */ case 2: /* prefetchnt0 */ case 3: /* prefetchnt0 */ if (mod == 3) goto illegalop; gennopmodrm(env, s, modrm); /* nothing more to do */ break; default: /* nop (multi byte) */ gennopmodrm(env, s, modrm); break; } break; case 0x11a: modrm = x86ldubcode(env, s); if (s->flags & HFMPXENMASK) { mod = (modrm >> 6) & 3; reg = ((modrm >> 3) & 7) | rexr; if (prefixes & PREFIXREPZ) { /* bndcl */ if (reg >= 4 || (prefixes & PREFIXLOCK) || s->aflag == MO16) { goto illegalop; } genbndck(env, s, modrm, TCGCONDLTU, cpubndl[reg]); } else if (prefixes & PREFIXREPNZ) { /* bndcu */ if (reg >= 4 || (prefixes & PREFIXLOCK) || s->aflag == MO16) { goto illegalop; } TCGvi64 notu = tcgtempnewi64(); tcggennoti64(notu, cpubndu[reg]); genbndck(env, s, modrm, TCGCONDGTU, notu); tcgtempfreei64(notu); } else if (prefixes & PREFIXDATA) { /* bndmov -- from reg/mem */ if (reg >= 4 || s->aflag == MO16) { goto illegalop; } if (mod == 3) { int reg2 = (modrm & 7) | REXB(s); if (reg2 >= 4 || (prefixes & PREFIXLOCK)) { goto illegalop; } if (s->flags & HFMPXIUMASK) { tcggenmovi64(cpubndl[reg], cpubndl[reg2]); tcggenmovi64(cpubndu[reg], cpubndu[reg2]); } } else { genleamodrm(env, s, modrm); if (CODE64(s)) { tcggenqemuldi64(cpubndl[reg], cpuA0, s->memindex, MOLEQ); tcggenadditl(cpuA0, cpuA0, 8); tcggenqemuldi64(cpubndu[reg], cpuA0, s->memindex, MOLEQ); } else { tcggenqemuldi64(cpubndl[reg], cpuA0, s->memindex, MOLEUL); tcggenadditl(cpuA0, cpuA0, 4); tcggenqemuldi64(cpubndu[reg], cpuA0, s->memindex, MOLEUL); } /* bnd registers are now in-use */ gensethflag(s, HFMPXIUMASK); } } else if (mod != 3) { /* bndldx */ AddressParts a = genleamodrm0(env, s, modrm); if (reg >= 4 || (prefixes & PREFIXLOCK) || s->aflag == MO16 || a.base < -1) { goto illegalop; } if (a.base >= 0) { tcggenadditl(cpuA0, cpuregs[a.base], a.disp); } else { tcggenmovitl(cpuA0, 0); } genleavseg(s, s->aflag, cpuA0, a.defseg, s->override); if (a.index >= 0) { tcggenmovtl(cpuT0, cpuregs[a.index]); } else { tcggenmovitl(cpuT0, 0); } if (CODE64(s)) { genhelperbndldx64(cpubndl[reg], cpuenv, cpuA0, cpuT0); tcggenldi64(cpubndu[reg], cpuenv, offsetof(CPUX86State, mmxt0.MMXQ(0))); } else { genhelperbndldx32(cpubndu[reg], cpuenv, cpuA0, cpuT0); tcggenext32ui64(cpubndl[reg], cpubndu[reg]); tcggenshrii64(cpubndu[reg], cpubndu[reg], 32); } gensethflag(s, HFMPXIUMASK); } } gennopmodrm(env, s, modrm); break; case 0x11b: modrm = x86ldubcode(env, s); if (s->flags & HFMPXENMASK) { mod = (modrm >> 6) & 3; reg = ((modrm >> 3) & 7) | rexr; if (mod != 3 && (prefixes & PREFIXREPZ)) { /* bndmk */ if (reg >= 4 || (prefixes & PREFIXLOCK) || s->aflag == MO16) { goto illegalop; } AddressParts a = genleamodrm0(env, s, modrm); if (a.base >= 0) { tcggenextutli64(cpubndl[reg], cpuregs[a.base]); if (!CODE64(s)) { tcggenext32ui64(cpubndl[reg], cpubndl[reg]); } } else if (a.base == -1) { /* no base register has lower bound of 0 */ tcggenmovii64(cpubndl[reg], 0); } else { /* rip-relative generates #ud */ goto illegalop; } tcggennottl(cpuA0, genleamodrm1(a)); if (!CODE64(s)) { tcggenext32utl(cpuA0, cpuA0); } tcggenextutli64(cpubndu[reg], cpuA0); /* bnd registers are now in-use */ gensethflag(s, HFMPXIUMASK); break; } else if (prefixes & PREFIXREPNZ) { /* bndcn */ if (reg >= 4 || (prefixes & PREFIXLOCK) || s->aflag == MO16) { goto illegalop; } genbndck(env, s, modrm, TCGCONDGTU, cpubndu[reg]); } else if (prefixes & PREFIXDATA) { /* bndmov -- to reg/mem */ if (reg >= 4 || s->aflag == MO16) { goto illegalop; } if (mod == 3) { int reg2 = (modrm & 7) | REXB(s); if (reg2 >= 4 || (prefixes & PREFIXLOCK)) { goto illegalop; } if (s->flags & HFMPXIUMASK) { tcggenmovi64(cpubndl[reg2], cpubndl[reg]); tcggenmovi64(cpubndu[reg2], cpubndu[reg]); } } else { genleamodrm(env, s, modrm); if (CODE64(s)) { tcggenqemusti64(cpubndl[reg], cpuA0, s->memindex, MOLEQ); tcggenadditl(cpuA0, cpuA0, 8); tcggenqemusti64(cpubndu[reg], cpuA0, s->memindex, MOLEQ); } else { tcggenqemusti64(cpubndl[reg], cpuA0, s->memindex, MOLEUL); tcggenadditl(cpuA0, cpuA0, 4); tcggenqemusti64(cpubndu[reg], cpuA0, s->memindex, MOLEUL); } } } else if (mod != 3) { /* bndstx */ AddressParts a = genleamodrm0(env, s, modrm); if (reg >= 4 || (prefixes & PREFIXLOCK) || s->aflag == MO16 || a.base < -1) { goto illegalop; } if (a.base >= 0) { tcggenadditl(cpuA0, cpuregs[a.base], a.disp); } else { tcggenmovitl(cpuA0, 0); } genleavseg(s, s->aflag, cpuA0, a.defseg, s->override); if (a.index >= 0) { tcggenmovtl(cpuT0, cpuregs[a.index]); } else { tcggenmovitl(cpuT0, 0); } if (CODE64(s)) { genhelperbndstx64(cpuenv, cpuA0, cpuT0, cpubndl[reg], cpubndu[reg]); } else { genhelperbndstx32(cpuenv, cpuA0, cpuT0, cpubndl[reg], cpubndu[reg]); } } } gennopmodrm(env, s, modrm); break; case 0x119: case 0x11c ... 0x11f: /* nop (multi byte) */ modrm = x86ldubcode(env, s); gennopmodrm(env, s, modrm); break; case 0x120: /* mov reg, crN */ case 0x122: /* mov crN, reg */ if (s->cpl != 0) { genexception(s, EXCP0DGPF, pcstart - s->csbase); } else { modrm = x86ldubcode(env, s); /* Ignore the mod bits (assume (modrm&0xc0)==0xc0). * AMD documentation (24594.pdf) and testing of * intel 386 and 486 processors all show that the mod bits * are assumed to be 1's, regardless of actual values. */ rm = (modrm & 7) | REXB(s); reg = ((modrm >> 3) & 7) | rexr; if (CODE64(s)) ot = MO64; else ot = MO32; if ((prefixes & PREFIXLOCK) && (reg == 0) && (s->cpuidext3features & CPUIDEXT3CR8LEG)) { reg = 8; } switch(reg) { case 0: case 2: case 3: case 4: case 8: genupdateccop(s); genjmpim(pcstart - s->csbase); if (b & 2) { if (s->base.tb->cflags & CFUSEICOUNT) { geniostart(); } genopmovvreg(ot, cpuT0, rm); genhelperwritecrN(cpuenv, tcgconsti32(reg), cpuT0); if (s->base.tb->cflags & CFUSEICOUNT) { genioend(); } genjmpim(s->pc - s->csbase); geneob(s); } else { if (s->base.tb->cflags & CFUSEICOUNT) { geniostart(); } genhelperreadcrN(cpuT0, cpuenv, tcgconsti32(reg)); genopmovregv(ot, rm, cpuT0); if (s->base.tb->cflags & CFUSEICOUNT) { genioend(); } } break; default: goto unknownop; } } break; case 0x121: /* mov reg, drN */ case 0x123: /* mov drN, reg */ if (s->cpl != 0) { genexception(s, EXCP0DGPF, pcstart - s->csbase); } else { modrm = x86ldubcode(env, s); /* Ignore the mod bits (assume (modrm&0xc0)==0xc0). * AMD documentation (24594.pdf) and testing of * intel 386 and 486 processors all show that the mod bits * are assumed to be 1's, regardless of actual values. */ rm = (modrm & 7) | REXB(s); reg = ((modrm >> 3) & 7) | rexr; if (CODE64(s)) ot = MO64; else ot = MO32; if (reg >= 8) { goto illegalop; } if (b & 2) { gensvmcheckintercept(s, pcstart, SVMEXITWRITEDR0 + reg); genopmovvreg(ot, cpuT0, rm); tcggenmovii32(cputmp2i32, reg); genhelpersetdr(cpuenv, cputmp2i32, cpuT0); genjmpim(s->pc - s->csbase); geneob(s); } else { gensvmcheckintercept(s, pcstart, SVMEXITREADDR0 + reg); tcggenmovii32(cputmp2i32, reg); genhelpergetdr(cpuT0, cpuenv, cputmp2i32); genopmovregv(ot, rm, cpuT0); } } break; case 0x106: /* clts */ if (s->cpl != 0) { genexception(s, EXCP0DGPF, pcstart - s->csbase); } else { gensvmcheckintercept(s, pcstart, SVMEXITWRITECR0); genhelperclts(cpuenv); /* abort block because static cpu state changed */ genjmpim(s->pc - s->csbase); geneob(s); } break; /* MMX/3DNow!/SSE/SSE2/SSE3/SSSE3/SSE4 support */ case 0x1c3: /* MOVNTI reg, mem */ if (!(s->cpuidfeatures & CPUIDSSE2)) goto illegalop; ot = mo6432(dflag); modrm = x86ldubcode(env, s); mod = (modrm >> 6) & 3; if (mod == 3) goto illegalop; reg = ((modrm >> 3) & 7) | rexr; /* generate a generic store */ genldstmodrm(env, s, modrm, ot, reg, 1); break; case 0x1ae: modrm = x86ldubcode(env, s); switch (modrm) { CASEMODRMMEMOP(0): /* fxsave */ if (!(s->cpuidfeatures & CPUIDFXSR) || (prefixes & PREFIXLOCK)) { goto illegalop; } if ((s->flags & HFEMMASK) || (s->flags & HFTSMASK)) { genexception(s, EXCP07PREX, pcstart - s->csbase); break; } genleamodrm(env, s, modrm); genhelperfxsave(cpuenv, cpuA0); break; CASEMODRMMEMOP(1): /* fxrstor */ if (!(s->cpuidfeatures & CPUIDFXSR) || (prefixes & PREFIXLOCK)) { goto illegalop; } if ((s->flags & HFEMMASK) || (s->flags & HFTSMASK)) { genexception(s, EXCP07PREX, pcstart - s->csbase); break; } genleamodrm(env, s, modrm); genhelperfxrstor(cpuenv, cpuA0); break; CASEMODRMMEMOP(2): /* ldmxcsr */ if ((s->flags & HFEMMASK) || !(s->flags & HFOSFXSRMASK)) { goto illegalop; } if (s->flags & HFTSMASK) { genexception(s, EXCP07PREX, pcstart - s->csbase); break; } genleamodrm(env, s, modrm); tcggenqemuldi32(cputmp2i32, cpuA0, s->memindex, MOLEUL); genhelperldmxcsr(cpuenv, cputmp2i32); break; CASEMODRMMEMOP(3): /* stmxcsr */ if ((s->flags & HFEMMASK) || !(s->flags & HFOSFXSRMASK)) { goto illegalop; } if (s->flags & HFTSMASK) { genexception(s, EXCP07PREX, pcstart - s->csbase); break; } genleamodrm(env, s, modrm); tcggenld32utl(cpuT0, cpuenv, offsetof(CPUX86State, mxcsr)); genopstv(s, MO32, cpuT0, cpuA0); break; CASEMODRMMEMOP(4): /* xsave */ if ((s->cpuidextfeatures & CPUIDEXTXSAVE) == 0 || (prefixes & (PREFIXLOCK | PREFIXDATA | PREFIXREPZ | PREFIXREPNZ))) { goto illegalop; } genleamodrm(env, s, modrm); tcggenconcattli64(cputmp1i64, cpuregs[REAX], cpuregs[REDX]); genhelperxsave(cpuenv, cpuA0, cputmp1i64); break; CASEMODRMMEMOP(5): /* xrstor */ if ((s->cpuidextfeatures & CPUIDEXTXSAVE) == 0 || (prefixes & (PREFIXLOCK | PREFIXDATA | PREFIXREPZ | PREFIXREPNZ))) { goto illegalop; } genleamodrm(env, s, modrm); tcggenconcattli64(cputmp1i64, cpuregs[REAX], cpuregs[REDX]); genhelperxrstor(cpuenv, cpuA0, cputmp1i64); /* XRSTOR is how MPX is enabled, which changes how we translate. Thus we need to end the TB. */ genupdateccop(s); genjmpim(s->pc - s->csbase); geneob(s); break; CASEMODRMMEMOP(6): /* xsaveopt / clwb */ if (prefixes & PREFIXLOCK) { goto illegalop; } if (prefixes & PREFIXDATA) { /* clwb */ if (!(s->cpuid70ebxfeatures & CPUID70EBXCLWB)) { goto illegalop; } gennopmodrm(env, s, modrm); } else { /* xsaveopt */ if ((s->cpuidextfeatures & CPUIDEXTXSAVE) == 0 || (s->cpuidxsavefeatures & CPUIDXSAVEXSAVEOPT) == 0 || (prefixes & (PREFIXREPZ | PREFIXREPNZ))) { goto illegalop; } genleamodrm(env, s, modrm); tcggenconcattli64(cputmp1i64, cpuregs[REAX], cpuregs[REDX]); genhelperxsaveopt(cpuenv, cpuA0, cputmp1i64); } break; CASEMODRMMEMOP(7): /* clflush / clflushopt */ if (prefixes & PREFIXLOCK) { goto illegalop; } if (prefixes & PREFIXDATA) { /* clflushopt */ if (!(s->cpuid70ebxfeatures & CPUID70EBXCLFLUSHOPT)) { goto illegalop; } } else { /* clflush */ if ((s->prefix & (PREFIXREPZ | PREFIXREPNZ)) || !(s->cpuidfeatures & CPUIDCLFLUSH)) { goto illegalop; } } gennopmodrm(env, s, modrm); break; case 0xc0 ... 0xc7: /* rdfsbase (f3 0f ae /0) */ case 0xc8 ... 0xcf: /* rdgsbase (f3 0f ae /1) */ case 0xd0 ... 0xd7: /* wrfsbase (f3 0f ae /2) */ case 0xd8 ... 0xdf: /* wrgsbase (f3 0f ae /3) */ if (CODE64(s) && (prefixes & PREFIXREPZ) && !(prefixes & PREFIXLOCK) && (s->cpuid70ebxfeatures & CPUID70EBXFSGSBASE)) { TCGv base, treg, src, dst; /* Preserve hflags bits by testing CR4 at runtime. */ tcggenmovii32(cputmp2i32, CR4FSGSBASEMASK); genhelpercr4testbit(cpuenv, cputmp2i32); base = cpusegbase[modrm & 8 ? RGS : RFS]; treg = cpuregs[(modrm & 7) | REXB(s)]; if (modrm & 0x10) { /* wr*base */ dst = base, src = treg; } else { /* rd*base */ dst = treg, src = base; } if (s->dflag == MO32) { tcggenext32utl(dst, src); } else { tcggenmovtl(dst, src); } break; } goto unknownop; case 0xf8: /* sfence / pcommit */ if (prefixes & PREFIXDATA) { /* pcommit */ if (!(s->cpuid70ebxfeatures & CPUID70EBXPCOMMIT) || (prefixes & PREFIXLOCK)) { goto illegalop; } break; } /* fallthru */ case 0xf9 ... 0xff: /* sfence */ if (!(s->cpuidfeatures & CPUIDSSE) || (prefixes & PREFIXLOCK)) { goto illegalop; } tcggenmb(TCGMOSTST | TCGBARSC); break; case 0xe8 ... 0xef: /* lfence */ if (!(s->cpuidfeatures & CPUIDSSE) || (prefixes & PREFIXLOCK)) { goto illegalop; } tcggenmb(TCGMOLDLD | TCGBARSC); break; case 0xf0 ... 0xf7: /* mfence */ if (!(s->cpuidfeatures & CPUIDSSE2) || (prefixes & PREFIXLOCK)) { goto illegalop; } tcggenmb(TCGMOALL | TCGBARSC); break; default: goto unknownop; } break; case 0x10d: /* 3DNow! prefetch(w) */ modrm = x86ldubcode(env, s); mod = (modrm >> 6) & 3; if (mod == 3) goto illegalop; gennopmodrm(env, s, modrm); break; case 0x1aa: /* rsm */ gensvmcheckintercept(s, pcstart, SVMEXITRSM); if (!(s->flags & HFSMMMASK)) goto illegalop; genupdateccop(s); genjmpim(s->pc - s->csbase); genhelperrsm(cpuenv); geneob(s); break; case 0x1b8: /* SSE4.2 popcnt */ if ((prefixes & (PREFIXREPZ | PREFIXLOCK | PREFIXREPNZ)) != PREFIXREPZ) goto illegalop; if (!(s->cpuidextfeatures & CPUIDEXTPOPCNT)) goto illegalop; modrm = x86ldubcode(env, s); reg = ((modrm >> 3) & 7) | rexr; if (s->prefix & PREFIXDATA) { ot = MO16; } else { ot = mo6432(dflag); } genldstmodrm(env, s, modrm, ot, ORTMP0, 0); genextu(ot, cpuT0); tcggenmovtl(cpuccsrc, cpuT0); tcggenctpoptl(cpuT0, cpuT0); genopmovregv(ot, reg, cpuT0); setccop(s, CCOPPOPCNT); break; case 0x10e ... 0x10f: /* 3DNow! instructions, ignore prefixes */ s->prefix &= ~(PREFIXREPZ | PREFIXREPNZ | PREFIXDATA); case 0x110 ... 0x117: case 0x128 ... 0x12f: case 0x138 ... 0x13a: case 0x150 ... 0x179: case 0x17c ... 0x17f: case 0x1c2: case 0x1c4 ... 0x1c6: case 0x1d0 ... 0x1fe: gensse(env, s, b, pcstart, rexr); break; default: goto unknownop; } return s->pc; illegalop: genillegalopcode(s); return s->pc; unknownop: genunknownopcode(env, s); return s->pc; } ", "target": 1}
{"func": "static int iscsiopen(BlockDriverState *bs, const char *filename, int flags) { IscsiLun *iscsilun = bs->opaque; struct iscsicontext *iscsi = NULL; struct iscsiurl *iscsiurl = NULL; struct IscsiTask task; char *initiatorname = NULL; int ret; if ((BDRVSECTORSIZE % 512) != 0) { errorreport(\"iSCSI: Invalid BDRVSECTORSIZE. \" \"BDRVSECTORSIZE(%lld) is not a multiple \" \"of 512\", BDRVSECTORSIZE); return -EINVAL; } iscsiurl = iscsiparsefullurl(iscsi, filename); if (iscsiurl == NULL) { errorreport(\"Failed to parse URL : %s %s\", filename, iscsigeterror(iscsi)); ret = -EINVAL; goto failed; } memset(iscsilun, 0, sizeof(IscsiLun)); initiatorname = parseinitiatorname(iscsiurl->target); iscsi = iscsicreatecontext(initiatorname); if (iscsi == NULL) { errorreport(\"iSCSI: Failed to create iSCSI context.\"); ret = -ENOMEM; goto failed; } if (iscsisettargetname(iscsi, iscsiurl->target)) { errorreport(\"iSCSI: Failed to set target name.\"); ret = -EINVAL; goto failed; } if (iscsiurl->user != NULL) { ret = iscsisetinitiatorusernamepwd(iscsi, iscsiurl->user, iscsiurl->passwd); if (ret != 0) { errorreport(\"Failed to set initiator username and password\"); ret = -EINVAL; goto failed; } } /* check if we got CHAP username/password via the options */ if (parsechap(iscsi, iscsiurl->target) != 0) { errorreport(\"iSCSI: Failed to set CHAP user/password\"); ret = -EINVAL; goto failed; } if (iscsisetsessiontype(iscsi, ISCSISESSIONNORMAL) != 0) { errorreport(\"iSCSI: Failed to set session type to normal.\"); ret = -EINVAL; goto failed; } iscsisetheaderdigest(iscsi, ISCSIHEADERDIGESTNONECRC32C); /* check if we got HEADERDIGEST via the options */ parseheaderdigest(iscsi, iscsiurl->target); task.iscsilun = iscsilun; task.status = 0; task.complete = 0; task.bs = bs; iscsilun->iscsi = iscsi; iscsilun->lun = iscsiurl->lun; if (iscsifullconnectasync(iscsi, iscsiurl->portal, iscsiurl->lun, iscsiconnectcb, &task) != 0) { errorreport(\"iSCSI: Failed to start async connect.\"); ret = -EINVAL; goto failed; } while (!task.complete) { iscsisetevents(iscsilun); qemuaiowait(); } if (task.status != 0) { errorreport(\"iSCSI: Failed to connect to LUN : %s\", iscsigeterror(iscsi)); ret = -EINVAL; goto failed; } if (iscsiurl != NULL) { iscsidestroyurl(iscsiurl); } /* Medium changer or tape. We dont have any emulation for this so this must * be sg ioctl compatible. We force it to be sg, otherwise qemu will try * to read from the device to guess the image format. */ if (iscsilun->type == TYPEMEDIUMCHANGER || iscsilun->type == TYPETAPE) { bs->sg = 1; } return 0; failed: if (initiatorname != NULL) { gfree(initiatorname); } if (iscsiurl != NULL) { iscsidestroyurl(iscsiurl); } if (iscsi != NULL) { iscsidestroycontext(iscsi); } memset(iscsilun, 0, sizeof(IscsiLun)); return ret; } ", "target": 1}
{"func": "static void vmxnet3rxneedcsumcalculate(struct VmxnetRxPkt *pkt, const void *pktdata, sizet pktlen) { struct virtionethdr *vhdr; bool isip4, isip6, istcp, isudp; uint8t *data; int len; if (!vmxnetrxpkthasvirthdr(pkt)) { return; } vhdr = vmxnetrxpktgetvhdr(pkt); if (!VMXNETFLAGISSET(vhdr->flags, VIRTIONETHDRFNEEDSCSUM)) { return; } vmxnetrxpktgetprotocols(pkt, &isip4, &isip6, &isudp, &istcp); if (!(isip4 || isip6) || !(istcp || isudp)) { return; } vmxnet3dumpvirthdr(vhdr); /* Validate packet len: csumstart + scumoffset + length of csum field */ if (pktlen < (vhdr->csumstart + vhdr->csumoffset + 2)) { VMWPKPRN(\"packet len:%d < csumstart(%d) + csumoffset(%d) + 2, \" \"cannot calculate checksum\", len, vhdr->csumstart, vhdr->csumoffset); return; } data = (uint8t *)pktdata + vhdr->csumstart; len = pktlen - vhdr->csumstart; /* Put the checksum obtained into the packet */ stwbep(data + vhdr->csumoffset, netrawchecksum(data, len)); vhdr->flags &= ~VIRTIONETHDRFNEEDSCSUM; vhdr->flags |= VIRTIONETHDRFDATAVALID; } ", "target": 1}
{"func": "CommandInfoList *qmpquerycommands(Error **errp) { CommandInfoList *list = NULL; qmpforeachcommand(&qmpcommands, querycommandscb, &list); return list; } ", "target": 1}
{"func": "static int decodeblocks(ALSDecContext *ctx, unsigned int raframe, unsigned int c, const unsigned int *divblocks, unsigned int *jsblocks) { ALSSpecificConfig *sconf = &ctx->sconf; unsigned int offset = 0; unsigned int b; ALSBlockData bd[2] = { { 0 } }; bd[0].rablock = raframe; bd[0].constblock = ctx->constblock; bd[0].shiftlsbs = ctx->shiftlsbs; bd[0].optorder = ctx->optorder; bd[0].storeprevsamples = ctx->storeprevsamples; bd[0].useltp = ctx->useltp; bd[0].ltplag = ctx->ltplag; bd[0].ltpgain = ctx->ltpgain[0]; bd[0].quantcof = ctx->quantcof[0]; bd[0].lpccof = ctx->lpccof[0]; bd[0].prevrawsamples = ctx->prevrawsamples; bd[0].jsblocks = *jsblocks; bd[1].rablock = raframe; bd[1].constblock = ctx->constblock; bd[1].shiftlsbs = ctx->shiftlsbs; bd[1].optorder = ctx->optorder; bd[1].storeprevsamples = ctx->storeprevsamples; bd[1].useltp = ctx->useltp; bd[1].ltplag = ctx->ltplag; bd[1].ltpgain = ctx->ltpgain[0]; bd[1].quantcof = ctx->quantcof[0]; bd[1].lpccof = ctx->lpccof[0]; bd[1].prevrawsamples = ctx->prevrawsamples; bd[1].jsblocks = *(jsblocks + 1); // decode all blocks for (b = 0; b < ctx->numblocks; b++) { unsigned int s; bd[0].blocklength = divblocks[b]; bd[1].blocklength = divblocks[b]; bd[0].rawsamples = ctx->rawsamples[c ] + offset; bd[1].rawsamples = ctx->rawsamples[c + 1] + offset; bd[0].rawother = bd[1].rawsamples; bd[1].rawother = bd[0].rawsamples; if(readdecodeblock(ctx, &bd[0]) || readdecodeblock(ctx, &bd[1])) { // damaged block, write zero for the rest of the frame zeroremaining(b, ctx->numblocks, divblocks, bd[0].rawsamples); zeroremaining(b, ctx->numblocks, divblocks, bd[1].rawsamples); return -1; } // reconstruct joint-stereo blocks if (bd[0].jsblocks) { if (bd[1].jsblocks) avlog(ctx->avctx, AVLOGWARNING, \"Invalid channel pair!\\n\"); for (s = 0; s < divblocks[b]; s++) bd[0].rawsamples[s] = bd[1].rawsamples[s] - bd[0].rawsamples[s]; } else if (bd[1].jsblocks) { for (s = 0; s < divblocks[b]; s++) bd[1].rawsamples[s] = bd[1].rawsamples[s] + bd[0].rawsamples[s]; } offset += divblocks[b]; bd[0].rablock = 0; bd[1].rablock = 0; } // store carryover raw samples, // the others channel raw samples are stored by the calling function. memmove(ctx->rawsamples[c] - sconf->maxorder, ctx->rawsamples[c] - sconf->maxorder + sconf->framelength, sizeof(*ctx->rawsamples[c]) * sconf->maxorder); return 0; } ", "target": 1}
{"func": "static int writef(int argc, char **argv) { struct timeval t1, t2; int Cflag = 0, pflag = 0, qflag = 0, bflag = 0; int c, cnt; char *buf; int64t offset; int count; /* Some compilers get confused and warn if this is not initialized. */ int total = 0; int pattern = 0xcd; while ((c = getopt(argc, argv, \"bCpP:q\")) != EOF) { switch (c) { case 'b': bflag = 1; break; case 'C': Cflag = 1; break; case 'p': pflag = 1; break; case 'P': pattern = parsepattern(optarg); if (pattern < 0) { return 0; } break; case 'q': qflag = 1; break; default: return commandusage(&writecmd); } } if (optind != argc - 2) { return commandusage(&writecmd); } if (bflag && pflag) { printf(\"-b and -p cannot be specified at the same time\\n\"); return 0; } offset = cvtnum(argv[optind]); if (offset < 0) { printf(\"non-numeric length argument -- %s\\n\", argv[optind]); return 0; } optind++; count = cvtnum(argv[optind]); if (count < 0) { printf(\"non-numeric length argument -- %s\\n\", argv[optind]); return 0; } if (!pflag) { if (offset & 0x1ff) { printf(\"offset %\" PRId64 \" is not sector aligned\\n\", offset); return 0; } if (count & 0x1ff) { printf(\"count %d is not sector aligned\\n\", count); return 0; } } buf = qemuioalloc(count, pattern); gettimeofday(&t1, NULL); if (pflag) { cnt = dopwrite(buf, offset, count, &total); } else if (bflag) { cnt = dosavevmstate(buf, offset, count, &total); } else { cnt = dowrite(buf, offset, count, &total); } gettimeofday(&t2, NULL); if (cnt < 0) { printf(\"write failed: %s\\n\", strerror(-cnt)); goto out; } if (qflag) { goto out; } /* Finally, report back -- -C gives a parsable format */ t2 = tsub(t2, t1); printreport(\"wrote\", &t2, offset, count, total, cnt, Cflag); out: qemuiofree(buf); return 0; } ", "target": 0}
{"func": "static int libopenjpegcopypacked12(AVCodecContext *avctx, const AVFrame *frame, opjimaget *image) { int compno; int x, y; int *imageline; int frameindex; const int numcomps = image->numcomps; uint16t *frameptr = (uint16t *)frame->data[0]; for (compno = 0; compno < numcomps; ++compno) { if (image->comps[compno].w > frame->linesize[0] / numcomps) { avlog(avctx, AVLOGERROR, \"Error: frame's linesize is too small for the image\\n\"); return 0; } } for (compno = 0; compno < numcomps; ++compno) { for (y = 0; y < avctx->height; ++y) { imageline = image->comps[compno].data + y * image->comps[compno].w; frameindex = y * (frame->linesize[0] / 2) + compno; for (x = 0; x < avctx->width; ++x) { imageline[x] = frameptr[frameindex] >> 4; frameindex += numcomps; } for (; x < image->comps[compno].w; ++x) { imageline[x] = imageline[x - 1]; } } for (; y < image->comps[compno].h; ++y) { imageline = image->comps[compno].data + y * image->comps[compno].w; for (x = 0; x < image->comps[compno].w; ++x) { imageline[x] = imageline[x - image->comps[compno].w]; } } } return 1; } ", "target": 1}
{"func": "static void buildfeedstreams(void) { FFStream *stream, *feed; int i; /* gather all streams */ for(stream = firststream; stream != NULL; stream = stream->next) { feed = stream->feed; if (feed) { if (!stream->isfeed) { /* we handle a stream coming from a feed */ for(i=0;i<stream->nbstreams;i++) stream->feedstreams[i] = addavstream(feed, stream->streams[i]); } } } /* gather all streams */ for(stream = firststream; stream != NULL; stream = stream->next) { feed = stream->feed; if (feed) { if (stream->isfeed) { for(i=0;i<stream->nbstreams;i++) stream->feedstreams[i] = i; } } } /* create feed files if needed */ for(feed = firstfeed; feed != NULL; feed = feed->nextfeed) { int fd; if (urlexist(feed->feedfilename)) { /* See if it matches */ AVFormatContext *s; int matches = 0; if (avopeninputfile(&s, feed->feedfilename, NULL, FFMPACKETSIZE, NULL) >= 0) { /* Now see if it matches */ if (s->nbstreams == feed->nbstreams) { matches = 1; for(i=0;i<s->nbstreams;i++) { AVStream *sf, *ss; sf = feed->streams[i]; ss = s->streams[i]; if (sf->index != ss->index || sf->id != ss->id) { httplog(\"Index & Id do not match for stream %d (%s)\\n\", i, feed->feedfilename); matches = 0; } else { AVCodecContext *ccf, *ccs; ccf = sf->codec; ccs = ss->codec; #define CHECKCODEC(x) (ccf->x != ccs->x) if (CHECKCODEC(codecid) || CHECKCODEC(codectype)) { httplog(\"Codecs do not match for stream %d\\n\", i); matches = 0; } else if (CHECKCODEC(bitrate) || CHECKCODEC(flags)) { httplog(\"Codec bitrates do not match for stream %d\\n\", i); matches = 0; } else if (ccf->codectype == AVMEDIATYPEVIDEO) { if (CHECKCODEC(timebase.den) || CHECKCODEC(timebase.num) || CHECKCODEC(width) || CHECKCODEC(height)) { httplog(\"Codec width, height and framerate do not match for stream %d\\n\", i); matches = 0; } } else if (ccf->codectype == AVMEDIATYPEAUDIO) { if (CHECKCODEC(samplerate) || CHECKCODEC(channels) || CHECKCODEC(framesize)) { httplog(\"Codec samplerate, channels, framesize do not match for stream %d\\n\", i); matches = 0; } } else { httplog(\"Unknown codec type\\n\"); matches = 0; } } if (!matches) break; } } else httplog(\"Deleting feed file '%s' as stream counts differ (%d != %d)\\n\", feed->feedfilename, s->nbstreams, feed->nbstreams); avcloseinputfile(s); } else httplog(\"Deleting feed file '%s' as it appears to be corrupt\\n\", feed->feedfilename); if (!matches) { if (feed->readonly) { httplog(\"Unable to delete feed file '%s' as it is marked readonly\\n\", feed->feedfilename); exit(1); } unlink(feed->feedfilename); } } if (!urlexist(feed->feedfilename)) { AVFormatContext s1 = {0}, *s = &s1; if (feed->readonly) { httplog(\"Unable to create feed file '%s' as it is marked readonly\\n\", feed->feedfilename); exit(1); } /* only write the header of the ffm file */ if (avioopen(&s->pb, feed->feedfilename, AVIOFLAGWRITE) < 0) { httplog(\"Could not open output feed file '%s'\\n\", feed->feedfilename); exit(1); } s->oformat = feed->fmt; s->nbstreams = feed->nbstreams; for(i=0;i<s->nbstreams;i++) { AVStream *st; st = feed->streams[i]; s->streams[i] = st; } avsetparameters(s, NULL); if (avwriteheader(s) < 0) { httplog(\"Container doesn't supports the required parameters\\n\"); exit(1); } /* XXX: need better api */ avfreep(&s->privdata); avioclose(s->pb); } /* get feed size and write index */ fd = open(feed->feedfilename, ORDONLY); if (fd < 0) { httplog(\"Could not open output feed file '%s'\\n\", feed->feedfilename); exit(1); } feed->feedwriteindex = FFMAX(ffmreadwriteindex(fd), FFMPACKETSIZE); feed->feedsize = lseek(fd, 0, SEEKEND); /* ensure that we do not wrap before the end of file */ if (feed->feedmaxsize && feed->feedmaxsize < feed->feedsize) feed->feedmaxsize = feed->feedsize; close(fd); } } ", "target": 0}
{"func": "static void dointerrupt64(CPUX86State *env, int intno, int isint, int errorcode, targetulong nexteip, int ishw) { SegmentCache *dt; targetulong ptr; int type, dpl, selector, cpl, ist; int haserrorcode, newstack; uint32t e1, e2, e3, ss; targetulong oldeip, esp, offset; haserrorcode = 0; if (!isint && !ishw) { haserrorcode = exceptionhaserrorcode(intno); } if (isint) { oldeip = nexteip; } else { oldeip = env->eip; } dt = &env->idt; if (intno * 16 + 15 > dt->limit) { raiseexceptionerr(env, EXCP0DGPF, intno * 16 + 2); } ptr = dt->base + intno * 16; e1 = cpuldlkernel(env, ptr); e2 = cpuldlkernel(env, ptr + 4); e3 = cpuldlkernel(env, ptr + 8); /* check gate type */ type = (e2 >> DESCTYPESHIFT) & 0x1f; switch (type) { case 14: /* 386 interrupt gate */ case 15: /* 386 trap gate */ break; default: raiseexceptionerr(env, EXCP0DGPF, intno * 16 + 2); break; } dpl = (e2 >> DESCDPLSHIFT) & 3; cpl = env->hflags & HFCPLMASK; /* check privilege if software int */ if (isint && dpl < cpl) { raiseexceptionerr(env, EXCP0DGPF, intno * 16 + 2); } /* check valid bit */ if (!(e2 & DESCPMASK)) { raiseexceptionerr(env, EXCP0BNOSEG, intno * 16 + 2); } selector = e1 >> 16; offset = ((targetulong)e3 << 32) | (e2 & 0xffff0000) | (e1 & 0x0000ffff); ist = e2 & 7; if ((selector & 0xfffc) == 0) { raiseexceptionerr(env, EXCP0DGPF, 0); } if (loadsegment(env, &e1, &e2, selector) != 0) { raiseexceptionerr(env, EXCP0DGPF, selector & 0xfffc); } if (!(e2 & DESCSMASK) || !(e2 & (DESCCSMASK))) { raiseexceptionerr(env, EXCP0DGPF, selector & 0xfffc); } dpl = (e2 >> DESCDPLSHIFT) & 3; if (dpl > cpl) { raiseexceptionerr(env, EXCP0DGPF, selector & 0xfffc); } if (!(e2 & DESCPMASK)) { raiseexceptionerr(env, EXCP0BNOSEG, selector & 0xfffc); } if (!(e2 & DESCLMASK) || (e2 & DESCBMASK)) { raiseexceptionerr(env, EXCP0DGPF, selector & 0xfffc); } if ((!(e2 & DESCCMASK) && dpl < cpl) || ist != 0) { /* to inner privilege */ newstack = 1; esp = getrspfromtss(env, ist != 0 ? ist + 3 : dpl); ss = 0; } else if ((e2 & DESCCMASK) || dpl == cpl) { /* to same privilege */ if (env->eflags & VMMASK) { raiseexceptionerr(env, EXCP0DGPF, selector & 0xfffc); } newstack = 0; esp = env->regs[RESP]; dpl = cpl; } else { raiseexceptionerr(env, EXCP0DGPF, selector & 0xfffc); newstack = 0; /* avoid warning */ esp = 0; /* avoid warning */ } esp &= ~0xfLL; /* align stack */ PUSHQ(esp, env->segs[RSS].selector); PUSHQ(esp, env->regs[RESP]); PUSHQ(esp, cpucomputeeflags(env)); PUSHQ(esp, env->segs[RCS].selector); PUSHQ(esp, oldeip); if (haserrorcode) { PUSHQ(esp, errorcode); } /* interrupt gate clear IF mask */ if ((type & 1) == 0) { env->eflags &= ~IFMASK; } env->eflags &= ~(TFMASK | VMMASK | RFMASK | NTMASK); if (newstack) { ss = 0 | dpl; cpux86loadsegcache(env, RSS, ss, 0, 0, 0); } env->regs[RESP] = esp; selector = (selector & ~3) | dpl; cpux86loadsegcache(env, RCS, selector, getsegbase(e1, e2), getseglimit(e1, e2), e2); env->eip = offset; } ", "target": 1}
{"func": "void palette8tobgr24(const uint8t *src, uint8t *dst, long numpixels, const uint8t *palette) { \tlong i; /* \twrites 1 byte o much and might cause alignment issues on some architectures? \tfor(i=0; i<numpixels; i++) \t\t((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ]; */ \tfor(i=0; i<numpixels; i++) \t{ \t\t//FIXME slow? \t\tdst[0]= palette[ src[i]*4+0 ]; \t\tdst[1]= palette[ src[i]*4+1 ]; \t\tdst[2]= palette[ src[i]*4+2 ]; \t\tdst+= 3; \t} } ", "target": 1}
{"func": "static inline void codeblock(DiracContext *s, SubBand *b, GetBitContext *gb, DiracArith *c, int left, int right, int top, int bottom, int blockcntone, int isarith) { int x, y, zeroblock; int qoffset, qfactor; IDWTELEM *buf; /* check for any coded coefficients in this codeblock */ if (!blockcntone) { if (isarith) zeroblock = diracgetarithbit(c, CTXZEROBLOCK); else zeroblock = getbits1(gb); if (zeroblock) return; } if (s->codeblockmode && !(s->olddeltaquant && blockcntone)) { if (isarith) b->quant += diracgetarithint(c, CTXDELTAQF, CTXDELTAQDATA); else b->quant += diracgetsegolomb(gb); } b->quant = FFMIN(b->quant, MAXQUANT); qfactor = qscaletab[b->quant]; /* TODO: context pointer? */ if (!s->numrefs) qoffset = qoffsetintratab[b->quant]; else qoffset = qoffsetintertab[b->quant]; buf = b->ibuf + top * b->stride; for (y = top; y < bottom; y++) { for (x = left; x < right; x++) { /* [DIRACSTD] 13.4.4 Subband coefficients. coeffunpack() */ if (isarith) coeffunpackarith(c, qfactor, qoffset, b, buf+x, x, y); else buf[x] = coeffunpackgolomb(gb, qfactor, qoffset); } buf += b->stride; } } ", "target": 0}
{"func": "static int encodeframe(AVCodecContext *avctx, unsigned char *buf, int bufsize, void *data){ FFV1Context *f = avctx->privdata; CABACContext * const c= &f->c; AVFrame *pict = data; const int width= f->width; const int height= f->height; AVFrame * const p= &f->picture; int usedcount= 0; if(avctx->strictstdcompliance >= 0){ avlog(avctx, AVLOGERROR, \"this codec is under development, files encoded with it wont be decodeable with future versions!!!\\n\" \"use vstrict=-1 to use it anyway\\n\"); return -1; } ffinitcabacencoder(c, buf, bufsize); ffinitcabacstates(c, ffh264lpsrange, ffh264mpsstate, ffh264lpsstate, 64); c->lpsstate[2] = 1; c->lpsstate[3] = 0; *p = *pict; p->picttype= FFITYPE; if(avctx->gopsize==0 || f->picturenumber % avctx->gopsize == 0){ putcabacbypass(c, 1); p->keyframe= 1; writeheader(f); clearstate(f); }else{ putcabacbypass(c, 0); p->keyframe= 0; } if(!f->ac){ usedcount += putcabacterminate(c, 1); //printf(\"pos=%d\\n\", usedcount); initputbits(&f->pb, buf + usedcount, bufsize - usedcount); } if(f->colorspace==0){ const int chromawidth = -((-width )>>f->chromahshift); const int chromaheight= -((-height)>>f->chromavshift); encodeplane(f, p->data[0], width, height, p->linesize[0], 0); encodeplane(f, p->data[1], chromawidth, chromaheight, p->linesize[1], 1); encodeplane(f, p->data[2], chromawidth, chromaheight, p->linesize[2], 1); }else{ encodergbframe(f, (uint32t*)(p->data[0]), width, height, p->linesize[0]/4); } emmsc(); f->picturenumber++; if(f->ac){ return putcabacterminate(c, 1); }else{ flushputbits(&f->pb); //nicer padding FIXME return usedcount + (putbitscount(&f->pb)+7)/8; } } ", "target": 1}
{"func": "void doPOWERmaskg (void) { uint32t ret; if ((uint32t)T0 == (uint32t)(T1 + 1)) { ret = -1; } else { ret = (((uint32t)(-1)) >> ((uint32t)T0)) ^ (((uint32t)(-1) >> ((uint32t)T1)) >> 1); if ((uint32t)T0 > (uint32t)T1) ret = ~ret; } T0 = ret; } ", "target": 1}
{"func": "static void qedaioreaddata(void *opaque, int ret, uint64t offset, sizet len) { QEDAIOCB *acb = opaque; BDRVQEDState *s = acbtos(acb); BlockDriverState *bs = acb->common.bs; /* Adjust offset into cluster */ offset += qedoffsetintocluster(s, acb->curpos); traceqedaioreaddata(s, acb, ret, offset, len); if (ret < 0) { goto err; } qemuiovecconcat(&acb->curqiov, acb->qiov, acb->qiovoffset, len); /* Handle zero cluster and backing file reads */ if (ret == QEDCLUSTERZERO) { qemuiovecmemset(&acb->curqiov, 0, 0, acb->curqiov.size); qedaionextio(acb, 0); return; } else if (ret != QEDCLUSTERFOUND) { qedreadbackingfile(s, acb->curpos, &acb->curqiov, qedaionextio, acb); return; } BLKDBGEVENT(bs->file, BLKDBGREADAIO); bdrvaioreadv(bs->file, offset / BDRVSECTORSIZE, &acb->curqiov, acb->curqiov.size / BDRVSECTORSIZE, qedaionextio, acb); return; err: qedaiocomplete(acb, ret); } ", "target": 1}
{"func": "int qcow2updateheader(BlockDriverState *bs) { BDRVQcowState *s = bs->opaque; QCowHeader *header; char *buf; sizet buflen = s->clustersize; int ret; uint64t totalsize; uint32t refcounttableclusters; sizet headerlength; Qcow2UnknownHeaderExtension *uext; buf = qemublockalign(bs, buflen); /* Header structure */ header = (QCowHeader*) buf; if (buflen < sizeof(*header)) { ret = -ENOSPC; goto fail; } headerlength = sizeof(*header) + s->unknownheaderfieldssize; totalsize = bs->totalsectors * BDRVSECTORSIZE; refcounttableclusters = s->refcounttablesize >> (s->clusterbits - 3); *header = (QCowHeader) { /* Version 2 fields */ .magic = cputobe32(QCOWMAGIC), .version = cputobe32(s->qcowversion), .backingfileoffset = 0, .backingfilesize = 0, .clusterbits = cputobe32(s->clusterbits), .size = cputobe64(totalsize), .cryptmethod = cputobe32(s->cryptmethodheader), .l1size = cputobe32(s->l1size), .l1tableoffset = cputobe64(s->l1tableoffset), .refcounttableoffset = cputobe64(s->refcounttableoffset), .refcounttableclusters = cputobe32(refcounttableclusters), .nbsnapshots = cputobe32(s->nbsnapshots), .snapshotsoffset = cputobe64(s->snapshotsoffset), /* Version 3 fields */ .incompatiblefeatures = cputobe64(s->incompatiblefeatures), .compatiblefeatures = cputobe64(s->compatiblefeatures), .autoclearfeatures = cputobe64(s->autoclearfeatures), .refcountorder = cputobe32(3 + REFCOUNTSHIFT), .headerlength = cputobe32(headerlength), }; /* For older versions, write a shorter header */ switch (s->qcowversion) { case 2: ret = offsetof(QCowHeader, incompatiblefeatures); break; case 3: ret = sizeof(*header); break; default: return -EINVAL; } buf += ret; buflen -= ret; memset(buf, 0, buflen); /* Preserve any unknown field in the header */ if (s->unknownheaderfieldssize) { if (buflen < s->unknownheaderfieldssize) { ret = -ENOSPC; goto fail; } memcpy(buf, s->unknownheaderfields, s->unknownheaderfieldssize); buf += s->unknownheaderfieldssize; buflen -= s->unknownheaderfieldssize; } /* Backing file format header extension */ if (*bs->backingformat) { ret = headerextadd(buf, QCOW2EXTMAGICBACKINGFORMAT, bs->backingformat, strlen(bs->backingformat), buflen); if (ret < 0) { goto fail; } buf += ret; buflen -= ret; } /* Feature table */ Qcow2Feature features[] = { /* no feature defined yet */ }; ret = headerextadd(buf, QCOW2EXTMAGICFEATURETABLE, features, sizeof(features), buflen); if (ret < 0) { goto fail; } buf += ret; buflen -= ret; /* Keep unknown header extensions */ QLISTFOREACH(uext, &s->unknownheaderext, next) { ret = headerextadd(buf, uext->magic, uext->data, uext->len, buflen); if (ret < 0) { goto fail; } buf += ret; buflen -= ret; } /* End of header extensions */ ret = headerextadd(buf, QCOW2EXTMAGICEND, NULL, 0, buflen); if (ret < 0) { goto fail; } buf += ret; buflen -= ret; /* Backing file name */ if (*bs->backingfile) { sizet backingfilelen = strlen(bs->backingfile); if (buflen < backingfilelen) { ret = -ENOSPC; goto fail; } strncpy(buf, bs->backingfile, buflen); header->backingfileoffset = cputobe64(buf - ((char*) header)); header->backingfilesize = cputobe32(backingfilelen); } /* Write the new header */ ret = bdrvpwrite(bs->file, 0, header, s->clustersize); if (ret < 0) { goto fail; } ret = 0; fail: qemuvfree(header); return ret; } ", "target": 1}
{"func": "void tcpstartincomingmigration(const char *hostport, Error **errp) { int s; s = inetlisten(hostport, NULL, 256, SOCKSTREAM, 0, errp); if (s < 0) { return; } qemusetfdhandler2(s, NULL, tcpacceptincomingmigration, NULL, (void *)(intptrt)s); } ", "target": 1}
{"func": "static int spaprpopulatepcichilddt(PCIDevice *dev, void *fdt, int offset, sPAPRPHBState *sphb) { ResourceProps rp; bool isbridge = false; int pcistatus, err; char *buf = NULL; uint32t drcindex = spaprphbgetpcidrcindex(sphb, dev); uint32t ccode = pcidefaultreadconfig(dev, PCICLASSPROG, 3); uint32t maxmsi, maxmsix; if (pcidefaultreadconfig(dev, PCIHEADERTYPE, 1) == PCIHEADERTYPEBRIDGE) { isbridge = true; } /* in accordance with PAPR+ v2.7 13.6.3, Table 181 */ FDT(fdtsetpropcell(fdt, offset, \"vendor-id\", pcidefaultreadconfig(dev, PCIVENDORID, 2))); FDT(fdtsetpropcell(fdt, offset, \"device-id\", pcidefaultreadconfig(dev, PCIDEVICEID, 2))); FDT(fdtsetpropcell(fdt, offset, \"revision-id\", pcidefaultreadconfig(dev, PCIREVISIONID, 1))); FDT(fdtsetpropcell(fdt, offset, \"class-code\", ccode)); if (pcidefaultreadconfig(dev, PCIINTERRUPTPIN, 1)) { FDT(fdtsetpropcell(fdt, offset, \"interrupts\", pcidefaultreadconfig(dev, PCIINTERRUPTPIN, 1))); } if (!isbridge) { FDT(fdtsetpropcell(fdt, offset, \"min-grant\", pcidefaultreadconfig(dev, PCIMINGNT, 1))); FDT(fdtsetpropcell(fdt, offset, \"max-latency\", pcidefaultreadconfig(dev, PCIMAXLAT, 1))); } if (pcidefaultreadconfig(dev, PCISUBSYSTEMID, 2)) { FDT(fdtsetpropcell(fdt, offset, \"subsystem-id\", pcidefaultreadconfig(dev, PCISUBSYSTEMID, 2))); } if (pcidefaultreadconfig(dev, PCISUBSYSTEMVENDORID, 2)) { FDT(fdtsetpropcell(fdt, offset, \"subsystem-vendor-id\", pcidefaultreadconfig(dev, PCISUBSYSTEMVENDORID, 2))); } FDT(fdtsetpropcell(fdt, offset, \"cache-line-size\", pcidefaultreadconfig(dev, PCICACHELINESIZE, 1))); /* the following fdt cells are masked off the pci status register */ pcistatus = pcidefaultreadconfig(dev, PCISTATUS, 2); FDT(fdtsetpropcell(fdt, offset, \"devsel-speed\", PCISTATUSDEVSELMASK & pcistatus)); if (pcistatus & PCISTATUSFASTBACK) { FDT(fdtsetprop(fdt, offset, \"fast-back-to-back\", NULL, 0)); } if (pcistatus & PCISTATUS66MHZ) { FDT(fdtsetprop(fdt, offset, \"66mhz-capable\", NULL, 0)); } if (pcistatus & PCISTATUSUDF) { FDT(fdtsetprop(fdt, offset, \"udf-supported\", NULL, 0)); } FDT(fdtsetpropstring(fdt, offset, \"name\", pcifinddevicename((ccode >> 16) & 0xff, (ccode >> 8) & 0xff, ccode & 0xff))); buf = spaprphbgetloccode(sphb, dev); if (!buf) { errorreport(\"Failed setting the ibm,loc-code\"); return -1; } err = fdtsetpropstring(fdt, offset, \"ibm,loc-code\", buf); gfree(buf); if (err < 0) { return err; } if (drcindex) { FDT(fdtsetpropcell(fdt, offset, \"ibm,my-drc-index\", drcindex)); } FDT(fdtsetpropcell(fdt, offset, \"#address-cells\", RESOURCECELLSADDRESS)); FDT(fdtsetpropcell(fdt, offset, \"#size-cells\", RESOURCECELLSSIZE)); maxmsi = msinrvectorsallocated(dev); if (maxmsi) { FDT(fdtsetpropcell(fdt, offset, \"ibm,req#msi\", maxmsi)); } maxmsix = dev->msixentriesnr; if (maxmsix) { FDT(fdtsetpropcell(fdt, offset, \"ibm,req#msi-x\", maxmsix)); } populateresourceprops(dev, &rp); FDT(fdtsetprop(fdt, offset, \"reg\", (uint8t *)rp.reg, rp.reglen)); FDT(fdtsetprop(fdt, offset, \"assigned-addresses\", (uint8t *)rp.assigned, rp.assignedlen)); if (sphb->pcieecs && pciisexpress(dev)) { FDT(fdtsetpropcell(fdt, offset, \"ibm,pci-config-space-type\", 0x1)); } return 0; } ", "target": 1}
{"func": "static int readmajorsync(MLPDecodeContext *m, GetBitContext *gb) { MLPHeaderInfo mh; int substr, ret; if ((ret = ffmlpreadmajorsync(m->avctx, &mh, gb)) != 0) return ret; if (mh.group1bits == 0) { avlog(m->avctx, AVLOGERROR, \"invalid/unknown bits per sample\\n\"); return AVERRORINVALIDDATA; if (mh.group2bits > mh.group1bits) { avlog(m->avctx, AVLOGERROR, \"Channel group 2 cannot have more bits per sample than group 1.\\n\"); return AVERRORINVALIDDATA; if (mh.group2samplerate && mh.group2samplerate != mh.group1samplerate) { avlog(m->avctx, AVLOGERROR, \"Channel groups with differing sample rates are not currently supported.\\n\"); return AVERRORINVALIDDATA; if (mh.group1samplerate == 0) { avlog(m->avctx, AVLOGERROR, \"invalid/unknown sampling rate\\n\"); return AVERRORINVALIDDATA; if (mh.group1samplerate > MAXSAMPLERATE) { avlog(m->avctx, AVLOGERROR, \"Sampling rate %d is greater than the supported maximum (%d).\\n\", mh.group1samplerate, MAXSAMPLERATE); return AVERRORINVALIDDATA; if (mh.accessunitsize > MAXBLOCKSIZE) { avlog(m->avctx, AVLOGERROR, \"Block size %d is greater than the supported maximum (%d).\\n\", mh.accessunitsize, MAXBLOCKSIZE); return AVERRORINVALIDDATA; if (mh.accessunitsizepow2 > MAXBLOCKSIZEPOW2) { avlog(m->avctx, AVLOGERROR, \"Block size pow2 %d is greater than the supported maximum (%d).\\n\", mh.accessunitsizepow2, MAXBLOCKSIZEPOW2); return AVERRORINVALIDDATA; if (mh.numsubstreams == 0) return AVERRORINVALIDDATA; if (m->avctx->codecid == AVCODECIDMLP && mh.numsubstreams > 2) { avlog(m->avctx, AVLOGERROR, \"MLP only supports up to 2 substreams.\\n\"); return AVERRORINVALIDDATA; if (mh.numsubstreams > MAXSUBSTREAMS) { \"%d substreams (more than the \" \"maximum supported by the decoder)\", mh.numsubstreams); m->accessunitsize = mh.accessunitsize; m->accessunitsizepow2 = mh.accessunitsizepow2; m->numsubstreams = mh.numsubstreams; m->maxdecodedsubstream = m->numsubstreams - 1; m->avctx->samplerate = mh.group1samplerate; m->avctx->framesize = mh.accessunitsize; m->avctx->bitsperrawsample = mh.group1bits; if (mh.group1bits > 16) m->avctx->samplefmt = AVSAMPLEFMTS32; else m->avctx->samplefmt = AVSAMPLEFMTS16; m->paramsvalid = 1; for (substr = 0; substr < MAXSUBSTREAMS; substr++) m->substream[substr].restartseen = 0; /* Set the layout for each substream. When there's more than one, the first * substream is Stereo. Subsequent substreams' layouts are indicated in the * major sync. */ if (m->avctx->codecid == AVCODECIDMLP) { if ((substr = (mh.numsubstreams > 1))) m->substream[0].chlayout = AVCHLAYOUTSTEREO; m->substream[substr].chlayout = mh.channellayoutmlp; } else { if ((substr = (mh.numsubstreams > 1))) m->substream[0].chlayout = AVCHLAYOUTSTEREO; if (mh.numsubstreams > 2) if (mh.channellayoutthdstream2) m->substream[2].chlayout = mh.channellayoutthdstream2; else m->substream[2].chlayout = mh.channellayoutthdstream1; m->substream[substr].chlayout = mh.channellayoutthdstream1; if (m->avctx->channels<=2 && m->substream[substr].chlayout == AVCHLAYOUTMONO && m->maxdecodedsubstream == 1) { avlog(m->avctx, AVLOGDEBUG, \"Mono stream with 2 substreams, ignoring 2nd\\n\"); m->maxdecodedsubstream = 0; if (m->avctx->channels==2) m->avctx->channellayout = AVCHLAYOUTSTEREO; m->needsreordering = mh.channelarrangement >= 18 && mh.channelarrangement <= 20; return 0; ", "target": 1}
{"func": "static AVStream * initstream(AVFormatContext *s) { BinDemuxContext *bin = s->privdata; AVStream *st = avformatnewstream(s, NULL); if (!st) return NULL; st->codec->codectag = 0; st->codec->codectype = AVMEDIATYPEVIDEO; if (!bin->width) { st->codec->width = (80<<3); st->codec->height = (25<<4); } avprivsetptsinfo(st, 60, bin->framerate.den, bin->framerate.num); /* simulate tty display speed */ bin->charsperframe = FFMAX(avq2d(st->timebase) * bin->charsperframe, 1); return st; } ", "target": 1}
{"func": "static coroutinefn int sdcowritev(BlockDriverState *bs, int64t sectornum, int nbsectors, QEMUIOVector *qiov) { SheepdogAIOCB *acb; int ret; if (bs->growable && sectornum + nbsectors > bs->totalsectors) { ret = sdtruncate(bs, (sectornum + nbsectors) * BDRVSECTORSIZE); if (ret < 0) { return ret; } bs->totalsectors = sectornum + nbsectors; } acb = sdaiosetup(bs, qiov, sectornum, nbsectors); acb->aiodonefunc = sdwritedone; acb->aiocbtype = AIOCBWRITEUDATA; ret = sdcorwvector(acb); if (ret <= 0) { qemuaiorelease(acb); return ret; } qemucoroutineyield(); return acb->ret; } ", "target": 1}
{"func": "static void sdlsendmouseevent(int dx, int dy, int x, int y, int state) { static uint32t bmap[INPUTBUTTONMAX] = { [INPUTBUTTONLEFT] = SDLBUTTON(SDLBUTTONLEFT), [INPUTBUTTONMIDDLE] = SDLBUTTON(SDLBUTTONMIDDLE), [INPUTBUTTONRIGHT] = SDLBUTTON(SDLBUTTONRIGHT), [INPUTBUTTONWHEELUP] = SDLBUTTON(SDLBUTTONWHEELUP), [INPUTBUTTONWHEELDOWN] = SDLBUTTON(SDLBUTTONWHEELDOWN), }; static uint32t prevstate; if (prevstate != state) { qemuinputupdatebuttons(dcl->con, bmap, prevstate, state); prevstate = state; } if (qemuinputisabsolute()) { qemuinputqueueabs(dcl->con, INPUTAXISX, x, realscreen->w); qemuinputqueueabs(dcl->con, INPUTAXISY, y, realscreen->h); } else { if (guestcursor) { x -= guestx; y -= guesty; guestx += x; guesty += y; dx = x; dy = y; } qemuinputqueuerel(dcl->con, INPUTAXISX, dx); qemuinputqueuerel(dcl->con, INPUTAXISY, dy); } qemuinputeventsync(); } ", "target": 0}
{"func": "static void deviceinitfn(Object *obj) { DeviceState *dev = DEVICE(obj); Property *prop; if (qdevhotplug) { dev->hotplugged = 1; qdevhotadded = true; } dev->instanceidalias = -1; dev->state = DEVSTATECREATED; qdevpropsetdefaults(dev, qdevgetprops(dev)); for (prop = qdevgetprops(dev); prop && prop->name; prop++) { qdevpropertyaddlegacy(dev, prop, NULL); qdevpropertyaddstatic(dev, prop, NULL); } objectpropertyaddstr(OBJECT(dev), \"type\", qdevgettype, NULL, NULL); } ", "target": 0}
{"func": "static void scsiwritedata(SCSIRequest *req) { SCSIDiskReq *r = DOUPCAST(SCSIDiskReq, req, req); SCSIDiskState *s = DOUPCAST(SCSIDiskState, qdev, r->req.dev); uint32t n; /* No data transfer may already be in progress */ assert(r->req.aiocb == NULL); /* The request is used as the AIO opaque value, so add a ref. */ scsireqref(&r->req); if (r->req.cmd.mode != SCSIXFERTODEV) { DPRINTF(\"Data transfer direction invalid\\n\"); scsiwritecomplete(r, -EINVAL); return; } if (!r->req.sg && !r->qiov.size) { /* Called for the first time. Ask the driver to send us more data. */ r->started = true; scsiwritecomplete(r, 0); return; } if (s->trayopen) { scsiwritecomplete(r, -ENOMEDIUM); return; } if (r->req.cmd.buf[0] == VERIFY10 || r->req.cmd.buf[0] == VERIFY12 || r->req.cmd.buf[0] == VERIFY16) { if (r->req.sg) { scsidmacomplete(r, 0); } else { scsiwritecomplete(r, 0); } return; } if (r->req.sg) { dmaacctstart(s->qdev.conf.bs, &r->acct, r->req.sg, BDRVACCTWRITE); r->req.resid -= r->req.sg->size; r->req.aiocb = dmabdrvwrite(s->qdev.conf.bs, r->req.sg, r->sector, scsidmacomplete, r); } else { n = r->qiov.size / 512; bdrvacctstart(s->qdev.conf.bs, &r->acct, n * BDRVSECTORSIZE, BDRVACCTWRITE); r->req.aiocb = bdrvaiowritev(s->qdev.conf.bs, r->sector, &r->qiov, n, scsiwritecomplete, r); } } ", "target": 1}
{"func": "static void idiv64(uint64t *plow, uint64t *phigh, int64t b) { int sa, sb; sa = ((int64t)*phigh < 0); if (sa) neg128(plow, phigh); sb = (b < 0); if (sb) b = -b; div64(plow, phigh, b); if (sa ^ sb) *plow = - *plow; if (sa) *phigh = - *phigh; } ", "target": 1}
{"func": "void bioslinkerloaderalloc(GArray *linker, const char *file, uint32t allocalign, bool allocfseg) { BiosLinkerLoaderEntry entry; assert(!(allocalign & (allocalign - 1))); memset(&entry, 0, sizeof entry); strncpy(entry.alloc.file, file, sizeof entry.alloc.file - 1); entry.command = cputole32(BIOSLINKERLOADERCOMMANDALLOCATE); entry.alloc.align = cputole32(allocalign); entry.alloc.zone = cputole32(allocfseg ? BIOSLINKERLOADERALLOCZONEFSEG : BIOSLINKERLOADERALLOCZONEHIGH); /* Alloc entries must come first, so prepend them */ garrayprependvals(linker, &entry, sizeof entry); } ", "target": 1}
{"func": "static void iscsirefreshlimits(BlockDriverState *bs, Error **errp) { /* We don't actually refresh here, but just return data queried in * iscsiopen(): iscsi targets don't change their limits. */ IscsiLun *iscsilun = bs->opaque; uint64t maxxferlen = iscsilun->use16forrw ? 0xffffffff : 0xffff; bs->bl.requestalignment = iscsilun->blocksize; if (iscsilun->bl.maxxferlen) { maxxferlen = MIN(maxxferlen, iscsilun->bl.maxxferlen); } if (maxxferlen * iscsilun->blocksize < INTMAX) { bs->bl.maxtransfer = maxxferlen * iscsilun->blocksize; } if (iscsilun->lbp.lbpu) { if (iscsilun->bl.maxunmap < 0xffffffff / iscsilun->blocksize) { bs->bl.maxpdiscard = iscsilun->bl.maxunmap * iscsilun->blocksize; } bs->bl.pdiscardalignment = iscsilun->bl.optunmapgran * iscsilun->blocksize; } else { bs->bl.pdiscardalignment = iscsilun->blocksize; } if (iscsilun->bl.maxwslen < 0xffffffff / iscsilun->blocksize) { bs->bl.maxpwritezeroes = iscsilun->bl.maxwslen * iscsilun->blocksize; } if (iscsilun->lbp.lbpws) { bs->bl.pwritezeroesalignment = iscsilun->bl.optunmapgran * iscsilun->blocksize; } else { bs->bl.pwritezeroesalignment = iscsilun->blocksize; } if (iscsilun->bl.optxferlen && iscsilun->bl.optxferlen < INTMAX / iscsilun->blocksize) { bs->bl.opttransfer = pow2floor(iscsilun->bl.optxferlen * iscsilun->blocksize); } } ", "target": 1}
{"func": "static void tapreceive(void *opaque, const uint8t *buf, sizet size) { TAPState *s = opaque; int ret; for(;;) { ret = write(s->fd, buf, size); if (ret < 0 && (errno == EINTR || errno == EAGAIN)) { } else { break; } } } ", "target": 0}
{"func": "static void scsidiskrealize(SCSIDevice *dev, Error **errp) { DriveInfo *dinfo; Error *localerr = NULL; if (!dev->conf.bs) { scsirealize(dev, &localerr); assert(localerr); errorpropagate(errp, localerr); return; } dinfo = drivegetbyblockdev(dev->conf.bs); if (dinfo->mediacd) { scsicdrealize(dev, errp); } else { scsihdrealize(dev, errp); } } ", "target": 0}
{"func": "static int sdsnapshotcreate(BlockDriverState *bs, QEMUSnapshotInfo *sninfo) { BDRVSheepdogState *s = bs->opaque; int ret, fd; uint32t newvid; SheepdogInode *inode; unsigned int datalen; dprintf(\"sninfo: name %s idstr %s s: name %s vmstatesize %\" PRId64 \" \" \"issnapshot %d\\n\", sninfo->name, sninfo->idstr, s->name, sninfo->vmstatesize, s->issnapshot); if (s->issnapshot) { errorreport(\"You can't create a snapshot of a snapshot VDI, \" \"%s (%\" PRIu32 \").\", s->name, s->inode.vdiid); return -EINVAL; } dprintf(\"%s %s\\n\", sninfo->name, sninfo->idstr); s->inode.vmstatesize = sninfo->vmstatesize; s->inode.vmclocknsec = sninfo->vmclocknsec; /* It appears that inode.tag does not require a NUL terminator, * which means this use of strncpy is ok. */ strncpy(s->inode.tag, sninfo->name, sizeof(s->inode.tag)); /* we don't need to update entire object */ datalen = SDINODESIZE - sizeof(s->inode.datavdiid); /* refresh inode. */ fd = connecttosdog(s->addr, s->port); if (fd < 0) { ret = fd; goto cleanup; } ret = writeobject(fd, (char *)&s->inode, vidtovdioid(s->inode.vdiid), s->inode.nrcopies, datalen, 0, false, s->cacheenabled); if (ret < 0) { errorreport(\"failed to write snapshot's inode.\"); goto cleanup; } ret = dosdcreate(s->name, s->inode.vdisize, s->inode.vdiid, &newvid, 1, s->addr, s->port); if (ret < 0) { errorreport(\"failed to create inode for snapshot. %s\", strerror(errno)); goto cleanup; } inode = (SheepdogInode *)gmalloc(datalen); ret = readobject(fd, (char *)inode, vidtovdioid(newvid), s->inode.nrcopies, datalen, 0, s->cacheenabled); if (ret < 0) { errorreport(\"failed to read new inode info. %s\", strerror(errno)); goto cleanup; } memcpy(&s->inode, inode, datalen); dprintf(\"s->inode: name %s snapid %x oid %x\\n\", s->inode.name, s->inode.snapid, s->inode.vdiid); cleanup: closesocket(fd); return ret; } ", "target": 0}
{"func": "static int vncdisplaylisten(VncDisplay *vd, SocketAddress **saddr, sizet nsaddr, SocketAddress **wsaddr, sizet nwsaddr, Error **errp) { sizet i; for (i = 0; i < nsaddr; i++) { if (vncdisplaylistenaddr(vd, saddr[i], \"vnc-listen\", &vd->lsock, &vd->lsocktag, &vd->nlsock, errp) < 0) { return -1; } } for (i = 0; i < nwsaddr; i++) { if (vncdisplaylistenaddr(vd, wsaddr[i], \"vnc-ws-listen\", &vd->lwebsock, &vd->lwebsocktag, &vd->nlwebsock, errp) < 0) { return -1; } } return 0; } ", "target": 0}
{"func": "static char *enumeratecpus(unsigned long *cpus, int maxcpus) { int cpu; bool first = true; GString *s = gstringnew(NULL); for (cpu = findfirstbit(cpus, maxcpus); cpu < maxcpus; cpu = findnextbit(cpus, maxcpus, cpu + 1)) { gstringappendprintf(s, \"%s%d\", first ? \"\" : \" \", cpu); first = false; } return gstringfree(s, FALSE); } ", "target": 0}
{"func": "MigrationState *execstartoutgoingmigration(const char *command, int64t bandwidthlimit, int async) { FdMigrationState *s; FILE *f; s = qemumallocz(sizeof(*s)); if (s == NULL) { dprintf(\"Unable to allocate FdMigrationState\\n\"); goto err; } f = popen(command, \"w\"); if (f == NULL) { dprintf(\"Unable to popen exec target\\n\"); goto errafteralloc; } s->fd = fileno(f); if (s->fd == -1) { dprintf(\"Unable to retrieve file descriptor for popen'd handle\\n\"); goto errafteropen; } if (fcntl(s->fd, FSETFD, ONONBLOCK) == -1) { dprintf(\"Unable to set nonblocking mode on file descriptor\\n\"); goto errafteropen; } s->opaque = qemupopen(f, \"w\"); s->geterror = fileerrno; s->write = filewrite; s->migstate.cancel = migratefdcancel; s->migstate.getstatus = migratefdgetstatus; s->migstate.release = migratefdrelease; s->state = MIGSTATEACTIVE; s->detach = !async; s->bandwidthlimit = bandwidthlimit; if (s->detach == 1) { dprintf(\"detaching from monitor\\n\"); monitorsuspend(); s->detach = 2; } migratefdconnect(s); return &s->migstate; errafteropen: pclose(f); errafteralloc: qemufree(s); err: return NULL; }", "target": 1}
{"func": "static void registercorertas(void) { spaprrtasregister(\"display-character\", rtasdisplaycharacter); spaprrtasregister(\"get-time-of-day\", rtasgettimeofday); spaprrtasregister(\"power-off\", rtaspoweroff); }", "target": 1}
{"func": "static targetulong hputtce(CPUPPCState *env, sPAPREnvironment *spapr, targetulong opcode, targetulong *args) { targetulong liobn = args[0]; targetulong ioba = args[1]; targetulong tce = args[2]; VIOsPAPRDevice *dev = spaprviofindbyreg(spapr->viobus, liobn); VIOsPAPRRTCE *rtce; if (!dev) { hcalldprintf(\"LIOBN 0x\" TARGETFMTlx \" does not exist\\n\", liobn); return HPARAMETER; } ioba &= ~(SPAPRVIOTCEPAGESIZE - 1); #ifdef DEBUGTCE fprintf(stderr, \"spaprvioputtce on %s ioba 0x\" TARGETFMTlx \" TCE 0x\" TARGETFMTlx \"\\n\", dev->qdev.id, ioba, tce); #endif if (ioba >= dev->rtcewindowsize) { hcalldprintf(\"Out-of-bounds IOBA 0x\" TARGETFMTlx \"\\n\", ioba); return HPARAMETER; } rtce = dev->rtcetable + (ioba >> SPAPRVIOTCEPAGESHIFT); rtce->tce = tce; return HSUCCESS; } ", "target": 1}
{"func": "static void nvmegetbootindex(Object *obj, Visitor *v, void *opaque, const char *name, Error **errp) { NvmeCtrl *s = NVME(obj); visittypeint32(v, &s->conf.bootindex, name, errp); } ", "target": 1}
{"func": "ffrmparsepacket (AVFormatContext *s, AVIOContext *pb, AVStream *st, RMStream *ast, int len, AVPacket *pkt, int *seq, int flags, int64t timestamp) { RMDemuxContext *rm = s->privdata; int ret; if (st->codec->codectype == AVMEDIATYPEVIDEO) { rm->currentstream= st->id; ret = rmassemblevideoframe(s, pb, rm, ast, pkt, len, seq, &timestamp); if(ret) return ret < 0 ? ret : -1; //got partial frame or error } else if (st->codec->codectype == AVMEDIATYPEAUDIO) { if ((ast->deintid == DEINTIDGENR) || (ast->deintid == DEINTIDINT4) || (ast->deintid == DEINTIDSIPR)) { int x; int sps = ast->subpacketsize; int cfs = ast->codedframesize; int h = ast->subpacketh; int y = ast->subpacketcnt; int w = ast->audioframesize; if (flags & 2) y = ast->subpacketcnt = 0; if (!y) ast->audiotimestamp = timestamp; switch (ast->deintid) { case DEINTIDINT4: for (x = 0; x < h/2; x++) avioread(pb, ast->pkt.data+x*2*w+y*cfs, cfs); break; case DEINTIDGENR: for (x = 0; x < w/sps; x++) avioread(pb, ast->pkt.data+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), sps); break; case DEINTIDSIPR: avioread(pb, ast->pkt.data + y * w, w); break; } if (++(ast->subpacketcnt) < h) return -1; if (ast->deintid == DEINTIDSIPR) ffrmreordersiprdata(ast->pkt.data, h, w); ast->subpacketcnt = 0; rm->audiostreamnum = st->index; rm->audiopktcnt = h * w / st->codec->blockalign; } else if ((ast->deintid == DEINTIDVBRF) || (ast->deintid == DEINTIDVBRS)) { int x; rm->audiostreamnum = st->index; ast->subpacketcnt = (aviorb16(pb) & 0xf0) >> 4; if (ast->subpacketcnt) { for (x = 0; x < ast->subpacketcnt; x++) ast->subpacketlengths[x] = aviorb16(pb); rm->audiopktcnt = ast->subpacketcnt; ast->audiotimestamp = timestamp; } else return -1; } else { avgetpacket(pb, pkt, len); rmac3swapbytes(st, pkt); } } else avgetpacket(pb, pkt, len); pkt->streamindex = st->index; #if 0 if (st->codec->codectype == AVMEDIATYPEVIDEO) { if(st->codec->codecid == AVCODECIDRV20){ int seq= 128*(pkt->data[2]&0x7F) + (pkt->data[3]>>1); avlog(s, AVLOGDEBUG, \"%d %\"PRId64\" %d\\n\", *timestamp, *timestamp*512LL/25, seq); seq |= (timestamp&~0x3FFF); if(seq - timestamp > 0x2000) seq -= 0x4000; if(seq - timestamp < -0x2000) seq += 0x4000; } } #endif pkt->pts = timestamp; if (flags & 2) pkt->flags |= AVPKTFLAGKEY; return st->codec->codectype == AVMEDIATYPEAUDIO ? rm->audiopktcnt : 0; } ", "target": 1}
{"func": "Object *objectresolvepathcomponent(Object *parent, const gchar *part) { ObjectProperty *prop = objectpropertyfind(parent, part, NULL); if (prop == NULL) { return NULL; } if (objectpropertyislink(prop)) { return *(Object **)prop->opaque; } else if (objectpropertyischild(prop)) { return prop->opaque; } else { return NULL; } } ", "target": 1}
{"func": "static void vscsiprocesslogin(VSCSIState *s, vscsireq *req) { union viosrpiu *iu = &req->iu; struct srploginrsp *rsp = &iu->srp.loginrsp; uint64t tag = iu->srp.rsp.tag; tracespaprvscsiprocesslogin(); /* TODO handle case that requested size is wrong and * buffer format is wrong */ memset(iu, 0, sizeof(struct srploginrsp)); rsp->opcode = SRPLOGINRSP; /* Don't advertise quite as many request as we support to * keep room for management stuff etc... */ rsp->reqlimdelta = cputobe32(VSCSIREQLIMIT-2); rsp->tag = tag; rsp->maxitiulen = cputobe32(sizeof(union srpiu)); rsp->maxtiiulen = cputobe32(sizeof(union srpiu)); /* direct and indirect */ rsp->buffmt = cputobe16(SRPBUFFORMATDIRECT | SRPBUFFORMATINDIRECT); vscsisendiu(s, req, sizeof(*rsp), VIOSRPSRPFORMAT); } ", "target": 1}
{"func": "void cputicksetcount(CPUTimer *timer, uint64t count) { uint64t realcount = count & ~timer->disabledmask; uint64t disabledbit = count & timer->disabledmask; int64t vmclockoffset = qemuclockgetns(QEMUCLOCKVIRTUAL) - cputotimerticks(realcount, timer->frequency); TIMERDPRINTF(\"%s setcount count=0x%016lx (%s) p=%p\\n\", timer->name, realcount, timer->disabled?\"disabled\":\"enabled\", timer); timer->disabled = disabledbit ? 1 : 0; timer->clockoffset = vmclockoffset; } ", "target": 1}
{"func": "void commitstart(const char *jobid, BlockDriverState *bs, BlockDriverState *base, BlockDriverState *top, int64t speed, BlockdevOnError onerror, const char *backingfilestr, const char *filternodename, Error **errp) { CommitBlockJob *s; BlockReopenQueue *reopenqueue = NULL; int origoverlayflags; int origbaseflags; BlockDriverState *iter; BlockDriverState *overlaybs; BlockDriverState *committopbs = NULL; Error *localerr = NULL; int ret; assert(top != bs); if (top == base) { errorsetg(errp, \"Invalid files for merge: top and base are the same\"); return; overlaybs = bdrvfindoverlay(bs, top); if (overlaybs == NULL) { errorsetg(errp, \"Could not find overlay image for %s:\", top->filename); return; s = blockjobcreate(jobid, &commitjobdriver, bs, 0, BLKPERMALL, speed, BLOCKJOBDEFAULT, NULL, NULL, errp); if (!s) { return; origbaseflags = bdrvgetflags(base); origoverlayflags = bdrvgetflags(overlaybs); /* convert base & overlaybs to r/w, if necessary */ if (!(origbaseflags & BDRVORDWR)) { reopenqueue = bdrvreopenqueue(reopenqueue, base, NULL, origbaseflags | BDRVORDWR); if (!(origoverlayflags & BDRVORDWR)) { reopenqueue = bdrvreopenqueue(reopenqueue, overlaybs, NULL, origoverlayflags | BDRVORDWR); if (reopenqueue) { bdrvreopenmultiple(bdrvgetaiocontext(bs), reopenqueue, &localerr); if (localerr != NULL) { errorpropagate(errp, localerr); goto fail; /* Insert committop block node above top, so we can block consistent read * on the backing chain below it */ committopbs = bdrvnewopendriver(&bdrvcommittop, filternodename, 0, errp); if (committopbs == NULL) { goto fail; committopbs->totalsectors = top->totalsectors; bdrvsetaiocontext(committopbs, bdrvgetaiocontext(top)); bdrvsetbackinghd(committopbs, top, &localerr); if (localerr) { bdrvunref(committopbs); committopbs = NULL; errorpropagate(errp, localerr); goto fail; bdrvsetbackinghd(overlaybs, committopbs, &localerr); if (localerr) { bdrvunref(committopbs); committopbs = NULL; errorpropagate(errp, localerr); goto fail; s->committopbs = committopbs; bdrvunref(committopbs); /* Block all nodes between top and base, because they will * disappear from the chain after this operation. */ assert(bdrvchaincontains(top, base)); for (iter = top; iter != base; iter = backingbs(iter)) { /* XXX BLKPERMWRITE needs to be allowed so we don't block ourselves * at s->base (if writes are blocked for a node, they are also blocked * for its backing file). The other options would be a second filter * driver above s->base. */ ret = blockjobaddbdrv(&s->common, \"intermediate node\", iter, 0, BLKPERMWRITEUNCHANGED | BLKPERMWRITE, errp); if (ret < 0) { goto fail; ret = blockjobaddbdrv(&s->common, \"base\", base, 0, BLKPERMALL, errp); if (ret < 0) { goto fail; /* overlaybs must be blocked because it needs to be modified to * update the backing image string. */ ret = blockjobaddbdrv(&s->common, \"overlay of top\", overlaybs, BLKPERMGRAPHMOD, BLKPERMALL, errp); if (ret < 0) { goto fail; s->base = blknew(BLKPERMCONSISTENTREAD | BLKPERMWRITE | BLKPERMRESIZE, BLKPERMCONSISTENTREAD | BLKPERMGRAPHMOD | BLKPERMWRITEUNCHANGED); ret = blkinsertbs(s->base, base, errp); if (ret < 0) { goto fail; /* Required permissions are already taken with blockjobaddbdrv() */ s->top = blknew(0, BLKPERMALL); ret = blkinsertbs(s->top, top, errp); if (ret < 0) { goto fail; s->active = bs; s->baseflags = origbaseflags; s->origoverlayflags = origoverlayflags; s->backingfilestr = gstrdup(backingfilestr); s->onerror = onerror; tracecommitstart(bs, base, top, s); blockjobstart(&s->common); return; fail: if (s->base) { blkunref(s->base); if (s->top) { blkunref(s->top); if (committopbs) { bdrvsetbackinghd(overlaybs, top, &errorabort); blockjobearlyfail(&s->common); ", "target": 1}
{"func": "int bdrvisremovable(BlockDriverState *bs) { return bs->removable; } ", "target": 0}
{"func": "static int nullfiltersamples(AVFilterLink *link, AVFilterBufferRef *samplesref) { return 0; }", "target": 1}
{"func": "void qmpblockdevadd(BlockdevOptions *options, Error **errp) { QmpOutputVisitor *ov = qmpoutputvisitornew(); QObject *obj; QDict *qdict; Error *localerr = NULL; /* Require an ID in the top level */ if (!options->hasid) { errorsetg(errp, \"Block device needs an ID\"); goto fail; } /* TODO Sort it out in raw-posix and driveinit: Reject aio=native with * cache.direct=false instead of silently switching to aio=threads, except * if called from driveinit. * * For now, simply forbidding the combination for all drivers will do. */ if (options->hasaio && options->aio == BLOCKDEVAIOOPTIONSNATIVE) { bool direct = options->cache->hasdirect && options->cache->direct; if (!options->hascache && !direct) { errorsetg(errp, \"aio=native requires cache.direct=true\"); goto fail; } } visittypeBlockdevOptions(qmpoutputgetvisitor(ov), &options, NULL, &localerr); if (localerr) { errorpropagate(errp, localerr); goto fail; } obj = qmpoutputgetqobject(ov); qdict = qobjecttoqdict(obj); qdictflatten(qdict); blockdevinit(NULL, qdict, &localerr); if (localerr) { errorpropagate(errp, localerr); goto fail; } fail: qmpoutputvisitorcleanup(ov); } ", "target": 1}
{"func": "void dodivwuo (void) { if (likely((uint32t)T1 != 0)) { xerov = 0; T0 = (uint32t)T0 / (uint32t)T1; } else { xerso = 1; xerov = 1; T0 = 0; } } ", "target": 1}
{"func": "static void kvmclockpresave(void *opaque) { KVMClockState *s = opaque; struct kvmclockdata data; int ret; if (s->clockvalid) { return; } ret = kvmvmioctl(kvmstate, KVMGETCLOCK, &data); if (ret < 0) { fprintf(stderr, \"KVMGETCLOCK failed: %s\\n\", strerror(ret)); data.clock = 0; } s->clock = data.clock; /* * If the VM is stopped, declare the clock state valid to avoid re-reading * it on next vmsave (which would return a different value). Will be reset * when the VM is continued. */ s->clockvalid = !runstateisrunning(); } ", "target": 1}
{"func": "static void handlesatn(ESPState *s) { uint8t buf[32]; int len; if (s->dma && !s->dmaenabled) { s->dmacb = handlesatn; return; } len = getcmd(s, buf); if (len) docmd(s, buf); } ", "target": 1}
{"func": "static int checkchecksum(ByteIOContext *bc){ unsigned long checksum= getchecksum(bc); // return checksum != getbe32(bc); avlog(NULL, AVLOGERROR, \"%08X %08X\\n\", checksum, (int)getbe32(bc)); return 0; } ", "target": 1}
{"func": "int ideinitdrive(IDEState *s, BlockBackend *blk, IDEDriveKind kind, const char *version, const char *serial, const char *model, uint64t wwn, uint32t cylinders, uint32t heads, uint32t secs, int chstrans) { uint64t nbsectors; s->blk = blk; s->drivekind = kind; blkgetgeometry(blk, &nbsectors); s->cylinders = cylinders; s->heads = heads; s->sectors = secs; s->chstrans = chstrans; s->nbsectors = nbsectors; s->wwn = wwn; /* The SMART values should be preserved across power cycles but they aren't. */ s->smartenabled = 1; s->smartautosave = 1; s->smarterrors = 0; s->smartselftestcount = 0; if (kind == IDECD) { blksetdevops(blk, &idecdblockops, s); blksetguestblocksize(blk, 2048); } else { if (!blkisinserted(s->blk)) { errorreport(\"Device needs media, but drive is empty\"); return -1; } if (blkisreadonly(blk)) { errorreport(\"Can't use a read-only drive\"); return -1; } blksetdevops(blk, &idehdblockops, s); } if (serial) { pstrcpy(s->driveserialstr, sizeof(s->driveserialstr), serial); } else { snprintf(s->driveserialstr, sizeof(s->driveserialstr), \"QM%05d\", s->driveserial); } if (model) { pstrcpy(s->drivemodelstr, sizeof(s->drivemodelstr), model); } else { switch (kind) { case IDECD: strcpy(s->drivemodelstr, \"QEMU DVD-ROM\"); break; case IDECFATA: strcpy(s->drivemodelstr, \"QEMU MICRODRIVE\"); break; default: strcpy(s->drivemodelstr, \"QEMU HARDDISK\"); break; } } if (version) { pstrcpy(s->version, sizeof(s->version), version); } else { pstrcpy(s->version, sizeof(s->version), qemugetversion()); } idereset(s); blkiostatusenable(blk); return 0; } ", "target": 0}
{"func": "int vhostbackendinvalidatedeviceiotlb(struct vhostdev *dev, uint64t iova, uint64t len) { struct vhostiotlbmsg imsg; imsg.iova = iova; imsg.size = len; imsg.type = VHOSTIOTLBINVALIDATE; return dev->vhostops->vhostsenddeviceiotlbmsg(dev, &imsg); } ", "target": 1}
{"func": "static uint32t gicdistreadw(void *opaque, targetphysaddrt offset) { uint32t val; val = gicdistreadb(opaque, offset); val |= gicdistreadb(opaque, offset + 1) << 8; return val; } ", "target": 0}
{"func": "static void testqemustrtoulloverflow(void) { const char *str = \"99999999999999999999999999999999999999999999\"; char f = 'X'; const char *endptr = &f; uint64t res = 999; int err; err = qemustrtoull(str, &endptr, 0, &res); gassertcmpint(err, ==, -ERANGE); gassertcmpint(res, ==, ULLONGMAX); gassert(endptr == str + strlen(str)); } ", "target": 0}
{"func": "PXA2xxState *pxa255init(unsigned int sdramsize) { PXA2xxState *s; int iomemtype, i; DriveInfo *dinfo; s = (PXA2xxState *) qemumallocz(sizeof(PXA2xxState)); s->env = cpuinit(\"pxa255\"); if (!s->env) { fprintf(stderr, \"Unable to find CPU definition\\n\"); exit(1); } s->reset = qemuallocateirqs(pxa2xxreset, s, 1)[0]; /* SDRAM & Internal Memory Storage */ cpuregisterphysicalmemory(PXA2XXSDRAMBASE, sdramsize, qemuramalloc(NULL, \"pxa255.sdram\", sdramsize) | IOMEMRAM); cpuregisterphysicalmemory(PXA2XXINTERNALBASE, PXA2XXINTERNALSIZE, qemuramalloc(NULL, \"pxa255.internal\", PXA2XXINTERNALSIZE) | IOMEMRAM); s->pic = pxa2xxpicinit(0x40d00000, s->env); s->dma = pxa255dmainit(0x40000000, s->pic[PXA2XXPICDMA]); pxa25xtimerinit(0x40a00000, &s->pic[PXA2XXPICOST0]); s->gpio = pxa2xxgpioinit(0x40e00000, s->env, s->pic, 85); dinfo = driveget(IFSD, 0, 0); if (!dinfo) { fprintf(stderr, \"qemu: missing SecureDigital device\\n\"); exit(1); } s->mmc = pxa2xxmmciinit(0x41100000, dinfo->bdrv, s->pic[PXA2XXPICMMC], s->dma); for (i = 0; pxa255serial[i].iobase; i ++) if (serialhds[i]) { #ifdef TARGETWORDSBIGENDIAN serialmminit(pxa255serial[i].iobase, 2, s->pic[pxa255serial[i].irqn], 14745600/16, serialhds[i], 1, 1); #else serialmminit(pxa255serial[i].iobase, 2, s->pic[pxa255serial[i].irqn], 14745600/16, serialhds[i], 1, 0); #endif } else { break; } if (serialhds[i]) s->fir = pxa2xxfirinit(0x40800000, s->pic[PXA2XXPICICP], s->dma, serialhds[i]); s->lcd = pxa2xxlcdcinit(0x44000000, s->pic[PXA2XXPICLCD]); s->cmbase = 0x41300000; s->cmregs[CCCR >> 2] = 0x02000210;\t/* 416.0 MHz */ s->clkcfg = 0x00000009;\t\t/* Turbo mode active */ iomemtype = cpuregisteriomemory(pxa2xxcmreadfn, pxa2xxcmwritefn, s, DEVICENATIVEENDIAN); cpuregisterphysicalmemory(s->cmbase, 0x1000, iomemtype); registersavevm(NULL, \"pxa2xxcm\", 0, 0, pxa2xxcmsave, pxa2xxcmload, s); cpuarmsetcpio(s->env, 14, pxa2xxcp14read, pxa2xxcp14write, s); s->mmbase = 0x48000000; s->mmregs[MDMRS >> 2] = 0x00020002; s->mmregs[MDREFR >> 2] = 0x03ca4000; s->mmregs[MECR >> 2] = 0x00000001;\t/* Two PC Card sockets */ iomemtype = cpuregisteriomemory(pxa2xxmmreadfn, pxa2xxmmwritefn, s, DEVICENATIVEENDIAN); cpuregisterphysicalmemory(s->mmbase, 0x1000, iomemtype); registersavevm(NULL, \"pxa2xxmm\", 0, 0, pxa2xxmmsave, pxa2xxmmload, s); s->pmbase = 0x40f00000; iomemtype = cpuregisteriomemory(pxa2xxpmreadfn, pxa2xxpmwritefn, s, DEVICENATIVEENDIAN); cpuregisterphysicalmemory(s->pmbase, 0x100, iomemtype); registersavevm(NULL, \"pxa2xxpm\", 0, 0, pxa2xxpmsave, pxa2xxpmload, s); for (i = 0; pxa255ssp[i].iobase; i ++); s->ssp = (SSIBus **)qemumallocz(sizeof(SSIBus *) * i); for (i = 0; pxa255ssp[i].iobase; i ++) { DeviceState *dev; dev = sysbuscreatesimple(\"pxa2xx-ssp\", pxa255ssp[i].iobase, s->pic[pxa255ssp[i].irqn]); s->ssp[i] = (SSIBus *)qdevgetchildbus(dev, \"ssi\"); } if (usbenabled) { sysbuscreatesimple(\"sysbus-ohci\", 0x4c000000, s->pic[PXA2XXPICUSBH1]); } s->pcmcia[0] = pxa2xxpcmciainit(0x20000000); s->pcmcia[1] = pxa2xxpcmciainit(0x30000000); s->rtcbase = 0x40900000; iomemtype = cpuregisteriomemory(pxa2xxrtcreadfn, pxa2xxrtcwritefn, s, DEVICENATIVEENDIAN); cpuregisterphysicalmemory(s->rtcbase, 0x1000, iomemtype); pxa2xxrtcinit(s); registersavevm(NULL, \"pxa2xxrtc\", 0, 0, pxa2xxrtcsave, pxa2xxrtcload, s); s->i2c[0] = pxa2xxi2cinit(0x40301600, s->pic[PXA2XXPICI2C], 0xffff); s->i2c[1] = pxa2xxi2cinit(0x40f00100, s->pic[PXA2XXPICPWRI2C], 0xff); s->i2s = pxa2xxi2sinit(0x40400000, s->pic[PXA2XXPICI2S], s->dma); /* GPIO1 resets the processor */ /* The handler can be overridden by board-specific code */ qdevconnectgpioout(s->gpio, 1, s->reset); return s; } ", "target": 0}
{"func": "int usbdevicedeleteaddr(int busnr, int addr) { USBBus *bus; USBPort *port; USBDevice *dev; bus = usbbusfind(busnr); if (!bus) return -1; TAILQFOREACH(port, &bus->used, next) { if (port->dev->addr == addr) break; } if (!port) return -1; dev = port->dev; TAILQREMOVE(&bus->used, port, next); bus->nused--; usbattach(port, NULL); dev->info->handledestroy(dev); TAILQINSERTTAIL(&bus->free, port, next); bus->nfree++; return 0; } ", "target": 0}
{"func": "static void qmpoutputtypenumber(Visitor *v, const char *name, double *obj, Error **errp) { QmpOutputVisitor *qov = toqov(v); qmpoutputadd(qov, name, qfloatfromdouble(*obj)); } ", "target": 0}
{"func": "static int aiowritef(BlockBackend *blk, int argc, char **argv) { int nriov, c; int pattern = 0xcd; struct aioctx *ctx = gnew0(struct aioctx, 1); ctx->blk = blk; while ((c = getopt(argc, argv, \"CqP:z\")) != -1) { switch (c) { case 'C': ctx->Cflag = 1; break; case 'q': ctx->qflag = 1; break; case 'P': pattern = parsepattern(optarg); if (pattern < 0) { return 0; } break; case 'z': ctx->zflag = 1; break; default: return qemuiocommandusage(&aiowritecmd); } } if (optind > argc - 2) { return qemuiocommandusage(&aiowritecmd); } if (ctx->zflag && optind != argc - 2) { printf(\"-z supports only a single length parameter\\n\"); return 0; } if (ctx->zflag && ctx->Pflag) { printf(\"-z and -P cannot be specified at the same time\\n\"); return 0; } ctx->offset = cvtnum(argv[optind]); if (ctx->offset < 0) { printcvtnumerr(ctx->offset, argv[optind]); return 0; } optind++; if (ctx->offset & 0x1ff) { printf(\"offset %\" PRId64 \" is not sector aligned\\n\", ctx->offset); blockacctinvalid(blkgetstats(blk), BLOCKACCTWRITE); return 0; } if (ctx->zflag) { int64t count = cvtnum(argv[optind]); if (count < 0) { printcvtnumerr(count, argv[optind]); return 0; } ctx->qiov.size = count; blkaiowritezeroes(blk, ctx->offset >> 9, count >> 9, 0, aiowritedone, ctx); } else { nriov = argc - optind; ctx->buf = createiovec(blk, &ctx->qiov, &argv[optind], nriov, pattern); if (ctx->buf == NULL) { blockacctinvalid(blkgetstats(blk), BLOCKACCTWRITE); return 0; } gettimeofday(&ctx->t1, NULL); blockacctstart(blkgetstats(blk), &ctx->acct, ctx->qiov.size, BLOCKACCTWRITE); blkaiowritev(blk, ctx->offset >> 9, &ctx->qiov, ctx->qiov.size >> 9, aiowritedone, ctx); } return 0; }", "target": 1}
{"func": "static int allocrefcountblock(BlockDriverState *bs, int64t clusterindex, uint16t **refcountblock) { BDRVQcowState *s = bs->opaque; unsigned int refcounttableindex; int ret; BLKDBGEVENT(bs->file, BLKDBGREFBLOCKALLOC); /* Find the refcount block for the given cluster */ refcounttableindex = clusterindex >> s->refcountblockbits; if (refcounttableindex < s->refcounttablesize) { uint64t refcountblockoffset = s->refcounttable[refcounttableindex] & REFTOFFSETMASK; /* If it's already there, we're done */ if (refcountblockoffset) { if (offsetintocluster(s, refcountblockoffset)) { qcow2signalcorruption(bs, true, -1, -1, \"Refblock offset %#\" PRIx64 \" unaligned (reftable index: \" \"%#x)\", refcountblockoffset, refcounttableindex); return -EIO; } return loadrefcountblock(bs, refcountblockoffset, (void**) refcountblock); } } /* * If we came here, we need to allocate something. Something is at least * a cluster for the new refcount block. It may also include a new refcount * table if the old refcount table is too small. * * Note that allocating clusters here needs some special care: * * - We can't use the normal qcow2allocclusters(), it would try to * increase the refcount and very likely we would end up with an endless * recursion. Instead we must place the refcount blocks in a way that * they can describe them themselves. * * - We need to consider that at this point we are inside updaterefcounts * and potentially doing an initial refcount increase. This means that * some clusters have already been allocated by the caller, but their * refcount isn't accurate yet. If we allocate clusters for metadata, we * need to return -EAGAIN to signal the caller that it needs to restart * the search for free clusters. * * - allocclustersnoref and qcow2freeclusters may load a different * refcount block into the cache */ *refcountblock = NULL; /* We write to the refcount table, so we might depend on L2 tables */ ret = qcow2cacheflush(bs, s->l2tablecache); if (ret < 0) { return ret; } /* Allocate the refcount block itself and mark it as used */ int64t newblock = allocclustersnoref(bs, s->clustersize); if (newblock < 0) { return newblock; } #ifdef DEBUGALLOC2 fprintf(stderr, \"qcow2: Allocate refcount block %d for %\" PRIx64 \" at %\" PRIx64 \"\\n\", refcounttableindex, clusterindex << s->clusterbits, newblock); #endif if (insamerefcountblock(s, newblock, clusterindex << s->clusterbits)) { /* Zero the new refcount block before updating it */ ret = qcow2cachegetempty(bs, s->refcountblockcache, newblock, (void**) refcountblock); if (ret < 0) { goto failblock; } memset(*refcountblock, 0, s->clustersize); /* The block describes itself, need to update the cache */ int blockindex = (newblock >> s->clusterbits) & (s->refcountblocksize - 1); (*refcountblock)[blockindex] = cputobe16(1); } else { /* Described somewhere else. This can recurse at most twice before we * arrive at a block that describes itself. */ ret = updaterefcount(bs, newblock, s->clustersize, 1, false, QCOW2DISCARDNEVER); if (ret < 0) { goto failblock; } ret = qcow2cacheflush(bs, s->refcountblockcache); if (ret < 0) { goto failblock; } /* Initialize the new refcount block only after updating its refcount, * updaterefcount uses the refcount cache itself */ ret = qcow2cachegetempty(bs, s->refcountblockcache, newblock, (void**) refcountblock); if (ret < 0) { goto failblock; } memset(*refcountblock, 0, s->clustersize); } /* Now the new refcount block needs to be written to disk */ BLKDBGEVENT(bs->file, BLKDBGREFBLOCKALLOCWRITE); qcow2cacheentrymarkdirty(s->refcountblockcache, *refcountblock); ret = qcow2cacheflush(bs, s->refcountblockcache); if (ret < 0) { goto failblock; } /* If the refcount table is big enough, just hook the block up there */ if (refcounttableindex < s->refcounttablesize) { uint64t data64 = cputobe64(newblock); BLKDBGEVENT(bs->file, BLKDBGREFBLOCKALLOCHOOKUP); ret = bdrvpwritesync(bs->file, s->refcounttableoffset + refcounttableindex * sizeof(uint64t), &data64, sizeof(data64)); if (ret < 0) { goto failblock; } s->refcounttable[refcounttableindex] = newblock; /* The new refcount block may be where the caller intended to put its * data, so let it restart the search. */ return -EAGAIN; } ret = qcow2cacheput(bs, s->refcountblockcache, (void**) refcountblock); if (ret < 0) { goto failblock; } /* * If we come here, we need to grow the refcount table. Again, a new * refcount table needs some space and we can't simply allocate to avoid * endless recursion. * * Therefore let's grab new refcount blocks at the end of the image, which * will describe themselves and the new refcount table. This way we can * reference them only in the new table and do the switch to the new * refcount table at once without producing an inconsistent state in * between. */ BLKDBGEVENT(bs->file, BLKDBGREFTABLEGROW); /* Calculate the number of refcount blocks needed so far */ uint64t blocksused = DIVROUNDUP(clusterindex, s->refcountblocksize); if (blocksused > QCOWMAXREFTABLESIZE / sizeof(uint64t)) { return -EFBIG; } /* And now we need at least one block more for the new metadata */ uint64t tablesize = nextrefcounttablesize(s, blocksused + 1); uint64t lasttablesize; uint64t blocksclusters; do { uint64t tableclusters = sizetoclusters(s, tablesize * sizeof(uint64t)); blocksclusters = 1 + ((tableclusters + s->refcountblocksize - 1) / s->refcountblocksize); uint64t metaclusters = tableclusters + blocksclusters; lasttablesize = tablesize; tablesize = nextrefcounttablesize(s, blocksused + ((metaclusters + s->refcountblocksize - 1) / s->refcountblocksize)); } while (lasttablesize != tablesize); #ifdef DEBUGALLOC2 fprintf(stderr, \"qcow2: Grow refcount table %\" PRId32 \" => %\" PRId64 \"\\n\", s->refcounttablesize, tablesize); #endif /* Create the new refcount table and blocks */ uint64t metaoffset = (blocksused * s->refcountblocksize) * s->clustersize; uint64t tableoffset = metaoffset + blocksclusters * s->clustersize; uint64t *newtable = gtrynew0(uint64t, tablesize); uint16t *newblocks = gtrymalloc0(blocksclusters * s->clustersize); assert(tablesize > 0 && blocksclusters > 0); if (newtable == NULL || newblocks == NULL) { ret = -ENOMEM; goto failtable; } /* Fill the new refcount table */ memcpy(newtable, s->refcounttable, s->refcounttablesize * sizeof(uint64t)); newtable[refcounttableindex] = newblock; int i; for (i = 0; i < blocksclusters; i++) { newtable[blocksused + i] = metaoffset + (i * s->clustersize); } /* Fill the refcount blocks */ uint64t tableclusters = sizetoclusters(s, tablesize * sizeof(uint64t)); int block = 0; for (i = 0; i < tableclusters + blocksclusters; i++) { newblocks[block++] = cputobe16(1); } /* Write refcount blocks to disk */ BLKDBGEVENT(bs->file, BLKDBGREFBLOCKALLOCWRITEBLOCKS); ret = bdrvpwritesync(bs->file, metaoffset, newblocks, blocksclusters * s->clustersize); gfree(newblocks); newblocks = NULL; if (ret < 0) { goto failtable; } /* Write refcount table to disk */ for(i = 0; i < tablesize; i++) { cputobe64s(&newtable[i]); } BLKDBGEVENT(bs->file, BLKDBGREFBLOCKALLOCWRITETABLE); ret = bdrvpwritesync(bs->file, tableoffset, newtable, tablesize * sizeof(uint64t)); if (ret < 0) { goto failtable; } for(i = 0; i < tablesize; i++) { be64tocpus(&newtable[i]); } /* Hook up the new refcount table in the qcow2 header */ uint8t data[12]; cputobe64w((uint64t*)data, tableoffset); cputobe32w((uint32t*)(data + 8), tableclusters); BLKDBGEVENT(bs->file, BLKDBGREFBLOCKALLOCSWITCHTABLE); ret = bdrvpwritesync(bs->file, offsetof(QCowHeader, refcounttableoffset), data, sizeof(data)); if (ret < 0) { goto failtable; } /* And switch it in memory */ uint64t oldtableoffset = s->refcounttableoffset; uint64t oldtablesize = s->refcounttablesize; gfree(s->refcounttable); s->refcounttable = newtable; s->refcounttablesize = tablesize; s->refcounttableoffset = tableoffset; /* Free old table. */ qcow2freeclusters(bs, oldtableoffset, oldtablesize * sizeof(uint64t), QCOW2DISCARDOTHER); ret = loadrefcountblock(bs, newblock, (void**) refcountblock); if (ret < 0) { return ret; } /* If we were trying to do the initial refcount update for some cluster * allocation, we might have used the same clusters to store newly * allocated metadata. Make the caller search some new space. */ return -EAGAIN; failtable: gfree(newblocks); gfree(newtable); failblock: if (*refcountblock != NULL) { qcow2cacheput(bs, s->refcountblockcache, (void**) refcountblock); } return ret; } ", "target": 1}
{"func": "static int alacdecodeframe(AVCodecContext *avctx, void *outbuffer, int *outputsize, const uint8t *inbuffer, int inputbuffersize) { ALACContext *alac = avctx->privdata; int channels; unsigned int outputsamples; int hassize; int readsamplesize; int wastedbytes; int isnotcompressed; uint8t interlacingshift; uint8t interlacingleftweight; /* short-circuit null buffers */ if (!inbuffer || !inputbuffersize) return inputbuffersize; /* initialize from the extradata */ if (!alac->contextinitialized) { if (alac->avctx->extradatasize != ALACEXTRADATASIZE) { avlog(avctx, AVLOGERROR, \"alac: expected %d extradata bytes\\n\", ALACEXTRADATASIZE); return inputbuffersize; } if (alacsetinfo(alac)) { avlog(avctx, AVLOGERROR, \"alac: setinfo failed\\n\"); return inputbuffersize; } alac->contextinitialized = 1; } initgetbits(&alac->gb, inbuffer, inputbuffersize * 8); channels = getbits(&alac->gb, 3) + 1; if (channels > MAXCHANNELS) { avlog(avctx, AVLOGERROR, \"channels > %d not supported\\n\", MAXCHANNELS); return inputbuffersize; } /* 2^result = something to do with output waiting. * perhaps matters if we read > 1 frame in a pass? */ skipbits(&alac->gb, 4); skipbits(&alac->gb, 12); /* unknown, skip 12 bits */ /* the output sample size is stored soon */ hassize = getbits1(&alac->gb); wastedbytes = getbits(&alac->gb, 2); /* unknown ? */ /* whether the frame is compressed */ isnotcompressed = getbits1(&alac->gb); if (hassize) { /* now read the number of samples as a 32bit integer */ outputsamples = getbitslong(&alac->gb, 32); if(outputsamples > alac->setinfomaxsamplesperframe){ avlog(avctx, AVLOGERROR, \"outputsamples %d > %d\\n\", outputsamples, alac->setinfomaxsamplesperframe); return -1; } } else outputsamples = alac->setinfomaxsamplesperframe; if(outputsamples > *outputsize / alac->bytespersample){ avlog(avctx, AVLOGERROR, \"sample buffer too small\\n\"); return -1; } *outputsize = outputsamples * alac->bytespersample; readsamplesize = alac->setinfosamplesize - (wastedbytes * 8) + channels - 1; if (!isnotcompressed) { /* so it is compressed */ int16t predictorcoeftable[channels][32]; int predictorcoefnum[channels]; int predictiontype[channels]; int predictionquantitization[channels]; int ricemodifier[channels]; int i, chan; interlacingshift = getbits(&alac->gb, 8); interlacingleftweight = getbits(&alac->gb, 8); for (chan = 0; chan < channels; chan++) { predictiontype[chan] = getbits(&alac->gb, 4); predictionquantitization[chan] = getbits(&alac->gb, 4); ricemodifier[chan] = getbits(&alac->gb, 3); predictorcoefnum[chan] = getbits(&alac->gb, 5); /* read the predictor table */ for (i = 0; i < predictorcoefnum[chan]; i++) predictorcoeftable[chan][i] = (int16t)getbits(&alac->gb, 16); } if (wastedbytes) avlog(avctx, AVLOGERROR, \"FIXME: unimplemented, unhandling of wastedbytes\\n\"); for (chan = 0; chan < channels; chan++) { bastardizedricedecompress(alac, alac->predicterrorbuffer[chan], outputsamples, readsamplesize, alac->setinforiceinitialhistory, alac->setinforicekmodifier, ricemodifier[chan] * alac->setinforicehistorymult / 4, (1 << alac->setinforicekmodifier) - 1); if (predictiontype[chan] == 0) { /* adaptive fir */ predictordecompressfiradapt(alac->predicterrorbuffer[chan], alac->outputsamplesbuffer[chan], outputsamples, readsamplesize, predictorcoeftable[chan], predictorcoefnum[chan], predictionquantitization[chan]); } else { avlog(avctx, AVLOGERROR, \"FIXME: unhandled prediction type: %i\\n\", predictiontype[chan]); /* I think the only other prediction type (or perhaps this is * just a boolean?) runs adaptive fir twice.. like: * predictordecompressfiradapt(predictorerror, tempout, ...) * predictordecompressfiradapt(predictorerror, outputsamples ...) * little strange.. */ } } } else { /* not compressed, easy case */ int i, chan; for (i = 0; i < outputsamples; i++) for (chan = 0; chan < channels; chan++) { int32t audiobits; audiobits = getbitslong(&alac->gb, alac->setinfosamplesize); audiobits = extendsign32(audiobits, alac->setinfosamplesize); alac->outputsamplesbuffer[chan][i] = audiobits; } /* wastedbytes = 0; */ interlacingshift = 0; interlacingleftweight = 0; } if (getbits(&alac->gb, 3) != 7) avlog(avctx, AVLOGERROR, \"Error : Wrong End Of Frame\\n\"); switch(alac->setinfosamplesize) { case 16: if (channels == 2) { reconstructstereo16(alac->outputsamplesbuffer, (int16t*)outbuffer, alac->numchannels, outputsamples, interlacingshift, interlacingleftweight); } else { int i; for (i = 0; i < outputsamples; i++) { int16t sample = alac->outputsamplesbuffer[0][i]; ((int16t*)outbuffer)[i * alac->numchannels] = sample; } } break; case 20: case 24: // It is not clear if there exist any encoder that creates 24 bit ALAC // files. iTunes convert 24 bit raw files to 16 bit before encoding. case 32: avlog(avctx, AVLOGERROR, \"FIXME: unimplemented sample size %i\\n\", alac->setinfosamplesize); break; default: break; } if (inputbuffersize * 8 - getbitscount(&alac->gb) > 8) avlog(avctx, AVLOGERROR, \"Error : %d bits left\\n\", inputbuffersize * 8 - getbitscount(&alac->gb)); return inputbuffersize; } ", "target": 1}
{"func": "static int getopt(int argc, char *argv[], char *opts) { static int sp = 1; int c; char *cp; if (sp == 1) if (optind >= argc || argv[optind][0] != '-' || argv[optind][1] == '\\0') return EOF; else if (!strcmp(argv[optind], \"--\")) { optind++; return EOF; } optopt = c = argv[optind][sp]; if (c == ':' || (cp = strchr(opts, c)) == NULL) { fprintf(stderr, \": illegal option -- %c\\n\", c); if (argv[optind][++sp] == '\\0') { optind++; sp = 1; } return '?'; } if (*++cp == ':') { if (argv[optind][sp+1] != '\\0') optarg = &argv[optind++][sp+1]; else if(++optind >= argc) { fprintf(stderr, \": option requires an argument -- %c\\n\", c); sp = 1; return '?'; } else optarg = argv[optind++]; sp = 1; } else { if (argv[optind][++sp] == '\\0') { sp = 1; optind++; } optarg = NULL; } return c; } ", "target": 0}
{"func": "static void slaviotimermemwritel(void *opaque, targetphysaddrt addr, uint32t val) { SLAVIOTIMERState *s = opaque; uint32t saddr; int reload = 0; DPRINTF(\"write \" TARGETFMTplx \" %08x\\n\", addr, val); saddr = (addr & TIMERMAXADDR) >> 2; switch (saddr) { case TIMERLIMIT: if (slaviotimerisuser(s)) { // set user counter MSW, reset counter qemuirqlower(s->irq); s->limit = TIMERMAXCOUNT64; DPRINTF(\"processor %d user timer reset\\n\", s->slaveindex); ptimersetlimit(s->timer, LIMITTOPERIODS(s->limit), 1); } else { // set limit, reset counter qemuirqlower(s->irq); s->limit = val & TIMERMAXCOUNT32; if (!s->limit) s->limit = TIMERMAXCOUNT32; ptimersetlimit(s->timer, s->limit >> 9, 1); } break; case TIMERCOUNTER: if (slaviotimerisuser(s)) { // set user counter LSW, reset counter qemuirqlower(s->irq); s->limit = TIMERMAXCOUNT64; DPRINTF(\"processor %d user timer reset\\n\", s->slaveindex); ptimersetlimit(s->timer, LIMITTOPERIODS(s->limit), 1); } else DPRINTF(\"not user timer\\n\"); break; case TIMERCOUNTERNORST: // set limit without resetting counter s->limit = val & TIMERMAXCOUNT32; if (!s->limit) s->limit = TIMERMAXCOUNT32; ptimersetlimit(s->timer, LIMITTOPERIODS(s->limit), reload); break; case TIMERSTATUS: if (slaviotimerisuser(s)) { // start/stop user counter if ((val & 1) && !s->running) { DPRINTF(\"processor %d user timer started\\n\", s->slaveindex); ptimerrun(s->timer, 0); s->running = 1; } else if (!(val & 1) && s->running) { DPRINTF(\"processor %d user timer stopped\\n\", s->slaveindex); ptimerstop(s->timer); s->running = 0; } } break; case TIMERMODE: if (s->master == NULL) { unsigned int i; for (i = 0; i < s->numslaves; i++) { if (val & (1 << i)) { qemuirqlower(s->slave[i]->irq); s->slave[i]->limit = -1ULL; } if ((val & (1 << i)) != (s->slavemode & (1 << i))) { ptimerstop(s->slave[i]->timer); ptimersetlimit(s->slave[i]->timer, LIMITTOPERIODS(s->slave[i]->limit), 1); DPRINTF(\"processor %d timer changed\\n\", s->slave[i]->slaveindex); ptimerrun(s->slave[i]->timer, 0); } } s->slavemode = val & ((1 << s->numslaves) - 1); } else DPRINTF(\"not system timer\\n\"); break; default: DPRINTF(\"invalid write address \" TARGETFMTplx \"\\n\", addr); break; } } ", "target": 0}
{"func": "void qemucpukick(void *env) { return; } ", "target": 0}
{"func": "static void tempallocateframe(TCGContext *s, int temp) { TCGTemp *ts; ts = &s->temps[temp]; s->currentframeoffset = (s->currentframeoffset + sizeof(tcgtargetlong) - 1) & ~(sizeof(tcgtargetlong) - 1); if (s->currentframeoffset + sizeof(tcgtargetlong) > s->frameend) tcgabort(); ts->memoffset = s->currentframeoffset; ts->memreg = s->framereg; ts->memallocated = 1; s->currentframeoffset += sizeof(tcgtargetlong); } ", "target": 0}
{"func": "void qmpblockstream(const char *device, bool hasbase, const char *base, Error **errp) { BlockDriverState *bs; BlockDriverState *basebs = NULL; Error *localerr = NULL; bs = bdrvfind(device); if (!bs) { errorset(errp, QERRDEVICENOTFOUND, device); return; } if (base) { basebs = bdrvfindbackingimage(bs, base); if (basebs == NULL) { errorset(errp, QERRBASENOTFOUND, base); return; } } streamstart(bs, basebs, base, blockstreamcb, bs, &localerr); if (errorisset(&localerr)) { errorpropagate(errp, localerr); return; } /* Grab a reference so hotplug does not delete the BlockDriverState from * underneath us. */ drivegetref(drivegetbyblockdev(bs)); traceqmpblockstream(bs, bs->job); } ", "target": 0}
{"func": "static void mptsasscsiinit(PCIDevice *dev, Error **errp) { DeviceState *d = DEVICE(dev); MPTSASState *s = MPTSAS(dev); dev->config[PCILATENCYTIMER] = 0; dev->config[PCIINTERRUPTPIN] = 0x01; memoryregioninitio(&s->mmioio, OBJECT(s), &mptsasmmioops, s, \"mptsas-mmio\", 0x4000); memoryregioninitio(&s->portio, OBJECT(s), &mptsasportops, s, \"mptsas-io\", 256); memoryregioninitio(&s->diagio, OBJECT(s), &mptsasdiagops, s, \"mptsas-diag\", 0x10000); if (s->msi != ONOFFAUTOOFF && msiinit(dev, 0, 1, true, false) >= 0) { /* TODO check for errors */ s->msiinuse = true; } pciregisterbar(dev, 0, PCIBASEADDRESSSPACEIO, &s->portio); pciregisterbar(dev, 1, PCIBASEADDRESSSPACEMEMORY | PCIBASEADDRESSMEMTYPE32, &s->mmioio); pciregisterbar(dev, 2, PCIBASEADDRESSSPACEMEMORY | PCIBASEADDRESSMEMTYPE32, &s->diagio); if (!s->sasaddr) { s->sasaddr = ((NAALOCALLYASSIGNEDID << 24) | IEEECOMPANYLOCALLYASSIGNED) << 36; s->sasaddr |= (pcibusnum(dev->bus) << 16); s->sasaddr |= (PCISLOT(dev->devfn) << 8); s->sasaddr |= PCIFUNC(dev->devfn); } s->maxdevices = MPTSASNUMPORTS; s->requestbh = qemubhnew(mptsasfetchrequests, s); QTAILQINIT(&s->pending); scsibusnew(&s->bus, sizeof(s->bus), &dev->qdev, &mptsasscsiinfo, NULL); if (!d->hotplugged) { scsibuslegacyhandlecmdline(&s->bus, errp); } } ", "target": 1}
{"func": "static inline int numeffectivebusses(XilinxSPIPS *s) { return (s->regs[RLQSPISTS] & LQSPICFGSEPBUS && s->regs[RLQSPISTS] & LQSPICFGTWOMEM) ? s->numbusses : 1; } ", "target": 0}
{"func": "FFTContext *avfftinit(int nbits, int inverse) { FFTContext *s = avmalloc(sizeof(*s)); if (s && fffftinit(s, nbits, inverse)) avfreep(&s); return s; } ", "target": 1}
{"func": "static void gensetCFbit31(TCGv var) { TCGv tmp = newtmp(); tcggenshrii32(tmp, var, 31); gensetCF(tmp); deadtmp(tmp); } ", "target": 1}
{"func": "static int getsiz(Jpeg2000DecoderContext *s) { int i; int ncomponents; uint32t log2chromawh = 0; const enum AVPixelFormat *possiblefmts = NULL; int possiblefmtsnb = 0; if (bytestream2getbytesleft(&s->g) < 36) { avlog(s->avctx, AVLOGERROR, \"Insufficient space for SIZ\\n\"); s->avctx->profile = bytestream2getbe16u(&s->g); // Rsiz s->width = bytestream2getbe32u(&s->g); // Width s->height = bytestream2getbe32u(&s->g); // Height s->imageoffsetx = bytestream2getbe32u(&s->g); // X0Siz s->imageoffsety = bytestream2getbe32u(&s->g); // Y0Siz s->tilewidth = bytestream2getbe32u(&s->g); // XTSiz s->tileheight = bytestream2getbe32u(&s->g); // YTSiz s->tileoffsetx = bytestream2getbe32u(&s->g); // XT0Siz s->tileoffsety = bytestream2getbe32u(&s->g); // YT0Siz ncomponents = bytestream2getbe16u(&s->g); // CSiz if (s->imageoffsetx || s->imageoffsety) { avprivrequestsample(s->avctx, \"Support for image offsets\"); return AVERRORPATCHWELCOME; if (avimagechecksize(s->width, s->height, 0, s->avctx)) { avprivrequestsample(s->avctx, \"Large Dimensions\"); return AVERRORPATCHWELCOME; if (ncomponents <= 0) { avlog(s->avctx, AVLOGERROR, \"Invalid number of components: %d\\n\", if (ncomponents > 4) { avprivrequestsample(s->avctx, \"Support for %d components\", ncomponents); return AVERRORPATCHWELCOME; s->ncomponents = ncomponents; if (s->tilewidth <= 0 || s->tileheight <= 0) { avlog(s->avctx, AVLOGERROR, \"Invalid tile dimension %dx%d.\\n\", s->tilewidth, s->tileheight); if (bytestream2getbytesleft(&s->g) < 3 * s->ncomponents) { avlog(s->avctx, AVLOGERROR, \"Insufficient space for %d components in SIZ\\n\", s->ncomponents); for (i = 0; i < s->ncomponents; i++) { // Ssizi XRsizi, YRsizi uint8t x = bytestream2getbyteu(&s->g); s->cbps[i] = (x & 0x7f) + 1; s->precision = FFMAX(s->cbps[i], s->precision); s->sgnd[i] = !!(x & 0x80); s->cdx[i] = bytestream2getbyteu(&s->g); s->cdy[i] = bytestream2getbyteu(&s->g); if ( !s->cdx[i] || s->cdx[i] == 3 || s->cdx[i] > 4 || !s->cdy[i] || s->cdy[i] == 3 || s->cdy[i] > 4) { avlog(s->avctx, AVLOGERROR, \"Invalid sample separation %d/%d\\n\", s->cdx[i], s->cdy[i]); log2chromawh |= s->cdy[i] >> 1 << i * 4 | s->cdx[i] >> 1 << i * 4 + 2; s->numXtiles = ffjpeg2000ceildiv(s->width - s->tileoffsetx, s->tilewidth); s->numYtiles = ffjpeg2000ceildiv(s->height - s->tileoffsety, s->tileheight); if (s->numXtiles * (uint64t)s->numYtiles > INTMAX/sizeof(*s->tile)) { s->numXtiles = s->numYtiles = 0; return AVERROR(EINVAL); s->tile = avmalloczarray(s->numXtiles * s->numYtiles, sizeof(*s->tile)); if (!s->tile) { s->numXtiles = s->numYtiles = 0; return AVERROR(ENOMEM); for (i = 0; i < s->numXtiles * s->numYtiles; i++) { Jpeg2000Tile *tile = s->tile + i; tile->comp = avmallocz(s->ncomponents * sizeof(*tile->comp)); if (!tile->comp) return AVERROR(ENOMEM); /* compute image size with reduction factor */ s->avctx->width = ffjpeg2000ceildivpow2(s->width - s->imageoffsetx, s->reductionfactor); s->avctx->height = ffjpeg2000ceildivpow2(s->height - s->imageoffsety, s->reductionfactor); if (s->avctx->profile == FFPROFILEJPEG2000DCINEMA2K || s->avctx->profile == FFPROFILEJPEG2000DCINEMA4K) { possiblefmts = xyzpixfmts; possiblefmtsnb = FFARRAYELEMS(xyzpixfmts); } else { switch (s->colourspace) { case 16: possiblefmts = rgbpixfmts; possiblefmtsnb = FFARRAYELEMS(rgbpixfmts); break; case 17: possiblefmts = graypixfmts; possiblefmtsnb = FFARRAYELEMS(graypixfmts); break; case 18: possiblefmts = yuvpixfmts; possiblefmtsnb = FFARRAYELEMS(yuvpixfmts); break; default: possiblefmts = allpixfmts; possiblefmtsnb = FFARRAYELEMS(allpixfmts); break; for (i = 0; i < possiblefmtsnb; ++i) { if (pixfmtmatch(possiblefmts[i], ncomponents, s->precision, log2chromawh, s->pal8)) { s->avctx->pixfmt = possiblefmts[i]; break; if (i == possiblefmtsnb) { if (ncomponents == 4 && s->cdy[0] == 1 && s->cdx[0] == 1 && s->cdy[1] == 1 && s->cdx[1] == 1 && s->cdy[2] == s->cdy[3] && s->cdx[2] == s->cdx[3]) { if (s->precision == 8 && s->cdy[2] == 2 && s->cdx[2] == 2 && !s->pal8) { s->avctx->pixfmt = AVPIXFMTYUVA420P; s->cdef[0] = 0; s->cdef[1] = 1; s->cdef[2] = 2; s->cdef[3] = 3; i = 0; if (i == possiblefmtsnb) { avlog(s->avctx, AVLOGERROR, \"Unknown pixfmt, profile: %d, colourspace: %d, \" \"components: %d, precision: %d\\n\" \"cdx[0]: %d, cdy[0]: %d\\n\" \"cdx[1]: %d, cdy[1]: %d\\n\" \"cdx[2]: %d, cdy[2]: %d\\n\" \"cdx[3]: %d, cdy[3]: %d\\n\", s->avctx->profile, s->colourspace, ncomponents, s->precision, s->cdx[0], s->cdy[0], ncomponents > 1 ? s->cdx[1] : 0, ncomponents > 1 ? s->cdy[1] : 0, ncomponents > 2 ? s->cdx[2] : 0, ncomponents > 2 ? s->cdy[2] : 0, ncomponents > 3 ? s->cdx[3] : 0, ncomponents > 3 ? s->cdy[3] : 0); return AVERRORPATCHWELCOME; s->avctx->bitsperrawsample = s->precision; return 0;", "target": 1}
{"func": "static void commitsetspeed(BlockJob *job, int64t speed, Error **errp) { CommitBlockJob *s = containerof(job, CommitBlockJob, common); if (speed < 0) { errorsetg(errp, QERRINVALIDPARAMETER, \"speed\"); return; } ratelimitsetspeed(&s->limit, speed / BDRVSECTORSIZE, SLICETIME); } ", "target": 1}
{"func": "static void sd1d97int(int *p, int i0, int i1) { int i; if (i1 <= i0 + 1) { if (i0 == 1) p[1] = (p[1] * ILFTGX + (1<<15)) >> 16; else p[0] = (p[0] * ILFTGK + (1<<15)) >> 16; return; } extend97int(p, i0, i1); i0++; i1++; for (i = i0/2 - 2; i < i1/2 + 1; i++) p[2 * i + 1] -= (ILFTGALPHA * (p[2 * i] + p[2 * i + 2]) + (1 << 15)) >> 16; for (i = i0/2 - 1; i < i1/2 + 1; i++) p[2 * i] -= (ILFTGBETA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16; for (i = i0/2 - 1; i < i1/2; i++) p[2 * i + 1] += (ILFTGGAMMA * (p[2 * i] + p[2 * i + 2]) + (1 << 15)) >> 16; for (i = i0/2; i < i1/2; i++) p[2 * i] += (ILFTGDELTA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16; } ", "target": 1}
{"func": "static inline void RENAME(rgb32ToY)(uint8t *dst, uint8t *src, int width) { \tint i; \tfor(i=0; i<width; i++) \t{ \t\tint r= ((uint32t*)src)[i]&0xFF; \t\tint g= (((uint32t*)src)[i]>>8)&0xFF; \t\tint b= (((uint32t*)src)[i]>>16)&0xFF; \t\tdst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUVSHIFT-1)) )>>RGB2YUVSHIFT); \t} } ", "target": 1}
{"func": "static uint32t s390pcigeneratefid(Error **errp) { uint32t fid = 0; while (fid <= ZPCIMAXFID) { if (!s390pcifinddevbyfid(fid)) { return fid; } if (fid == ZPCIMAXFID) { break; } fid++; } errorsetg(errp, \"no free fid could be found\"); return 0; } ", "target": 0}
{"func": "static void virtio9pdeviceunrealize(DeviceState *dev, Error **errp) { VirtIODevice *vdev = VIRTIODEVICE(dev); V9fsVirtioState *v = VIRTIO9P(dev); V9fsState *s = &v->state; virtiocleanup(vdev); v9fsdeviceunrealizecommon(s, errp); } ", "target": 0}
{"func": "static int ipmoviereadpacket(AVFormatContext *s, AVPacket *pkt) { IPMVEContext *ipmovie = (IPMVEContext *)s->privdata; ByteIOContext *pb = &s->pb; int ret; ret = processipmoviechunk(ipmovie, pb, pkt); if (ret == CHUNKBAD) ret = AVERRORINVALIDDATA; else if (ret == CHUNKEOF) ret = AVERRORIO; else if (ret == CHUNKNOMEM) ret = AVERRORNOMEM; else ret = 0; return ret; } ", "target": 1}
{"func": "static int opusdecodeframe(OpusStreamContext *s, const uint8t *data, int size) { int samples = s->packet.frameduration; int redundancy = 0; int redundancysize, redundancypos; int ret, i, consumed; int delayedsamples = s->delayedsamples; ret = opusrcinit(&s->rc, data, size); if (ret < 0) return ret; /* decode the silk frame */ if (s->packet.mode == OPUSMODESILK || s->packet.mode == OPUSMODEHYBRID) { if (!swrisinitialized(s->swr)) { ret = opusinitresample(s); if (ret < 0) return ret; } samples = ffsilkdecodesuperframe(s->silk, &s->rc, s->silkoutput, FFMIN(s->packet.bandwidth, OPUSBANDWIDTHWIDEBAND), s->packet.stereo + 1, silkframedurationms[s->packet.config]); if (samples < 0) { avlog(s->avctx, AVLOGERROR, \"Error decoding a SILK frame.\\n\"); return samples; } samples = swrconvert(s->swr, (uint8t**)s->out, s->packet.frameduration, (const uint8t**)s->silkoutput, samples); if (samples < 0) { avlog(s->avctx, AVLOGERROR, \"Error resampling SILK data.\\n\"); return samples; } s->delayedsamples += s->packet.frameduration - samples; } else ffsilkflush(s->silk); // decode redundancy information consumed = opusrctell(&s->rc); if (s->packet.mode == OPUSMODEHYBRID && consumed + 37 <= size * 8) redundancy = opusrcp2model(&s->rc, 12); else if (s->packet.mode == OPUSMODESILK && consumed + 17 <= size * 8) redundancy = 1; if (redundancy) { redundancypos = opusrcp2model(&s->rc, 1); if (s->packet.mode == OPUSMODEHYBRID) redundancysize = opusrcunimodel(&s->rc, 256) + 2; else redundancysize = size - (consumed + 7) / 8; size -= redundancysize; if (size < 0) { avlog(s->avctx, AVLOGERROR, \"Invalid redundancy frame size.\\n\"); return AVERRORINVALIDDATA; } if (redundancypos) { ret = opusdecoderedundancy(s, data + size, redundancysize); if (ret < 0) return ret; ffceltflush(s->celt); } } /* decode the CELT frame */ if (s->packet.mode == OPUSMODECELT || s->packet.mode == OPUSMODEHYBRID) { float *outtmp[2] = { s->out[0], s->out[1] }; float **dst = (s->packet.mode == OPUSMODECELT) ? outtmp : s->celtoutput; int celtoutputsamples = samples; int delaysamples = avaudiofifosize(s->celtdelay); if (delaysamples) { if (s->packet.mode == OPUSMODEHYBRID) { avaudiofiforead(s->celtdelay, (void**)s->celtoutput, delaysamples); for (i = 0; i < s->outputchannels; i++) { s->fdsp->vectorfmacscalar(outtmp[i], s->celtoutput[i], 1.0, delaysamples); outtmp[i] += delaysamples; } celtoutputsamples -= delaysamples; } else { avlog(s->avctx, AVLOGWARNING, \"Spurious CELT delay samples present.\\n\"); avaudiofifodrain(s->celtdelay, delaysamples); if (s->avctx->errrecognition & AVEFEXPLODE) return AVERRORBUG; } } opusrawinit(&s->rc, data + size, size); ret = ffceltdecodeframe(s->celt, &s->rc, dst, s->packet.stereo + 1, s->packet.frameduration, (s->packet.mode == OPUSMODEHYBRID) ? 17 : 0, celtbandend[s->packet.bandwidth]); if (ret < 0) return ret; if (s->packet.mode == OPUSMODEHYBRID) { int celtdelay = s->packet.frameduration - celtoutputsamples; void *delaybuf[2] = { s->celtoutput[0] + celtoutputsamples, s->celtoutput[1] + celtoutputsamples }; for (i = 0; i < s->outputchannels; i++) { s->fdsp->vectorfmacscalar(outtmp[i], s->celtoutput[i], 1.0, celtoutputsamples); } ret = avaudiofifowrite(s->celtdelay, delaybuf, celtdelay); if (ret < 0) return ret; } } else ffceltflush(s->celt); if (s->redundancyidx) { for (i = 0; i < s->outputchannels; i++) opusfade(s->out[i], s->out[i], s->redundancyoutput[i] + 120 + s->redundancyidx, ffceltwindow2 + s->redundancyidx, 120 - s->redundancyidx); s->redundancyidx = 0; } if (redundancy) { if (!redundancypos) { ffceltflush(s->celt); ret = opusdecoderedundancy(s, data + size, redundancysize); if (ret < 0) return ret; for (i = 0; i < s->outputchannels; i++) { opusfade(s->out[i] + samples - 120 + delayedsamples, s->out[i] + samples - 120 + delayedsamples, s->redundancyoutput[i] + 120, ffceltwindow2, 120 - delayedsamples); if (delayedsamples) s->redundancyidx = 120 - delayedsamples; } } else { for (i = 0; i < s->outputchannels; i++) { memcpy(s->out[i] + delayedsamples, s->redundancyoutput[i], 120 * sizeof(float)); opusfade(s->out[i] + 120 + delayedsamples, s->redundancyoutput[i] + 120, s->out[i] + 120 + delayedsamples, ffceltwindow2, 120); } } } return samples; }", "target": 1}
{"func": "bool qemucoenternext(CoQueue *queue) { Coroutine *next; next = QSIMPLEQFIRST(&queue->entries); if (!next) { return false; } QSIMPLEQREMOVEHEAD(&queue->entries, coqueuenext); qemucoroutineenter(next, NULL); return true; } ", "target": 1}
{"func": "static int decodeChannelSoundUnit (ATRAC3Context *q, GetBitContext *gb, channelunit *pSnd, float *pOut, int channelNum, int codingMode) { int band, result=0, numSubbands, lastTonal, numBands; if (codingMode == JOINTSTEREO && channelNum == 1) { if (getbits(gb,2) != 3) { avlog(NULL,AVLOGERROR,\"JS mono Sound Unit id != 3.\\n\"); return -1; } } else { if (getbits(gb,6) != 0x28) { avlog(NULL,AVLOGERROR,\"Sound Unit id != 0x28.\\n\"); return -1; } } /* number of coded QMF bands */ pSnd->bandsCoded = getbits(gb,2); result = decodeGainControl (gb, &(pSnd->gainBlock[pSnd->gcBlkSwitch]), pSnd->bandsCoded); if (result) return result; pSnd->numComponents = decodeTonalComponents (gb, pSnd->components, pSnd->bandsCoded); if (pSnd->numComponents == -1) return -1; numSubbands = decodeSpectrum (gb, pSnd->spectrum); /* Merge the decoded spectrum and tonal components. */ lastTonal = addTonalComponents (pSnd->spectrum, pSnd->numComponents, pSnd->components); /* calculate number of used MLT/QMF bands according to the amount of coded spectral lines */ numBands = (subbandTab[numSubbands] - 1) >> 8; if (lastTonal >= 0) numBands = FFMAX((lastTonal + 256) >> 8, numBands); /* Reconstruct time domain samples. */ for (band=0; band<4; band++) { /* Perform the IMDCT step without overlapping. */ if (band <= numBands) { IMLT(&(pSnd->spectrum[band*256]), pSnd->IMDCTbuf, band&1); } else memset(pSnd->IMDCTbuf, 0, 512 * sizeof(float)); /* gain compensation and overlapping */ gainCompensateAndOverlap (pSnd->IMDCTbuf, &(pSnd->prevFrame[band*256]), &(pOut[band*256]), &((pSnd->gainBlock[1 - (pSnd->gcBlkSwitch)]).gBlock[band]), &((pSnd->gainBlock[pSnd->gcBlkSwitch]).gBlock[band])); } /* Swap the gain control buffers for the next frame. */ pSnd->gcBlkSwitch ^= 1; return 0; } ", "target": 1}
{"func": "static targetlong monitorgetreg(const struct MonitorDef *md, int val) { CPUState *env = mongetcpu(); if (!env) return 0; return env->regwptr[val]; } ", "target": 1}
{"func": "static void vp8idctdcadd4uvc(uint8t *dst, int16t block[4][16], ptrdifft stride) { vp8idctdcaddc(dst+stride*0+0, block[0], stride); vp8idctdcaddc(dst+stride*0+4, block[1], stride); vp8idctdcaddc(dst+stride*4+0, block[2], stride); vp8idctdcaddc(dst+stride*4+4, block[3], stride); } ", "target": 0}
{"func": "static void integratorcpinit(QEMUMachineInitArgs *args) { ramaddrt ramsize = args->ramsize; const char *cpumodel = args->cpumodel; const char *kernelfilename = args->kernelfilename; const char *kernelcmdline = args->kernelcmdline; const char *initrdfilename = args->initrdfilename; ARMCPU *cpu; MemoryRegion *addressspacemem = getsystemmemory(); MemoryRegion *ram = gnew(MemoryRegion, 1); MemoryRegion *ramalias = gnew(MemoryRegion, 1); qemuirq pic[32]; DeviceState *dev; int i; if (!cpumodel) { cpumodel = \"arm926\"; } cpu = cpuarminit(cpumodel); if (!cpu) { fprintf(stderr, \"Unable to find CPU definition\\n\"); exit(1); } memoryregioninitram(ram, NULL, \"integrator.ram\", ramsize); vmstateregisterramglobal(ram); /* ??? On a real system the first 1Mb is mapped as SSRAM or boot flash. */ /* ??? RAM should repeat to fill physical memory space. */ /* SDRAM at address zero*/ memoryregionaddsubregion(addressspacemem, 0, ram); /* And again at address 0x80000000 */ memoryregioninitalias(ramalias, NULL, \"ram.alias\", ram, 0, ramsize); memoryregionaddsubregion(addressspacemem, 0x80000000, ramalias); dev = qdevcreate(NULL, TYPEINTEGRATORCM); qdevpropsetuint32(dev, \"memsz\", ramsize >> 20); qdevinitnofail(dev); sysbusmmiomap((SysBusDevice *)dev, 0, 0x10000000); dev = sysbuscreatevarargs(TYPEINTEGRATORPIC, 0x14000000, qdevgetgpioin(DEVICE(cpu), ARMCPUIRQ), qdevgetgpioin(DEVICE(cpu), ARMCPUFIQ), NULL); for (i = 0; i < 32; i++) { pic[i] = qdevgetgpioin(dev, i); } sysbuscreatesimple(TYPEINTEGRATORPIC, 0xca000000, pic[26]); sysbuscreatevarargs(\"integratorpit\", 0x13000000, pic[5], pic[6], pic[7], NULL); sysbuscreatesimple(\"pl031\", 0x15000000, pic[8]); sysbuscreatesimple(\"pl011\", 0x16000000, pic[1]); sysbuscreatesimple(\"pl011\", 0x17000000, pic[2]); icpcontrolinit(0xcb000000); sysbuscreatesimple(\"pl050keyboard\", 0x18000000, pic[3]); sysbuscreatesimple(\"pl050mouse\", 0x19000000, pic[4]); sysbuscreatevarargs(\"pl181\", 0x1c000000, pic[23], pic[24], NULL); if (ndtable[0].used) smc91c111init(&ndtable[0], 0xc8000000, pic[27]); sysbuscreatesimple(\"pl110\", 0xc0000000, pic[22]); integratorbinfo.ramsize = ramsize; integratorbinfo.kernelfilename = kernelfilename; integratorbinfo.kernelcmdline = kernelcmdline; integratorbinfo.initrdfilename = initrdfilename; armloadkernel(cpu, &integratorbinfo); }", "target": 1}
{"func": "static void setvlan(Object *obj, Visitor *v, void *opaque, const char *name, Error **errp) { DeviceState *dev = DEVICE(obj); Property *prop = opaque; NICPeers *peersptr = qdevgetpropptr(dev, prop); NetClientState **ptr = &peersptr->ncs[0]; Error *localerr = NULL; int32t id; NetClientState *hubport; if (dev->realized) { qdevpropsetafterrealize(dev, name, errp); visittypeint32(v, &id, name, &localerr); if (localerr) { errorpropagate(errp, localerr); if (id == -1) { *ptr = NULL; hubport = nethubportfind(id); if (!hubport) { errorset(errp, QERRINVALIDPARAMETERVALUE, name, prop->info->name); *ptr = hubport; ", "target": 1}
{"func": "static avcold int pngdecend(AVCodecContext *avctx) { PNGDecContext *s = avctx->privdata; ffthreadreleasebuffer(avctx, &s->previouspicture); avframefree(&s->previouspicture.f); ffthreadreleasebuffer(avctx, &s->lastpicture); avframefree(&s->lastpicture.f); ffthreadreleasebuffer(avctx, &s->picture); avframefree(&s->picture.f); avfreep(&s->buffer); s->buffersize = 0; avfreep(&s->lastrow); s->lastrowsize = 0; avfreep(&s->tmprow); s->tmprowsize = 0; avfreep(&s->extradata); s->extradatasize = 0; return 0; } ", "target": 1}
{"func": "static void fdchrupdatereadhandler(CharDriverState *chr) { FDCharDriver *s = chr->opaque; if (s->fdintag) { gsourceremove(s->fdintag); s->fdintag = 0; } if (s->fdin) { s->fdintag = ioaddwatchpoll(s->fdin, fdchrreadpoll, fdchrread, chr); } } ", "target": 1}
{"func": "static int probefile(WriterContext *wctx, const char *filename) { AVFormatContext *fmtctx; int ret, i; int sectionid; doreadframes = doshowframes || docountframes; doreadpackets = doshowpackets || docountpackets; ret = openinputfile(&fmtctx, filename); if (ret < 0) return ret; #define CHECKEND if (ret < 0) goto end nbstreamsframes = avcalloc(fmtctx->nbstreams, sizeof(*nbstreamsframes)); nbstreamspackets = avcalloc(fmtctx->nbstreams, sizeof(*nbstreamspackets)); selectedstreams = avcalloc(fmtctx->nbstreams, sizeof(*selectedstreams)); for (i = 0; i < fmtctx->nbstreams; i++) { if (streamspecifier) { ret = avformatmatchstreamspecifier(fmtctx, fmtctx->streams[i], streamspecifier); CHECKEND; else selectedstreams[i] = ret; ret = 0; } else { selectedstreams[i] = 1; } } if (doreadframes || doreadpackets) { if (doshowframes && doshowpackets && wctx->writer->flags & WRITERFLAGPUTPACKETSANDFRAMESINSAMECHAPTER) sectionid = SECTIONIDPACKETSANDFRAMES; else if (doshowpackets && !doshowframes) sectionid = SECTIONIDPACKETS; else // (!doshowpackets && doshowframes) sectionid = SECTIONIDFRAMES; if (doshowframes || doshowpackets) writerprintsectionheader(wctx, sectionid); ret = readpackets(wctx, fmtctx); if (doshowframes || doshowpackets) writerprintsectionfooter(wctx); CHECKEND; } if (doshowprograms) { ret = showprograms(wctx, fmtctx); CHECKEND; } if (doshowstreams) { ret = showstreams(wctx, fmtctx); CHECKEND; } if (doshowchapters) { ret = showchapters(wctx, fmtctx); CHECKEND; } if (doshowformat) { ret = showformat(wctx, fmtctx); CHECKEND; } end: closeinputfile(&fmtctx); avfreep(&nbstreamsframes); avfreep(&nbstreamspackets); avfreep(&selectedstreams); return ret; } ", "target": 1}
{"func": "static int kvmphysicalsyncdirtybitmap(targetphysaddrt startaddr, targetphysaddrt endaddr) { KVMState *s = kvmstate; unsigned long size, allocatedsize = 0; KVMDirtyLog d; KVMSlot *mem; int ret = 0; d.dirtybitmap = NULL; while (startaddr < endaddr) { mem = kvmlookupoverlappingslot(s, startaddr, endaddr); if (mem == NULL) { break; } size = ALIGN(((mem->memorysize) >> TARGETPAGEBITS), HOSTLONGBITS) / 8; if (!d.dirtybitmap) { d.dirtybitmap = qemumalloc(size); } else if (size > allocatedsize) { d.dirtybitmap = qemurealloc(d.dirtybitmap, size); } allocatedsize = size; memset(d.dirtybitmap, 0, allocatedsize); d.slot = mem->slot; if (kvmvmioctl(s, KVMGETDIRTYLOG, &d) == -1) { DPRINTF(\"ioctl failed %d\\n\", errno); ret = -1; break; } kvmgetdirtypageslogrange(mem->startaddr, d.dirtybitmap, mem->startaddr, mem->memorysize); startaddr = mem->startaddr + mem->memorysize; } qemufree(d.dirtybitmap); return ret; } ", "target": 1}
{"func": "static void filter(USPPContext *p, uint8t *dst[3], uint8t *src[3], int dststride[3], int srcstride[3], int width, int height, uint8t *qpstore, int qpstride) { int x, y, i, j; const int count = 1<<p->log2count; for (i = 0; i < 3; i++) { int ischroma = !!i; int w = width >> (ischroma ? p->hsub : 0); int h = height >> (ischroma ? p->vsub : 0); int stride = p->tempstride[i]; int block = BLOCK >> (ischroma ? p->hsub : 0); if (!src[i] || !dst[i]) continue; for (y = 0; y < h; y++) { int index = block + block * stride + y * stride; memcpy(p->src[i] + index, src[i] + y * srcstride[i], w ); for (x = 0; x < block; x++) { p->src[i][index - x - 1] = p->src[i][index + x ]; p->src[i][index + w + x ] = p->src[i][index + w - x - 1]; } } for (y = 0; y < block; y++) { memcpy(p->src[i] + ( block-1-y) * stride, p->src[i] + ( y+block ) * stride, stride); memcpy(p->src[i] + (h+block +y) * stride, p->src[i] + (h-y+block-1) * stride, stride); } p->frame->linesize[i] = stride; memset(p->temp[i], 0, (h + 2 * block) * stride * sizeof(int16t)); } if (p->qp) p->frame->quality = p->qp * FFQP2LAMBDA; else { int qpsum=0; int qpcount = (height>>4) * (height>>4); for (y = 0; y < (height>>4); y++) { for (x = 0; x < (width>>4); x++) qpsum += qpstore[x + y * qpstride]; } p->frame->quality = normqscale((qpsum + qpcount/2) / qpcount, p->qscaletype) * FFQP2LAMBDA; } // init per MB qscale stuff FIXME p->frame->height = height; p->frame->width = width; for (i = 0; i < count; i++) { const int x1 = offset[i+count-1][0]; const int y1 = offset[i+count-1][1]; const int x1c = x1 >> p->hsub; const int y1c = y1 >> p->vsub; const int BLOCKc = BLOCK >> p->hsub; int offset; AVPacket pkt; int gotpktptr; avinitpacket(&pkt); pkt.data = p->outbuf; pkt.size = p->outbufsize; p->frame->data[0] = p->src[0] + x1 + y1 * p->frame->linesize[0]; p->frame->data[1] = p->src[1] + x1c + y1c * p->frame->linesize[1]; p->frame->data[2] = p->src[2] + x1c + y1c * p->frame->linesize[2]; p->frame->format = p->avctxenc[i]->pixfmt; avcodecencodevideo2(p->avctxenc[i], &pkt, p->frame, &gotpktptr); p->framedec = p->avctxenc[i]->codedframe; offset = (BLOCK-x1) + (BLOCK-y1) * p->framedec->linesize[0]; for (y = 0; y < height; y++) for (x = 0; x < width; x++) p->temp[0][x + y * p->tempstride[0]] += p->framedec->data[0][x + y * p->framedec->linesize[0] + offset]; if (!src[2] || !dst[2]) continue; offset = (BLOCKc-x1c) + (BLOCKc-y1c) * p->framedec->linesize[1]; for (y = 0; y < height>>p->vsub; y++) { for (x = 0; x < width>>p->hsub; x++) { p->temp[1][x + y * p->tempstride[1]] += p->framedec->data[1][x + y * p->framedec->linesize[1] + offset]; p->temp[2][x + y * p->tempstride[2]] += p->framedec->data[2][x + y * p->framedec->linesize[2] + offset]; } } } for (j = 0; j < 3; j++) { int ischroma = !!j; if (!dst[j]) continue; storeslicec(dst[j], p->temp[j], dststride[j], p->tempstride[j], width >> (ischroma ? p->hsub : 0), height >> (ischroma ? p->vsub : 0), 8-p->log2count); } } ", "target": 1}
{"func": "int main(void) { int nf; Suite *s; SRunner *sr; s = qfloatsuite(); sr = srunnercreate(s); srunnerrunall(sr, CKNORMAL); nf = srunnerntestsfailed(sr); srunnerfree(sr); return (nf == 0) ? EXITSUCCESS : EXITFAILURE; } ", "target": 0}
{"func": "static targetulong puttceemu(sPAPRTCETable *tcet, targetulong ioba, targetulong tce) { IOMMUTLBEntry entry; hwaddr pagemask = IOMMUPAGEMASK(tcet->pageshift); unsigned long index = (ioba - tcet->busoffset) >> tcet->pageshift; if (index >= tcet->nbtable) { hcalldprintf(\"spaprvioputtce on out-of-bounds IOBA 0x\" TARGETFMTlx \"\\n\", ioba); return HPARAMETER; } tcet->table[index] = tce; entry.targetas = &addressspacememory, entry.iova = ioba & pagemask; entry.translatedaddr = tce & pagemask; entry.addrmask = ~pagemask; entry.perm = spaprtceiommuaccessflags(tce); memoryregionnotifyiommu(&tcet->iommu, entry); return HSUCCESS; } ", "target": 0}
{"func": "static targetulong henter(CPUState *env, sPAPREnvironment *spapr, targetulong opcode, targetulong *args) { targetulong flags = args[0]; targetulong pteindex = args[1]; targetulong pteh = args[2]; targetulong ptel = args[3]; targetulong i; uint8t *hpte; /* only handle 4k and 16M pages for now */ if (pteh & HPTEVLARGE) { #if 0 /* We don't support 64k pages yet */ if ((ptel & 0xf000) == 0x1000) { /* 64k page */ } else #endif if ((ptel & 0xff000) == 0) { /* 16M page */ /* lowest AVA bit must be 0 for 16M pages */ if (pteh & 0x80) { return HPARAMETER; } } else { return HPARAMETER; } } /* FIXME: bounds check the pa? */ /* Check WIMG */ if ((ptel & HPTERWIMG) != HPTERM) { return HPARAMETER; } pteh &= ~0x60ULL; if ((pteindex * HASHPTESIZE64) & ~env->htabmask) { return HPARAMETER; } if (likely((flags & HEXACT) == 0)) { pteindex &= ~7ULL; hpte = env->externalhtab + (pteindex * HASHPTESIZE64); for (i = 0; ; ++i) { if (i == 8) { return HPTEGFULL; } if (((ldqp(hpte) & HPTEVVALID) == 0) && lockhpte(hpte, HPTEVHVLOCK | HPTEVVALID)) { break; } hpte += HASHPTESIZE64; } } else { i = 0; hpte = env->externalhtab + (pteindex * HASHPTESIZE64); if (!lockhpte(hpte, HPTEVHVLOCK | HPTEVVALID)) { return HPTEGFULL; } } stqp(hpte + (HASHPTESIZE64/2), ptel); /* eieio(); FIXME: need some sort of barrier for smp? */ stqp(hpte, pteh); assert(!(ldqp(hpte) & HPTEVHVLOCK)); args[0] = pteindex + i; return HSUCCESS; } ", "target": 0}
{"func": "static inline void genoparithadd(DisasContext *ctx, TCGv ret, TCGv arg1, TCGv arg2, int addca, int computeca, int computeov) { TCGv t0, t1; if ((!computeca && !computeov) || (!TCGVEQUAL(ret,arg1) && !TCGVEQUAL(ret, arg2))) { t0 = ret; } else { t0 = tcgtemplocalnew(); } if (addca) { t1 = tcgtemplocalnew(); tcggenmovtl(t1, cpuca); } else { TCGVUNUSED(t1); } if (computeca) { /* Start with XER CA disabled, the most likely case */ tcggenmovitl(cpuca, 0); } if (computeov) { /* Start with XER OV disabled, the most likely case */ tcggenmovitl(cpuov, 0); } tcggenaddtl(t0, arg1, arg2); if (computeca) { genoparithcomputeca(ctx, t0, arg1, 0); } if (addca) { tcggenaddtl(t0, t0, t1); genoparithcomputeca(ctx, t0, t1, 0); tcgtempfree(t1); } if (computeov) { genoparithcomputeov(ctx, t0, arg1, arg2, 0); } if (unlikely(Rc(ctx->opcode) != 0)) gensetRc0(ctx, t0); if (!TCGVEQUAL(t0, ret)) { tcggenmovtl(ret, t0); tcgtempfree(t0); } } ", "target": 1}
{"func": "static inline void RENAME(rgb15tobgr24)(const uint8t *src, uint8t *dst, int srcsize) { const uint16t *end; const uint16t *mmend; uint8t *d = dst; const uint16t *s = (const uint16t*)src; end = s + srcsize/2; asm volatile(PREFETCH\" %0\"::\"m\"(*s):\"memory\"); mmend = end - 7; while (s < mmend) { asm volatile( PREFETCH\" 32%1 \\n\\t\" \"movq %1, %%mm0 \\n\\t\" \"movq %1, %%mm1 \\n\\t\" \"movq %1, %%mm2 \\n\\t\" \"pand %2, %%mm0 \\n\\t\" \"pand %3, %%mm1 \\n\\t\" \"pand %4, %%mm2 \\n\\t\" \"psllq $3, %%mm0 \\n\\t\" \"psrlq $2, %%mm1 \\n\\t\" \"psrlq $7, %%mm2 \\n\\t\" \"movq %%mm0, %%mm3 \\n\\t\" \"movq %%mm1, %%mm4 \\n\\t\" \"movq %%mm2, %%mm5 \\n\\t\" \"punpcklwd %5, %%mm0 \\n\\t\" \"punpcklwd %5, %%mm1 \\n\\t\" \"punpcklwd %5, %%mm2 \\n\\t\" \"punpckhwd %5, %%mm3 \\n\\t\" \"punpckhwd %5, %%mm4 \\n\\t\" \"punpckhwd %5, %%mm5 \\n\\t\" \"psllq $8, %%mm1 \\n\\t\" \"psllq $16, %%mm2 \\n\\t\" \"por %%mm1, %%mm0 \\n\\t\" \"por %%mm2, %%mm0 \\n\\t\" \"psllq $8, %%mm4 \\n\\t\" \"psllq $16, %%mm5 \\n\\t\" \"por %%mm4, %%mm3 \\n\\t\" \"por %%mm5, %%mm3 \\n\\t\" \"movq %%mm0, %%mm6 \\n\\t\" \"movq %%mm3, %%mm7 \\n\\t\" \"movq 8%1, %%mm0 \\n\\t\" \"movq 8%1, %%mm1 \\n\\t\" \"movq 8%1, %%mm2 \\n\\t\" \"pand %2, %%mm0 \\n\\t\" \"pand %3, %%mm1 \\n\\t\" \"pand %4, %%mm2 \\n\\t\" \"psllq $3, %%mm0 \\n\\t\" \"psrlq $2, %%mm1 \\n\\t\" \"psrlq $7, %%mm2 \\n\\t\" \"movq %%mm0, %%mm3 \\n\\t\" \"movq %%mm1, %%mm4 \\n\\t\" \"movq %%mm2, %%mm5 \\n\\t\" \"punpcklwd %5, %%mm0 \\n\\t\" \"punpcklwd %5, %%mm1 \\n\\t\" \"punpcklwd %5, %%mm2 \\n\\t\" \"punpckhwd %5, %%mm3 \\n\\t\" \"punpckhwd %5, %%mm4 \\n\\t\" \"punpckhwd %5, %%mm5 \\n\\t\" \"psllq $8, %%mm1 \\n\\t\" \"psllq $16, %%mm2 \\n\\t\" \"por %%mm1, %%mm0 \\n\\t\" \"por %%mm2, %%mm0 \\n\\t\" \"psllq $8, %%mm4 \\n\\t\" \"psllq $16, %%mm5 \\n\\t\" \"por %%mm4, %%mm3 \\n\\t\" \"por %%mm5, %%mm3 \\n\\t\" :\"=m\"(*d) :\"m\"(*s),\"m\"(mask15b),\"m\"(mask15g),\"m\"(mask15r), \"m\"(mmxnull) :\"memory\"); /* borrowed 32 to 24 */ asm volatile( \"movq %%mm0, %%mm4 \\n\\t\" \"movq %%mm3, %%mm5 \\n\\t\" \"movq %%mm6, %%mm0 \\n\\t\" \"movq %%mm7, %%mm1 \\n\\t\" \"movq %%mm4, %%mm6 \\n\\t\" \"movq %%mm5, %%mm7 \\n\\t\" \"movq %%mm0, %%mm2 \\n\\t\" \"movq %%mm1, %%mm3 \\n\\t\" STOREBGR24MMX :\"=m\"(*d) :\"m\"(*s) :\"memory\"); d += 24; s += 8; } asm volatile(SFENCE:::\"memory\"); asm volatile(EMMS:::\"memory\"); while (s < end) { register uint16t bgr; bgr = *s++; *d++ = (bgr&0x1F)<<3; *d++ = (bgr&0x3E0)>>2; *d++ = (bgr&0x7C00)>>7; } } ", "target": 1}
{"func": "int inetdgramopts(QemuOpts *opts) { struct addrinfo ai, *peer = NULL, *local = NULL; const char *addr; const char *port; char uaddr[INET6ADDRSTRLEN+1]; char uport[33]; int sock = -1, rc; /* lookup peer addr */ memset(&ai,0, sizeof(ai)); ai.aiflags = AICANONNAME | AIADDRCONFIG; ai.aifamily = PFUNSPEC; ai.aisocktype = SOCKDGRAM; addr = qemuoptget(opts, \"host\"); port = qemuoptget(opts, \"port\"); if (addr == NULL || strlen(addr) == 0) { addr = \"localhost\"; } if (port == NULL || strlen(port) == 0) { fprintf(stderr, \"inetdgram: port not specified\\n\"); return -1; } if (qemuoptgetbool(opts, \"ipv4\", 0)) ai.aifamily = PFINET; if (qemuoptgetbool(opts, \"ipv6\", 0)) ai.aifamily = PFINET6; if (0 != (rc = getaddrinfo(addr, port, &ai, &peer))) { fprintf(stderr,\"getaddrinfo(%s,%s): %s\\n\", addr, port, gaistrerror(rc)); \treturn -1; } if (socketsdebug) { fprintf(stderr, \"%s: peer (%s:%s)\\n\", FUNCTION, addr, port); inetprintaddrinfo(FUNCTION, peer); } /* lookup local addr */ memset(&ai,0, sizeof(ai)); ai.aiflags = AIPASSIVE; ai.aifamily = peer->aifamily; ai.aisocktype = SOCKDGRAM; addr = qemuoptget(opts, \"localaddr\"); port = qemuoptget(opts, \"localport\"); if (addr == NULL || strlen(addr) == 0) { addr = NULL; } if (!port || strlen(port) == 0) port = \"0\"; if (0 != (rc = getaddrinfo(addr, port, &ai, &local))) { fprintf(stderr,\"getaddrinfo(%s,%s): %s\\n\", addr, port, gaistrerror(rc)); return -1; } if (socketsdebug) { fprintf(stderr, \"%s: local (%s:%s)\\n\", FUNCTION, addr, port); inetprintaddrinfo(FUNCTION, local); } /* create socket */ sock = socket(peer->aifamily, peer->aisocktype, peer->aiprotocol); if (sock < 0) { fprintf(stderr,\"%s: socket(%s): %s\\n\", FUNCTION, inetstrfamily(peer->aifamily), strerror(errno)); goto err; } setsockopt(sock,SOLSOCKET,SOREUSEADDR,(void*)&on,sizeof(on)); /* bind socket */ if (getnameinfo((struct sockaddr*)local->aiaddr,local->aiaddrlen, uaddr,INET6ADDRSTRLEN,uport,32, NINUMERICHOST | NINUMERICSERV) != 0) { fprintf(stderr, \"%s: getnameinfo: oops\\n\", FUNCTION); goto err; } if (bind(sock, local->aiaddr, local->aiaddrlen) < 0) { fprintf(stderr,\"%s: bind(%s,%s,%d): OK\\n\", FUNCTION, inetstrfamily(local->aifamily), uaddr, inetgetport(local)); goto err; } /* connect to peer */ if (getnameinfo((struct sockaddr*)peer->aiaddr, peer->aiaddrlen, uaddr, INET6ADDRSTRLEN, uport, 32, NINUMERICHOST | NINUMERICSERV) != 0) { fprintf(stderr, \"%s: getnameinfo: oops\\n\", FUNCTION); goto err; } if (connect(sock,peer->aiaddr,peer->aiaddrlen) < 0) { fprintf(stderr, \"%s: connect(%s,%s,%s,%s): %s\\n\", FUNCTION, inetstrfamily(peer->aifamily), peer->aicanonname, uaddr, uport, strerror(errno)); goto err; } freeaddrinfo(local); freeaddrinfo(peer); return sock; err: if (-1 != sock) closesocket(sock); if (local) freeaddrinfo(local); if (peer) freeaddrinfo(peer); return -1; } ", "target": 1}
{"func": "static int ftpfilesize(FTPContext *s) { char command[CONTROLBUFFERSIZE]; char *res = NULL; const int sizecodes[] = {213, 0}; snprintf(command, sizeof(command), \"SIZE %s\\r\\n\", s->path); if (ftpsendcommand(s, command, sizecodes, &res)) { s->filesize = strtoll(&res[4], NULL, 10); } else { s->filesize = -1; avfree(res); return AVERROR(EIO); } avfree(res); return 0; } ", "target": 0}
{"func": "static void tcgoutqemuld(TCGContext *s, const TCGArg *args, bool is64) { TCGReg datalo, datahi, addrlo, rbase; TCGReg addrhi attribute((unused)); TCGMemOpIdx oi; TCGMemOp opc, sbits; #ifdef CONFIGSOFTMMU int memindex; tcginsnunit *labelptr; #endif datalo = *args++; datahi = (TCGTARGETREGBITS == 32 && is64 ? *args++ : 0); addrlo = *args++; addrhi = (TCGTARGETREGBITS < TARGETLONGBITS ? *args++ : 0); oi = *args++; opc = getmemop(oi); sbits = opc & MOSIZE; #ifdef CONFIGSOFTMMU memindex = getmmuidx(oi); addrlo = tcgouttlbread(s, sbits, addrlo, addrhi, memindex, true); /* Load a pointer into the current opcode w/conditional branch-link. */ labelptr = s->codeptr; tcgoutbcnoaddr(s, BC | BI(7, CREQ) | BOCONDFALSE | LK); rbase = TCGREGR3; #else /* !CONFIGSOFTMMU */ rbase = GUESTBASE ? TCGGUESTBASEREG : 0; if (TCGTARGETREGBITS > TARGETLONGBITS) { tcgoutext32u(s, TCGREGTMP1, addrlo); addrlo = TCGREGTMP1; } #endif if (TCGTARGETREGBITS == 32 && sbits == MO64) { if (opc & MOBSWAP) { tcgout32(s, ADDI | TAI(TCGREGR0, addrlo, 4)); tcgout32(s, LWBRX | TAB(datalo, rbase, addrlo)); tcgout32(s, LWBRX | TAB(datahi, rbase, TCGREGR0)); } else if (rbase != 0) { tcgout32(s, ADDI | TAI(TCGREGR0, addrlo, 4)); tcgout32(s, LWZX | TAB(datahi, rbase, addrlo)); tcgout32(s, LWZX | TAB(datalo, rbase, TCGREGR0)); } else if (addrlo == datahi) { tcgout32(s, LWZ | TAI(datalo, addrlo, 4)); tcgout32(s, LWZ | TAI(datahi, addrlo, 0)); } else { tcgout32(s, LWZ | TAI(datahi, addrlo, 0)); tcgout32(s, LWZ | TAI(datalo, addrlo, 4)); } } else { uint32t insn = qemuldxopc[opc & (MOBSWAP | MOSSIZE)]; if (!HAVEISA206 && insn == LDBRX) { tcgout32(s, ADDI | TAI(TCGREGR0, addrlo, 4)); tcgout32(s, LWBRX | TAB(datalo, rbase, addrlo)); tcgout32(s, LWBRX | TAB(TCGREGR0, rbase, TCGREGR0)); tcgoutrld(s, RLDIMI, datalo, TCGREGR0, 32, 0); } else if (insn) { tcgout32(s, insn | TAB(datalo, rbase, addrlo)); } else { insn = qemuldxopc[opc & (MOSIZE | MOBSWAP)]; tcgout32(s, insn | TAB(datalo, rbase, addrlo)); insn = qemuextsopc[sbits]; tcgout32(s, insn | RA(datalo) | RS(datalo)); } } #ifdef CONFIGSOFTMMU addqemuldstlabel(s, true, oi, datalo, datahi, addrlo, addrhi, s->codeptr, labelptr); #endif } ", "target": 1}
{"func": "int ffh264decoderefpicmarking(const H264Context *h, H264SliceContext *sl, GetBitContext *gb) { int i; MMCO *mmco = sl->mmco; int nbmmco = 0; if (h->nalunittype == NALIDRSLICE) { // FIXME fields skipbits1(gb); // brokenlink if (getbits1(gb)) { mmco[0].opcode = MMCOLONG; mmco[0].longarg = 0; nbmmco = 1; } sl->explicitrefmarking = 1; } else { sl->explicitrefmarking = getbits1(gb); if (sl->explicitrefmarking) { for (i = 0; i < MAXMMCOCOUNT; i++) { MMCOOpcode opcode = getuegolomb31(gb); mmco[i].opcode = opcode; if (opcode == MMCOSHORT2UNUSED || opcode == MMCOSHORT2LONG) { mmco[i].shortpicnum = (sl->currpicnum - getuegolomb(gb) - 1) & (sl->maxpicnum - 1); #if 0 if (mmco[i].shortpicnum >= h->shortrefcount || !h->shortref[mmco[i].shortpicnum]) { avlog(s->avctx, AVLOGERROR, \"illegal short ref in memory management control \" \"operation %d\\n\", mmco); return -1; } #endif } if (opcode == MMCOSHORT2LONG || opcode == MMCOLONG2UNUSED || opcode == MMCOLONG || opcode == MMCOSETMAXLONG) { unsigned int longarg = getuegolomb31(gb); if (longarg >= 32 || (longarg >= 16 && !(opcode == MMCOSETMAXLONG && longarg == 16) && !(opcode == MMCOLONG2UNUSED && FIELDPICTURE(h)))) { avlog(h->avctx, AVLOGERROR, \"illegal long ref in memory management control \" \"operation %d\\n\", opcode); return -1; } mmco[i].longarg = longarg; } if (opcode > (unsigned) MMCOLONG) { avlog(h->avctx, AVLOGERROR, \"illegal memory management control operation %d\\n\", opcode); return -1; } if (opcode == MMCOEND) break; } nbmmco = i; } } sl->nbmmco = nbmmco; return 0; } ", "target": 0}
{"func": " void cpush4invalidatetlb(CPUSH4State *s) { int i; /* UTLB */ for (i = 0; i < UTLBSIZE; i++) { tlbt * entry = &s->utlb[i]; entry->v = 0; } /* ITLB */ for (i = 0; i < UTLBSIZE; i++) { tlbt * entry = &s->utlb[i]; entry->v = 0; } tlbflush(s, 1); } ", "target": 0}
{"func": "uint16t netchecksumfinish(uint32t sum) { while (sum>>16) \tsum = (sum & 0xFFFF)+(sum >> 16); return ~sum; } ", "target": 0}
{"func": "static void pciinitmaskbridge(PCIDevice *d) { /* PCIPRIMARYBUS, PCISECONDARYBUS, PCISUBORDINATEBUS and PCISECLETENCYTIMER */ memset(d->wmask + PCIPRIMARYBUS, 0xff, 4); /* base and limit */ d->wmask[PCIIOBASE] = PCIIORANGEMASK & 0xff; d->wmask[PCIIOLIMIT] = PCIIORANGEMASK & 0xff; pcisetword(d->wmask + PCIMEMORYBASE, PCIMEMORYRANGEMASK & 0xffff); pcisetword(d->wmask + PCIMEMORYLIMIT, PCIMEMORYRANGEMASK & 0xffff); pcisetword(d->wmask + PCIPREFMEMORYBASE, PCIPREFRANGEMASK & 0xffff); pcisetword(d->wmask + PCIPREFMEMORYLIMIT, PCIPREFRANGEMASK & 0xffff); /* PCIPREFBASEUPPER32 and PCIPREFLIMITUPPER32 */ memset(d->wmask + PCIPREFBASEUPPER32, 0xff, 8); /* Supported memory and i/o types */ d->config[PCIIOBASE] |= PCIIORANGETYPE16; d->config[PCIIOLIMIT] |= PCIIORANGETYPE16; pciwordtestandsetmask(d->config + PCIPREFMEMORYBASE, PCIPREFRANGETYPE64); pciwordtestandsetmask(d->config + PCIPREFMEMORYLIMIT, PCIPREFRANGETYPE64); /* TODO: add this define to pciregs.h in linux and then in qemu. */ #define PCIBRIDGECTLVGA16BIT\t0x10\t/* VGA 16-bit decode */ #define PCIBRIDGECTLDISCARD\t\t0x100\t/* Primary discard timer */ #define PCIBRIDGECTLSECDISCARD\t0x200\t/* Secondary discard timer */ #define PCIBRIDGECTLDISCARDSTATUS\t0x400\t/* Discard timer status */ #define PCIBRIDGECTLDISCARDSERR\t0x800\t/* Discard timer SERR# enable */ /* * TODO: Bridges default to 10-bit VGA decoding but we currently only * implement 16-bit decoding (no alias support). */ pcisetword(d->wmask + PCIBRIDGECONTROL, PCIBRIDGECTLPARITY | PCIBRIDGECTLSERR | PCIBRIDGECTLISA | PCIBRIDGECTLVGA | PCIBRIDGECTLVGA16BIT | PCIBRIDGECTLMASTERABORT | PCIBRIDGECTLBUSRESET | PCIBRIDGECTLFASTBACK | PCIBRIDGECTLDISCARD | PCIBRIDGECTLSECDISCARD | PCIBRIDGECTLDISCARDSERR); /* Below does not do anything as we never set this bit, put here for * completeness. */ pcisetword(d->w1cmask + PCIBRIDGECONTROL, PCIBRIDGECTLDISCARDSTATUS); d->cmask[PCIIOBASE] |= PCIIORANGETYPEMASK; d->cmask[PCIIOLIMIT] |= PCIIORANGETYPEMASK; pciwordtestandsetmask(d->cmask + PCIPREFMEMORYBASE, PCIPREFRANGETYPEMASK); pciwordtestandsetmask(d->cmask + PCIPREFMEMORYLIMIT, PCIPREFRANGETYPEMASK); } ", "target": 0}
{"func": "static TranslationBlock *tballoc(targetulong pc) { TranslationBlock *tb; TBContext *ctx; asserttblocked(); tb = tcgtballoc(&tcgctx); if (unlikely(tb == NULL)) { return NULL; } ctx = &tcgctx.tbctx; if (unlikely(ctx->nbtbs == ctx->tbssize)) { ctx->tbssize *= 2; ctx->tbs = grenew(TranslationBlock *, ctx->tbs, ctx->tbssize); } ctx->tbs[ctx->nbtbs++] = tb; tb->pc = pc; tb->cflags = 0; tb->invalid = false; return tb; } ", "target": 0}
{"func": "static void gpollfdsfromselect(void) { int fd; for (fd = 0; fd <= nfds; fd++) { int events = 0; if (FDISSET(fd, &rfds)) { events |= GIOIN | GIOHUP | GIOERR; } if (FDISSET(fd, &wfds)) { events |= GIOOUT | GIOERR; } if (FDISSET(fd, &xfds)) { events |= GIOPRI; } if (events) { GPollFD pfd = { .fd = fd, .events = events, }; garrayappendval(gpollfds, pfd); } } } ", "target": 0}
{"func": "static int decodeframe(AVCodecContext *avctx, void *data, int *gotframe, AVPacket *avpkt) { TiffContext *const s = avctx->privdata; AVFrame *const p = data; ThreadFrame frame = { .f = data }; unsigned off; int le, ret, plane, planes; int i, j, entries, stride; unsigned soff, ssize; uint8t *dst; GetByteContext stripsizes; GetByteContext stripdata; bytestream2init(&s->gb, avpkt->data, avpkt->size); // parse image header if ((ret = fftdecodeheader(&s->gb, &le, &off))) { avlog(avctx, AVLOGERROR, \"Invalid TIFF header\\n\"); return ret; } else if (off >= UINTMAX - 14 || avpkt->size < off + 14) { avlog(avctx, AVLOGERROR, \"IFD offset is greater than image size\\n\"); return AVERRORINVALIDDATA; } s->le = le; // TIFFBPP is not a required tag and defaults to 1 s->bppcount = s->bpp = 1; s->photometric = TIFFPHOTOMETRICNONE; s->compr = TIFFRAW; s->fillorder = 0; freegeotags(s); // Reset these offsets so we can tell if they were set this frame s->stripsizesoff = s->strippos = 0; /* parse image file directory */ bytestream2seek(&s->gb, off, SEEKSET); entries = fftgetshort(&s->gb, le); if (bytestream2getbytesleft(&s->gb) < entries * 12) return AVERRORINVALIDDATA; for (i = 0; i < entries; i++) { if ((ret = tiffdecodetag(s, p)) < 0) return ret; } for (i = 0; i<s->geotagcount; i++) { const char *keyname = getgeokeyname(s->geotags[i].key); if (!keyname) { avlog(avctx, AVLOGWARNING, \"Unknown or unsupported GeoTIFF key %d\\n\", s->geotags[i].key); continue; } if (getgeokeytype(s->geotags[i].key) != s->geotags[i].type) { avlog(avctx, AVLOGWARNING, \"Type of GeoTIFF key %d is wrong\\n\", s->geotags[i].key); continue; } ret = avdictset(avprivframegetmetadatap(p), keyname, s->geotags[i].val, 0); if (ret<0) { avlog(avctx, AVLOGERROR, \"Writing metadata with key '%s' failed\\n\", keyname); return ret; } } if (!s->strippos && !s->stripoff) { avlog(avctx, AVLOGERROR, \"Image data is missing\\n\"); return AVERRORINVALIDDATA; } /* now we have the data and may start decoding */ if ((ret = initimage(s, &frame)) < 0) return ret; if (s->strips == 1 && !s->stripsize) { avlog(avctx, AVLOGWARNING, \"Image data size missing\\n\"); s->stripsize = avpkt->size - s->stripoff; } if (s->stripsizesoff) { if (s->stripsizesoff >= (unsigned)avpkt->size) return AVERRORINVALIDDATA; bytestream2init(&stripsizes, avpkt->data + s->stripsizesoff, avpkt->size - s->stripsizesoff); } if (s->strippos) { if (s->strippos >= (unsigned)avpkt->size) return AVERRORINVALIDDATA; bytestream2init(&stripdata, avpkt->data + s->strippos, avpkt->size - s->strippos); } if (s->rps <= 0) { avlog(avctx, AVLOGERROR, \"rps %d invalid\\n\", s->rps); return AVERRORINVALIDDATA; } planes = s->planar ? s->bppcount : 1; for (plane = 0; plane < planes; plane++) { stride = p->linesize[plane]; dst = p->data[plane]; for (i = 0; i < s->height; i += s->rps) { if (s->stripsizesoff) ssize = fftget(&stripsizes, s->sstype, le); else ssize = s->stripsize; if (s->strippos) soff = fftget(&stripdata, s->sot, le); else soff = s->stripoff; if (soff > avpkt->size || ssize > avpkt->size - soff) { avlog(avctx, AVLOGERROR, \"Invalid strip size/offset\\n\"); return AVERRORINVALIDDATA; } if ((ret = tiffunpackstrip(s, p, dst, stride, avpkt->data + soff, ssize, i, FFMIN(s->rps, s->height - i))) < 0) { if (avctx->errrecognition & AVEFEXPLODE) return ret; break; } dst += s->rps * stride; } if (s->predictor == 2) { if (s->photometric == TIFFPHOTOMETRICYCBCR) { avlog(s->avctx, AVLOGERROR, \"predictor == 2 with YUV is unsupported\"); return AVERRORPATCHWELCOME; } dst = p->data[plane]; soff = s->bpp >> 3; if (s->planar) soff = FFMAX(soff / s->bppcount, 1); ssize = s->width * soff; if (s->avctx->pixfmt == AVPIXFMTRGB48LE || s->avctx->pixfmt == AVPIXFMTRGBA64LE || s->avctx->pixfmt == AVPIXFMTGRAY16LE || s->avctx->pixfmt == AVPIXFMTYA16LE || s->avctx->pixfmt == AVPIXFMTGBRP16LE || s->avctx->pixfmt == AVPIXFMTGBRAP16LE) { for (i = 0; i < s->height; i++) { for (j = soff; j < ssize; j += 2) AVWL16(dst + j, AVRL16(dst + j) + AVRL16(dst + j - soff)); dst += stride; } } else if (s->avctx->pixfmt == AVPIXFMTRGB48BE || s->avctx->pixfmt == AVPIXFMTRGBA64BE || s->avctx->pixfmt == AVPIXFMTGRAY16BE || s->avctx->pixfmt == AVPIXFMTYA16BE || s->avctx->pixfmt == AVPIXFMTGBRP16BE || s->avctx->pixfmt == AVPIXFMTGBRAP16BE) { for (i = 0; i < s->height; i++) { for (j = soff; j < ssize; j += 2) AVWB16(dst + j, AVRB16(dst + j) + AVRB16(dst + j - soff)); dst += stride; } } else { for (i = 0; i < s->height; i++) { for (j = soff; j < ssize; j++) dst[j] += dst[j - soff]; dst += stride; } } } if (s->photometric == TIFFPHOTOMETRICWHITEISZERO) { dst = p->data[plane]; for (i = 0; i < s->height; i++) { for (j = 0; j < stride; j++) dst[j] = (s->avctx->pixfmt == AVPIXFMTPAL8 ? (1<<s->bpp) - 1 : 255) - dst[j]; dst += stride; } } } if (s->planar && s->bppcount > 2) { FFSWAP(uint8t*, p->data[0], p->data[2]); FFSWAP(int, p->linesize[0], p->linesize[2]); FFSWAP(uint8t*, p->data[0], p->data[1]); FFSWAP(int, p->linesize[0], p->linesize[1]); } *gotframe = 1; return avpkt->size; } ", "target": 0}
{"func": "int attributealignarg avcodecdecodevideo2(AVCodecContext *avctx, AVFrame *picture, int *gotpictureptr, AVPacket *avpkt) { int ret; *gotpictureptr = 0; if ((avctx->codedwidth || avctx->codedheight) && avimagechecksize(avctx->codedwidth, avctx->codedheight, 0, avctx)) return -1; avctx->pkt = avpkt; applyparamchange(avctx, avpkt); avcodecgetframedefaults(picture); if ((avctx->codec->capabilities & CODECCAPDELAY) || avpkt->size || (avctx->activethreadtype & FFTHREADFRAME)) { if (HAVETHREADS && avctx->activethreadtype & FFTHREADFRAME) ret = ffthreaddecodeframe(avctx, picture, gotpictureptr, avpkt); else { ret = avctx->codec->decode(avctx, picture, gotpictureptr, avpkt); picture->pktdts = avpkt->dts; picture->sampleaspectratio = avctx->sampleaspectratio; picture->width = avctx->width; picture->height = avctx->height; picture->format = avctx->pixfmt; } emmsc(); //needed to avoid an emmsc() call before every return; if (*gotpictureptr) avctx->framenumber++; } else ret = 0; /* many decoders assign whole AVFrames, thus overwriting extendeddata; * make sure it's set correctly */ picture->extendeddata = picture->data; return ret; } ", "target": 0}
{"func": "static int megasaspdgetinfosubmit(SCSIDevice *sdev, int lun, MegasasCmd *cmd) { struct mfipdinfo *info = cmd->iovbuf; sizet dcmdsize = sizeof(struct mfipdinfo); uint64t pdsize; uint16t pdid = ((sdev->id & 0xFF) << 8) | (lun & 0xFF); uint8t cmdbuf[6]; SCSIRequest *req; sizet len, resid; if (!cmd->iovbuf) { cmd->iovbuf = gmalloc0(dcmdsize); info = cmd->iovbuf; info->inquirydata[0] = 0x7f; /* Force PQual 0x3, PType 0x1f */ info->vpdpage83[0] = 0x7f; megasassetupinquiry(cmdbuf, 0, sizeof(info->inquirydata)); req = scsireqnew(sdev, cmd->index, lun, cmdbuf, cmd); if (!req) { tracemegasasdcmdreqallocfailed(cmd->index, \"PD get info std inquiry\"); gfree(cmd->iovbuf); cmd->iovbuf = NULL; return MFISTATFLASHALLOCFAIL; } tracemegasasdcmdinternalsubmit(cmd->index, \"PD get info std inquiry\", lun); len = scsireqenqueue(req); if (len > 0) { cmd->iovsize = len; scsireqcontinue(req); } return MFISTATINVALIDSTATUS; } else if (info->inquirydata[0] != 0x7f && info->vpdpage83[0] == 0x7f) { megasassetupinquiry(cmdbuf, 0x83, sizeof(info->vpdpage83)); req = scsireqnew(sdev, cmd->index, lun, cmdbuf, cmd); if (!req) { tracemegasasdcmdreqallocfailed(cmd->index, \"PD get info vpd inquiry\"); return MFISTATFLASHALLOCFAIL; } tracemegasasdcmdinternalsubmit(cmd->index, \"PD get info vpd inquiry\", lun); len = scsireqenqueue(req); if (len > 0) { cmd->iovsize = len; scsireqcontinue(req); } return MFISTATINVALIDSTATUS; } /* Finished, set FW state */ if ((info->inquirydata[0] >> 5) == 0) { if (megasasisjbod(cmd->state)) { info->fwstate = cputole16(MFIPDSTATESYSTEM); } else { info->fwstate = cputole16(MFIPDSTATEONLINE); } } else { info->fwstate = cputole16(MFIPDSTATEOFFLINE); } info->ref.v.deviceid = cputole16(pdid); info->state.ddf.pdtype = cputole16(MFIPDDDFTYPEINVD| MFIPDDDFTYPEINTFSAS); blkgetgeometry(sdev->conf.blk, &pdsize); info->rawsize = cputole64(pdsize); info->noncoercedsize = cputole64(pdsize); info->coercedsize = cputole64(pdsize); info->encldeviceid = 0xFFFF; info->slotnumber = (sdev->id & 0xFF); info->pathinfo.count = 1; info->pathinfo.sasaddr[0] = cputole64(megasasgetsataaddr(pdid)); info->connectedportbitmap = 0x1; info->devicespeed = 1; info->linkspeed = 1; resid = dmabufread(cmd->iovbuf, dcmdsize, &cmd->qsg); gfree(cmd->iovbuf); cmd->iovsize = dcmdsize - resid; cmd->iovbuf = NULL; return MFISTATOK; } ", "target": 1}
{"func": "static void genisel(DisasContext *ctx) { int l1, l2; uint32t bi = rC(ctx->opcode); uint32t mask; TCGvi32 t0; l1 = gennewlabel(); l2 = gennewlabel(); mask = 0x08 >> (bi & 0x03); t0 = tcgtempnewi32(); tcggenandii32(t0, cpucrf[bi >> 2], mask); tcggenbrcondii32(TCGCONDEQ, t0, 0, l1); if (rA(ctx->opcode) == 0) tcggenmovitl(cpugpr[rD(ctx->opcode)], 0); else tcggenmovtl(cpugpr[rD(ctx->opcode)], cpugpr[rA(ctx->opcode)]); tcggenbr(l2); gensetlabel(l1); tcggenmovtl(cpugpr[rD(ctx->opcode)], cpugpr[rB(ctx->opcode)]); gensetlabel(l2); tcgtempfreei32(t0); } ", "target": 0}
{"func": "static void streamprocessmem2s(struct Stream *s, StreamSlave *txdev) { uint32t prevd; unsigned char txbuf[16 * 1024]; unsigned int txlen; uint32t app[6]; if (!streamrunning(s) || streamidle(s)) { return; } while (1) { streamdescload(s, s->regs[RCURDESC]); if (s->desc.status & SDESCSTATUSCOMPLETE) { s->regs[RDMASR] |= DMASRHALTED; break; } if (streamdescsof(&s->desc)) { s->pos = 0; memcpy(app, s->desc.app, sizeof app); } txlen = s->desc.control & SDESCCTRLLENMASK; if ((txlen + s->pos) > sizeof txbuf) { hwerror(\"%s: too small internal txbuf! %d\\n\", func, txlen + s->pos); } cpuphysicalmemoryread(s->desc.bufferaddress, txbuf + s->pos, txlen); s->pos += txlen; if (streamdesceof(&s->desc)) { streampush(txdev, txbuf, s->pos, app); s->pos = 0; streamcomplete(s); } /* Update the descriptor. */ s->desc.status = txlen | SDESCSTATUSCOMPLETE; streamdescstore(s, s->regs[RCURDESC]); /* Advance. */ prevd = s->regs[RCURDESC]; s->regs[RCURDESC] = s->desc.nxtdesc; if (prevd == s->regs[RTAILDESC]) { s->regs[RDMASR] |= DMASRIDLE; break; } } } ", "target": 0}
{"func": "static int adpcmdecodeinit(AVCodecContext * avctx) { ADPCMContext *c = avctx->privdata; if(avctx->channels > 2U){ return -1; } c->channel = 0; c->status[0].predictor = c->status[1].predictor = 0; c->status[0].stepindex = c->status[1].stepindex = 0; c->status[0].step = c->status[1].step = 0; switch(avctx->codec->id) { case CODECIDADPCMCT: c->status[0].step = c->status[1].step = 511; break; case CODECIDADPCMIMAWS: if (avctx->extradata && avctx->extradatasize == 2 * 4) { c->status[0].predictor = AVRL32(avctx->extradata); c->status[1].predictor = AVRL32(avctx->extradata + 4); } break; default: break; } return 0; } ", "target": 0}
{"func": "static inline void bthcieventcompletereadlocalname(struct bthcis *hci) { readlocalnamerp params; params.status = HCISUCCESS; memset(params.name, 0, sizeof(params.name)); if (hci->device.lmpname) strncpy(params.name, hci->device.lmpname, sizeof(params.name)); bthcieventcomplete(hci, &params, READLOCALNAMERPSIZE); } ", "target": 1}
{"func": "static bool vncshouldupdate(VncState *vs) { switch (vs->update) { case VNCSTATEUPDATENONE: break; case VNCSTATEUPDATEINCREMENTAL: /* Only allow incremental updates if the output buffer * is empty, or if audio capture is enabled. */ if (!vs->output.offset || vs->audiocap) { return true; } break; case VNCSTATEUPDATEFORCE: return true; } return false; } ", "target": 1}
{"func": "static void testqemustrtollwhitespace(void) { const char *str = \" \\t \"; char f = 'X'; const char *endptr = &f; int64t res = 999; int err; err = qemustrtoll(str, &endptr, 0, &res); gassertcmpint(err, ==, 0); gassertcmpint(res, ==, 0); gassert(endptr == str); } ", "target": 1}
{"func": "static void testmigrate(void) { char *uri = gstrdupprintf(\"unix:%s/migsocket\", tmpfs); QTestState *global = globalqtest, *from, *to; unsigned char destbytea, destbyteb, destbytec, destbyted; gchar *cmd; QDict *rsp; char *bootpath = gstrdupprintf(\"%s/bootsect\", tmpfs); FILE *bootfile = fopen(bootpath, \"wb\"); gotstop = false; gassertcmpint(fwrite(bootsect, 512, 1, bootfile), ==, 1); fclose(bootfile); cmd = gstrdupprintf(\"-machine accel=kvm:tcg -m 150M\" \" -name pcsource,debug-threads=on\" \" -serial file:%s/srcserial\" \" -drive file=%s,format=raw\", tmpfs, bootpath); from = qteststart(cmd); gfree(cmd); cmd = gstrdupprintf(\"-machine accel=kvm:tcg -m 150M\" \" -name pcdest,debug-threads=on\" \" -serial file:%s/destserial\" \" -drive file=%s,format=raw\" \" -incoming %s\", tmpfs, bootpath, uri); to = qtestinit(cmd); gfree(cmd); globalqtest = from; rsp = qmp(\"{ 'execute': 'migrate-set-capabilities',\" \"'arguments': { \" \"'capabilities': [ {\" \"'capability': 'postcopy-ram',\" \"'state': true } ] } }\"); gassert(qdicthaskey(rsp, \"return\")); QDECREF(rsp); globalqtest = to; rsp = qmp(\"{ 'execute': 'migrate-set-capabilities',\" \"'arguments': { \" \"'capabilities': [ {\" \"'capability': 'postcopy-ram',\" \"'state': true } ] } }\"); gassert(qdicthaskey(rsp, \"return\")); QDECREF(rsp); /* We want to pick a speed slow enough that the test completes * quickly, but that it doesn't complete precopy even on a slow * machine, so also set the downtime. */ globalqtest = from; rsp = qmp(\"{ 'execute': 'migratesetspeed',\" \"'arguments': { 'value': 100000000 } }\"); gassert(qdicthaskey(rsp, \"return\")); QDECREF(rsp); /* 1ms downtime - it should never finish precopy */ rsp = qmp(\"{ 'execute': 'migratesetdowntime',\" \"'arguments': { 'value': 0.001 } }\"); gassert(qdicthaskey(rsp, \"return\")); QDECREF(rsp); /* Wait for the first serial output from the source */ waitforserial(\"srcserial\"); cmd = gstrdupprintf(\"{ 'execute': 'migrate',\" \"'arguments': { 'uri': '%s' } }\", uri); rsp = qmp(cmd); gfree(cmd); gassert(qdicthaskey(rsp, \"return\")); QDECREF(rsp); waitformigrationpass(); rsp = returnorevent(qmp(\"{ 'execute': 'migrate-start-postcopy' }\")); gassert(qdicthaskey(rsp, \"return\")); QDECREF(rsp); if (!gotstop) { qmpeventwait(\"STOP\"); } globalqtest = to; qmpeventwait(\"RESUME\"); waitforserial(\"destserial\"); globalqtest = from; waitformigrationcomplete(); qtestquit(from); globalqtest = to; qtestmemread(to, startaddress, &destbytea, 1); /* Destination still running, wait for a byte to change */ do { qtestmemread(to, startaddress, &destbyteb, 1); usleep(10 * 1000); } while (destbytea == destbyteb); qmp(\"{ 'execute' : 'stop'}\"); /* With it stopped, check nothing changes */ qtestmemread(to, startaddress, &destbytec, 1); sleep(1); qtestmemread(to, startaddress, &destbyted, 1); gassertcmpint(destbytec, ==, destbyted); checkguestsram(); qtestquit(to); gfree(uri); globalqtest = global; cleanup(\"bootsect\"); cleanup(\"migsocket\"); cleanup(\"srcserial\"); cleanup(\"destserial\"); } ", "target": 0}
{"func": "static uint8t nettxpktgetgsotype(struct NetTxPkt *pkt, bool tsoenable) { uint8t rc = VIRTIONETHDRGSONONE; uint16t l3proto; l3proto = ethgetl3proto(pkt->vec[NETTXPKTL2HDRFRAG].iovbase, pkt->vec[NETTXPKTL2HDRFRAG].iovlen); if (!tsoenable) { goto funcexit; } rc = ethgetgsotype(l3proto, pkt->vec[NETTXPKTL3HDRFRAG].iovbase, pkt->l4proto); funcexit: return rc; } ", "target": 0}
{"func": "static int scsireqlength(SCSIRequest *req, uint8t *cmd) { switch (cmd[0] >> 5) { case 0: req->cmd.xfer = cmd[4]; req->cmd.len = 6; /* length 0 means 256 blocks */ if (req->cmd.xfer == 0) req->cmd.xfer = 256; break; case 1: case 2: req->cmd.xfer = cmd[8] | (cmd[7] << 8); req->cmd.len = 10; break; case 4: req->cmd.xfer = cmd[13] | (cmd[12] << 8) | (cmd[11] << 16) | (cmd[10] << 24); req->cmd.len = 16; break; case 5: req->cmd.xfer = cmd[9] | (cmd[8] << 8) | (cmd[7] << 16) | (cmd[6] << 24); req->cmd.len = 12; break; default: tracescsireqparsebad(req->dev->id, req->lun, req->tag, cmd[0]); return -1; } switch(cmd[0]) { case TESTUNITREADY: case STARTSTOP: case SEEK6: case WRITEFILEMARKS: case SPACE: case RESERVE: case RELEASE: case ERASE: case ALLOWMEDIUMREMOVAL: case VERIFY: case SEEK10: case SYNCHRONIZECACHE: case LOCKUNLOCKCACHE: case LOADUNLOAD: case SETCDSPEED: case SETLIMITS: case WRITELONG: case MOVEMEDIUM: case UPDATEBLOCK: req->cmd.xfer = 0; break; case MODESENSE: break; case WRITESAME: req->cmd.xfer = 1; break; case READCAPACITY: req->cmd.xfer = 8; break; case READBLOCKLIMITS: req->cmd.xfer = 6; break; case READPOSITION: req->cmd.xfer = 20; break; case SENDVOLUMETAG: req->cmd.xfer *= 40; break; case MEDIUMSCAN: req->cmd.xfer *= 8; break; case WRITE10: case WRITEVERIFY: case WRITE6: case WRITE12: case WRITEVERIFY12: case WRITE16: case WRITEVERIFY16: req->cmd.xfer *= req->dev->blocksize; break; case READ10: case READ6: case READREVERSE: case RECOVERBUFFEREDDATA: case READ12: case READ16: req->cmd.xfer *= req->dev->blocksize; break; case INQUIRY: req->cmd.xfer = cmd[4] | (cmd[3] << 8); break; case MAINTENANCEOUT: case MAINTENANCEIN: if (req->dev->type == TYPEROM) { /* GPCMDREPORTKEY and GPCMDSENDKEY from multi media commands */ req->cmd.xfer = cmd[9] | (cmd[8] << 8); } break; } return 0; } ", "target": 1}
{"func": "int ffschroqueuepushback(FFSchroQueue *queue, void *pdata) { FFSchroQueueElement *pnew = avmallocz(sizeof(FFSchroQueueElement)); if (!pnew) return -1; pnew->data = pdata; if (!queue->phead) queue->phead = pnew; else queue->ptail->next = pnew; queue->ptail = pnew; ++queue->size; return 0; } ", "target": 1}
{"func": "int kvmppcresethtab(int shifthint) { uint32t shift = shifthint; if (!kvmenabled()) { /* Full emulation, tell caller to allocate htab itself */ return 0; } if (kvmcheckextension(kvmstate, KVMCAPPPCALLOCHTAB)) { int ret; ret = kvmvmioctl(kvmstate, KVMPPCALLOCATEHTAB, &shift); if (ret == -ENOTTY) { /* At least some versions of PR KVM advertise the * capability, but don't implement the ioctl(). Oops. * Return 0 so that we allocate the htab in qemu, as is * correct for PR. */ return 0; } else if (ret < 0) { return ret; } return shift; } /* We have a kernel that predates the htab reset calls. For PR * KVM, we need to allocate the htab ourselves, for an HV KVM of * this era, it has allocated a 16MB fixed size hash table already. */ if (kvmppcispr(kvmstate)) { /* PR - tell caller to allocate htab */ return 0; } else { /* HV - assume 16MB kernel allocated htab */ return 24; } } ", "target": 1}
{"func": "static int ptxdecodeframe(AVCodecContext *avctx, void *data, int *datasize, AVPacket *avpkt) { const uint8t *buf = avpkt->data; PTXContext * const s = avctx->privdata; AVFrame *picture = data; AVFrame * const p = &s->picture; unsigned int offset, w, h, y, stride, bytesperpixel; uint8t *ptr; offset = AVRL16(buf); w = AVRL16(buf+8); h = AVRL16(buf+10); bytesperpixel = AVRL16(buf+12) >> 3; if (bytesperpixel != 2) { avlogaskforsample(avctx, \"Image format is not RGB15.\\n\"); return -1; } avctx->pixfmt = PIXFMTRGB555; if (bufend - buf < offset) if (offset != 0x2c) avlogaskforsample(avctx, \"offset != 0x2c\\n\"); buf += offset; if (p->data[0]) avctx->releasebuffer(avctx, p); if (avimagechecksize(w, h, 0, avctx)) return -1; if (w != avctx->width || h != avctx->height) avcodecsetdimensions(avctx, w, h); if (avctx->getbuffer(avctx, p) < 0) { avlog(avctx, AVLOGERROR, \"getbuffer() failed\\n\"); return -1; } p->picttype = AVPICTURETYPEI; ptr = p->data[0]; stride = p->linesize[0]; for (y=0; y<h; y++) { if (bufend - buf < w * bytesperpixel) break; #if HAVEBIGENDIAN unsigned int x; for (x=0; x<w*bytesperpixel; x+=bytesperpixel) AVWN16(ptr+x, AVRL16(buf+x)); #else memcpy(ptr, buf, w*bytesperpixel); #endif ptr += stride; buf += w*bytesperpixel; } *picture = s->picture; *datasize = sizeof(AVPicture); return offset + w*h*bytesperpixel; }", "target": 1}
{"func": "static void vpcclose(BlockDriverState *bs) { BDRVVPCState *s = bs->opaque; gfree(s->pagetable); #ifdef CACHE gfree(s->pageentryu8); #endif migratedelblocker(s->migrationblocker); errorfree(s->migrationblocker); } ", "target": 1}
{"func": "POWERPCFAMILY(POWER9)(ObjectClass *oc, void *data) { DeviceClass *dc = DEVICECLASS(oc); PowerPCCPUClass *pcc = POWERPCCPUCLASS(oc); CPUClass *cc = CPUCLASS(oc); dc->fwname = \"PowerPC,POWER9\"; dc->desc = \"POWER9\"; dc->props = powerpcservercpuproperties; pcc->pvrmatch = ppcpvrmatchpower9; pcc->pcrmask = PCRCOMPAT205 | PCRCOMPAT206 | PCRCOMPAT207; pcc->pcrsupported = PCRCOMPAT300 | PCRCOMPAT207 | PCRCOMPAT206 | PCRCOMPAT205; pcc->initproc = initprocPOWER9; pcc->checkpow = checkpownocheck; cc->haswork = cpuhasworkPOWER9; pcc->insnsflags = PPCINSNSBASE | PPCISEL | PPCSTRING | PPCMFTB | PPCFLOAT | PPCFLOATFSEL | PPCFLOATFRES | PPCFLOATFSQRT | PPCFLOATFRSQRTE | PPCFLOATFRSQRTES | PPCFLOATSTFIWX | PPCFLOATEXT | PPCCACHE | PPCCACHEICBI | PPCCACHEDCBZ | PPCMEMSYNC | PPCMEMEIEIO | PPCMEMTLBIE | PPCMEMTLBSYNC | PPC64B | PPC64BX | PPCALTIVEC | PPCSEGMENT64B | PPCSLBI | PPCPOPCNTB | PPCPOPCNTWD | PPCCILDST; pcc->insnsflags2 = PPC2VSX | PPC2VSX207 | PPC2DFP | PPC2DBRX | PPC2PERMISA206 | PPC2DIVEISA206 | PPC2ATOMICISA206 | PPC2FPCVTISA206 | PPC2FPTSTISA206 | PPC2BCTARISA207 | PPC2LSQISA207 | PPC2ALTIVEC207 | PPC2ISA205 | PPC2ISA207S | PPC2FPCVTS64 | PPC2TM | PPC2PMISA206 | PPC2ISA300; pcc->msrmask = (1ull << MSRSF) | (1ull << MSRTM) | (1ull << MSRVR) | (1ull << MSRVSX) | (1ull << MSREE) | (1ull << MSRPR) | (1ull << MSRFP) | (1ull << MSRME) | (1ull << MSRFE0) | (1ull << MSRSE) | (1ull << MSRDE) | (1ull << MSRFE1) | (1ull << MSRIR) | (1ull << MSRDR) | (1ull << MSRPMM) | (1ull << MSRRI) | (1ull << MSRLE); pcc->mmumodel = POWERPCMMU300; #if defined(CONFIGSOFTMMU) pcc->handlemmufault = ppc64v3handlemmufault; /* segment page size remain the same */ pcc->sps = &POWER7POWER8sps; pcc->radixpageinfo = &POWER9radixpageinfo; #endif pcc->excpmodel = POWERPCEXCPPOWER8; pcc->busmodel = PPCFLAGSINPUTPOWER7; pcc->bfdmach = bfdmachppc64; pcc->flags = POWERPCFLAGVRE | POWERPCFLAGSE | POWERPCFLAGBE | POWERPCFLAGPMM | POWERPCFLAGBUSCLK | POWERPCFLAGCFAR | POWERPCFLAGVSX | POWERPCFLAGTM; pcc->l1dcachesize = 0x8000; pcc->l1icachesize = 0x8000; pcc->interruptsbigendian = ppccpuinterruptsbigendianlpcr; } ", "target": 1}
{"func": "static int mxfreadheader(AVFormatContext *s, AVFormatParameters *ap) { MXFContext *mxf = s->privdata; KLVPacket klv; int64t essenceoffset = 0; mxf->lastforwardtell = INT64MAX; if (!mxfreadsync(s->pb, mxfheaderpartitionpackkey, 14)) { avlog(s, AVLOGERROR, \"could not find header partition pack key\\n\"); return AVERRORINVALIDDATA; } avioseek(s->pb, -14, SEEKCUR); mxf->fc = s; mxf->runin = aviotell(s->pb); while (!s->pb->eofreached) { const MXFMetadataReadTableEntry *metadata; if (klvreadpacket(&klv, s->pb) < 0) { /* EOF - seek to previous partition or stop */ if(mxfparsehandlepartitionoreof(mxf) <= 0) break; else continue; } PRINTKEY(s, \"read header\", klv.key); avdlog(s, \"size %\"PRIu64\" offset %#\"PRIx64\"\\n\", klv.length, klv.offset); if (ISKLVKEY(klv.key, mxfencryptedtripletkey) || ISKLVKEY(klv.key, mxfessenceelementkey) || ISKLVKEY(klv.key, mxfavidessenceelementkey) || ISKLVKEY(klv.key, mxfsystemitemkey)) { if (!mxf->currentpartition->essenceoffset) { computepartitionessenceoffset(s, mxf, &klv); } if (!essenceoffset) essenceoffset = klv.offset; /* seek to footer, previous partition or stop */ if (mxfparsehandleessence(mxf) <= 0) break; continue; } else if (!memcmp(klv.key, mxfheaderpartitionpackkey, 13) && klv.key[13] >= 2 && klv.key[13] <= 4 && mxf->currentpartition) { /* next partition pack - keep going, seek to previous partition or stop */ if(mxfparsehandlepartitionoreof(mxf) <= 0) break; } for (metadata = mxfmetadatareadtable; metadata->read; metadata++) { if (ISKLVKEY(klv.key, metadata->key)) { int res; if (klv.key[5] == 0x53) { res = mxfreadlocaltags(mxf, &klv, metadata->read, metadata->ctxsize, metadata->type); } else { uint64t next = aviotell(s->pb) + klv.length; res = metadata->read(mxf, s->pb, 0, klv.length, klv.key, klv.offset); avioseek(s->pb, next, SEEKSET); } if (res < 0) { avlog(s, AVLOGERROR, \"error reading header metadata\\n\"); return res; } break; } } if (!metadata->read) avioskip(s->pb, klv.length); } /* FIXME avoid seek */ if (!essenceoffset) { avlog(s, AVLOGERROR, \"no essence\\n\"); return AVERRORINVALIDDATA; } avioseek(s->pb, essenceoffset, SEEKSET); mxfcomputeessencecontainers(mxf); return mxfparsestructuralmetadata(mxf); } ", "target": 1}
{"func": "static opjimaget *mj2createimage(AVCodecContext *avctx, opjcparameterst *parameters) { const AVPixFmtDescriptor *desc = avpixfmtdescget(avctx->pixfmt); opjimagecmptparmt cmptparm[4] = {{0}}; opjimaget *img; int i; int subdx[4]; int subdy[4]; int numcomps; OPJCOLORSPACE colorspace = CLRSPCUNKNOWN; subdx[0] = subdx[3] = 1; subdy[0] = subdy[3] = 1; subdx[1] = subdx[2] = 1 << desc->log2chromaw; subdy[1] = subdy[2] = 1 << desc->log2chromah; numcomps = desc->nbcomponents; switch (avctx->pixfmt) { case AVPIXFMTGRAY8: case AVPIXFMTYA8: case AVPIXFMTGRAY16: case AVPIXFMTYA16: colorspace = CLRSPCGRAY; break; case AVPIXFMTRGB24: case AVPIXFMTRGBA: case AVPIXFMTRGB48: case AVPIXFMTRGBA64: case AVPIXFMTGBR24P: case AVPIXFMTGBRP9: case AVPIXFMTGBRP10: case AVPIXFMTGBRP12: case AVPIXFMTGBRP14: case AVPIXFMTGBRP16: case AVPIXFMTXYZ12: colorspace = CLRSPCSRGB; break; case AVPIXFMTYUV410P: case AVPIXFMTYUV411P: case AVPIXFMTYUV420P: case AVPIXFMTYUV422P: case AVPIXFMTYUV440P: case AVPIXFMTYUV444P: case AVPIXFMTYUVA420P: case AVPIXFMTYUVA422P: case AVPIXFMTYUVA444P: case AVPIXFMTYUV420P9: case AVPIXFMTYUV422P9: case AVPIXFMTYUV444P9: case AVPIXFMTYUVA420P9: case AVPIXFMTYUVA422P9: case AVPIXFMTYUVA444P9: case AVPIXFMTYUV420P10: case AVPIXFMTYUV422P10: case AVPIXFMTYUV444P10: case AVPIXFMTYUVA420P10: case AVPIXFMTYUVA422P10: case AVPIXFMTYUVA444P10: case AVPIXFMTYUV420P12: case AVPIXFMTYUV422P12: case AVPIXFMTYUV444P12: case AVPIXFMTYUV420P14: case AVPIXFMTYUV422P14: case AVPIXFMTYUV444P14: case AVPIXFMTYUV420P16: case AVPIXFMTYUV422P16: case AVPIXFMTYUV444P16: case AVPIXFMTYUVA420P16: case AVPIXFMTYUVA422P16: case AVPIXFMTYUVA444P16: colorspace = CLRSPCSYCC; break; default: avlog(avctx, AVLOGERROR, \"The requested pixel format '%s' is not supported\\n\", avgetpixfmtname(avctx->pixfmt)); } for (i = 0; i < numcomps; i++) { cmptparm[i].prec = desc->comp[i].depthminus1 + 1; cmptparm[i].bpp = desc->comp[i].depthminus1 + 1; cmptparm[i].sgnd = 0; cmptparm[i].dx = subdx[i]; cmptparm[i].dy = subdy[i]; cmptparm[i].w = (avctx->width + subdx[i] - 1) / subdx[i]; cmptparm[i].h = (avctx->height + subdy[i] - 1) / subdy[i]; } img = opjimagecreate(numcomps, cmptparm, colorspace); // x0, y0 is the top left corner of the image // x1, y1 is the width, height of the reference grid img->x0 = 0; img->y0 = 0; img->x1 = (avctx->width - 1) * parameters->subsamplingdx + 1; img->y1 = (avctx->height - 1) * parameters->subsamplingdy + 1; return img; }", "target": 1}
{"func": "static int xenplatforminitfn(PCIDevice *dev) { PCIXenPlatformState *d = DOUPCAST(PCIXenPlatformState, pcidev, dev); uint8t *pciconf; pciconf = d->pcidev.config; pcisetword(pciconf + PCICOMMAND, PCICOMMANDIO | PCICOMMANDMEMORY); pciconfigsetproginterface(pciconf, 0); pciconf[PCIINTERRUPTPIN] = 1; pciregisterbar(&d->pcidev, 0, 0x100, PCIBASEADDRESSSPACEIO, platformioportmap); /* reserve 16MB mmio address for share memory*/ pciregisterbar(&d->pcidev, 1, 0x1000000, PCIBASEADDRESSMEMPREFETCH, platformmmiomap); platformfixedioportinit(d); return 0; } ", "target": 0}
{"func": "static int proxysymlink(FsContext *fsctx, const char *oldpath, V9fsPath *dirpath, const char *name, FsCred *credp) { int retval; V9fsString fullname, target; v9fsstringinit(&fullname); v9fsstringinit(&target); v9fsstringsprintf(&fullname, \"%s/%s\", dirpath->data, name); v9fsstringsprintf(&target, \"%s\", oldpath); retval = v9fsrequest(fsctx->private, TSYMLINK, NULL, \"ssdd\", &target, &fullname, credp->fcuid, credp->fcgid); v9fsstringfree(&fullname); v9fsstringfree(&target); if (retval < 0) { errno = -retval; retval = -1; } return retval; } ", "target": 0}
{"func": "static int vfioenableintx(VFIODevice *vdev) { VFIOIRQSetFD irqsetfd = { .irqset = { .argsz = sizeof(irqsetfd), .flags = VFIOIRQSETDATAEVENTFD | VFIOIRQSETACTIONTRIGGER, .index = VFIOPCIINTXIRQINDEX, .start = 0, .count = 1, }, }; uint8t pin = vfiopcireadconfig(&vdev->pdev, PCIINTERRUPTPIN, 1); int ret; if (vdev->intx.disabled || !pin) { return 0; } vfiodisableinterrupts(vdev); vdev->intx.pin = pin - 1; /* Pin A (1) -> irq[0] */ ret = eventnotifierinit(&vdev->intx.interrupt, 0); if (ret) { errorreport(\"vfio: Error: eventnotifierinit failed\\n\"); return ret; } irqsetfd.fd = eventnotifiergetfd(&vdev->intx.interrupt); qemusetfdhandler(irqsetfd.fd, vfiointxinterrupt, NULL, vdev); if (ioctl(vdev->fd, VFIODEVICESETIRQS, &irqsetfd)) { errorreport(\"vfio: Error: Failed to setup INTx fd: %m\\n\"); return -errno; } /* * Disable mmaps so we can trap on BAR accesses. We interpret any * access as a response to an interrupt and unmask the physical * device. The device will re-assert if the interrupt is still * pending. We'll likely retrigger on the host multiple times per * guest interrupt, but without EOI notification it's better than * nothing. Acceleration paths through KVM will avoid this. */ vfiommapsetenabled(vdev, false); vdev->interrupt = VFIOINTINTx; DPRINTF(\"%s(%04x:%02x:%02x.%x)\\n\", func, vdev->host.domain, vdev->host.bus, vdev->host.slot, vdev->host.function); return 0; } ", "target": 0}
{"func": "void HELPER(mvc)(CPUS390XState *env, uint32t l, uint64t dest, uint64t src) { int i = 0; int x = 0; uint32t l64 = (l + 1) / 8; HELPERLOG(\"%s l %d dest %\" PRIx64 \" src %\" PRIx64 \"\\n\", func, l, dest, src); #ifndef CONFIGUSERONLY if ((l > 32) && (src & TARGETPAGEMASK) == ((src + l) & TARGETPAGEMASK) && (dest & TARGETPAGEMASK) == ((dest + l) & TARGETPAGEMASK)) { if (dest == (src + 1)) { mvcfastmemset(env, l + 1, dest, cpuldubdata(env, src)); return; } else if ((src & TARGETPAGEMASK) != (dest & TARGETPAGEMASK)) { mvcfastmemmove(env, l + 1, dest, src); return; } } #else if (dest == (src + 1)) { memset(g2h(dest), cpuldubdata(env, src), l + 1); return; /* mvc and memmove do not behave the same when areas overlap! */ } else if ((dest < src) || (src + l < dest)) { memmove(g2h(dest), g2h(src), l + 1); return; } #endif /* handle the parts that fit into 8-byte loads/stores */ if ((dest + 8 <= src) || (src + 8 <= dest)) { for (i = 0; i < l64; i++) { cpustqdata(env, dest + x, cpuldqdata(env, src + x)); x += 8; } } /* slow version with byte accesses which always work */ for (i = x; i <= l; i++) { cpustbdata(env, dest + i, cpuldubdata(env, src + i)); } } ", "target": 0}
{"func": "void helperstorefpcr (uint64t val) { #ifdef CONFIGSOFTFLOAT setfloatexceptionflags((val >> 52) & 0x3F, &FPSTATUS); #endif switch ((val >> 58) & 3) { case 0: setfloatroundingmode(floatroundtozero, &FPSTATUS); break; case 1: setfloatroundingmode(floatrounddown, &FPSTATUS); break; case 2: setfloatroundingmode(floatroundnearesteven, &FPSTATUS); break; case 3: setfloatroundingmode(floatroundup, &FPSTATUS); break; } } ", "target": 0}
{"func": "void spaprtcesetbypass(sPAPRTCETable *tcet, bool bypass) { tcet->bypass = bypass; } ", "target": 0}
{"func": "void qemusystemwakeuprequest(WakeupReason reason) { if (!issuspended) { return; } if (!(wakeupreasonmask & (1 << reason))) { return; } runstateset(RUNSTATERUNNING); monitorprotocolevent(QEVENTWAKEUP, NULL); notifierlistnotify(&wakeupnotifiers, &reason); resetrequested = 1; qemunotifyevent(); issuspended = false; } ", "target": 0}
{"func": "static int rtsplisten(AVFormatContext *s) { RTSPState *rt = s->privdata; char proto[128], host[128], path[512], auth[128]; char uri[500]; int port; int defaultport = RTSPDEFAULTPORT; char tcpname[500]; const char *lowerproto = \"tcp\"; unsigned char rbuf[4096]; unsigned char method[10]; int rbuflen = 0; int ret; enum RTSPMethod methodcode; if (!rt->protocols) { rt->protocols = ffurlgetprotocols(NULL, NULL); if (!rt->protocols) return AVERROR(ENOMEM); } /* extract hostname and port */ avurlsplit(proto, sizeof(proto), auth, sizeof(auth), host, sizeof(host), &port, path, sizeof(path), s->filename); /* ffurljoin. No authorization by now (NULL) */ ffurljoin(rt->controluri, sizeof(rt->controluri), proto, NULL, host, port, \"%s\", path); if (!strcmp(proto, \"rtsps\")) { lowerproto = \"tls\"; defaultport = RTSPSDEFAULTPORT; } if (port < 0) port = defaultport; /* Create TCP connection */ ffurljoin(tcpname, sizeof(tcpname), lowerproto, NULL, host, port, \"?listen&listentimeout=%d\", rt->initialtimeout * 1000); if (ret = ffurlopen(&rt->rtsphd, tcpname, AVIOFLAGREADWRITE, &s->interruptcallback, NULL, rt->protocols)) { avlog(s, AVLOGERROR, \"Unable to open RTSP for listening\\n\"); return ret; } rt->state = RTSPSTATEIDLE; rt->rtsphdout = rt->rtsphd; for (;;) { /* Wait for incoming RTSP messages */ ret = readline(s, rbuf, sizeof(rbuf), &rbuflen); if (ret < 0) return ret; ret = parsecommandline(s, rbuf, rbuflen, uri, sizeof(uri), method, sizeof(method), &methodcode); if (ret) { avlog(s, AVLOGERROR, \"RTSP: Unexpected Command\\n\"); return ret; } if (methodcode == ANNOUNCE) { ret = rtspreadannounce(s); rt->state = RTSPSTATEPAUSED; } else if (methodcode == OPTIONS) { ret = rtspreadoptions(s); } else if (methodcode == RECORD) { ret = rtspreadrecord(s); if (!ret) return 0; // We are ready for streaming } else if (methodcode == SETUP) ret = rtspreadsetup(s, host, uri); if (ret) { ffurlclose(rt->rtsphd); return AVERRORINVALIDDATA; } } return 0; } ", "target": 1}
{"func": "int ffwmarunleveldecode(AVCodecContext *avctx, GetBitContext *gb, VLC *vlc, const float *leveltable, const uint16t *runtable, int version, WMACoef *ptr, int offset, int numcoefs, int blocklen, int framelenbits, int coefnbbits) { int code, level, sign; const uint32t *ilvl = (const uint32t *) leveltable; uint32t *iptr = (uint32t *) ptr; const unsigned int coefmask = blocklen - 1; for (; offset < numcoefs; offset++) { code = getvlc2(gb, vlc->table, VLCBITS, VLCMAX); if (code > 1) { /** normal code */ offset += runtable[code]; sign = getbits1(gb) - 1; iptr[offset & coefmask] = ilvl[code] ^ sign << 31; } else if (code == 1) { /** EOB */ break; } else { /** escape */ if (!version) { level = getbits(gb, coefnbbits); /** NOTE: this is rather suboptimal. reading * blocklenbits would be better */ offset += getbits(gb, framelenbits); } else { level = ffwmagetlargeval(gb); /** escape decode */ if (getbits1(gb)) { if (getbits1(gb)) { if (getbits1(gb)) { avlog(avctx, AVLOGERROR, \"broken escape sequence\\n\"); return -1; } else offset += getbits(gb, framelenbits) + 4; } else offset += getbits(gb, 2) + 1; } } sign = getbits1(gb) - 1; ptr[offset & coefmask] = (level ^ sign) - sign; } } /** NOTE: EOB can be omitted */ if (offset > numcoefs) { avlog(avctx, AVLOGERROR, \"overflow in spectral RLE, ignoring\\n\"); return -1; } return 0; } ", "target": 1}
{"func": "int avfiltergraphparse(AVFilterGraph *graph, const char *filters, AVFilterInOut *openinputs, AVFilterInOut *openoutputs, AVClass *logctx) { int index = 0, ret; char chr = 0; AVFilterInOut *currinputs = NULL; do { AVFilterContext *filter; filters += strspn(filters, WHITESPACES); if ((ret = parseinputs(&filters, &currinputs, &openoutputs, logctx)) < 0) goto fail; if ((ret = parsefilter(&filter, &filters, graph, index, logctx)) < 0) goto fail; if (filter->inputcount == 1 && !currinputs && !index) { /* First input can be omitted if it is \"[in]\" */ const char *tmp = \"[in]\"; if ((ret = parseinputs(&tmp, &currinputs, &openoutputs, logctx)) < 0) goto fail; } if ((ret = linkfilterinouts(filter, &currinputs, &openinputs, logctx)) < 0) goto fail; if ((ret = parseoutputs(&filters, &currinputs, &openinputs, &openoutputs, logctx)) < 0) goto fail; filters += strspn(filters, WHITESPACES); chr = *filters++; if (chr == ';' && currinputs) { avlog(logctx, AVLOGERROR, \"Could not find a output to link when parsing \\\"%s\\\"\\n\", filters - 1); ret = AVERROR(EINVAL); goto fail; } index++; } while (chr == ',' || chr == ';'); if (chr) { avlog(logctx, AVLOGERROR, \"Unable to parse graph description substring: \\\"%s\\\"\\n\", filters - 1); ret = AVERROR(EINVAL); goto fail; } if (openinputs && !strcmp(openinputs->name, \"out\") && currinputs) { /* Last output can be omitted if it is \"[out]\" */ const char *tmp = \"[out]\"; if ((ret = parseoutputs(&tmp, &currinputs, &openinputs, &openoutputs, logctx)) < 0) goto fail; } return 0; fail: avfiltergraphfree(graph); freeinout(openinputs); freeinout(openoutputs); freeinout(currinputs); return ret; } ", "target": 0}
{"func": "static int virtionetdeviceexit(DeviceState *qdev) { VirtIONet *n = VIRTIONET(qdev); VirtIODevice *vdev = VIRTIODEVICE(qdev); int i; /* This will stop vhost backend if appropriate. */ virtionetsetstatus(vdev, 0); unregistersavevm(qdev, \"virtio-net\", n); if (n->netclientname) { gfree(n->netclientname); n->netclientname = NULL; } if (n->netclienttype) { gfree(n->netclienttype); n->netclienttype = NULL; } gfree(n->mactable.macs); gfree(n->vlans); for (i = 0; i < n->maxqueues; i++) { VirtIONetQueue *q = &n->vqs[i]; NetClientState *nc = qemugetsubqueue(n->nic, i); qemupurgequeuedpackets(nc); if (q->txtimer) { timerdel(q->txtimer); timerfree(q->txtimer); } else { qemubhdelete(q->txbh); } } gfree(n->vqs); qemudelnic(n->nic); virtiocleanup(vdev); return 0; } ", "target": 0}
{"func": "static inline void genneonwiden(TCGv dest, TCGv src, int size, int u) { if (u) { switch (size) { case 0: genhelperneonwidenu8(dest, src); break; case 1: genhelperneonwidenu16(dest, src); break; case 2: tcggenextui32i64(dest, src); break; default: abort(); } } else { switch (size) { case 0: genhelperneonwidens8(dest, src); break; case 1: genhelperneonwidens16(dest, src); break; case 2: tcggenexti32i64(dest, src); break; default: abort(); } } deadtmp(src); } ", "target": 0}
{"func": "static int sdcreatebranch(BDRVSheepdogState *s) { int ret, fd; uint32t vid; char *buf; dprintf(\"%\" PRIx32 \" is snapshot.\\n\", s->inode.vdiid); buf = gmalloc(SDINODESIZE); ret = dosdcreate(s->name, s->inode.vdisize, s->inode.vdiid, &vid, 1, s->addr, s->port); if (ret) { goto out; } dprintf(\"%\" PRIx32 \" is created.\\n\", vid); fd = connecttosdog(s->addr, s->port); if (fd < 0) { errorreport(\"failed to connect\"); ret = fd; goto out; } ret = readobject(fd, buf, vidtovdioid(vid), s->inode.nrcopies, SDINODESIZE, 0, s->cacheenabled); closesocket(fd); if (ret < 0) { goto out; } memcpy(&s->inode, buf, sizeof(s->inode)); s->issnapshot = false; ret = 0; dprintf(\"%\" PRIx32 \" was newly created.\\n\", s->inode.vdiid); out: gfree(buf); return ret; } ", "target": 0}
{"func": "static int parseuint8(DeviceState *dev, Property *prop, const char *str) { uint8t *ptr = qdevgetpropptr(dev, prop); const char *fmt; /* accept both hex and decimal */ fmt = strncasecmp(str, \"0x\",2) == 0 ? \"%\" PRIx8 : \"%\" PRIu8; if (sscanf(str, fmt, ptr) != 1) return -EINVAL; return 0; } ", "target": 1}
{"func": "avcold int swrirematrixinit(SwrContext *s){ int i, j; int nbin = avgetchannellayoutnbchannels(s->inchlayout); int nbout = avgetchannellayoutnbchannels(s->outchlayout); s->mixanyf = NULL; if (!s->rematrixcustom) { int r = automatrix(s); if (r) return r; } if (s->midbuf.fmt == AVSAMPLEFMTS16P){ s->nativematrix = avcalloc(nbin * nbout, sizeof(int)); s->nativeone = avmallocz(sizeof(int)); if (!s->nativematrix || !s->nativeone) return AVERROR(ENOMEM); for (i = 0; i < nbout; i++) { double rem = 0; for (j = 0; j < nbin; j++) { double target = s->matrix[i][j] * 32768 + rem; ((int*)s->nativematrix)[i * nbin + j] = lrintf(target); rem += target - ((int*)s->nativematrix)[i * nbin + j]; } } *((int*)s->nativeone) = 32768; s->mix11f = (mix11functype*)copys16; s->mix21f = (mix21functype*)sum2s16; s->mixanyf = (mixanyfunctype*)getmixanyfuncs16(s); }else if(s->midbuf.fmt == AVSAMPLEFMTFLTP){ s->nativematrix = avcalloc(nbin * nbout, sizeof(float)); s->nativeone = avmallocz(sizeof(float)); if (!s->nativematrix || !s->nativeone) return AVERROR(ENOMEM); for (i = 0; i < nbout; i++) for (j = 0; j < nbin; j++) ((float*)s->nativematrix)[i * nbin + j] = s->matrix[i][j]; *((float*)s->nativeone) = 1.0; s->mix11f = (mix11functype*)copyfloat; s->mix21f = (mix21functype*)sum2float; s->mixanyf = (mixanyfunctype*)getmixanyfuncfloat(s); }else if(s->midbuf.fmt == AVSAMPLEFMTDBLP){ s->nativematrix = avcalloc(nbin * nbout, sizeof(double)); s->nativeone = avmallocz(sizeof(double)); if (!s->nativematrix || !s->nativeone) return AVERROR(ENOMEM); for (i = 0; i < nbout; i++) for (j = 0; j < nbin; j++) ((double*)s->nativematrix)[i * nbin + j] = s->matrix[i][j]; *((double*)s->nativeone) = 1.0; s->mix11f = (mix11functype*)copydouble; s->mix21f = (mix21functype*)sum2double; s->mixanyf = (mixanyfunctype*)getmixanyfuncdouble(s); }else if(s->midbuf.fmt == AVSAMPLEFMTS32P){ // Only for dithering currently // s->nativematrix = avcalloc(nbin * nbout, sizeof(double)); s->nativeone = avmallocz(sizeof(int)); if (!s->nativeone) return AVERROR(ENOMEM); // for (i = 0; i < nbout; i++) // for (j = 0; j < nbin; j++) // ((double*)s->nativematrix)[i * nbin + j] = s->matrix[i][j]; *((int*)s->nativeone) = 32768; s->mix11f = (mix11functype*)copys32; s->mix21f = (mix21functype*)sum2s32; s->mixanyf = (mixanyfunctype*)getmixanyfuncs32(s); }else avassert0(0); //FIXME quantize for integeres for (i = 0; i < SWRCHMAX; i++) { int chin=0; for (j = 0; j < SWRCHMAX; j++) { s->matrix32[i][j]= lrintf(s->matrix[i][j] * 32768); if(s->matrix[i][j]) s->matrixch[i][++chin]= j; } s->matrixch[i][0]= chin; } if(HAVEYASM && HAVEMMX) return swrirematrixinitx86(s); return 0; } ", "target": 1}
{"func": "void s390machinereset(void) { S390CPU *iplcpu = S390CPU(qemugetcpu(0)); qemudevicesreset(); s390cmmareset(); s390cryptoreset(); /* all cpus are stopped - configure and start the ipl cpu only */ s390iplpreparecpu(iplcpu); s390cpusetstate(CPUSTATEOPERATING, iplcpu); } ", "target": 1}
{"func": "static int ficdecodeblock(FICContext *ctx, GetBitContext *gb, uint8t *dst, int stride, int16t *block) { int i, numcoeff; /* Is it a skip block? */ if (getbits1(gb)) { /* This is a P-frame. */ ctx->frame->keyframe = 0; ctx->frame->picttype = AVPICTURETYPEP; return 0; } memset(block, 0, sizeof(*block) * 64); numcoeff = getbits(gb, 7); if (numcoeff > 64) return AVERRORINVALIDDATA; for (i = 0; i < numcoeff; i++) block[ffzigzagdirect[i]] = getsegolomb(gb) * ctx->qmat[ffzigzagdirect[i]]; ficidctput(dst, stride, block); return 0; } ", "target": 1}
{"func": "void ffrtspundosetup(AVFormatContext *s, int sendpackets) { RTSPState *rt = s->privdata; int i; for (i = 0; i < rt->nbrtspstreams; i++) { RTSPStream *rtspst = rt->rtspstreams[i]; if (!rtspst) continue; if (rtspst->transportpriv) { if (s->oformat) { AVFormatContext *rtpctx = rtspst->transportpriv; avwritetrailer(rtpctx); if (rt->lowertransport == RTSPLOWERTRANSPORTTCP) { uint8t *ptr; if (CONFIGRTSPMUXER && rtpctx->pb && sendpackets) ffrtsptcpwritepacket(s, rtspst); avioclosedynbuf(rtpctx->pb, &ptr); avfree(ptr); } else { avioclose(rtpctx->pb); } avformatfreecontext(rtpctx); } else if (rt->transport == RTSPTRANSPORTRDT && CONFIGRTPDEC) ffrdtparseclose(rtspst->transportpriv); else if (rt->transport == RTSPTRANSPORTRTP && CONFIGRTPDEC) ffrtpparseclose(rtspst->transportpriv); } rtspst->transportpriv = NULL; if (rtspst->rtphandle) ffurlclose(rtspst->rtphandle); rtspst->rtphandle = NULL; } } ", "target": 1}
{"func": "static void dotokenin(USBDevice *s, USBPacket *p) { int request, value, index; assert(p->ep->nr == 0); request = (s->setupbuf[0] << 8) | s->setupbuf[1]; value = (s->setupbuf[3] << 8) | s->setupbuf[2]; index = (s->setupbuf[5] << 8) | s->setupbuf[4]; switch(s->setupstate) { case SETUPSTATEACK: if (!(s->setupbuf[0] & USBDIRIN)) { usbdevicehandlecontrol(s, p, request, value, index, s->setuplen, s->databuf); if (p->status == USBRETASYNC) { return; } s->setupstate = SETUPSTATEIDLE; p->actuallength = 0; } break; case SETUPSTATEDATA: if (s->setupbuf[0] & USBDIRIN) { int len = s->setuplen - s->setupindex; if (len > p->iov.size) { len = p->iov.size; } usbpacketcopy(p, s->databuf + s->setupindex, len); s->setupindex += len; if (s->setupindex >= s->setuplen) { s->setupstate = SETUPSTATEACK; } return; } s->setupstate = SETUPSTATEIDLE; p->status = USBRETSTALL; break; default: p->status = USBRETSTALL; } } ", "target": 0}
{"func": "static int getvideobuffer(AVFrame *frame, int align) { const AVPixFmtDescriptor *desc = avpixfmtdescget(frame->format); int ret, i; if (!desc) return AVERROR(EINVAL); if ((ret = avimagechecksize(frame->width, frame->height, 0, NULL)) < 0) return ret; if (!frame->linesize[0]) { ret = avimagefilllinesizes(frame->linesize, frame->format, frame->width); if (ret < 0) return ret; for (i = 0; i < 4 && frame->linesize[i]; i++) frame->linesize[i] = FFALIGN(frame->linesize[i], align); } for (i = 0; i < 4 && frame->linesize[i]; i++) { int h = FFALIGN(frame->height, 32); if (i == 1 || i == 2) h = -((-h) >> desc->log2chromah); frame->buf[i] = avbufferalloc(frame->linesize[i] * h); if (!frame->buf[i]) goto fail; frame->data[i] = frame->buf[i]->data; } if (desc->flags & PIXFMTPAL || desc->flags & PIXFMTPSEUDOPAL) { avbufferunref(&frame->buf[1]); frame->buf[1] = avbufferalloc(1024); if (!frame->buf[1]) goto fail; frame->data[1] = frame->buf[1]->data; } frame->extendeddata = frame->data; return 0; fail: avframeunref(frame); return AVERROR(ENOMEM); } ", "target": 0}
{"func": "static int kvmgetmsrs(X86CPU *cpu) { CPUX86State *env = &cpu->env; struct kvmmsrentry *msrs = cpu->kvmmsrbuf->entries; int ret, i; uint64t mtrrtopbits; kvmmsrbufreset(cpu); kvmmsrentryadd(cpu, MSRIA32SYSENTERCS, 0); kvmmsrentryadd(cpu, MSRIA32SYSENTERESP, 0); kvmmsrentryadd(cpu, MSRIA32SYSENTEREIP, 0); kvmmsrentryadd(cpu, MSRPAT, 0); if (hasmsrstar) { kvmmsrentryadd(cpu, MSRSTAR, 0); } if (hasmsrhsavepa) { kvmmsrentryadd(cpu, MSRVMHSAVEPA, 0); } if (hasmsrtscaux) { kvmmsrentryadd(cpu, MSRTSCAUX, 0); } if (hasmsrtscadjust) { kvmmsrentryadd(cpu, MSRTSCADJUST, 0); } if (hasmsrtscdeadline) { kvmmsrentryadd(cpu, MSRIA32TSCDEADLINE, 0); } if (hasmsrmiscenable) { kvmmsrentryadd(cpu, MSRIA32MISCENABLE, 0); } if (hasmsrsmbase) { kvmmsrentryadd(cpu, MSRIA32SMBASE, 0); } if (hasmsrfeaturecontrol) { kvmmsrentryadd(cpu, MSRIA32FEATURECONTROL, 0); } if (hasmsrbndcfgs) { kvmmsrentryadd(cpu, MSRIA32BNDCFGS, 0); } if (hasmsrxss) { kvmmsrentryadd(cpu, MSRIA32XSS, 0); } if (!env->tscvalid) { kvmmsrentryadd(cpu, MSRIA32TSC, 0); env->tscvalid = !runstateisrunning(); } #ifdef TARGETX8664 if (lmcapablekernel) { kvmmsrentryadd(cpu, MSRCSTAR, 0); kvmmsrentryadd(cpu, MSRKERNELGSBASE, 0); kvmmsrentryadd(cpu, MSRFMASK, 0); kvmmsrentryadd(cpu, MSRLSTAR, 0); } #endif kvmmsrentryadd(cpu, MSRKVMSYSTEMTIME, 0); kvmmsrentryadd(cpu, MSRKVMWALLCLOCK, 0); if (hasmsrasyncpfen) { kvmmsrentryadd(cpu, MSRKVMASYNCPFEN, 0); } if (hasmsrpveoien) { kvmmsrentryadd(cpu, MSRKVMPVEOIEN, 0); } if (hasmsrkvmstealtime) { kvmmsrentryadd(cpu, MSRKVMSTEALTIME, 0); } if (hasmsrarchitecturalpmu) { kvmmsrentryadd(cpu, MSRCOREPERFFIXEDCTRCTRL, 0); kvmmsrentryadd(cpu, MSRCOREPERFGLOBALCTRL, 0); kvmmsrentryadd(cpu, MSRCOREPERFGLOBALSTATUS, 0); kvmmsrentryadd(cpu, MSRCOREPERFGLOBALOVFCTRL, 0); for (i = 0; i < MAXFIXEDCOUNTERS; i++) { kvmmsrentryadd(cpu, MSRCOREPERFFIXEDCTR0 + i, 0); } for (i = 0; i < numarchitecturalpmucounters; i++) { kvmmsrentryadd(cpu, MSRP6PERFCTR0 + i, 0); kvmmsrentryadd(cpu, MSRP6EVNTSEL0 + i, 0); } } if (env->mcgcap) { kvmmsrentryadd(cpu, MSRMCGSTATUS, 0); kvmmsrentryadd(cpu, MSRMCGCTL, 0); if (hasmsrmcgextctl) { kvmmsrentryadd(cpu, MSRMCGEXTCTL, 0); } for (i = 0; i < (env->mcgcap & 0xff) * 4; i++) { kvmmsrentryadd(cpu, MSRMC0CTL + i, 0); } } if (hasmsrhvhypercall) { kvmmsrentryadd(cpu, HVX64MSRHYPERCALL, 0); kvmmsrentryadd(cpu, HVX64MSRGUESTOSID, 0); } if (hasmsrhvvapic) { kvmmsrentryadd(cpu, HVX64MSRAPICASSISTPAGE, 0); } if (hasmsrhvtsc) { kvmmsrentryadd(cpu, HVX64MSRREFERENCETSC, 0); } if (hasmsrhvcrash) { int j; for (j = 0; j < HVX64MSRCRASHPARAMS; j++) { kvmmsrentryadd(cpu, HVX64MSRCRASHP0 + j, 0); } } if (hasmsrhvruntime) { kvmmsrentryadd(cpu, HVX64MSRVPRUNTIME, 0); } if (cpu->hypervsynic) { uint32t msr; kvmmsrentryadd(cpu, HVX64MSRSCONTROL, 0); kvmmsrentryadd(cpu, HVX64MSRSVERSION, 0); kvmmsrentryadd(cpu, HVX64MSRSIEFP, 0); kvmmsrentryadd(cpu, HVX64MSRSIMP, 0); for (msr = HVX64MSRSINT0; msr <= HVX64MSRSINT15; msr++) { kvmmsrentryadd(cpu, msr, 0); } } if (hasmsrhvstimer) { uint32t msr; for (msr = HVX64MSRSTIMER0CONFIG; msr <= HVX64MSRSTIMER3COUNT; msr++) { kvmmsrentryadd(cpu, msr, 0); } } if (hasmsrmtrr) { kvmmsrentryadd(cpu, MSRMTRRdefType, 0); kvmmsrentryadd(cpu, MSRMTRRfix64K00000, 0); kvmmsrentryadd(cpu, MSRMTRRfix16K80000, 0); kvmmsrentryadd(cpu, MSRMTRRfix16KA0000, 0); kvmmsrentryadd(cpu, MSRMTRRfix4KC0000, 0); kvmmsrentryadd(cpu, MSRMTRRfix4KC8000, 0); kvmmsrentryadd(cpu, MSRMTRRfix4KD0000, 0); kvmmsrentryadd(cpu, MSRMTRRfix4KD8000, 0); kvmmsrentryadd(cpu, MSRMTRRfix4KE0000, 0); kvmmsrentryadd(cpu, MSRMTRRfix4KE8000, 0); kvmmsrentryadd(cpu, MSRMTRRfix4KF0000, 0); kvmmsrentryadd(cpu, MSRMTRRfix4KF8000, 0); for (i = 0; i < MSRMTRRcapVCNT; i++) { kvmmsrentryadd(cpu, MSRMTRRphysBase(i), 0); kvmmsrentryadd(cpu, MSRMTRRphysMask(i), 0); } } ret = kvmvcpuioctl(CPU(cpu), KVMGETMSRS, cpu->kvmmsrbuf); if (ret < 0) { return ret; } assert(ret == cpu->kvmmsrbuf->nmsrs); /* * MTRR masks: Each mask consists of 5 parts * a 10..0: must be zero * b 11 : valid bit * c n-1.12: actual mask bits * d 51..n: reserved must be zero * e 63.52: reserved must be zero * * 'n' is the number of physical bits supported by the CPU and is * apparently always <= 52. We know our 'n' but don't know what * the destinations 'n' is; it might be smaller, in which case * it masks (c) on loading. It might be larger, in which case * we fill 'd' so that d..c is consistent irrespetive of the 'n' * we're migrating to. */ if (cpu->fillmtrrmask) { QEMUBUILDBUGON(TARGETPHYSADDRSPACEBITS > 52); assert(cpu->physbits <= TARGETPHYSADDRSPACEBITS); mtrrtopbits = MAKE64BITMASK(cpu->physbits, 52 - cpu->physbits); } else { mtrrtopbits = 0; } for (i = 0; i < ret; i++) { uint32t index = msrs[i].index; switch (index) { case MSRIA32SYSENTERCS: env->sysentercs = msrs[i].data; break; case MSRIA32SYSENTERESP: env->sysenteresp = msrs[i].data; break; case MSRIA32SYSENTEREIP: env->sysentereip = msrs[i].data; break; case MSRPAT: env->pat = msrs[i].data; break; case MSRSTAR: env->star = msrs[i].data; break; #ifdef TARGETX8664 case MSRCSTAR: env->cstar = msrs[i].data; break; case MSRKERNELGSBASE: env->kernelgsbase = msrs[i].data; break; case MSRFMASK: env->fmask = msrs[i].data; break; case MSRLSTAR: env->lstar = msrs[i].data; break; #endif case MSRIA32TSC: env->tsc = msrs[i].data; break; case MSRTSCAUX: env->tscaux = msrs[i].data; break; case MSRTSCADJUST: env->tscadjust = msrs[i].data; break; case MSRIA32TSCDEADLINE: env->tscdeadline = msrs[i].data; break; case MSRVMHSAVEPA: env->vmhsave = msrs[i].data; break; case MSRKVMSYSTEMTIME: env->systemtimemsr = msrs[i].data; break; case MSRKVMWALLCLOCK: env->wallclockmsr = msrs[i].data; break; case MSRMCGSTATUS: env->mcgstatus = msrs[i].data; break; case MSRMCGCTL: env->mcgctl = msrs[i].data; break; case MSRMCGEXTCTL: env->mcgextctl = msrs[i].data; break; case MSRIA32MISCENABLE: env->msria32miscenable = msrs[i].data; break; case MSRIA32SMBASE: env->smbase = msrs[i].data; break; case MSRIA32FEATURECONTROL: env->msria32featurecontrol = msrs[i].data; break; case MSRIA32BNDCFGS: env->msrbndcfgs = msrs[i].data; break; case MSRIA32XSS: env->xss = msrs[i].data; break; default: if (msrs[i].index >= MSRMC0CTL && msrs[i].index < MSRMC0CTL + (env->mcgcap & 0xff) * 4) { env->mcebanks[msrs[i].index - MSRMC0CTL] = msrs[i].data; } break; case MSRKVMASYNCPFEN: env->asyncpfenmsr = msrs[i].data; break; case MSRKVMPVEOIEN: env->pveoienmsr = msrs[i].data; break; case MSRKVMSTEALTIME: env->stealtimemsr = msrs[i].data; break; case MSRCOREPERFFIXEDCTRCTRL: env->msrfixedctrctrl = msrs[i].data; break; case MSRCOREPERFGLOBALCTRL: env->msrglobalctrl = msrs[i].data; break; case MSRCOREPERFGLOBALSTATUS: env->msrglobalstatus = msrs[i].data; break; case MSRCOREPERFGLOBALOVFCTRL: env->msrglobalovfctrl = msrs[i].data; break; case MSRCOREPERFFIXEDCTR0 ... MSRCOREPERFFIXEDCTR0 + MAXFIXEDCOUNTERS - 1: env->msrfixedcounters[index - MSRCOREPERFFIXEDCTR0] = msrs[i].data; break; case MSRP6PERFCTR0 ... MSRP6PERFCTR0 + MAXGPCOUNTERS - 1: env->msrgpcounters[index - MSRP6PERFCTR0] = msrs[i].data; break; case MSRP6EVNTSEL0 ... MSRP6EVNTSEL0 + MAXGPCOUNTERS - 1: env->msrgpevtsel[index - MSRP6EVNTSEL0] = msrs[i].data; break; case HVX64MSRHYPERCALL: env->msrhvhypercall = msrs[i].data; break; case HVX64MSRGUESTOSID: env->msrhvguestosid = msrs[i].data; break; case HVX64MSRAPICASSISTPAGE: env->msrhvvapic = msrs[i].data; break; case HVX64MSRREFERENCETSC: env->msrhvtsc = msrs[i].data; break; case HVX64MSRCRASHP0 ... HVX64MSRCRASHP4: env->msrhvcrashparams[index - HVX64MSRCRASHP0] = msrs[i].data; break; case HVX64MSRVPRUNTIME: env->msrhvruntime = msrs[i].data; break; case HVX64MSRSCONTROL: env->msrhvsyniccontrol = msrs[i].data; break; case HVX64MSRSVERSION: env->msrhvsynicversion = msrs[i].data; break; case HVX64MSRSIEFP: env->msrhvsynicevtpage = msrs[i].data; break; case HVX64MSRSIMP: env->msrhvsynicmsgpage = msrs[i].data; break; case HVX64MSRSINT0 ... HVX64MSRSINT15: env->msrhvsynicsint[index - HVX64MSRSINT0] = msrs[i].data; break; case HVX64MSRSTIMER0CONFIG: case HVX64MSRSTIMER1CONFIG: case HVX64MSRSTIMER2CONFIG: case HVX64MSRSTIMER3CONFIG: env->msrhvstimerconfig[(index - HVX64MSRSTIMER0CONFIG)/2] = msrs[i].data; break; case HVX64MSRSTIMER0COUNT: case HVX64MSRSTIMER1COUNT: case HVX64MSRSTIMER2COUNT: case HVX64MSRSTIMER3COUNT: env->msrhvstimercount[(index - HVX64MSRSTIMER0COUNT)/2] = msrs[i].data; break; case MSRMTRRdefType: env->mtrrdeftype = msrs[i].data; break; case MSRMTRRfix64K00000: env->mtrrfixed[0] = msrs[i].data; break; case MSRMTRRfix16K80000: env->mtrrfixed[1] = msrs[i].data; break; case MSRMTRRfix16KA0000: env->mtrrfixed[2] = msrs[i].data; break; case MSRMTRRfix4KC0000: env->mtrrfixed[3] = msrs[i].data; break; case MSRMTRRfix4KC8000: env->mtrrfixed[4] = msrs[i].data; break; case MSRMTRRfix4KD0000: env->mtrrfixed[5] = msrs[i].data; break; case MSRMTRRfix4KD8000: env->mtrrfixed[6] = msrs[i].data; break; case MSRMTRRfix4KE0000: env->mtrrfixed[7] = msrs[i].data; break; case MSRMTRRfix4KE8000: env->mtrrfixed[8] = msrs[i].data; break; case MSRMTRRfix4KF0000: env->mtrrfixed[9] = msrs[i].data; break; case MSRMTRRfix4KF8000: env->mtrrfixed[10] = msrs[i].data; break; case MSRMTRRphysBase(0) ... MSRMTRRphysMask(MSRMTRRcapVCNT - 1): if (index & 1) { env->mtrrvar[MSRMTRRphysIndex(index)].mask = msrs[i].data | mtrrtopbits; } else { env->mtrrvar[MSRMTRRphysIndex(index)].base = msrs[i].data; } break; } } return 0; } ", "target": 0}
{"func": "hostmemorybackendcanbedeleted(UserCreatable *uc, Error **errp) { MemoryRegion *mr; mr = hostmemorybackendgetmemory(MEMORYBACKEND(uc), errp); if (memoryregionismapped(mr)) { return false; } else { return true; } } ", "target": 0}
{"func": "avcold int ffv1initslicecontexts(FFV1Context *f) { int i; f->slicecount = f->numhslices * f->numvslices; if (f->slicecount <= 0) { avlog(f->avctx, AVLOGERROR, \"Invalid number of slices\\n\"); return AVERROR(EINVAL); } for (i = 0; i < f->slicecount; i++) { FFV1Context *fs = avmallocz(sizeof(*fs)); int sx = i % f->numhslices; int sy = i / f->numhslices; int sxs = f->avctx->width * sx / f->numhslices; int sxe = f->avctx->width * (sx + 1) / f->numhslices; int sys = f->avctx->height * sy / f->numvslices; int sye = f->avctx->height * (sy + 1) / f->numvslices; f->slicecontext[i] = fs; memcpy(fs, f, sizeof(*fs)); memset(fs->rcstat2, 0, sizeof(fs->rcstat2)); fs->slicewidth = sxe - sxs; fs->sliceheight = sye - sys; fs->slicex = sxs; fs->slicey = sys; fs->samplebuffer = avmalloc(3 * MAXPLANES * (fs->width + 6) * sizeof(*fs->samplebuffer)); if (!fs->samplebuffer) return AVERROR(ENOMEM); } return 0; } ", "target": 0}
{"func": "static void omappwtwrite(void *opaque, targetphysaddrt addr, uint64t value, unsigned size) { struct omappwts *s = (struct omappwts *) opaque; int offset = addr & OMAPMPUIREGMASK; if (size != 1) { return omapbadwidthwrite8(opaque, addr, value); } switch (offset) { case 0x00:\t/* FRC */ s->frc = value & 0x3f; break; case 0x04:\t/* VRC */ if ((value ^ s->vrc) & 1) { if (value & 1) printf(\"%s: %iHz buzz on\\n\", FUNCTION, (int) /* 1.5 MHz from a 12-MHz or 13-MHz PWTCLK */ ((omapclkgetrate(s->clk) >> 3) / /* Pre-multiplexer divider */ ((s->gcr & 2) ? 1 : 154) / /* Octave multiplexer */ (2 << (value & 3)) * /* 101/107 divider */ ((value & (1 << 2)) ? 101 : 107) * /* 49/55 divider */ ((value & (1 << 3)) ? 49 : 55) * /* 50/63 divider */ ((value & (1 << 4)) ? 50 : 63) * /* 80/127 divider */ ((value & (1 << 5)) ? 80 : 127) / (107 * 55 * 63 * 127))); else printf(\"%s: silence!\\n\", FUNCTION); } s->vrc = value & 0x7f; break; case 0x08:\t/* GCR */ s->gcr = value & 3; break; default: OMAPBADREG(addr); return; } } ", "target": 0}
{"func": "static void predictordecodemono(APEContext *ctx, int count) { APEPredictor *p = &ctx->predictor; int32t *decoded0 = ctx->decoded[0]; int32t predictionA, currentA, A, sign; currentA = p->lastA[0]; while (count--) { A = *decoded0; p->buf[YDELAYA] = currentA; p->buf[YDELAYA - 1] = p->buf[YDELAYA] - p->buf[YDELAYA - 1]; predictionA = p->buf[YDELAYA ] * p->coeffsA[0][0] + p->buf[YDELAYA - 1] * p->coeffsA[0][1] + p->buf[YDELAYA - 2] * p->coeffsA[0][2] + p->buf[YDELAYA - 3] * p->coeffsA[0][3]; currentA = A + (predictionA >> 10); p->buf[YADAPTCOEFFSA] = APESIGN(p->buf[YDELAYA ]); p->buf[YADAPTCOEFFSA - 1] = APESIGN(p->buf[YDELAYA - 1]); sign = APESIGN(A); p->coeffsA[0][0] += p->buf[YADAPTCOEFFSA ] * sign; p->coeffsA[0][1] += p->buf[YADAPTCOEFFSA - 1] * sign; p->coeffsA[0][2] += p->buf[YADAPTCOEFFSA - 2] * sign; p->coeffsA[0][3] += p->buf[YADAPTCOEFFSA - 3] * sign; p->buf++; /* Have we filled the history buffer? */ if (p->buf == p->historybuffer + HISTORYSIZE) { memmove(p->historybuffer, p->buf, PREDICTORSIZE * sizeof(*p->historybuffer)); p->buf = p->historybuffer; } p->filterA[0] = currentA + ((p->filterA[0] * 31) >> 5); *(decoded0++) = p->filterA[0]; } p->lastA[0] = currentA; } ", "target": 0}
{"func": "static void printreport(AVFormatContext **outputfiles, AVOutputStream **osttable, int nbostreams, int islastreport) { char buf[1024]; AVOutputStream *ost; AVFormatContext *oc; int64t totalsize; AVCodecContext *enc; int framenumber, vid, i; double bitrate, ti1, pts; static int64t lasttime = -1; static int qphistogram[52]; if (!islastreport) { int64t curtime; /* display the report every 0.5 seconds */ curtime = avgettime(); if (lasttime == -1) { lasttime = curtime; return; } if ((curtime - lasttime) < 500000) return; lasttime = curtime; } oc = outputfiles[0]; totalsize = aviosize(oc->pb); if(totalsize<0) // FIXME improve aviosize() so it works with non seekable output too totalsize= aviotell(oc->pb); buf[0] = '\\0'; ti1 = 1e10; vid = 0; for(i=0;i<nbostreams;i++) { float q= -1; ost = osttable[i]; enc = ost->st->codec; if(!ost->st->streamcopy && enc->codedframe) q= enc->codedframe->quality/(float)FFQP2LAMBDA; if (vid && enc->codectype == AVMEDIATYPEVIDEO) { snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"q=%2.1f \", q); } if (!vid && enc->codectype == AVMEDIATYPEVIDEO) { float t = (avgettime()-timerstart) / 1000000.0; framenumber = ost->framenumber; snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"frame=%5d fps=%3d q=%3.1f \", framenumber, (t>1)?(int)(framenumber/t+0.5) : 0, q); if(islastreport) snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"L\"); if(qphist){ int j; int qp= lrintf(q); if(qp>=0 && qp<FFARRAYELEMS(qphistogram)) qphistogram[qp]++; for(j=0; j<32; j++) snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"%X\", (int)lrintf(log(qphistogram[j]+1)/log(2))); } if (enc->flags&CODECFLAGPSNR){ int j; double error, errorsum=0; double scale, scalesum=0; char type[3]= {'Y','U','V'}; snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"PSNR=\"); for(j=0; j<3; j++){ if(islastreport){ error= enc->error[j]; scale= enc->width*enc->height*255.0*255.0*framenumber; }else{ error= enc->codedframe->error[j]; scale= enc->width*enc->height*255.0*255.0; } if(j) scale/=4; errorsum += error; scalesum += scale; snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"%c:%2.2f \", type[j], psnr(error/scale)); } snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"*:%2.2f \", psnr(errorsum/scalesum)); } vid = 1; } /* compute min output value */ pts = (double)ost->st->pts.val * avq2d(ost->st->timebase); if ((pts < ti1) && (pts > 0)) ti1 = pts; } if (ti1 < 0.01) ti1 = 0.01; if (verbose || islastreport) { bitrate = (double)(totalsize * 8) / ti1 / 1000.0; snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \"size=%8.0fkB time=%0.2f bitrate=%6.1fkbits/s\", (double)totalsize / 1024, ti1, bitrate); if (nbframesdup || nbframesdrop) snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), \" dup=%d drop=%d\", nbframesdup, nbframesdrop); if (verbose >= 0) fprintf(stderr, \"%s \\r\", buf); fflush(stderr); } if (islastreport && verbose >= 0){ int64t raw= audiosize + videosize + extrasize; fprintf(stderr, \"\\n\"); fprintf(stderr, \"video:%1.0fkB audio:%1.0fkB global headers:%1.0fkB muxing overhead %f%%\\n\", videosize/1024.0, audiosize/1024.0, extrasize/1024.0, 100.0*(totalsize - raw)/raw ); } } ", "target": 0}
{"func": "static avalwaysinline void rv40strongloopfilter(uint8t *src, const int step, const int stride, const int alpha, const int lims, const int dmode, const int chroma) { int i; for(i = 0; i < 4; i++, src += stride){ int sflag, p0, q0, p1, q1; int t = src[0*step] - src[-1*step]; if (!t) continue; sflag = (alpha * FFABS(t)) >> 7; if (sflag > 1) continue; p0 = (25*src[-3*step] + 26*src[-2*step] + 26*src[-1*step] + 26*src[ 0*step] + 25*src[ 1*step] + rv40ditherl[dmode + i]) >> 7; q0 = (25*src[-2*step] + 26*src[-1*step] + 26*src[ 0*step] + 26*src[ 1*step] + 25*src[ 2*step] + rv40ditherr[dmode + i]) >> 7; if (sflag) { p0 = avclip(p0, src[-1*step] - lims, src[-1*step] + lims); q0 = avclip(q0, src[ 0*step] - lims, src[ 0*step] + lims); } p1 = (25*src[-4*step] + 26*src[-3*step] + 26*src[-2*step] + 26*p0 + 25*src[ 0*step] + rv40ditherl[dmode + i]) >> 7; q1 = (25*src[-1*step] + 26*q0 + 26*src[ 1*step] + 26*src[ 2*step] + 25*src[ 3*step] + rv40ditherr[dmode + i]) >> 7; if (sflag) { p1 = avclip(p1, src[-2*step] - lims, src[-2*step] + lims); q1 = avclip(q1, src[ 1*step] - lims, src[ 1*step] + lims); } src[-2*step] = p1; src[-1*step] = p0; src[ 0*step] = q0; src[ 1*step] = q1; if(!chroma){ src[-3*step] = (25*src[-1*step] + 26*src[-2*step] + 51*src[-3*step] + 26*src[-4*step] + 64) >> 7; src[ 2*step] = (25*src[ 0*step] + 26*src[ 1*step] + 51*src[ 2*step] + 26*src[ 3*step] + 64) >> 7; } } } ", "target": 1}
{"func": "DeviceState *qdevdeviceadd(QemuOpts *opts, Error **errp) { DeviceClass *dc; const char *driver, *path; DeviceState *dev; BusState *bus = NULL; Error *err = NULL; driver = qemuoptget(opts, \"driver\"); if (!driver) { errorsetg(errp, QERRMISSINGPARAMETER, \"driver\"); return NULL; } /* find driver */ dc = qdevgetdeviceclass(&driver, errp); if (!dc) { return NULL; } /* find bus */ path = qemuoptget(opts, \"bus\"); if (path != NULL) { bus = qbusfind(path, errp); if (!bus) { return NULL; } if (!objectdynamiccast(OBJECT(bus), dc->bustype)) { errorsetg(errp, \"Device '%s' can't go on %s bus\", driver, objectgettypename(OBJECT(bus))); return NULL; } } else if (dc->bustype != NULL) { bus = qbusfindrecursive(sysbusgetdefault(), NULL, dc->bustype); if (!bus || qbusisfull(bus)) { errorsetg(errp, \"No '%s' bus found for device '%s'\", dc->bustype, driver); return NULL; } } if (qdevhotplug && bus && !qbusishotpluggable(bus)) { errorsetg(errp, QERRBUSNOHOTPLUG, bus->name); return NULL; } if (!migrationisidle()) { errorsetg(errp, \"deviceadd not allowed while migrating\"); return NULL; } /* create device */ dev = DEVICE(objectnew(driver)); if (bus) { qdevsetparentbus(dev, bus); } qdevsetid(dev, qemuoptsid(opts)); /* set properties */ if (qemuoptforeach(opts, setproperty, dev, &err)) { } dev->opts = opts; objectpropertysetbool(OBJECT(dev), true, \"realized\", &err); if (err != NULL) { dev->opts = NULL; } return dev; errdeldev: errorpropagate(errp, err); objectunparent(OBJECT(dev)); objectunref(OBJECT(dev)); return NULL; }", "target": 1}
{"func": "static int rv10decodepacket(AVCodecContext *avctx, const uint8t *buf, int bufsize, int bufsize2) { RVDecContext *rv = avctx->privdata; MpegEncContext *s = &rv->m; int mbcount, mbpos, left, startmbx, activebitssize, ret; activebitssize = bufsize * 8; initgetbits(&s->gb, buf, FFMAX(bufsize, bufsize2) * 8); if (s->codecid == AVCODECIDRV10) mbcount = rv10decodepictureheader(s); else mbcount = rv20decodepictureheader(rv); if (mbcount < 0) { avlog(s->avctx, AVLOGERROR, \"HEADER ERROR\\n\"); return AVERRORINVALIDDATA; } if (s->mbx >= s->mbwidth || s->mby >= s->mbheight) { avlog(s->avctx, AVLOGERROR, \"POS ERROR %d %d\\n\", s->mbx, s->mby); return AVERRORINVALIDDATA; } mbpos = s->mby * s->mbwidth + s->mbx; left = s->mbwidth * s->mbheight - mbpos; if (mbcount > left) { avlog(s->avctx, AVLOGERROR, \"COUNT ERROR\\n\"); return AVERRORINVALIDDATA; } if ((s->mbx == 0 && s->mby == 0) || s->currentpictureptr == NULL) { // FIXME write parser so we always have complete frames? if (s->currentpictureptr) { fferframeend(&s->er); ffMPVframeend(s); s->mbx = s->mby = s->resyncmbx = s->resyncmby = 0; } if ((ret = ffMPVframestart(s, avctx)) < 0) return ret; ffmpegerframestart(s); } else { if (s->currentpictureptr->f.picttype != s->picttype) { avlog(s->avctx, AVLOGERROR, \"Slice type mismatch\\n\"); return AVERRORINVALIDDATA; } } avdlog(avctx, \"qscale=%d\\n\", s->qscale); /* default quantization values */ if (s->codecid == AVCODECIDRV10) { if (s->mby == 0) s->firstsliceline = 1; } else { s->firstsliceline = 1; s->resyncmbx = s->mbx; } startmbx = s->mbx; s->resyncmby = s->mby; if (s->h263aic) { s->ydcscaletable = s->cdcscaletable = ffaicdcscaletable; } else { s->ydcscaletable = s->cdcscaletable = ffmpeg1dcscaletable; } if (s->modifiedquant) s->chromaqscaletable = ffh263chromaqscaletable; ffsetqscale(s, s->qscale); s->rv10firstdccoded[0] = 0; s->rv10firstdccoded[1] = 0; s->rv10firstdccoded[2] = 0; s->blockwrap[0] = s->blockwrap[1] = s->blockwrap[2] = s->blockwrap[3] = s->b8stride; s->blockwrap[4] = s->blockwrap[5] = s->mbstride; ffinitblockindex(s); /* decode each macroblock */ for (s->mbnumleft = mbcount; s->mbnumleft > 0; s->mbnumleft--) { int ret; ffupdateblockindex(s); avdlog(avctx, \"**mb x=%d y=%d\\n\", s->mbx, s->mby); s->mvdir = MVDIRFORWARD; s->mvtype = MVTYPE16X16; ret = ffh263decodemb(s, s->block); // Repeat the slice end check from ffh263decodemb with our active // bitstream size if (ret != SLICEERROR) { int v = showbits(&s->gb, 16); if (getbitscount(&s->gb) + 16 > activebitssize) v >>= getbitscount(&s->gb) + 16 - activebitssize; if (!v) ret = SLICEEND; } if (ret != SLICEERROR && activebitssize < getbitscount(&s->gb) && 8 * bufsize2 >= getbitscount(&s->gb)) { activebitssize = bufsize2 * 8; avlog(avctx, AVLOGDEBUG, \"update size from %d to %d\\n\", 8 * bufsize, activebitssize); ret = SLICEOK; } if (ret == SLICEERROR || activebitssize < getbitscount(&s->gb)) { avlog(s->avctx, AVLOGERROR, \"ERROR at MB %d %d\\n\", s->mbx, s->mby); return AVERRORINVALIDDATA; } if (s->picttype != AVPICTURETYPEB) ffh263updatemotionval(s); ffMPVdecodemb(s, s->block); if (s->loopfilter) ffh263loopfilter(s); if (++s->mbx == s->mbwidth) { s->mbx = 0; s->mby++; ffinitblockindex(s); } if (s->mbx == s->resyncmbx) s->firstsliceline = 0; if (ret == SLICEEND) break; } fferaddslice(&s->er, startmbx, s->resyncmby, s->mbx - 1, s->mby, ERMBEND); return activebitssize; } ", "target": 1}
{"func": "static inline int cpugdbindex(CPUState *cpu) { #if defined(CONFIGUSERONLY) return cpu->hosttid; #else return cpu->cpuindex + 1; #endif } ", "target": 1}
{"func": "static inline int *DECUQUAD(int *dst, unsigned idx, unsigned sign) { unsigned nz = idx >> 12; dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1)); sign <<= nz & 1; nz >>= 1; dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1)); sign <<= nz & 1; nz >>= 1; dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1)); sign <<= nz & 1; nz >>= 1; dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1)); return dst + 4; } ", "target": 1}
{"func": "void hmpinfoblockjobs(Monitor *mon, const QDict *qdict) { BlockJobInfoList *list; Error *err = NULL; list = qmpqueryblockjobs(&err); assert(!err); if (!list) { monitorprintf(mon, \"No active jobs\\n\"); return; } while (list) { if (strcmp(list->value->type, \"stream\") == 0) { monitorprintf(mon, \"Streaming device %s: Completed %\" PRId64 \" of %\" PRId64 \" bytes, speed limit %\" PRId64 \" bytes/s\\n\", list->value->device, list->value->offset, list->value->len, list->value->speed); } else { monitorprintf(mon, \"Type %s, device %s: Completed %\" PRId64 \" of %\" PRId64 \" bytes, speed limit %\" PRId64 \" bytes/s\\n\", list->value->type, list->value->device, list->value->offset, list->value->len, list->value->speed); } list = list->next; } }", "target": 1}
{"func": "static int atrimfilterframe(AVFilterLink *inlink, AVFrame *frame) { AVFilterContext *ctx = inlink->dst; TrimContext *s = ctx->priv; int64t startsample, endsample = frame->nbsamples; int64t pts; int drop; /* drop everything if EOF has already been returned */ if (s->eof) { avframefree(&frame); return 0; } if (frame->pts != AVNOPTSVALUE) pts = avrescaleq(frame->pts, inlink->timebase, (AVRational){ 1, inlink->samplerate }); else pts = s->nextpts; s->nextpts = pts + frame->nbsamples; /* check if at least a part of the frame is after the start time */ if (s->startsample < 0 && s->startpts == AVNOPTSVALUE) { startsample = 0; } else { drop = 1; startsample = frame->nbsamples; if (s->startsample >= 0 && s->nbsamples + frame->nbsamples > s->startsample) { drop = 0; startsample = FFMIN(startsample, s->startsample - s->nbsamples); } if (s->startpts != AVNOPTSVALUE && pts != AVNOPTSVALUE && pts + frame->nbsamples > s->startpts) { drop = 0; startsample = FFMIN(startsample, s->startpts - pts); } if (drop) goto drop; } if (s->firstpts == AVNOPTSVALUE) s->firstpts = pts + startsample; /* check if at least a part of the frame is before the end time */ if (s->endsample == INT64MAX && s->endpts == AVNOPTSVALUE && !s->durationtb) { endsample = frame->nbsamples; } else { drop = 1; endsample = 0; if (s->endsample != INT64MAX && s->nbsamples < s->endsample) { drop = 0; endsample = FFMAX(endsample, s->endsample - s->nbsamples); } if (s->endpts != AVNOPTSVALUE && pts != AVNOPTSVALUE && pts < s->endpts) { drop = 0; endsample = FFMAX(endsample, s->endpts - pts); } if (s->durationtb && pts - s->firstpts < s->durationtb) { drop = 0; endsample = FFMAX(endsample, s->firstpts + s->durationtb - pts); } if (drop) { s->eof = 1; goto drop; } } s->nbsamples += frame->nbsamples; startsample = FFMAX(0, startsample); endsample = FFMIN(frame->nbsamples, endsample); avassert0(startsample < endsample); if (startsample) { AVFrame *out = ffgetaudiobuffer(ctx->outputs[0], endsample - startsample); if (!out) { avframefree(&frame); return AVERROR(ENOMEM); } avframecopyprops(out, frame); avsamplescopy(out->extendeddata, frame->extendeddata, 0, startsample, out->nbsamples, avgetchannellayoutnbchannels(frame->channellayout), frame->format); if (out->pts != AVNOPTSVALUE) out->pts += avrescaleq(startsample, (AVRational){ 1, out->samplerate }, inlink->timebase); avframefree(&frame); frame = out; } else frame->nbsamples = endsample; s->gotoutput = 1; return fffilterframe(ctx->outputs[0], frame); drop: s->nbsamples += frame->nbsamples; avframefree(&frame); return 0; } ", "target": 0}
{"func": "static void tcgregalloccall(TCGContext *s, int nboargs, int nbiargs, const TCGArg * const args, uint16t deadargs, uint8t syncargs) { int flags, nbregs, i; TCGReg reg; TCGArg arg; TCGTemp *ts; intptrt stackoffset; sizet callstacksize; tcginsnunit *funcaddr; int allocateargs; TCGRegSet allocatedregs; funcaddr = (tcginsnunit *)(intptrt)args[nboargs + nbiargs]; flags = args[nboargs + nbiargs + 1]; nbregs = ARRAYSIZE(tcgtargetcalliargregs); if (nbregs > nbiargs) { nbregs = nbiargs; } /* assign stack slots first */ callstacksize = (nbiargs - nbregs) * sizeof(tcgtargetlong); callstacksize = (callstacksize + TCGTARGETSTACKALIGN - 1) & ~(TCGTARGETSTACKALIGN - 1); allocateargs = (callstacksize > TCGSTATICCALLARGSSIZE); if (allocateargs) { /* XXX: if more than TCGSTATICCALLARGSSIZE is needed, preallocate call stack */ tcgabort(); } stackoffset = TCGTARGETCALLSTACKOFFSET; for(i = nbregs; i < nbiargs; i++) { arg = args[nboargs + i]; #ifdef TCGTARGETSTACKGROWSUP stackoffset -= sizeof(tcgtargetlong); #endif if (arg != TCGCALLDUMMYARG) { ts = &s->temps[arg]; tempload(s, ts, tcgtargetavailableregs[ts->type], s->reservedregs); tcgoutst(s, ts->type, ts->reg, TCGREGCALLSTACK, stackoffset); } #ifndef TCGTARGETSTACKGROWSUP stackoffset += sizeof(tcgtargetlong); #endif } /* assign input registers */ tcgregsetset(allocatedregs, s->reservedregs); for(i = 0; i < nbregs; i++) { arg = args[nboargs + i]; if (arg != TCGCALLDUMMYARG) { ts = &s->temps[arg]; reg = tcgtargetcalliargregs[i]; tcgregfree(s, reg, allocatedregs); if (ts->valtype == TEMPVALREG) { if (ts->reg != reg) { tcgoutmov(s, ts->type, reg, ts->reg); } } else { TCGRegSet argset; tcgregsetclear(argset); tcgregsetsetreg(argset, reg); tempload(s, ts, argset, allocatedregs); } tcgregsetsetreg(allocatedregs, reg); } } /* mark dead temporaries and free the associated registers */ for(i = nboargs; i < nbiargs + nboargs; i++) { if (ISDEADARG(i)) { tempdead(s, &s->temps[args[i]]); } } /* clobber call registers */ for (i = 0; i < TCGTARGETNBREGS; i++) { if (tcgregsettestreg(tcgtargetcallclobberregs, i)) { tcgregfree(s, i, allocatedregs); } } /* Save globals if they might be written by the helper, sync them if they might be read. */ if (flags & TCGCALLNOREADGLOBALS) { /* Nothing to do */ } else if (flags & TCGCALLNOWRITEGLOBALS) { syncglobals(s, allocatedregs); } else { saveglobals(s, allocatedregs); } tcgoutcall(s, funcaddr); /* assign output registers and emit moves if needed */ for(i = 0; i < nboargs; i++) { arg = args[i]; ts = &s->temps[arg]; reg = tcgtargetcalloargregs[i]; assert(s->regtotemp[reg] == NULL); if (ts->fixedreg) { if (ts->reg != reg) { tcgoutmov(s, ts->type, ts->reg, reg); } } else { if (ts->valtype == TEMPVALREG) { s->regtotemp[ts->reg] = NULL; } ts->valtype = TEMPVALREG; ts->reg = reg; ts->memcoherent = 0; s->regtotemp[reg] = ts; if (NEEDSYNCARG(i)) { tcgregsync(s, reg, allocatedregs); } if (ISDEADARG(i)) { tempdead(s, ts); } } } } ", "target": 0}
{"func": "static void curlmultido(void *arg) { BDRVCURLState *s = (BDRVCURLState *)arg; int running; int r; if (!s->multi) { return; } do { r = curlmultisocketall(s->multi, &running); } while(r == CURLMCALLMULTIPERFORM); curlmultiread(s); } ", "target": 0}
{"func": "static int ffserversaveavoption(const char *opt, const char *arg, int type, FFServerConfig *config) { static int hinted = 0; int ret = 0; AVDictionaryEntry *e; const AVOption *o = NULL; const char *option = NULL; const char *codecname = NULL; char buff[1024]; AVCodecContext *ctx; AVDictionary **dict; enum AVCodecID guessedcodecid; switch (type) { case AVOPTFLAGVIDEOPARAM: ctx = config->dummyvctx; dict = &config->videoopts; guessedcodecid = config->guessedvideocodecid != AVCODECIDNONE ? config->guessedvideocodecid : AVCODECIDH264; break; case AVOPTFLAGAUDIOPARAM: ctx = config->dummyactx; dict = &config->audioopts; guessedcodecid = config->guessedaudiocodecid != AVCODECIDNONE ? config->guessedaudiocodecid : AVCODECIDAAC; break; default: avassert0(0); } if (strchr(opt, ':')) { //explicit private option snprintf(buff, sizeof(buff), \"%s\", opt); codecname = buff; option = strchr(buff, ':'); buff[option - buff] = '\\0'; option++; if ((ret = ffserversetcodec(ctx, codecname, config)) < 0) return ret; if (!ctx->codec || !ctx->privdata) return -1; } else { option = opt; } o = avoptfind(ctx, option, NULL, type | AVOPTFLAGENCODINGPARAM, AVOPTSEARCHCHILDREN); if (!o && (!strcmp(option, \"timebase\") || !strcmp(option, \"pixelformat\") || !strcmp(option, \"videosize\") || !strcmp(option, \"codectag\"))) o = avoptfind(ctx, option, NULL, 0, 0); if (!o) { reportconfigerror(config->filename, config->linenum, AVLOGERROR, &config->errors, \"Option not found: %s\\n\", opt); if (!hinted && ctx->codecid == AVCODECIDNONE) { hinted = 1; reportconfigerror(config->filename, config->linenum, AVLOGERROR, NULL, \"If '%s' is a codec private option, then prefix it with codec name, \" \"for example '%s:%s %s' or define codec earlier.\\n\", opt, avcodecgetname(guessedcodecid) ,opt, arg); } } else if ((ret = avoptset(ctx, option, arg, AVOPTSEARCHCHILDREN)) < 0) { reportconfigerror(config->filename, config->linenum, AVLOGERROR, &config->errors, \"Invalid value for option %s (%s): %s\\n\", opt, arg, averr2str(ret)); } else if ((e = avdictget(*dict, option, NULL, 0))) { if ((o->type == AVOPTTYPEFLAGS) && arg && (arg[0] == '+' || arg[0] == '-')) return avdictset(dict, option, arg, AVDICTAPPEND); reportconfigerror(config->filename, config->linenum, AVLOGERROR, &config->errors, \"Redeclaring value of the option %s, previous value: %s\\n\", opt, e->value); } else if (avdictset(dict, option, arg, 0) < 0) { return AVERROR(ENOMEM); } return 0; } ", "target": 0}
{"func": "static int decodeopc(MoxieCPU *cpu, DisasContext *ctx) { CPUMoxieState *env = &cpu->env; /* Local cache for the instruction opcode. */ int opcode; /* Set the default instruction length. */ int length = 2; if (unlikely(qemuloglevelmask(CPULOGTBOP | CPULOGTBOPOPT))) { tcggendebuginsnstart(ctx->pc); } /* Examine the 16-bit opcode. */ opcode = ctx->opcode; /* Decode instruction. */ if (opcode & (1 << 15)) { if (opcode & (1 << 14)) { /* This is a Form 3 instruction. */ int inst = (opcode >> 10 & 0xf); #define BRANCH(cond) \\ do { \\ int l1 = gennewlabel(); \\ tcggenbrcondi32(cond, cca, ccb, l1); \\ gengototb(env, ctx, 1, ctx->pc+2); \\ gensetlabel(l1); \\ gengototb(env, ctx, 0, extractbranchoffset(opcode) + ctx->pc+2); \\ ctx->bstate = BSBRANCH; \\ } while (0) switch (inst) { case 0x00: /* beq */ BRANCH(TCGCONDEQ); break; case 0x01: /* bne */ BRANCH(TCGCONDNE); break; case 0x02: /* blt */ BRANCH(TCGCONDLT); break; case 0x03: /* bgt */ BRANCH(TCGCONDGT); break; case 0x04: /* bltu */ BRANCH(TCGCONDLTU); break; case 0x05: /* bgtu */ BRANCH(TCGCONDGTU); break; case 0x06: /* bge */ BRANCH(TCGCONDGE); break; case 0x07: /* ble */ BRANCH(TCGCONDLE); break; case 0x08: /* bgeu */ BRANCH(TCGCONDGEU); break; case 0x09: /* bleu */ BRANCH(TCGCONDLEU); break; default: { TCGv temp = tcgtempnewi32(); tcggenmovii32(cpupc, ctx->pc); tcggenmovii32(temp, MOXIEEXBAD); genhelperraiseexception(cpuenv, temp); tcgtempfreei32(temp); } break; } } else { /* This is a Form 2 instruction. */ int inst = (opcode >> 12 & 0x3); switch (inst) { case 0x00: /* inc */ { int a = (opcode >> 8) & 0xf; unsigned int v = (opcode & 0xff); tcggenaddii32(REG(a), REG(a), v); } break; case 0x01: /* dec */ { int a = (opcode >> 8) & 0xf; unsigned int v = (opcode & 0xff); tcggensubii32(REG(a), REG(a), v); } break; case 0x02: /* gsr */ { int a = (opcode >> 8) & 0xf; unsigned v = (opcode & 0xff); tcggenldi32(REG(a), cpuenv, offsetof(CPUMoxieState, sregs[v])); } break; case 0x03: /* ssr */ { int a = (opcode >> 8) & 0xf; unsigned v = (opcode & 0xff); tcggensti32(REG(a), cpuenv, offsetof(CPUMoxieState, sregs[v])); } break; default: { TCGv temp = tcgtempnewi32(); tcggenmovii32(cpupc, ctx->pc); tcggenmovii32(temp, MOXIEEXBAD); genhelperraiseexception(cpuenv, temp); tcgtempfreei32(temp); } break; } } } else { /* This is a Form 1 instruction. */ int inst = opcode >> 8; switch (inst) { case 0x00: /* nop */ break; case 0x01: /* ldi.l (immediate) */ { int reg = (opcode >> 4) & 0xf; int val = cpuldlcode(env, ctx->pc+2); tcggenmovii32(REG(reg), val); length = 6; } break; case 0x02: /* mov (register-to-register) */ { int dest = (opcode >> 4) & 0xf; int src = opcode & 0xf; tcggenmovi32(REG(dest), REG(src)); } break; case 0x03: /* jsra */ { TCGv t1 = tcgtempnewi32(); TCGv t2 = tcgtempnewi32(); tcggenmovii32(t1, ctx->pc + 6); /* Make space for the static chain and return address. */ tcggensubii32(t2, REG(1), 8); tcggenmovi32(REG(1), t2); tcggenqemust32(t1, REG(1), ctx->memidx); /* Push the current frame pointer. */ tcggensubii32(t2, REG(1), 4); tcggenmovi32(REG(1), t2); tcggenqemust32(REG(0), REG(1), ctx->memidx); /* Set the pc and $fp. */ tcggenmovi32(REG(0), REG(1)); gengototb(env, ctx, 0, cpuldlcode(env, ctx->pc+2)); tcgtempfreei32(t1); tcgtempfreei32(t2); ctx->bstate = BSBRANCH; length = 6; } break; case 0x04: /* ret */ { TCGv t1 = tcgtempnewi32(); /* The new $sp is the old $fp. */ tcggenmovi32(REG(1), REG(0)); /* Pop the frame pointer. */ tcggenqemuld32u(REG(0), REG(1), ctx->memidx); tcggenaddii32(t1, REG(1), 4); tcggenmovi32(REG(1), t1); /* Pop the return address and skip over the static chain slot. */ tcggenqemuld32u(cpupc, REG(1), ctx->memidx); tcggenaddii32(t1, REG(1), 8); tcggenmovi32(REG(1), t1); tcgtempfreei32(t1); /* Jump... */ tcggenexittb(0); ctx->bstate = BSBRANCH; } break; case 0x05: /* add.l */ { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcggenaddi32(REG(a), REG(a), REG(b)); } break; case 0x06: /* push */ { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcgtempnewi32(); tcggensubii32(t1, REG(a), 4); tcggenmovi32(REG(a), t1); tcggenqemust32(REG(b), REG(a), ctx->memidx); tcgtempfreei32(t1); } break; case 0x07: /* pop */ { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcgtempnewi32(); tcggenqemuld32u(REG(b), REG(a), ctx->memidx); tcggenaddii32(t1, REG(a), 4); tcggenmovi32(REG(a), t1); tcgtempfreei32(t1); } break; case 0x08: /* lda.l */ { int reg = (opcode >> 4) & 0xf; TCGv ptr = tcgtempnewi32(); tcggenmovii32(ptr, cpuldlcode(env, ctx->pc+2)); tcggenqemuld32u(REG(reg), ptr, ctx->memidx); tcgtempfreei32(ptr); length = 6; } break; case 0x09: /* sta.l */ { int val = (opcode >> 4) & 0xf; TCGv ptr = tcgtempnewi32(); tcggenmovii32(ptr, cpuldlcode(env, ctx->pc+2)); tcggenqemust32(REG(val), ptr, ctx->memidx); tcgtempfreei32(ptr); length = 6; } break; case 0x0a: /* ld.l (register indirect) */ { int src = opcode & 0xf; int dest = (opcode >> 4) & 0xf; tcggenqemuld32u(REG(dest), REG(src), ctx->memidx); } break; case 0x0b: /* st.l */ { int dest = (opcode >> 4) & 0xf; int val = opcode & 0xf; tcggenqemust32(REG(val), REG(dest), ctx->memidx); } break; case 0x0c: /* ldo.l */ { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcgtempnewi32(); TCGv t2 = tcgtempnewi32(); tcggenaddii32(t1, REG(b), cpuldlcode(env, ctx->pc+2)); tcggenqemuld32u(t2, t1, ctx->memidx); tcggenmovi32(REG(a), t2); tcgtempfreei32(t1); tcgtempfreei32(t2); length = 6; } break; case 0x0d: /* sto.l */ { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcgtempnewi32(); TCGv t2 = tcgtempnewi32(); tcggenaddii32(t1, REG(a), cpuldlcode(env, ctx->pc+2)); tcggenqemust32(REG(b), t1, ctx->memidx); tcgtempfreei32(t1); tcgtempfreei32(t2); length = 6; } break; case 0x0e: /* cmp */ { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcggenmovi32(cca, REG(a)); tcggenmovi32(ccb, REG(b)); } break; case 0x19: /* jsr */ { int fnreg = (opcode >> 4) & 0xf; /* Load the stack pointer into T0. */ TCGv t1 = tcgtempnewi32(); TCGv t2 = tcgtempnewi32(); tcggenmovii32(t1, ctx->pc+2); /* Make space for the static chain and return address. */ tcggensubii32(t2, REG(1), 8); tcggenmovi32(REG(1), t2); tcggenqemust32(t1, REG(1), ctx->memidx); /* Push the current frame pointer. */ tcggensubii32(t2, REG(1), 4); tcggenmovi32(REG(1), t2); tcggenqemust32(REG(0), REG(1), ctx->memidx); /* Set the pc and $fp. */ tcggenmovi32(REG(0), REG(1)); tcggenmovi32(cpupc, REG(fnreg)); tcgtempfreei32(t1); tcgtempfreei32(t2); tcggenexittb(0); ctx->bstate = BSBRANCH; } break; case 0x1a: /* jmpa */ { tcggenmovii32(cpupc, cpuldlcode(env, ctx->pc+2)); tcggenexittb(0); ctx->bstate = BSBRANCH; length = 6; } break; case 0x1b: /* ldi.b (immediate) */ { int reg = (opcode >> 4) & 0xf; int val = cpuldlcode(env, ctx->pc+2); tcggenmovii32(REG(reg), val); length = 6; } break; case 0x1c: /* ld.b (register indirect) */ { int src = opcode & 0xf; int dest = (opcode >> 4) & 0xf; tcggenqemuld8u(REG(dest), REG(src), ctx->memidx); } break; case 0x1d: /* lda.b */ { int reg = (opcode >> 4) & 0xf; TCGv ptr = tcgtempnewi32(); tcggenmovii32(ptr, cpuldlcode(env, ctx->pc+2)); tcggenqemuld8u(REG(reg), ptr, ctx->memidx); tcgtempfreei32(ptr); length = 6; } break; case 0x1e: /* st.b */ { int dest = (opcode >> 4) & 0xf; int val = opcode & 0xf; tcggenqemust8(REG(val), REG(dest), ctx->memidx); } break; case 0x1f: /* sta.b */ { int val = (opcode >> 4) & 0xf; TCGv ptr = tcgtempnewi32(); tcggenmovii32(ptr, cpuldlcode(env, ctx->pc+2)); tcggenqemust8(REG(val), ptr, ctx->memidx); tcgtempfreei32(ptr); length = 6; } break; case 0x20: /* ldi.s (immediate) */ { int reg = (opcode >> 4) & 0xf; int val = cpuldlcode(env, ctx->pc+2); tcggenmovii32(REG(reg), val); length = 6; } break; case 0x21: /* ld.s (register indirect) */ { int src = opcode & 0xf; int dest = (opcode >> 4) & 0xf; tcggenqemuld16u(REG(dest), REG(src), ctx->memidx); } break; case 0x22: /* lda.s */ { int reg = (opcode >> 4) & 0xf; TCGv ptr = tcgtempnewi32(); tcggenmovii32(ptr, cpuldlcode(env, ctx->pc+2)); tcggenqemuld16u(REG(reg), ptr, ctx->memidx); tcgtempfreei32(ptr); length = 6; } break; case 0x23: /* st.s */ { int dest = (opcode >> 4) & 0xf; int val = opcode & 0xf; tcggenqemust16(REG(val), REG(dest), ctx->memidx); } break; case 0x24: /* sta.s */ { int val = (opcode >> 4) & 0xf; TCGv ptr = tcgtempnewi32(); tcggenmovii32(ptr, cpuldlcode(env, ctx->pc+2)); tcggenqemust16(REG(val), ptr, ctx->memidx); tcgtempfreei32(ptr); length = 6; } break; case 0x25: /* jmp */ { int reg = (opcode >> 4) & 0xf; tcggenmovi32(cpupc, REG(reg)); tcggenexittb(0); ctx->bstate = BSBRANCH; } break; case 0x26: /* and */ { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcggenandi32(REG(a), REG(a), REG(b)); } break; case 0x27: /* lshr */ { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv sv = tcgtempnewi32(); tcggenandii32(sv, REG(b), 0x1f); tcggenshri32(REG(a), REG(a), sv); tcgtempfreei32(sv); } break; case 0x28: /* ashl */ { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv sv = tcgtempnewi32(); tcggenandii32(sv, REG(b), 0x1f); tcggenshli32(REG(a), REG(a), sv); tcgtempfreei32(sv); } break; case 0x29: /* sub.l */ { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcggensubi32(REG(a), REG(a), REG(b)); } break; case 0x2a: /* neg */ { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcggennegi32(REG(a), REG(b)); } break; case 0x2b: /* or */ { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcggenori32(REG(a), REG(a), REG(b)); } break; case 0x2c: /* not */ { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcggennoti32(REG(a), REG(b)); } break; case 0x2d: /* ashr */ { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv sv = tcgtempnewi32(); tcggenandii32(sv, REG(b), 0x1f); tcggensari32(REG(a), REG(a), sv); tcgtempfreei32(sv); } break; case 0x2e: /* xor */ { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcggenxori32(REG(a), REG(a), REG(b)); } break; case 0x2f: /* mul.l */ { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcggenmuli32(REG(a), REG(a), REG(b)); } break; case 0x30: /* swi */ { int val = cpuldlcode(env, ctx->pc+2); TCGv temp = tcgtempnewi32(); tcggenmovii32(temp, val); tcggensti32(temp, cpuenv, offsetof(CPUMoxieState, sregs[3])); tcggenmovii32(cpupc, ctx->pc); tcggenmovii32(temp, MOXIEEXSWI); genhelperraiseexception(cpuenv, temp); tcgtempfreei32(temp); length = 6; } break; case 0x31: /* div.l */ { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcggenmovii32(cpupc, ctx->pc); genhelperdiv(REG(a), cpuenv, REG(a), REG(b)); } break; case 0x32: /* udiv.l */ { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcggenmovii32(cpupc, ctx->pc); genhelperudiv(REG(a), cpuenv, REG(a), REG(b)); } break; case 0x33: /* mod.l */ { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcggenremi32(REG(a), REG(a), REG(b)); } break; case 0x34: /* umod.l */ { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcggenremui32(REG(a), REG(a), REG(b)); } break; case 0x35: /* brk */ { TCGv temp = tcgtempnewi32(); tcggenmovii32(cpupc, ctx->pc); tcggenmovii32(temp, MOXIEEXBREAK); genhelperraiseexception(cpuenv, temp); tcgtempfreei32(temp); } break; case 0x36: /* ldo.b */ { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcgtempnewi32(); TCGv t2 = tcgtempnewi32(); tcggenaddii32(t1, REG(b), cpuldlcode(env, ctx->pc+2)); tcggenqemuld8u(t2, t1, ctx->memidx); tcggenmovi32(REG(a), t2); tcgtempfreei32(t1); tcgtempfreei32(t2); length = 6; } break; case 0x37: /* sto.b */ { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcgtempnewi32(); TCGv t2 = tcgtempnewi32(); tcggenaddii32(t1, REG(a), cpuldlcode(env, ctx->pc+2)); tcggenqemust8(REG(b), t1, ctx->memidx); tcgtempfreei32(t1); tcgtempfreei32(t2); length = 6; } break; case 0x38: /* ldo.s */ { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcgtempnewi32(); TCGv t2 = tcgtempnewi32(); tcggenaddii32(t1, REG(b), cpuldlcode(env, ctx->pc+2)); tcggenqemuld16u(t2, t1, ctx->memidx); tcggenmovi32(REG(a), t2); tcgtempfreei32(t1); tcgtempfreei32(t2); length = 6; } break; case 0x39: /* sto.s */ { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcgtempnewi32(); TCGv t2 = tcgtempnewi32(); tcggenaddii32(t1, REG(a), cpuldlcode(env, ctx->pc+2)); tcggenqemust16(REG(b), t1, ctx->memidx); tcgtempfreei32(t1); tcgtempfreei32(t2); length = 6; } break; default: { TCGv temp = tcgtempnewi32(); tcggenmovii32(cpupc, ctx->pc); tcggenmovii32(temp, MOXIEEXBAD); genhelperraiseexception(cpuenv, temp); tcgtempfreei32(temp); } break; } } return length; } ", "target": 0}
{"func": "static void tcgoutopc(TCGContext *s, int opc, int r, int rm, int x) { int rex; if (opc & PGS) { tcgout8(s, 0x65); } if (opc & PDATA16) { /* We should never be asking for both 16 and 64-bit operation. */ assert((opc & PREXW) == 0); tcgout8(s, 0x66); } if (opc & PADDR32) { tcgout8(s, 0x67); } rex = 0; rex |= (opc & PREXW) ? 0x8 : 0x0; /* REX.W */ rex |= (r & 8) >> 1; /* REX.R */ rex |= (x & 8) >> 2; /* REX.X */ rex |= (rm & 8) >> 3; /* REX.B */ /* PREXB{R,RM} indicates that the given register is the low byte. For %[abcd]l we need no REX prefix, but for %{si,di,bp,sp}l we do, as otherwise the encoding indicates %[abcd]h. Note that the values that are ORed in merely indicate that the REX byte must be present; those bits get discarded in output. */ rex |= opc & (r >= 4 ? PREXBR : 0); rex |= opc & (rm >= 4 ? PREXBRM : 0); if (rex) { tcgout8(s, (uint8t)(rex | 0x40)); } if (opc & (PEXT | PEXT38)) { tcgout8(s, 0x0f); if (opc & PEXT38) { tcgout8(s, 0x38); } } tcgout8(s, opc); } ", "target": 0}
{"func": "qcow2copwritevcompressed(BlockDriverState *bs, uint64t offset, uint64t bytes, QEMUIOVector *qiov) { BDRVQcow2State *s = bs->opaque; QEMUIOVector hdqiov; struct iovec iov; zstream strm; int ret, outlen; uint8t *buf, *outbuf; uint64t clusteroffset; if (bytes == 0) { /* align end of file to a sector boundary to ease reading with sector based I/Os */ clusteroffset = bdrvgetlength(bs->file->bs); return bdrvtruncate(bs->file, clusteroffset, PREALLOCMODEOFF, NULL); } buf = qemublockalign(bs, s->clustersize); if (bytes != s->clustersize) { if (bytes > s->clustersize || offset + bytes != bs->totalsectors << BDRVSECTORBITS) { qemuvfree(buf); return -EINVAL; } /* Zero-pad last write if image size is not cluster aligned */ memset(buf + bytes, 0, s->clustersize - bytes); } qemuiovectobuf(qiov, 0, buf, bytes); outbuf = gmalloc(s->clustersize); /* best compression, small window, no zlib header */ memset(&strm, 0, sizeof(strm)); ret = deflateInit2(&strm, ZDEFAULTCOMPRESSION, ZDEFLATED, -12, 9, ZDEFAULTSTRATEGY); if (ret != 0) { ret = -EINVAL; goto fail; } strm.availin = s->clustersize; strm.nextin = (uint8t *)buf; strm.availout = s->clustersize; strm.nextout = outbuf; ret = deflate(&strm, ZFINISH); if (ret != ZSTREAMEND && ret != ZOK) { deflateEnd(&strm); ret = -EINVAL; goto fail; } outlen = strm.nextout - outbuf; deflateEnd(&strm); if (ret != ZSTREAMEND || outlen >= s->clustersize) { /* could not compress: write normal cluster */ ret = qcow2copwritev(bs, offset, bytes, qiov, 0); if (ret < 0) { goto fail; } goto success; } qemucomutexlock(&s->lock); clusteroffset = qcow2alloccompressedclusteroffset(bs, offset, outlen); if (!clusteroffset) { qemucomutexunlock(&s->lock); ret = -EIO; goto fail; } clusteroffset &= s->clusteroffsetmask; ret = qcow2prewriteoverlapcheck(bs, 0, clusteroffset, outlen); qemucomutexunlock(&s->lock); if (ret < 0) { goto fail; } iov = (struct iovec) { .iovbase = outbuf, .iovlen = outlen, }; qemuiovecinitexternal(&hdqiov, &iov, 1); BLKDBGEVENT(bs->file, BLKDBGWRITECOMPRESSED); ret = bdrvcopwritev(bs->file, clusteroffset, outlen, &hdqiov, 0); if (ret < 0) { goto fail; } success: ret = 0; fail: qemuvfree(buf); gfree(outbuf); return ret; } ", "target": 1}
{"func": "static void genmfrom(DisasContext *ctx) { #if defined(CONFIGUSERONLY) geninvalexception(ctx, POWERPCEXCPPRIVOPC); #else if (unlikely(ctx->pr)) { geninvalexception(ctx, POWERPCEXCPPRIVOPC); return; } genhelper602mfrom(cpugpr[rD(ctx->opcode)], cpugpr[rA(ctx->opcode)]); #endif } ", "target": 1}
{"func": "static inline void RENAME(yuv422ptouyvy)(const uint8t *ysrc, const uint8t *usrc, const uint8t *vsrc, uint8t *dst, long width, long height, long lumStride, long chromStride, long dstStride) { RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1); } ", "target": 0}
{"func": "static gboolean gachannelopen(GAChannel *c, const gchar *path, GAChannelMethod method, int fd) { int ret; c->method = method; switch (c->method) { case GACHANNELVIRTIOSERIAL: { assert(fd < 0); fd = qemuopen(path, ORDWR | ONONBLOCK #ifndef CONFIGSOLARIS | OASYNC #endif ); if (fd == -1) { gcritical(\"error opening channel: %s\", strerror(errno)); return false; } #ifdef CONFIGSOLARIS ret = ioctl(fd, ISETSIG, SOUTPUT | SINPUT | SHIPRI); if (ret == -1) { gcritical(\"error setting event mask for channel: %s\", strerror(errno)); close(fd); return false; } #endif ret = gachannelclientadd(c, fd); if (ret) { gcritical(\"error adding channel to main loop\"); close(fd); return false; } break; } case GACHANNELISASERIAL: { struct termios tio; assert(fd < 0); fd = qemuopen(path, ORDWR | ONOCTTY | ONONBLOCK); if (fd == -1) { gcritical(\"error opening channel: %s\", strerror(errno)); return false; } tcgetattr(fd, &tio); /* set up serial port for non-canonical, dumb byte streaming */ tio.ciflag &= ~(IGNBRK | BRKINT | IGNPAR | PARMRK | INPCK | ISTRIP | INLCR | IGNCR | ICRNL | IXON | IXOFF | IXANY | IMAXBEL); tio.coflag = 0; tio.clflag = 0; tio.ccflag |= GACHANNELBAUDRATEDEFAULT; /* 1 available byte min or reads will block (we'll set non-blocking * elsewhere, else we have to deal with read()=0 instead) */ tio.ccc[VMIN] = 1; tio.ccc[VTIME] = 0; /* flush everything waiting for read/xmit, it's garbage at this point */ tcflush(fd, TCIFLUSH); tcsetattr(fd, TCSANOW, &tio); ret = gachannelclientadd(c, fd); if (ret) { gcritical(\"error adding channel to main loop\"); close(fd); return false; } break; } case GACHANNELUNIXLISTEN: { if (fd < 0) { Error *localerr = NULL; fd = unixlisten(path, NULL, strlen(path), &localerr); if (localerr != NULL) { gcritical(\"%s\", errorgetpretty(localerr)); errorfree(localerr); return false; } } gachannellistenadd(c, fd, true); break; } case GACHANNELVSOCKLISTEN: { if (fd < 0) { Error *localerr = NULL; SocketAddress *addr; char *addrstr; addrstr = gstrdupprintf(\"vsock:%s\", path); addr = socketparse(addrstr, &localerr); gfree(addrstr); if (localerr != NULL) { gcritical(\"%s\", errorgetpretty(localerr)); errorfree(localerr); return false; } fd = socketlisten(addr, &localerr); qapifreeSocketAddress(addr); if (localerr != NULL) { gcritical(\"%s\", errorgetpretty(localerr)); errorfree(localerr); return false; } } gachannellistenadd(c, fd, true); break; } default: gcritical(\"error binding/listening to specified socket\"); return false; } return true; } ", "target": 0}
{"func": "static int ramsaveblock(QEMUFile *f) { RAMBlock *block = lastblock; ramaddrt offset = lastoffset; int bytessent = -1; MemoryRegion *mr; if (!block) block = QLISTFIRST(&ramlist.blocks); do { mr = block->mr; if (memoryregiongetdirty(mr, offset, TARGETPAGESIZE, DIRTYMEMORYMIGRATION)) { uint8t *p; int cont = (block == lastblock) ? RAMSAVEFLAGCONTINUE : 0; memoryregionresetdirty(mr, offset, TARGETPAGESIZE, DIRTYMEMORYMIGRATION); p = memoryregiongetramptr(mr) + offset; if (isduppage(p)) { saveblockhdr(f, block, offset, cont, RAMSAVEFLAGCOMPRESS); qemuputbyte(f, *p); bytessent = 1; } else { saveblockhdr(f, block, offset, cont, RAMSAVEFLAGPAGE); qemuputbuffer(f, p, TARGETPAGESIZE); bytessent = TARGETPAGESIZE; } break; } offset += TARGETPAGESIZE; if (offset >= block->length) { offset = 0; block = QLISTNEXT(block, next); if (!block) block = QLISTFIRST(&ramlist.blocks); } } while (block != lastblock || offset != lastoffset); lastblock = block; lastoffset = offset; return bytessent; } ", "target": 0}
{"func": "bool nettxpktaddrawfragment(struct NetTxPkt *pkt, hwaddr pa, sizet len) { hwaddr mappedlen = 0; struct iovec *ventry; assert(pkt); assert(pkt->maxrawfrags > pkt->rawfrags); if (!len) { return true; } ventry = &pkt->raw[pkt->rawfrags]; mappedlen = len; ventry->iovbase = cpuphysicalmemorymap(pa, &mappedlen, false); ventry->iovlen = mappedlen; pkt->rawfrags += !!ventry->iovbase; if ((ventry->iovbase == NULL) || (len != mappedlen)) { return false; } return true; } ", "target": 0}
{"func": "yuv24222ctemplate(SwsContext *c, const uint16t *buf0, const uint16t *buf1, const uint16t *ubuf0, const uint16t *ubuf1, const uint16t *vbuf0, const uint16t *vbuf1, const uint16t *abuf0, const uint16t *abuf1, uint8t *dest, int dstW, int yalpha, int uvalpha, int y, enum PixelFormat target) { int yalpha1 = 4095 - yalpha; int uvalpha1 = 4095 - uvalpha; int i; for (i = 0; i < (dstW >> 1); i++) { int Y1 = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19; int Y2 = (buf0[i * 2 + 1] * yalpha1 + buf1[i * 2 + 1] * yalpha) >> 19; int U = (ubuf0[i] * uvalpha1 + ubuf1[i] * uvalpha) >> 19; int V = (vbuf0[i] * uvalpha1 + vbuf1[i] * uvalpha) >> 19; outputpixels(i * 4, Y1, U, Y2, V); } } ", "target": 0}
{"func": "static avalwaysinline void emulatededgemc(uint8t *buf, const uint8t *src, int linesize, int blockw, int blockh, int srcx, int srcy, int w, int h, emuedgecorefunc *corefn) { int starty, startx, endy, endx, srcyadd = 0; if (srcy >= h) { srcyadd = h - 1 - srcy; srcy = h - 1; } else if (srcy <= -blockh) { srcyadd = 1 - blockh - srcy; srcy = 1 - blockh; } if (srcx >= w) { src += w - 1 - srcx; srcx = w - 1; } else if (srcx <= -blockw) { src += 1 - blockw - srcx; srcx = 1 - blockw; } starty = FFMAX(0, -srcy); startx = FFMAX(0, -srcx); endy = FFMIN(blockh, h-srcy); endx = FFMIN(blockw, w-srcx); avassert2(startx < endx && blockw > 0); avassert2(starty < endy && blockh > 0); // fill in the to-be-copied part plus all above/below src += (srcyadd + starty) * linesize + startx; buf += startx; corefn(buf, src, linesize, starty, endy, blockh, startx, endx, blockw); } ", "target": 0}
{"func": "static avcold int initbundles(BinkContext *c) { int bw, bh, blocks; int i; bw = (c->avctx->width + 7) >> 3; bh = (c->avctx->height + 7) >> 3; blocks = bw * bh; for (i = 0; i < BINKBNBSRC; i++) { c->bundle[i].data = avmalloc(blocks * 64); if (!c->bundle[i].data) return AVERROR(ENOMEM); c->bundle[i].dataend = c->bundle[i].data + blocks * 64; } return 0; } ", "target": 1}
{"func": "static void quorumvote(QuorumAIOCB *acb) { bool quorum = true; int i, j, ret; QuorumVoteValue hash; BDRVQuorumState *s = acb->common.bs->opaque; QuorumVoteVersion *winner; if (quorumhastoomuchiofailed(acb)) { return; } /* get the index of the first successful read */ for (i = 0; i < s->numchildren; i++) { if (!acb->qcrs[i].ret) { break; } } assert(i < s->numchildren); /* compare this read with all other successful reads stopping at quorum * failure */ for (j = i + 1; j < s->numchildren; j++) { if (acb->qcrs[j].ret) { continue; } quorum = quorumcompare(acb, &acb->qcrs[i].qiov, &acb->qcrs[j].qiov); if (!quorum) { break; } } /* Every successful read agrees */ if (quorum) { quorumcopyqiov(acb->qiov, &acb->qcrs[i].qiov); return; } /* compute hashes for each successful read, also store indexes */ for (i = 0; i < s->numchildren; i++) { if (acb->qcrs[i].ret) { continue; } ret = quorumcomputehash(acb, i, &hash); /* if ever the hash computation failed */ if (ret < 0) { acb->voteret = ret; goto freeexit; } quorumcountvote(&acb->votes, &hash, i); } /* vote to select the most represented version */ winner = quorumgetvotewinner(&acb->votes); /* if the winner count is smaller than threshold the read fails */ if (winner->votecount < s->threshold) { quorumreportfailure(acb); acb->voteret = -EIO; goto freeexit; } /* we have a winner: copy it */ quorumcopyqiov(acb->qiov, &acb->qcrs[winner->index].qiov); /* some versions are bad print them */ quorumreportbadversions(s, acb, &winner->value); freeexit: /* free lists */ quorumfreevotelist(&acb->votes); } ", "target": 1}
{"func": "static void stellarisinit(const char *kernelfilename, const char *cpumodel, stellarisboardinfo *board) { static const int uartirq[] = {5, 6, 33, 34}; static const int timerirq[] = {19, 21, 23, 35}; static const uint32t gpioaddr[7] = { 0x40004000, 0x40005000, 0x40006000, 0x40007000, 0x40024000, 0x40025000, 0x40026000}; static const int gpioirq[7] = {0, 1, 2, 3, 4, 30, 31}; qemuirq *pic; DeviceState *gpiodev[7]; qemuirq gpioin[7][8]; qemuirq gpioout[7][8]; qemuirq adc; int sramsize; int flashsize; I2CBus *i2c; DeviceState *dev; int i; int j; MemoryRegion *sram = gnew(MemoryRegion, 1); MemoryRegion *flash = gnew(MemoryRegion, 1); MemoryRegion *systemmemory = getsystemmemory(); flashsize = (((board->dc0 & 0xffff) + 1) << 1) * 1024; sramsize = ((board->dc0 >> 18) + 1) * 1024; /* Flash programming is done via the SCU, so pretend it is ROM. */ memoryregioninitram(flash, NULL, \"stellaris.flash\", flashsize, &errorabort); vmstateregisterramglobal(flash); memoryregionsetreadonly(flash, true); memoryregionaddsubregion(systemmemory, 0, flash); memoryregioninitram(sram, NULL, \"stellaris.sram\", sramsize, &errorabort); vmstateregisterramglobal(sram); memoryregionaddsubregion(systemmemory, 0x20000000, sram); pic = armv7minit(systemmemory, flashsize, NUMIRQLINES, kernelfilename, cpumodel); if (board->dc1 & (1 << 16)) { dev = sysbuscreatevarargs(TYPESTELLARISADC, 0x40038000, pic[14], pic[15], pic[16], pic[17], NULL); adc = qdevgetgpioin(dev, 0); } else { adc = NULL; } for (i = 0; i < 4; i++) { if (board->dc2 & (0x10000 << i)) { dev = sysbuscreatesimple(TYPESTELLARISGPTM, 0x40030000 + i * 0x1000, pic[timerirq[i]]); /* TODO: This is incorrect, but we get away with it because the ADC output is only ever pulsed. */ qdevconnectgpioout(dev, 0, adc); } } stellarissysinit(0x400fe000, pic[28], board, ndtable[0].macaddr.a); for (i = 0; i < 7; i++) { if (board->dc4 & (1 << i)) { gpiodev[i] = sysbuscreatesimple(\"pl061luminary\", gpioaddr[i], pic[gpioirq[i]]); for (j = 0; j < 8; j++) { gpioin[i][j] = qdevgetgpioin(gpiodev[i], j); gpioout[i][j] = NULL; } } } if (board->dc2 & (1 << 12)) { dev = sysbuscreatesimple(TYPESTELLARISI2C, 0x40020000, pic[8]); i2c = (I2CBus *)qdevgetchildbus(dev, \"i2c\"); if (board->peripherals & BPOLEDI2C) { i2ccreateslave(i2c, \"ssd0303\", 0x3d); } } for (i = 0; i < 4; i++) { if (board->dc2 & (1 << i)) { sysbuscreatesimple(\"pl011luminary\", 0x4000c000 + i * 0x1000, pic[uartirq[i]]); } } if (board->dc2 & (1 << 4)) { dev = sysbuscreatesimple(\"pl022\", 0x40008000, pic[7]); if (board->peripherals & BPOLEDSSI) { void *bus; DeviceState *sddev; DeviceState *ssddev; /* Some boards have both an OLED controller and SD card connected to * the same SSI port, with the SD card chip select connected to a * GPIO pin. Technically the OLED chip select is connected to the * SSI Fss pin. We do not bother emulating that as both devices * should never be selected simultaneously, and our OLED controller * ignores stray 0xff commands that occur when deselecting the SD * card. */ bus = qdevgetchildbus(dev, \"ssi\"); sddev = ssicreateslave(bus, \"ssi-sd\"); ssddev = ssicreateslave(bus, \"ssd0323\"); gpioout[GPIOD][0] = qemuirqsplit( qdevgetgpioinnamed(sddev, SSIGPIOCS, 0), qdevgetgpioinnamed(ssddev, SSIGPIOCS, 0)); gpioout[GPIOC][7] = qdevgetgpioin(ssddev, 0); /* Make sure the select pin is high. */ qemuirqraise(gpioout[GPIOD][0]); } } if (board->dc4 & (1 << 28)) { DeviceState *enet; qemuchecknicmodel(&ndtable[0], \"stellaris\"); enet = qdevcreate(NULL, \"stellarisenet\"); qdevsetnicproperties(enet, &ndtable[0]); qdevinitnofail(enet); sysbusmmiomap(SYSBUSDEVICE(enet), 0, 0x40048000); sysbusconnectirq(SYSBUSDEVICE(enet), 0, pic[42]); } if (board->peripherals & BPGAMEPAD) { qemuirq gpadirq[5]; static const int gpadkeycode[5] = { 0xc8, 0xd0, 0xcb, 0xcd, 0x1d }; gpadirq[0] = qemuirqinvert(gpioin[GPIOE][0]); /* up */ gpadirq[1] = qemuirqinvert(gpioin[GPIOE][1]); /* down */ gpadirq[2] = qemuirqinvert(gpioin[GPIOE][2]); /* left */ gpadirq[3] = qemuirqinvert(gpioin[GPIOE][3]); /* right */ gpadirq[4] = qemuirqinvert(gpioin[GPIOF][1]); /* select */ stellarisgamepadinit(5, gpadirq, gpadkeycode); } for (i = 0; i < 7; i++) { if (board->dc4 & (1 << i)) { for (j = 0; j < 8; j++) { if (gpioout[i][j]) { qdevconnectgpioout(gpiodev[i], j, gpioout[i][j]); } } } } } ", "target": 1}
{"func": "void cpuexecinit(CPUState *env) { CPUState **penv; int cpuindex; if (!codegenptr) { codegenptr = codegenbuffer; pageinit(); iomeminit(); } env->nextcpu = NULL; penv = &firstcpu; cpuindex = 0; while (*penv != NULL) { penv = (CPUState **)&(*penv)->nextcpu; cpuindex++; } env->cpuindex = cpuindex; *penv = env; }", "target": 1}
{"func": "static inline void RENAME(yuv422ptoyuy2)(const uint8t *ysrc, const uint8t *usrc, const uint8t *vsrc, uint8t *dst, \tlong width, long height, \tlong lumStride, long chromStride, long dstStride) { \tRENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1); } ", "target": 1}
{"func": "static inline bool handlerisasync(const moncmdt *cmd) { return cmd->flags & MONITORCMDASYNC; } ", "target": 1}
{"func": "static int vqadecodeinit(AVCodecContext *avctx) { VqaContext *s = (VqaContext *)avctx->privdata; unsigned char *vqaheader; int i, j, codebookindex;; s->avctx = avctx; avctx->pixfmt = PIXFMTPAL8; avctx->hasbframes = 0; dsputilinit(&s->dsp, avctx); /* make sure the extradata made it */ if (s->avctx->extradatasize != VQAHEADERSIZE) { avlog(s->avctx, AVLOGERROR, \" VQA video: expected extradata size of %d\\n\", VQAHEADERSIZE); /* load up the VQA parameters from the header */ vqaheader = (unsigned char *)s->avctx->extradata; s->vqaversion = vqaheader[0]; s->width = LE16(&vqaheader[6]); s->height = LE16(&vqaheader[8]); s->vectorwidth = vqaheader[10]; s->vectorheight = vqaheader[11]; s->partialcount = s->partialcountdown = vqaheader[13]; /* the vector dimensions have to meet very stringent requirements */ if ((s->vectorwidth != 4) || ((s->vectorheight != 2) && (s->vectorheight != 4))) { /* return without further initialization */ /* allocate codebooks */ s->codebooksize = MAXCODEBOOKSIZE; s->codebook = avmalloc(s->codebooksize); s->nextcodebookbuffer = avmalloc(s->codebooksize); /* initialize the solid-color vectors */ if (s->vectorheight == 4) { codebookindex = 0xFF00 * 16; for (i = 0; i < 256; i++) for (j = 0; j < 16; j++) s->codebook[codebookindex++] = i; } else { codebookindex = 0xF00 * 8; for (i = 0; i < 256; i++) for (j = 0; j < 8; j++) s->codebook[codebookindex++] = i; s->nextcodebookbufferindex = 0; /* allocate decode buffer */ s->decodebuffersize = (s->width / s->vectorwidth) * (s->height / s->vectorheight) * 2; s->decodebuffer = avmalloc(s->decodebuffersize); s->frame.data[0] = NULL; return 0; ", "target": 1}
{"func": "static int openoutputfile(OptionsContext *o, const char *filename) { AVFormatContext *oc; int i, j, err; AVOutputFormat *fileoformat; OutputFile *of; OutputStream *ost; InputStream *ist; AVDictionary *unusedopts = NULL; AVDictionaryEntry *e = NULL; if (configurecomplexfilters() < 0) { avlog(NULL, AVLOGFATAL, \"Error configuring filters.\\n\"); exitprogram(1); } if (o->stoptime != INT64MAX && o->recordingtime != INT64MAX) { o->stoptime = INT64MAX; avlog(NULL, AVLOGWARNING, \"-t and -to cannot be used together; using -t.\\n\"); } if (o->stoptime != INT64MAX && o->recordingtime == INT64MAX) { int64t starttime = o->starttime == AVNOPTSVALUE ? 0 : o->starttime; if (o->stoptime <= starttime) { avlog(NULL, AVLOGWARNING, \"-to value smaller than -ss; ignoring -to.\\n\"); o->stoptime = INT64MAX; } else { o->recordingtime = o->stoptime - starttime; } } GROWARRAY(outputfiles, nboutputfiles); of = avmallocz(sizeof(*of)); if (!of) exitprogram(1); outputfiles[nboutputfiles - 1] = of; of->ostindex = nboutputstreams; of->recordingtime = o->recordingtime; of->starttime = o->starttime; of->limitfilesize = o->limitfilesize; of->shortest = o->shortest; avdictcopy(&of->opts, o->g->formatopts, 0); if (!strcmp(filename, \"-\")) filename = \"pipe:\"; err = avformatallocoutputcontext2(&oc, NULL, o->format, filename); if (!oc) { printerror(filename, err); exitprogram(1); } of->ctx = oc; if (o->recordingtime != INT64MAX) oc->duration = o->recordingtime; fileoformat= oc->oformat; oc->interruptcallback = intcb; /* create streams for all unlabeled output pads */ for (i = 0; i < nbfiltergraphs; i++) { FilterGraph *fg = filtergraphs[i]; for (j = 0; j < fg->nboutputs; j++) { OutputFilter *ofilter = fg->outputs[j]; if (!ofilter->outtmp || ofilter->outtmp->name) continue; switch (avfilterpadgettype(ofilter->outtmp->filterctx->outputpads, ofilter->outtmp->padidx)) { case AVMEDIATYPEVIDEO: o->videodisable = 1; break; case AVMEDIATYPEAUDIO: o->audiodisable = 1; break; case AVMEDIATYPESUBTITLE: o->subtitledisable = 1; break; } initoutputfilter(ofilter, o, oc); } } /* ffserver seeking with date=... needs a date reference */ if (!strcmp(fileoformat->name, \"ffm\") && avstrstart(filename, \"http:\", NULL)) { int err = parseoption(o, \"metadata\", \"creationtime=now\", options); if (err < 0) { printerror(filename, err); exitprogram(1); } } if (!strcmp(fileoformat->name, \"ffm\") && !overrideffserver && avstrstart(filename, \"http:\", NULL)) { int j; /* special case for files sent to ffserver: we get the stream parameters from ffserver */ int err = readffserverstreams(o, oc, filename); if (err < 0) { printerror(filename, err); exitprogram(1); } for(j = nboutputstreams - oc->nbstreams; j < nboutputstreams; j++) { ost = outputstreams[j]; for (i = 0; i < nbinputstreams; i++) { ist = inputstreams[i]; if(ist->st->codec->codectype == ost->st->codec->codectype){ ost->syncist= ist; ost->sourceindex= i; if(ost->st->codec->codectype == AVMEDIATYPEAUDIO) ost->avfilter = avstrdup(\"anull\"); if(ost->st->codec->codectype == AVMEDIATYPEVIDEO) ost->avfilter = avstrdup(\"null\"); ist->discard = 0; ist->st->discard = AVDISCARDNONE; break; } } if(!ost->syncist){ avlog(NULL, AVLOGFATAL, \"Missing %s stream which is required by this ffm\\n\", avgetmediatypestring(ost->st->codec->codectype)); exitprogram(1); } } } else if (!o->nbstreammaps) { char *subtitlecodecname = NULL; /* pick the \"best\" stream of each type */ /* video: highest resolution */ if (!o->videodisable && oc->oformat->videocodec != AVCODECIDNONE) { int area = 0, idx = -1; int qcr = avformatquerycodec(oc->oformat, oc->oformat->videocodec, 0); for (i = 0; i < nbinputstreams; i++) { int newarea; ist = inputstreams[i]; newarea = ist->st->codec->width * ist->st->codec->height; if((qcr!=MKTAG('A', 'P', 'I', 'C')) && (ist->st->disposition & AVDISPOSITIONATTACHEDPIC)) newarea = 1; if (ist->st->codec->codectype == AVMEDIATYPEVIDEO && newarea > area) { if((qcr==MKTAG('A', 'P', 'I', 'C')) && !(ist->st->disposition & AVDISPOSITIONATTACHEDPIC)) continue; area = newarea; idx = i; } } if (idx >= 0) newvideostream(o, oc, idx); } /* audio: most channels */ if (!o->audiodisable && oc->oformat->audiocodec != AVCODECIDNONE) { int channels = 0, idx = -1; for (i = 0; i < nbinputstreams; i++) { ist = inputstreams[i]; if (ist->st->codec->codectype == AVMEDIATYPEAUDIO && ist->st->codec->channels > channels) { channels = ist->st->codec->channels; idx = i; } } if (idx >= 0) newaudiostream(o, oc, idx); } /* subtitles: pick first */ MATCHPERTYPEOPT(codecnames, str, subtitlecodecname, oc, \"s\"); if (!o->subtitledisable && (oc->oformat->subtitlecodec != AVCODECIDNONE || subtitlecodecname)) { for (i = 0; i < nbinputstreams; i++) if (inputstreams[i]->st->codec->codectype == AVMEDIATYPESUBTITLE) { newsubtitlestream(o, oc, i); break; } } /* do something with data? */ } else { for (i = 0; i < o->nbstreammaps; i++) { StreamMap *map = &o->streammaps[i]; if (map->disabled) continue; if (map->linklabel) { FilterGraph *fg; OutputFilter *ofilter = NULL; int j, k; for (j = 0; j < nbfiltergraphs; j++) { fg = filtergraphs[j]; for (k = 0; k < fg->nboutputs; k++) { AVFilterInOut *out = fg->outputs[k]->outtmp; if (out && !strcmp(out->name, map->linklabel)) { ofilter = fg->outputs[k]; goto loopend; } } } loopend: if (!ofilter) { avlog(NULL, AVLOGFATAL, \"Output with label '%s' does not exist \" \"in any defined filter graph, or was already used elsewhere.\\n\", map->linklabel); exitprogram(1); } initoutputfilter(ofilter, o, oc); } else { int srcidx = inputfiles[map->fileindex]->istindex + map->streamindex; ist = inputstreams[inputfiles[map->fileindex]->istindex + map->streamindex]; if(o->subtitledisable && ist->st->codec->codectype == AVMEDIATYPESUBTITLE) continue; if(o-> audiodisable && ist->st->codec->codectype == AVMEDIATYPEAUDIO) continue; if(o-> videodisable && ist->st->codec->codectype == AVMEDIATYPEVIDEO) continue; if(o-> datadisable && ist->st->codec->codectype == AVMEDIATYPEDATA) continue; switch (ist->st->codec->codectype) { case AVMEDIATYPEVIDEO: ost = newvideostream (o, oc, srcidx); break; case AVMEDIATYPEAUDIO: ost = newaudiostream (o, oc, srcidx); break; case AVMEDIATYPESUBTITLE: ost = newsubtitlestream (o, oc, srcidx); break; case AVMEDIATYPEDATA: ost = newdatastream (o, oc, srcidx); break; case AVMEDIATYPEATTACHMENT: ost = newattachmentstream(o, oc, srcidx); break; default: avlog(NULL, AVLOGFATAL, \"Cannot map stream #%d:%d - unsupported type.\\n\", map->fileindex, map->streamindex); exitprogram(1); } } } } /* handle attached files */ for (i = 0; i < o->nbattachments; i++) { AVIOContext *pb; uint8t *attachment; const char *p; int64t len; if ((err = avioopen2(&pb, o->attachments[i], AVIOFLAGREAD, &intcb, NULL)) < 0) { avlog(NULL, AVLOGFATAL, \"Could not open attachment file %s.\\n\", o->attachments[i]); exitprogram(1); } if ((len = aviosize(pb)) <= 0) { avlog(NULL, AVLOGFATAL, \"Could not get size of the attachment %s.\\n\", o->attachments[i]); exitprogram(1); } if (!(attachment = avmalloc(len))) { avlog(NULL, AVLOGFATAL, \"Attachment %s too large to fit into memory.\\n\", o->attachments[i]); exitprogram(1); } avioread(pb, attachment, len); ost = newattachmentstream(o, oc, -1); ost->streamcopy = 0; ost->attachmentfilename = o->attachments[i]; ost->finished = 1; ost->st->codec->extradata = attachment; ost->st->codec->extradatasize = len; p = strrchr(o->attachments[i], '/'); avdictset(&ost->st->metadata, \"filename\", (p && *p) ? p + 1 : o->attachments[i], AVDICTDONTOVERWRITE); avioclose(pb); } for (i = nboutputstreams - oc->nbstreams; i < nboutputstreams; i++) { //for all streams of this output file AVDictionaryEntry *e; ost = outputstreams[i]; if ((ost->streamcopy || ost->attachmentfilename) && (e = avdictget(o->g->codecopts, \"flags\", NULL, AVDICTIGNORESUFFIX)) && (!e->key[5] || checkstreamspecifier(oc, ost->st, e->key+6))) if (avoptset(ost->st->codec, \"flags\", e->value, 0) < 0) exitprogram(1); } /* check if all codec options have been used */ unusedopts = stripspecifiers(o->g->codecopts); for (i = of->ostindex; i < nboutputstreams; i++) { e = NULL; while ((e = avdictget(outputstreams[i]->opts, \"\", e, AVDICTIGNORESUFFIX))) avdictset(&unusedopts, e->key, NULL, 0); } e = NULL; while ((e = avdictget(unusedopts, \"\", e, AVDICTIGNORESUFFIX))) { const AVClass *class = avcodecgetclass(); const AVOption *option = avoptfind(&class, e->key, NULL, 0, AVOPTSEARCHCHILDREN | AVOPTSEARCHFAKEOBJ); if (!option) continue; if (!(option->flags & AVOPTFLAGENCODINGPARAM)) { avlog(NULL, AVLOGERROR, \"Codec AVOption %s (%s) specified for \" \"output file #%d (%s) is not an encoding option.\\n\", e->key, option->help ? option->help : \"\", nboutputfiles - 1, filename); exitprogram(1); } // goptimecode is injected by generic code but not always used if (!strcmp(e->key, \"goptimecode\")) continue; avlog(NULL, AVLOGWARNING, \"Codec AVOption %s (%s) specified for \" \"output file #%d (%s) has not been used for any stream. The most \" \"likely reason is either wrong type (e.g. a video option with \" \"no video streams) or that it is a private option of some encoder \" \"which was not actually used for any stream.\\n\", e->key, option->help ? option->help : \"\", nboutputfiles - 1, filename); } avdictfree(&unusedopts); /* check filename in case of an image number is expected */ if (oc->oformat->flags & AVFMTNEEDNUMBER) { if (!avfilenamenumbertest(oc->filename)) { printerror(oc->filename, AVERROR(EINVAL)); exitprogram(1); } } if (!(oc->oformat->flags & AVFMTNOFILE)) { /* test if it already exists to avoid losing precious files */ assertfileoverwrite(filename); /* open the file */ if ((err = avioopen2(&oc->pb, filename, AVIOFLAGWRITE, &oc->interruptcallback, &of->opts)) < 0) { printerror(filename, err); exitprogram(1); } } else if (strcmp(oc->oformat->name, \"image2\")==0 && !avfilenamenumbertest(filename)) assertfileoverwrite(filename); if (o->muxpreload) { uint8t buf[64]; snprintf(buf, sizeof(buf), \"%d\", (int)(o->muxpreload*AVTIMEBASE)); avdictset(&of->opts, \"preload\", buf, 0); } oc->maxdelay = (int)(o->muxmaxdelay * AVTIMEBASE); /* copy metadata */ for (i = 0; i < o->nbmetadatamap; i++) { char *p; int infileindex = strtol(o->metadatamap[i].u.str, &p, 0); if (infileindex >= nbinputfiles) { avlog(NULL, AVLOGFATAL, \"Invalid input file index %d while processing metadata maps\\n\", infileindex); exitprogram(1); } copymetadata(o->metadatamap[i].specifier, *p ? p + 1 : p, oc, infileindex >= 0 ? inputfiles[infileindex]->ctx : NULL, o); } /* copy chapters */ if (o->chaptersinputfile >= nbinputfiles) { if (o->chaptersinputfile == INTMAX) { /* copy chapters from the first input file that has them*/ o->chaptersinputfile = -1; for (i = 0; i < nbinputfiles; i++) if (inputfiles[i]->ctx->nbchapters) { o->chaptersinputfile = i; break; } } else { avlog(NULL, AVLOGFATAL, \"Invalid input file index %d in chapter mapping.\\n\", o->chaptersinputfile); exitprogram(1); } } if (o->chaptersinputfile >= 0) copychapters(inputfiles[o->chaptersinputfile], of, !o->metadatachaptersmanual); /* copy global metadata by default */ if (!o->metadataglobalmanual && nbinputfiles){ avdictcopy(&oc->metadata, inputfiles[0]->ctx->metadata, AVDICTDONTOVERWRITE); if(o->recordingtime != INT64MAX) avdictset(&oc->metadata, \"duration\", NULL, 0); avdictset(&oc->metadata, \"creationtime\", NULL, 0); } if (!o->metadatastreamsmanual) for (i = of->ostindex; i < nboutputstreams; i++) { InputStream *ist; if (outputstreams[i]->sourceindex < 0) /* this is true e.g. for attached files */ continue; ist = inputstreams[outputstreams[i]->sourceindex]; avdictcopy(&outputstreams[i]->st->metadata, ist->st->metadata, AVDICTDONTOVERWRITE); } /* process manually set metadata */ for (i = 0; i < o->nbmetadata; i++) { AVDictionary **m; char type, *val; const char *streamspec; int index = 0, j, ret = 0; val = strchr(o->metadata[i].u.str, '='); if (!val) { avlog(NULL, AVLOGFATAL, \"No '=' character in metadata string %s.\\n\", o->metadata[i].u.str); exitprogram(1); } *val++ = 0; parsemetatype(o->metadata[i].specifier, &type, &index, &streamspec); if (type == 's') { for (j = 0; j < oc->nbstreams; j++) { if ((ret = checkstreamspecifier(oc, oc->streams[j], streamspec)) > 0) { avdictset(&oc->streams[j]->metadata, o->metadata[i].u.str, *val ? val : NULL, 0); } else if (ret < 0) exitprogram(1); } } else { switch (type) { case 'g': m = &oc->metadata; break; case 'c': if (index < 0 || index >= oc->nbchapters) { avlog(NULL, AVLOGFATAL, \"Invalid chapter index %d in metadata specifier.\\n\", index); exitprogram(1); } m = &oc->chapters[index]->metadata; break; default: avlog(NULL, AVLOGFATAL, \"Invalid metadata specifier %s.\\n\", o->metadata[i].specifier); exitprogram(1); } avdictset(m, o->metadata[i].u.str, *val ? val : NULL, 0); } } return 0; } ", "target": 0}
{"func": "static bool logicimmdecodewmask(uint64t *result, unsigned int immn, unsigned int imms, unsigned int immr) { uint64t mask; unsigned e, levels, s, r; int len; assert(immn < 2 && imms < 64 && immr < 64); /* The bit patterns we create here are 64 bit patterns which * are vectors of identical elements of size e = 2, 4, 8, 16, 32 or * 64 bits each. Each element contains the same value: a run * of between 1 and e-1 non-zero bits, rotated within the * element by between 0 and e-1 bits. * * The element size and run length are encoded into immn (1 bit) * and imms (6 bits) as follows: * 64 bit elements: immn = 1, imms = <length of run - 1> * 32 bit elements: immn = 0, imms = 0 : <length of run - 1> * 16 bit elements: immn = 0, imms = 10 : <length of run - 1> * 8 bit elements: immn = 0, imms = 110 : <length of run - 1> * 4 bit elements: immn = 0, imms = 1110 : <length of run - 1> * 2 bit elements: immn = 0, imms = 11110 : <length of run - 1> * Notice that immn = 0, imms = 11111x is the only combination * not covered by one of the above options; this is reserved. * Further, <length of run - 1> all-ones is a reserved pattern. * * In all cases the rotation is by immr % e (and immr is 6 bits). */ /* First determine the element size */ len = 31 - clz32((immn << 6) | (~imms & 0x3f)); if (len < 1) { /* This is the immn == 0, imms == 0x11111x case */ return false; } e = 1 << len; levels = e - 1; s = imms & levels; r = immr & levels; if (s == levels) { /* <length of run - 1> mustn't be all-ones. */ return false; } /* Create the value of one element: s+1 set bits rotated * by r within the element (which is e bits wide)... */ mask = bitmask64(s + 1); mask = (mask >> r) | (mask << (e - r)); /* ...then replicate the element over the whole 64 bit value */ mask = bitfieldreplicate(mask, e); *result = mask; return true; } ", "target": 1}
{"func": "static int addcandidateref(HEVCContext *s, RefPicList *list, int poc, int refflag) { HEVCFrame *ref = findrefidx(s, poc); if (ref == s->ref) return AVERRORINVALIDDATA; if (!ref) { ref = generatemissingref(s, poc); if (!ref) return AVERROR(ENOMEM); } list->list[list->nbrefs] = ref->poc; list->ref[list->nbrefs] = ref; list->nbrefs++; markref(ref, refflag); return 0; } ", "target": 1}
{"func": "static inline void tgenmovpregTN(DisasContext *dc, int r, TCGv tn) { if (r < 0 || r > 15) { fprintf(stderr, \"wrong register write $p%d\\n\", r); } if (r == PRBZ || r == PRWZ || r == PRDZ) { return; } else if (r == PRSRS) { tcggenanditl(cpuPR[r], tn, 3); } else { if (r == PRPID) { genhelpertlbflushpid(cpuenv, tn); } if (dc->tbflags & SFLAG && r == PRSPC) { genhelperspcwrite(cpuenv, tn); } else if (r == PRCCS) { dc->cpustatechanged = 1; } tcggenmovtl(cpuPR[r], tn); } } ", "target": 1}
{"func": "static int vorbisparseidhdr(vorbiscontext *vc){ GetBitContext *gb=&vc->gb; uintfast8t bl0, bl1; if ((getbits(gb, 8)!='v') || (getbits(gb, 8)!='o') || (getbits(gb, 8)!='r') || (getbits(gb, 8)!='b') || (getbits(gb, 8)!='i') || (getbits(gb, 8)!='s')) { avlog(vc->avccontext, AVLOGERROR, \" Vorbis id header packet corrupt (no vorbis signature). \\n\"); return 1; } vc->version=getbitslong(gb, 32); //FIXME check 0 vc->audiochannels=getbits(gb, 8); //FIXME check >0 vc->audiosamplerate=getbitslong(gb, 32); //FIXME check >0 vc->bitratemaximum=getbitslong(gb, 32); vc->bitratenominal=getbitslong(gb, 32); vc->bitrateminimum=getbitslong(gb, 32); bl0=getbits(gb, 4); bl1=getbits(gb, 4); vc->blocksize[0]=(1<<bl0); vc->blocksize[1]=(1<<bl1); if (bl0>13 || bl0<6 || bl1>13 || bl1<6 || bl1<bl0) { avlog(vc->avccontext, AVLOGERROR, \" Vorbis id header packet corrupt (illegal blocksize). \\n\"); return 3; } // output format int16 if (vc->blocksize[1]/2 * vc->audiochannels * 2 > AVCODECMAXAUDIOFRAMESIZE) { avlog(vc->avccontext, AVLOGERROR, \"Vorbis channel count makes \" \"output packets too large.\\n\"); return 4; } vc->win[0]=ffvorbisvwin[bl0-6]; vc->win[1]=ffvorbisvwin[bl1-6]; if(vc->expbias){ int i, j; for(j=0; j<2; j++){ float *win = avmalloc(vc->blocksize[j]/2 * sizeof(float)); for(i=0; i<vc->blocksize[j]/2; i++) win[i] = vc->win[j][i] * (1<<15); vc->win[j] = win; } } if ((getbits1(gb)) == 0) { avlog(vc->avccontext, AVLOGERROR, \" Vorbis id header packet corrupt (framing flag not set). \\n\"); return 2; } vc->channelresidues= avmalloc((vc->blocksize[1]/2)*vc->audiochannels * sizeof(float)); vc->channelfloors = avmalloc((vc->blocksize[1]/2)*vc->audiochannels * sizeof(float)); vc->saved = avmallocz((vc->blocksize[1]/2)*vc->audiochannels * sizeof(float)); vc->ret = avmalloc((vc->blocksize[1]/2)*vc->audiochannels * sizeof(float)); vc->buf = avmalloc( vc->blocksize[1] * sizeof(float)); vc->buftmp = avmalloc( vc->blocksize[1] * sizeof(float)); vc->previouswindow=0; ffmdctinit(&vc->mdct[0], bl0, 1); ffmdctinit(&vc->mdct[1], bl1, 1); AVDEBUG(\" vorbis version %d \\n audiochannels %d \\n audiosamplerate %d \\n bitratemax %d \\n bitratenom %d \\n bitratemin %d \\n blk0 %d blk1 %d \\n \", vc->version, vc->audiochannels, vc->audiosamplerate, vc->bitratemaximum, vc->bitratenominal, vc->bitrateminimum, vc->blocksize[0], vc->blocksize[1]); /* BLK=vc->blocksize[0]; for(i=0;i<BLK/2;++i) { vc->win[0][i]=sin(0.5*3.14159265358*(sin(((float)i+0.5)/(float)BLK*3.14159265358))*(sin(((float)i+0.5)/(float)BLK*3.14159265358))); } */ return 0; } ", "target": 1}
{"func": "void ffavgh264qpel4mc31msa(uint8t *dst, const uint8t *src, ptrdifft stride) { avclumahvqrtandaverdst4x4msa(src - 2, src - (stride * 2) + sizeof(uint8t), stride, dst, stride); } ", "target": 0}
{"func": "static int netvhostuserinit(NetClientState *peer, const char *device, const char *name, CharDriverState *chr, int queues) { NetClientState *nc; VhostUserState *s; int i; for (i = 0; i < queues; i++) { nc = qemunewnetclient(&netvhostuserinfo, peer, device, name); snprintf(nc->infostr, sizeof(nc->infostr), \"vhost-user%d to %s\", i, chr->label); nc->queueindex = i; s = DOUPCAST(VhostUserState, nc, nc); s->chr = chr; } qemuchraddhandlers(chr, NULL, NULL, netvhostuserevent, (void*)name); return 0; } ", "target": 1}
{"func": "static int flvprobe(AVProbeData *p) { const uint8t *d; if (p->bufsize < 6) return 0; d = p->buf; if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) { return AVPROBESCOREMAX; } return 0; } ", "target": 0}
{"func": "static void scsireaddata(SCSIDevice *d, uint32t tag) { SCSIDiskState *s = DOUPCAST(SCSIDiskState, qdev, d); SCSIDiskReq *r; r = scsifindrequest(s, tag); if (!r) { BADF(\"Bad read tag 0x%x\\n\", tag); /* ??? This is the wrong error. */ scsicommandcomplete(r, CHECKCONDITION, HARDWAREERROR); return; } /* No data transfer may already be in progress */ assert(r->req.aiocb == NULL); scsireadrequest(r); } ", "target": 0}
{"func": "static void optoutputfile(void *optctx, const char *filename) { OptionsContext *o = optctx; AVFormatContext *oc; int i, err; AVOutputFormat *fileoformat; OutputStream *ost; InputStream *ist; if (!strcmp(filename, \"-\")) filename = \"pipe:\"; oc = avformatalloccontext(); if (!oc) { printerror(filename, AVERROR(ENOMEM)); exitprogram(1); } if (lastaskedformat) { fileoformat = avguessformat(lastaskedformat, NULL, NULL); if (!fileoformat) { fprintf(stderr, \"Requested output format '%s' is not a suitable output format\\n\", lastaskedformat); exitprogram(1); } lastaskedformat = NULL; } else { fileoformat = avguessformat(NULL, filename, NULL); if (!fileoformat) { fprintf(stderr, \"Unable to find a suitable output format for '%s'\\n\", filename); exitprogram(1); } } oc->oformat = fileoformat; avstrlcpy(oc->filename, filename, sizeof(oc->filename)); if (!strcmp(fileoformat->name, \"ffm\") && avstrstart(filename, \"http:\", NULL)) { /* special case for files sent to avserver: we get the stream parameters from avserver */ int err = readavserverstreams(oc, filename); if (err < 0) { printerror(filename, err); exitprogram(1); } } else if (!o->nbstreammaps) { /* pick the \"best\" stream of each type */ #define NEWSTREAM(type, index)\\ if (index >= 0) {\\ ost = new ## type ## stream(oc);\\ ost->sourceindex = index;\\ ost->syncist = &inputstreams[index];\\ inputstreams[index].discard = 0;\\ } /* video: highest resolution */ if (!videodisable && oc->oformat->videocodec != CODECIDNONE) { int area = 0, idx = -1; for (i = 0; i < nbinputstreams; i++) { ist = &inputstreams[i]; if (ist->st->codec->codectype == AVMEDIATYPEVIDEO && ist->st->codec->width * ist->st->codec->height > area) { area = ist->st->codec->width * ist->st->codec->height; idx = i; } } NEWSTREAM(video, idx); } /* audio: most channels */ if (!audiodisable && oc->oformat->audiocodec != CODECIDNONE) { int channels = 0, idx = -1; for (i = 0; i < nbinputstreams; i++) { ist = &inputstreams[i]; if (ist->st->codec->codectype == AVMEDIATYPEAUDIO && ist->st->codec->channels > channels) { channels = ist->st->codec->channels; idx = i; } } NEWSTREAM(audio, idx); } /* subtitles: pick first */ if (!subtitledisable && oc->oformat->subtitlecodec != CODECIDNONE) { for (i = 0; i < nbinputstreams; i++) if (inputstreams[i].st->codec->codectype == AVMEDIATYPESUBTITLE) { NEWSTREAM(subtitle, i); break; } } /* do something with data? */ } else { for (i = 0; i < o->nbstreammaps; i++) { StreamMap *map = &o->streammaps[i]; if (map->disabled) continue; ist = &inputstreams[inputfiles[map->fileindex].istindex + map->streamindex]; switch (ist->st->codec->codectype) { case AVMEDIATYPEVIDEO: ost = newvideostream(oc); break; case AVMEDIATYPEAUDIO: ost = newaudiostream(oc); break; case AVMEDIATYPESUBTITLE: ost = newsubtitlestream(oc); break; case AVMEDIATYPEDATA: ost = newdatastream(oc); break; default: avlog(NULL, AVLOGERROR, \"Cannot map stream #%d.%d - unsupported type.\\n\", map->fileindex, map->streamindex); exitprogram(1); } ost->sourceindex = inputfiles[map->fileindex].istindex + map->streamindex; ost->syncist = &inputstreams[inputfiles[map->syncfileindex].istindex + map->syncstreamindex]; ist->discard = 0; } } avdictcopy(&oc->metadata, metadata, 0); avdictfree(&metadata); outputfiles = growarray(outputfiles, sizeof(*outputfiles), &nboutputfiles, nboutputfiles + 1); outputfiles[nboutputfiles - 1].ctx = oc; outputfiles[nboutputfiles - 1].ostindex = nboutputstreams - oc->nbstreams; outputfiles[nboutputfiles - 1].recordingtime = o->recordingtime; outputfiles[nboutputfiles - 1].starttime = o->starttime; outputfiles[nboutputfiles - 1].limitfilesize = limitfilesize; avdictcopy(&outputfiles[nboutputfiles - 1].opts, formatopts, 0); /* check filename in case of an image number is expected */ if (oc->oformat->flags & AVFMTNEEDNUMBER) { if (!avfilenamenumbertest(oc->filename)) { printerror(oc->filename, AVERROR(EINVAL)); exitprogram(1); } } if (!(oc->oformat->flags & AVFMTNOFILE)) { /* test if it already exists to avoid loosing precious files */ if (!fileoverwrite && (strchr(filename, ':') == NULL || filename[1] == ':' || avstrstart(filename, \"file:\", NULL))) { if (aviocheck(filename, 0) == 0) { if (!usingstdin) { fprintf(stderr,\"File '%s' already exists. Overwrite ? [y/N] \", filename); fflush(stderr); if (!readyesno()) { fprintf(stderr, \"Not overwriting - exiting\\n\"); exitprogram(1); } } else { fprintf(stderr,\"File '%s' already exists. Exiting.\\n\", filename); exitprogram(1); } } } /* open the file */ if ((err = avioopen(&oc->pb, filename, AVIOFLAGWRITE)) < 0) { printerror(filename, err); exitprogram(1); } } oc->preload= (int)(muxpreload*AVTIMEBASE); oc->maxdelay= (int)(muxmaxdelay*AVTIMEBASE); oc->flags |= AVFMTFLAGNONBLOCK; /* copy chapters */ if (chaptersinputfile >= nbinputfiles) { if (chaptersinputfile == INTMAX) { /* copy chapters from the first input file that has them*/ chaptersinputfile = -1; for (i = 0; i < nbinputfiles; i++) if (inputfiles[i].ctx->nbchapters) { chaptersinputfile = i; break; } } else { avlog(NULL, AVLOGERROR, \"Invalid input file index %d in chapter mapping.\\n\", chaptersinputfile); exitprogram(1); } } if (chaptersinputfile >= 0) copychapters(&inputfiles[chaptersinputfile], &outputfiles[nboutputfiles - 1]); /* copy metadata */ for (i = 0; i < nbmetadatamaps; i++) { AVFormatContext *files[2]; AVDictionary **meta[2]; int j; #define METADATACHECKINDEX(index, nbelems, desc)\\ if ((index) < 0 || (index) >= (nbelems)) {\\ avlog(NULL, AVLOGERROR, \"Invalid %s index %d while processing metadata maps\\n\",\\ (desc), (index));\\ exitprogram(1);\\ } int infileindex = metadatamaps[i][1].file; if (infileindex < 0) continue; METADATACHECKINDEX(infileindex, nbinputfiles, \"input file\") files[0] = oc; files[1] = inputfiles[infileindex].ctx; for (j = 0; j < 2; j++) { MetadataMap *map = &metadatamaps[i][j]; switch (map->type) { case 'g': meta[j] = &files[j]->metadata; break; case 's': METADATACHECKINDEX(map->index, files[j]->nbstreams, \"stream\") meta[j] = &files[j]->streams[map->index]->metadata; break; case 'c': METADATACHECKINDEX(map->index, files[j]->nbchapters, \"chapter\") meta[j] = &files[j]->chapters[map->index]->metadata; break; case 'p': METADATACHECKINDEX(map->index, files[j]->nbprograms, \"program\") meta[j] = &files[j]->programs[map->index]->metadata; break; } } avdictcopy(meta[0], *meta[1], AVDICTDONTOVERWRITE); } /* copy global metadata by default */ if (metadataglobalautocopy && nbinputfiles) avdictcopy(&oc->metadata, inputfiles[0].ctx->metadata, AVDICTDONTOVERWRITE); if (metadatastreamsautocopy) for (i = outputfiles[nboutputfiles - 1].ostindex; i < nboutputstreams; i++) { InputStream *ist = &inputstreams[outputstreams[i].sourceindex]; avdictcopy(&outputstreams[i].st->metadata, ist->st->metadata, AVDICTDONTOVERWRITE); } framerate = (AVRational){0, 0}; framewidth = 0; frameheight = 0; audiosamplerate = 0; audiochannels = 0; audiosamplefmt = AVSAMPLEFMTNONE; chaptersinputfile = INTMAX; limitfilesize = UINT64MAX; avfreep(&metadatamaps); nbmetadatamaps = 0; metadataglobalautocopy = 1; metadatastreamsautocopy = 1; metadatachaptersautocopy = 1; avfreep(&streamidmap); nbstreamidmap = 0; avdictfree(&codecnames); avfreep(&forcedkeyframes); resetoptions(o); } ", "target": 0}
{"func": "static int spawnthread(void) { pthreadattrt attr; int ret; curthreads++; idlethreads++; pthreadattrinit(&attr); pthreadattrsetdetachstate(&attr, PTHREADCREATEDETACHED); ret = pthreadcreate(&threadid, &attr, aiothread, NULL); pthreadattrdestroy(&attr); return ret; } ", "target": 0}
{"func": "static int readgab2sub(AVStream *st, AVPacket *pkt) { if (pkt->size >= 7 && !strcmp(pkt->data, \"GAB2\") && AVRL16(pkt->data + 5) == 2) { uint8t desc[256]; int score = AVPROBESCOREEXTENSION, ret; AVIStream *ast = st->privdata; AVInputFormat *subdemuxer; AVRational timebase; AVIOContext *pb = avioalloccontext(pkt->data + 7, pkt->size - 7, 0, NULL, NULL, NULL, NULL); AVProbeData pd; unsigned int desclen = aviorl32(pb); if (desclen > pb->bufend - pb->bufptr) goto error; ret = aviogetstr16le(pb, desclen, desc, sizeof(desc)); avioskip(pb, desclen - ret); if (*desc) avdictset(&st->metadata, \"title\", desc, 0); aviorl16(pb); /* flags? */ aviorl32(pb); /* data size */ pd = (AVProbeData) { .buf = pb->bufptr, .bufsize = pb->bufend - pb->bufptr }; if (!(subdemuxer = avprobeinputformat2(&pd, 1, &score))) goto error; if (!(ast->subctx = avformatalloccontext())) goto error; ast->subctx->pb = pb; if (!avformatopeninput(&ast->subctx, \"\", subdemuxer, NULL)) { ffreadpacket(ast->subctx, &ast->subpkt); *st->codec = *ast->subctx->streams[0]->codec; ast->subctx->streams[0]->codec->extradata = NULL; timebase = ast->subctx->streams[0]->timebase; avprivsetptsinfo(st, 64, timebase.num, timebase.den); } ast->subbuffer = pkt->data; memset(pkt, 0, sizeof(*pkt)); return 1; error: avfreep(&pb); } return 0; } ", "target": 0}
{"func": "bool machineiommu(MachineState *machine) { return machine->iommu; } ", "target": 0}
{"func": "static int disascp15insn(CPUState *env, DisasContext *s, uint32t insn) { uint32t rd; TCGv tmp, tmp2; /* M profile cores use memory mapped registers instead of cp15. */ if (armfeature(env, ARMFEATUREM)) \treturn 1; if ((insn & (1 << 25)) == 0) { if (insn & (1 << 20)) { /* mrrc */ return 1; } /* mcrr. Used for block cache operations, so implement as no-op. */ return 0; } if ((insn & (1 << 4)) == 0) { /* cdp */ return 1; } if (ISUSER(s) && !cp15userok(insn)) { return 1; } if ((insn & 0x0fff0fff) == 0x0e070f90 || (insn & 0x0fff0fff) == 0x0e070f58) { /* Wait for interrupt. */ gensetpcim(s->pc); s->isjmp = DISASWFI; return 0; } rd = (insn >> 12) & 0xf; if (cp15tlsloadstore(env, s, insn, rd)) return 0; tmp2 = tcgconsti32(insn); if (insn & ARMCPRWBIT) { tmp = newtmp(); genhelpergetcp15(tmp, cpuenv, tmp2); /* If the destination register is r15 then sets condition codes. */ if (rd != 15) storereg(s, rd, tmp); else deadtmp(tmp); } else { tmp = loadreg(s, rd); genhelpersetcp15(cpuenv, tmp2, tmp); deadtmp(tmp); /* Normally we would always end the TB here, but Linux * arch/arm/mach-pxa/sleep.S expects two instructions following * an MMU enable to execute from cache. Imitate this behaviour. */ if (!armfeature(env, ARMFEATUREXSCALE) || (insn & 0x0fff0fff) != 0x0e010f10) genlookuptb(s); } tcgtempfreei32(tmp2); return 0; } ", "target": 0}
{"func": "static CharDriverState *vcinit(const char *id, ChardevBackend *backend, ChardevReturn *ret, Error **errp) { return vchandler(backend->u.vc, errp); } ", "target": 0}
{"func": "USBDevice *usbhostdeviceopen(const char *devname) { int fd = -1, ret; USBHostDevice *dev = NULL; struct usbdevfsconnectinfo ci; char buf[1024]; int busnum, addr; char productname[PRODUCTNAMESZ]; dev = qemumallocz(sizeof(USBHostDevice)); if (!dev) goto fail; #ifdef DEBUGISOCH printf(\"usbhostdeviceopen %s\\n\", devname); #endif if (usbhostfinddevice(&busnum, &addr, productname, sizeof(productname), devname) < 0) return NULL; snprintf(buf, sizeof(buf), USBDEVFSPATH \"/%03d/%03d\", busnum, addr); fd = open(buf, ORDWR | ONONBLOCK); if (fd < 0) { perror(buf); return NULL; } /* read the device description */ dev->descrlen = read(fd, dev->descr, sizeof(dev->descr)); if (dev->descrlen <= 0) { perror(\"usbhostdeviceopen: reading device data failed\"); goto fail; } #ifdef DEBUG { int x; printf(\"=== begin dumping device descriptor data ===\\n\"); for (x = 0; x < dev->descrlen; x++) printf(\"%02x \", dev->descr[x]); printf(\"\\n=== end dumping device descriptor data ===\\n\"); } #endif dev->fd = fd; dev->configuration = 1; /* XXX - do something about initial configuration */ if (!usbhostupdateinterfaces(dev, 1)) goto fail; ret = ioctl(fd, USBDEVFSCONNECTINFO, &ci); if (ret < 0) { perror(\"usbhostdeviceopen: USBDEVFSCONNECTINFO\"); goto fail; } #ifdef DEBUG printf(\"host USB device %d.%d grabbed\\n\", busnum, addr); #endif ret = usblinuxupdateendptable(dev); if (ret) goto fail; if (ci.slow) dev->dev.speed = USBSPEEDLOW; else dev->dev.speed = USBSPEEDHIGH; dev->dev.handlepacket = usbgenerichandlepacket; dev->dev.handlereset = usbhosthandlereset; dev->dev.handlecontrol = usbhosthandlecontrol; dev->dev.handledata = usbhosthandledata; dev->dev.handledestroy = usbhosthandledestroy; if (productname[0] == '\\0') snprintf(dev->dev.devname, sizeof(dev->dev.devname), \"host:%s\", devname); else pstrcpy(dev->dev.devname, sizeof(dev->dev.devname), productname); #ifdef USEASYNCIO /* set up the signal handlers */ sigemptyset(&sigact.samask); sigact.sasigaction = isochdone; sigact.saflags = SASIGINFO; sigact.sarestorer = 0; ret = sigaction(SIGISOCOMPLETE, &sigact, NULL); if (ret < 0) { perror(\"usbhostdeviceopen: sigaction failed\"); goto fail; } if (pipe(dev->pipefds) < 0) { perror(\"usbhostdeviceopen: pipe creation failed\"); goto fail; } fcntl(dev->pipefds[0], FSETFL, ONONBLOCK | OASYNC); fcntl(dev->pipefds[1], FSETFL, ONONBLOCK); qemusetfdhandler(dev->pipefds[0], urbcompletionpiperead, NULL, dev); #endif dev->urbsready = 0; return (USBDevice *)dev; fail: if (dev) qemufree(dev); close(fd); return NULL; } ", "target": 0}
{"func": "uint64t helperfrsp(CPUPPCState *env, uint64t arg) { CPUDoubleU farg; float32 f32; farg.ll = arg; if (unlikely(float64issignalingnan(farg.d))) { /* sNaN square root */ floadinvalidopexcp(env, POWERPCEXCPFPVXSNAN); } f32 = float64tofloat32(farg.d, &env->fpstatus); farg.d = float32tofloat64(f32, &env->fpstatus); return farg.ll; } ", "target": 0}
{"func": "int gennewlabel(void) { TCGContext *s = &tcgctx; int idx; TCGLabel *l; if (s->nblabels >= TCGMAXLABELS) tcgabort(); idx = s->nblabels++; l = &s->labels[idx]; l->hasvalue = 0; l->u.firstreloc = NULL; return idx; } ", "target": 0}
{"func": "void bdrvroundtoclusters(BlockDriverState *bs, int64t sectornum, int nbsectors, int64t *clustersectornum, int *clusternbsectors) { BlockDriverInfo bdi; if (bdrvgetinfo(bs, &bdi) < 0 || bdi.clustersize == 0) { *clustersectornum = sectornum; *clusternbsectors = nbsectors; } else { int64t c = bdi.clustersize / BDRVSECTORSIZE; *clustersectornum = QEMUALIGNDOWN(sectornum, c); *clusternbsectors = QEMUALIGNUP(sectornum - *clustersectornum + nbsectors, c); } } ", "target": 0}
{"func": "void tlbresetdirty(CPUState *cpu, ramaddrt start1, ramaddrt length) { CPUArchState *env; int mmuidx; assertcpuisself(cpu); env = cpu->envptr; for (mmuidx = 0; mmuidx < NBMMUMODES; mmuidx++) { unsigned int i; for (i = 0; i < CPUTLBSIZE; i++) { tlbresetdirtyrange(&env->tlbtable[mmuidx][i], start1, length); } for (i = 0; i < CPUVTLBSIZE; i++) { tlbresetdirtyrange(&env->tlbvtable[mmuidx][i], start1, length); } } } ", "target": 1}
{"func": "blkdebugcopreadv(BlockDriverState *bs, uint64t offset, uint64t bytes, QEMUIOVector *qiov, int flags) { BDRVBlkdebugState *s = bs->opaque; BlkdebugRule *rule = NULL; QSIMPLEQFOREACH(rule, &s->activerules, activenext) { uint64t injectoffset = rule->options.inject.offset; if (injectoffset == -1 || (injectoffset >= offset && injectoffset < offset + bytes)) { break; if (rule && rule->options.inject.error) { return injecterror(bs, rule); return bdrvcopreadv(bs->file, offset, bytes, qiov, flags);", "target": 1}
{"func": "static int idreginit1(SysBusDevice *dev) { IDRegState *s = MACIOIDREGISTER(dev); memoryregioninitram(&s->mem, OBJECT(s), \"sun4m.idreg\", sizeof(idregdata), &errorabort); vmstateregisterramglobal(&s->mem); memoryregionsetreadonly(&s->mem, true); sysbusinitmmio(dev, &s->mem); return 0; } ", "target": 1}
{"func": "static inline void tcgoutldptr(TCGContext *s, int ret, tcgtargetlong arg) { #if defined(sparcv9) && !defined(sparcv8plus) if (arg != (arg & 0xffffffff)) fprintf(stderr, \"unimplemented %s with offset %ld\\n\", func, arg); if (arg != (arg & 0xfff)) tcgout32(s, SETHI | INSNRD(ret) | (((uint32t)arg & 0xfffffc00) >> 10)); tcgout32(s, LDX | INSNRD(ret) | INSNRS1(ret) | INSNIMM13(arg & 0x3ff)); #else tcgoutldraw(s, ret, arg); #endif } ", "target": 0}
{"func": "int xenconfigdevblk(DriveInfo *disk) { char fe[256], be[256]; int vdev = 202 * 256 + 16 * disk->unit; int cdrom = disk->bdrv->type == BDRVTYPECDROM; const char *devtype = cdrom ? \"cdrom\" : \"disk\"; const char *mode = cdrom ? \"r\" : \"w\"; snprintf(disk->bdrv->devicename, sizeof(disk->bdrv->devicename), \t \"xvd%c\", 'a' + disk->unit); xenbeprintf(NULL, 1, \"config disk %d [%s]: %s\\n\", disk->unit, disk->bdrv->devicename, disk->bdrv->filename); xenconfigdevdirs(\"vbd\", \"qdisk\", vdev, fe, be, sizeof(fe)); /* frontend */ xenstorewriteint(fe, \"virtual-device\", vdev); xenstorewritestr(fe, \"device-type\", devtype); /* backend */ xenstorewritestr(be, \"dev\", disk->bdrv->devicename); xenstorewritestr(be, \"type\", \"file\"); xenstorewritestr(be, \"params\", disk->bdrv->filename); xenstorewritestr(be, \"mode\", mode); /* common stuff */ return xenconfigdevall(fe, be); } ", "target": 0}
{"func": "static inline void genintermediatecodeinternal(OpenRISCCPU *cpu, TranslationBlock *tb, int searchpc) { CPUState *cs = CPU(cpu); struct DisasContext ctx, *dc = &ctx; uint16t *genopcend; uint32t pcstart; int j, k; uint32t nextpagestart; int numinsns; int maxinsns; pcstart = tb->pc; dc->tb = tb; genopcend = tcgctx.genopcbuf + OPCMAXSIZE; dc->isjmp = DISASNEXT; dc->ppc = pcstart; dc->pc = pcstart; dc->flags = cpu->env.cpucfgr; dc->memidx = cpummuindex(&cpu->env); dc->syncedflags = dc->tbflags = tb->flags; dc->delayedbranch = !!(dc->tbflags & DFLAG); dc->singlestepenabled = cs->singlestepenabled; if (qemuloglevelmask(CPULOGTBINASM)) { qemulog(\"-----------------------------------------\\n\"); logcpustate(CPU(cpu), 0); } nextpagestart = (pcstart & TARGETPAGEMASK) + TARGETPAGESIZE; k = -1; numinsns = 0; maxinsns = tb->cflags & CFCOUNTMASK; if (maxinsns == 0) { maxinsns = CFCOUNTMASK; } gentbstart(); do { checkbreakpoint(cpu, dc); if (searchpc) { j = tcgctx.genopcptr - tcgctx.genopcbuf; if (k < j) { k++; while (k < j) { tcgctx.genopcinstrstart[k++] = 0; } } tcgctx.genopcpc[k] = dc->pc; tcgctx.genopcinstrstart[k] = 1; tcgctx.genopcicount[k] = numinsns; } if (unlikely(qemuloglevelmask(CPULOGTBOP | CPULOGTBOPOPT))) { tcggendebuginsnstart(dc->pc); } if (numinsns + 1 == maxinsns && (tb->cflags & CFLASTIO)) { geniostart(); } dc->ppc = dc->pc - 4; dc->npc = dc->pc + 4; tcggenmovitl(cpuppc, dc->ppc); tcggenmovitl(cpunpc, dc->npc); disasopenriscinsn(dc, cpu); dc->pc = dc->npc; numinsns++; /* delay slot */ if (dc->delayedbranch) { dc->delayedbranch--; if (!dc->delayedbranch) { dc->tbflags &= ~DFLAG; gensyncflags(dc); tcggenmovtl(cpupc, jmppc); tcggenmovtl(cpunpc, jmppc); tcggenmovitl(jmppc, 0); tcggenexittb(0); dc->isjmp = DISASJUMP; break; } } } while (!dc->isjmp && tcgctx.genopcptr < genopcend && !cs->singlestepenabled && !singlestep && (dc->pc < nextpagestart) && numinsns < maxinsns); if (tb->cflags & CFLASTIO) { genioend(); } if (dc->isjmp == DISASNEXT) { dc->isjmp = DISASUPDATE; tcggenmovitl(cpupc, dc->pc); } if (unlikely(cs->singlestepenabled)) { if (dc->isjmp == DISASNEXT) { tcggenmovitl(cpupc, dc->pc); } genexception(dc, EXCPDEBUG); } else { switch (dc->isjmp) { case DISASNEXT: gengototb(dc, 0, dc->pc); break; default: case DISASJUMP: break; case DISASUPDATE: /* indicate that the hash table must be used to find the next TB */ tcggenexittb(0); break; case DISASTBJUMP: /* nothing more to generate */ break; } } gentbend(tb, numinsns); *tcgctx.genopcptr = INDEXopend; if (searchpc) { j = tcgctx.genopcptr - tcgctx.genopcbuf; k++; while (k <= j) { tcgctx.genopcinstrstart[k++] = 0; } } else { tb->size = dc->pc - pcstart; tb->icount = numinsns; } #ifdef DEBUGDISAS if (qemuloglevelmask(CPULOGTBINASM)) { qemulog(\"\\n\"); logtargetdisas(&cpu->env, pcstart, dc->pc - pcstart, 0); qemulog(\"\\nisize=%d osize=%td\\n\", dc->pc - pcstart, tcgctx.genopcptr - tcgctx.genopcbuf); } #endif } ", "target": 0}
{"func": "static void pciivshmemrealize(PCIDevice *dev, Error **errp) { IVShmemState *s = IVSHMEM(dev); Error *err = NULL; uint8t *pciconf; uint8t attr = PCIBASEADDRESSSPACEMEMORY | PCIBASEADDRESSMEMPREFETCH; if (!!s->serverchr + !!s->shmobj + !!s->hostmem != 1) { errorsetg(errp, \"You must specify either 'shm', 'chardev' or 'x-memdev'\"); return; } if (s->hostmem) { MemoryRegion *mr; if (s->sizearg) { gwarning(\"size argument ignored with hostmem\"); } mr = hostmemorybackendgetmemory(s->hostmem, &errorabort); s->ivshmemsize = memoryregionsize(mr); } else if (s->sizearg == NULL) { s->ivshmemsize = 4 << 20; /* 4 MB default */ } else { char *end; int64t size = qemustrtosz(s->sizearg, &end); if (size < 0 || *end != '\\0' || !ispowerof2(size)) { errorsetg(errp, \"Invalid size %s\", s->sizearg); return; } s->ivshmemsize = size; } /* IRQFD requires MSI */ if (ivshmemhasfeature(s, IVSHMEMIOEVENTFD) && !ivshmemhasfeature(s, IVSHMEMMSI)) { errorsetg(errp, \"ioeventfd/irqfd requires MSI\"); return; } /* check that role is reasonable */ if (s->role) { if (strncmp(s->role, \"peer\", 5) == 0) { s->roleval = IVSHMEMPEER; } else if (strncmp(s->role, \"master\", 7) == 0) { s->roleval = IVSHMEMMASTER; } else { errorsetg(errp, \"'role' must be 'peer' or 'master'\"); return; } } else { s->roleval = IVSHMEMMASTER; /* default */ } pciconf = dev->config; pciconf[PCICOMMAND] = PCICOMMANDIO | PCICOMMANDMEMORY; /* * Note: we don't use INTx with IVSHMEMMSI at all, so this is a * bald-faced lie then. But it's a backwards compatible lie. */ pciconfigsetinterruptpin(pciconf, 1); memoryregioninitio(&s->ivshmemmmio, OBJECT(s), &ivshmemmmioops, s, \"ivshmem-mmio\", IVSHMEMREGBARSIZE); /* region for registers*/ pciregisterbar(dev, 0, PCIBASEADDRESSSPACEMEMORY, &s->ivshmemmmio); memoryregioninit(&s->bar, OBJECT(s), \"ivshmem-bar2-container\", s->ivshmemsize); if (s->ivshmem64bit) { attr |= PCIBASEADDRESSMEMTYPE64; } if (s->hostmem != NULL) { MemoryRegion *mr; IVSHMEMDPRINTF(\"using hostmem\\n\"); mr = hostmemorybackendgetmemory(MEMORYBACKEND(s->hostmem), &errorabort); vmstateregisterram(mr, DEVICE(s)); memoryregionaddsubregion(&s->bar, 0, mr); pciregisterbar(PCIDEVICE(s), 2, attr, &s->bar); } else if (s->serverchr != NULL) { /* FIXME do not rely on what chr drivers put into filename */ if (strncmp(s->serverchr->filename, \"unix:\", 5)) { errorsetg(errp, \"chardev is not a unix client socket\"); return; } /* if we get a UNIX socket as the parameter we will talk * to the ivshmem server to receive the memory region */ IVSHMEMDPRINTF(\"using shared memory server (socket = %s)\\n\", s->serverchr->filename); if (ivshmemsetupinterrupts(s) < 0) { errorsetg(errp, \"failed to initialize interrupts\"); return; } /* we allocate enough space for 16 peers and grow as needed */ resizepeers(s, 16); s->vmid = -1; pciregisterbar(dev, 2, attr, &s->bar); qemuchraddhandlers(s->serverchr, ivshmemcanreceive, ivshmemcheckversion, NULL, s); } else { /* just map the file immediately, we're not using a server */ int fd; IVSHMEMDPRINTF(\"using shmopen (shm object = %s)\\n\", s->shmobj); /* try opening with OEXCL and if it succeeds zero the memory * by truncating to 0 */ if ((fd = shmopen(s->shmobj, OCREAT|ORDWR|OEXCL, SIRWXU|SIRWXG|SIRWXO)) > 0) { /* truncate file to length PCI device's memory */ if (ftruncate(fd, s->ivshmemsize) != 0) { errorreport(\"could not truncate shared file\"); } } else if ((fd = shmopen(s->shmobj, OCREAT|ORDWR, SIRWXU|SIRWXG|SIRWXO)) < 0) { errorsetg(errp, \"could not open shared file\"); return; } if (checkshmsize(s, fd, errp) == -1) { return; } createsharedmemoryBAR(s, fd, attr, &err); if (err) { errorpropagate(errp, err); return; } } fifo8create(&s->incomingfifo, sizeof(int64t)); if (s->roleval == IVSHMEMPEER) { errorsetg(&s->migrationblocker, \"Migration is disabled when using feature 'peer mode' in device 'ivshmem'\"); migrateaddblocker(s->migrationblocker); } } ", "target": 1}
{"func": "int printinsnlm32(bfdvma memaddr, struct disassembleinfo *info) { fprintffunction fprintffn = info->fprintffunc; void *stream = info->stream; int rc; uint8t insn[4]; const Lm32OpcodeInfo *opcinfo; uint32t op; const char *argsfmt; rc = info->readmemoryfunc(memaddr, insn, 4, info); if (rc != 0) { info->memoryerrorfunc(rc, memaddr, info); return -1; } fprintffn(stream, \"%02x %02x %02x %02x \", insn[0], insn[1], insn[2], insn[3]); op = bfdgetb32(insn); opcinfo = findopcodeinfo(op); if (opcinfo) { fprintffn(stream, \"%-8s \", opcinfo->name); argsfmt = opcinfo->argsfmt; while (argsfmt && *argsfmt) { if (*argsfmt == '%') { switch (*(++argsfmt)) { case '0': { uint8t r0; const char *r0name; r0 = (op >> 21) & 0x1f; r0name = findreginfo(r0)->name; fprintffn(stream, \"%s\", r0name); break; } case '1': { uint8t r1; const char *r1name; r1 = (op >> 16) & 0x1f; r1name = findreginfo(r1)->name; fprintffn(stream, \"%s\", r1name); break; } case '2': { uint8t r2; const char *r2name; r2 = (op >> 11) & 0x1f; r2name = findreginfo(r2)->name; fprintffn(stream, \"%s\", r2name); break; } case 'c': { uint8t csr; const char *csrname; csr = (op >> 21) & 0x1f; csrname = findcsrinfo(csr)->name; if (csrname) { fprintffn(stream, \"%s\", csrname); } else { fprintffn(stream, \"0x%x\", csr); } break; } case 'u': { uint16t u16; u16 = op & 0xffff; fprintffn(stream, \"0x%x\", u16); break; } case 's': { int16t s16; s16 = (int16t)(op & 0xffff); fprintffn(stream, \"%d\", s16); break; } case 'r': { uint32t rela; rela = memaddr + (((int16t)(op & 0xffff)) << 2); fprintffn(stream, \"%x\", rela); break; } case 'R': { uint32t rela; int32t imm26; imm26 = (int32t)((op & 0x3ffffff) << 6) >> 4; rela = memaddr + imm26; fprintffn(stream, \"%x\", rela); break; } case 'h': { uint8t u5; u5 = (op & 0x1f); fprintffn(stream, \"%d\", u5); break; } default: break; } } else { fprintffn(stream, \"%c\", *argsfmt); } argsfmt++; } } else { fprintffn(stream, \".word 0x%x\", op); } return 4; } ", "target": 1}
{"func": "static int getcoc(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c, uint8t *properties) { int compno; if (s->bufend - s->buf < 2) return AVERROR(EINVAL); compno = bytestreamgetbyte(&s->buf); c += compno; c->csty = bytestreamgetbyte(&s->buf); getcox(s, c); properties[compno] |= HADCOC; return 0; } ", "target": 0}
{"func": "static void cursessetup(void) { int i, colourdefault[8] = { COLORBLACK, COLORBLUE, COLORGREEN, COLORCYAN, COLORRED, COLORMAGENTA, COLORYELLOW, COLORWHITE, }; /* input as raw as possible, let everything be interpreted * by the guest system */ initscr(); noecho(); intrflush(stdscr, FALSE); nodelay(stdscr, TRUE); nonl(); keypad(stdscr, TRUE); startcolor(); raw(); scrollok(stdscr, FALSE); for (i = 0; i < 64; i ++) initpair(i, colourdefault[i & 7], colourdefault[i >> 3]); } ", "target": 1}
{"func": "static inline void RENAME(hyscale)(uint16t *dst, int dstWidth, uint8t *src, int srcW, int xInc) { #ifdef HAVEMMX \t// use the new MMX scaler if th mmx2 cant be used (its faster than the x86asm one) if(swsflags != SWSFASTBILINEAR || (!canMMX2BeUsed)) #else if(swsflags != SWSFASTBILINEAR) #endif { \tRENAME(hScale)(dst, dstWidth, src, srcW, xInc, hLumFilter, hLumFilterPos, hLumFilterSize); } else // Fast Bilinear upscale / crap downscale { #ifdef ARCHX86 #ifdef HAVEMMX2 \tint i; \tif(canMMX2BeUsed) \t{ \t\tasm volatile( \t\t\t\"pxor %%mm7, %%mm7\t\t\\n\\t\" \t\t\t\"pxor %%mm2, %%mm2\t\t\\n\\t\" // 2*xalpha \t\t\t\"movd %5, %%mm6\t\t\t\\n\\t\" // xInc&0xFFFF \t\t\t\"punpcklwd %%mm6, %%mm6\t\t\\n\\t\" \t\t\t\"punpcklwd %%mm6, %%mm6\t\t\\n\\t\" \t\t\t\"movq %%mm6, %%mm2\t\t\\n\\t\" \t\t\t\"psllq $16, %%mm2\t\t\\n\\t\" \t\t\t\"paddw %%mm6, %%mm2\t\t\\n\\t\" \t\t\t\"psllq $16, %%mm2\t\t\\n\\t\" \t\t\t\"paddw %%mm6, %%mm2\t\t\\n\\t\" \t\t\t\"psllq $16, %%mm2\t\t\\n\\t\" //0,t,2t,3t\t\tt=xInc&0xFF \t\t\t\"movq %%mm2, \"MANGLE(temp0)\"\t\\n\\t\" \t\t\t\"movd %4, %%mm6\t\t\t\\n\\t\" //(xInc*4)&0xFFFF \t\t\t\"punpcklwd %%mm6, %%mm6\t\t\\n\\t\" \t\t\t\"punpcklwd %%mm6, %%mm6\t\t\\n\\t\" \t\t\t\"xorl %%eax, %%eax\t\t\\n\\t\" // i \t\t\t\"movl %0, %%esi\t\t\t\\n\\t\" // src \t\t\t\"movl %1, %%edi\t\t\t\\n\\t\" // buf1 \t\t\t\"movl %3, %%edx\t\t\t\\n\\t\" // (xInc*4)>>16 \t\t\t\"xorl %%ecx, %%ecx\t\t\\n\\t\" \t\t\t\"xorl %%ebx, %%ebx\t\t\\n\\t\" \t\t\t\"movw %4, %%bx\t\t\t\\n\\t\" // (xInc*4)&0xFFFF #define FUNNYYCODE \\ \t\t\tPREFETCH\" 1024(%%esi)\t\t\\n\\t\"\\ \t\t\tPREFETCH\" 1056(%%esi)\t\t\\n\\t\"\\ \t\t\tPREFETCH\" 1088(%%esi)\t\t\\n\\t\"\\ \t\t\t\"call \"MANGLE(funnyYCode)\"\t\\n\\t\"\\ \t\t\t\"movq \"MANGLE(temp0)\", %%mm2\t\\n\\t\"\\ \t\t\t\"xorl %%ecx, %%ecx\t\t\\n\\t\" FUNNYYCODE FUNNYYCODE FUNNYYCODE FUNNYYCODE FUNNYYCODE FUNNYYCODE FUNNYYCODE FUNNYYCODE \t\t\t:: \"m\" (src), \"m\" (dst), \"m\" (dstWidth), \"m\" ((xInc*4)>>16), \t\t\t\"m\" ((xInc*4)&0xFFFF), \"m\" (xInc&0xFFFF) \t\t\t: \"%eax\", \"%ebx\", \"%ecx\", \"%edx\", \"%esi\", \"%edi\" \t\t); \t\tfor(i=dstWidth-1; (i*xInc)>>16 >=srcW-1; i--) dst[i] = src[srcW-1]*128; \t} \telse \t{ #endif \t//NO MMX just normal asm ... \tasm volatile( \t\t\"xorl %%eax, %%eax\t\t\\n\\t\" // i \t\t\"xorl %%ebx, %%ebx\t\t\\n\\t\" // xx \t\t\"xorl %%ecx, %%ecx\t\t\\n\\t\" // 2*xalpha \t\t\".balign 16\t\t\t\\n\\t\" \t\t\"1:\t\t\t\t\\n\\t\" \t\t\"movzbl (%0, %%ebx), %%edi\t\\n\\t\" //src[xx] \t\t\"movzbl 1(%0, %%ebx), %%esi\t\\n\\t\" //src[xx+1] \t\t\"subl %%edi, %%esi\t\t\\n\\t\" //src[xx+1] - src[xx] \t\t\"imull %%ecx, %%esi\t\t\\n\\t\" //(src[xx+1] - src[xx])*2*xalpha \t\t\"shll $16, %%edi\t\t\\n\\t\" \t\t\"addl %%edi, %%esi\t\t\\n\\t\" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha) \t\t\"movl %1, %%edi\t\t\t\\n\\t\" \t\t\"shrl $9, %%esi\t\t\t\\n\\t\" \t\t\"movw %%si, (%%edi, %%eax, 2)\t\\n\\t\" \t\t\"addw %4, %%cx\t\t\t\\n\\t\" //2*xalpha += xInc&0xFF \t\t\"adcl %3, %%ebx\t\t\t\\n\\t\" //xx+= xInc>>8 + carry \t\t\"movzbl (%0, %%ebx), %%edi\t\\n\\t\" //src[xx] \t\t\"movzbl 1(%0, %%ebx), %%esi\t\\n\\t\" //src[xx+1] \t\t\"subl %%edi, %%esi\t\t\\n\\t\" //src[xx+1] - src[xx] \t\t\"imull %%ecx, %%esi\t\t\\n\\t\" //(src[xx+1] - src[xx])*2*xalpha \t\t\"shll $16, %%edi\t\t\\n\\t\" \t\t\"addl %%edi, %%esi\t\t\\n\\t\" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha) \t\t\"movl %1, %%edi\t\t\t\\n\\t\" \t\t\"shrl $9, %%esi\t\t\t\\n\\t\" \t\t\"movw %%si, 2(%%edi, %%eax, 2)\t\\n\\t\" \t\t\"addw %4, %%cx\t\t\t\\n\\t\" //2*xalpha += xInc&0xFF \t\t\"adcl %3, %%ebx\t\t\t\\n\\t\" //xx+= xInc>>8 + carry \t\t\"addl $2, %%eax\t\t\t\\n\\t\" \t\t\"cmpl %2, %%eax\t\t\t\\n\\t\" \t\t\" jb 1b\t\t\t\t\\n\\t\" \t\t:: \"r\" (src), \"m\" (dst), \"m\" (dstWidth), \"m\" (xInc>>16), \"m\" (xInc&0xFFFF) \t\t: \"%eax\", \"%ebx\", \"%ecx\", \"%edi\", \"%esi\" \t\t); #ifdef HAVEMMX2 \t} //if MMX2 cant be used #endif #else \tint i; \tunsigned int xpos=0; \tfor(i=0;i<dstWidth;i++) \t{ \t\tregister unsigned int xx=xpos>>16; \t\tregister unsigned int xalpha=(xpos&0xFFFF)>>9; \t\tdst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha; \t\txpos+=xInc; \t} #endif } } ", "target": 1}
{"func": "static int getuint16equal(QEMUFile *f, void *pv, sizet size) { uint16t *v = pv; uint16t v2; qemugetbe16s(f, &v2); if (*v == v2) { return 0; } return -EINVAL; } ", "target": 1}
{"func": "static int h264handlepacket(AVFormatContext *ctx, PayloadContext *data, AVStream *st, AVPacket *pkt, uint32t *timestamp, const uint8t *buf, int len, uint16t seq, int flags) { uint8t nal; uint8t type; int result = 0; if (!len) { avlog(ctx, AVLOGERROR, \"Empty H264 RTP packet\\n\"); return AVERRORINVALIDDATA; } nal = buf[0]; type = nal & 0x1f; assert(data); assert(buf); /* Simplify the case (these are all the nal types used internally by * the h264 codec). */ if (type >= 1 && type <= 23) type = 1; switch (type) { case 0: // undefined, but pass them through case 1: avnewpacket(pkt, len + sizeof(startsequence)); memcpy(pkt->data, startsequence, sizeof(startsequence)); memcpy(pkt->data + sizeof(startsequence), buf, len); COUNTNALTYPE(data, nal); break; case 24: // STAP-A (one packet, multiple nals) // consume the STAP-A NAL buf++; len--; // first we are going to figure out the total size { int pass = 0; int totallength = 0; uint8t *dst = NULL; for (pass = 0; pass < 2; pass++) { const uint8t *src = buf; int srclen = len; while (srclen > 2) { uint16t nalsize = AVRB16(src); // consume the length of the aggregate src += 2; srclen -= 2; if (nalsize <= srclen) { if (pass == 0) { // counting totallength += sizeof(startsequence) + nalsize; } else { // copying assert(dst); memcpy(dst, startsequence, sizeof(startsequence)); dst += sizeof(startsequence); memcpy(dst, src, nalsize); COUNTNALTYPE(data, *src); dst += nalsize; } } else { avlog(ctx, AVLOGERROR, \"nal size exceeds length: %d %d\\n\", nalsize, srclen); } // eat what we handled src += nalsize; srclen -= nalsize; if (srclen < 0) avlog(ctx, AVLOGERROR, \"Consumed more bytes than we got! (%d)\\n\", srclen); } if (pass == 0) { /* now we know the total size of the packet (with the * start sequences added) */ avnewpacket(pkt, totallength); dst = pkt->data; } else { assert(dst - pkt->data == totallength); } } } break; case 25: // STAP-B case 26: // MTAP-16 case 27: // MTAP-24 case 29: // FU-B avlog(ctx, AVLOGERROR, \"Unhandled type (%d) (See RFC for implementation details\\n\", type); result = AVERROR(ENOSYS); break; case 28: // FU-A (fragmented nal) buf++; len--; // skip the fuindicator if (len > 1) { // these are the same as above, we just redo them here for clarity uint8t fuindicator = nal; uint8t fuheader = *buf; uint8t startbit = fuheader >> 7; uint8t avunused endbit = (fuheader & 0x40) >> 6; uint8t naltype = fuheader & 0x1f; uint8t reconstructednal; // Reconstruct this packet's true nal; only the data follows. /* The original nal forbidden bit and NRI are stored in this * packet's nal. */ reconstructednal = fuindicator & 0xe0; reconstructednal |= naltype; // skip the fuheader buf++; len--; if (startbit) COUNTNALTYPE(data, naltype); if (startbit) { /* copy in the start sequence, and the reconstructed nal */ avnewpacket(pkt, sizeof(startsequence) + sizeof(nal) + len); memcpy(pkt->data, startsequence, sizeof(startsequence)); pkt->data[sizeof(startsequence)] = reconstructednal; memcpy(pkt->data + sizeof(startsequence) + sizeof(nal), buf, len); } else { avnewpacket(pkt, len); memcpy(pkt->data, buf, len); } } else { avlog(ctx, AVLOGERROR, \"Too short data for FU-A H264 RTP packet\\n\"); result = AVERRORINVALIDDATA; } break; case 30: // undefined case 31: // undefined default: avlog(ctx, AVLOGERROR, \"Undefined type (%d)\\n\", type); result = AVERRORINVALIDDATA; break; } pkt->streamindex = st->index; return result; } ", "target": 1}
{"func": "void bdrvrefreshfilename(BlockDriverState *bs) { BlockDriver *drv = bs->drv; QDict *opts; if (!drv) { return; } /* This BDS's file name will most probably depend on its file's name, so * refresh that first */ if (bs->file) { bdrvrefreshfilename(bs->file->bs); } if (drv->bdrvrefreshfilename) { /* Obsolete information is of no use here, so drop the old file name * information before refreshing it */ bs->exactfilename[0] = '\\0'; if (bs->fullopenoptions) { QDECREF(bs->fullopenoptions); bs->fullopenoptions = NULL; } drv->bdrvrefreshfilename(bs); } else if (bs->file) { /* Try to reconstruct valid information from the underlying file */ bool hasopenoptions; bs->exactfilename[0] = '\\0'; if (bs->fullopenoptions) { QDECREF(bs->fullopenoptions); bs->fullopenoptions = NULL; } opts = qdictnew(); hasopenoptions = appendopenoptions(opts, bs); /* If no specific options have been given for this BDS, the filename of * the underlying file should suffice for this one as well */ if (bs->file->bs->exactfilename[0] && !hasopenoptions) { strcpy(bs->exactfilename, bs->file->bs->exactfilename); } /* Reconstructing the full options QDict is simple for most format block * drivers, as long as the full options are known for the underlying * file BDS. The full options QDict of that file BDS should somehow * contain a representation of the filename, therefore the following * suffices without querying the (exact)filename of this BDS. */ if (bs->file->bs->fullopenoptions) { qdictputobj(opts, \"driver\", QOBJECT(qstringfromstr(drv->formatname))); QINCREF(bs->file->bs->fullopenoptions); qdictputobj(opts, \"file\", QOBJECT(bs->file->bs->fullopenoptions)); bs->fullopenoptions = opts; } else { QDECREF(opts); } } else if (!bs->fullopenoptions && qdictsize(bs->options)) { /* There is no underlying file BDS (at least referenced by BDS.file), * so the full options QDict should be equal to the options given * specifically for this block device when it was opened (plus the * driver specification). * Because those options don't change, there is no need to update * fullopenoptions when it's already set. */ opts = qdictnew(); appendopenoptions(opts, bs); qdictputobj(opts, \"driver\", QOBJECT(qstringfromstr(drv->formatname))); if (bs->exactfilename[0]) { /* This may not work for all block protocol drivers (some may * require this filename to be parsed), but we have to find some * default solution here, so just include it. If some block driver * does not support pure options without any filename at all or * needs some special format of the options QDict, it needs to * implement the driver-specific bdrvrefreshfilename() function. */ qdictputobj(opts, \"filename\", QOBJECT(qstringfromstr(bs->exactfilename))); } bs->fullopenoptions = opts; } if (bs->exactfilename[0]) { pstrcpy(bs->filename, sizeof(bs->filename), bs->exactfilename); } else if (bs->fullopenoptions) { QString *json = qobjecttojson(QOBJECT(bs->fullopenoptions)); snprintf(bs->filename, sizeof(bs->filename), \"json:%s\", qstringgetstr(json)); QDECREF(json); } } ", "target": 0}
{"func": "static inline bool cpuhandleexception(CPUState *cpu, int *ret) { if (cpu->exceptionindex >= 0) { if (cpu->exceptionindex >= EXCPINTERRUPT) { /* exit request from the cpu execution loop */ *ret = cpu->exceptionindex; if (*ret == EXCPDEBUG) { cpuhandledebugexception(cpu); } cpu->exceptionindex = -1; return true; } else { #if defined(CONFIGUSERONLY) /* if user mode only, we simulate a fake exception which will be handled outside the cpu execution loop */ #if defined(TARGETI386) CPUClass *cc = CPUGETCLASS(cpu); cc->dointerrupt(cpu); #endif *ret = cpu->exceptionindex; cpu->exceptionindex = -1; return true; #else if (replayexception()) { CPUClass *cc = CPUGETCLASS(cpu); qemumutexlockiothread(); cc->dointerrupt(cpu); qemumutexunlockiothread(); cpu->exceptionindex = -1; } else if (!replayhasinterrupt()) { /* give a chance to iothread in replay mode */ *ret = EXCPINTERRUPT; return true; } #endif } #ifndef CONFIGUSERONLY } else if (replayhasexception() && cpu->icountdecr.u16.low + cpu->icountextra == 0) { /* try to cause an exception pending in the log */ cpuexecnocache(cpu, 1, tbfind(cpu, NULL, 0), true); *ret = -1; return true; #endif } return false; } ", "target": 0}
{"func": "void ffdnxhdencinitx86(DNXHDEncContext *ctx) { #if HAVEINLINEASM if (avgetcpuflags() & AVCPUFLAGSSE2) { if (ctx->cidtable->bitdepth == 8) ctx->getpixels8x4sym = getpixels8x4symsse2; } #endif /* HAVEINLINEASM */ } ", "target": 0}
{"func": "uint64t helperfdiv(CPUPPCState *env, uint64t arg1, uint64t arg2) { CPUDoubleU farg1, farg2; farg1.ll = arg1; farg2.ll = arg2; if (unlikely(float64isinfinity(farg1.d) && float64isinfinity(farg2.d))) { /* Division of infinity by infinity */ farg1.ll = floadinvalidopexcp(env, POWERPCEXCPFPVXIDI); } else if (unlikely(float64iszero(farg1.d) && float64iszero(farg2.d))) { /* Division of zero by zero */ farg1.ll = floadinvalidopexcp(env, POWERPCEXCPFPVXZDZ); } else { if (unlikely(float64issignalingnan(farg1.d) || float64issignalingnan(farg2.d))) { /* sNaN division */ floadinvalidopexcp(env, POWERPCEXCPFPVXSNAN); } farg1.d = float64div(farg1.d, farg2.d, &env->fpstatus); } return farg1.ll; } ", "target": 0}
{"func": "static void testiochannelipv4(bool async) { SocketAddress *listenaddr = gnew0(SocketAddress, 1); SocketAddress *connectaddr = gnew0(SocketAddress, 1); listenaddr->type = SOCKETADDRESSKINDINET; listenaddr->u.inet = gnew0(InetSocketAddress, 1); listenaddr->u.inet->host = gstrdup(\"0.0.0.0\"); listenaddr->u.inet->port = NULL; /* Auto-select */ connectaddr->type = SOCKETADDRESSKINDINET; connectaddr->u.inet = gnew0(InetSocketAddress, 1); connectaddr->u.inet->host = gstrdup(\"127.0.0.1\"); connectaddr->u.inet->port = NULL; /* Filled in later */ testiochannel(async, listenaddr, connectaddr); qapifreeSocketAddress(listenaddr); qapifreeSocketAddress(connectaddr); } ", "target": 0}
{"func": "static void genloongsonmultimedia(DisasContext *ctx, int rd, int rs, int rt) { const char *opn = \"loongsoncp2\"; uint32t opc, shiftmax; TCGvi64 t0, t1; opc = MASKLMI(ctx->opcode); switch (opc) { case OPCADDCP2: case OPCSUBCP2: case OPCDADDCP2: case OPCDSUBCP2: t0 = tcgtemplocalnewi64(); t1 = tcgtemplocalnewi64(); break; default: t0 = tcgtempnewi64(); t1 = tcgtempnewi64(); break; } genloadfpr64(ctx, t0, rs); genloadfpr64(ctx, t1, rt); #define LMIHELPER(UP, LO) \\ case OPC##UP: genhelper##LO(t0, t0, t1); opn = #LO; break #define LMIHELPER1(UP, LO) \\ case OPC##UP: genhelper##LO(t0, t0); opn = #LO; break #define LMIDIRECT(UP, LO, OP) \\ case OPC##UP: tcggen##OP##i64(t0, t0, t1); opn = #LO; break switch (opc) { LMIHELPER(PADDSH, paddsh); LMIHELPER(PADDUSH, paddush); LMIHELPER(PADDH, paddh); LMIHELPER(PADDW, paddw); LMIHELPER(PADDSB, paddsb); LMIHELPER(PADDUSB, paddusb); LMIHELPER(PADDB, paddb); LMIHELPER(PSUBSH, psubsh); LMIHELPER(PSUBUSH, psubush); LMIHELPER(PSUBH, psubh); LMIHELPER(PSUBW, psubw); LMIHELPER(PSUBSB, psubsb); LMIHELPER(PSUBUSB, psubusb); LMIHELPER(PSUBB, psubb); LMIHELPER(PSHUFH, pshufh); LMIHELPER(PACKSSWH, packsswh); LMIHELPER(PACKSSHB, packsshb); LMIHELPER(PACKUSHB, packushb); LMIHELPER(PUNPCKLHW, punpcklhw); LMIHELPER(PUNPCKHHW, punpckhhw); LMIHELPER(PUNPCKLBH, punpcklbh); LMIHELPER(PUNPCKHBH, punpckhbh); LMIHELPER(PUNPCKLWD, punpcklwd); LMIHELPER(PUNPCKHWD, punpckhwd); LMIHELPER(PAVGH, pavgh); LMIHELPER(PAVGB, pavgb); LMIHELPER(PMAXSH, pmaxsh); LMIHELPER(PMINSH, pminsh); LMIHELPER(PMAXUB, pmaxub); LMIHELPER(PMINUB, pminub); LMIHELPER(PCMPEQW, pcmpeqw); LMIHELPER(PCMPGTW, pcmpgtw); LMIHELPER(PCMPEQH, pcmpeqh); LMIHELPER(PCMPGTH, pcmpgth); LMIHELPER(PCMPEQB, pcmpeqb); LMIHELPER(PCMPGTB, pcmpgtb); LMIHELPER(PSLLW, psllw); LMIHELPER(PSLLH, psllh); LMIHELPER(PSRLW, psrlw); LMIHELPER(PSRLH, psrlh); LMIHELPER(PSRAW, psraw); LMIHELPER(PSRAH, psrah); LMIHELPER(PMULLH, pmullh); LMIHELPER(PMULHH, pmulhh); LMIHELPER(PMULHUH, pmulhuh); LMIHELPER(PMADDHW, pmaddhw); LMIHELPER(PASUBUB, pasubub); LMIHELPER1(BIADD, biadd); LMIHELPER1(PMOVMSKB, pmovmskb); LMIDIRECT(PADDD, paddd, add); LMIDIRECT(PSUBD, psubd, sub); LMIDIRECT(XORCP2, xor, xor); LMIDIRECT(NORCP2, nor, nor); LMIDIRECT(ANDCP2, and, and); LMIDIRECT(PANDN, pandn, andc); LMIDIRECT(OR, or, or); case OPCPINSRH0: tcggendepositi64(t0, t0, t1, 0, 16); opn = \"pinsrh0\"; break; case OPCPINSRH1: tcggendepositi64(t0, t0, t1, 16, 16); opn = \"pinsrh1\"; break; case OPCPINSRH2: tcggendepositi64(t0, t0, t1, 32, 16); opn = \"pinsrh2\"; break; case OPCPINSRH3: tcggendepositi64(t0, t0, t1, 48, 16); opn = \"pinsrh3\"; break; case OPCPEXTRH: tcggenandii64(t1, t1, 3); tcggenshlii64(t1, t1, 4); tcggenshri64(t0, t0, t1); tcggenext16ui64(t0, t0); opn = \"pextrh\"; break; case OPCADDUCP2: tcggenaddi64(t0, t0, t1); tcggenext32si64(t0, t0); opn = \"addu\"; break; case OPCSUBUCP2: tcggensubi64(t0, t0, t1); tcggenext32si64(t0, t0); opn = \"addu\"; break; case OPCSLLCP2: opn = \"sll\"; shiftmax = 32; goto doshift; case OPCSRLCP2: opn = \"srl\"; shiftmax = 32; goto doshift; case OPCSRACP2: opn = \"sra\"; shiftmax = 32; goto doshift; case OPCDSLLCP2: opn = \"dsll\"; shiftmax = 64; goto doshift; case OPCDSRLCP2: opn = \"dsrl\"; shiftmax = 64; goto doshift; case OPCDSRACP2: opn = \"dsra\"; shiftmax = 64; goto doshift; doshift: /* Make sure shift count isn't TCG undefined behaviour. */ tcggenandii64(t1, t1, shiftmax - 1); switch (opc) { case OPCSLLCP2: case OPCDSLLCP2: tcggenshli64(t0, t0, t1); break; case OPCSRACP2: case OPCDSRACP2: /* Since SRA is UndefinedResult without sign-extended inputs, we can treat SRA and DSRA the same. */ tcggensari64(t0, t0, t1); break; case OPCSRLCP2: /* We want to shift in zeros for SRL; zero-extend first. */ tcggenext32ui64(t0, t0); /* FALLTHRU */ case OPCDSRLCP2: tcggenshri64(t0, t0, t1); break; } if (shiftmax == 32) { tcggenext32si64(t0, t0); } /* Shifts larger than MAX produce zero. */ tcggensetcondii64(TCGCONDLTU, t1, t1, shiftmax); tcggennegi64(t1, t1); tcggenandi64(t0, t0, t1); break; case OPCADDCP2: case OPCDADDCP2: { TCGvi64 t2 = tcgtempnewi64(); int lab = gennewlabel(); tcggenmovi64(t2, t0); tcggenaddi64(t0, t1, t2); if (opc == OPCADDCP2) { tcggenext32si64(t0, t0); } tcggenxori64(t1, t1, t2); tcggenxori64(t2, t2, t0); tcggenandci64(t1, t2, t1); tcgtempfreei64(t2); tcggenbrcondii64(TCGCONDGE, t1, 0, lab); generateexception(ctx, EXCPOVERFLOW); gensetlabel(lab); opn = (opc == OPCADDCP2 ? \"add\" : \"dadd\"); break; } case OPCSUBCP2: case OPCDSUBCP2: { TCGvi64 t2 = tcgtempnewi64(); int lab = gennewlabel(); tcggenmovi64(t2, t0); tcggensubi64(t0, t1, t2); if (opc == OPCSUBCP2) { tcggenext32si64(t0, t0); } tcggenxori64(t1, t1, t2); tcggenxori64(t2, t2, t0); tcggenandi64(t1, t1, t2); tcgtempfreei64(t2); tcggenbrcondii64(TCGCONDGE, t1, 0, lab); generateexception(ctx, EXCPOVERFLOW); gensetlabel(lab); opn = (opc == OPCSUBCP2 ? \"sub\" : \"dsub\"); break; } case OPCPMULUW: tcggenext32ui64(t0, t0); tcggenext32ui64(t1, t1); tcggenmuli64(t0, t0, t1); opn = \"pmuluw\"; break; case OPCSEQUCP2: case OPCSEQCP2: case OPCSLTUCP2: case OPCSLTCP2: case OPCSLEUCP2: case OPCSLECP2: /* ??? Document is unclear: Set FCC[CC]. Does that mean the FD field is the CC field? */ default: MIPSINVAL(opn); generateexception(ctx, EXCPRI); return; } #undef LMIHELPER #undef LMIDIRECT genstorefpr64(ctx, t0, rd); (void)opn; /* avoid a compiler warning */ MIPSDEBUG(\"%s %s, %s, %s\", opn, fregnames[rd], fregnames[rs], fregnames[rt]); tcgtempfreei64(t0); tcgtempfreei64(t1); } ", "target": 0}
{"func": "static void v9fsstat(void *opaque) { int32t fid; V9fsStat v9stat; ssizet err = 0; sizet offset = 7; struct stat stbuf; V9fsFidState *fidp; V9fsPDU *pdu = opaque; V9fsState *s = pdu->s; pduunmarshal(pdu, offset, \"d\", &fid); tracev9fsstat(pdu->tag, pdu->id, fid); fidp = getfid(pdu, fid); if (fidp == NULL) { err = -ENOENT; goto outnofid; } err = v9fscolstat(pdu, &fidp->path, &stbuf); if (err < 0) { goto out; } err = stattov9stat(pdu, &fidp->path, &stbuf, &v9stat); if (err < 0) { goto out; } offset += pdumarshal(pdu, offset, \"wS\", 0, &v9stat); err = offset; tracev9fsstatreturn(pdu->tag, pdu->id, v9stat.mode, v9stat.atime, v9stat.mtime, v9stat.length); v9fsstatfree(&v9stat); out: putfid(pdu, fidp); outnofid: completepdu(s, pdu, err); } ", "target": 0}
{"func": "uint64t helperaddlv (uint64t op1, uint64t op2) { uint64t tmp = op1; op1 = (uint32t)(op1 + op2); if (unlikely((tmp ^ op2 ^ (-1UL)) & (tmp ^ op1) & (1UL << 31))) { arithexcp(env, GETPC(), EXCMIOV, 0); } return op1; } ", "target": 1}
{"func": "static int ofdpacmdaddl2flood(OfDpa *ofdpa, OfDpaGroup *group, RockerTlv **grouptlvs) { OfDpaGroup *l2group; RockerTlv **tlvs; int err; int i; if (!grouptlvs[ROCKERTLVOFDPAGROUPCOUNT] || !grouptlvs[ROCKERTLVOFDPAGROUPIDS]) { return -ROCKEREINVAL; } group->l2flood.groupcount = rockertlvgetle16(grouptlvs[ROCKERTLVOFDPAGROUPCOUNT]); tlvs = gmalloc0((group->l2flood.groupcount + 1) * sizeof(RockerTlv *)); if (!tlvs) { return -ROCKERENOMEM; } gfree(group->l2flood.groupids); group->l2flood.groupids = gmalloc0(group->l2flood.groupcount * sizeof(uint32t)); if (!group->l2flood.groupids) { err = -ROCKERENOMEM; goto errout; } rockertlvparsenested(tlvs, group->l2flood.groupcount, grouptlvs[ROCKERTLVOFDPAGROUPIDS]); for (i = 0; i < group->l2flood.groupcount; i++) { group->l2flood.groupids[i] = rockertlvgetle32(tlvs[i + 1]); } /* All of the L2 interface groups referenced by the L2 flood * must have same VLAN */ for (i = 0; i < group->l2flood.groupcount; i++) { l2group = ofdpagroupfind(ofdpa, group->l2flood.groupids[i]); if (!l2group) { continue; } if ((ROCKERGROUPTYPEGET(l2group->id) == ROCKEROFDPAGROUPTYPEL2INTERFACE) && (ROCKERGROUPVLANGET(l2group->id) != ROCKERGROUPVLANGET(group->id))) { DPRINTF(\"l2 interface group 0x%08x VLAN doesn't match l2 \" \"flood group 0x%08x\\n\", group->l2flood.groupids[i], group->id); err = -ROCKEREINVAL; goto errout; } } gfree(tlvs); return ROCKEROK; errout: group->l2flood.groupcount = 0; gfree(group->l2flood.groupids); gfree(tlvs); return err; } ", "target": 1}
{"func": "int LLVMFuzzerTestOneInput(const uint8t *data, sizet size) { const uint64t fuzztag = FUZZTAG; FuzzDataBuffer buffer; const uint8t *last = data; const uint8t *end = data + size; uint32t it = 0; if (!c) c = AVCodecInitialize(FFMPEGCODEC); // Done once. AVCodecContext* ctx = avcodecalloccontext3(NULL); if (!ctx) error(\"Failed memory allocation\"); ctx->maxpixels = 4096 * 4096; //To reduce false positive OOM and hangs int res = avcodecopen2(ctx, c, NULL); if (res < 0) return res; FDBCreate(&buffer); int gotframe; AVFrame *frame = avframealloc(); if (!frame) error(\"Failed memory allocation\"); // Read very simple container AVPacket avpkt; while (data < end && it < maxiteration) { // Search for the TAG while (data + sizeof(fuzztag) < end) { if (data[0] == (fuzztag & 0xFF) && *(const uint64t *)(data) == fuzztag) break; data++; } if (data + sizeof(fuzztag) > end) data = end; FDBPrepare(&buffer, &avpkt, last, data - last); data += sizeof(fuzztag); last = data; // Iterate through all data while (avpkt.size > 0 && it++ < maxiteration) { avframeunref(frame); int ret = decodehandler(ctx, frame, &gotframe, &avpkt); if (it > 20) ctx->errorconcealment = 0; if (ret <= 0 || ret > avpkt.size) break; avpkt.data += ret; avpkt.size -= ret; } } avinitpacket(&avpkt); avpkt.data = NULL; avpkt.size = 0; do { gotframe = 0; decodehandler(ctx, frame, &gotframe, &avpkt); } while (gotframe == 1 && it++ < maxiteration); avframefree(&frame); avcodecfreecontext(&ctx); avfreep(&ctx); FDBDesroy(&buffer); return 0; }", "target": 1}
{"func": "void opcp164bitmode(void) { if (!(env->CP0Status & (1 << CP0StFR))) { CALLFROMTB1(doraiseexception, EXCPRI); } RETURN(); } ", "target": 0}
{"func": "void disasa64insn(CPUARMState *env, DisasContext *s) { uint32t insn; insn = armldlcode(env, s->pc, s->bswapcode); s->insn = insn; s->pc += 4; switch ((insn >> 24) & 0x1f) { default: unallocatedencoding(s); break; } if (unlikely(s->singlestepenabled) && (s->isjmp == DISASTBJUMP)) { /* go through the main loop for single step */ s->isjmp = DISASJUMP; } } ", "target": 0}
{"func": "static inline void genopmovvreg(int ot, TCGv t0, int reg) { switch(ot) { case OTBYTE: if (reg < 4 X8664DEF( || reg >= 8 || x8664hregs)) { goto stdcase; } else { tcggenshritl(t0, cpuregs[reg - 4], 8); tcggenext8utl(t0, t0); } break; default: stdcase: tcggenmovtl(t0, cpuregs[reg]); break; } } ", "target": 0}
{"func": "static int hdevopen(BlockDriverState *bs, const char *filename, int flags) { BDRVRawState *s = bs->opaque; int accessflags, createflags; DWORD overlapped; char devicename[64]; if (strstart(filename, \"/dev/cdrom\", NULL)) { if (findcdrom(devicename, sizeof(devicename)) < 0) return -ENOENT; filename = devicename; } else { /* transform drive letters into device name */ if (((filename[0] >= 'a' && filename[0] <= 'z') || (filename[0] >= 'A' && filename[0] <= 'Z')) && filename[1] == ':' && filename[2] == '\\0') { snprintf(devicename, sizeof(devicename), \"\\\\\\\\.\\\\%c:\", filename[0]); filename = devicename; } } s->type = finddevicetype(bs, filename); if ((flags & BDRVOACCESS) == ORDWR) { accessflags = GENERICREAD | GENERICWRITE; } else { accessflags = GENERICREAD; } createflags = OPENEXISTING; #ifdef QEMUTOOL overlapped = FILEATTRIBUTENORMAL; #else overlapped = FILEFLAGOVERLAPPED; #endif s->hfile = CreateFile(filename, accessflags, FILESHAREREAD, NULL, createflags, overlapped, NULL); if (s->hfile == INVALIDHANDLEVALUE) return -1; return 0; } ", "target": 0}
{"func": "static void sigpstoreadtlstatus(CPUState *cs, runoncpudata arg) { S390CPU *cpu = S390CPU(cs); SigpInfo *si = arg.hostptr; if (!s390hasfeat(S390FEATVECTOR)) { setsigpstatus(si, SIGPSTATINVALIDORDER); return; } /* cpu has to be stopped */ if (s390cpugetstate(cpu) != CPUSTATESTOPPED) { setsigpstatus(si, SIGPSTATINCORRECTSTATE); return; } /* parameter must be aligned to 1024-byte boundary */ if (si->param & 0x3ff) { setsigpstatus(si, SIGPSTATINVALIDPARAMETER); return; } cpusynchronizestate(cs); if (kvms390storeadtlstatus(cpu, si->param)) { setsigpstatus(si, SIGPSTATINVALIDPARAMETER); return; } si->cc = SIGPCCORDERCODEACCEPTED; } ", "target": 0}
{"func": "static int cpugdbwriteregister(CPUState *env, uint8t *membuf, int n) { targetulong tmp; tmp = ldtulp(membuf); if (n < 32) { env->activetc.gpr[n] = tmp; return sizeof(targetulong); } if (env->CP0Config1 & (1 << CP0C1FP) && n >= 38 && n < 73) { if (n < 70) { if (env->CP0Status & (1 << CP0StFR)) env->activefpu.fpr[n - 38].d = tmp; else env->activefpu.fpr[n - 38].w[FPENDIANIDX] = tmp; } switch (n) { case 70: env->activefpu.fcr31 = tmp & 0xFF83FFFF; /* set rounding mode */ RESTOREROUNDINGMODE; #ifndef CONFIGSOFTFLOAT /* no floating point exception for native float */ SETFPENABLE(env->activefpu.fcr31, 0); #endif break; case 71: env->activefpu.fcr0 = tmp; break; } return sizeof(targetulong); } switch (n) { case 32: env->CP0Status = tmp; break; case 33: env->activetc.LO[0] = tmp; break; case 34: env->activetc.HI[0] = tmp; break; case 35: env->CP0BadVAddr = tmp; break; case 36: env->CP0Cause = tmp; break; case 37: env->activetc.PC = tmp; break; case 72: /* fp, ignored */ break; default: \tif (n > 89) \t return 0; \t/* Other registers are readonly. Ignore writes. */ \tbreak; } return sizeof(targetulong); } ", "target": 0}
{"func": "QEMUBH *aiobhnew(AioContext *ctx, QEMUBHFunc *cb, void *opaque) { QEMUBH *bh; bh = gmalloc0(sizeof(QEMUBH)); bh->ctx = ctx; bh->cb = cb; bh->opaque = opaque; qemumutexlock(&ctx->bhlock); bh->next = ctx->firstbh; /* Make sure that the members are ready before putting bh into list */ smpwmb(); ctx->firstbh = bh; qemumutexunlock(&ctx->bhlock); return bh; } ", "target": 0}
{"func": "static void audiogen(void *data, enum AVSampleFormat samplefmt, int channels, int samplerate, int nbsamples) { int i, ch, k; double v, f, a, ampa; double tabf1[SWRCHMAX]; double tabf2[SWRCHMAX]; double taba[SWRCHMAX]; unsigned static rnd; #define PUTSAMPLE set(data, ch, k, channels, samplefmt, v); #define uintrand(x) (x = x * 1664525 + 1013904223) #define dblrand(x) (uintrand(x)*2.0 / (double)UINTMAX - 1) k = 0; /* 1 second of single freq sinus at 1000 Hz */ a = 0; for (i = 0; i < 1 * samplerate && k < nbsamples; i++, k++) { v = sin(a) * 0.30; for (ch = 0; ch < channels; ch++) PUTSAMPLE a += MPI * 1000.0 * 2.0 / samplerate; } /* 1 second of varying frequency between 100 and 10000 Hz */ a = 0; for (i = 0; i < 1 * samplerate && k < nbsamples; i++, k++) { v = sin(a) * 0.30; for (ch = 0; ch < channels; ch++) PUTSAMPLE f = 100.0 + (((10000.0 - 100.0) * i) / samplerate); a += MPI * f * 2.0 / samplerate; } /* 0.5 second of low amplitude white noise */ for (i = 0; i < samplerate / 2 && k < nbsamples; i++, k++) { v = dblrand(rnd) * 0.30; for (ch = 0; ch < channels; ch++) PUTSAMPLE } /* 0.5 second of high amplitude white noise */ for (i = 0; i < samplerate / 2 && k < nbsamples; i++, k++) { v = dblrand(rnd); for (ch = 0; ch < channels; ch++) PUTSAMPLE } /* 1 second of unrelated ramps for each channel */ for (ch = 0; ch < channels; ch++) { taba[ch] = 0; tabf1[ch] = 100 + uintrand(rnd) % 5000; tabf2[ch] = 100 + uintrand(rnd) % 5000; } for (i = 0; i < 1 * samplerate && k < nbsamples; i++, k++) { for (ch = 0; ch < channels; ch++) { v = sin(taba[ch]) * 0.30; PUTSAMPLE f = tabf1[ch] + (((tabf2[ch] - tabf1[ch]) * i) / samplerate); taba[ch] += MPI * f * 2.0 / samplerate; } } /* 2 seconds of 500 Hz with varying volume */ a = 0; ampa = 0; for (i = 0; i < 2 * samplerate && k < nbsamples; i++, k++) { for (ch = 0; ch < channels; ch++) { double amp = (1.0 + sin(ampa)) * 0.15; if (ch & 1) amp = 0.30 - amp; v = sin(a) * amp; PUTSAMPLE a += MPI * 500.0 * 2.0 / samplerate; ampa += MPI * 2.0 / samplerate; } } } ", "target": 0}
{"func": "static void paintmousepointer(AVFormatContext *s1, struct gdigrab *gdigrab) { CURSORINFO ci = {0}; #define CURSORERROR(str) \\ if (!gdigrab->cursorerrorprinted) { \\ WIN32APIERROR(str); \\ gdigrab->cursorerrorprinted = 1; \\ } ci.cbSize = sizeof(ci); if (GetCursorInfo(&ci)) { HCURSOR icon = CopyCursor(ci.hCursor); ICONINFO info; POINT pos; RECT cliprect = gdigrab->cliprect; HWND hwnd = gdigrab->hwnd; info.hbmMask = NULL; info.hbmColor = NULL; if (ci.flags != CURSORSHOWING) return; if (!icon) { /* Use the standard arrow cursor as a fallback. * You'll probably only hit this in Wine, which can't fetch * the current system cursor. */ icon = CopyCursor(LoadCursor(NULL, IDCARROW)); } if (!GetIconInfo(icon, &info)) { CURSORERROR(\"Could not get icon info\"); goto iconerror; } pos.x = ci.ptScreenPos.x - cliprect.left - info.xHotspot; pos.y = ci.ptScreenPos.y - cliprect.top - info.yHotspot; if (hwnd) { RECT rect; if (GetWindowRect(hwnd, &rect)) { pos.x -= rect.left; pos.y -= rect.top; } else { CURSORERROR(\"Couldn't get window rectangle\"); goto iconerror; } } avlog(s1, AVLOGDEBUG, \"Cursor pos (%li,%li) -> (%li,%li)\\n\", ci.ptScreenPos.x, ci.ptScreenPos.y, pos.x, pos.y); if (pos.x >= 0 && pos.x <= cliprect.right - cliprect.left && pos.y >= 0 && pos.y <= cliprect.bottom - cliprect.top) { if (!DrawIcon(gdigrab->desthdc, pos.x, pos.y, icon)) CURSORERROR(\"Couldn't draw icon\"); } iconerror: if (icon) DestroyCursor(icon); } else { CURSORERROR(\"Couldn't get cursor info\"); } }", "target": 1}
{"func": "static void machineinitfn(Object *obj) { MachineState *ms = MACHINE(obj); ms->kernelirqchipallowed = true; ms->kvmshadowmem = -1; ms->dumpguestcore = true; objectpropertyaddstr(obj, \"accel\", machinegetaccel, machinesetaccel, NULL); objectpropertysetdescription(obj, \"accel\", \"Accelerator list\", NULL); objectpropertyaddbool(obj, \"kernel-irqchip\", NULL, machinesetkernelirqchip, NULL); objectpropertysetdescription(obj, \"kernel-irqchip\", \"Use KVM in-kernel irqchip\", NULL); objectpropertyadd(obj, \"kvm-shadow-mem\", \"int\", machinegetkvmshadowmem, machinesetkvmshadowmem, NULL, NULL, NULL); objectpropertysetdescription(obj, \"kvm-shadow-mem\", \"KVM shadow MMU size\", NULL); objectpropertyaddstr(obj, \"kernel\", machinegetkernel, machinesetkernel, NULL); objectpropertysetdescription(obj, \"kernel\", \"Linux kernel image file\", NULL); objectpropertyaddstr(obj, \"initrd\", machinegetinitrd, machinesetinitrd, NULL); objectpropertysetdescription(obj, \"initrd\", \"Linux initial ramdisk file\", NULL); objectpropertyaddstr(obj, \"append\", machinegetappend, machinesetappend, NULL); objectpropertysetdescription(obj, \"append\", \"Linux kernel command line\", NULL); objectpropertyaddstr(obj, \"dtb\", machinegetdtb, machinesetdtb, NULL); objectpropertysetdescription(obj, \"dtb\", \"Linux kernel device tree file\", NULL); objectpropertyaddstr(obj, \"dumpdtb\", machinegetdumpdtb, machinesetdumpdtb, NULL); objectpropertysetdescription(obj, \"dumpdtb\", \"Dump current dtb to a file and quit\", NULL); objectpropertyadd(obj, \"phandle-start\", \"int\", machinegetphandlestart, machinesetphandlestart, NULL, NULL, NULL); objectpropertysetdescription(obj, \"phandle-start\", \"The first phandle ID we may generate dynamically\", NULL); objectpropertyaddstr(obj, \"dt-compatible\", machinegetdtcompatible, machinesetdtcompatible, NULL); objectpropertysetdescription(obj, \"dt-compatible\", \"Overrides the \\\"compatible\\\" property of the dt root node\", NULL); objectpropertyaddbool(obj, \"dump-guest-core\", machinegetdumpguestcore, machinesetdumpguestcore, NULL); objectpropertysetdescription(obj, \"dump-guest-core\", \"Include guest memory in a core dump\", NULL); objectpropertyaddbool(obj, \"mem-merge\", machinegetmemmerge, machinesetmemmerge, NULL); objectpropertysetdescription(obj, \"mem-merge\", \"Enable/disable memory merge support\", NULL); objectpropertyaddbool(obj, \"usb\", machinegetusb, machinesetusb, NULL); objectpropertysetdescription(obj, \"usb\", \"Set on/off to enable/disable usb\", NULL); objectpropertyaddstr(obj, \"firmware\", machinegetfirmware, machinesetfirmware, NULL); objectpropertysetdescription(obj, \"firmware\", \"Firmware image\", NULL); objectpropertyaddbool(obj, \"iommu\", machinegetiommu, machinesetiommu, NULL); objectpropertysetdescription(obj, \"iommu\", \"Set on/off to enable/disable Intel IOMMU (VT-d)\", NULL); /* Register notifier when init is done for sysbus sanity checks */ ms->sysbusnotifier.notify = machineinitnotify; qemuaddmachineinitdonenotifier(&ms->sysbusnotifier); }", "target": 1}
{"func": "void bdrvdelete(BlockDriverState *bs) { assert(!bs->peer); /* remove from list, if necessary */ if (bs->devicename[0] != '\\0') { QTAILQREMOVE(&bdrvstates, bs, list); } bdrvclose(bs); if (bs->file != NULL) { bdrvdelete(bs->file); } assert(bs != bssnapshots); qemufree(bs); } ", "target": 1}
{"func": "static void hmpmigratestatuscb(void *opaque) { MigrationStatus *status = opaque; MigrationInfo *info; info = qmpquerymigrate(NULL); if (!info->hasstatus || strcmp(info->status, \"active\") == 0) { if (info->hasdisk) { int progress; if (info->disk->remaining) { progress = info->disk->transferred * 100 / info->disk->total; } else { progress = 100; } monitorprintf(status->mon, \"Completed %d %%\\r\", progress); monitorflush(status->mon); } timermod(status->timer, qemuclockgetms(QEMUCLOCKREALTIME) + 1000); } else { if (status->isblockmigration) { monitorprintf(status->mon, \"\\n\"); } monitorresume(status->mon); timerdel(status->timer); gfree(status); } qapifreeMigrationInfo(info); } ", "target": 1}
{"func": "int kvmarchonsigbus(int code, void *addr) { #ifdef KVMCAPMCE if ((firstcpu->mcgcap & MCGSERP) && addr && code == BUSMCEERRAO) { void *vaddr; ramaddrt ramaddr; targetphysaddrt paddr; /* Hope we are lucky for AO MCE */ vaddr = addr; if (qemuramaddrfromhost(vaddr, &ramaddr) || !kvmphysicalmemoryaddrfromram(firstcpu->kvmstate, ramaddr, &paddr)) { fprintf(stderr, \"Hardware memory error for memory used by \" \"QEMU itself instead of guest system!: %p\\n\", addr); return 0; } kvmmceinjsraomemscrub2(firstcpu, paddr); } else #endif /* KVMCAPMCE */ { if (code == BUSMCEERRAO) { return 0; } else if (code == BUSMCEERRAR) { hardwarememoryerror(); } else { return 1; } } return 0; } ", "target": 0}
{"func": "coroutinefn iscsicopdiscard(BlockDriverState *bs, int64t offset, int bytes) { IscsiLun *iscsilun = bs->opaque; struct IscsiTask iTask; struct unmaplist list; int r = 0; if (!isbyterequestlunaligned(offset, bytes, iscsilun)) { return -ENOTSUP; } if (!iscsilun->lbp.lbpu) { /* UNMAP is not supported by the target */ return 0; } list.lba = offset / iscsilun->blocksize; list.num = bytes / iscsilun->blocksize; iscsicoinitiscsitask(iscsilun, &iTask); qemumutexlock(&iscsilun->mutex); retry: if (iscsiunmaptask(iscsilun->iscsi, iscsilun->lun, 0, 0, &list, 1, iscsicogenericcb, &iTask) == NULL) { r = -ENOMEM; goto outunlock; } while (!iTask.complete) { iscsisetevents(iscsilun); qemumutexunlock(&iscsilun->mutex); qemucoroutineyield(); qemumutexlock(&iscsilun->mutex); } if (iTask.task != NULL) { scsifreescsitask(iTask.task); iTask.task = NULL; } if (iTask.doretry) { iTask.complete = 0; goto retry; } if (iTask.status == SCSISTATUSCHECKCONDITION) { /* the target might fail with a check condition if it is not happy with the alignment of the UNMAP request we silently fail in this case */ goto outunlock; } if (iTask.status != SCSISTATUSGOOD) { r = iTask.errcode; goto outunlock; } iscsiallocmapsetinvalid(iscsilun, offset >> BDRVSECTORBITS, bytes >> BDRVSECTORBITS); outunlock: qemumutexunlock(&iscsilun->mutex); return r; } ", "target": 1}
{"func": "int mipscpuhandlemmufault(CPUState *cs, vaddr address, int rw, int mmuidx) { MIPSCPU *cpu = MIPSCPU(cs); CPUMIPSState *env = &cpu->env; #if !defined(CONFIGUSERONLY) hwaddr physical; int prot; int accesstype; #endif int ret = 0; #if 0 logcpustate(cs, 0); #endif qemulogmask(CPULOGMMU, \"%s pc \" TARGETFMTlx \" ad %\" VADDRPRIx \" rw %d mmuidx %d\\n\", func, env->activetc.PC, address, rw, mmuidx); /* data access */ #if !defined(CONFIGUSERONLY) /* XXX: put correct access by using cpurestorestate() correctly */ accesstype = ACCESSINT; ret = getphysicaladdress(env, &physical, &prot, address, rw, accesstype); qemulogmask(CPULOGMMU, \"%s address=%\" VADDRPRIx \" ret %d physical \" TARGETFMTplx \" prot %d\\n\", func, address, ret, physical, prot); if (ret == TLBRETMATCH) { tlbsetpage(cs, address & TARGETPAGEMASK, physical & TARGETPAGEMASK, prot | PAGEEXEC, mmuidx, TARGETPAGESIZE); ret = 0; } else if (ret < 0) #endif { raisemmuexception(env, address, rw, ret); ret = 1; } return ret; } ", "target": 1}
{"func": "static ModuleTypeList *findtype(moduleinittype type) { ModuleTypeList *l; inittypes(); l = &inittypelist[type]; return l; } ", "target": 0}
{"func": "static int qemususpendrequested(void) { int r = suspendrequested; suspendrequested = 0; return r; } ", "target": 0}
{"func": "int optcpuflags(const char *opt, const char *arg) { #define CPUFLAGMMX2 (AVCPUFLAGMMX | AVCPUFLAGMMX2) #define CPUFLAG3DNOW (AVCPUFLAG3DNOW | AVCPUFLAGMMX) #define CPUFLAG3DNOWEXT (AVCPUFLAG3DNOWEXT | CPUFLAG3DNOW) #define CPUFLAGSSE (AVCPUFLAGSSE | CPUFLAGMMX2) #define CPUFLAGSSE2 (AVCPUFLAGSSE2 | CPUFLAGSSE) #define CPUFLAGSSE2SLOW (AVCPUFLAGSSE2SLOW | CPUFLAGSSE2) #define CPUFLAGSSE3 (AVCPUFLAGSSE3 | CPUFLAGSSE2) #define CPUFLAGSSE3SLOW (AVCPUFLAGSSE3SLOW | CPUFLAGSSE3) #define CPUFLAGSSSE3 (AVCPUFLAGSSSE3 | CPUFLAGSSE3) #define CPUFLAGSSE4 (AVCPUFLAGSSE4 | CPUFLAGSSSE3) #define CPUFLAGSSE42 (AVCPUFLAGSSE42 | CPUFLAGSSE4) #define CPUFLAGAVX (AVCPUFLAGAVX | CPUFLAGSSE42) #define CPUFLAGXOP (AVCPUFLAGXOP | CPUFLAGAVX) #define CPUFLAGFMA4 (AVCPUFLAGFMA4 | CPUFLAGAVX) static const AVOption cpuflagsopts[] = { { \"flags\" , NULL, 0, AVOPTTYPEFLAGS, { 0 }, INT64MIN, INT64MAX, .unit = \"flags\" }, { \"altivec\" , NULL, 0, AVOPTTYPECONST, { AVCPUFLAGALTIVEC }, .unit = \"flags\" }, { \"mmx\" , NULL, 0, AVOPTTYPECONST, { AVCPUFLAGMMX }, .unit = \"flags\" }, { \"mmx2\" , NULL, 0, AVOPTTYPECONST, { CPUFLAGMMX2 }, .unit = \"flags\" }, { \"sse\" , NULL, 0, AVOPTTYPECONST, { CPUFLAGSSE }, .unit = \"flags\" }, { \"sse2\" , NULL, 0, AVOPTTYPECONST, { CPUFLAGSSE2 }, .unit = \"flags\" }, { \"sse2slow\", NULL, 0, AVOPTTYPECONST, { CPUFLAGSSE2SLOW }, .unit = \"flags\" }, { \"sse3\" , NULL, 0, AVOPTTYPECONST, { CPUFLAGSSE3 }, .unit = \"flags\" }, { \"sse3slow\", NULL, 0, AVOPTTYPECONST, { CPUFLAGSSE3SLOW }, .unit = \"flags\" }, { \"ssse3\" , NULL, 0, AVOPTTYPECONST, { CPUFLAGSSSE3 }, .unit = \"flags\" }, { \"atom\" , NULL, 0, AVOPTTYPECONST, { AVCPUFLAGATOM }, .unit = \"flags\" }, { \"sse4.1\" , NULL, 0, AVOPTTYPECONST, { CPUFLAGSSE4 }, .unit = \"flags\" }, { \"sse4.2\" , NULL, 0, AVOPTTYPECONST, { CPUFLAGSSE42 }, .unit = \"flags\" }, { \"avx\" , NULL, 0, AVOPTTYPECONST, { CPUFLAGAVX }, .unit = \"flags\" }, { \"xop\" , NULL, 0, AVOPTTYPECONST, { CPUFLAGXOP }, .unit = \"flags\" }, { \"fma4\" , NULL, 0, AVOPTTYPECONST, { CPUFLAGFMA4 }, .unit = \"flags\" }, { \"3dnow\" , NULL, 0, AVOPTTYPECONST, { CPUFLAG3DNOW }, .unit = \"flags\" }, { \"3dnowext\", NULL, 0, AVOPTTYPECONST, { CPUFLAG3DNOWEXT }, .unit = \"flags\" }, { NULL }, }; static const AVClass class = { .classname = \"cpuflags\", .itemname = avdefaultitemname, .option = cpuflagsopts, .version = LIBAVUTILVERSIONINT, }; int flags = avgetcpuflags(); int ret; const AVClass *pclass = &class; if ((ret = avoptevalflags(&pclass, &cpuflagsopts[0], arg, &flags)) < 0) return ret; avforcecpuflags(flags); return 0; } ", "target": 0}
{"func": "void ffputh264qpel8mc21msa(uint8t *dst, const uint8t *src, ptrdifft stride) { avclumamidvqrt8wmsa(src - (2 * stride) - 2, stride, dst, stride, 8, 0); } ", "target": 0}
{"func": "static void serialtxdone(void *opaque) { SerialState *s = opaque; if (s->txburst < 0) { uint16t divider; if (s->divider) divider = s->divider; else divider = 1; /* We assume 10 bits/char, OK for this purpose. */ s->txburst = THROTTLETXINTERVAL * 1000 / (1000000 * 10 / (s->baudbase / divider)); } s->thripending = 1; s->lsr |= UARTLSRTHRE; s->lsr |= UARTLSRTEMT; serialupdateirq(s); } ", "target": 1}
{"func": "void qemuspicecreatehostprimary(SimpleSpiceDisplay *ssd) { QXLDevSurfaceCreate surface; memset(&surface, 0, sizeof(surface)); dprint(1, \"%s/%d: %dx%d\\n\", func, ssd->qxl.id, surfacewidth(ssd->ds), surfaceheight(ssd->ds)); surface.format = SPICESURFACEFMT32xRGB; surface.width = surfacewidth(ssd->ds); surface.height = surfaceheight(ssd->ds); surface.stride = -surface.width * 4; surface.mousemode = true; surface.flags = 0; surface.type = 0; surface.mem = (uintptrt)ssd->buf; surface.groupid = MEMSLOTGROUPHOST; qemuspicecreateprimarysurface(ssd, 0, &surface, QXLSYNC); } ", "target": 1}
{"func": "static void initproc750fx (CPUPPCState *env) { gensprne601(env); genspr7xx(env); /* XXX : not implemented */ sprregister(env, SPRL2CR, \"L2CR\", SPRNOACCESS, SPRNOACCESS, &sprreadgeneric, NULL, 0x00000000); /* Time base */ gentbl(env); /* Thermal management */ gensprthrm(env); /* XXX : not implemented */ sprregister(env, SPR750THRM4, \"THRM4\", SPRNOACCESS, SPRNOACCESS, &sprreadgeneric, &sprwritegeneric, 0x00000000); /* Hardware implementation registers */ /* XXX : not implemented */ sprregister(env, SPRHID0, \"HID0\", SPRNOACCESS, SPRNOACCESS, &sprreadgeneric, &sprwritegeneric, 0x00000000); /* XXX : not implemented */ sprregister(env, SPRHID1, \"HID1\", SPRNOACCESS, SPRNOACCESS, &sprreadgeneric, &sprwritegeneric, 0x00000000); /* XXX : not implemented */ sprregister(env, SPR750FXHID2, \"HID2\", SPRNOACCESS, SPRNOACCESS, &sprreadgeneric, &sprwritegeneric, 0x00000000); /* Memory management */ genlowBATs(env); /* PowerPC 750fx & 750gx has 8 DBATs and 8 IBATs */ genhighBATs(env); initexcp7x0(env); env->dcachelinesize = 32; env->icachelinesize = 32; /* Allocate hardware IRQ controller */ ppc6xxirqinit(env); } ", "target": 1}
{"func": "void stprinttracefilestatus(FILE *stream, int (*streamprintf)(FILE *stream, const char *fmt, ...)) { streamprintf(stream, \"Trace file \\\"%s\\\" %s.\\n\", tracefilename, tracefileenabled ? \"on\" : \"off\"); } ", "target": 1}
{"func": "static int mkvwriteheader(AVFormatContext *s) { MatroskaMuxContext *mkv = s->privdata; AVIOContext *pb = s->pb; ebmlmaster ebmlheader; AVDictionaryEntry *tag; int ret, i, version = 2; int64t creationtime; if (!strcmp(s->oformat->name, \"webm\")) mkv->mode = MODEWEBM; else mkv->mode = MODEMATROSKAv2; if (mkv->mode != MODEWEBM || avdictget(s->metadata, \"stereomode\", NULL, 0) || avdictget(s->metadata, \"alphamode\", NULL, 0)) version = 4; if (s->nbstreams > MAXTRACKS) { avlog(s, AVLOGERROR, \"At most %d streams are supported for muxing in Matroska\\n\", MAXTRACKS); return AVERROR(EINVAL); } for (i = 0; i < s->nbstreams; i++) { if (s->streams[i]->codecpar->codecid == AVCODECIDATRAC3 || s->streams[i]->codecpar->codecid == AVCODECIDCOOK || s->streams[i]->codecpar->codecid == AVCODECIDRA288 || s->streams[i]->codecpar->codecid == AVCODECIDSIPR || s->streams[i]->codecpar->codecid == AVCODECIDRV10 || s->streams[i]->codecpar->codecid == AVCODECIDRV20) { avlog(s, AVLOGERROR, \"The Matroska muxer does not yet support muxing %s\\n\", avcodecgetname(s->streams[i]->codecpar->codecid)); return AVERRORPATCHWELCOME; } if (s->streams[i]->codecpar->codecid == AVCODECIDOPUS || avdictget(s->streams[i]->metadata, \"stereomode\", NULL, 0) || avdictget(s->streams[i]->metadata, \"alphamode\", NULL, 0)) version = 4; } mkv->tracks = avmalloczarray(s->nbstreams, sizeof(*mkv->tracks)); if (!mkv->tracks) { ret = AVERROR(ENOMEM); goto fail; } ebmlheader = startebmlmaster(pb, EBMLIDHEADER, 0); putebmluint (pb, EBMLIDEBMLVERSION , 1); putebmluint (pb, EBMLIDEBMLREADVERSION , 1); putebmluint (pb, EBMLIDEBMLMAXIDLENGTH , 4); putebmluint (pb, EBMLIDEBMLMAXSIZELENGTH , 8); putebmlstring (pb, EBMLIDDOCTYPE , s->oformat->name); putebmluint (pb, EBMLIDDOCTYPEVERSION , version); putebmluint (pb, EBMLIDDOCTYPEREADVERSION , 2); endebmlmaster(pb, ebmlheader); mkv->segment = startebmlmaster(pb, MATROSKAIDSEGMENT, 0); mkv->segmentoffset = aviotell(pb); // we write 2 seek heads - one at the end of the file to point to each // cluster, and one at the beginning to point to all other level one // elements (including the seek head at the end of the file), which // isn't more than 10 elements if we only write one of each other // currently defined level 1 element mkv->mainseekhead = mkvstartseekhead(pb, mkv->segmentoffset, 10); if (!mkv->mainseekhead) { ret = AVERROR(ENOMEM); goto fail; } ret = mkvaddseekheadentry(mkv->mainseekhead, MATROSKAIDINFO, aviotell(pb)); if (ret < 0) goto fail; ret = startebmlmastercrc32(pb, &mkv->infobc, mkv, &mkv->info, MATROSKAIDINFO, 0); if (ret < 0) return ret; pb = mkv->infobc; putebmluint(pb, MATROSKAIDTIMECODESCALE, 1000000); if ((tag = avdictget(s->metadata, \"title\", NULL, 0))) putebmlstring(pb, MATROSKAIDTITLE, tag->value); if (!(s->flags & AVFMTFLAGBITEXACT)) { putebmlstring(pb, MATROSKAIDMUXINGAPP, LIBAVFORMATIDENT); if ((tag = avdictget(s->metadata, \"encodingtool\", NULL, 0))) putebmlstring(pb, MATROSKAIDWRITINGAPP, tag->value); else putebmlstring(pb, MATROSKAIDWRITINGAPP, LIBAVFORMATIDENT); if (mkv->mode != MODEWEBM) { uint32t segmentuid[4]; AVLFG lfg; avlfginit(&lfg, avgetrandomseed()); for (i = 0; i < 4; i++) segmentuid[i] = avlfgget(&lfg); putebmlbinary(pb, MATROSKAIDSEGMENTUID, segmentuid, 16); } } else { const char *ident = \"Lavf\"; putebmlstring(pb, MATROSKAIDMUXINGAPP , ident); putebmlstring(pb, MATROSKAIDWRITINGAPP, ident); } if (ffparsecreationtimemetadata(s, &creationtime, 0) > 0) { // Adjust time so it's relative to 2001-01-01 and convert to nanoseconds. int64t dateutc = (creationtime - 978307200000000LL) * 1000; uint8t dateutcbuf[8]; AVWB64(dateutcbuf, dateutc); putebmlbinary(pb, MATROSKAIDDATEUTC, dateutcbuf, 8); } // reserve space for the duration mkv->duration = 0; mkv->durationoffset = aviotell(pb); if (!mkv->islive) { int64t metadataduration = getmetadataduration(s); if (s->duration > 0) { int64t scaledDuration = avrescale(s->duration, 1000, AVTIMEBASE); putebmlfloat(pb, MATROSKAIDDURATION, scaledDuration); avlog(s, AVLOGDEBUG, \"Write early duration from recording time = %\" PRIu64 \"\\n\", scaledDuration); } else if (metadataduration > 0) { int64t scaledDuration = avrescale(metadataduration, 1000, AVTIMEBASE); putebmlfloat(pb, MATROSKAIDDURATION, scaledDuration); avlog(s, AVLOGDEBUG, \"Write early duration from metadata = %\" PRIu64 \"\\n\", scaledDuration); } else { putebmlvoid(pb, 11); // assumes double-precision float to be written } } if ((s->pb->seekable & AVIOSEEKABLENORMAL) && !mkv->islive) endebmlmastercrc32preliminary(s->pb, &mkv->infobc, mkv, mkv->info); else endebmlmastercrc32(s->pb, &mkv->infobc, mkv, mkv->info); pb = s->pb; // initialize streamduration fields mkv->streamdurations = avmallocz(s->nbstreams * sizeof(int64t)); mkv->streamdurationoffsets = avmallocz(s->nbstreams * sizeof(int64t)); ret = mkvwritetracks(s); if (ret < 0) goto fail; for (i = 0; i < s->nbchapters; i++) mkv->chapteridoffset = FFMAX(mkv->chapteridoffset, 1LL - s->chapters[i]->id); ret = mkvwritechapters(s); if (ret < 0) goto fail; if (mkv->mode != MODEWEBM) { ret = mkvwriteattachments(s); if (ret < 0) goto fail; } ret = mkvwritetags(s); if (ret < 0) goto fail; if (!(s->pb->seekable & AVIOSEEKABLENORMAL) && !mkv->islive) mkvwriteseekhead(pb, mkv); mkv->cues = mkvstartcues(mkv->segmentoffset); if (!mkv->cues) { ret = AVERROR(ENOMEM); goto fail; } if ((pb->seekable & AVIOSEEKABLENORMAL) && mkv->reservecuesspace) { mkv->cuespos = aviotell(pb); putebmlvoid(pb, mkv->reservecuesspace); } avinitpacket(&mkv->curaudiopkt); mkv->curaudiopkt.size = 0; mkv->clusterpos = -1; avioflush(pb); // start a new cluster every 5 MB or 5 sec, or 32k / 1 sec for streaming or // after 4k and on a keyframe if (pb->seekable & AVIOSEEKABLENORMAL) { if (mkv->clustertimelimit < 0) mkv->clustertimelimit = 5000; if (mkv->clustersizelimit < 0) mkv->clustersizelimit = 5 * 1024 * 1024; } else { if (mkv->clustertimelimit < 0) mkv->clustertimelimit = 1000; if (mkv->clustersizelimit < 0) mkv->clustersizelimit = 32 * 1024; } return 0; fail: mkvfree(mkv); return ret; } ", "target": 0}
{"func": "e1000canreceive(void *opaque) { E1000State *s = opaque; return (!(s->macreg[RCTL] & E1000RCTLEN) || s->macreg[RDH] != s->macreg[RDT]); } ", "target": 1}
{"func": "avcold void ffswsinitswScalemmx(SwsContext *c) { int cpuflags = avgetcpuflags(); #if HAVEINLINEASM if (cpuflags & AVCPUFLAGMMX) swsinitswScaleMMX(c); #if HAVEMMXEXTINLINE if (cpuflags & AVCPUFLAGMMXEXT) swsinitswScaleMMX2(c); #endif #endif /* HAVEINLINEASM */ #if HAVEYASM #define ASSIGNSCALEFUNC2(hscalefn, filtersize, opt1, opt2) do { \\ if (c->srcBpc == 8) { \\ hscalefn = c->dstBpc <= 10 ? ffhscale8to15 ## filtersize ## ## opt2 : \\ ffhscale8to19 ## filtersize ## ## opt1; \\ } else if (c->srcBpc == 9) { \\ hscalefn = c->dstBpc <= 10 ? ffhscale9to15 ## filtersize ## ## opt2 : \\ ffhscale9to19 ## filtersize ## ## opt1; \\ } else if (c->srcBpc == 10) { \\ hscalefn = c->dstBpc <= 10 ? ffhscale10to15 ## filtersize ## ## opt2 : \\ ffhscale10to19 ## filtersize ## ## opt1; \\ } else /* c->srcBpc == 16 */ { \\ hscalefn = c->dstBpc <= 10 ? ffhscale16to15 ## filtersize ## ## opt2 : \\ ffhscale16to19 ## filtersize ## ## opt1; \\ } \\ } while (0) #define ASSIGNMMXSCALEFUNC(hscalefn, filtersize, opt1, opt2) \\ switch (filtersize) { \\ case 4: ASSIGNSCALEFUNC2(hscalefn, 4, opt1, opt2); break; \\ case 8: ASSIGNSCALEFUNC2(hscalefn, 8, opt1, opt2); break; \\ default: ASSIGNSCALEFUNC2(hscalefn, X, opt1, opt2); break; \\ } #define ASSIGNVSCALEXFUNC(vscalefn, opt, do16case, condition8bit) \\ switch(c->dstBpc){ \\ case 16: do16case; break; \\ case 10: if (!isBE(c->dstFormat)) vscalefn = ffyuv2planeX10 ## opt; break; \\ case 9: if (!isBE(c->dstFormat)) vscalefn = ffyuv2planeX9 ## opt; break; \\ default: if (condition8bit) vscalefn = ffyuv2planeX8 ## opt; break; \\ } #define ASSIGNVSCALEFUNC(vscalefn, opt1, opt2, opt2chk) \\ switch(c->dstBpc){ \\ case 16: if (!isBE(c->dstFormat)) vscalefn = ffyuv2plane116 ## opt1; break; \\ case 10: if (!isBE(c->dstFormat) && opt2chk) vscalefn = ffyuv2plane110 ## opt2; break; \\ case 9: if (!isBE(c->dstFormat) && opt2chk) vscalefn = ffyuv2plane19 ## opt2; break; \\ default: vscalefn = ffyuv2plane18 ## opt1; break; \\ } #define casergb(x, X, opt) \\ case PIXFMT ## X: \\ c->lumToYV12 = ff ## x ## ToY ## opt; \\ if (!c->chrSrcHSubSample) \\ c->chrToYV12 = ff ## x ## ToUV ## opt; \\ break #if ARCHX8632 if (cpuflags & AVCPUFLAGMMX) { ASSIGNMMXSCALEFUNC(c->hyScale, c->hLumFilterSize, mmx, mmx); ASSIGNMMXSCALEFUNC(c->hcScale, c->hChrFilterSize, mmx, mmx); ASSIGNVSCALEFUNC(c->yuv2plane1, mmx, mmx2, cpuflags & AVCPUFLAGMMXEXT); switch (c->srcFormat) { case PIXFMTY400A: c->lumToYV12 = ffyuyvToYmmx; if (c->alpPixBuf) c->alpToYV12 = ffuyvyToYmmx; break; case PIXFMTYUYV422: c->lumToYV12 = ffyuyvToYmmx; c->chrToYV12 = ffyuyvToUVmmx; break; case PIXFMTUYVY422: c->lumToYV12 = ffuyvyToYmmx; c->chrToYV12 = ffuyvyToUVmmx; break; case PIXFMTNV12: c->chrToYV12 = ffnv12ToUVmmx; break; case PIXFMTNV21: c->chrToYV12 = ffnv21ToUVmmx; break; casergb(rgb24, RGB24, mmx); casergb(bgr24, BGR24, mmx); casergb(bgra, BGRA, mmx); casergb(rgba, RGBA, mmx); casergb(abgr, ABGR, mmx); casergb(argb, ARGB, mmx); default: break; } } if (cpuflags & AVCPUFLAGMMXEXT) { ASSIGNVSCALEXFUNC(c->yuv2planeX, mmx2, , 1); } #endif /* ARCHX8632 */ #define ASSIGNSSESCALEFUNC(hscalefn, filtersize, opt1, opt2) \\ switch (filtersize) { \\ case 4: ASSIGNSCALEFUNC2(hscalefn, 4, opt1, opt2); break; \\ case 8: ASSIGNSCALEFUNC2(hscalefn, 8, opt1, opt2); break; \\ default: if (filtersize & 4) ASSIGNSCALEFUNC2(hscalefn, X4, opt1, opt2); \\ else ASSIGNSCALEFUNC2(hscalefn, X8, opt1, opt2); \\ break; \\ } if (cpuflags & AVCPUFLAGSSE2) { ASSIGNSSESCALEFUNC(c->hyScale, c->hLumFilterSize, sse2, sse2); ASSIGNSSESCALEFUNC(c->hcScale, c->hChrFilterSize, sse2, sse2); ASSIGNVSCALEXFUNC(c->yuv2planeX, sse2, , HAVEALIGNEDSTACK || ARCHX8664); ASSIGNVSCALEFUNC(c->yuv2plane1, sse2, sse2, 1); switch (c->srcFormat) { case PIXFMTY400A: c->lumToYV12 = ffyuyvToYsse2; if (c->alpPixBuf) c->alpToYV12 = ffuyvyToYsse2; break; case PIXFMTYUYV422: c->lumToYV12 = ffyuyvToYsse2; c->chrToYV12 = ffyuyvToUVsse2; break; case PIXFMTUYVY422: c->lumToYV12 = ffuyvyToYsse2; c->chrToYV12 = ffuyvyToUVsse2; break; case PIXFMTNV12: c->chrToYV12 = ffnv12ToUVsse2; break; case PIXFMTNV21: c->chrToYV12 = ffnv21ToUVsse2; break; casergb(rgb24, RGB24, sse2); casergb(bgr24, BGR24, sse2); casergb(bgra, BGRA, sse2); casergb(rgba, RGBA, sse2); casergb(abgr, ABGR, sse2); casergb(argb, ARGB, sse2); default: break; } } if (cpuflags & AVCPUFLAGSSSE3) { ASSIGNSSESCALEFUNC(c->hyScale, c->hLumFilterSize, ssse3, ssse3); ASSIGNSSESCALEFUNC(c->hcScale, c->hChrFilterSize, ssse3, ssse3); switch (c->srcFormat) { casergb(rgb24, RGB24, ssse3); casergb(bgr24, BGR24, ssse3); default: break; } } if (cpuflags & AVCPUFLAGSSE4) { /* Xto15 don't need special sse4 functions */ ASSIGNSSESCALEFUNC(c->hyScale, c->hLumFilterSize, sse4, ssse3); ASSIGNSSESCALEFUNC(c->hcScale, c->hChrFilterSize, sse4, ssse3); ASSIGNVSCALEXFUNC(c->yuv2planeX, sse4, if (!isBE(c->dstFormat)) c->yuv2planeX = ffyuv2planeX16sse4, HAVEALIGNEDSTACK || ARCHX8664); if (c->dstBpc == 16 && !isBE(c->dstFormat)) c->yuv2plane1 = ffyuv2plane116sse4; } if (cpuflags & AVCPUFLAGAVX) { ASSIGNVSCALEXFUNC(c->yuv2planeX, avx, , HAVEALIGNEDSTACK || ARCHX8664); ASSIGNVSCALEFUNC(c->yuv2plane1, avx, avx, 1); switch (c->srcFormat) { case PIXFMTYUYV422: c->chrToYV12 = ffyuyvToUVavx; break; case PIXFMTUYVY422: c->chrToYV12 = ffuyvyToUVavx; break; case PIXFMTNV12: c->chrToYV12 = ffnv12ToUVavx; break; case PIXFMTNV21: c->chrToYV12 = ffnv21ToUVavx; break; casergb(rgb24, RGB24, avx); casergb(bgr24, BGR24, avx); casergb(bgra, BGRA, avx); casergb(rgba, RGBA, avx); casergb(abgr, ABGR, avx); casergb(argb, ARGB, avx); default: break; } } #endif } ", "target": 0}
{"func": "static unsigned tget(const uint8t **p, int type, int le) { switch (type) { case TIFFBYTE: return *(*p)++; case TIFFSHORT: return tgetshort(p, le); case TIFFLONG: return tgetlong(p, le); default: return UINTMAX; } } ", "target": 1}
{"func": "static int decodehqslice(AVCodecContext *avctx, void *arg) { int i, quant, level, orientation, quantidx; uint8t quants[MAXDWTLEVELS][4]; DiracContext *s = avctx->privdata; DiracSlice *slice = arg; GetBitContext *gb = &slice->gb; skipbitslong(gb, 8*s->highquality.prefixbytes); quantidx = getbits(gb, 8); /* Slice quantization (slicequantizers() in the specs) */ for (level = 0; level < s->waveletdepth; level++) { for (orientation = !!level; orientation < 4; orientation++) { quant = FFMAX(quantidx - s->lowdelay.quant[level][orientation], 0); quants[level][orientation] = quant; } } /* Luma + 2 Chroma planes */ for (i = 0; i < 3; i++) { int64t length = s->highquality.sizescaler * getbits(gb, 8); int64t bitsleft = 8 * length; int64t bitsend = getbitscount(gb) + bitsleft; if (bitsend >= INTMAX) { avlog(s->avctx, AVLOGERROR, \"end too far away\\n\"); return AVERRORINVALIDDATA; } for (level = 0; level < s->waveletdepth; level++) { for (orientation = !!level; orientation < 4; orientation++) { decodesubband(s, gb, quants[level][orientation], slice->slicex, slice->slicey, bitsend, &s->plane[i].band[level][orientation], NULL); } } skipbitslong(gb, bitsend - getbitscount(gb)); } return 0; } ", "target": 1}
{"func": "static avcold int amrwbencodeinit(AVCodecContext *avctx) { AMRWBContext *s = avctx->privdata; if (avctx->samplerate != 16000) { avlog(avctx, AVLOGERROR, \"Only 16000Hz sample rate supported\\n\"); return AVERROR(ENOSYS); } if (avctx->channels != 1) { avlog(avctx, AVLOGERROR, \"Only mono supported\\n\"); return AVERROR(ENOSYS); } s->mode = getwbbitratemode(avctx->bitrate, avctx); s->lastbitrate = avctx->bitrate; avctx->framesize = 320; avctx->codedframe = avcodecallocframe(); s->state = EIFinit(); return 0; }", "target": 1}
{"func": "uint32t div32(uint32t *qptr, uint64t num, uint32t den) { *qptr = num / den; return num % den; } ", "target": 1}
{"func": "void fffetchtimestamp(AVCodecParserContext *s, int off, int remove) { int i; s->dts = s->pts = AVNOPTSVALUE; s->pos = -1; s->offset = 0; for (i = 0; i < AVPARSERPTSNB; i++) { if (s->curoffset + off >= s->curframeoffset[i] && (s->frameoffset < s->curframeoffset[i] || (!s->frameoffset && !s->nextframeoffset)) && // first field/frame // check disabled since MPEG-TS does not send complete PES packets /*s->nextframeoffset + off <*/ s->curframeend[i]){ s->dts = s->curframedts[i]; s->pts = s->curframepts[i]; s->pos = s->curframepos[i]; s->offset = s->nextframeoffset - s->curframeoffset[i]; if (remove) s->curframeoffset[i] = INT64MAX; if (s->curoffset + off < s->curframeend[i]) break; } } } ", "target": 1}
{"func": "static void simplewhitespace(void) { int i; struct { const char *encoded; LiteralQObject decoded; } testcases[] = { { .encoded = \" [ 43 , 42 ]\", .decoded = QLITQLIST(((LiteralQObject[]){ QLITQINT(43), QLITQINT(42), { } })), }, { .encoded = \" [ 43 , { 'h' : 'b' }, [ ], 42 ]\", .decoded = QLITQLIST(((LiteralQObject[]){ QLITQINT(43), QLITQDICT(((LiteralQDictEntry[]){ { \"h\", QLITQSTR(\"b\") }, { }})), QLITQLIST(((LiteralQObject[]){ { }})), QLITQINT(42), { } })), }, { .encoded = \" [ 43 , { 'h' : 'b' , 'a' : 32 }, [ ], 42 ]\", .decoded = QLITQLIST(((LiteralQObject[]){ QLITQINT(43), QLITQDICT(((LiteralQDictEntry[]){ { \"h\", QLITQSTR(\"b\") }, { \"a\", QLITQINT(32) }, { }})), QLITQLIST(((LiteralQObject[]){ { }})), QLITQINT(42), { } })), }, { } }; for (i = 0; testcases[i].encoded; i++) { QObject *obj; QString *str; obj = qobjectfromjson(testcases[i].encoded, NULL); gassert(comparelitqobjtoqobj(&testcases[i].decoded, obj) == 1); str = qobjecttojson(obj); qobjectdecref(obj); obj = qobjectfromjson(qstringgetstr(str), NULL); gassert(comparelitqobjtoqobj(&testcases[i].decoded, obj) == 1); qobjectdecref(obj); QDECREF(str); } } ", "target": 1}
{"func": "static void genchecksr(DisasContext *dc, uint32t sr, unsigned access) { if (!xtensaoptionbitsenabled(dc->config, sregnames[sr].optbits)) { if (sregnames[sr].name) { qemulog(\"SR %s is not configured\\n\", sregnames[sr].name); } else { qemulog(\"SR %d is not implemented\\n\", sr); } genexceptioncause(dc, ILLEGALINSTRUCTIONCAUSE); } else if (!(sregnames[sr].access & access)) { static const char * const accesstext[] = { [SRR] = \"rsr\", [SRW] = \"wsr\", [SRX] = \"xsr\", }; assert(access < ARRAYSIZE(accesstext) && accesstext[access]); qemulog(\"SR %s is not available for %s\\n\", sregnames[sr].name, accesstext[access]); genexceptioncause(dc, ILLEGALINSTRUCTIONCAUSE); } } ", "target": 1}
{"func": "static void genlswi(DisasContext *ctx) { TCGv t0; TCGvi32 t1, t2; int nb = NB(ctx->opcode); int start = rD(ctx->opcode); int ra = rA(ctx->opcode); int nr; if (nb == 0) nb = 32; nr = (nb + 3) / 4; if (unlikely(lswreginrange(start, nr, ra))) { geninvalexception(ctx, POWERPCEXCPINVALLSWX); return; } gensetaccesstype(ctx, ACCESSINT); /* NIP cannot be restored if the memory exception comes from an helper */ genupdatenip(ctx, ctx->nip - 4); t0 = tcgtempnew(); genaddrregister(ctx, t0); t1 = tcgconsti32(nb); t2 = tcgconsti32(start); genhelperlsw(cpuenv, t0, t1, t2); tcgtempfree(t0); tcgtempfreei32(t1); tcgtempfreei32(t2); } ", "target": 1}
{"func": "static int decodeframe(AVCodecContext *avctx, const uint8t *databuf, float **outsamples) { ATRAC3Context *q = avctx->privdata; int ret, i; uint8t *ptr1; if (q->codingmode == JOINTSTEREO) { /* channel coupling mode */ /* decode Sound Unit 1 */ initgetbits(&q->gb, databuf, avctx->blockalign * 8); ret = decodechannelsoundunit(q, &q->gb, q->units, outsamples[0], 0, JOINTSTEREO); if (ret != 0) return ret; /* Framedata of the su2 in the joint-stereo mode is encoded in * reverse byte order so we need to swap it first. */ if (databuf == q->decodedbytesbuffer) { uint8t *ptr2 = q->decodedbytesbuffer + avctx->blockalign - 1; ptr1 = q->decodedbytesbuffer; for (i = 0; i < avctx->blockalign / 2; i++, ptr1++, ptr2--) FFSWAP(uint8t, *ptr1, *ptr2); } else { const uint8t *ptr2 = databuf + avctx->blockalign - 1; for (i = 0; i < avctx->blockalign; i++) q->decodedbytesbuffer[i] = *ptr2--; } /* Skip the sync codes (0xF8). */ ptr1 = q->decodedbytesbuffer; for (i = 4; *ptr1 == 0xF8; i++, ptr1++) { if (i >= avctx->blockalign) return AVERRORINVALIDDATA; } /* set the bitstream reader at the start of the second Sound Unit*/ initgetbits8(&q->gb, ptr1, q->decodedbytesbuffer + avctx->blockalign - ptr1); /* Fill the Weighting coeffs delay buffer */ memmove(q->weightingdelay, &q->weightingdelay[2], 4 * sizeof(*q->weightingdelay)); q->weightingdelay[4] = getbits1(&q->gb); q->weightingdelay[5] = getbits(&q->gb, 3); for (i = 0; i < 4; i++) { q->matrixcoeffindexprev[i] = q->matrixcoeffindexnow[i]; q->matrixcoeffindexnow[i] = q->matrixcoeffindexnext[i]; q->matrixcoeffindexnext[i] = getbits(&q->gb, 2); } /* Decode Sound Unit 2. */ ret = decodechannelsoundunit(q, &q->gb, &q->units[1], outsamples[1], 1, JOINTSTEREO); if (ret != 0) return ret; /* Reconstruct the channel coefficients. */ reversematrixing(outsamples[0], outsamples[1], q->matrixcoeffindexprev, q->matrixcoeffindexnow); channelweighting(outsamples[0], outsamples[1], q->weightingdelay); } else { /* single channels */ /* Decode the channel sound units. */ for (i = 0; i < avctx->channels; i++) { /* Set the bitstream reader at the start of a channel sound unit. */ initgetbits(&q->gb, databuf + i * avctx->blockalign / avctx->channels, avctx->blockalign * 8 / avctx->channels); ret = decodechannelsoundunit(q, &q->gb, &q->units[i], outsamples[i], i, q->codingmode); if (ret != 0) return ret; } } /* Apply the iQMF synthesis filter. */ for (i = 0; i < avctx->channels; i++) { float *p1 = outsamples[i]; float *p2 = p1 + 256; float *p3 = p2 + 256; float *p4 = p3 + 256; ffatraciqmf(p1, p2, 256, p1, q->units[i].delaybuf1, q->tempbuf); ffatraciqmf(p4, p3, 256, p3, q->units[i].delaybuf2, q->tempbuf); ffatraciqmf(p1, p3, 512, p1, q->units[i].delaybuf3, q->tempbuf); } return 0; } ", "target": 0}
{"func": "uint32t HELPER(shrcc)(CPUM68KState *env, uint32t val, uint32t shift) { uint64t temp; uint32t result; shift &= 63; temp = (uint64t)val << 32 >> shift; result = temp >> 32; env->ccc = (temp >> 31) & 1; env->ccn = result; env->ccz = result; env->ccv = 0; env->ccx = shift ? env->ccc : env->ccx; return result; } ", "target": 1}
{"func": "static void termdownchar(void) { if (termhistentry == TERMMAXCMDS - 1 || termhistentry == -1) \treturn; if (termhistory[++termhistentry] != NULL) { \tstrcpy(termcmdbuf, termhistory[termhistentry]); } else { \ttermhistentry = -1; } termprintf(\"\\n\"); termprintcmdline(termcmdbuf); termcmdbufindex = termcmdbufsize = strlen(termcmdbuf); } ", "target": 1}
{"func": "static int decodecabacmbcbpluma( H264Context *h) { int cbpb, cbpa, ctx, cbp = 0; cbpa = h->slicetable[h->leftmbxy[0]] == h->slicenum ? h->leftcbp : -1; cbpb = h->slicetable[h->topmbxy] == h->slicenum ? h->topcbp : -1; ctx = !(cbpa & 0x02) + 2 * !(cbpb & 0x04); cbp |= getcabacnoinline(&h->cabac, &h->cabacstate[73 + ctx]); ctx = !(cbp & 0x01) + 2 * !(cbpb & 0x08); cbp |= getcabacnoinline(&h->cabac, &h->cabacstate[73 + ctx]) << 1; ctx = !(cbpa & 0x08) + 2 * !(cbp & 0x01); cbp |= getcabacnoinline(&h->cabac, &h->cabacstate[73 + ctx]) << 2; ctx = !(cbp & 0x04) + 2 * !(cbp & 0x02); cbp |= getcabacnoinline(&h->cabac, &h->cabacstate[73 + ctx]) << 3; return cbp; } ", "target": 0}
{"func": "void ffqsvdecodereset(AVCodecContext *avctx, QSVContext *q) { QSVFrame *cur; AVPacket pkt; int ret = 0; mfxVideoParam param = { { 0 } }; if (q->reinitpending) { closedecoder(q); } else if (q->engineready) { ret = MFXVideoDECODEGetVideoParam(q->session, &param); if (ret < 0) { avlog(avctx, AVLOGERROR, \"MFX decode get param error %d\\n\", ret); } ret = MFXVideoDECODEReset(q->session, &param); if (ret < 0) { avlog(avctx, AVLOGERROR, \"MFX decode reset error %d\\n\", ret); } /* Free all frames*/ cur = q->workframes; while (cur) { q->workframes = cur->next; avframefree(&cur->frame); avfreep(&cur); cur = q->workframes; } } /* Reset output surfaces */ avfiforeset(q->asyncfifo); /* Reset input packets fifo */ while (avfifosize(q->pktfifo)) { avfifogenericread(q->pktfifo, &pkt, sizeof(pkt), NULL); avpacketunref(&pkt); } /* Reset input bitstream fifo */ avfiforeset(q->inputfifo); } ", "target": 1}
{"func": "targetulong helpersdiv(targetulong a, targetulong b) { int64t x0; int32t x1; x0 = (a & 0xffffffff) | ((int64t) (env->y) << 32); x1 = (b & 0xffffffff); if (x1 == 0) { raiseexception(TTDIVZERO); } x0 = x0 / x1; if ((int32t) x0 != x0) { env->ccsrc2 = 1; return x0 < 0? 0x80000000: 0x7fffffff; } else { env->ccsrc2 = 0; return x0; } } ", "target": 1}
{"func": "static void xhcireset(DeviceState *dev) { XHCIState *xhci = XHCI(dev); int i; traceusbxhcireset(); if (!(xhci->usbsts & USBSTSHCH)) { DPRINTF(\"xhci: reset while running!\\n\"); } xhci->usbcmd = 0; xhci->usbsts = USBSTSHCH; xhci->dnctrl = 0; xhci->crcrlow = 0; xhci->crcrhigh = 0; xhci->dcbaaplow = 0; xhci->dcbaaphigh = 0; xhci->config = 0; for (i = 0; i < xhci->numslots; i++) { xhcidisableslot(xhci, i+1); } for (i = 0; i < xhci->numports; i++) { xhciportupdate(xhci->ports + i, 0); } for (i = 0; i < xhci->numintrs; i++) { xhci->intr[i].iman = 0; xhci->intr[i].imod = 0; xhci->intr[i].erstsz = 0; xhci->intr[i].erstbalow = 0; xhci->intr[i].erstbahigh = 0; xhci->intr[i].erdplow = 0; xhci->intr[i].erdphigh = 0; xhci->intr[i].msixused = 0; xhci->intr[i].erepidx = 0; xhci->intr[i].erpcs = 1; xhci->intr[i].erfull = 0; xhci->intr[i].evbufferput = 0; xhci->intr[i].evbufferget = 0; } xhci->mfindexstart = qemuclockgetns(QEMUCLOCKVIRTUAL); xhcimfwrapupdate(xhci); } ", "target": 1}
{"func": "int ppcfindbypvr (uint32t pvr, ppcdeft **def) { int i, ret; ret = -1; *def = NULL; for (i = 0; ppcdefs[i].name != NULL; i++) { if ((pvr & ppcdefs[i].pvrmask) == (ppcdefs[i].pvr & ppcdefs[i].pvrmask)) { *def = &ppcdefs[i]; ret = 0; break; } } return ret; } ", "target": 1}
{"func": "void helpertlbupdate(uint32t T0) { #if !defined(CONFIGUSERONLY) \tuint32t vaddr; \tuint32t srs = env->pregs[PRSRS]; \tif (srs != 1 && srs != 2) \t\treturn; \tvaddr = crismmutlblatestupdate(env, T0); \tD(printf(\"flush oldvaddr=%x vaddr=%x T0=%x\\n\", vaddr, \t\t env->sregs[SFRRMMCAUSE] & TARGETPAGEMASK, T0)); \ttlbflushpage(env, vaddr); #endif } ", "target": 0}
{"func": "static void patchpcihp(int slot, uint8t *ssdtptr, uint32t eject) { ssdtptr[ACPIPCIHPOFFSETHEX] = acpigethex(slot >> 4); ssdtptr[ACPIPCIHPOFFSETHEX + 1] = acpigethex(slot); ssdtptr[ACPIPCIHPOFFSETID] = slot; ssdtptr[ACPIPCIHPOFFSETADR + 2] = slot; /* Runtime patching of ACPIEJ0: to disable hotplug for a slot, * replace the method name: EJ0 by ACPIEJ0. */ /* Sanity check */ assert(!memcmp(ssdtptr + ACPIPCIHPOFFSETEJ0, \"EJ0\", 4)); if (!eject) { memcpy(ssdtptr + ACPIPCIHPOFFSETEJ0, \"EJ0\", 4); } } ", "target": 0}
{"func": "static float ssimplane(uint8t *main, int mainstride, uint8t *ref, int refstride, int width, int height, void *temp) { int z = 0; int x, y; float ssim = 0.0; int (*sum0)[4] = temp; int (*sum1)[4] = sum0 + (width >> 2) + 3; width >>= 2; height >>= 2; for (y = 1; y < height; y++) { for (; z <= y; z++) { FFSWAP(void*, sum0, sum1); for (x = 0; x < width; x+=2) ssim4x4x2core(&main[4 * (x + z * mainstride)], mainstride, &ref[4 * (x + z * refstride)], refstride, &sum0[x]); } ssim += ssimendn(sum0, sum1, width - 1); } return ssim / ((height - 1) * (width - 1)); } ", "target": 0}
{"func": "static void nvmeinstanceinit(Object *obj) { objectpropertyadd(obj, \"bootindex\", \"int32\", nvmegetbootindex, nvmesetbootindex, NULL, NULL, NULL); objectpropertysetint(obj, -1, \"bootindex\", NULL); } ", "target": 1}
{"func": "static int blkverifyopen(BlockDriverState *bs, QDict *options, int flags, Error **errp) { BDRVBlkverifyState *s = bs->opaque; QemuOpts *opts; Error *localerr = NULL; int ret; opts = qemuoptscreate(&runtimeopts, NULL, 0, &errorabort); qemuoptsabsorbqdict(opts, options, &localerr); if (localerr) { errorpropagate(errp, localerr); ret = -EINVAL; goto fail; /* Open the raw file */ bs->file = bdrvopenchild(qemuoptget(opts, \"x-raw\"), options, \"raw\", bs, &childfile, false, &localerr); if (localerr) { ret = -EINVAL; errorpropagate(errp, localerr); goto fail; /* Open the test file */ s->testfile = bdrvopenchild(qemuoptget(opts, \"x-image\"), options, \"test\", bs, &childformat, false, &localerr); if (localerr) { ret = -EINVAL; errorpropagate(errp, localerr); goto fail; ret = 0; fail: qemuoptsdel(opts); return ret; ", "target": 1}
{"func": "static void tcgouttlbread(TCGContext *s, TCGReg addrlo, TCGReg addrhi, int sbits, int tlboffset) { TCGReg base = TCGAREG0; /* Should generate something like the following: * pre-v7: * shr tmp, addrreg, #TARGETPAGEBITS (1) * add r2, env, #off & 0xff00 * and r0, tmp, #(CPUTLBSIZE - 1) (2) * add r2, r2, r0, lsl #CPUTLBENTRYBITS (3) * ldr r0, [r2, #off & 0xff]! (4) * tst addrreg, #smask * cmpeq r0, tmp, lsl #TARGETPAGEBITS (5) * * v7 (not implemented yet): * ubfx r2, addrreg, #TARGETPAGEBITS, #CPUTLBBITS (1) * movw tmp, #~TARGETPAGEMASK & ~smask * movw r0, #off * add r2, env, r2, lsl #CPUTLBENTRYBITS (2) * bic tmp, addrreg, tmp * ldr r0, [r2, r0]! (3) * cmp r0, tmp (4) */ # if CPUTLBBITS > 8 # error # endif tcgoutdatreg(s, CONDAL, ARITHMOV, TCGREGTMP, 0, addrlo, SHIFTIMMLSR(TARGETPAGEBITS)); /* We assume that the offset is contained within 16 bits. */ assert((tlboffset & ~0xffff) == 0); if (tlboffset > 0xff) { tcgoutdatimm(s, CONDAL, ARITHADD, TCGREGR2, base, (24 << 7) | (tlboffset >> 8)); tlboffset &= 0xff; base = TCGREGR2; } tcgoutdatimm(s, CONDAL, ARITHAND, TCGREGR0, TCGREGTMP, CPUTLBSIZE - 1); tcgoutdatreg(s, CONDAL, ARITHADD, TCGREGR2, base, TCGREGR0, SHIFTIMMLSL(CPUTLBENTRYBITS)); /* Load the tlb comparator. Use ldrd if needed and available, but due to how the pointer needs setting up, ldm isn't useful. Base arm5 doesn't have ldrd, but armv5te does. */ if (usearmv6instructions && TARGETLONGBITS == 64) { tcgoutmemop8(s, CONDAL, INSNLDRDIMM, TCGREGR0, TCGREGR2, tlboffset, 1, 1); } else { tcgoutmemop12(s, CONDAL, INSNLDRIMM, TCGREGR0, TCGREGR2, tlboffset, 1, 1); if (TARGETLONGBITS == 64) { tcgoutmemop12(s, CONDAL, INSNLDRIMM, TCGREGR1, TCGREGR2, 4, 1, 0); } } /* Check alignment. */ if (sbits) { tcgoutdatimm(s, CONDAL, ARITHTST, 0, addrlo, (1 << sbits) - 1); } tcgoutdatreg(s, (sbits ? CONDEQ : CONDAL), ARITHCMP, 0, TCGREGR0, TCGREGTMP, SHIFTIMMLSL(TARGETPAGEBITS)); if (TARGETLONGBITS == 64) { tcgoutdatreg(s, CONDEQ, ARITHCMP, 0, TCGREGR1, addrhi, SHIFTIMMLSL(0)); } } ", "target": 1}
{"func": "static void qdm2decodesuperblock(QDM2Context *q) { GetBitContext gb; QDM2SubPacket header, *packet; int i, packetbytes, subpacketsize, subpacketsD; unsigned int nextindex = 0; memset(q->tonelevelidxhi1, 0, sizeof(q->tonelevelidxhi1)); memset(q->tonelevelidxmid, 0, sizeof(q->tonelevelidxmid)); memset(q->tonelevelidxhi2, 0, sizeof(q->tonelevelidxhi2)); q->subpacketsB = 0; subpacketsD = 0; averagequantizedcoeffs(q); // average elements in quantizedcoeffs[maxch][10][8] initgetbits(&gb, q->compresseddata, q->compressedsize * 8); qdm2decodesubpacketheader(&gb, &header); if (header.type < 2 || header.type >= 8) { q->haserrors = 1; avlog(NULL, AVLOGERROR, \"bad superblock type\\n\"); return; } q->superblocktype23 = (header.type == 2 || header.type == 3); packetbytes = (q->compressedsize - getbitscount(&gb) / 8); initgetbits(&gb, header.data, header.size * 8); if (header.type == 2 || header.type == 4 || header.type == 5) { int csum = 257 * getbits(&gb, 8); csum += 2 * getbits(&gb, 8); csum = qdm2packetchecksum(q->compresseddata, q->checksumsize, csum); if (csum != 0) { q->haserrors = 1; avlog(NULL, AVLOGERROR, \"bad packet checksum\\n\"); return; } } q->subpacketlistB[0].packet = NULL; q->subpacketlistD[0].packet = NULL; for (i = 0; i < 6; i++) if (--q->fftlevelexp[i] < 0) q->fftlevelexp[i] = 0; for (i = 0; packetbytes > 0; i++) { int j; if (i >= FFARRAYELEMS(q->subpacketlistA)) { SAMPLESNEEDED2(\"too many packet bytes\"); return; } q->subpacketlistA[i].next = NULL; if (i > 0) { q->subpacketlistA[i - 1].next = &q->subpacketlistA[i]; /* seek to next block */ initgetbits(&gb, header.data, header.size * 8); skipbits(&gb, nextindex * 8); if (nextindex >= header.size) break; } /* decode subpacket */ packet = &q->subpackets[i]; qdm2decodesubpacketheader(&gb, packet); nextindex = packet->size + getbitscount(&gb) / 8; subpacketsize = ((packet->size > 0xff) ? 1 : 0) + packet->size + 2; if (packet->type == 0) break; if (subpacketsize > packetbytes) { if (packet->type != 10 && packet->type != 11 && packet->type != 12) break; packet->size += packetbytes - subpacketsize; } packetbytes -= subpacketsize; /* add subpacket to 'all subpackets' list */ q->subpacketlistA[i].packet = packet; /* add subpacket to related list */ if (packet->type == 8) { SAMPLESNEEDED2(\"packet type 8\"); return; } else if (packet->type >= 9 && packet->type <= 12) { /* packets for MPEG Audio like Synthesis Filter */ QDM2LISTADD(q->subpacketlistD, subpacketsD, packet); } else if (packet->type == 13) { for (j = 0; j < 6; j++) q->fftlevelexp[j] = getbits(&gb, 6); } else if (packet->type == 14) { for (j = 0; j < 6; j++) q->fftlevelexp[j] = qdm2getvlc(&gb, &fftlevelexpvlc, 0, 2); } else if (packet->type == 15) { SAMPLESNEEDED2(\"packet type 15\") return; } else if (packet->type >= 16 && packet->type < 48 && !fftsubpackets[packet->type - 16]) { /* packets for FFT */ QDM2LISTADD(q->subpacketlistB, q->subpacketsB, packet); } } // Packet bytes loop if (q->subpacketlistD[0].packet != NULL) { processsynthesissubpackets(q, q->subpacketlistD); q->dosynthfilter = 1; } else if (q->dosynthfilter) { processsubpacket10(q, NULL); processsubpacket11(q, NULL); processsubpacket12(q, NULL); } } ", "target": 0}
{"func": "static void hScale8To15c(SwsContext *c, int16t *dst, int dstW, const uint8t *src, const int16t *filter, const int16t *filterPos, int filterSize) { int i; for (i=0; i<dstW; i++) { int j; int srcPos= filterPos[i]; int val=0; for (j=0; j<filterSize; j++) { val += ((int)src[srcPos + j])*filter[filterSize*i + j]; } //filter += hFilterSize; dst[i] = FFMIN(val>>7, (1<<15)-1); // the cubic equation does overflow ... //dst[i] = val>>7; } } ", "target": 1}
{"func": "MigrationState *migrategetcurrent(void) { static MigrationState currentmigration = { .state = MIGSTATENONE, .bandwidthlimit = MAXTHROTTLE, .xbzrlecachesize = DEFAULTMIGRATECACHESIZE, .mbps = -1, }; return &currentmigration; } ", "target": 1}
{"func": "qemucosendvrecvv(int sockfd, struct iovec *iov, unsigned iovcnt, sizet offset, sizet bytes, bool dosend) { sizet done = 0; ssizet ret; while (done < bytes) { ret = iovsendrecv(sockfd, iov, offset + done, bytes - done, dosend); if (ret > 0) { done += ret; } else if (ret < 0) { if (errno == EAGAIN) { qemucoroutineyield(); } else if (done == 0) { return -1; } else { break; } } else if (ret == 0 && !dosend) { /* write (send) should never return 0. * read (recv) returns 0 for end-of-file (-data). * In both cases there's little point retrying, * but we do for write anyway, just in case */ break; } } return done; } ", "target": 1}
{"func": "static int qcow2changebackingfile(BlockDriverState *bs, const char *backingfile, const char *backingfmt) { return qcow2updateextheader(bs, backingfile, backingfmt); } ", "target": 1}
{"func": "static void avalwaysinline filtermbedgech( uint8t *pix, int stride, const int16t bS[4], unsigned int qp, H264Context *h ) { const int qpbdoffset = 6 * (h->sps.bitdepthluma - 8); const unsigned int indexa = qp - qpbdoffset + h->slicealphac0offset; const int alpha = alphatable[indexa]; const int beta = betatable[qp - qpbdoffset + h->slicebetaoffset]; if (alpha ==0 || beta == 0) return; if( bS[0] < 4 ) { int8t tc[4]; tc[0] = tc0table[indexa][bS[0]]+1; tc[1] = tc0table[indexa][bS[1]]+1; tc[2] = tc0table[indexa][bS[2]]+1; tc[3] = tc0table[indexa][bS[3]]+1; h->h264dsp.h264vloopfilterchroma(pix, stride, alpha, beta, tc); } else { h->h264dsp.h264vloopfilterchromaintra(pix, stride, alpha, beta); } } ", "target": 0}
{"func": "static void sun4dhwinit(const struct sun4dhwdef *hwdef, ramaddrt RAMsize, const char *bootdevice, DisplayState *ds, const char *kernelfilename, const char *kernelcmdline, const char *initrdfilename, const char *cpumodel) { CPUState *env, *envs[MAXCPUS]; unsigned int i; void *iounits[MAXIOUNITS], *espdma, *ledma, *mainesp, *nvram, *sbi; qemuirq *cpuirqs[MAXCPUS], *sbiirq, *sbicpuirq, *espdmairq, *ledmairq; qemuirq *espreset, *lereset; ramaddrt ramoffset, promoffset, tcxoffset; unsigned long kernelsize; int ret; char buf[1024]; int driveindex; void *fwcfg; /* init CPUs */ if (!cpumodel) cpumodel = hwdef->defaultcpumodel; for (i = 0; i < smpcpus; i++) { env = cpuinit(cpumodel); if (!env) { fprintf(stderr, \"qemu: Unable to find Sparc CPU definition\\n\"); exit(1); } cpusparcsetid(env, i); envs[i] = env; if (i == 0) { qemuregisterreset(maincpureset, env); } else { qemuregisterreset(secondarycpureset, env); env->halted = 1; } cpuirqs[i] = qemuallocateirqs(cpusetirq, envs[i], MAXPILS); env->promaddr = hwdef->slaviobase; } for (i = smpcpus; i < MAXCPUS; i++) cpuirqs[i] = qemuallocateirqs(dummycpusetirq, NULL, MAXPILS); /* allocate RAM */ if ((uint64t)RAMsize > hwdef->maxmem) { fprintf(stderr, \"qemu: Too much memory for this machine: %d, maximum %d\\n\", (unsigned int)(RAMsize / (1024 * 1024)), (unsigned int)(hwdef->maxmem / (1024 * 1024))); exit(1); } ramoffset = qemuramalloc(RAMsize); cpuregisterphysicalmemory(0, RAMsize, ramoffset); /* load boot prom */ promoffset = qemuramalloc(PROMSIZEMAX); cpuregisterphysicalmemory(hwdef->slaviobase, (PROMSIZEMAX + TARGETPAGESIZE - 1) & TARGETPAGEMASK, promoffset | IOMEMROM); if (biosname == NULL) biosname = PROMFILENAME; snprintf(buf, sizeof(buf), \"%s/%s\", biosdir, biosname); ret = loadelf(buf, hwdef->slaviobase - PROMVADDR, NULL, NULL, NULL); if (ret < 0 || ret > PROMSIZEMAX) ret = loadimagetargphys(buf, hwdef->slaviobase, PROMSIZEMAX); if (ret < 0 || ret > PROMSIZEMAX) { fprintf(stderr, \"qemu: could not load prom '%s'\\n\", buf); exit(1); } /* set up devices */ sbi = sbiinit(hwdef->sbibase, &sbiirq, &sbicpuirq, cpuirqs); for (i = 0; i < MAXIOUNITS; i++) if (hwdef->iounitbases[i] != (targetphysaddrt)-1) iounits[i] = iommuinit(hwdef->iounitbases[i], hwdef->iounitversion, sbiirq[hwdef->meirq]); espdma = sparc32dmainit(hwdef->espdmabase, sbiirq[hwdef->espirq], iounits[0], &espdmairq, &espreset); ledma = sparc32dmainit(hwdef->ledmabase, sbiirq[hwdef->leirq], iounits[0], &ledmairq, &lereset); if (graphicdepth != 8 && graphicdepth != 24) { fprintf(stderr, \"qemu: Unsupported depth: %d\\n\", graphicdepth); exit (1); } tcxoffset = qemuramalloc(hwdef->vramsize); tcxinit(ds, hwdef->tcxbase, physrambase + tcxoffset, tcxoffset, hwdef->vramsize, graphicwidth, graphicheight, graphicdepth); if (ndtable[0].model == NULL) ndtable[0].model = \"lance\"; if (strcmp(ndtable[0].model, \"lance\") == 0) { lanceinit(&ndtable[0], hwdef->lebase, ledma, *ledmairq, lereset); } else if (strcmp(ndtable[0].model, \"?\") == 0) { fprintf(stderr, \"qemu: Supported NICs: lance\\n\"); exit (1); } else { fprintf(stderr, \"qemu: Unsupported NIC: %s\\n\", ndtable[0].model); exit (1); } nvram = m48t59init(sbiirq[0], hwdef->nvrambase, 0, hwdef->nvramsize, 8); slaviotimerinitall(hwdef->counterbase, sbiirq[hwdef->clock1irq], sbicpuirq, smpcpus); slavioserialmskbdinit(hwdef->mskbbase, sbiirq[hwdef->mskbirq], nographic, ESCCCLOCK, 1); // Slavio TTYA (base+4, Linux ttyS0) is the first Qemu serial device // Slavio TTYB (base+0, Linux ttyS1) is the second Qemu serial device esccinit(hwdef->serialbase, sbiirq[hwdef->serirq], serialhds[1], serialhds[0], ESCCCLOCK, 1); if (drivegetmaxbus(IFSCSI) > 0) { fprintf(stderr, \"qemu: too many SCSI bus\\n\"); exit(1); } mainesp = espinit(hwdef->espbase, 2, espdmamemoryread, espdmamemorywrite, espdma, *espdmairq, espreset); for (i = 0; i < ESPMAXDEVS; i++) { driveindex = drivegetindex(IFSCSI, 0, i); if (driveindex == -1) continue; espscsiattach(mainesp, drivestable[driveindex].bdrv, i); } kernelsize = sun4mloadkernel(kernelfilename, initrdfilename, RAMsize); nvraminit(nvram, (uint8t *)&ndtable[0].macaddr, kernelcmdline, bootdevice, RAMsize, kernelsize, graphicwidth, graphicheight, graphicdepth, hwdef->nvrammachineid, \"Sun4d\"); fwcfg = fwcfginit(0, 0, CFGADDR, CFGADDR + 2); fwcfgaddi32(fwcfg, FWCFGID, 1); fwcfgaddi64(fwcfg, FWCFGRAMSIZE, (uint64t)ramsize); fwcfgaddi16(fwcfg, FWCFGMACHINEID, hwdef->machineid); } ", "target": 0}
{"func": "static int qemurdmablockforwrid(RDMAContext *rdma, int wridrequested) { int numcqevents = 0, ret = 0; struct ibvcq *cq; void *cqctx; uint64t wrid = RDMAWRIDNONE, wridin; if (ibvreqnotifycq(rdma->cq, 0)) { return -1; } /* poll cq first */ while (wrid != wridrequested) { ret = qemurdmapoll(rdma, &wridin); if (ret < 0) { return ret; } wrid = wridin & RDMAWRIDTYPEMASK; if (wrid == RDMAWRIDNONE) { break; } if (wrid != wridrequested) { DDDPRINTF(\"A Wanted wrid %s (%d) but got %s (%\" PRIu64 \")\\n\", printwrid(wridrequested), wridrequested, printwrid(wrid), wrid); } } if (wrid == wridrequested) { return 0; } while (1) { /* * Coroutine doesn't start until processincomingmigration() * so don't yield unless we know we're running inside of a coroutine. */ if (rdma->migrationstartedondestination) { yielduntilfdreadable(rdma->compchannel->fd); } if (ibvgetcqevent(rdma->compchannel, &cq, &cqctx)) { perror(\"ibvgetcqevent\"); goto errblockforwrid; } numcqevents++; if (ibvreqnotifycq(cq, 0)) { goto errblockforwrid; } while (wrid != wridrequested) { ret = qemurdmapoll(rdma, &wridin); if (ret < 0) { goto errblockforwrid; } wrid = wridin & RDMAWRIDTYPEMASK; if (wrid == RDMAWRIDNONE) { break; } if (wrid != wridrequested) { DDDPRINTF(\"B Wanted wrid %s (%d) but got %s (%\" PRIu64 \")\\n\", printwrid(wridrequested), wridrequested, printwrid(wrid), wrid); } } if (wrid == wridrequested) { goto successblockforwrid; } } successblockforwrid: if (numcqevents) { ibvackcqevents(cq, numcqevents); } return 0; errblockforwrid: if (numcqevents) { ibvackcqevents(cq, numcqevents); } return ret; } ", "target": 0}
{"func": "static inline void RENAME(rgb15to32)(const uint8t *src, uint8t *dst, int srcsize) { const uint16t *end; const uint16t *mmend; uint8t *d = dst; const uint16t *s = (const uint16t *)src; end = s + srcsize/2; asm volatile(PREFETCH\" %0\"::\"m\"(*s):\"memory\"); asm volatile(\"pxor %%mm7,%%mm7 \\n\\t\":::\"memory\"); asm volatile(\"pcmpeqd %%mm6,%%mm6 \\n\\t\":::\"memory\"); mmend = end - 3; while (s < mmend) { asm volatile( PREFETCH\" 32%1 \\n\\t\" \"movq %1, %%mm0 \\n\\t\" \"movq %1, %%mm1 \\n\\t\" \"movq %1, %%mm2 \\n\\t\" \"pand %2, %%mm0 \\n\\t\" \"pand %3, %%mm1 \\n\\t\" \"pand %4, %%mm2 \\n\\t\" \"psllq $3, %%mm0 \\n\\t\" \"psrlq $2, %%mm1 \\n\\t\" \"psrlq $7, %%mm2 \\n\\t\" PACKRGB32 :\"=m\"(*d) :\"m\"(*s),\"m\"(mask15b),\"m\"(mask15g),\"m\"(mask15r) :\"memory\"); d += 16; s += 4; } asm volatile(SFENCE:::\"memory\"); asm volatile(EMMS:::\"memory\"); while (s < end) { register uint16t bgr; bgr = *s++; *d++ = (bgr&0x1F)<<3; *d++ = (bgr&0x3E0)>>2; *d++ = (bgr&0x7C00)>>7; *d++ = 255; } } ", "target": 1}
{"func": "static int muxchrcanread(void *opaque) { CharDriverState *chr = opaque; MuxDriver *d = chr->opaque; if ((d->prod - d->cons) < MUXBUFFERSIZE) return 1; if (d->chrcanread[chr->focus]) return d->chrcanread[chr->focus](d->extopaque[chr->focus]); return 0; } ", "target": 1}
{"func": "static inline bool vtdqueuedinvenablecheck(IntelIOMMUState *s) { return s->iqtail == 0; } ", "target": 1}
{"func": "static avalwaysinline void hcscale(SwsContext *c, int16t *dst1, int16t *dst2, int dstWidth, const uint8t *srcin[4], int srcW, int xInc, const int16t *hChrFilter, const int16t *hChrFilterPos, int hChrFilterSize, uint8t *formatConvBuffer, uint32t *pal) { const uint8t *src1 = srcin[1], *src2 = srcin[2]; if (c->chrToYV12) { uint8t *buf2 = formatConvBuffer + FFALIGN(srcW * FFALIGN(c->srcBpc, 8) >> 3, 16); c->chrToYV12(formatConvBuffer, buf2, src1, src2, srcW, pal); src1= formatConvBuffer; src2= buf2; } else if (c->readChrPlanar) { uint8t *buf2 = formatConvBuffer + FFALIGN(srcW * FFALIGN(c->srcBpc, 8) >> 3, 16); c->readChrPlanar(formatConvBuffer, buf2, srcin, srcW); src1= formatConvBuffer; src2= buf2; } if (!c->hcscalefast) { c->hcScale(c, dst1, dstWidth, src1, hChrFilter, hChrFilterPos, hChrFilterSize); c->hcScale(c, dst2, dstWidth, src2, hChrFilter, hChrFilterPos, hChrFilterSize); } else { // fast bilinear upscale / crap downscale c->hcscalefast(c, dst1, dst2, dstWidth, src1, src2, srcW, xInc); } if (c->chrConvertRange) c->chrConvertRange(dst1, dst2, dstWidth); } ", "target": 1}
{"func": "static int coroutinefn bdrvcodocopyonreadv(BdrvChild *child, int64t offset, unsigned int bytes, QEMUIOVector *qiov) { BlockDriverState *bs = child->bs; /* Perform I/O through a temporary buffer so that users who scribble over * their read buffer while the operation is in progress do not end up * modifying the image file. This is critical for zero-copy guest I/O * where anything might happen inside guest memory. */ void *bouncebuffer; BlockDriver *drv = bs->drv; struct iovec iov; QEMUIOVector localqiov; int64t clusteroffset; int64t clusterbytes; sizet skipbytes; int ret; int maxtransfer = MINNONZERO(bs->bl.maxtransfer, BDRVREQUESTMAXBYTES); unsigned int progress = 0; /* FIXME We cannot require callers to have write permissions when all they * are doing is a read request. If we did things right, write permissions * would be obtained anyway, but internally by the copy-on-read code. As * long as it is implemented here rather than in a separate filter driver, * the copy-on-read code doesn't have its own BdrvChild, however, for which * it could request permissions. Therefore we have to bypass the permission * system for the moment. */ // assert(child->perm & (BLKPERMWRITEUNCHANGED | BLKPERMWRITE)); /* Cover entire cluster so no additional backing file I/O is required when * allocating cluster in the image file. Note that this value may exceed * BDRVREQUESTMAXBYTES (even when the original read did not), which * is one reason we loop rather than doing it all at once. */ bdrvroundtoclusters(bs, offset, bytes, &clusteroffset, &clusterbytes); skipbytes = offset - clusteroffset; tracebdrvcodocopyonreadv(bs, offset, bytes, clusteroffset, clusterbytes); bouncebuffer = qemutryblockalign(bs, MIN(MIN(maxtransfer, clusterbytes), MAXBOUNCEBUFFER)); if (bouncebuffer == NULL) { ret = -ENOMEM; goto err; while (clusterbytes) { int64t pnum; ret = bdrvisallocated(bs, clusteroffset, MIN(clusterbytes, maxtransfer), &pnum); if (ret < 0) { /* Safe to treat errors in querying allocation as if * unallocated; we'll probably fail again soon on the * read, but at least that will set a decent errno. */ pnum = MIN(clusterbytes, maxtransfer); assert(skipbytes < pnum); if (ret <= 0) { /* Must copy-on-read; use the bounce buffer */ iov.iovbase = bouncebuffer; iov.iovlen = pnum = MIN(pnum, MAXBOUNCEBUFFER); qemuiovecinitexternal(&localqiov, &iov, 1); ret = bdrvdriverpreadv(bs, clusteroffset, pnum, &localqiov, 0); if (ret < 0) { goto err; bdrvdebugevent(bs, BLKDBGCORWRITE); if (drv->bdrvcopwritezeroes && bufferiszero(bouncebuffer, pnum)) { /* FIXME: Should we (perhaps conditionally) be setting * BDRVREQMAYUNMAP, if it will allow for a sparser copy * that still correctly reads as zero? */ ret = bdrvcodopwritezeroes(bs, clusteroffset, pnum, 0); } else { /* This does not change the data on the disk, it is not * necessary to flush even in cache=writethrough mode. */ ret = bdrvdriverpwritev(bs, clusteroffset, pnum, &localqiov, 0); if (ret < 0) { /* It might be okay to ignore write errors for guest * requests. If this is a deliberate copy-on-read * then we don't want to ignore the error. Simply * report it in all cases. */ goto err; qemuiovecfrombuf(qiov, progress, bouncebuffer + skipbytes, pnum - skipbytes); } else { /* Read directly into the destination */ qemuiovecinit(&localqiov, qiov->niov); qemuiovecconcat(&localqiov, qiov, progress, pnum - skipbytes); ret = bdrvdriverpreadv(bs, offset + progress, localqiov.size, &localqiov, 0); qemuiovecdestroy(&localqiov); if (ret < 0) { goto err; clusteroffset += pnum; clusterbytes -= pnum; progress += pnum - skipbytes; skipbytes = 0; ret = 0; err: qemuvfree(bouncebuffer); return ret;", "target": 1}
{"func": "static void virtioscsideviceunrealize(DeviceState *dev, Error **errp) { virtioscsicommonunrealize(dev, errp); }", "target": 1}
{"func": "static int protocolclientinit(VncState *vs, uint8t *data, sizet len) { char buf[1024]; VncShareMode mode; int size; mode = data[0] ? VNCSHAREMODESHARED : VNCSHAREMODEEXCLUSIVE; switch (vs->vd->sharepolicy) { case VNCSHAREPOLICYIGNORE: /* * Ignore the shared flag. Nothing to do here. * * Doesn't conform to the rfb spec but is traditional qemu * behavior, thus left here as option for compatibility * reasons. */ break; case VNCSHAREPOLICYALLOWEXCLUSIVE: /* * Policy: Allow clients ask for exclusive access. * * Implementation: When a client asks for exclusive access, * disconnect all others. Shared connects are allowed as long * as no exclusive connection exists. * * This is how the rfb spec suggests to handle the shared flag. */ if (mode == VNCSHAREMODEEXCLUSIVE) { VncState *client; QTAILQFOREACH(client, &vs->vd->clients, next) { if (vs == client) { continue; } if (client->sharemode != VNCSHAREMODEEXCLUSIVE && client->sharemode != VNCSHAREMODESHARED) { continue; } vncdisconnectstart(client); } } if (mode == VNCSHAREMODESHARED) { if (vs->vd->numexclusive > 0) { vncdisconnectstart(vs); return 0; } } break; case VNCSHAREPOLICYFORCESHARED: /* * Policy: Shared connects only. * Implementation: Disallow clients asking for exclusive access. * * Useful for shared desktop sessions where you don't want * someone forgetting to say -shared when running the vnc * client disconnect everybody else. */ if (mode == VNCSHAREMODEEXCLUSIVE) { vncdisconnectstart(vs); return 0; } break; } vncsetsharemode(vs, mode); vs->clientwidth = surfacewidth(vs->vd->ds); vs->clientheight = surfaceheight(vs->vd->ds); vncwriteu16(vs, vs->clientwidth); vncwriteu16(vs, vs->clientheight); pixelformatmessage(vs); if (qemuname) size = snprintf(buf, sizeof(buf), \"QEMU (%s)\", qemuname); else size = snprintf(buf, sizeof(buf), \"QEMU\"); vncwriteu32(vs, size); vncwrite(vs, buf, size); vncflush(vs); vncclientcacheauth(vs); vncqmpevent(vs, QAPIEVENTVNCINITIALIZED); vncreadwhen(vs, protocolclientmsg, 1); return 0; } ", "target": 1}
{"func": "static void avclumahvqrtandaverdst4x4msa(const uint8t *srcx, const uint8t *srcy, int32t srcstride, uint8t *dst, int32t dststride) { v16i8 srchz0, srchz1, srchz2, srchz3; v16u8 dst0, dst1, dst2, dst3; v16i8 srcvt0, srcvt1, srcvt2, srcvt3, srcvt4; v16i8 srcvt5, srcvt6, srcvt7, srcvt8; v16i8 mask0, mask1, mask2; v8i16 hzout0, hzout1, vertout0, vertout1; v8i16 res0, res1; v16u8 res; LDSB3(&lumamaskarr[48], 16, mask0, mask1, mask2); LDSB5(srcy, srcstride, srcvt0, srcvt1, srcvt2, srcvt3, srcvt4); srcy += (5 * srcstride); srcvt0 = (v16i8) msainsvew((v4i32) srcvt0, 1, (v4i32) srcvt1); srcvt1 = (v16i8) msainsvew((v4i32) srcvt1, 1, (v4i32) srcvt2); srcvt2 = (v16i8) msainsvew((v4i32) srcvt2, 1, (v4i32) srcvt3); srcvt3 = (v16i8) msainsvew((v4i32) srcvt3, 1, (v4i32) srcvt4); XORIB4128SB(srcvt0, srcvt1, srcvt2, srcvt3); LDSB4(srcx, srcstride, srchz0, srchz1, srchz2, srchz3); LDUB4(dst, dststride, dst0, dst1, dst2, dst3); XORIB4128SB(srchz0, srchz1, srchz2, srchz3); hzout0 = AVCXORVSHFBANDAPPLY6TAPHORIZFILTSH(srchz0, srchz1, mask0, mask1, mask2); hzout1 = AVCXORVSHFBANDAPPLY6TAPHORIZFILTSH(srchz2, srchz3, mask0, mask1, mask2); SRARIH2SH(hzout0, hzout1, 5); SATSH2SH(hzout0, hzout1, 7); LDSB4(srcy, srcstride, srcvt5, srcvt6, srcvt7, srcvt8); srcvt4 = (v16i8) msainsvew((v4i32) srcvt4, 1, (v4i32) srcvt5); srcvt5 = (v16i8) msainsvew((v4i32) srcvt5, 1, (v4i32) srcvt6); srcvt6 = (v16i8) msainsvew((v4i32) srcvt6, 1, (v4i32) srcvt7); srcvt7 = (v16i8) msainsvew((v4i32) srcvt7, 1, (v4i32) srcvt8); XORIB4128SB(srcvt4, srcvt5, srcvt6, srcvt7); /* filter calc */ vertout0 = AVCCALCDPADDB6PIX2COEFFRSH(srcvt0, srcvt1, srcvt2, srcvt3, srcvt4, srcvt5); vertout1 = AVCCALCDPADDB6PIX2COEFFRSH(srcvt2, srcvt3, srcvt4, srcvt5, srcvt6, srcvt7); SRARIH2SH(vertout0, vertout1, 5); SATSH2SH(vertout0, vertout1, 7); res1 = msasrarih((hzout1 + vertout1), 1); res0 = msasrarih((hzout0 + vertout0), 1); SATSH2SH(res0, res1, 7); res = PCKEVXORI128UB(res0, res1); dst0 = (v16u8) msainsvew((v4i32) dst0, 1, (v4i32) dst1); dst1 = (v16u8) msainsvew((v4i32) dst2, 1, (v4i32) dst3); dst0 = (v16u8) msainsved((v2i64) dst0, 1, (v2i64) dst1); dst0 = msaaverub(res, dst0); ST4x4UB(dst0, dst0, 0, 1, 2, 3, dst, dststride); } ", "target": 0}
{"func": "static BlockDriverAIOCB *rawaioreadv(BlockDriverState *bs, int64t sectornum, QEMUIOVector *qiov, int nbsectors, BlockDriverCompletionFunc *cb, void *opaque) { BDRVRawState *s = bs->opaque; return paiosubmit(bs, s->hfile, sectornum, qiov, nbsectors, cb, opaque, QEMUAIOREAD); } ", "target": 0}
{"func": "static void tcxblitwritel(void *opaque, hwaddr addr, uint64t val, unsigned size) { TCXState *s = opaque; uint32t adsr, len; int i; if (!(addr & 4)) { s->tmpblit = val; } else { addr = (addr >> 3) & 0xfffff; adsr = val & 0xffffff; len = ((val >> 24) & 0x1f) + 1; if (adsr == 0xffffff) { memset(&s->vram[addr], s->tmpblit, len); if (s->depth == 24) { val = s->tmpblit & 0xffffff; val = cputobe32(val); for (i = 0; i < len; i++) { s->vram24[addr + i] = val; } } } else { memcpy(&s->vram[addr], &s->vram[adsr], len); if (s->depth == 24) { memcpy(&s->vram24[addr], &s->vram24[adsr], len * 4); } } memoryregionsetdirty(&s->vrammem, addr, len); } } ", "target": 0}
{"func": "static void avcloopfiltercborcrintraedgevermsa(uint8t *datacborcr, uint8t alphain, uint8t betain, uint32t imgwidth) { uint16t out0, out1, out2, out3; v8i16 tmp1; v16u8 alpha, beta, islessthan; v8i16 p0orq0, q0orp0; v16u8 p1orq1org, p0orq0org, q0orp0org, q1orp1org; v16i8 zero = { 0 }; v16u8 p0asubq0, p1asubp0, q1asubq0; v16u8 islessthanalpha, islessthanbeta; v8i16 p1orgr, p0orgr, q0orgr, q1orgr; { v16u8 row0, row1, row2, row3, row4, row5, row6, row7; LOAD8VECSUB((datacborcr - 2), imgwidth, row0, row1, row2, row3, row4, row5, row6, row7); TRANSPOSE8x4BUB(row0, row1, row2, row3, row4, row5, row6, row7, p1orq1org, p0orq0org, q0orp0org, q1orp1org); } alpha = (v16u8) msafillb(alphain); beta = (v16u8) msafillb(betain); p0asubq0 = msaasubub(p0orq0org, q0orp0org); p1asubp0 = msaasubub(p1orq1org, p0orq0org); q1asubq0 = msaasubub(q1orp1org, q0orp0org); islessthanalpha = (p0asubq0 < alpha); islessthanbeta = (p1asubp0 < beta); islessthan = islessthanbeta & islessthanalpha; islessthanbeta = (q1asubq0 < beta); islessthan = islessthanbeta & islessthan; islessthan = (v16u8) msailvrd((v2i64) zero, (v2i64) islessthan); if (!msatestbzv(islessthan)) { p1orgr = (v8i16) msailvrb(zero, (v16i8) p1orq1org); p0orgr = (v8i16) msailvrb(zero, (v16i8) p0orq0org); q0orgr = (v8i16) msailvrb(zero, (v16i8) q0orp0org); q1orgr = (v8i16) msailvrb(zero, (v16i8) q1orp1org); AVCLOOPFILTERP0ORQ0(p0orgr, q1orgr, p1orgr, p0orq0); AVCLOOPFILTERP0ORQ0(q0orgr, p1orgr, q1orgr, q0orp0); /* convert 16 bit output into 8 bit output */ p0orq0 = (v8i16) msapckevb(zero, (v16i8) p0orq0); q0orp0 = (v8i16) msapckevb(zero, (v16i8) q0orp0); p0orq0org = msabmnzv(p0orq0org, (v16u8) p0orq0, islessthan); q0orp0org = msabmnzv(q0orp0org, (v16u8) q0orp0, islessthan); tmp1 = (v8i16) msailvrb((v16i8) q0orp0org, (v16i8) p0orq0org); datacborcr -= 1; out0 = msacopyuh(tmp1, 0); out1 = msacopyuh(tmp1, 1); out2 = msacopyuh(tmp1, 2); out3 = msacopyuh(tmp1, 3); STOREHWORD(datacborcr, out0); datacborcr += imgwidth; STOREHWORD(datacborcr, out1); datacborcr += imgwidth; STOREHWORD(datacborcr, out2); datacborcr += imgwidth; STOREHWORD(datacborcr, out3); datacborcr += imgwidth; out0 = msacopyuh(tmp1, 4); out1 = msacopyuh(tmp1, 5); out2 = msacopyuh(tmp1, 6); out3 = msacopyuh(tmp1, 7); STOREHWORD(datacborcr, out0); datacborcr += imgwidth; STOREHWORD(datacborcr, out1); datacborcr += imgwidth; STOREHWORD(datacborcr, out2); datacborcr += imgwidth; STOREHWORD(datacborcr, out3); } } ", "target": 0}
{"func": "int ffh261handlepacket(AVFormatContext *ctx, PayloadContext *data, AVStream *st, AVPacket *pkt, uint32t *timestamp, const uint8t *buf, int len, uint16t seq, int flags) { int sbit, ebit, gobn, mbap, quant; int res; //avlog(ctx, AVLOGDEBUG, \"got h261 RTP packet with time: %u\\n\", timestamp); /* drop data of previous packets in case of non-continuous (loss) packet stream */ if (data->buf && data->timestamp != *timestamp) { h261freedynbuffer(&data->buf); } /* sanity check for size of input packet */ if (len < 5 /* 4 bytes header and 1 byte payload at least */) { avlog(ctx, AVLOGERROR, \"Too short H.261 RTP packet\\n\"); return AVERRORINVALIDDATA; } /* decode the H.261 payload header according to section 4.1 of RFC 4587: (uses 4 bytes between RTP header and H.261 stream per packet) 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |SBIT |EBIT |I|V| GOBN | MBAP | QUANT | HMVD | VMVD | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Start bit position (SBIT): 3 bits End bit position (EBIT): 3 bits INTRA-frame encoded data (I): 1 bit Motion Vector flag (V): 1 bit GOB number (GOBN): 4 bits Macroblock address predictor (MBAP): 5 bits Quantizer (QUANT): 5 bits Horizontal motion vector data (HMVD): 5 bits Vertical motion vector data (VMVD): 5 bits */ sbit = (buf[0] >> 5) & 0x07; ebit = (buf[0] >> 2) & 0x07; gobn = (buf[1] >> 4) & 0x0f; mbap = ((buf[1] << 1) & 0x1e) | ((buf[1] >> 7) & 0x01); quant = (buf[1] >> 4) & 0x0f; /* pass the H.261 payload header and continue with the actual payload */ buf += RTPH261PAYLOADHEADERSIZE; len -= RTPH261PAYLOADHEADERSIZE; /* start frame buffering with new dynamic buffer */ if (!data->buf) { /* sanity check: a new frame starts with gobn=0, sbit=0, mbap=0, uqnat=0 */ if (!gobn && !sbit && !mbap && !quant){ res = avioopendynbuf(&data->buf); if (res < 0) return res; /* update the timestamp in the frame packet with the one from the RTP packet */ data->timestamp = *timestamp; } else { /* frame not started yet, need more packets */ return AVERROR(EAGAIN); } } /* do the \"byte merging\" at the boundaries of two consecutive frame fragments */ if (data->endbytebits || sbit) { if (data->endbytebits == sbit) { data->endbyte |= buf[0] & (0xff >> sbit); data->endbytebits = 0; buf++; len--; aviow8(data->buf, data->endbyte); } else { /* ebit/sbit values inconsistent, assuming packet loss */ GetBitContext gb; initgetbits(&gb, buf, len*8 - ebit); skipbits(&gb, sbit); if (data->endbytebits) { data->endbyte |= getbits(&gb, 8 - data->endbytebits); aviow8(data->buf, data->endbyte); } while (getbitsleft(&gb) >= 8) aviow8(data->buf, getbits(&gb, 8)); data->endbytebits = getbitsleft(&gb); if (data->endbytebits) data->endbyte = getbits(&gb, data->endbytebits) << (8 - data->endbytebits); ebit = 0; len = 0; } } if (ebit) { if (len > 0) aviowrite(data->buf, buf, len - 1); data->endbytebits = 8 - ebit; data->endbyte = buf[len - 1] & (0xff << ebit); } else { aviowrite(data->buf, buf, len); } /* RTP marker bit means: last fragment of current frame was received; otherwise, an additional fragment is needed for the current frame */ if (!(flags & RTPFLAGMARKER)) return AVERROR(EAGAIN); /* write the completed last byte from the \"byte merging\" */ if (data->endbytebits) aviow8(data->buf, data->endbyte); data->endbytebits = 0; /* close frame buffering and create resulting A/V packet */ res = ffrtpfinalizepacket(pkt, &data->buf, st->index); if (res < 0) return res; return 0; } ", "target": 1}
{"func": "static int vdpaumpegstartframe(AVCodecContext *avctx, const uint8t *buffer, uint32t size) { MpegEncContext * const s = avctx->privdata; Picture *pic = s->currentpictureptr; struct vdpaupicturecontext *picctx = pic->hwaccelpictureprivate; VdpPictureInfoMPEG1Or2 *info = &picctx->info.mpeg; VdpVideoSurface ref; int i; /* fill VdpPictureInfoMPEG1Or2 struct */ info->forwardreference = VDPINVALIDHANDLE; info->backwardreference = VDPINVALIDHANDLE; switch (s->picttype) { case AVPICTURETYPEB: ref = ffvdpaugetsurfaceid(&s->nextpicture.f); assert(ref != VDPINVALIDHANDLE); info->backwardreference = ref; /* fall through to forward prediction */ case AVPICTURETYPEP: ref = ffvdpaugetsurfaceid(&s->lastpicture.f); info->forwardreference = ref; } info->slicecount = 0; info->picturestructure = s->picturestructure; info->picturecodingtype = s->picttype; info->intradcprecision = s->intradcprecision; info->framepredframedct = s->framepredframedct; info->concealmentmotionvectors = s->concealmentmotionvectors; info->intravlcformat = s->intravlcformat; info->alternatescan = s->alternatescan; info->qscaletype = s->qscaletype; info->topfieldfirst = s->topfieldfirst; // Both for MPEG-1 only, zero for MPEG-2: info->fullpelforwardvector = s->fullpel[0]; info->fullpelbackwardvector = s->fullpel[1]; // For MPEG-1 fill both horizontal & vertical: info->fcode[0][0] = s->mpegfcode[0][0]; info->fcode[0][1] = s->mpegfcode[0][1]; info->fcode[1][0] = s->mpegfcode[1][0]; info->fcode[1][1] = s->mpegfcode[1][1]; for (i = 0; i < 64; ++i) { info->intraquantizermatrix[i] = s->intramatrix[i]; info->nonintraquantizermatrix[i] = s->intermatrix[i]; } return ffvdpaucommonstartframe(picctx, buffer, size); } ", "target": 1}
{"func": "void h263decodeinitvlc(MpegEncContext *s) { static int done = 0; if (!done) { done = 1; initvlc(&intraMCBPCvlc, INTRAMCBPCVLCBITS, 9, intraMCBPCbits, 1, 1, intraMCBPCcode, 1, 1); initvlc(&interMCBPCvlc, INTERMCBPCVLCBITS, 28, interMCBPCbits, 1, 1, interMCBPCcode, 1, 1); initvlc(&cbpyvlc, CBPYVLCBITS, 16, &cbpytab[0][1], 2, 1, &cbpytab[0][0], 2, 1); initvlc(&mvvlc, MVVLCBITS, 33, &mvtab[0][1], 2, 1, &mvtab[0][0], 2, 1); initrl(&rlinter); initrl(&rlintra); initrl(&rvlcrlinter); initrl(&rvlcrlintra); initrl(&rlintraaic); initvlcrl(&rlinter); initvlcrl(&rlintra); initvlcrl(&rvlcrlinter); initvlcrl(&rvlcrlintra); initvlcrl(&rlintraaic); initvlc(&dclum, DCVLCBITS, 10 /* 13 */, &DCtablum[0][1], 2, 1, &DCtablum[0][0], 2, 1); initvlc(&dcchrom, DCVLCBITS, 10 /* 13 */, &DCtabchrom[0][1], 2, 1, &DCtabchrom[0][0], 2, 1); initvlc(&spritetrajectory, SPRITETRAJVLCBITS, 15, &spritetrajectorytab[0][1], 4, 2, &spritetrajectorytab[0][0], 4, 2); initvlc(&mbtypebvlc, MBTYPEBVLCBITS, 4, &mbtypebtab[0][1], 2, 1, &mbtypebtab[0][0], 2, 1); initvlc(&h263mbtypebvlc, H263MBTYPEBVLCBITS, 15, &h263mbtypebtab[0][1], 2, 1, &h263mbtypebtab[0][0], 2, 1); initvlc(&cbpcbvlc, CBPCBVLCBITS, 4, &cbpcbtab[0][1], 2, 1, &cbpcbtab[0][0], 2, 1); } } ", "target": 1}
{"func": "static uint64t icppitread(void *opaque, targetphysaddrt offset, unsigned size) { icppitstate *s = (icppitstate *)opaque; int n; /* ??? Don't know the PrimeCell ID for this device. */ n = offset >> 8; if (n > 3) { hwerror(\"sp804read: Bad timer %d\\n\", n); } return armtimerread(s->timer[n], offset & 0xff); } ", "target": 1}
{"func": "static int mpeg1decodesequence(AVCodecContext *avctx, UINT8 *buf, int bufsize) { Mpeg1Context *s1 = avctx->privdata; MpegEncContext *s = &s1->mpegencctx; int width, height, i, v, j; initgetbits(&s->gb, buf, bufsize); width = getbits(&s->gb, 12); height = getbits(&s->gb, 12); skipbits(&s->gb, 4); s->framerateindex = getbits(&s->gb, 4); if (s->framerateindex == 0) return -1; s->bitrate = getbits(&s->gb, 18) * 400; if (getbits1(&s->gb) == 0) /* marker */ return -1; if (width <= 0 || height <= 0 || (width % 2) != 0 || (height % 2) != 0) return -1; if (width != s->width || height != s->height) { /* start new mpeg1 context decoding */ s->outformat = FMTMPEG1; if (s1->mpegencctxallocated) { MPVcommonend(s); } s->width = width; s->height = height; s->hasbframes = 1; s->avctx = avctx; avctx->width = width; avctx->height = height; avctx->framerate = frameratetab[s->framerateindex]; s->framerate = avctx->framerate; avctx->bitrate = s->bitrate; if (MPVcommoninit(s) < 0) return -1; mpeg1initvlc(s); s1->mpegencctxallocated = 1; } skipbits(&s->gb, 10); /* vbvbuffersize */ skipbits(&s->gb, 1); /* get matrix */ if (getbits1(&s->gb)) { for(i=0;i<64;i++) { v = getbits(&s->gb, 8); j = zigzagdirect[i]; s->intramatrix[j] = v; s->chromaintramatrix[j] = v; } #ifdef DEBUG dprintf(\"intra matrix present\\n\"); for(i=0;i<64;i++) dprintf(\" %d\", s->intramatrix[zigzagdirect[i]]); printf(\"\\n\"); #endif } else { for(i=0;i<64;i++) { v = defaultintramatrix[i]; s->intramatrix[i] = v; s->chromaintramatrix[i] = v; } } if (getbits1(&s->gb)) { for(i=0;i<64;i++) { v = getbits(&s->gb, 8); j = zigzagdirect[i]; s->nonintramatrix[j] = v; s->chromanonintramatrix[j] = v; } #ifdef DEBUG dprintf(\"non intra matrix present\\n\"); for(i=0;i<64;i++) dprintf(\" %d\", s->nonintramatrix[zigzagdirect[i]]); printf(\"\\n\"); #endif } else { for(i=0;i<64;i++) { v = defaultnonintramatrix[i]; s->nonintramatrix[i] = v; s->chromanonintramatrix[i] = v; } } /* we set mpeg2 parameters so that it emulates mpeg1 */ s->progressivesequence = 1; s->progressiveframe = 1; s->picturestructure = PICTFRAME; s->framepredframedct = 1; s->mpeg2 = 0; return 0; } ", "target": 1}
{"func": "void ffrfpscalculate(AVFormatContext *ic) { int i, j; for (i = 0; i<ic->nbstreams; i++) { AVStream *st = ic->streams[i]; if (st->codec->codectype != AVMEDIATYPEVIDEO) // the check for tbunreliable() is not completely correct, since this is not about handling // a unreliable/inexact time base, but a time base that is finer than necessary, as e.g. // ipmovie.c produces. if (tbunreliable(st->codec) && st->info->durationcount > 15 && st->info->durationgcd > FFMAX(1, st->timebase.den/(500LL*st->timebase.num)) && !st->rframerate.num) avreduce(&st->rframerate.num, &st->rframerate.den, st->timebase.den, st->timebase.num * st->info->durationgcd, INTMAX); if (st->info->durationcount>1 && !st->rframerate.num && tbunreliable(st->codec)) { int num = 0; double besterror= 0.01; for (j=0; j<MAXSTDTIMEBASES; j++) { int k; if(st->info->codecinfoduration && st->info->codecinfoduration*avq2d(st->timebase) < (1001*12.0)/getstdframerate(j)) if(!st->info->codecinfoduration && 1.0 < (1001*12.0)/getstdframerate(j)) for(k=0; k<2; k++){ int n= st->info->durationcount; double a= st->info->durationerror[k][0][j] / n; double error= st->info->durationerror[k][1][j]/n - a*a; if(error < besterror && besterror> 0.000000001){ besterror= error; num = getstdframerate(j); } if(error < 0.02) avlog(NULL, AVLOGDEBUG, \"rfps: %f %f\\n\", getstdframerate(j) / 12.0/1001, error); } } // do not increase frame rate by more than 1 % in order to match a standard rate. if (num && (!st->rframerate.num || (double)num/(12*1001) < 1.01 * avq2d(st->rframerate))) avreduce(&st->rframerate.num, &st->rframerate.den, num, 12*1001, INTMAX); } avfreep(&st->info->durationerror); st->info->lastdts = AVNOPTSVALUE; st->info->durationcount = 0; st->info->rfpsdurationsum = 0; } }", "target": 1}
{"func": "static void gencomputeeflagso(DisasContext *s, TCGv reg) { gencomputeeflags(s); tcggenshritl(reg, cpuccsrc, 11); tcggenanditl(reg, reg, 1); } ", "target": 0}
{"func": "static void predspatialdirectmotion(const H264Context *const h, H264SliceContext *sl, int *mbtype) { int b8stride = 2; int b4stride = h->bstride; int mbxy = sl->mbxy, mby = sl->mby; int mbtypecol[2]; const int16t (*l1mv0)[2], (*l1mv1)[2]; const int8t *l1ref0, *l1ref1; const int isb8x8 = IS8X8(*mbtype); unsigned int submbtype = MBTYPEL0L1; int i8, i4; int ref[2]; int mv[2]; int list; assert(sl->reflist[1][0].reference & 3); awaitreferencembrow(h, sl->reflist[1][0].parent, sl->mby + !!ISINTERLACED(*mbtype)); #define MBTYPE16x16ORINTRA (MBTYPE16x16 | MBTYPEINTRA4x4 | \\ MBTYPEINTRA16x16 | MBTYPEINTRAPCM) /* ref = min(neighbors) */ for (list = 0; list < 2; list++) { int leftref = sl->refcache[list][scan8[0] - 1]; int topref = sl->refcache[list][scan8[0] - 8]; int refc = sl->refcache[list][scan8[0] - 8 + 4]; const int16t *C = sl->mvcache[list][scan8[0] - 8 + 4]; if (refc == PARTNOTAVAILABLE) { refc = sl->refcache[list][scan8[0] - 8 - 1]; C = sl->mvcache[list][scan8[0] - 8 - 1]; } ref[list] = FFMIN3((unsigned)leftref, (unsigned)topref, (unsigned)refc); if (ref[list] >= 0) { /* This is just predmotion() but with the cases removed that * cannot happen for direct blocks. */ const int16t *const A = sl->mvcache[list][scan8[0] - 1]; const int16t *const B = sl->mvcache[list][scan8[0] - 8]; int matchcount = (leftref == ref[list]) + (topref == ref[list]) + (refc == ref[list]); if (matchcount > 1) { // most common mv[list] = pack16to32(midpred(A[0], B[0], C[0]), midpred(A[1], B[1], C[1])); } else { assert(matchcount == 1); if (leftref == ref[list]) mv[list] = AVRN32A(A); else if (topref == ref[list]) mv[list] = AVRN32A(B); else mv[list] = AVRN32A(C); } } else { int mask = ~(MBTYPEL0 << (2 * list)); mv[list] = 0; ref[list] = -1; if (!isb8x8) *mbtype &= mask; submbtype &= mask; } } if (ref[0] < 0 && ref[1] < 0) { ref[0] = ref[1] = 0; if (!isb8x8) *mbtype |= MBTYPEL0L1; submbtype |= MBTYPEL0L1; } if (!(isb8x8 | mv[0] | mv[1])) { fillrectangle(&sl->refcache[0][scan8[0]], 4, 4, 8, (uint8t)ref[0], 1); fillrectangle(&sl->refcache[1][scan8[0]], 4, 4, 8, (uint8t)ref[1], 1); fillrectangle(&sl->mvcache[0][scan8[0]], 4, 4, 8, 0, 4); fillrectangle(&sl->mvcache[1][scan8[0]], 4, 4, 8, 0, 4); *mbtype = (*mbtype & ~(MBTYPE8x8 | MBTYPE16x8 | MBTYPE8x16 | MBTYPEP1L0 | MBTYPEP1L1)) | MBTYPE16x16 | MBTYPEDIRECT2; return; } if (ISINTERLACED(sl->reflist[1][0].parent->mbtype[mbxy])) { // AFL/AFR/FR/FL -> AFL/FL if (!ISINTERLACED(*mbtype)) { // AFR/FR -> AFL/FL mby = (sl->mby & ~1) + sl->colparity; mbxy = sl->mbx + ((sl->mby & ~1) + sl->colparity) * h->mbstride; b8stride = 0; } else { mby += sl->colfieldoff; mbxy += h->mbstride * sl->colfieldoff; // non-zero for FL -> FL & differ parity } goto singlecol; } else { // AFL/AFR/FR/FL -> AFR/FR if (ISINTERLACED(*mbtype)) { // AFL /FL -> AFR/FR mby = sl->mby & ~1; mbxy = (sl->mby & ~1) * h->mbstride + sl->mbx; mbtypecol[0] = sl->reflist[1][0].parent->mbtype[mbxy]; mbtypecol[1] = sl->reflist[1][0].parent->mbtype[mbxy + h->mbstride]; b8stride = 2 + 4 * h->mbstride; b4stride *= 6; if (ISINTERLACED(mbtypecol[0]) != ISINTERLACED(mbtypecol[1])) { mbtypecol[0] &= ~MBTYPEINTERLACED; mbtypecol[1] &= ~MBTYPEINTERLACED; } submbtype |= MBTYPE16x16 | MBTYPEDIRECT2; /* BSUB8x8 */ if ((mbtypecol[0] & MBTYPE16x16ORINTRA) && (mbtypecol[1] & MBTYPE16x16ORINTRA) && !isb8x8) { *mbtype |= MBTYPE16x8 | MBTYPEDIRECT2; /* B16x8 */ } else { *mbtype |= MBTYPE8x8; } } else { // AFR/FR -> AFR/FR singlecol: mbtypecol[0] = mbtypecol[1] = sl->reflist[1][0].parent->mbtype[mbxy]; submbtype |= MBTYPE16x16 | MBTYPEDIRECT2; /* BSUB8x8 */ if (!isb8x8 && (mbtypecol[0] & MBTYPE16x16ORINTRA)) { *mbtype |= MBTYPE16x16 | MBTYPEDIRECT2; /* B16x16 */ } else if (!isb8x8 && (mbtypecol[0] & (MBTYPE16x8 | MBTYPE8x16))) { *mbtype |= MBTYPEDIRECT2 | (mbtypecol[0] & (MBTYPE16x8 | MBTYPE8x16)); } else { if (!h->sps.direct8x8inferenceflag) { /* FIXME: Save sub mb types from previous frames (or derive * from MVs) so we know exactly what block size to use. */ submbtype += (MBTYPE8x8 - MBTYPE16x16); /* BSUB4x4 */ } *mbtype |= MBTYPE8x8; } } } awaitreferencembrow(h, sl->reflist[1][0].parent, mby); l1mv0 = &sl->reflist[1][0].parent->motionval[0][h->mb2bxy[mbxy]]; l1mv1 = &sl->reflist[1][0].parent->motionval[1][h->mb2bxy[mbxy]]; l1ref0 = &sl->reflist[1][0].parent->refindex[0][4 * mbxy]; l1ref1 = &sl->reflist[1][0].parent->refindex[1][4 * mbxy]; if (!b8stride) { if (sl->mby & 1) { l1ref0 += 2; l1ref1 += 2; l1mv0 += 2 * b4stride; l1mv1 += 2 * b4stride; } } if (ISINTERLACED(*mbtype) != ISINTERLACED(mbtypecol[0])) { int n = 0; for (i8 = 0; i8 < 4; i8++) { int x8 = i8 & 1; int y8 = i8 >> 1; int xy8 = x8 + y8 * b8stride; int xy4 = x8 * 3 + y8 * b4stride; int a, b; if (isb8x8 && !ISDIRECT(sl->submbtype[i8])) continue; sl->submbtype[i8] = submbtype; fillrectangle(&sl->refcache[0][scan8[i8 * 4]], 2, 2, 8, (uint8t)ref[0], 1); fillrectangle(&sl->refcache[1][scan8[i8 * 4]], 2, 2, 8, (uint8t)ref[1], 1); if (!ISINTRA(mbtypecol[y8]) && !sl->reflist[1][0].parent->longref && ((l1ref0[xy8] == 0 && FFABS(l1mv0[xy4][0]) <= 1 && FFABS(l1mv0[xy4][1]) <= 1) || (l1ref0[xy8] < 0 && l1ref1[xy8] == 0 && FFABS(l1mv1[xy4][0]) <= 1 && FFABS(l1mv1[xy4][1]) <= 1))) { a = b = 0; if (ref[0] > 0) a = mv[0]; if (ref[1] > 0) b = mv[1]; n++; } else { a = mv[0]; b = mv[1]; } fillrectangle(&sl->mvcache[0][scan8[i8 * 4]], 2, 2, 8, a, 4); fillrectangle(&sl->mvcache[1][scan8[i8 * 4]], 2, 2, 8, b, 4); } if (!isb8x8 && !(n & 3)) *mbtype = (*mbtype & ~(MBTYPE8x8 | MBTYPE16x8 | MBTYPE8x16 | MBTYPEP1L0 | MBTYPEP1L1)) | MBTYPE16x16 | MBTYPEDIRECT2; } else if (IS16X16(*mbtype)) { int a, b; fillrectangle(&sl->refcache[0][scan8[0]], 4, 4, 8, (uint8t)ref[0], 1); fillrectangle(&sl->refcache[1][scan8[0]], 4, 4, 8, (uint8t)ref[1], 1); if (!ISINTRA(mbtypecol[0]) && !sl->reflist[1][0].parent->longref && ((l1ref0[0] == 0 && FFABS(l1mv0[0][0]) <= 1 && FFABS(l1mv0[0][1]) <= 1) || (l1ref0[0] < 0 && !l1ref1[0] && FFABS(l1mv1[0][0]) <= 1 && FFABS(l1mv1[0][1]) <= 1 && h->x264build > 33U))) { a = b = 0; if (ref[0] > 0) a = mv[0]; if (ref[1] > 0) b = mv[1]; } else { a = mv[0]; b = mv[1]; } fillrectangle(&sl->mvcache[0][scan8[0]], 4, 4, 8, a, 4); fillrectangle(&sl->mvcache[1][scan8[0]], 4, 4, 8, b, 4); } else { int n = 0; for (i8 = 0; i8 < 4; i8++) { const int x8 = i8 & 1; const int y8 = i8 >> 1; if (isb8x8 && !ISDIRECT(sl->submbtype[i8])) continue; sl->submbtype[i8] = submbtype; fillrectangle(&sl->mvcache[0][scan8[i8 * 4]], 2, 2, 8, mv[0], 4); fillrectangle(&sl->mvcache[1][scan8[i8 * 4]], 2, 2, 8, mv[1], 4); fillrectangle(&sl->refcache[0][scan8[i8 * 4]], 2, 2, 8, (uint8t)ref[0], 1); fillrectangle(&sl->refcache[1][scan8[i8 * 4]], 2, 2, 8, (uint8t)ref[1], 1); assert(b8stride == 2); /* colzeroflag */ if (!ISINTRA(mbtypecol[0]) && !sl->reflist[1][0].parent->longref && (l1ref0[i8] == 0 || (l1ref0[i8] < 0 && l1ref1[i8] == 0 && h->x264build > 33U))) { const int16t (*l1mv)[2] = l1ref0[i8] == 0 ? l1mv0 : l1mv1; if (ISSUB8X8(submbtype)) { const int16t *mvcol = l1mv[x8 * 3 + y8 * 3 * b4stride]; if (FFABS(mvcol[0]) <= 1 && FFABS(mvcol[1]) <= 1) { if (ref[0] == 0) fillrectangle(&sl->mvcache[0][scan8[i8 * 4]], 2, 2, 8, 0, 4); if (ref[1] == 0) fillrectangle(&sl->mvcache[1][scan8[i8 * 4]], 2, 2, 8, 0, 4); n += 4; } } else { int m = 0; for (i4 = 0; i4 < 4; i4++) { const int16t *mvcol = l1mv[x8 * 2 + (i4 & 1) + (y8 * 2 + (i4 >> 1)) * b4stride]; if (FFABS(mvcol[0]) <= 1 && FFABS(mvcol[1]) <= 1) { if (ref[0] == 0) AVZERO32(sl->mvcache[0][scan8[i8 * 4 + i4]]); if (ref[1] == 0) AVZERO32(sl->mvcache[1][scan8[i8 * 4 + i4]]); m++; } } if (!(m & 3)) sl->submbtype[i8] += MBTYPE16x16 - MBTYPE8x8; n += m; } } } if (!isb8x8 && !(n & 15)) *mbtype = (*mbtype & ~(MBTYPE8x8 | MBTYPE16x8 | MBTYPE8x16 | MBTYPEP1L0 | MBTYPEP1L1)) | MBTYPE16x16 | MBTYPEDIRECT2; } } ", "target": 0}
{"func": "static void gemwrite(void *opaque, targetphysaddrt offset, uint64t val, unsigned size) { GemState *s = (GemState *)opaque; uint32t readonly; DBPRINT(\"offset: 0x%04x write: 0x%08x \", offset, (unsigned)val); offset >>= 2; /* Squash bits which are read only in write value */ val &= ~(s->regsro[offset]); /* Preserve (only) bits which are read only in register */ readonly = s->regs[offset]; readonly &= s->regsro[offset]; /* Squash bits which are write 1 to clear */ val &= ~(s->regsw1c[offset] & val); /* Copy register write to backing store */ s->regs[offset] = val | readonly; /* Handle register write side effects */ switch (offset) { case GEMNWCTRL: if (val & GEMNWCTRLTXSTART) { gemtransmit(s); } if (!(val & GEMNWCTRLTXENA)) { /* Reset to start of Q when transmit disabled. */ s->txdescaddr = s->regs[GEMTXQBASE]; } if (!(val & GEMNWCTRLRXENA)) { /* Reset to start of Q when receive disabled. */ s->rxdescaddr = s->regs[GEMRXQBASE]; } break; case GEMTXSTATUS: gemupdateintstatus(s); break; case GEMRXQBASE: s->rxdescaddr = val; break; case GEMTXQBASE: s->txdescaddr = val; break; case GEMRXSTATUS: gemupdateintstatus(s); break; case GEMIER: s->regs[GEMIMR] &= ~val; gemupdateintstatus(s); break; case GEMIDR: s->regs[GEMIMR] |= val; gemupdateintstatus(s); break; case GEMPHYMNTNC: if (val & GEMPHYMNTNCOPW) { uint32t phyaddr, regnum; phyaddr = (val & GEMPHYMNTNCADDR) >> GEMPHYMNTNCADDRSHFT; if (phyaddr == BOARDPHYADDRESS) { regnum = (val & GEMPHYMNTNCREG) >> GEMPHYMNTNCREGSHIFT; gemphywrite(s, regnum, val); } } break; } DBPRINT(\"newval: 0x%08x\\n\", s->regs[offset]); } ", "target": 0}
{"func": "void cpuloop(CPUMIPSState *env) { targetsiginfot info; int trapnr, ret; unsigned int syscallnum; for(;;) { trapnr = cpumipsexec(env); switch(trapnr) { case EXCPSYSCALL: syscallnum = env->activetc.gpr[2] - 4000; env->activetc.PC += 4; if (syscallnum >= sizeof(mipssyscallargs)) { ret = -ENOSYS; } else { int nbargs; abiulong spreg; abiulong arg5 = 0, arg6 = 0, arg7 = 0, arg8 = 0; nbargs = mipssyscallargs[syscallnum]; spreg = env->activetc.gpr[29]; switch (nbargs) { /* these arguments are taken from the stack */ /* FIXME - what to do if getuser() fails? */ case 8: getuserual(arg8, spreg + 28); case 7: getuserual(arg7, spreg + 24); case 6: getuserual(arg6, spreg + 20); case 5: getuserual(arg5, spreg + 16); default: ret = dosyscall(env, env->activetc.gpr[2], env->activetc.gpr[4], env->activetc.gpr[5], env->activetc.gpr[6], env->activetc.gpr[7], arg5, arg6/*, arg7, arg8*/); if ((unsigned int)ret >= (unsigned int)(-1133)) { env->activetc.gpr[7] = 1; /* error flag */ ret = -ret; } else { env->activetc.gpr[7] = 0; /* error flag */ env->activetc.gpr[2] = ret; case EXCPTLBL: case EXCPTLBS: info.sisigno = TARGETSIGSEGV; info.sierrno = 0; /* XXX: check env->errorcode */ info.sicode = TARGETSEGVMAPERR; info.sifields.sigfault.addr = env->CP0BadVAddr; queuesignal(env, info.sisigno, &info); case EXCPCpU: case EXCPRI: info.sisigno = TARGETSIGILL; info.sierrno = 0; info.sicode = 0; queuesignal(env, info.sisigno, &info); case EXCPINTERRUPT: /* just indicate that signals should be handled asap */ case EXCPDEBUG: { int sig; sig = gdbhandlesig (env, TARGETSIGTRAP); if (sig) { info.sisigno = sig; info.sierrno = 0; info.sicode = TARGETTRAPBRKPT; queuesignal(env, info.sisigno, &info); default: // error: fprintf(stderr, \"qemu: unhandled CPU exception 0x%x - aborting\\n\", trapnr); cpudumpstate(env, stderr, fprintf, 0); abort(); processpendingsignals(env); ", "target": 1}
{"func": "static int tmvreadseek(AVFormatContext *s, int streamindex, int64t timestamp, int flags) { TMVContext *tmv = s->privdata; int64t pos; if (streamindex) return -1; pos = timestamp * (tmv->audiochunksize + tmv->videochunksize + tmv->padding); avioseek(s->pb, pos + TMVHEADERSIZE, SEEKSET); tmv->streamindex = 0; return 0; } ", "target": 1}
{"func": "static void bonitoldmawritel(void *opaque, hwaddr addr, uint64t val, unsigned size) { PCIBonitoState *s = opaque; ((uint32t *)(&s->bonldma))[addr/sizeof(uint32t)] = val & 0xffffffff;", "target": 1}
{"func": "static int jpeg2000decodepacket(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile, int *tpindex, Jpeg2000CodingStyle *codsty, Jpeg2000ResLevel *rlevel, int precno, int layno, uint8t *expn, int numgbits) { int bandno, cblkno, ret, nbcodeblocks; int cwsno; if (layno < rlevel->band[0].prec[precno].decodedlayers) return 0; rlevel->band[0].prec[precno].decodedlayers = layno + 1; if (bytestream2getbytesleft(&s->g) == 0 && s->bitindex == 8) { if (*tpindex < FFARRAYELEMS(tile->tilepart) - 1) { s->g = tile->tilepart[++(*tpindex)].tpg; } } if (bytestream2peekbe32(&s->g) == JPEG2000SOPFIXEDBYTES) bytestream2skip(&s->g, JPEG2000SOPBYTELENGTH); if (!(ret = getbits(s, 1))) { jpeg2000flush(s); return 0; } else if (ret < 0) return ret; for (bandno = 0; bandno < rlevel->nbands; bandno++) { Jpeg2000Band *band = rlevel->band + bandno; Jpeg2000Prec *prec = band->prec + precno; if (band->coord[0][0] == band->coord[0][1] || band->coord[1][0] == band->coord[1][1]) continue; nbcodeblocks = prec->nbcodeblocksheight * prec->nbcodeblockswidth; for (cblkno = 0; cblkno < nbcodeblocks; cblkno++) { Jpeg2000Cblk *cblk = prec->cblk + cblkno; int incl, newpasses, llen; if (cblk->npasses) incl = getbits(s, 1); else incl = tagtreedecode(s, prec->cblkincl + cblkno, layno + 1) == layno; if (!incl) continue; else if (incl < 0) return incl; if (!cblk->npasses) { int v = expn[bandno] + numgbits - 1 - tagtreedecode(s, prec->zerobits + cblkno, 100); if (v < 0 || v > 30) { avlog(s->avctx, AVLOGERROR, \"nonzerobits %d invalid or unsupported\\n\", v); return AVERRORINVALIDDATA; } cblk->nonzerobits = v; } if ((newpasses = getnpasses(s)) < 0) return newpasses; avassert2(newpasses > 0); if (cblk->npasses + newpasses >= JPEG2000MAXPASSES) { avprivrequestsample(s->avctx, \"Too many passes\"); return AVERRORPATCHWELCOME; } if ((llen = getlblockinc(s)) < 0) return llen; if (cblk->lblock + llen + avlog2(newpasses) > 16) { avprivrequestsample(s->avctx, \"Block with length beyond 16 bits\"); return AVERRORPATCHWELCOME; } cblk->lblock += llen; cblk->nblengthinc = 0; cblk->nbterminationsinc = 0; do { int newpasses1 = 0; while (newpasses1 < newpasses) { newpasses1 ++; if (needstermination(codsty->cblkstyle, cblk->npasses + newpasses1 - 1)) { cblk->nbterminationsinc ++; break; } } if ((ret = getbits(s, avlog2(newpasses1) + cblk->lblock)) < 0) return ret; if (ret > sizeof(cblk->data)) { avprivrequestsample(s->avctx, \"Block with lengthinc greater than %\"SIZESPECIFIER\"\", sizeof(cblk->data)); return AVERRORPATCHWELCOME; } cblk->lengthinc[cblk->nblengthinc++] = ret; cblk->npasses += newpasses1; newpasses -= newpasses1; } while(newpasses); } } jpeg2000flush(s); if (codsty->csty & JPEG2000CSTYEPH) { if (bytestream2peekbe16(&s->g) == JPEG2000EPH) bytestream2skip(&s->g, 2); else avlog(s->avctx, AVLOGERROR, \"EPH marker not found. instead %X\\n\", bytestream2peekbe32(&s->g)); } for (bandno = 0; bandno < rlevel->nbands; bandno++) { Jpeg2000Band *band = rlevel->band + bandno; Jpeg2000Prec *prec = band->prec + precno; nbcodeblocks = prec->nbcodeblocksheight * prec->nbcodeblockswidth; for (cblkno = 0; cblkno < nbcodeblocks; cblkno++) { Jpeg2000Cblk *cblk = prec->cblk + cblkno; for (cwsno = 0; cwsno < cblk->nblengthinc; cwsno ++) { if ( bytestream2getbytesleft(&s->g) < cblk->lengthinc[cwsno] || sizeof(cblk->data) < cblk->length + cblk->lengthinc[cwsno] + 4 ) { avlog(s->avctx, AVLOGERROR, \"Block length %\"PRIu16\" or lengthinc %d is too large, left %d\\n\", cblk->length, cblk->lengthinc[cwsno], bytestream2getbytesleft(&s->g)); return AVERRORINVALIDDATA; } bytestream2getbufferu(&s->g, cblk->data + cblk->length, cblk->lengthinc[cwsno]); cblk->length += cblk->lengthinc[cwsno]; cblk->lengthinc[cwsno] = 0; if (cblk->nbterminationsinc) { cblk->nbterminationsinc--; cblk->nbterminations++; cblk->data[cblk->length++] = 0xFF; cblk->data[cblk->length++] = 0xFF; cblk->datastart[cblk->nbterminations] = cblk->length; } } } } return 0; } ", "target": 1}
{"func": "static void cursesrefresh(DisplayChangeListener *dcl) { int chr, nextchr, keysym, keycode, keycodealt; curseswinchcheck(); if (invalidate) { clear(); refresh(); cursescalcpad(); graphichwinvalidate(NULL); invalidate = 0; } graphichwtextupdate(NULL, screen); nextchr = ERR; while (1) { /* while there are any pending key strokes to process */ if (nextchr == ERR) chr = getch(); else { chr = nextchr; nextchr = ERR; } if (chr == ERR) break; #ifdef KEYRESIZE /* this shouldn't occur when we use a custom SIGWINCH handler */ if (chr == KEYRESIZE) { clear(); refresh(); cursescalcpad(); cursesupdate(dcl, 0, 0, width, height); continue; } #endif keycode = curses2keycode[chr]; keycodealt = 0; /* alt key */ if (keycode == 1) { nextchr = getch(); if (nextchr != ERR) { chr = nextchr; keycodealt = ALT; keycode = curses2keycode[nextchr]; nextchr = ERR; if (keycode != -1) { keycode |= ALT; /* process keys reserved for qemu */ if (keycode >= QEMUKEYCONSOLE0 && keycode < QEMUKEYCONSOLE0 + 9) { erase(); wnoutrefresh(stdscr); consoleselect(keycode - QEMUKEYCONSOLE0); invalidate = 1; continue; } } } } if (kbdlayout) { keysym = -1; if (chr < CURSESKEYS) keysym = curses2keysym[chr]; if (keysym == -1) { if (chr < ' ') { keysym = chr + '@'; if (keysym >= 'A' && keysym <= 'Z') keysym += 'a' - 'A'; keysym |= KEYSYMCNTRL; } else keysym = chr; } keycode = keysym2scancode(kbdlayout, keysym & KEYSYMMASK); if (keycode == 0) continue; keycode |= (keysym & ~KEYSYMMASK) >> 16; keycode |= keycodealt; } if (keycode == -1) continue; if (qemuconsoleisgraphic(NULL)) { /* since terminals don't know about key press and release * events, we need to emit both for each key received */ if (keycode & SHIFT) { qemuinputeventsendkeynumber(NULL, SHIFTCODE, true); qemuinputeventsendkeydelay(0); } if (keycode & CNTRL) { qemuinputeventsendkeynumber(NULL, CNTRLCODE, true); qemuinputeventsendkeydelay(0); } if (keycode & ALT) { qemuinputeventsendkeynumber(NULL, ALTCODE, true); qemuinputeventsendkeydelay(0); } if (keycode & ALTGR) { qemuinputeventsendkeynumber(NULL, GREY | ALTCODE, true); qemuinputeventsendkeydelay(0); } qemuinputeventsendkeynumber(NULL, keycode & KEYMASK, true); qemuinputeventsendkeydelay(0); qemuinputeventsendkeynumber(NULL, keycode & KEYMASK, false); qemuinputeventsendkeydelay(0); if (keycode & ALTGR) { qemuinputeventsendkeynumber(NULL, GREY | ALTCODE, false); qemuinputeventsendkeydelay(0); } if (keycode & ALT) { qemuinputeventsendkeynumber(NULL, ALTCODE, false); qemuinputeventsendkeydelay(0); } if (keycode & CNTRL) { qemuinputeventsendkeynumber(NULL, CNTRLCODE, false); qemuinputeventsendkeydelay(0); } if (keycode & SHIFT) { qemuinputeventsendkeynumber(NULL, SHIFTCODE, false); qemuinputeventsendkeydelay(0); } } else { keysym = curses2qemu[chr]; if (keysym == -1) keysym = chr; kbdputkeysym(keysym); } } } ", "target": 1}
{"func": "static int64t readts(char **line, int *duration) { int64t start, end; if (sscanf(*line, \"%\"SCNd64\",%\"SCNd64, &start, &end) == 2) { *line += strcspn(*line, \"\\\"\") + 1; *duration = end - start; return start; } return AVNOPTSVALUE; } ", "target": 1}
{"func": "static void ravenclassinit(ObjectClass *klass, void *data) { PCIDeviceClass *k = PCIDEVICECLASS(klass); DeviceClass *dc = DEVICECLASS(klass); k->init = raveninit; k->vendorid = PCIVENDORIDMOTOROLA; k->deviceid = PCIDEVICEIDMOTOROLARAVEN; k->revision = 0x00; k->classid = PCICLASSBRIDGEHOST; dc->desc = \"PReP Host Bridge - Motorola Raven\"; dc->vmsd = &vmstateraven; dc->nouser = 1; } ", "target": 1}
{"func": "static void pciaddoptionrom(PCIDevice *pdev, bool isdefaultrom, Error **errp) { int size; char *path; void *ptr; char name[32]; const VMStateDescription *vmsd; if (!pdev->romfile) return; if (strlen(pdev->romfile) == 0) return; if (!pdev->rombar) { /* * Load rom via fwcfg instead of creating a rom bar, * for 0.11 compatibility. */ int class = pcigetword(pdev->config + PCICLASSDEVICE); /* * Hot-plugged devices can't use the option ROM * if the rom bar is disabled. */ if (DEVICE(pdev)->hotplugged) { errorsetg(errp, \"Hot-plugged device without ROM bar\" \" can't have an option ROM\"); return; } if (class == 0x0300) { romaddvga(pdev->romfile); } else { romaddoption(pdev->romfile, -1); } return; } path = qemufindfile(QEMUFILETYPEBIOS, pdev->romfile); if (path == NULL) { path = gstrdup(pdev->romfile); } size = getimagesize(path); if (size < 0) { errorsetg(errp, \"failed to find romfile \\\"%s\\\"\", pdev->romfile); gfree(path); return; } else if (size == 0) { errorsetg(errp, \"romfile \\\"%s\\\" is empty\", pdev->romfile); gfree(path); return; } size = pow2ceil(size); vmsd = qdevgetvmsd(DEVICE(pdev)); if (vmsd) { snprintf(name, sizeof(name), \"%s.rom\", vmsd->name); } else { snprintf(name, sizeof(name), \"%s.rom\", objectgettypename(OBJECT(pdev))); } pdev->hasrom = true; memoryregioninitram(&pdev->rom, OBJECT(pdev), name, size, &errorabort); vmstateregisterram(&pdev->rom, &pdev->qdev); ptr = memoryregiongetramptr(&pdev->rom); loadimage(path, ptr); gfree(path); if (isdefaultrom) { /* Only the default rom images will be patched (if needed). */ pcipatchids(pdev, ptr, size); } pciregisterbar(pdev, PCIROMSLOT, 0, &pdev->rom); } ", "target": 1}
{"func": "static void movwriteuuidproftag(AVIOContext *pb, AVFormatContext *s) { AVStream *videost = s->streams[0]; AVCodecParameters *videopar = s->streams[0]->codecpar; AVCodecParameters *audiopar = s->streams[1]->codecpar; int audiorate = audiopar->samplerate; // TODO: should be avgframerate int framerate = ((videost->timebase.den) * (0x10000)) / (videost->timebase.num); int audiokbitrate = audiopar->bitrate / 1000; int videokbitrate = FFMIN(videopar->bitrate / 1000, 800 - audiokbitrate); aviowb32(pb, 0x94); /* size */ ffiowfourcc(pb, \"uuid\"); ffiowfourcc(pb, \"PROF\"); aviowb32(pb, 0x21d24fce); /* 96 bit UUID */ aviowb32(pb, 0xbb88695c); aviowb32(pb, 0xfac9c740); aviowb32(pb, 0x0); /* ? */ aviowb32(pb, 0x3); /* 3 sections ? */ aviowb32(pb, 0x14); /* size */ ffiowfourcc(pb, \"FPRF\"); aviowb32(pb, 0x0); /* ? */ aviowb32(pb, 0x0); /* ? */ aviowb32(pb, 0x0); /* ? */ aviowb32(pb, 0x2c); /* size */ ffiowfourcc(pb, \"APRF\"); /* audio */ aviowb32(pb, 0x0); aviowb32(pb, 0x2); /* TrackID */ ffiowfourcc(pb, \"mp4a\"); aviowb32(pb, 0x20f); aviowb32(pb, 0x0); aviowb32(pb, audiokbitrate); aviowb32(pb, audiokbitrate); aviowb32(pb, audiorate); aviowb32(pb, audiopar->channels); aviowb32(pb, 0x34); /* size */ ffiowfourcc(pb, \"VPRF\"); /* video */ aviowb32(pb, 0x0); aviowb32(pb, 0x1); /* TrackID */ if (videopar->codecid == AVCODECIDH264) { ffiowfourcc(pb, \"avc1\"); aviowb16(pb, 0x014D); aviowb16(pb, 0x0015); } else { ffiowfourcc(pb, \"mp4v\"); aviowb16(pb, 0x0000); aviowb16(pb, 0x0103); } aviowb32(pb, 0x0); aviowb32(pb, videokbitrate); aviowb32(pb, videokbitrate); aviowb32(pb, framerate); aviowb32(pb, framerate); aviowb16(pb, videopar->width); aviowb16(pb, videopar->height); aviowb32(pb, 0x010001); /* ? */ } ", "target": 1}
{"func": "static char *spaprphbvfiogetloccode(sPAPRPHBState *sphb, PCIDevice *pdev) { char *path = NULL, *buf = NULL, *host = NULL; /* Get the PCI VFIO host id */ host = objectpropertygetstr(OBJECT(pdev), \"host\", NULL); if (!host) { goto errout; } /* Construct the path of the file that will give us the DT location */ path = gstrdupprintf(\"/sys/bus/pci/devices/%s/devspec\", host); gfree(host); if (!path || !gfilegetcontents(path, &buf, NULL, NULL)) { goto errout; } gfree(path); /* Construct and read from host device tree the loc-code */ path = gstrdupprintf(\"/proc/device-tree%s/ibm,loc-code\", buf); gfree(buf); if (!path || !gfilegetcontents(path, &buf, NULL, NULL)) { goto errout; } return buf; errout: gfree(path); return NULL; } ", "target": 1}
{"func": "static inline void yuv2nv12XinC(int16t *lumFilter, int16t **lumSrc, int lumFilterSize, int16t *chrFilter, int16t **chrSrc, int chrFilterSize, uint8t *dest, uint8t *uDest, int dstW, int chrDstW, int dstFormat) { //FIXME Optimize (just quickly writen not opti..) int i; for (i=0; i<dstW; i++) { int val=1<<18; int j; for (j=0; j<lumFilterSize; j++) val += lumSrc[j][i] * lumFilter[j]; dest[i]= avclipuint8(val>>19); } if (!uDest) return; if (dstFormat == PIXFMTNV12) for (i=0; i<chrDstW; i++) { int u=1<<18; int v=1<<18; int j; for (j=0; j<chrFilterSize; j++) { u += chrSrc[j][i] * chrFilter[j]; v += chrSrc[j][i + 2048] * chrFilter[j]; } uDest[2*i]= avclipuint8(u>>19); uDest[2*i+1]= avclipuint8(v>>19); } else for (i=0; i<chrDstW; i++) { int u=1<<18; int v=1<<18; int j; for (j=0; j<chrFilterSize; j++) { u += chrSrc[j][i] * chrFilter[j]; v += chrSrc[j][i + 2048] * chrFilter[j]; } uDest[2*i]= avclipuint8(v>>19); uDest[2*i+1]= avclipuint8(u>>19); } } ", "target": 1}
{"func": "static void nvmeprocessdb(NvmeCtrl *n, hwaddr addr, int val) { uint32t qid; if (addr & ((1 << 2) - 1)) { return; } if (((addr - 0x1000) >> 2) & 1) { uint16t newhead = val & 0xffff; int startsqs; NvmeCQueue *cq; qid = (addr - (0x1000 + (1 << 2))) >> 3; if (nvmecheckcqid(n, qid)) { return; } cq = n->cq[qid]; if (newhead >= cq->size) { return; } startsqs = nvmecqfull(cq) ? 1 : 0; cq->head = newhead; if (startsqs) { NvmeSQueue *sq; QTAILQFOREACH(sq, &cq->sqlist, entry) { timermod(sq->timer, qemuclockgetns(QEMUCLOCKVIRTUAL) + 500); } timermod(cq->timer, qemuclockgetns(QEMUCLOCKVIRTUAL) + 500); } if (cq->tail != cq->head) { nvmeisrnotify(n, cq); } } else { uint16t newtail = val & 0xffff; NvmeSQueue *sq; qid = (addr - 0x1000) >> 3; if (nvmechecksqid(n, qid)) { return; } sq = n->sq[qid]; if (newtail >= sq->size) { return; } sq->tail = newtail; timermod(sq->timer, qemuclockgetns(QEMUCLOCKVIRTUAL) + 500); } } ", "target": 1}
{"func": "static avcold void buildmodpred(Indeo3DecodeContext *s) { int i, j; s->ModPred = avmalloc(8 * 128); for (i=0; i < 128; ++i) { s->ModPred[i+0*128] = i > 126 ? 254 : 2*(i + 1 - ((i + 1) % 2)); s->ModPred[i+1*128] = i == 7 ? 20 : i == 119 || i == 120 ? 236 : 2*(i + 2 - ((i + 1) % 3)); s->ModPred[i+2*128] = i > 125 ? 248 : 2*(i + 2 - ((i + 2) % 4)); s->ModPred[i+3*128] = 2*(i + 1 - ((i - 3) % 5)); s->ModPred[i+4*128] = i == 8 ? 20 : 2*(i + 1 - ((i - 3) % 6)); s->ModPred[i+5*128] = 2*(i + 4 - ((i + 3) % 7)); s->ModPred[i+6*128] = i > 123 ? 240 : 2*(i + 4 - ((i + 4) % 8)); s->ModPred[i+7*128] = 2*(i + 5 - ((i + 4) % 9)); } s->correctortype = avmalloc(24 * 256); for (i=0; i < 24; ++i) { for (j=0; j < 256; ++j) { s->correctortype[i*256+j] = j < correctortype0[i] ? 1 : j < 248 || (i == 16 && j == 248) ? 0 : correctortype2[j - 248]; } } } ", "target": 0}
{"func": "static void genstoreqreg(DisasContext *s, int rlow, int rhigh, TCGvi64 val) { TCGv tmp; tmp = newtmp(); tcggentrunci64i32(tmp, val); storereg(s, rlow, tmp); tmp = newtmp(); tcggenshrii64(val, val, 32); tcggentrunci64i32(tmp, val); storereg(s, rhigh, tmp); } ", "target": 1}
{"func": "static int ccidbulkincopytoguest(USBCCIDState *s, uint8t *data, int len) { int ret = 0; assert(len > 0); ccidbulkinget(s); if (s->currentbulkin != NULL) { ret = MIN(s->currentbulkin->len - s->currentbulkin->pos, len); memcpy(data, s->currentbulkin->data + s->currentbulkin->pos, ret); s->currentbulkin->pos += ret; if (s->currentbulkin->pos == s->currentbulkin->len) { ccidbulkinrelease(s); } } else { /* return when device has no data - usb 2.0 spec Table 8-4 */ ret = USBRETNAK; } if (ret > 0) { DPRINTF(s, DMOREINFO, \"%s: %d/%d req/act to guest (BULKIN)\\n\", func, len, ret); } if (ret != USBRETNAK && ret < len) { DPRINTF(s, 1, \"%s: returning short (EREMOTEIO) %d < %d\\n\", func, ret, len); } return ret; } ", "target": 1}
{"func": "static void lmsupdate(WmallDecodeCtx *s, int ich, int ilms, int16t input, int16t pred) { int16t icoef; int recent = s->cdlms[ich][ilms].recent; int16t range = 1 << (s->bitspersample - 1); int bps = s->bitspersample > 16 ? 4 : 2; // bytes per sample if (input > pred) { for (icoef = 0; icoef < s->cdlms[ich][ilms].order; icoef++) s->cdlms[ich][ilms].coefs[icoef] += s->cdlms[ich][ilms].lmsupdates[icoef + recent]; } else { for (icoef = 0; icoef < s->cdlms[ich][ilms].order; icoef++) s->cdlms[ich][ilms].coefs[icoef] -= s->cdlms[ich][ilms].lmsupdates[icoef]; // XXX: [icoef + recent] ? } s->cdlms[ich][ilms].recent--; s->cdlms[ich][ilms].lmsprevvalues[recent] = avclip(input, -range, range - 1); if (input > pred) s->cdlms[ich][ilms].lmsupdates[recent] = s->updatespeed[ich]; else if (input < pred) s->cdlms[ich][ilms].lmsupdates[recent] = -s->updatespeed[ich]; /* XXX: spec says: cdlms[iCh][ilms].updates[iRecent + cdlms[iCh][ilms].order >> 4] >>= 2; lmsupdates[iCh][ilms][iRecent + cdlms[iCh][ilms].order >> 3] >>= 1; Questions is - are cdlms[iCh][ilms].updates[] and lmsupdates[][][] two seperate buffers? Here I've assumed that the two are same which makes more sense to me. */ s->cdlms[ich][ilms].lmsupdates[recent + s->cdlms[ich][ilms].order >> 4] >>= 2; s->cdlms[ich][ilms].lmsupdates[recent + s->cdlms[ich][ilms].order >> 3] >>= 1; /* XXX: recent + (s->cdlms[ich][ilms].order >> 4) ? */ if (s->cdlms[ich][ilms].recent == 0) { /* XXX: This memcpy()s will probably fail if a fixed 32-bit buffer is used. follow kshishkov's suggestion of using a union. */ memcpy(s->cdlms[ich][ilms].lmsprevvalues + s->cdlms[ich][ilms].order, s->cdlms[ich][ilms].lmsprevvalues, bps * s->cdlms[ich][ilms].order); memcpy(s->cdlms[ich][ilms].lmsupdates + s->cdlms[ich][ilms].order, s->cdlms[ich][ilms].lmsupdates, bps * s->cdlms[ich][ilms].order); s->cdlms[ich][ilms].recent = s->cdlms[ich][ilms].order; } } ", "target": 1}
{"func": "static int createfilter(AVFilterContext **filtctx, AVFilterGraph *ctx, int index, const char *filtname, const char *args, AVClass *logctx) { AVFilter *filt; char instname[30]; char tmpargs[256]; int ret; snprintf(instname, sizeof(instname), \"Parsed filter %d %s\", index, filtname); filt = avfiltergetbyname(filtname); if (!filt) { avlog(logctx, AVLOGERROR, \"No such filter: '%s'\\n\", filtname); return AVERROR(EINVAL); } ret = avfilteropen(filtctx, filt, instname); if (!*filtctx) { avlog(logctx, AVLOGERROR, \"Error creating filter '%s'\\n\", filtname); return ret; } if ((ret = avfiltergraphaddfilter(ctx, *filtctx)) < 0) { avfilterfree(*filtctx); return ret; } if (!strcmp(filtname, \"scale\") && !strstr(args, \"flags\")) { snprintf(tmpargs, sizeof(tmpargs), \"%s:%s\", args, ctx->scaleswsopts); args = tmpargs; } if ((ret = avfilterinitfilter(*filtctx, args, NULL)) < 0) { avlog(logctx, AVLOGERROR, \"Error initializing filter '%s' with args '%s'\\n\", filtname, args); return ret; } return 0; } ", "target": 1}
{"func": "static void decodemclms(WmallDecodeCtx *s) { s->mclmsorder = (getbits(&s->gb, 4) + 1) * 2; s->mclmsscaling = getbits(&s->gb, 4); if(getbits1(&s->gb)) { \t// mclmssendcoef \tint i; \tint sendcoefbits; \tint cbits = avlog2(s->mclmsscaling + 1); \tassert(cbits == mylog2(s->mclmsscaling + 1)); \tif(1 << cbits < s->mclmsscaling + 1) \t cbits++; \tsendcoefbits = (cbits ? getbits(&s->gb, cbits) : 0) + 2; \tfor(i = 0; i < s->mclmsorder * s->numchannels * s->numchannels; i++) { \t s->mclmscoeffs[i] = getbits(&s->gb, sendcoefbits); \t} \tfor(i = 0; i < s->numchannels; i++) { \t int c; \t for(c = 0; c < i; c++) { \t\ts->mclmscoeffscur[i * s->numchannels + c] = getbits(&s->gb, sendcoefbits); \t } \t} } } ", "target": 1}
{"func": "static void ppcspaprinit(ramaddrt ramsize, const char *bootdevice, const char *kernelfilename, const char *kernelcmdline, const char *initrdfilename, const char *cpumodel) { PowerPCCPU *cpu; CPUPPCState *env; int i; MemoryRegion *sysmem = getsystemmemory(); MemoryRegion *ram = gnew(MemoryRegion, 1); targetphysaddrt rmaallocsize, rmasize; uint32t initrdbase = 0; long kernelsize = 0, initrdsize = 0; long loadlimit, rtaslimit, fwsize; long ptegshift = 17; char *filename; spapr = gmalloc0(sizeof(*spapr)); QLISTINIT(&spapr->phbs); cpuppchypercall = emulatespaprhypercall; /* Allocate RMA if necessary */ rmaallocsize = kvmppcallocrma(\"ppcspapr.rma\", sysmem); if (rmaallocsize == -1) { hwerror(\"qemu: Unable to create RMA\\n\"); exit(1); } if (rmaallocsize && (rmaallocsize < ramsize)) { rmasize = rmaallocsize; } else { rmasize = ramsize; } /* We place the device tree and RTAS just below either the top of the RMA, * or just below 2GB, whichever is lowere, so that it can be * processed with 32-bit real mode code if necessary */ rtaslimit = MIN(rmasize, 0x80000000); spapr->rtasaddr = rtaslimit - RTASMAXSIZE; spapr->fdtaddr = spapr->rtasaddr - FDTMAXSIZE; loadlimit = spapr->fdtaddr - FWOVERHEAD; /* init CPUs */ if (cpumodel == NULL) { cpumodel = kvmenabled() ? \"host\" : \"POWER7\"; } for (i = 0; i < smpcpus; i++) { cpu = cpuppcinit(cpumodel); if (cpu == NULL) { fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\"); exit(1); } env = &cpu->env; /* Set time-base frequency to 512 MHz */ cpuppctbinit(env, TIMEBASEFREQ); qemuregisterreset(spaprcpureset, cpu); env->hresetvector = 0x60; env->hresetexcpprefix = 0; env->gpr[3] = env->cpuindex; } /* allocate RAM */ spapr->ramlimit = ramsize; if (spapr->ramlimit > rmaallocsize) { ramaddrt nonrmabase = rmaallocsize; ramaddrt nonrmasize = spapr->ramlimit - rmaallocsize; memoryregioninitram(ram, \"ppcspapr.ram\", nonrmasize); vmstateregisterramglobal(ram); memoryregionaddsubregion(sysmem, nonrmabase, ram); } /* allocate hash page table. For now we always make this 16mb, * later we should probably make it scale to the size of guest * RAM */ spapr->htabsize = 1ULL << (ptegshift + 7); spapr->htab = qemumemalign(spapr->htabsize, spapr->htabsize); for (env = firstcpu; env != NULL; env = env->nextcpu) { env->externalhtab = spapr->htab; env->htabbase = -1; env->htabmask = spapr->htabsize - 1; /* Tell KVM that we're in PAPR mode */ env->spr[SPRSDR1] = (unsigned long)spapr->htab | ((ptegshift + 7) - 18); env->spr[SPRHIOR] = 0; if (kvmenabled()) { kvmppcsetpapr(env); } } filename = qemufindfile(QEMUFILETYPEBIOS, \"spapr-rtas.bin\"); spapr->rtassize = loadimagetargphys(filename, spapr->rtasaddr, rtaslimit - spapr->rtasaddr); if (spapr->rtassize < 0) { hwerror(\"qemu: could not load LPAR rtas '%s'\\n\", filename); exit(1); } if (spapr->rtassize > RTASMAXSIZE) { hwerror(\"RTAS too big ! 0x%lx bytes (max is 0x%x)\\n\", spapr->rtassize, RTASMAXSIZE); exit(1); } gfree(filename); /* Set up Interrupt Controller */ spapr->icp = xicssysteminit(XICSIRQS); spapr->nextirq = 16; /* Set up VIO bus */ spapr->viobus = spaprviobusinit(); for (i = 0; i < MAXSERIALPORTS; i++) { if (serialhds[i]) { spaprvtycreate(spapr->viobus, serialhds[i]); } } /* Set up PCI */ spaprcreatephb(spapr, \"pci\", SPAPRPCIBUID, SPAPRPCIMEMWINADDR, SPAPRPCIMEMWINSIZE, SPAPRPCIIOWINADDR); for (i = 0; i < nbnics; i++) { NICInfo *nd = &ndtable[i]; if (!nd->model) { nd->model = gstrdup(\"ibmveth\"); } if (strcmp(nd->model, \"ibmveth\") == 0) { spaprvlancreate(spapr->viobus, nd); } else { pcinicinitnofail(&ndtable[i], nd->model, NULL); } } for (i = 0; i <= drivegetmaxbus(IFSCSI); i++) { spaprvscsicreate(spapr->viobus); } if (rmasize < (MINRMASLOF << 20)) { fprintf(stderr, \"qemu: pSeries SLOF firmware requires >= \" \"%ldM guest RMA (Real Mode Area memory)\\n\", MINRMASLOF); exit(1); } fprintf(stderr, \"sPAPR memory map:\\n\"); fprintf(stderr, \"RTAS : 0x%08lx..%08lx\\n\", (unsigned long)spapr->rtasaddr, (unsigned long)(spapr->rtasaddr + spapr->rtassize - 1)); fprintf(stderr, \"FDT : 0x%08lx..%08lx\\n\", (unsigned long)spapr->fdtaddr, (unsigned long)(spapr->fdtaddr + FDTMAXSIZE - 1)); if (kernelfilename) { uint64t lowaddr = 0; kernelsize = loadelf(kernelfilename, translatekerneladdress, NULL, NULL, &lowaddr, NULL, 1, ELFMACHINE, 0); if (kernelsize < 0) { kernelsize = loadimagetargphys(kernelfilename, KERNELLOADADDR, loadlimit - KERNELLOADADDR); } if (kernelsize < 0) { fprintf(stderr, \"qemu: could not load kernel '%s'\\n\", kernelfilename); exit(1); } fprintf(stderr, \"Kernel : 0x%08x..%08lx\\n\", KERNELLOADADDR, KERNELLOADADDR + kernelsize - 1); /* load initrd */ if (initrdfilename) { /* Try to locate the initrd in the gap between the kernel * and the firmware. Add a bit of space just in case */ initrdbase = (KERNELLOADADDR + kernelsize + 0x1ffff) & ~0xffff; initrdsize = loadimagetargphys(initrdfilename, initrdbase, loadlimit - initrdbase); if (initrdsize < 0) { fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\", initrdfilename); exit(1); } fprintf(stderr, \"Ramdisk : 0x%08lx..%08lx\\n\", (long)initrdbase, (long)(initrdbase + initrdsize - 1)); } else { initrdbase = 0; initrdsize = 0; } } filename = qemufindfile(QEMUFILETYPEBIOS, FWFILENAME); fwsize = loadimagetargphys(filename, 0, FWMAXSIZE); if (fwsize < 0) { hwerror(\"qemu: could not load LPAR rtas '%s'\\n\", filename); exit(1); } gfree(filename); fprintf(stderr, \"Firmware load : 0x%08x..%08lx\\n\", 0, fwsize); fprintf(stderr, \"Firmware runtime : 0x%08lx..%08lx\\n\", loadlimit, (unsigned long)spapr->fdtaddr); spapr->entrypoint = 0x100; /* SLOF will startup the secondary CPUs using RTAS */ for (env = firstcpu; env != NULL; env = env->nextcpu) { env->halted = 1; } /* Prepare the device tree */ spapr->fdtskel = spaprcreatefdtskel(cpumodel, rmasize, initrdbase, initrdsize, kernelsize, bootdevice, kernelcmdline, ptegshift + 7); assert(spapr->fdtskel != NULL); qemuregisterreset(spaprreset, spapr); }", "target": 1}
{"func": "static avcold int sonicencodeinit(AVCodecContext *avctx) { SonicContext *s = avctx->privdata; PutBitContext pb; int i, version = 0; if (avctx->channels > MAXCHANNELS) { avlog(avctx, AVLOGERROR, \"Only mono and stereo streams are supported by now\\n\"); return AVERROR(EINVAL); /* only stereo or mono for now */ } if (avctx->channels == 2) s->decorrelation = MIDSIDE; else s->decorrelation = 3; if (avctx->codec->id == AVCODECIDSONICLS) { s->lossless = 1; s->numtaps = 32; s->downsampling = 1; s->quantization = 0.0; } else { s->numtaps = 128; s->downsampling = 2; s->quantization = 1.0; } // max tap 2048 if ((s->numtaps < 32) || (s->numtaps > 1024) || ((s->numtaps>>5)<<5 != s->numtaps)) { avlog(avctx, AVLOGERROR, \"Invalid number of taps\\n\"); return AVERRORINVALIDDATA; } // generate taps s->tapquant = avcalloc(s->numtaps, sizeof(*s->tapquant)); for (i = 0; i < s->numtaps; i++) s->tapquant[i] = ffsqrt(i+1); s->channels = avctx->channels; s->samplerate = avctx->samplerate; s->blockalign = 2048LL*s->samplerate/(44100*s->downsampling); s->framesize = s->channels*s->blockalign*s->downsampling; s->tailsize = s->numtaps*s->channels; s->tail = avcalloc(s->tailsize, sizeof(*s->tail)); if (!s->tail) return AVERROR(ENOMEM); s->predictork = avcalloc(s->numtaps, sizeof(*s->predictork) ); if (!s->predictork) return AVERROR(ENOMEM); for (i = 0; i < s->channels; i++) { s->codedsamples[i] = avcalloc(s->blockalign, sizeof(**s->codedsamples)); if (!s->codedsamples[i]) return AVERROR(ENOMEM); } s->intsamples = avcalloc(s->framesize, sizeof(*s->intsamples)); s->windowsize = ((2*s->tailsize)+s->framesize); s->window = avcalloc(s->windowsize, sizeof(*s->window)); if (!s->window) return AVERROR(ENOMEM); avctx->extradata = avmallocz(16); if (!avctx->extradata) return AVERROR(ENOMEM); initputbits(&pb, avctx->extradata, 16*8); putbits(&pb, 2, version); // version if (version == 1) { putbits(&pb, 2, s->channels); putbits(&pb, 4, codesamplerate(s->samplerate)); } putbits(&pb, 1, s->lossless); if (!s->lossless) putbits(&pb, 3, SAMPLESHIFT); // XXX FIXME: sample precision putbits(&pb, 2, s->decorrelation); putbits(&pb, 2, s->downsampling); putbits(&pb, 5, (s->numtaps >> 5)-1); // 32..1024 putbits(&pb, 1, 0); // XXX FIXME: no custom tap quant table flushputbits(&pb); avctx->extradatasize = putbitscount(&pb)/8; avlog(avctx, AVLOGINFO, \"Sonic: ver: %d ls: %d dr: %d taps: %d block: %d frame: %d downsamp: %d\\n\", version, s->lossless, s->decorrelation, s->numtaps, s->blockalign, s->framesize, s->downsampling); avctx->framesize = s->blockalign*s->downsampling; return 0; } ", "target": 0}
{"func": "int ffh264checkintrapredmode(H264Context *h, int mode, int ischroma) { static const int8t top[7] = { LEFTDCPRED8x8, 1, -1, -1 }; static const int8t left[7] = { TOPDCPRED8x8, -1, 2, -1, DC128PRED8x8 }; if (mode > 6U) { avlog(h->avctx, AVLOGERROR, \"out of range intra chroma pred mode at %d %d\\n\", h->mbx, h->mby); return -1; } if (!(h->topsamplesavailable & 0x8000)) { mode = top[mode]; if (mode < 0) { avlog(h->avctx, AVLOGERROR, \"top block unavailable for requested intra mode at %d %d\\n\", h->mbx, h->mby); return -1; } } if ((h->leftsamplesavailable & 0x8080) != 0x8080) { mode = left[mode]; if (ischroma && (h->leftsamplesavailable & 0x8080)) { // mad cow disease mode, aka MBAFF + constrainedintrapred mode = ALZHEIMERDCL0TPRED8x8 + (!(h->leftsamplesavailable & 0x8000)) + 2 * (mode == DC128PRED8x8); } if (mode < 0) { avlog(h->avctx, AVLOGERROR, \"left block unavailable for requested intra mode at %d %d\\n\", h->mbx, h->mby); return -1; } } return mode; } ", "target": 0}
{"func": "void audiopcminitinfo (struct audiopcminfo *info, audsettingst *as) { int bits = 8, sign = 0, shift = 0; switch (as->fmt) { case AUDFMTS8: sign = 1; case AUDFMTU8: break; case AUDFMTS16: sign = 1; case AUDFMTU16: bits = 16; shift = 1; break; case AUDFMTS32: sign = 1; case AUDFMTU32: bits = 32; shift = 2; break; } info->freq = as->freq; info->bits = bits; info->sign = sign; info->nchannels = as->nchannels; info->shift = (as->nchannels == 2) + shift; info->align = (1 << info->shift) - 1; info->bytespersecond = info->freq << info->shift; info->swapendianness = (as->endianness != AUDIOHOSTENDIANNESS); } ", "target": 0}
{"func": "static void blockjobcompletedtxnabort(BlockJob *job) { AioContext *ctx; BlockJobTxn *txn = job->txn; BlockJob *otherjob, *next; if (txn->aborting) { /* * We are cancelled by another job, which will handle everything. */ return; } txn->aborting = true; /* We are the first failed job. Cancel other jobs. */ QLISTFOREACH(otherjob, &txn->jobs, txnlist) { ctx = blkgetaiocontext(otherjob->blk); aiocontextacquire(ctx); } QLISTFOREACH(otherjob, &txn->jobs, txnlist) { if (otherjob == job || otherjob->completed) { /* Other jobs are \"effectively\" cancelled by us, set the status for * them; this job, however, may or may not be cancelled, depending * on the caller, so leave it. */ if (otherjob != job) { blockjobcancelasync(otherjob); } continue; } blockjobcancelsync(otherjob); assert(otherjob->completed); } QLISTFOREACHSAFE(otherjob, &txn->jobs, txnlist, next) { ctx = blkgetaiocontext(otherjob->blk); blockjobcompletedsingle(otherjob); aiocontextrelease(ctx); } } ", "target": 0}
{"func": "void isammiosetup(MemoryRegion *mr, targetphysaddrt size) { memoryregioninitio(mr, &isammioops, NULL, \"isa-mmio\", size); } ", "target": 0}
{"func": "int qiochannelsocketdgramsync(QIOChannelSocket *ioc, SocketAddressLegacy *localAddr, SocketAddressLegacy *remoteAddr, Error **errp) { int fd; traceqiochannelsocketdgramsync(ioc, localAddr, remoteAddr); fd = socketdgram(remoteAddr, localAddr, errp); if (fd < 0) { traceqiochannelsocketdgramfail(ioc); return -1; } traceqiochannelsocketdgramcomplete(ioc, fd); if (qiochannelsocketsetfd(ioc, fd, errp) < 0) { close(fd); return -1; } return 0; } ", "target": 0}
{"func": "static void decbit(DisasContext *dc) { TCGv t0, t1; unsigned int op; int memindex = cpummuindex(dc->env); op = dc->ir & ((1 << 9) - 1); switch (op) { case 0x21: /* src. */ t0 = tcgtempnew(); LOGDIS(\"src r%d r%d\\n\", dc->rd, dc->ra); tcggenanditl(t0, cpuR[dc->ra], 1); if (dc->rd) { t1 = tcgtempnew(); readcarry(dc, t1); tcggenshlitl(t1, t1, 31); tcggenshritl(cpuR[dc->rd], cpuR[dc->ra], 1); tcggenortl(cpuR[dc->rd], cpuR[dc->rd], t1); tcgtempfree(t1); } /* Update carry. */ writecarry(dc, t0); tcgtempfree(t0); break; case 0x1: case 0x41: /* srl. */ t0 = tcgtempnew(); LOGDIS(\"srl r%d r%d\\n\", dc->rd, dc->ra); /* Update carry. */ tcggenanditl(t0, cpuR[dc->ra], 1); writecarry(dc, t0); tcgtempfree(t0); if (dc->rd) { if (op == 0x41) tcggenshritl(cpuR[dc->rd], cpuR[dc->ra], 1); else tcggensaritl(cpuR[dc->rd], cpuR[dc->ra], 1); } break; case 0x60: LOGDIS(\"ext8s r%d r%d\\n\", dc->rd, dc->ra); tcggenext8si32(cpuR[dc->rd], cpuR[dc->ra]); break; case 0x61: LOGDIS(\"ext16s r%d r%d\\n\", dc->rd, dc->ra); tcggenext16si32(cpuR[dc->rd], cpuR[dc->ra]); break; case 0x64: case 0x66: case 0x74: case 0x76: /* wdc. */ LOGDIS(\"wdc r%d\\n\", dc->ra); if ((dc->tbflags & MSREEFLAG) && memindex == MMUUSERIDX) { tcggenmovitl(cpuSR[SRESR], ESRECPRIVINSN); tgenraiseexception(dc, EXCPHWEXCP); return; } break; case 0x68: /* wic. */ LOGDIS(\"wic r%d\\n\", dc->ra); if ((dc->tbflags & MSREEFLAG) && memindex == MMUUSERIDX) { tcggenmovitl(cpuSR[SRESR], ESRECPRIVINSN); tgenraiseexception(dc, EXCPHWEXCP); return; } break; case 0xe0: if ((dc->tbflags & MSREEFLAG) && (dc->env->pvr.regs[2] & PVR2ILLOPCODEEXCMASK) && !((dc->env->pvr.regs[2] & PVR2USEPCMPINSTR))) { tcggenmovitl(cpuSR[SRESR], ESRECILLEGALOP); tgenraiseexception(dc, EXCPHWEXCP); } if (dc->env->pvr.regs[2] & PVR2USEPCMPINSTR) { genhelperclz(cpuR[dc->rd], cpuR[dc->ra]); } break; case 0x1e0: /* swapb */ LOGDIS(\"swapb r%d r%d\\n\", dc->rd, dc->ra); tcggenbswap32i32(cpuR[dc->rd], cpuR[dc->ra]); break; case 0x1e2: /*swaph */ LOGDIS(\"swaph r%d r%d\\n\", dc->rd, dc->ra); tcggenrotrii32(cpuR[dc->rd], cpuR[dc->ra], 16); break; default: cpuabort(dc->env, \"unknown bit oc=%x op=%x rd=%d ra=%d rb=%d\\n\", dc->pc, op, dc->rd, dc->ra, dc->rb); break; } } ", "target": 0}
{"func": "int memoryregiongetfd(MemoryRegion *mr) { if (mr->alias) { return memoryregiongetfd(mr->alias); } assert(mr->terminates); return qemugetramfd(mr->ramaddr & TARGETPAGEMASK); } ", "target": 0}
{"func": "static void tcgoutinsn3314(TCGContext *s, AArch64Insn insn, TCGReg r1, TCGReg r2, TCGReg rn, tcgtargetlong ofs, bool pre, bool w) { insn |= 1u << 31; /* ext */ insn |= pre << 24; insn |= w << 23; assert(ofs >= -0x200 && ofs < 0x200 && (ofs & 7) == 0); insn |= (ofs & (0x7f << 3)) << (15 - 3); tcgout32(s, insn | r2 << 10 | rn << 5 | r1); } ", "target": 0}
{"func": "static void x86cpuidsettscfreq(Object *obj, Visitor *v, void *opaque, const char *name, Error **errp) { X86CPU *cpu = X86CPU(obj); const int64t min = 0; const int64t max = INTMAX; int64t value; visittypeint(v, &value, name, errp); if (errorisset(errp)) { return; } if (value < min || value > max) { errorset(errp, QERRPROPERTYVALUEOUTOFRANGE, \"\", name ? name : \"null\", value, min, max); return; } cpu->env.tsckhz = value / 1000; } ", "target": 0}
{"func": "static int cowcreate(const char *filename, QemuOpts *opts, Error **errp) { struct cowheaderv2 cowheader; struct stat st; int64t imagesectors = 0; char *imagefilename = NULL; Error *localerr = NULL; int ret; BlockDriverState *cowbs; /* Read out options */ imagesectors = qemuoptgetsizedel(opts, BLOCKOPTSIZE, 0) / 512; imagefilename = qemuoptgetdel(opts, BLOCKOPTBACKINGFILE); ret = bdrvcreatefile(filename, opts, &localerr); if (ret < 0) { errorpropagate(errp, localerr); goto exit; } cowbs = NULL; ret = bdrvopen(&cowbs, filename, NULL, NULL, BDRVORDWR | BDRVOPROTOCOL, NULL, &localerr); if (ret < 0) { errorpropagate(errp, localerr); goto exit; } memset(&cowheader, 0, sizeof(cowheader)); cowheader.magic = cputobe32(COWMAGIC); cowheader.version = cputobe32(COWVERSION); if (imagefilename) { /* Note: if no file, we put a dummy mtime */ cowheader.mtime = cputobe32(0); if (stat(imagefilename, &st) != 0) { goto mtimefail; } cowheader.mtime = cputobe32(st.stmtime); mtimefail: pstrcpy(cowheader.backingfile, sizeof(cowheader.backingfile), imagefilename); } cowheader.sectorsize = cputobe32(512); cowheader.size = cputobe64(imagesectors * 512); ret = bdrvpwrite(cowbs, 0, &cowheader, sizeof(cowheader)); if (ret < 0) { goto exit; } /* resize to include at least all the bitmap */ ret = bdrvtruncate(cowbs, sizeof(cowheader) + ((imagesectors + 7) >> 3)); if (ret < 0) { goto exit; } exit: gfree(imagefilename); bdrvunref(cowbs); return ret; } ", "target": 1}
{"func": "static avcold int checkformat(AVCodecContext *avctx) { AVCodecParserContext *parser; uint8t *pout; int psize; int index; H264Context *h; int ret = -1; /* init parser & parse file */ parser = avparserinit(avctx->codec->id); if (!parser) { avlog(avctx, AVLOGERROR, \"Failed to open H.264 parser.\\n\"); goto final; } parser->flags = PARSERFLAGCOMPLETEFRAMES; index = avparserparse2(parser, avctx, &pout, &psize, NULL, 0, 0, 0, 0); if (index < 0) { avlog(avctx, AVLOGERROR, \"Failed to parse this file.\\n\"); goto releaseparser; } /* check if support */ h = parser->privdata; switch (h->sps.bitdepthluma) { case 8: if (!CHROMA444(h) && !CHROMA422(h)) { // only this will H.264 decoder switch to hwaccel ret = 0; break; } default: avlog(avctx, AVLOGERROR, \"Unsupported file.\\n\"); } releaseparser: avparserclose(parser); final: return ret; } ", "target": 0}
{"func": "static unsigned int decmovemr(DisasContext *dc) { \tint memsize = memsizezz(dc); \tint insnlen; \tDIS(fprintf (logfile, \"move.%c [$r%u%s, $r%u\\n\", \t\t memsizechar(memsize), \t\t dc->op1, dc->postinc ? \"+]\" : \"]\", \t\t dc->op2)); \tif (memsize == 4) { \t\tinsnlen = decprepmovem(dc, 0, 4, cpuR[dc->op2]); \t\tcrisccmask(dc, CCMASKNZ); \t\tcrisupdateccop(dc, CCOPMOVE, 4); \t\tcrisupdateccx(dc); \t\tcrisupdateresult(dc, cpuR[dc->op2]); \t} \telse { \t\tTCGv t0; \t\tt0 = tcgtempnew(TCGTYPETL); \t\tinsnlen = decprepmovem(dc, 0, memsize, t0); \t\tcrisccmask(dc, CCMASKNZ); \t\tcrisalu(dc, CCOPMOVE, \t\t\t cpuR[dc->op2], cpuR[dc->op2], t0, memsize); \t\ttcgtempfree(t0); \t} \tdopostinc(dc, memsize); \treturn insnlen; } ", "target": 0}
{"func": "static int rtcinitfn(ISADevice *dev) { RTCState *s = DOUPCAST(RTCState, dev, dev); int base = 0x70; int isairq = 8; isainitirq(dev, &s->irq, isairq); s->cmosdata[RTCREGA] = 0x26; s->cmosdata[RTCREGB] = 0x02; s->cmosdata[RTCREGC] = 0x00; s->cmosdata[RTCREGD] = 0x80; rtcsetdatefromhost(s); s->periodictimer = qemunewtimer(rtcclock, rtcperiodictimer, s); #ifdef TARGETI386 if (rtctdhack) s->coalescedtimer = qemunewtimer(rtcclock, rtccoalescedtimer, s); #endif s->secondtimer = qemunewtimer(rtcclock, rtcupdatesecond, s); s->secondtimer2 = qemunewtimer(rtcclock, rtcupdatesecond2, s); s->nextsecondtime = qemugetclock(rtcclock) + (gettickspersec() * 99) / 100; qemumodtimer(s->secondtimer2, s->nextsecondtime); registerioportwrite(base, 2, 1, cmosioportwrite, s); registerioportread(base, 2, 1, cmosioportread, s); registersavevm(\"mc146818rtc\", base, 1, rtcsave, rtcload, s); #ifdef TARGETI386 if (rtctdhack) registersavevm(\"mc146818rtc-td\", base, 1, rtcsavetd, rtcloadtd, s); #endif qemuregisterreset(rtcreset, s); return 0; } ", "target": 0}
{"func": "static int virtionetload(QEMUFile *f, void *opaque, int versionid) { VirtIONet *n = opaque; VirtIODevice *vdev = VIRTIODEVICE(n); if (versionid < 2 || versionid > VIRTIONETVMVERSION) return -EINVAL; return virtioload(vdev, f, versionid); } ", "target": 0}
{"func": "static int readpacket(AVFormatContext *s1, AVPacket *pkt) { VideoDemuxData *s = s1->privdata; char filenamebytes[1024]; char *filename = filenamebytes; int i; int size[3]={0}, ret[3]={0}; AVIOContext *f[3] = {NULL}; AVCodecContext *codec= s1->streams[0]->codec; if (!s->ispipe) { /* loop over input */ if (s->loop && s->imgnumber > s->imglast) { s->imgnumber = s->imgfirst; } if (s->imgnumber > s->imglast) return AVERROREOF; if (s->useglob) { #if HAVEGLOB filename = s->globstate.glpathv[s->imgnumber]; #endif } else { if (avgetframefilename(filenamebytes, sizeof(filenamebytes), s->path, s->imgnumber)<0 && s->imgnumber > 1) return AVERROR(EIO); } for(i=0; i<3; i++){ if (avioopen2(&f[i], filename, AVIOFLAGREAD, &s1->interruptcallback, NULL) < 0) { if(i>=1) break; avlog(s1, AVLOGERROR, \"Could not open file : %s\\n\",filename); return AVERROR(EIO); } size[i]= aviosize(f[i]); if(!s->splitplanes) break; filename[ strlen(filename) - 1 ]= 'U' + i; } if(codec->codecid == AVCODECIDRAWVIDEO && !codec->width) infersize(&codec->width, &codec->height, size[0]); } else { f[0] = s1->pb; if (urlfeof(f[0])) return AVERROR(EIO); size[0]= 4096; } avnewpacket(pkt, size[0] + size[1] + size[2]); pkt->streamindex = 0; pkt->flags |= AVPKTFLAGKEY; pkt->size= 0; for(i=0; i<3; i++){ if(f[i]){ ret[i]= avioread(f[i], pkt->data + pkt->size, size[i]); if (!s->ispipe) avioclose(f[i]); if(ret[i]>0) pkt->size += ret[i]; } } if (ret[0] <= 0 || ret[1]<0 || ret[2]<0) { avfreepacket(pkt); return AVERROR(EIO); /* signal EOF */ } else { s->imgcount++; s->imgnumber++; return 0; } } ", "target": 0}
{"func": "static int smackerreadheader(AVFormatContext *s) { AVIOContext *pb = s->pb; SmackerContext *smk = s->privdata; AVStream *st, *ast[7]; int i, ret; int tbase; /* read and check header */ smk->magic = aviorl32(pb); if (smk->magic != MKTAG('S', 'M', 'K', '2') && smk->magic != MKTAG('S', 'M', 'K', '4')) smk->width = aviorl32(pb); smk->height = aviorl32(pb); smk->frames = aviorl32(pb); smk->ptsinc = (int32t)aviorl32(pb); smk->flags = aviorl32(pb); if(smk->flags & SMACKERFLAGRINGFRAME) smk->frames++; for(i = 0; i < 7; i++) smk->audio[i] = aviorl32(pb); smk->treesize = aviorl32(pb); if(smk->treesize >= UINTMAX/4){ // smk->treesize + 16 must not overflow (this check is probably redundant) avlog(s, AVLOGERROR, \"treesize too large\\n\"); //FIXME remove extradata \"rebuilding\" smk->mmapsize = aviorl32(pb); smk->mclrsize = aviorl32(pb); smk->fullsize = aviorl32(pb); smk->typesize = aviorl32(pb); for(i = 0; i < 7; i++) { smk->rates[i] = aviorl24(pb); smk->aflags[i] = avior8(pb); smk->pad = aviorl32(pb); /* setup data */ if(smk->frames > 0xFFFFFF) { avlog(s, AVLOGERROR, \"Too many frames: %\"PRIu32\"\\n\", smk->frames); smk->frmsize = avmallocarray(smk->frames, sizeof(*smk->frmsize)); smk->frmflags = avmalloc(smk->frames); if (!smk->frmsize || !smk->frmflags) { avfreep(&smk->frmsize); avfreep(&smk->frmflags); return AVERROR(ENOMEM); smk->isver4 = (smk->magic != MKTAG('S', 'M', 'K', '2')); /* read frame info */ for(i = 0; i < smk->frames; i++) { smk->frmsize[i] = aviorl32(pb); for(i = 0; i < smk->frames; i++) { smk->frmflags[i] = avior8(pb); /* init video codec */ st = avformatnewstream(s, NULL); if (!st) return AVERROR(ENOMEM); smk->videoindex = st->index; st->codec->width = smk->width; st->codec->height = smk->height; st->codec->pixfmt = AVPIXFMTPAL8; st->codec->codectype = AVMEDIATYPEVIDEO; st->codec->codecid = AVCODECIDSMACKVIDEO; st->codec->codectag = smk->magic; /* Smacker uses 100000 as internal timebase */ if(smk->ptsinc < 0) smk->ptsinc = -smk->ptsinc; else smk->ptsinc *= 100; tbase = 100000; avreduce(&tbase, &smk->ptsinc, tbase, smk->ptsinc, (1UL<<31)-1); avprivsetptsinfo(st, 33, smk->ptsinc, tbase); st->duration = smk->frames; /* handle possible audio streams */ for(i = 0; i < 7; i++) { smk->indexes[i] = -1; if (smk->rates[i]) { ast[i] = avformatnewstream(s, NULL); if (!ast[i]) return AVERROR(ENOMEM); smk->indexes[i] = ast[i]->index; ast[i]->codec->codectype = AVMEDIATYPEAUDIO; if (smk->aflags[i] & SMKAUDBINKAUD) { ast[i]->codec->codecid = AVCODECIDBINKAUDIORDFT; } else if (smk->aflags[i] & SMKAUDUSEDCT) { ast[i]->codec->codecid = AVCODECIDBINKAUDIODCT; } else if (smk->aflags[i] & SMKAUDPACKED){ ast[i]->codec->codecid = AVCODECIDSMACKAUDIO; ast[i]->codec->codectag = MKTAG('S', 'M', 'K', 'A'); } else { ast[i]->codec->codecid = AVCODECIDPCMU8; if (smk->aflags[i] & SMKAUDSTEREO) { ast[i]->codec->channels = 2; ast[i]->codec->channellayout = AVCHLAYOUTSTEREO; } else { ast[i]->codec->channels = 1; ast[i]->codec->channellayout = AVCHLAYOUTMONO; ast[i]->codec->samplerate = smk->rates[i]; ast[i]->codec->bitspercodedsample = (smk->aflags[i] & SMKAUD16BITS) ? 16 : 8; if(ast[i]->codec->bitspercodedsample == 16 && ast[i]->codec->codecid == AVCODECIDPCMU8) ast[i]->codec->codecid = AVCODECIDPCMS16LE; avprivsetptsinfo(ast[i], 64, 1, ast[i]->codec->samplerate * ast[i]->codec->channels * ast[i]->codec->bitspercodedsample / 8); /* load trees to extradata, they will be unpacked by decoder */ if(ffallocextradata(st->codec, smk->treesize + 16)){ avlog(s, AVLOGERROR, \"Cannot allocate %\"PRIu32\" bytes of extradata\\n\", smk->treesize + 16); avfreep(&smk->frmsize); avfreep(&smk->frmflags); return AVERROR(ENOMEM); ret = avioread(pb, st->codec->extradata + 16, st->codec->extradatasize - 16); if(ret != st->codec->extradatasize - 16){ avfreep(&smk->frmsize); avfreep(&smk->frmflags); return AVERROR(EIO); ((int32t*)st->codec->extradata)[0] = avle2ne32(smk->mmapsize); ((int32t*)st->codec->extradata)[1] = avle2ne32(smk->mclrsize); ((int32t*)st->codec->extradata)[2] = avle2ne32(smk->fullsize); ((int32t*)st->codec->extradata)[3] = avle2ne32(smk->typesize); smk->curstream = -1; smk->nextpos = aviotell(pb); return 0;", "target": 1}
{"func": "static int coroutinefn rawcodiscard(BlockDriverState *bs, int64t sectornum, int nbsectors) { return bdrvcodiscard(bs->file->bs, sectornum, nbsectors); } ", "target": 0}
{"func": "BlockAIOCB *bdrvaiowritezeroes(BlockDriverState *bs, int64t sectornum, int nbsectors, BdrvRequestFlags flags, BlockCompletionFunc *cb, void *opaque) { tracebdrvaiowritezeroes(bs, sectornum, nbsectors, flags, opaque); return bdrvcoaiorwvector(bs, sectornum, NULL, nbsectors, BDRVREQZEROWRITE | flags, cb, opaque, true); } ", "target": 0}
{"func": "static void virtiopcireset(DeviceState *d) { VirtIOPCIProxy *proxy = containerof(d, VirtIOPCIProxy, pcidev.qdev); virtioreset(proxy->vdev); msixreset(&proxy->pcidev); proxy->flags = 0; } ", "target": 0}
{"func": "static void tcgoutdatrIK(TCGContext *s, int cond, int opc, int opinv, TCGReg dst, TCGReg lhs, TCGArg rhs, bool rhsisconst) { /* Emit either the reg,imm or reg,reg form of a data-processing insn. * rhs must satisfy the \"rIK\" constraint. */ if (rhsisconst) { int rot = encodeimm(rhs); if (rot < 0) { rhs = ~rhs; rot = encodeimm(rhs); assert(rot >= 0); opc = opinv; } tcgoutdatimm(s, cond, opc, dst, lhs, rotl(rhs, rot) | (rot << 7)); } else { tcgoutdatreg(s, cond, opc, dst, lhs, rhs, SHIFTIMMLSL(0)); } } ", "target": 0}
{"func": "static int twl92230init(i2cslave *i2c) { MenelausState *s = FROMI2CSLAVE(MenelausState, i2c); s->rtc.hztm = qemunewtimer(rtclock, menelausrtchz, s); /* Three output pins plus one interrupt pin. */ qdevinitgpioout(&i2c->qdev, s->out, 4); qdevinitgpioin(&i2c->qdev, menelausgpioset, 3); s->pwrbtn = qemuallocateirqs(menelauspwrbtnset, s, 1)[0]; menelausreset(&s->i2c); return 0; } ", "target": 0}
{"func": "static int movwritepacket(AVFormatContext *s, AVPacket *pkt) { MOVContext *mov = s->privdata; ByteIOContext *pb = s->pb; MOVTrack *trk = &mov->tracks[pkt->streamindex]; AVCodecContext *enc = trk->enc; unsigned int samplesInChunk = 0; int size= pkt->size; if (urlisstreamed(s->pb)) return 0; /* Can't handle that */ if (!size) return 0; /* Discard 0 sized packets */ if (enc->codecid == CODECIDAMRNB) { /* We must find out how many AMR blocks there are in one packet */ static uint16t packedsize[16] = {13, 14, 16, 18, 20, 21, 27, 32, 6, 0, 0, 0, 0, 0, 0, 0}; int len = 0; while (len < size && samplesInChunk < 100) { len += packedsize[(pkt->data[len] >> 3) & 0x0F]; samplesInChunk++; } if(samplesInChunk > 1){ avlog(s, AVLOGERROR, \"fatal error, input is not a single packet, implement a AVParser for it\\n\"); return -1; } } else if (trk->sampleSize) samplesInChunk = size/trk->sampleSize; else samplesInChunk = 1; /* copy extradata if it exists */ if (trk->vosLen == 0 && enc->extradatasize > 0) { trk->vosLen = enc->extradatasize; trk->vosData = avmalloc(trk->vosLen); memcpy(trk->vosData, enc->extradata, trk->vosLen); } if (enc->codecid == CODECIDH264 && trk->vosLen > 0 && *(uint8t *)trk->vosData != 1) { /* from x264 or from bytestream h264 */ /* nal reformating needed */ int ret = ffavcparsenalunits(pkt->data, &pkt->data, &pkt->size); if (ret < 0) return ret; assert(pkt->size); size = pkt->size; } else if (enc->codecid == CODECIDDNXHD && !trk->vosLen) { /* copy frame to create needed atoms */ trk->vosLen = size; trk->vosData = avmalloc(size); memcpy(trk->vosData, pkt->data, size); } if (!(trk->entry % MOVINDEXCLUSTERSIZE)) { trk->cluster = avrealloc(trk->cluster, (trk->entry + MOVINDEXCLUSTERSIZE) * sizeof(*trk->cluster)); if (!trk->cluster) return -1; } trk->cluster[trk->entry].pos = urlftell(pb); trk->cluster[trk->entry].samplesInChunk = samplesInChunk; trk->cluster[trk->entry].size = size; trk->cluster[trk->entry].entries = samplesInChunk; trk->cluster[trk->entry].dts = pkt->dts; trk->trackDuration = pkt->dts - trk->cluster[0].dts + pkt->duration; if (pkt->pts == AVNOPTSVALUE) { avlog(s, AVLOGWARNING, \"pts has no value\\n\"); pkt->pts = pkt->dts; } if (pkt->dts != pkt->pts) trk->hasBframes = 1; trk->cluster[trk->entry].cts = pkt->pts - pkt->dts; trk->cluster[trk->entry].keyframe = !!(pkt->flags & PKTFLAGKEY); if(trk->cluster[trk->entry].keyframe) trk->hasKeyframes++; trk->entry++; trk->sampleCount += samplesInChunk; mov->mdatsize += size; putbuffer(pb, pkt->data, size); putflushpacket(pb); return 0; }", "target": 1}
{"func": "static void genstcond (DisasContext *ctx, uint32t opc, int rt, int base, int16t offset) { const char *opn = \"stcond\"; TCGv t0, t1; t0 = tcgtemplocalnew(); genbaseoffsetaddr(ctx, t0, base, offset); /* Don't do NOP if destination is zero: we must perform the actual memory access. */ t1 = tcgtemplocalnew(); genloadgpr(t1, rt); switch (opc) { #if defined(TARGETMIPS64) case OPCSCD: savecpustate(ctx, 0); opstscd(t1, t0, rt, ctx); opn = \"scd\"; break; #endif case OPCSC: savecpustate(ctx, 1); opstsc(t1, t0, rt, ctx); opn = \"sc\"; break; } (void)opn; /* avoid a compiler warning */ MIPSDEBUG(\"%s %s, %d(%s)\", opn, regnames[rt], offset, regnames[base]); tcgtempfree(t1); tcgtempfree(t0); } ", "target": 1}
{"func": "static int32t bmdmapreparebuf(IDEDMA *dma, int iswrite) { BMDMAState *bm = DOUPCAST(BMDMAState, dma, dma); IDEState *s = bmdmaactiveif(bm); PCIDevice *pcidev = PCIDEVICE(bm->pcidev); struct { uint32t addr; uint32t size; } prd; int l, len; pcidmasglistinit(&s->sg, pcidev, s->nsector / (BMDMAPAGESIZE / 512) + 1); s->iobuffersize = 0; for(;;) { if (bm->curprdlen == 0) { /* end of table (with a fail safe of one page) */ if (bm->curprdlast || (bm->curaddr - bm->addr) >= BMDMAPAGESIZE) { return s->iobuffersize; } pcidmaread(pcidev, bm->curaddr, &prd, 8); bm->curaddr += 8; prd.addr = le32tocpu(prd.addr); prd.size = le32tocpu(prd.size); len = prd.size & 0xfffe; if (len == 0) len = 0x10000; bm->curprdlen = len; bm->curprdaddr = prd.addr; bm->curprdlast = (prd.size & 0x80000000); } l = bm->curprdlen; if (l > 0) { qemusglistadd(&s->sg, bm->curprdaddr, l); /* Note: We limit the max transfer to be 2GiB. * This should accommodate the largest ATA transaction * for LBA48 (65,536 sectors) and 32K sector sizes. */ if (s->sg.size > INT32MAX) { errorreport(\"IDE: sglist describes more than 2GiB.\"); break; } bm->curprdaddr += l; bm->curprdlen -= l; s->iobuffersize += l; } } qemusglistdestroy(&s->sg); s->iobuffersize = 0; return -1; } ", "target": 1}
{"func": "static int applywindowandmdct(vorbisenccontext *venc, float *audio, int samples) { int channel; const float * win = venc->win[0]; int windowlen = 1 << (venc->log2blocksize[0] - 1); float n = (float)(1 << venc->log2blocksize[0]) / 4.0; AVFloatDSPContext *fdsp = venc->fdsp; if (!venc->havesaved && !samples) return 0; if (venc->havesaved) { for (channel = 0; channel < venc->channels; channel++) memcpy(venc->samples + channel * windowlen * 2, venc->saved + channel * windowlen, sizeof(float) * windowlen); } else { for (channel = 0; channel < venc->channels; channel++) memset(venc->samples + channel * windowlen * 2, 0, sizeof(float) * windowlen); } if (samples) { for (channel = 0; channel < venc->channels; channel++) { float *offset = venc->samples + channel * windowlen * 2 + windowlen; fdsp->vectorfmulreverse(offset, audio + channel * windowlen, win, samples); fdsp->vectorfmulscalar(offset, offset, 1/n, samples); } } else { for (channel = 0; channel < venc->channels; channel++) memset(venc->samples + channel * windowlen * 2 + windowlen, 0, sizeof(float) * windowlen); } for (channel = 0; channel < venc->channels; channel++) venc->mdct[0].mdctcalc(&venc->mdct[0], venc->coeffs + channel * windowlen, venc->samples + channel * windowlen * 2); if (samples) { for (channel = 0; channel < venc->channels; channel++) { float *offset = venc->saved + channel * windowlen; fdsp->vectorfmul(offset, audio + channel * windowlen, win, samples); fdsp->vectorfmulscalar(offset, offset, 1/n, samples); } venc->havesaved = 1; } else { venc->havesaved = 0; } return 1; } ", "target": 0}
{"func": "static inline int popcountl(unsigned long l) { return BITSPERLONG == 32 ? ctpop32(l) : ctpop64(l); } ", "target": 1}
{"func": "static int32t parsegain(const char *gain) { char *fraction; int scale = 10000; int32t mb = 0; int sign = 1; int db; if (!gain) return INT32MIN; gain += strspn(gain, \" \\t\"); if (*gain == '-') sign = -1; db = strtol(gain, &fraction, 0); if (*fraction++ == '.') { while (avisdigit(*fraction) && scale) { mb += scale * (*fraction - '0'); scale /= 10; fraction++; } } if (abs(db) > (INT32MAX - mb) / 100000) return INT32MIN; return db * 100000 + sign * mb; } ", "target": 1}
{"func": "static inline void idedmasubmitcheck(IDEState *s, BlockDriverCompletionFunc *dmacb) { if (s->bus->dma->aiocb) \treturn; dmacb(s, -1); } ", "target": 1}
{"func": "static BlockStats *bdrvquerybdsstats(const BlockDriverState *bs, bool querybacking) { BlockStats *s = NULL; s = gmalloc0(sizeof(*s)); s->stats = gmalloc0(sizeof(*s->stats)); if (!bs) { return s; } if (bdrvgetnodename(bs)[0]) { s->hasnodename = true; s->nodename = gstrdup(bdrvgetnodename(bs)); } s->stats->wrhighestoffset = stat64get(&bs->wrhighestoffset); if (bs->file) { s->hasparent = true; s->parent = bdrvquerybdsstats(bs->file->bs, querybacking); } if (querybacking && bs->backing) { s->hasbacking = true; s->backing = bdrvquerybdsstats(bs->backing->bs, querybacking); } return s; } ", "target": 1}
{"func": "static int lagdecodezerorunline(LagarithContext *l, uint8t *dst, const uint8t *src, const uint8t *srcend, int width, int esccount) { int i = 0; int count; uint8t zerorun = 0; const uint8t *srcstart = src; uint8t mask1 = -(esccount < 2); uint8t mask2 = -(esccount < 3); uint8t *end = dst + (width - 2); avprivrequestsample(l->avctx, \"zerorunline\"); return AVERRORPATCHWELCOME; outputzeros: if (l->zerosrem) { count = FFMIN(l->zerosrem, width - i); if (end - dst < count) { avlog(l->avctx, AVLOGERROR, \"Too many zeros remaining.\\n\"); return AVERRORINVALIDDATA; } memset(dst, 0, count); l->zerosrem -= count; dst += count; } while (dst < end) { i = 0; while (!zerorun && dst + i < end) { i++; if (i+2 >= srcend - src) return AVERRORINVALIDDATA; zerorun = !(src[i] | (src[i + 1] & mask1) | (src[i + 2] & mask2)); } if (zerorun) { zerorun = 0; i += esccount; memcpy(dst, src, i); dst += i; l->zerosrem = lagcalczerorun(src[i]); src += i + 1; goto outputzeros; } else { memcpy(dst, src, i); src += i; dst += i; } } return src - srcstart; } ", "target": 1}
{"func": "static int raminitall(RAMState **rsp) { Error *localerr = NULL; if (ramstateinit(rsp)) { return -1; } if (migrateusexbzrle()) { XBZRLEcachelock(); XBZRLE.zerotargetpage = gmalloc0(TARGETPAGESIZE); XBZRLE.cache = cacheinit(migratexbzrlecachesize(), TARGETPAGESIZE, &localerr); if (!XBZRLE.cache) { XBZRLEcacheunlock(); errorreporterr(localerr); gfree(*rsp); *rsp = NULL; return -1; } XBZRLEcacheunlock(); /* We prefer not to abort if there is no memory */ XBZRLE.encodedbuf = gtrymalloc0(TARGETPAGESIZE); if (!XBZRLE.encodedbuf) { errorreport(\"Error allocating encodedbuf\"); gfree(*rsp); *rsp = NULL; return -1; } XBZRLE.currentbuf = gtrymalloc(TARGETPAGESIZE); if (!XBZRLE.currentbuf) { errorreport(\"Error allocating currentbuf\"); gfree(XBZRLE.encodedbuf); XBZRLE.encodedbuf = NULL; gfree(*rsp); *rsp = NULL; return -1; } } /* For memoryglobaldirtylogstart below. */ qemumutexlockiothread(); qemumutexlockramlist(); rcureadlock(); /* Skip setting bitmap if there is no RAM */ if (rambytestotal()) { RAMBlock *block; QLISTFOREACHRCU(block, &ramlist.blocks, next) { unsigned long pages = block->maxlength >> TARGETPAGEBITS; block->bmap = bitmapnew(pages); bitmapset(block->bmap, 0, pages); if (migratepostcopyram()) { block->unsentmap = bitmapnew(pages); bitmapset(block->unsentmap, 0, pages); } } } memoryglobaldirtylogstart(); migrationbitmapsync(*rsp); qemumutexunlockramlist(); qemumutexunlockiothread(); rcureadunlock(); return 0; } ", "target": 1}
{"func": "static void avalwaysinline filtermbedgecv( uint8t *pix, int stride, int16t bS[4], unsigned int qp, H264Context *h ) { const unsigned int indexa = qp + h->slicealphac0offset; const int alpha = alphatable[indexa]; const int beta = betatable[qp + h->slicebetaoffset]; if (alpha ==0 || beta == 0) return; if( bS[0] < 4 ) { int8t tc[4]; tc[0] = tc0table[indexa][bS[0]]+1; tc[1] = tc0table[indexa][bS[1]]+1; tc[2] = tc0table[indexa][bS[2]]+1; tc[3] = tc0table[indexa][bS[3]]+1; h->h264dsp.h264hloopfilterchroma(pix, stride, alpha, beta, tc); } else { h->h264dsp.h264hloopfilterchromaintra(pix, stride, alpha, beta); } } ", "target": 0}
{"func": "static int decodeentropycodedimage(WebPContext *s, enum ImageRole role, int w, int h) { ImageContext *img; HuffReader *hg; int i, j, ret, x, y, width; img = &s->image[role]; img->role = role; if (!img->frame) { img->frame = avframealloc(); if (!img->frame) return AVERROR(ENOMEM); } img->frame->format = AVPIXFMTARGB; img->frame->width = w; img->frame->height = h; if (role == IMAGEROLEARGB && !img->isalphaprimary) { ThreadFrame pt = { .f = img->frame }; ret = ffthreadgetbuffer(s->avctx, &pt, 0); } else ret = avframegetbuffer(img->frame, 1); if (ret < 0) return ret; if (getbits1(&s->gb)) { img->colorcachebits = getbits(&s->gb, 4); if (img->colorcachebits < 1 || img->colorcachebits > 11) { avlog(s->avctx, AVLOGERROR, \"invalid color cache bits: %d\\n\", img->colorcachebits); return AVERRORINVALIDDATA; } img->colorcache = avmalloczarray(1 << img->colorcachebits, sizeof(*img->colorcache)); if (!img->colorcache) return AVERROR(ENOMEM); } else { img->colorcachebits = 0; } img->nbhuffmangroups = 1; if (role == IMAGEROLEARGB && getbits1(&s->gb)) { ret = decodeentropyimage(s); if (ret < 0) return ret; img->nbhuffmangroups = s->nbhuffmangroups; } img->huffmangroups = avmalloczarray(img->nbhuffmangroups * HUFFMANCODESPERMETACODE, sizeof(*img->huffmangroups)); if (!img->huffmangroups) return AVERROR(ENOMEM); for (i = 0; i < img->nbhuffmangroups; i++) { hg = &img->huffmangroups[i * HUFFMANCODESPERMETACODE]; for (j = 0; j < HUFFMANCODESPERMETACODE; j++) { int alphabetsize = alphabetsizes[j]; if (!j && img->colorcachebits > 0) alphabetsize += 1 << img->colorcachebits; if (getbits1(&s->gb)) { readhuffmancodesimple(s, &hg[j]); } else { ret = readhuffmancodenormal(s, &hg[j], alphabetsize); if (ret < 0) return ret; } } } width = img->frame->width; if (role == IMAGEROLEARGB && s->reducedwidth > 0) width = s->reducedwidth; x = 0; y = 0; while (y < img->frame->height) { int v; hg = gethuffmangroup(s, img, x, y); v = huffreadergetsymbol(&hg[HUFFIDXGREEN], &s->gb); if (v < NUMLITERALCODES) { /* literal pixel values */ uint8t *p = GETPIXEL(img->frame, x, y); p[2] = v; p[1] = huffreadergetsymbol(&hg[HUFFIDXRED], &s->gb); p[3] = huffreadergetsymbol(&hg[HUFFIDXBLUE], &s->gb); p[0] = huffreadergetsymbol(&hg[HUFFIDXALPHA], &s->gb); if (img->colorcachebits) colorcacheput(img, AVRB32(p)); x++; if (x == width) { x = 0; y++; } } else if (v < NUMLITERALCODES + NUMLENGTHCODES) { /* LZ77 backwards mapping */ int prefixcode, length, distance, refx, refy; /* parse length and distance */ prefixcode = v - NUMLITERALCODES; if (prefixcode < 4) { length = prefixcode + 1; } else { int extrabits = (prefixcode - 2) >> 1; int offset = 2 + (prefixcode & 1) << extrabits; length = offset + getbits(&s->gb, extrabits) + 1; } prefixcode = huffreadergetsymbol(&hg[HUFFIDXDIST], &s->gb); if (prefixcode > 39) { avlog(s->avctx, AVLOGERROR, \"distance prefix code too large: %d\\n\", prefixcode); return AVERRORINVALIDDATA; } if (prefixcode < 4) { distance = prefixcode + 1; } else { int extrabits = prefixcode - 2 >> 1; int offset = 2 + (prefixcode & 1) << extrabits; distance = offset + getbits(&s->gb, extrabits) + 1; } /* find reference location */ if (distance <= NUMSHORTDISTANCES) { int xi = lz77distanceoffsets[distance - 1][0]; int yi = lz77distanceoffsets[distance - 1][1]; distance = FFMAX(1, xi + yi * width); } else { distance -= NUMSHORTDISTANCES; } refx = x; refy = y; if (distance <= x) { refx -= distance; distance = 0; } else { refx = 0; distance -= x; } while (distance >= width) { refy--; distance -= width; } if (distance > 0) { refx = width - distance; refy--; } refx = FFMAX(0, refx); refy = FFMAX(0, refy); /* copy pixels * source and dest regions can overlap and wrap lines, so just * copy per-pixel */ for (i = 0; i < length; i++) { uint8t *pref = GETPIXEL(img->frame, refx, refy); uint8t *p = GETPIXEL(img->frame, x, y); AVCOPY32(p, pref); if (img->colorcachebits) colorcacheput(img, AVRB32(p)); x++; refx++; if (x == width) { x = 0; y++; } if (refx == width) { refx = 0; refy++; } if (y == img->frame->height || refy == img->frame->height) break; } } else { /* read from color cache */ uint8t *p = GETPIXEL(img->frame, x, y); int cacheidx = v - (NUMLITERALCODES + NUMLENGTHCODES); if (!img->colorcachebits) { avlog(s->avctx, AVLOGERROR, \"color cache not found\\n\"); return AVERRORINVALIDDATA; } if (cacheidx >= 1 << img->colorcachebits) { avlog(s->avctx, AVLOGERROR, \"color cache index out-of-bounds\\n\"); return AVERRORINVALIDDATA; } AVWB32(p, img->colorcache[cacheidx]); x++; if (x == width) { x = 0; y++; } } } return 0; } ", "target": 1}
{"func": "void ffmspelmotion(MpegEncContext *s, uint8t *desty, uint8t *destcb, uint8t *destcr, uint8t **refpicture, oppixelsfunc (*pixop)[4], int motionx, int motiony, int h) { Wmv2Context * const w= (Wmv2Context*)s; uint8t *ptr; int dxy, offset, mx, my, srcx, srcy, vedgepos, linesize, uvlinesize; int emu=0; dxy = ((motiony & 1) << 1) | (motionx & 1); dxy = 2*dxy + w->hshift; srcx = s->mbx * 16 + (motionx >> 1); srcy = s->mby * 16 + (motiony >> 1); /* WARNING: do no forget half pels */ vedgepos = s->vedgepos; srcx = avclip(srcx, -16, s->width); srcy = avclip(srcy, -16, s->height); if(srcx<=-16 || srcx >= s->width) dxy &= ~3; if(srcy<=-16 || srcy >= s->height) dxy &= ~4; linesize = s->linesize; uvlinesize = s->uvlinesize; ptr = refpicture[0] + (srcy * linesize) + srcx; if(srcx<1 || srcy<1 || srcx + 17 >= s->hedgepos || srcy + h+1 >= vedgepos){ s->vdsp.emulatededgemc(s->edgeemubuffer, ptr - 1 - s->linesize, s->linesize, 19, 19, srcx-1, srcy-1, s->hedgepos, s->vedgepos); ptr= s->edgeemubuffer + 1 + s->linesize; emu=1; } s->dsp.putmspelpixelstab[dxy](desty , ptr , linesize); s->dsp.putmspelpixelstab[dxy](desty+8 , ptr+8 , linesize); s->dsp.putmspelpixelstab[dxy](desty +8*linesize, ptr +8*linesize, linesize); s->dsp.putmspelpixelstab[dxy](desty+8+8*linesize, ptr+8+8*linesize, linesize); if(s->flags&CODECFLAGGRAY) return; if (s->outformat == FMTH263) { dxy = 0; if ((motionx & 3) != 0) dxy |= 1; if ((motiony & 3) != 0) dxy |= 2; mx = motionx >> 2; my = motiony >> 2; } else { mx = motionx / 2; my = motiony / 2; dxy = ((my & 1) << 1) | (mx & 1); mx >>= 1; my >>= 1; } srcx = s->mbx * 8 + mx; srcy = s->mby * 8 + my; srcx = avclip(srcx, -8, s->width >> 1); if (srcx == (s->width >> 1)) dxy &= ~1; srcy = avclip(srcy, -8, s->height >> 1); if (srcy == (s->height >> 1)) dxy &= ~2; offset = (srcy * uvlinesize) + srcx; ptr = refpicture[1] + offset; if(emu){ s->vdsp.emulatededgemc(s->edgeemubuffer, ptr, s->uvlinesize, 9, 9, srcx, srcy, s->hedgepos>>1, s->vedgepos>>1); ptr= s->edgeemubuffer; } pixop[1][dxy](destcb, ptr, uvlinesize, h >> 1); ptr = refpicture[2] + offset; if(emu){ s->vdsp.emulatededgemc(s->edgeemubuffer, ptr, s->uvlinesize, 9, 9, srcx, srcy, s->hedgepos>>1, s->vedgepos>>1); ptr= s->edgeemubuffer; } pixop[1][dxy](destcr, ptr, uvlinesize, h >> 1); } ", "target": 1}
{"func": "static int svq1encodeplane(SVQ1Context *s, int plane, unsigned char *srcplane, unsigned char *refplane, unsigned char *decodedplane, int width, int height, int srcstride, int stride) { const AVFrame *f = s->avctx->codedframe; int x, y; int i; int blockwidth, blockheight; int level; int threshold[6]; uint8t *src = s->scratchbuf + stride * 16; const int lambda = (f->quality * f->quality) >> (2 * FFLAMBDASHIFT); /* figure out the acceptable level thresholds in advance */ threshold[5] = QUALITYTHRESHOLD; for (level = 4; level >= 0; level--) threshold[level] = threshold[level + 1] * THRESHOLDMULTIPLIER; blockwidth = (width + 15) / 16; blockheight = (height + 15) / 16; if (f->picttype == AVPICTURETYPEP) { s->m.avctx = s->avctx; s->m.currentpictureptr = &s->m.currentpicture; s->m.lastpictureptr = &s->m.lastpicture; s->m.lastpicture.f.data[0] = refplane; s->m.linesize = s->m.lastpicture.f.linesize[0] = s->m.newpicture.f.linesize[0] = s->m.currentpicture.f.linesize[0] = stride; s->m.width = width; s->m.height = height; s->m.mbwidth = blockwidth; s->m.mbheight = blockheight; s->m.mbstride = s->m.mbwidth + 1; s->m.b8stride = 2 * s->m.mbwidth + 1; s->m.fcode = 1; s->m.picttype = f->picttype; s->m.memethod = s->avctx->memethod; s->m.me.scenechangescore = 0; s->m.flags = s->avctx->flags; // s->m.outformat = FMTH263; // s->m.unrestrictedmv = 1; s->m.lambda = f->quality; s->m.qscale = s->m.lambda * 139 + FFLAMBDASCALE * 64 >> FFLAMBDASHIFT + 7; s->m.lambda2 = s->m.lambda * s->m.lambda + FFLAMBDASCALE / 2 >> FFLAMBDASHIFT; if (!s->motionval8[plane]) { s->motionval8[plane] = avmallocz((s->m.b8stride * blockheight * 2 + 2) * 2 * sizeof(int16t)); s->motionval16[plane] = avmallocz((s->m.mbstride * (blockheight + 2) + 1) * 2 * sizeof(int16t)); } s->m.mbtype = s->mbtype; // dummies, to avoid segfaults s->m.currentpicture.mbmean = (uint8t *)s->dummy; s->m.currentpicture.mbvar = (uint16t *)s->dummy; s->m.currentpicture.mcmbvar = (uint16t *)s->dummy; s->m.currentpicture.mbtype = s->dummy; s->m.currentpicture.motionval[0] = s->motionval8[plane] + 2; s->m.pmvtable = s->motionval16[plane] + s->m.mbstride + 1; s->m.dsp = s->dsp; // move ffinitme(&s->m); s->m.me.diasize = s->avctx->diasize; s->m.firstsliceline = 1; for (y = 0; y < blockheight; y++) { s->m.newpicture.f.data[0] = src - y * 16 * stride; // ugly s->m.mby = y; for (i = 0; i < 16 && i + 16 * y < height; i++) { memcpy(&src[i * stride], &srcplane[(i + 16 * y) * srcstride], width); for (x = width; x < 16 * blockwidth; x++) src[i * stride + x] = src[i * stride + x - 1]; } for (; i < 16 && i + 16 * y < 16 * blockheight; i++) memcpy(&src[i * stride], &src[(i - 1) * stride], 16 * blockwidth); for (x = 0; x < blockwidth; x++) { s->m.mbx = x; ffinitblockindex(&s->m); ffupdateblockindex(&s->m); ffestimatepframemotion(&s->m, x, y); } s->m.firstsliceline = 0; } fffixlongpmvs(&s->m); fffixlongmvs(&s->m, NULL, 0, s->m.pmvtable, s->m.fcode, CANDIDATEMBTYPEINTER, 0); } s->m.firstsliceline = 1; for (y = 0; y < blockheight; y++) { for (i = 0; i < 16 && i + 16 * y < height; i++) { memcpy(&src[i * stride], &srcplane[(i + 16 * y) * srcstride], width); for (x = width; x < 16 * blockwidth; x++) src[i * stride + x] = src[i * stride + x - 1]; } for (; i < 16 && i + 16 * y < 16 * blockheight; i++) memcpy(&src[i * stride], &src[(i - 1) * stride], 16 * blockwidth); s->m.mby = y; for (x = 0; x < blockwidth; x++) { uint8t reorderbuffer[3][6][7 * 32]; int count[3][6]; int offset = y * 16 * stride + x * 16; uint8t *decoded = decodedplane + offset; uint8t *ref = refplane + offset; int score[4] = { 0, 0, 0, 0 }, best; uint8t *temp = s->scratchbuf; if (s->pb.bufend - s->pb.buf - (putbitscount(&s->pb) >> 3) < 3000) { // FIXME: check size avlog(s->avctx, AVLOGERROR, \"encoded frame too large\\n\"); return -1; } s->m.mbx = x; ffinitblockindex(&s->m); ffupdateblockindex(&s->m); if (f->picttype == AVPICTURETYPEI || (s->m.mbtype[x + y * s->m.mbstride] & CANDIDATEMBTYPEINTRA)) { for (i = 0; i < 6; i++) initputbits(&s->reorderpb[i], reorderbuffer[0][i], 7 * 32); if (f->picttype == AVPICTURETYPEP) { const uint8t *vlc = ffsvq1blocktypevlc[SVQ1BLOCKINTRA]; putbits(&s->reorderpb[5], vlc[1], vlc[0]); score[0] = vlc[1] * lambda; } score[0] += encodeblock(s, src + 16 * x, NULL, temp, stride, 5, 64, lambda, 1); for (i = 0; i < 6; i++) { count[0][i] = putbitscount(&s->reorderpb[i]); flushputbits(&s->reorderpb[i]); } } else score[0] = INTMAX; best = 0; if (f->picttype == AVPICTURETYPEP) { const uint8t *vlc = ffsvq1blocktypevlc[SVQ1BLOCKINTER]; int mx, my, predx, predy, dxy; int16t *motionptr; motionptr = ffh263predmotion(&s->m, 0, 0, &predx, &predy); if (s->m.mbtype[x + y * s->m.mbstride] & CANDIDATEMBTYPEINTER) { for (i = 0; i < 6; i++) initputbits(&s->reorderpb[i], reorderbuffer[1][i], 7 * 32); putbits(&s->reorderpb[5], vlc[1], vlc[0]); s->m.pb = s->reorderpb[5]; mx = motionptr[0]; my = motionptr[1]; assert(mx >= -32 && mx <= 31); assert(my >= -32 && my <= 31); assert(predx >= -32 && predx <= 31); assert(predy >= -32 && predy <= 31); ffh263encodemotion(&s->m, mx - predx, 1); ffh263encodemotion(&s->m, my - predy, 1); s->reorderpb[5] = s->m.pb; score[1] += lambda * putbitscount(&s->reorderpb[5]); dxy = (mx & 1) + 2 * (my & 1); s->hdsp.putpixelstab[0][dxy](temp + 16, ref + (mx >> 1) + stride * (my >> 1), stride, 16); score[1] += encodeblock(s, src + 16 * x, temp + 16, decoded, stride, 5, 64, lambda, 0); best = score[1] <= score[0]; vlc = ffsvq1blocktypevlc[SVQ1BLOCKSKIP]; score[2] = s->dsp.sse[0](NULL, src + 16 * x, ref, stride, 16); score[2] += vlc[1] * lambda; if (score[2] < score[best] && mx == 0 && my == 0) { best = 2; s->hdsp.putpixelstab[0][0](decoded, ref, stride, 16); for (i = 0; i < 6; i++) count[2][i] = 0; putbits(&s->pb, vlc[1], vlc[0]); } } if (best == 1) { for (i = 0; i < 6; i++) { count[1][i] = putbitscount(&s->reorderpb[i]); flushputbits(&s->reorderpb[i]); } } else { motionptr[0] = motionptr[1] = motionptr[2] = motionptr[3] = motionptr[0 + 2 * s->m.b8stride] = motionptr[1 + 2 * s->m.b8stride] = motionptr[2 + 2 * s->m.b8stride] = motionptr[3 + 2 * s->m.b8stride] = 0; } } s->rdtotal += score[best]; for (i = 5; i >= 0; i--) avprivcopybits(&s->pb, reorderbuffer[best][i], count[best][i]); if (best == 0) s->hdsp.putpixelstab[0][0](decoded, temp, stride, 16); } s->m.firstsliceline = 0; } return 0; } ", "target": 1}
{"func": "static int ffmmaladdpacket(AVCodecContext *avctx, AVPacket *avpkt, int isextradata) { MMALDecodeContext *ctx = avctx->privdata; AVBufferRef *buf = NULL; int size = 0; uint8t *data = (uint8t *)\"\"; uint8t *start; int ret = 0; if (avpkt->size) { if (avpkt->buf) { buf = avbufferref(avpkt->buf); size = avpkt->size; data = avpkt->data; } else { buf = avbufferalloc(avpkt->size); if (buf) { memcpy(buf->data, avpkt->data, avpkt->size); size = buf->size; data = buf->data; } } if (!buf) { ret = AVERROR(ENOMEM); goto done; } if (!isextradata) ctx->packetssent++; } else { if (!ctx->packetssent) { // Short-cut the flush logic to avoid upsetting MMAL. ctx->eossent = 1; ctx->eosreceived = 1; goto done; } } start = data; do { FFBufferEntry *buffer = avmallocz(sizeof(*buffer)); if (!buffer) { ret = AVERROR(ENOMEM); goto done; } buffer->data = data; buffer->length = FFMIN(size, ctx->decoder->input[0]->buffersize); if (isextradata) buffer->flags |= MMALBUFFERHEADERFLAGCONFIG; if (data == start) buffer->flags |= MMALBUFFERHEADERFLAGFRAMESTART; data += buffer->length; size -= buffer->length; buffer->pts = avpkt->pts == AVNOPTSVALUE ? MMALTIMEUNKNOWN : avpkt->pts; buffer->dts = avpkt->dts == AVNOPTSVALUE ? MMALTIMEUNKNOWN : avpkt->dts; if (!size) buffer->flags |= MMALBUFFERHEADERFLAGFRAMEEND; if (!buffer->length) { buffer->flags |= MMALBUFFERHEADERFLAGEOS; ctx->eossent = 1; } if (buf) { buffer->ref = avbufferref(buf); if (!buffer->ref) { avfree(buffer); ret = AVERROR(ENOMEM); goto done; } } // Insert at end of the list if (!ctx->waitingbuffers) ctx->waitingbuffers = buffer; if (ctx->waitingbufferstail) ctx->waitingbufferstail->next = buffer; ctx->waitingbufferstail = buffer; } while (size); done: avbufferunref(&buf); return ret; } ", "target": 1}
{"func": "static void writeframe(AVFormatContext *s, AVPacket *pkt, OutputStream *ost) { AVBitStreamFilterContext *bsfc = ost->bitstreamfilters; AVCodecContext *avctx = ost->st->codec; int ret; if ((avctx->codectype == AVMEDIATYPEVIDEO && videosyncmethod == VSYNCDROP) || (avctx->codectype == AVMEDIATYPEAUDIO && audiosyncmethod < 0)) pkt->pts = pkt->dts = AVNOPTSVALUE; if (avctx->codectype == AVMEDIATYPEAUDIO && pkt->dts != AVNOPTSVALUE) { int64t max = ost->st->curdts + !(s->oformat->flags & AVFMTTSNONSTRICT); if (ost->st->curdts && ost->st->curdts != AVNOPTSVALUE && max > pkt->dts) { avlog(s, max - pkt->dts > 2 ? AVLOGWARNING : AVLOGDEBUG, \"Audio timestamp %\"PRId64\" < %\"PRId64\" invalid, cliping\\n\", pkt->dts, max); pkt->pts = pkt->dts = max; /* * Audio encoders may split the packets -- #frames in != #packets out. * But there is no reordering, so we can limit the number of output packets * by simply dropping them here. * Counting encoded video frames needs to be done separately because of * reordering, see dovideoout() */ if (!(avctx->codectype == AVMEDIATYPEVIDEO && avctx->codec)) { if (ost->framenumber >= ost->maxframes) { avfreepacket(pkt); return; ost->framenumber++; while (bsfc) { AVPacket newpkt = *pkt; int a = avbitstreamfilterfilter(bsfc, avctx, NULL, &newpkt.data, &newpkt.size, pkt->data, pkt->size, pkt->flags & AVPKTFLAGKEY); if (a > 0) { avfreepacket(pkt); newpkt.destruct = avdestructpacket; } else if (a < 0) { avlog(NULL, AVLOGERROR, \"Failed to open bitstream filter %s for stream %d with codec %s\", bsfc->filter->name, pkt->streamindex, avctx->codec ? avctx->codec->name : \"copy\"); printerror(\"\", a); if (exitonerror) exitprogram(1); *pkt = newpkt; bsfc = bsfc->next; pkt->streamindex = ost->index; ret = avinterleavedwriteframe(s, pkt); if (ret < 0) { printerror(\"avinterleavedwriteframe()\", ret); exitprogram(1); ", "target": 1}
{"func": "void qedcommitl2cacheentry(L2TableCache *l2cache, CachedL2Table *l2table) { CachedL2Table *entry; entry = qedfindl2cacheentry(l2cache, l2table->offset); if (entry) { qedunrefl2cacheentry(entry); qedunrefl2cacheentry(l2table); return; } if (l2cache->nentries >= MAXL2CACHESIZE) { entry = QTAILQFIRST(&l2cache->entries); QTAILQREMOVE(&l2cache->entries, entry, node); l2cache->nentries--; qedunrefl2cacheentry(entry); } l2cache->nentries++; QTAILQINSERTTAIL(&l2cache->entries, l2table, node); } ", "target": 1}
{"func": "avcold void ffpixblockdspinitx86(PixblockDSPContext *c, AVCodecContext *avctx, unsigned highbitdepth) { int cpuflags = avgetcpuflags(); if (EXTERNALMMX(cpuflags)) { if (!highbitdepth) c->getpixels = ffgetpixelsmmx; c->diffpixels = ffdiffpixelsmmx; } if (EXTERNALSSE2(cpuflags)) { if (!highbitdepth) c->getpixels = ffgetpixelssse2; c->diffpixels = ffdiffpixelssse2; } }", "target": 1}
{"func": "static USBDevice *usbnetinit(const char *cmdline) { USBDevice *dev; QemuOpts *opts; int idx; opts = qemuoptsparse(&qemunetopts, cmdline, NULL); if (!opts) { qemuoptset(opts, \"type\", \"nic\"); qemuoptset(opts, \"model\", \"usb\"); idx = netclientinit(NULL, opts, 0); if (idx == -1) { dev = usbcreate(NULL /* FIXME */, \"usb-net\"); qdevsetnicproperties(&dev->qdev, &ndtable[idx]); qdevinitnofail(&dev->qdev); return dev; ", "target": 1}
{"func": "static void pktdumpinternal(void *avcl, FILE *f, int level, const AVPacket *pkt, int dumppayload, AVRational timebase) { HEXDUMPPRINT(\"stream #%d:\\n\", pkt->streamindex); HEXDUMPPRINT(\" keyframe=%d\\n\", (pkt->flags & AVPKTFLAGKEY) != 0); HEXDUMPPRINT(\" duration=%0.3f\\n\", pkt->duration * avq2d(timebase)); /* DTS is always valid after avreadframe() */ HEXDUMPPRINT(\" dts=\"); if (pkt->dts == AVNOPTSVALUE) HEXDUMPPRINT(\"N/A\"); else HEXDUMPPRINT(\"%0.3f\", pkt->dts * avq2d(timebase)); /* PTS may not be known if B-frames are present. */ HEXDUMPPRINT(\" pts=\"); if (pkt->pts == AVNOPTSVALUE) HEXDUMPPRINT(\"N/A\"); else HEXDUMPPRINT(\"%0.3f\", pkt->pts * avq2d(timebase)); HEXDUMPPRINT(\"\\n\"); HEXDUMPPRINT(\" size=%d\\n\", pkt->size); if (dumppayload) avhexdump(f, pkt->data, pkt->size); } ", "target": 1}
{"func": "static void handlemousewheel(SDLEvent *ev) { struct sdl2console *scon = getsconfromwindow(ev->key.windowID); SDLMouseWheelEvent *wev = &ev->wheel; InputButton btn; if (wev->y > 0) { btn = INPUTBUTTONWHEELUP; } else if (wev->y < 0) { btn = INPUTBUTTONWHEELDOWN; } else { return; } qemuinputqueuebtn(scon->dcl.con, btn, true); qemuinputeventsync(); qemuinputqueuebtn(scon->dcl.con, btn, false); qemuinputeventsync(); } ", "target": 0}
{"func": "static void initvirtiodev(TestServer *s) { QPCIBus *bus; QVirtioPCIDevice *dev; uint32t features; bus = qpciinitpc(NULL); gassertnonnull(bus); dev = qvirtiopcidevicefind(bus, VIRTIOIDNET); gassertnonnull(dev); qvirtiopcideviceenable(dev); qvirtioreset(&dev->vdev); qvirtiosetacknowledge(&dev->vdev); qvirtiosetdriver(&dev->vdev); features = qvirtiogetfeatures(&dev->vdev); features = features & VIRTIONETFMAC; qvirtiosetfeatures(&dev->vdev, features); qvirtiosetdriverok(&dev->vdev); } ", "target": 1}
{"func": "int avpacketsplitsidedata(AVPacket *pkt){ if (!pkt->sidedataelems && pkt->size >12 && AVRB64(pkt->data + pkt->size - 8) == FFMERGEMARKER){ int i; unsigned int size; uint8t *p; p = pkt->data + pkt->size - 8 - 5; for (i=1; ; i++){ size = AVRB32(p); if (size>INTMAX || p - pkt->data < size) return 0; if (p[4]&128) break; p-= size+5; } pkt->sidedata = avmallocarray(i, sizeof(*pkt->sidedata)); if (!pkt->sidedata) return AVERROR(ENOMEM); p= pkt->data + pkt->size - 8 - 5; for (i=0; ; i++){ size= AVRB32(p); avassert0(size<=INTMAX && p - pkt->data >= size); pkt->sidedata[i].data = avmallocz(size + AVINPUTBUFFERPADDINGSIZE); pkt->sidedata[i].size = size; pkt->sidedata[i].type = p[4]&127; if (!pkt->sidedata[i].data) return AVERROR(ENOMEM); memcpy(pkt->sidedata[i].data, p-size, size); pkt->size -= size + 5; if(p[4]&128) break; p-= size+5; } pkt->size -= 8; pkt->sidedataelems = i+1; return 1; } return 0; } ", "target": 1}
{"func": "static void usbmsdcancelio(USBDevice *dev, USBPacket *p) { MSDState *s = DOUPCAST(MSDState, dev, dev); scsireqcancel(s->req); } ", "target": 1}
{"func": "ramaddrt ppc405setbootinfo (CPUState *env, ppc4xxbdinfot *bd, uint32t flags) { ramaddrt bdloc; int i, n; /* We put the bd structure at the top of memory */ if (bd->bimemsize >= 0x01000000UL) bdloc = 0x01000000UL - sizeof(struct ppc4xxbdinfot); else bdloc = bd->bimemsize - sizeof(struct ppc4xxbdinfot); stlphys(bdloc + 0x00, bd->bimemstart); stlphys(bdloc + 0x04, bd->bimemsize); stlphys(bdloc + 0x08, bd->biflashstart); stlphys(bdloc + 0x0C, bd->biflashsize); stlphys(bdloc + 0x10, bd->biflashoffset); stlphys(bdloc + 0x14, bd->bisramstart); stlphys(bdloc + 0x18, bd->bisramsize); stlphys(bdloc + 0x1C, bd->bibootflags); stlphys(bdloc + 0x20, bd->biipaddr); for (i = 0; i < 6; i++) stbphys(bdloc + 0x24 + i, bd->bienetaddr[i]); stwphys(bdloc + 0x2A, bd->biethspeed); stlphys(bdloc + 0x2C, bd->biintfreq); stlphys(bdloc + 0x30, bd->bibusfreq); stlphys(bdloc + 0x34, bd->bibaudrate); for (i = 0; i < 4; i++) stbphys(bdloc + 0x38 + i, bd->bisversion[i]); for (i = 0; i < 32; i++) stbphys(bdloc + 0x3C + i, bd->bisversion[i]); stlphys(bdloc + 0x5C, bd->biplbbusfreq); stlphys(bdloc + 0x60, bd->bipcibusfreq); for (i = 0; i < 6; i++) stbphys(bdloc + 0x64 + i, bd->bipcienetaddr[i]); n = 0x6A; if (flags & 0x00000001) { for (i = 0; i < 6; i++) stbphys(bdloc + n++, bd->bipcienetaddr2[i]); } stlphys(bdloc + n, bd->biopbfreq); n += 4; for (i = 0; i < 2; i++) { stlphys(bdloc + n, bd->biiicfast[i]); n += 4; } return bdloc; } ", "target": 1}
{"func": "bool virtioipldiskisvalid(void) { return blkcfg.blksize && (virtiodiskisscsi() || virtiodiskiseckd()); } ", "target": 0}
{"func": "static void bdrvpasswordcb(Monitor *mon, const char *password, void *opaque) { BlockDriverState *bs = opaque; int ret = 0; if (bdrvsetkey(bs, password) != 0) { monitorprintf(mon, \"invalid password\\n\"); ret = -EPERM; } if (mon->passwordcompletioncb) mon->passwordcompletioncb(mon->passwordopaque, ret); monitorreadcommand(mon, 1); } ", "target": 0}
{"func": "dshowcycledevices(AVFormatContext *avctx, ICreateDevEnum *devenum, enum dshowDeviceType devtype, IBaseFilter **pfilter) { struct dshowctx *ctx = avctx->privdata; IBaseFilter *devicefilter = NULL; IEnumMoniker *classenum = NULL; IMoniker *m = NULL; const char *devicename = ctx->devicename[devtype]; int skip = (devtype == VideoDevice) ? ctx->videodevicenumber : ctx->audiodevicenumber; int r; const GUID *deviceguid[2] = { &CLSIDVideoInputDeviceCategory, &CLSIDAudioInputDeviceCategory }; const char *devtypename = (devtype == VideoDevice) ? \"video\" : \"audio\"; r = ICreateDevEnumCreateClassEnumerator(devenum, deviceguid[devtype], (IEnumMoniker **) &classenum, 0); if (r != SOK) { avlog(avctx, AVLOGERROR, \"Could not enumerate %s devices.\\n\", devtypename); return AVERROR(EIO); } while (!devicefilter && IEnumMonikerNext(classenum, 1, &m, NULL) == SOK) { IPropertyBag *bag = NULL; char *buf = NULL; VARIANT var; r = IMonikerBindToStorage(m, 0, 0, &IIDIPropertyBag, (void *) &bag); if (r != SOK) goto fail1; var.vt = VTBSTR; r = IPropertyBagRead(bag, L\"FriendlyName\", &var, NULL); if (r != SOK) goto fail1; buf = dupwchartoutf8(var.bstrVal); if (pfilter) { if (strcmp(devicename, buf)) goto fail1; if (!skip--) IMonikerBindToObject(m, 0, 0, &IIDIBaseFilter, (void *) &devicefilter); } else { avlog(avctx, AVLOGINFO, \" \\\"%s\\\"\\n\", buf); } fail1: if (buf) avfree(buf); if (bag) IPropertyBagRelease(bag); IMonikerRelease(m); } IEnumMonikerRelease(classenum); if (pfilter) { if (!devicefilter) { avlog(avctx, AVLOGERROR, \"Could not find %s device.\\n\", devtypename); return AVERROR(EIO); } *pfilter = devicefilter; } return 0; } ", "target": 0}
{"func": "static int dodecode(AVCodecContext *avctx, AVPacket *pkt) { int gotframe; int ret; avassert0(!avctx->internal->bufferframe->buf[0]); if (!pkt) pkt = avctx->internal->bufferpkt; // This is the lesser evil. The field is for compatibility with legacy users // of the legacy API, and users using the new API should not be forced to // even know about this field. avctx->refcountedframes = 1; // Some codecs (at least wma lossless) will crash when feeding drain packets // after EOF was signaled. if (avctx->internal->drainingdone) return AVERROREOF; if (avctx->codectype == AVMEDIATYPEVIDEO) { ret = avcodecdecodevideo2(avctx, avctx->internal->bufferframe, &gotframe, pkt); if (ret >= 0 && !(avctx->flags & AVCODECFLAGTRUNCATED)) ret = pkt->size; } else if (avctx->codectype == AVMEDIATYPEAUDIO) { ret = avcodecdecodeaudio4(avctx, avctx->internal->bufferframe, &gotframe, pkt); } else { ret = AVERROR(EINVAL); } if (ret == AVERROR(EAGAIN)) ret = pkt->size; if (ret < 0) return ret; if (avctx->internal->draining && !gotframe) avctx->internal->drainingdone = 1; if (ret >= pkt->size) { avpacketunref(avctx->internal->bufferpkt); } else { int consumed = ret; if (pkt != avctx->internal->bufferpkt) { avpacketunref(avctx->internal->bufferpkt); if ((ret = avpacketref(avctx->internal->bufferpkt, pkt)) < 0) return ret; } avctx->internal->bufferpkt->data += consumed; avctx->internal->bufferpkt->size -= consumed; avctx->internal->bufferpkt->pts = AVNOPTSVALUE; avctx->internal->bufferpkt->dts = AVNOPTSVALUE; } if (gotframe) avassert0(avctx->internal->bufferframe->buf[0]); return 0; } ", "target": 0}
{"func": "void nethostdeviceremove(Monitor *mon, int vlanid, const char *device) { VLANState *vlan; VLANClientState *vc; vlan = qemufindvlan(vlanid); for(vc = vlan->firstclient; vc != NULL; vc = vc->next) if (!strcmp(vc->name, device)) break; if (!vc) { monitorprintf(mon, \"can't find device %s\\n\", device); return; } qemudelvlanclient(vc); } ", "target": 0}
{"func": "static void vfiobarwrite(void *opaque, hwaddr addr, uint64t data, unsigned size) { VFIOBAR *bar = opaque; union { uint8t byte; uint16t word; uint32t dword; uint64t qword; } buf; switch (size) { case 1: buf.byte = data; break; case 2: buf.word = cputole16(data); break; case 4: buf.dword = cputole32(data); break; default: hwerror(\"vfio: unsupported write size, %d bytes\\n\", size); break; } if (pwrite(bar->fd, &buf, size, bar->fdoffset + addr) != size) { errorreport(\"%s(,0x%\"HWADDRPRIx\", 0x%\"PRIx64\", %d) failed: %m\", func, addr, data, size); } DPRINTF(\"%s(BAR%d+0x%\"HWADDRPRIx\", 0x%\"PRIx64\", %d)\\n\", func, bar->nr, addr, data, size); /* * A read or write to a BAR always signals an INTx EOI. This will * do nothing if not pending (including not in INTx mode). We assume * that a BAR access is in response to an interrupt and that BAR * accesses will service the interrupt. Unfortunately, we don't know * which access will service the interrupt, so we're potentially * getting quite a few host interrupts per guest interrupt. */ vfioeoi(containerof(bar, VFIODevice, bars[bar->nr])); } ", "target": 0}
{"func": "static void mcf5208evbinit(QEMUMachineInitArgs *args) { ramaddrt ramsize = args->ramsize; const char *cpumodel = args->cpumodel; const char *kernelfilename = args->kernelfilename; CPUM68KState *env; int kernelsize; uint64t elfentry; targetphysaddrt entry; qemuirq *pic; MemoryRegion *addressspacemem = getsystemmemory(); MemoryRegion *ram = gnew(MemoryRegion, 1); MemoryRegion *sram = gnew(MemoryRegion, 1); if (!cpumodel) cpumodel = \"m5208\"; env = cpuinit(cpumodel); if (!env) { fprintf(stderr, \"Unable to find m68k CPU definition\\n\"); exit(1); } /* Initialize CPU registers. */ env->vbr = 0; /* TODO: Configure BARs. */ /* DRAM at 0x40000000 */ memoryregioninitram(ram, \"mcf5208.ram\", ramsize); vmstateregisterramglobal(ram); memoryregionaddsubregion(addressspacemem, 0x40000000, ram); /* Internal SRAM. */ memoryregioninitram(sram, \"mcf5208.sram\", 16384); vmstateregisterramglobal(sram); memoryregionaddsubregion(addressspacemem, 0x80000000, sram); /* Internal peripherals. */ pic = mcfintcinit(addressspacemem, 0xfc048000, env); mcfuartmminit(addressspacemem, 0xfc060000, pic[26], serialhds[0]); mcfuartmminit(addressspacemem, 0xfc064000, pic[27], serialhds[1]); mcfuartmminit(addressspacemem, 0xfc068000, pic[28], serialhds[2]); mcf5208sysinit(addressspacemem, pic); if (nbnics > 1) { fprintf(stderr, \"Too many NICs\\n\"); exit(1); } if (ndtable[0].used) mcffecinit(addressspacemem, &ndtable[0], 0xfc030000, pic + 36); /* 0xfc000000 SCM. */ /* 0xfc004000 XBS. */ /* 0xfc008000 FlexBus CS. */ /* 0xfc030000 FEC. */ /* 0xfc040000 SCM + Power management. */ /* 0xfc044000 eDMA. */ /* 0xfc048000 INTC. */ /* 0xfc058000 I2C. */ /* 0xfc05c000 QSPI. */ /* 0xfc060000 UART0. */ /* 0xfc064000 UART0. */ /* 0xfc068000 UART0. */ /* 0xfc070000 DMA timers. */ /* 0xfc080000 PIT0. */ /* 0xfc084000 PIT1. */ /* 0xfc088000 EPORT. */ /* 0xfc08c000 Watchdog. */ /* 0xfc090000 clock module. */ /* 0xfc0a0000 CCM + reset. */ /* 0xfc0a4000 GPIO. */ /* 0xfc0a8000 SDRAM controller. */ /* Load kernel. */ if (!kernelfilename) { fprintf(stderr, \"Kernel image must be specified\\n\"); exit(1); } kernelsize = loadelf(kernelfilename, NULL, NULL, &elfentry, NULL, NULL, 1, ELFMACHINE, 0); entry = elfentry; if (kernelsize < 0) { kernelsize = loaduimage(kernelfilename, &entry, NULL, NULL); } if (kernelsize < 0) { kernelsize = loadimagetargphys(kernelfilename, 0x40000000, ramsize); entry = 0x40000000; } if (kernelsize < 0) { fprintf(stderr, \"qemu: could not load kernel '%s'\\n\", kernelfilename); exit(1); } env->pc = entry; } ", "target": 0}
{"func": "static QObject *parseescape(JSONParserContext *ctxt, valist *ap) { QObject *token; const char *val; if (ap == NULL) { return NULL; } token = parsercontextpoptoken(ctxt); assert(token && tokengettype(token) == JSONESCAPE); val = tokengetvalue(token); if (!strcmp(val, \"%p\")) { return vaarg(*ap, QObject *); } else if (!strcmp(val, \"%i\")) { return QOBJECT(qboolfrombool(vaarg(*ap, int))); } else if (!strcmp(val, \"%d\")) { return QOBJECT(qintfromint(vaarg(*ap, int))); } else if (!strcmp(val, \"%ld\")) { return QOBJECT(qintfromint(vaarg(*ap, long))); } else if (!strcmp(val, \"%lld\") || !strcmp(val, \"%I64d\")) { return QOBJECT(qintfromint(vaarg(*ap, long long))); } else if (!strcmp(val, \"%s\")) { return QOBJECT(qstringfromstr(vaarg(*ap, const char *))); } else if (!strcmp(val, \"%f\")) { return QOBJECT(qfloatfromdouble(vaarg(*ap, double))); } return NULL; } ", "target": 0}
{"func": "static inline uint64t ldqphysinternal(hwaddr addr, enum deviceendian endian) { uint8t *ptr; uint64t val; MemoryRegionSection *section; section = physpagefind(addressspacememory.dispatch, addr >> TARGETPAGEBITS); if (!(memoryregionisram(section->mr) || memoryregionisromd(section->mr))) { /* I/O case */ addr = memoryregionsectionaddr(section, addr); /* XXX This is broken when device endian != cpu endian. Fix and add \"endian\" variable check */ #ifdef TARGETWORDSBIGENDIAN val = iomemread(section->mr, addr, 4) << 32; val |= iomemread(section->mr, addr + 4, 4); #else val = iomemread(section->mr, addr, 4); val |= iomemread(section->mr, addr + 4, 4) << 32; #endif } else { /* RAM case */ ptr = qemugetramptr((memoryregiongetramaddr(section->mr) & TARGETPAGEMASK) + memoryregionsectionaddr(section, addr)); switch (endian) { case DEVICELITTLEENDIAN: val = ldqlep(ptr); break; case DEVICEBIGENDIAN: val = ldqbep(ptr); break; default: val = ldqp(ptr); break; } } return val; } ", "target": 0}
{"func": "void mainloopwait(int nonblocking) { fdset rfds, wfds, xfds; int ret, nfds; struct timeval tv; int timeout; if (nonblocking) timeout = 0; else { timeout = qemucalculatetimeout(); qemubhupdatetimeout(&timeout); } oshostmainloopwait(&timeout); tv.tvsec = timeout / 1000; tv.tvusec = (timeout % 1000) * 1000; /* poll any events */ /* XXX: separate device handlers from system ones */ nfds = -1; FDZERO(&rfds); FDZERO(&wfds); FDZERO(&xfds); qemuiohandlerfill(&nfds, &rfds, &wfds, &xfds); slirpselectfill(&nfds, &rfds, &wfds, &xfds); qemumutexunlockiothread(); ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv); qemumutexlockiothread(); qemuiohandlerpoll(&rfds, &wfds, &xfds, ret); slirpselectpoll(&rfds, &wfds, &xfds, (ret < 0)); qemurunalltimers(); /* Check bottom-halves last in case any of the earlier events triggered them. */ qemubhpoll(); } ", "target": 0}
{"func": "void bdrvinvalidatecacheall(Error **errp) { BlockDriverState *bs; Error *localerr = NULL; BdrvNextIterator *it = NULL; while ((it = bdrvnext(it, &bs)) != NULL) { AioContext *aiocontext = bdrvgetaiocontext(bs); aiocontextacquire(aiocontext); bdrvinvalidatecache(bs, &localerr); aiocontextrelease(aiocontext); if (localerr) { errorpropagate(errp, localerr); return; } } } ", "target": 1}
{"func": "static int parseadaptationsets(AVFormatContext *s) { WebMDashMuxContext *w = s->privdata; char *p = w->adaptationsets; char *q; enum { newset, parsedid, parsingstreams } state; if (!w->adaptationsets) { avlog(s, AVLOGERROR, \"The 'adaptationsets' option must be set.\\n\"); return AVERROR(EINVAL); } // syntax id=0,streams=0,1,2 id=1,streams=3,4 and so on state = newset; while (p < w->adaptationsets + strlen(w->adaptationsets)) { if (*p == ' ') continue; else if (state == newset && !strncmp(p, \"id=\", 3)) { void *mem = avrealloc(w->as, sizeof(*w->as) * (w->nbas + 1)); if (mem == NULL) return AVERROR(ENOMEM); w->as = mem; ++w->nbas; w->as[w->nbas - 1].nbstreams = 0; w->as[w->nbas - 1].streams = NULL; p += 3; // consume \"id=\" q = w->as[w->nbas - 1].id; while (*p != ',') *q++ = *p++; *q = 0; p++; state = parsedid; } else if (state == parsedid && !strncmp(p, \"streams=\", 8)) { p += 8; // consume \"streams=\" state = parsingstreams; } else if (state == parsingstreams) { struct AdaptationSet *as = &w->as[w->nbas - 1]; q = p; while (*q != '\\0' && *q != ',' && *q != ' ') q++; as->streams = avrealloc(as->streams, sizeof(*as->streams) * ++as->nbstreams); if (as->streams == NULL) return AVERROR(ENOMEM); as->streams[as->nbstreams - 1] = tointeger(p, q - p + 1); if (as->streams[as->nbstreams - 1] < 0) return -1; if (*q == '\\0') break; if (*q == ' ') state = newset; p = ++q; } else { return -1; } } return 0; } ", "target": 1}
{"func": "static QObject *parsekeyword(JSONParserContext *ctxt) { QObject *token, *ret; JSONParserContext savedctxt = parsercontextsave(ctxt); token = parsercontextpoptoken(ctxt); if (token == NULL) { goto out; } if (tokengettype(token) != JSONKEYWORD) { goto out; } if (tokeniskeyword(token, \"true\")) { ret = QOBJECT(qboolfromint(true)); } else if (tokeniskeyword(token, \"false\")) { ret = QOBJECT(qboolfromint(false)); } else { parseerror(ctxt, token, \"invalid keyword `%s'\", tokengetvalue(token)); goto out; } return ret; out: parsercontextrestore(ctxt, savedctxt); return NULL; }", "target": 1}
{"func": "static int aacencodeframe(AVCodecContext *avctx, uint8t *frame, int bufsize, void *data) { AACEncContext *s = avctx->privdata; int16t *samples = s->samples, *samples2, *la; ChannelElement *cpe; int i, j, chans, tag, startch; const uint8t *chanmap = aacchanconfigs[avctx->channels-1]; int chanelcounter[4]; FFPsyWindowInfo windows[AACMAXCHANNELS]; if (s->lastframe) return 0; if (data) { if (!s->psypp) { memcpy(s->samples + 1024 * avctx->channels, data, 1024 * avctx->channels * sizeof(s->samples[0])); } else { startch = 0; samples2 = s->samples + 1024 * avctx->channels; for (i = 0; i < chanmap[0]; i++) { tag = chanmap[i+1]; chans = tag == TYPECPE ? 2 : 1; ffpsypreprocess(s->psypp, (uint16t*)data + startch, samples2 + startch, startch, chans); startch += chans; } } } if (!avctx->framenumber) { memcpy(s->samples, s->samples + 1024 * avctx->channels, 1024 * avctx->channels * sizeof(s->samples[0])); return 0; } startch = 0; for (i = 0; i < chanmap[0]; i++) { FFPsyWindowInfo* wi = windows + startch; tag = chanmap[i+1]; chans = tag == TYPECPE ? 2 : 1; cpe = &s->cpe[i]; for (j = 0; j < chans; j++) { IndividualChannelStream *ics = &cpe->ch[j].ics; int k; int curchannel = startch + j; samples2 = samples + curchannel; la = samples2 + (448+64) * avctx->channels; if (!data) la = NULL; if (tag == TYPELFE) { wi[j].windowtype[0] = ONLYLONGSEQUENCE; wi[j].windowshape = 0; wi[j].numwindows = 1; wi[j].grouping[0] = 1; } else { wi[j] = ffpsysuggestwindow(&s->psy, samples2, la, curchannel, ics->windowsequence[0]); } ics->windowsequence[1] = ics->windowsequence[0]; ics->windowsequence[0] = wi[j].windowtype[0]; ics->usekbwindow[1] = ics->usekbwindow[0]; ics->usekbwindow[0] = wi[j].windowshape; ics->numwindows = wi[j].numwindows; ics->swbsizes = s->psy.bands [ics->numwindows == 8]; ics->numswb = tag == TYPELFE ? 12 : s->psy.numbands[ics->numwindows == 8]; for (k = 0; k < ics->numwindows; k++) ics->grouplen[k] = wi[j].grouping[k]; applywindowandmdct(avctx, s, &cpe->ch[j], samples2); } startch += chans; } do { int framebits; initputbits(&s->pb, frame, bufsize*8); if ((avctx->framenumber & 0xFF)==1 && !(avctx->flags & CODECFLAGBITEXACT)) putbitstreaminfo(avctx, s, LIBAVCODECIDENT); startch = 0; memset(chanelcounter, 0, sizeof(chanelcounter)); for (i = 0; i < chanmap[0]; i++) { FFPsyWindowInfo* wi = windows + startch; tag = chanmap[i+1]; chans = tag == TYPECPE ? 2 : 1; cpe = &s->cpe[i]; putbits(&s->pb, 3, tag); putbits(&s->pb, 4, chanelcounter[tag]++); for (j = 0; j < chans; j++) { s->curchannel = startch + j; ffpsysetbandinfo(&s->psy, s->curchannel, cpe->ch[j].coeffs, &wi[j]); s->coder->searchforquantizers(avctx, s, &cpe->ch[j], s->lambda); } cpe->commonwindow = 0; if (chans > 1 && wi[0].windowtype[0] == wi[1].windowtype[0] && wi[0].windowshape == wi[1].windowshape) { cpe->commonwindow = 1; for (j = 0; j < wi[0].numwindows; j++) { if (wi[0].grouping[j] != wi[1].grouping[j]) { cpe->commonwindow = 0; break; } } } s->curchannel = startch; if (cpe->commonwindow && s->coder->searchforms) s->coder->searchforms(s, cpe, s->lambda); adjustframeinformation(s, cpe, chans); if (chans == 2) { putbits(&s->pb, 1, cpe->commonwindow); if (cpe->commonwindow) { puticsinfo(s, &cpe->ch[0].ics); encodemsinfo(&s->pb, cpe); } } for (j = 0; j < chans; j++) { s->curchannel = startch + j; encodeindividualchannel(avctx, s, &cpe->ch[j], cpe->commonwindow); } startch += chans; } framebits = putbitscount(&s->pb); if (framebits <= 6144 * avctx->channels - 3) { s->psy.bitres.bits = framebits / avctx->channels; break; } s->lambda *= avctx->bitrate * 1024.0f / avctx->samplerate / framebits; } while (1); putbits(&s->pb, 3, TYPEEND); flushputbits(&s->pb); avctx->framebits = putbitscount(&s->pb); // rate control stuff if (!(avctx->flags & CODECFLAGQSCALE)) { float ratio = avctx->bitrate * 1024.0f / avctx->samplerate / avctx->framebits; s->lambda *= ratio; s->lambda = FFMIN(s->lambda, 65536.f); } if (!data) s->lastframe = 1; memcpy(s->samples, s->samples + 1024 * avctx->channels, 1024 * avctx->channels * sizeof(s->samples[0])); return putbitscount(&s->pb)>>3; } ", "target": 0}
{"func": "static int dxtorydecodev2420(AVCodecContext *avctx, AVFrame *pic, const uint8t *src, int srcsize) { GetByteContext gb; GetBitContext gb2; int nslices, slice, sliceheight, refsliceheight; int cury, nexty; uint32t off, slicesize; uint8t *Y, *U, *V; int ret; bytestream2init(&gb, src, srcsize); nslices = bytestream2getle16(&gb); off = FFALIGN(nslices * 4 + 2, 16); if (srcsize < off) { avlog(avctx, AVLOGERROR, \"no slice data\\n\"); return AVERRORINVALIDDATA; } if (!nslices || avctx->height % nslices) { avprivrequestsample(avctx, \"%d slices for %dx%d\", nslices, avctx->width, avctx->height); return AVERRORPATCHWELCOME; } refsliceheight = avctx->height / nslices; if ((avctx->width & 1) || (avctx->height & 1)) { avprivrequestsample(avctx, \"Frame dimensions %dx%d\", avctx->width, avctx->height); } avctx->pixfmt = AVPIXFMTYUV420P; if ((ret = ffgetbuffer(avctx, pic, 0)) < 0) return ret; Y = pic->data[0]; U = pic->data[1]; V = pic->data[2]; cury = 0; nexty = refsliceheight; for (slice = 0; slice < nslices; slice++) { slicesize = bytestream2getle32(&gb); sliceheight = (nexty & ~1) - (cury & ~1); if (slicesize > srcsize - off) { avlog(avctx, AVLOGERROR, \"invalid slice size %\"PRIu32\" (only %\"PRIu32\" bytes left)\\n\", slicesize, srcsize - off); return AVERRORINVALIDDATA; } if (slicesize <= 16) { avlog(avctx, AVLOGERROR, \"invalid slice size %\"PRIu32\"\\n\", slicesize); return AVERRORINVALIDDATA; } if (AVRL32(src + off) != slicesize - 16) { avlog(avctx, AVLOGERROR, \"Slice sizes mismatch: got %\"PRIu32\" instead of %\"PRIu32\"\\n\", AVRL32(src + off), slicesize - 16); } initgetbits(&gb2, src + off + 16, (slicesize - 16) * 8); dx2decodeslice420(&gb2, avctx->width, sliceheight, Y, U, V, pic->linesize[0], pic->linesize[1], pic->linesize[2]); Y += pic->linesize[0] * sliceheight; U += pic->linesize[1] * (sliceheight >> 1); V += pic->linesize[2] * (sliceheight >> 1); off += slicesize; cury = nexty; nexty += refsliceheight; } return 0; } ", "target": 0}
{"func": "static int readsbrgrid(AACContext *ac, SpectralBandReplication *sbr, GetBitContext *gb, SBRData *chdata) { int i; unsigned bspointer = 0; // frameLengthFlag ? 15 : 16; 960 sample length frames unsupported; this value is numTimeSlots int absbordtrail = 16; int numrellead, numreltrail; unsigned bsnumenvold = chdata->bsnumenv; chdata->bsfreqres[0] = chdata->bsfreqres[chdata->bsnumenv]; chdata->bsampres = sbr->bsampresheader; chdata->tenvnumenvold = chdata->tenv[bsnumenvold]; switch (chdata->bsframeclass = getbits(gb, 2)) { case FIXFIX: chdata->bsnumenv = 1 << getbits(gb, 2); numrellead = chdata->bsnumenv - 1; if (chdata->bsnumenv == 1) chdata->bsampres = 0; if (chdata->bsnumenv > 4) { avlog(ac->avccontext, AVLOGERROR, \"Invalid bitstream, too many SBR envelopes in FIXFIX type SBR frame: %d\\n\", chdata->bsnumenv); return -1; } chdata->tenv[0] = 0; chdata->tenv[chdata->bsnumenv] = absbordtrail; absbordtrail = (absbordtrail + (chdata->bsnumenv >> 1)) / chdata->bsnumenv; for (i = 0; i < numrellead; i++) chdata->tenv[i + 1] = chdata->tenv[i] + absbordtrail; chdata->bsfreqres[1] = getbits1(gb); for (i = 1; i < chdata->bsnumenv; i++) chdata->bsfreqres[i + 1] = chdata->bsfreqres[1]; break; case FIXVAR: absbordtrail += getbits(gb, 2); numreltrail = getbits(gb, 2); chdata->bsnumenv = numreltrail + 1; chdata->tenv[0] = 0; chdata->tenv[chdata->bsnumenv] = absbordtrail; for (i = 0; i < numreltrail; i++) chdata->tenv[chdata->bsnumenv - 1 - i] = chdata->tenv[chdata->bsnumenv - i] - 2 * getbits(gb, 2) - 2; bspointer = getbits(gb, ceillog2[chdata->bsnumenv]); for (i = 0; i < chdata->bsnumenv; i++) chdata->bsfreqres[chdata->bsnumenv - i] = getbits1(gb); break; case VARFIX: chdata->tenv[0] = getbits(gb, 2); numrellead = getbits(gb, 2); chdata->bsnumenv = numrellead + 1; chdata->tenv[chdata->bsnumenv] = absbordtrail; for (i = 0; i < numrellead; i++) chdata->tenv[i + 1] = chdata->tenv[i] + 2 * getbits(gb, 2) + 2; bspointer = getbits(gb, ceillog2[chdata->bsnumenv]); getbits1vector(gb, chdata->bsfreqres + 1, chdata->bsnumenv); break; case VARVAR: chdata->tenv[0] = getbits(gb, 2); absbordtrail += getbits(gb, 2); numrellead = getbits(gb, 2); numreltrail = getbits(gb, 2); chdata->bsnumenv = numrellead + numreltrail + 1; chdata->tenv[chdata->bsnumenv] = absbordtrail; if (chdata->bsnumenv > 5) { avlog(ac->avccontext, AVLOGERROR, \"Invalid bitstream, too many SBR envelopes in VARVAR type SBR frame: %d\\n\", chdata->bsnumenv); return -1; } for (i = 0; i < numrellead; i++) chdata->tenv[i + 1] = chdata->tenv[i] + 2 * getbits(gb, 2) + 2; for (i = 0; i < numreltrail; i++) chdata->tenv[chdata->bsnumenv - 1 - i] = chdata->tenv[chdata->bsnumenv - i] - 2 * getbits(gb, 2) - 2; bspointer = getbits(gb, ceillog2[chdata->bsnumenv]); getbits1vector(gb, chdata->bsfreqres + 1, chdata->bsnumenv); break; } if (bspointer > chdata->bsnumenv + 1) { avlog(ac->avccontext, AVLOGERROR, \"Invalid bitstream, bspointer points to a middle noise border outside the time borders table: %d\\n\", bspointer); return -1; } chdata->bsnumnoise = (chdata->bsnumenv > 1) + 1; chdata->tq[0] = chdata->tenv[0]; chdata->tq[chdata->bsnumnoise] = chdata->tenv[chdata->bsnumenv]; if (chdata->bsnumnoise > 1) { unsigned int idx; if (chdata->bsframeclass == FIXFIX) { idx = chdata->bsnumenv >> 1; } else if (chdata->bsframeclass & 1) { // FIXVAR or VARVAR idx = chdata->bsnumenv - FFMAX(bspointer - 1, 1); } else { // VARFIX if (!bspointer) idx = 1; else if (bspointer == 1) idx = chdata->bsnumenv - 1; else // bspointer > 1 idx = bspointer - 1; } chdata->tq[1] = chdata->tenv[idx]; } chdata->ea[0] = -(chdata->ea[1] != bsnumenvold); // lAPrev chdata->ea[1] = -1; if ((chdata->bsframeclass & 1) && bspointer) { // FIXVAR or VARVAR and bspointer != 0 chdata->ea[1] = chdata->bsnumenv + 1 - bspointer; } else if ((chdata->bsframeclass == 2) && (bspointer > 1)) // VARFIX and bspointer > 1 chdata->ea[1] = bspointer - 1; return 0; } ", "target": 0}
{"func": "static int uhcicompletetd(UHCIState *s, UHCITD *td, UHCIAsync *async, uint32t *intmask) { int len = 0, maxlen, err, ret; uint8t pid; maxlen = ((td->token >> 21) + 1) & 0x7ff; pid = td->token & 0xff; ret = async->packet.result; if (td->ctrl & TDCTRLIOS) td->ctrl &= ~TDCTRLACTIVE; if (ret < 0) goto out; len = async->packet.result; td->ctrl = (td->ctrl & ~0x7ff) | ((len - 1) & 0x7ff); /* The NAK bit may have been set by a previous frame, so clear it here. The docs are somewhat unclear, but win2k relies on this behavior. */ td->ctrl &= ~(TDCTRLACTIVE | TDCTRLNAK); if (td->ctrl & TDCTRLIOC) *intmask |= 0x01; if (pid == USBTOKENIN) { if (len > maxlen) { ret = USBRETBABBLE; goto out; } if ((td->ctrl & TDCTRLSPD) && len < maxlen) { *intmask |= 0x02; /* short packet: do not update QH */ traceusbuhcipacketcompleteshortxfer(async->queue->token, async->td); return TDRESULTNEXTQH; } } /* success */ traceusbuhcipacketcompletesuccess(async->queue->token, async->td); return TDRESULTCOMPLETE; out: /* * We should not do any further processing on a queue with errors! * This is esp. important for bulk endpoints with pipelining enabled * (redirection to a real USB device), where we must cancel all the * transfers after this one so that: * 1) If they've completed already, they are not processed further * causing more stalls, originating from the same failed transfer * 2) If still in flight, they are cancelled before the guest does * a clear stall, otherwise the guest and device can loose sync! */ while (!QTAILQEMPTY(&async->queue->asyncs)) { UHCIAsync *as = QTAILQFIRST(&async->queue->asyncs); uhciasyncunlink(as); uhciasynccancel(as); } switch(ret) { case USBRETSTALL: td->ctrl |= TDCTRLSTALL; td->ctrl &= ~TDCTRLACTIVE; s->status |= UHCISTSUSBERR; if (td->ctrl & TDCTRLIOC) { *intmask |= 0x01; } uhciupdateirq(s); traceusbuhcipacketcompletestall(async->queue->token, async->td); return TDRESULTNEXTQH; case USBRETBABBLE: td->ctrl |= TDCTRLBABBLE | TDCTRLSTALL; td->ctrl &= ~TDCTRLACTIVE; s->status |= UHCISTSUSBERR; if (td->ctrl & TDCTRLIOC) { *intmask |= 0x01; } uhciupdateirq(s); /* frame interrupted */ traceusbuhcipacketcompletebabble(async->queue->token, async->td); return TDRESULTSTOPFRAME; case USBRETNAK: td->ctrl |= TDCTRLNAK; if (pid == USBTOKENSETUP) break; return TDRESULTNEXTQH; case USBRETIOERROR: case USBRETNODEV: default: \tbreak; } /* Retry the TD if error count is not zero */ td->ctrl |= TDCTRLTIMEOUT; err = (td->ctrl >> TDCTRLERRORSHIFT) & 3; if (err != 0) { err--; if (err == 0) { td->ctrl &= ~TDCTRLACTIVE; s->status |= UHCISTSUSBERR; if (td->ctrl & TDCTRLIOC) *intmask |= 0x01; uhciupdateirq(s); traceusbuhcipacketcompleteerror(async->queue->token, async->td); } } td->ctrl = (td->ctrl & ~(3 << TDCTRLERRORSHIFT)) | (err << TDCTRLERRORSHIFT); return TDRESULTNEXTQH; } ", "target": 0}
{"func": "static void cpux86dumpstate(FILE *f) { int eflags; char ccopname[32]; eflags = cctable[CCOP].computeall(); eflags |= (DF & DFMASK); if ((unsigned)env->ccop < CCOPNB) strcpy(ccopname, ccopstr[env->ccop]); else snprintf(ccopname, sizeof(ccopname), \"[%d]\", env->ccop); fprintf(f, \"EAX=%08x EBX=%08X ECX=%08x EDX=%08x\\n\" \"ESI=%08x EDI=%08X EBP=%08x ESP=%08x\\n\" \"CCS=%08x CCD=%08x CCO=%-8s EFL=%c%c%c%c%c%c%c\\n\" \"EIP=%08x\\n\", env->regs[REAX], env->regs[REBX], env->regs[RECX], env->regs[REDX], env->regs[RESI], env->regs[REDI], env->regs[REBP], env->regs[RESP], env->ccsrc, env->ccdst, ccopname, eflags & DFMASK ? 'D' : '-', eflags & CCO ? 'O' : '-', eflags & CCS ? 'S' : '-', eflags & CCZ ? 'Z' : '-', eflags & CCA ? 'A' : '-', eflags & CCP ? 'P' : '-', eflags & CCC ? 'C' : '-', env->eip); #if 1 fprintf(f, \"ST0=%f ST1=%f ST2=%f ST3=%f\\n\", (double)ST0, (double)ST1, (double)ST(2), (double)ST(3)); #endif } ", "target": 0}
{"func": "static int gifreadimage(GifState *s) { int left, top, width, height, bitsperpixel, codesize, flags; int isinterleaved, haslocalpalette, y, pass, y1, linesize, n, i; uint8t *ptr, *spal, *palette, *ptr1; left = bytestreamgetle16(&s->bytestream); top = bytestreamgetle16(&s->bytestream); width = bytestreamgetle16(&s->bytestream); height = bytestreamgetle16(&s->bytestream); flags = bytestreamgetbyte(&s->bytestream); isinterleaved = flags & 0x40; haslocalpalette = flags & 0x80; bitsperpixel = (flags & 0x07) + 1; avdlog(s->avctx, \"image x=%d y=%d w=%d h=%d\\n\", left, top, width, height); if (haslocalpalette) { bytestreamgetbuffer(&s->bytestream, s->localpalette, 3 * (1 << bitsperpixel)); palette = s->localpalette; } else { palette = s->globalpalette; bitsperpixel = s->bitsperpixel; } /* verify that all the image is inside the screen dimensions */ if (left + width > s->screenwidth || top + height > s->screenheight) return AVERROR(EINVAL); /* build the palette */ n = (1 << bitsperpixel); spal = palette; for(i = 0; i < n; i++) { s->imagepalette[i] = (0xffu << 24) | AVRB24(spal); spal += 3; } for(; i < 256; i++) s->imagepalette[i] = (0xffu << 24); /* handle transparency */ if (s->transparentcolorindex >= 0) s->imagepalette[s->transparentcolorindex] = 0; /* now get the image data */ codesize = bytestreamgetbyte(&s->bytestream); fflzwdecodeinit(s->lzw, codesize, s->bytestream, s->bytestreamend - s->bytestream, FFLZWGIF); /* read all the image */ linesize = s->picture.linesize[0]; ptr1 = s->picture.data[0] + top * linesize + left; ptr = ptr1; pass = 0; y1 = 0; for (y = 0; y < height; y++) { fflzwdecode(s->lzw, ptr, width); if (isinterleaved) { switch(pass) { default: case 0: case 1: y1 += 8; ptr += linesize * 8; if (y1 >= height) { y1 = pass ? 2 : 4; ptr = ptr1 + linesize * y1; pass++; } break; case 2: y1 += 4; ptr += linesize * 4; if (y1 >= height) { y1 = 1; ptr = ptr1 + linesize; pass++; } break; case 3: y1 += 2; ptr += linesize * 2; break; } } else { ptr += linesize; } } /* read the garbage data until end marker is found */ fflzwdecodetail(s->lzw); s->bytestream = fflzwcurptr(s->lzw); return 0; } ", "target": 0}
{"func": "static int alacencodeframe(AVCodecContext *avctx, uint8t *frame, int bufsize, void *data) { AlacEncodeContext *s = avctx->privdata; PutBitContext *pb = &s->pbctx; int i, outbytes, verbatimflag = 0; if (avctx->framesize > DEFAULTFRAMESIZE) { avlog(avctx, AVLOGERROR, \"input frame size exceeded\\n\"); return -1; } if (bufsize < 2 * s->maxcodedframesize) { avlog(avctx, AVLOGERROR, \"buffer size is too small\\n\"); return -1; } verbatim: initputbits(pb, frame, bufsize); if (s->compressionlevel == 0 || verbatimflag) { // Verbatim mode const int16t *samples = data; writeframeheader(s, 1); for (i = 0; i < avctx->framesize * avctx->channels; i++) { putsbits(pb, 16, *samples++); } } else { initsamplebuffers(s, data); writeframeheader(s, 0); writecompressedframe(s); } putbits(pb, 3, 7); flushputbits(pb); outbytes = putbitscount(pb) >> 3; if (outbytes > s->maxcodedframesize) { /* frame too large. use verbatim mode */ if (verbatimflag || s->compressionlevel == 0) { /* still too large. must be an error. */ avlog(avctx, AVLOGERROR, \"error encoding frame\\n\"); return -1; } verbatimflag = 1; goto verbatim; } return outbytes; } ", "target": 0}
{"func": "static void i440fxupdatememorymappings(PCII440FXState *d) { int i, r; uint32t smram; bool smramenabled; memoryregiontransactionbegin(); updatepam(d, 0xf0000, 0x100000, (d->dev.config[I440FXPAM] >> 4) & 3, &d->pamregions[0]); for(i = 0; i < 12; i++) { r = (d->dev.config[(i >> 1) + (I440FXPAM + 1)] >> ((i & 1) * 4)) & 3; updatepam(d, 0xc0000 + 0x4000 * i, 0xc0000 + 0x4000 * (i + 1), r, &d->pamregions[i+1]); } smram = d->dev.config[I440FXSMRAM]; smramenabled = (d->smmenabled && (smram & 0x08)) || (smram & 0x40); memoryregionsetenabled(&d->smramregion, !smramenabled); memoryregiontransactioncommit(); } ", "target": 1}
{"func": "static int vmdkopenvmdk4(BlockDriverState *bs, BlockDriverState *file, int flags) { int ret; uint32t magic; uint32t l1size, l1entrysectors; VMDK4Header header; VmdkExtent *extent; int64t l1backupoffset = 0; ret = bdrvpread(file, sizeof(magic), &header, sizeof(header)); if (ret < 0) { return ret; } if (header.capacity == 0) { int64t descoffset = le64tocpu(header.descoffset); if (descoffset) { return vmdkopendescfile(bs, flags, descoffset << 9); } } if (le64tocpu(header.gdoffset) == VMDK4GDATEND) { /* * The footer takes precedence over the header, so read it in. The * footer starts at offset -1024 from the end: One sector for the * footer, and another one for the end-of-stream marker. */ struct { struct { uint64t val; uint32t size; uint32t type; uint8t pad[512 - 16]; } QEMUPACKED footermarker; uint32t magic; VMDK4Header header; uint8t pad[512 - 4 - sizeof(VMDK4Header)]; struct { uint64t val; uint32t size; uint32t type; uint8t pad[512 - 16]; } QEMUPACKED eosmarker; } QEMUPACKED footer; ret = bdrvpread(file, bs->file->totalsectors * 512 - 1536, &footer, sizeof(footer)); if (ret < 0) { return ret; } /* Some sanity checks for the footer */ if (be32tocpu(footer.magic) != VMDK4MAGIC || le32tocpu(footer.footermarker.size) != 0 || le32tocpu(footer.footermarker.type) != MARKERFOOTER || le64tocpu(footer.eosmarker.val) != 0 || le32tocpu(footer.eosmarker.size) != 0 || le32tocpu(footer.eosmarker.type) != MARKERENDOFSTREAM) { return -EINVAL; } header = footer.header; } if (le32tocpu(header.version) >= 3) { char buf[64]; snprintf(buf, sizeof(buf), \"VMDK version %d\", le32tocpu(header.version)); qerrorreport(QERRUNKNOWNBLOCKFORMATFEATURE, bs->devicename, \"vmdk\", buf); return -ENOTSUP; } l1entrysectors = le32tocpu(header.numgtespergte) * le64tocpu(header.granularity); if (l1entrysectors == 0) { return -EINVAL; } l1size = (le64tocpu(header.capacity) + l1entrysectors - 1) / l1entrysectors; if (le32tocpu(header.flags) & VMDK4FLAGRGD) { l1backupoffset = le64tocpu(header.rgdoffset) << 9; } extent = vmdkaddextent(bs, file, false, le64tocpu(header.capacity), le64tocpu(header.gdoffset) << 9, l1backupoffset, l1size, le32tocpu(header.numgtespergte), le64tocpu(header.granularity)); extent->compressed = le16tocpu(header.compressAlgorithm) == VMDK4COMPRESSIONDEFLATE; extent->hasmarker = le32tocpu(header.flags) & VMDK4FLAGMARKER; extent->version = le32tocpu(header.version); extent->haszerograin = le32tocpu(header.flags) & VMDK4FLAGZEROGRAIN; ret = vmdkinittables(bs, extent); if (ret) { /* free extent allocated by vmdkaddextent */ vmdkfreelastextent(bs); } return ret; } ", "target": 1}
{"func": "static void controltonetwork(RDMAControlHeader *control) { control->type = htonl(control->type); control->len = htonl(control->len); control->repeat = htonl(control->repeat); } ", "target": 1}
{"func": "static bool usemultiport(VirtIOSerial *vser) { VirtIODevice *vdev = VIRTIODEVICE(vser); return virtiohasfeature(vdev, VIRTIOCONSOLEFMULTIPORT); } ", "target": 0}
{"func": "static int pollfilter(OutputStream *ost) { OutputFile *of = outputfiles[ost->fileindex]; AVFrame *filteredframe = NULL; int framesize, ret; if (!ost->filteredframe && !(ost->filteredframe = avcodecallocframe())) { return AVERROR(ENOMEM); } else avcodecgetframedefaults(ost->filteredframe); filteredframe = ost->filteredframe; if (ost->enc->type == AVMEDIATYPEAUDIO && !(ost->enc->capabilities & CODECCAPVARIABLEFRAMESIZE)) ret = avbuffersinkgetsamples(ost->filter->filter, filteredframe, ost->st->codec->framesize); else ret = avbuffersinkgetframe(ost->filter->filter, filteredframe); if (ret < 0) return ret; if (filteredframe->pts != AVNOPTSVALUE) { filteredframe->pts = avrescaleq(filteredframe->pts, ost->filter->filter->inputs[0]->timebase, ost->st->codec->timebase) - avrescaleq(of->starttime, AVTIMEBASEQ, ost->st->codec->timebase); } switch (ost->filter->filter->inputs[0]->type) { case AVMEDIATYPEVIDEO: if (!ost->frameaspectratio) ost->st->codec->sampleaspectratio = filteredframe->sampleaspectratio; dovideoout(of->ctx, ost, filteredframe, &framesize); if (vstatsfilename && framesize) dovideostats(ost, framesize); break; case AVMEDIATYPEAUDIO: doaudioout(of->ctx, ost, filteredframe); break; default: // TODO support subtitle filters avassert0(0); } avframeunref(filteredframe); return 0; } ", "target": 0}
{"func": "void *memoryregiongetramptr(MemoryRegion *mr) { if (mr->alias) { return memoryregiongetramptr(mr->alias) + mr->aliasoffset; } assert(mr->terminates); return qemugetramptr(mr->ramaddr & TARGETPAGEMASK); } ", "target": 0}
{"func": "void ffafqueueinit(AVCodecContext *avctx, AudioFrameQueue *afq) { afq->avctx = avctx; afq->nextpts = AVNOPTSVALUE; afq->remainingdelay = avctx->delay; afq->remainingsamples = avctx->delay; afq->framequeue = NULL; } ", "target": 0}
{"func": "void kvms390serviceinterrupt(S390CPU *cpu, uint32t parm) { kvms390interruptinternal(cpu, KVMS390INTSERVICE, parm, 0 , 1); } ", "target": 0}
{"func": "static inline void RENAME(rgb24tobgr15)(const uint8t *src, uint8t *dst, int srcsize) { const uint8t *s = src; const uint8t *end; const uint8t *mmend; uint16t *d = (uint16t *)dst; end = s + srcsize; asm volatile(PREFETCH\" %0\"::\"m\"(*src):\"memory\"); asm volatile( \"movq %0, %%mm7 \\n\\t\" \"movq %1, %%mm6 \\n\\t\" ::\"m\"(red15mask),\"m\"(green15mask)); mmend = end - 11; while (s < mmend) { asm volatile( PREFETCH\" 32%1 \\n\\t\" \"movd %1, %%mm0 \\n\\t\" \"movd 3%1, %%mm3 \\n\\t\" \"punpckldq 6%1, %%mm0 \\n\\t\" \"punpckldq 9%1, %%mm3 \\n\\t\" \"movq %%mm0, %%mm1 \\n\\t\" \"movq %%mm0, %%mm2 \\n\\t\" \"movq %%mm3, %%mm4 \\n\\t\" \"movq %%mm3, %%mm5 \\n\\t\" \"psrlq $3, %%mm0 \\n\\t\" \"psrlq $3, %%mm3 \\n\\t\" \"pand %2, %%mm0 \\n\\t\" \"pand %2, %%mm3 \\n\\t\" \"psrlq $6, %%mm1 \\n\\t\" \"psrlq $6, %%mm4 \\n\\t\" \"pand %%mm6, %%mm1 \\n\\t\" \"pand %%mm6, %%mm4 \\n\\t\" \"psrlq $9, %%mm2 \\n\\t\" \"psrlq $9, %%mm5 \\n\\t\" \"pand %%mm7, %%mm2 \\n\\t\" \"pand %%mm7, %%mm5 \\n\\t\" \"por %%mm1, %%mm0 \\n\\t\" \"por %%mm4, %%mm3 \\n\\t\" \"por %%mm2, %%mm0 \\n\\t\" \"por %%mm5, %%mm3 \\n\\t\" \"psllq $16, %%mm3 \\n\\t\" \"por %%mm3, %%mm0 \\n\\t\" MOVNTQ\" %%mm0, %0 \\n\\t\" :\"=m\"(*d):\"m\"(*s),\"m\"(blue15mask):\"memory\"); d += 4; s += 12; } asm volatile(SFENCE:::\"memory\"); asm volatile(EMMS:::\"memory\"); while (s < end) { const int b = *s++; const int g = *s++; const int r = *s++; *d++ = (b>>3) | ((g&0xF8)<<2) | ((r&0xF8)<<7); } } ", "target": 1}
{"func": "static gboolean gdmotionevent(GtkWidget *widget, GdkEventMotion *motion, void *opaque) { GtkDisplayState *s = opaque; int x, y; int mx, my; int fbh, fbw; int ww, wh; fbw = surfacewidth(s->ds) * s->scalex; fbh = surfaceheight(s->ds) * s->scaley; gdkdrawablegetsize(gtkwidgetgetwindow(s->drawingarea), &ww, &wh); mx = my = 0; if (ww > fbw) { mx = (ww - fbw) / 2; } if (wh > fbh) { my = (wh - fbh) / 2; } x = (motion->x - mx) / s->scalex; y = (motion->y - my) / s->scaley; if (x < 0 || y < 0 || x >= surfacewidth(s->ds) || y >= surfaceheight(s->ds)) { return TRUE; } if (qemuinputisabsolute()) { qemuinputqueueabs(s->dcl.con, INPUTAXISX, x, surfacewidth(s->ds)); qemuinputqueueabs(s->dcl.con, INPUTAXISY, y, surfaceheight(s->ds)); qemuinputeventsync(); } else if (s->lastx != -1 && s->lasty != -1 && gdisgrabactive(s)) { qemuinputqueuerel(s->dcl.con, INPUTAXISX, x - s->lastx); qemuinputqueuerel(s->dcl.con, INPUTAXISY, y - s->lasty); qemuinputeventsync(); } s->lastx = x; s->lasty = y; if (!qemuinputisabsolute() && gdisgrabactive(s)) { GdkScreen *screen = gtkwidgetgetscreen(s->drawingarea); int x = (int)motion->xroot; int y = (int)motion->yroot; /* In relative mode check to see if client pointer hit * one of the screen edges, and if so move it back by * 200 pixels. This is important because the pointer * in the server doesn't correspond 1-for-1, and so * may still be only half way across the screen. Without * this warp, the server pointer would thus appear to hit * an invisible wall */ if (x == 0) { x += 200; } if (y == 0) { y += 200; } if (x == (gdkscreengetwidth(screen) - 1)) { x -= 200; } if (y == (gdkscreengetheight(screen) - 1)) { y -= 200; } if (x != (int)motion->xroot || y != (int)motion->yroot) { #if GTKCHECKVERSION(3, 0, 0) GdkDevice *dev = gdkeventgetdevice((GdkEvent *)motion); gdkdevicewarp(dev, screen, x, y); #else GdkDisplay *display = gtkwidgetgetdisplay(widget); gdkdisplaywarppointer(display, screen, x, y); #endif s->lastx = -1; s->lasty = -1; return FALSE; } } return TRUE; } ", "target": 1}
{"func": "int ffvdpaucommoninit(AVCodecContext *avctx, VdpDecoderProfile profile, int level) { VDPAUHWContext *hwctx = avctx->hwaccelcontext; VDPAUContext *vdctx = avctx->internal->hwaccelprivdata; VdpVideoSurfaceQueryCapabilities *surfacequerycaps; VdpDecoderQueryCapabilities *decoderquerycaps; VdpDecoderCreate *create; void *func; VdpStatus status; VdpBool supported; uint32t maxlevel, maxmb, maxwidth, maxheight; VdpChromaType type; uint32t width; uint32t height; vdctx->width = UINT32MAX; vdctx->height = UINT32MAX; if (avvdpaugetsurfaceparameters(avctx, &type, &width, &height)) return AVERROR(ENOSYS); if (hwctx) { hwctx->reset = 0; if (hwctx->context.decoder != VDPINVALIDHANDLE) { vdctx->decoder = hwctx->context.decoder; vdctx->render = hwctx->context.render; vdctx->device = VDPINVALIDHANDLE; return 0; /* Decoder created by user */ } vdctx->device = hwctx->device; vdctx->getprocaddress = hwctx->getprocaddress; if (hwctx->flags & AVHWACCELFLAGIGNORELEVEL) level = 0; if (!(hwctx->flags & AVHWACCELFLAGALLOWHIGHDEPTH) && type != VDPCHROMATYPE420) return AVERROR(ENOSYS); } else { AVHWFramesContext *framesctx = NULL; AVVDPAUDeviceContext *devctx; // We assume the hwframesctx always survives until ffvdpaucommonuninit // is called. This holds true as the user is not allowed to touch // hwdevicectx, or hwframesctx after getformat (and ffgetformat // itself also uninits before unreffing hwframesctx). if (avctx->hwframesctx) { framesctx = (AVHWFramesContext*)avctx->hwframesctx->data; } else if (avctx->hwdevicectx) { int ret; avctx->hwframesctx = avhwframectxalloc(avctx->hwdevicectx); if (!avctx->hwframesctx) return AVERROR(ENOMEM); framesctx = (AVHWFramesContext*)avctx->hwframesctx->data; framesctx->format = AVPIXFMTVDPAU; framesctx->swformat = avctx->swpixfmt; framesctx->width = avctx->codedwidth; framesctx->height = avctx->codedheight; ret = avhwframectxinit(avctx->hwframesctx); if (ret < 0) { avbufferunref(&avctx->hwframesctx); return ret; } } if (!framesctx) { avlog(avctx, AVLOGERROR, \"A hardware frames context is \" \"required for VDPAU decoding.\\n\"); return AVERROR(EINVAL); } devctx = framesctx->devicectx->hwctx; vdctx->device = devctx->device; vdctx->getprocaddress = devctx->getprocaddress; if (avctx->hwaccelflags & AVHWACCELFLAGIGNORELEVEL) level = 0; } if (level < 0) return AVERROR(ENOTSUP); status = vdctx->getprocaddress(vdctx->device, VDPFUNCIDVIDEOSURFACEQUERYCAPABILITIES, &func); if (status != VDPSTATUSOK) return vdpauerror(status); else surfacequerycaps = func; status = surfacequerycaps(vdctx->device, type, &supported, &maxwidth, &maxheight); if (status != VDPSTATUSOK) return vdpauerror(status); if (supported != VDPTRUE || maxwidth < width || maxheight < height) return AVERROR(ENOTSUP); status = vdctx->getprocaddress(vdctx->device, VDPFUNCIDDECODERQUERYCAPABILITIES, &func); if (status != VDPSTATUSOK) return vdpauerror(status); else decoderquerycaps = func; status = decoderquerycaps(vdctx->device, profile, &supported, &maxlevel, &maxmb, &maxwidth, &maxheight); #ifdef VDPDECODERPROFILEH264CONSTRAINEDBASELINE if ((status != VDPSTATUSOK || supported != VDPTRUE) && profile == VDPDECODERPROFILEH264CONSTRAINEDBASELINE) { profile = VDPDECODERPROFILEH264MAIN; status = decoderquerycaps(vdctx->device, profile, &supported, &maxlevel, &maxmb, &maxwidth, &maxheight); } #endif if (status != VDPSTATUSOK) return vdpauerror(status); if (supported != VDPTRUE || maxlevel < level || maxwidth < width || maxheight < height) return AVERROR(ENOTSUP); status = vdctx->getprocaddress(vdctx->device, VDPFUNCIDDECODERCREATE, &func); if (status != VDPSTATUSOK) return vdpauerror(status); else create = func; status = vdctx->getprocaddress(vdctx->device, VDPFUNCIDDECODERRENDER, &func); if (status != VDPSTATUSOK) return vdpauerror(status); else vdctx->render = func; status = create(vdctx->device, profile, width, height, avctx->refs, &vdctx->decoder); if (status == VDPSTATUSOK) { vdctx->width = avctx->codedwidth; vdctx->height = avctx->codedheight; } return vdpauerror(status); } ", "target": 0}
{"func": "static int estimateqp(MpegEncContext *s, int dryrun){ if (s->nextlambda){ s->currentpictureptr->f.quality = s->currentpicture.f.quality = s->nextlambda; if(!dryrun) s->nextlambda= 0; } else if (!s->fixedqscale) { s->currentpictureptr->f.quality = s->currentpicture.f.quality = ffrateestimateqscale(s, dryrun); if (s->currentpicture.f.quality < 0) return -1; } if(s->adaptivequant){ switch(s->codecid){ case AVCODECIDMPEG4: if (CONFIGMPEG4ENCODER) ffcleanmpeg4qscales(s); break; case AVCODECIDH263: case AVCODECIDH263P: case AVCODECIDFLV1: if (CONFIGH263ENCODER) ffcleanh263qscales(s); break; default: ffinitqscaletab(s); } s->lambda= s->lambdatable[0]; //FIXME broken }else s->lambda = s->currentpicture.f.quality; updateqscale(s); return 0; } ", "target": 1}
{"func": "static void sprwritetbu (DisasContext *ctx, int sprn, int gprn) { if (useicount) { geniostart(); } genhelperstoretbu(cpuenv, cpugpr[gprn]); if (useicount) { genioend(); genstopexception(ctx); } } ", "target": 0}
{"func": "static void vfiointxenablekvm(VFIOPCIDevice *vdev) { #ifdef CONFIGKVM struct kvmirqfd irqfd = { .fd = eventnotifiergetfd(&vdev->intx.interrupt), .gsi = vdev->intx.route.irq, .flags = KVMIRQFDFLAGRESAMPLE, }; struct vfioirqset *irqset; int ret, argsz; int32t *pfd; if (!VFIOALLOWKVMINTX || !kvmirqfdsenabled() || vdev->intx.route.mode != PCIINTXENABLED || !kvmresamplefdsenabled()) { return; } /* Get to a known interrupt state */ qemusetfdhandler(irqfd.fd, NULL, NULL, vdev); vfiomasksingleirqindex(&vdev->vbasedev, VFIOPCIINTXIRQINDEX); vdev->intx.pending = false; pciirqdeassert(&vdev->pdev); /* Get an eventfd for resample/unmask */ if (eventnotifierinit(&vdev->intx.unmask, 0)) { errorreport(\"vfio: Error: eventnotifierinit failed eoi\"); goto fail; } /* KVM triggers it, VFIO listens for it */ irqfd.resamplefd = eventnotifiergetfd(&vdev->intx.unmask); if (kvmvmioctl(kvmstate, KVMIRQFD, &irqfd)) { errorreport(\"vfio: Error: Failed to setup resample irqfd: %m\"); goto failirqfd; } argsz = sizeof(*irqset) + sizeof(*pfd); irqset = gmalloc0(argsz); irqset->argsz = argsz; irqset->flags = VFIOIRQSETDATAEVENTFD | VFIOIRQSETACTIONUNMASK; irqset->index = VFIOPCIINTXIRQINDEX; irqset->start = 0; irqset->count = 1; pfd = (int32t *)&irqset->data; *pfd = irqfd.resamplefd; ret = ioctl(vdev->vbasedev.fd, VFIODEVICESETIRQS, irqset); gfree(irqset); if (ret) { errorreport(\"vfio: Error: Failed to setup INTx unmask fd: %m\"); goto failvfio; } /* Let'em rip */ vfiounmasksingleirqindex(&vdev->vbasedev, VFIOPCIINTXIRQINDEX); vdev->intx.kvmaccel = true; tracevfiointxenablekvm(vdev->vbasedev.name); return; failvfio: irqfd.flags = KVMIRQFDFLAGDEASSIGN; kvmvmioctl(kvmstate, KVMIRQFD, &irqfd); failirqfd: eventnotifiercleanup(&vdev->intx.unmask); fail: qemusetfdhandler(irqfd.fd, vfiointxinterrupt, NULL, vdev); vfiounmasksingleirqindex(&vdev->vbasedev, VFIOPCIINTXIRQINDEX); #endif } ", "target": 0}
{"func": "static inline void genevfsnabs(DisasContext *ctx) { if (unlikely(!ctx->speenabled)) { genexception(ctx, POWERPCEXCPAPU); return; } #if defined(TARGETPPC64) tcggenoritl(cpugpr[rD(ctx->opcode)], cpugpr[rA(ctx->opcode)], 0x8000000080000000LL); #else tcggenoritl(cpugpr[rD(ctx->opcode)], cpugpr[rA(ctx->opcode)], 0x80000000); tcggenoritl(cpugprh[rD(ctx->opcode)], cpugprh[rA(ctx->opcode)], 0x80000000); #endif } ", "target": 0}
{"func": "static uint64t imxtimergread(void *opaque, targetphysaddrt offset, unsigned size) { IMXTimerGState *s = (IMXTimerGState *)opaque; DPRINTF(\"g-read(offset=%x)\", offset >> 2); switch (offset >> 2) { case 0: /* Control Register */ DPRINTF(\" cr = %x\\n\", s->cr); return s->cr; case 1: /* prescaler */ DPRINTF(\" pr = %x\\n\", s->pr); return s->pr; case 2: /* Status Register */ DPRINTF(\" sr = %x\\n\", s->sr); return s->sr; case 3: /* Interrupt Register */ DPRINTF(\" ir = %x\\n\", s->ir); return s->ir; case 4: /* Output Compare Register 1 */ DPRINTF(\" ocr1 = %x\\n\", s->ocr1); return s->ocr1; case 9: /* cnt */ imxtimergupdatecounts(s); DPRINTF(\" cnt = %x\\n\", s->cnt); return s->cnt; } IPRINTF(\"imxtimergread: Bad offset %x\\n\", (int)offset >> 2); return 0; } ", "target": 0}
{"func": "static int blkdebugopen(BlockDriverState *bs, QDict *options, int flags, Error **errp) { BDRVBlkdebugState *s = bs->opaque; QemuOpts *opts; Error *localerr = NULL; int ret; opts = qemuoptscreate(&runtimeopts, NULL, 0, &errorabort); qemuoptsabsorbqdict(opts, options, &localerr); if (localerr) { errorpropagate(errp, localerr); ret = -EINVAL; goto out; } /* Read rules from config file or command line options */ s->configfile = gstrdup(qemuoptget(opts, \"config\")); ret = readconfig(s, s->configfile, options, errp); if (ret) { goto out; } /* Set initial state */ s->state = 1; /* Open the image file */ bs->file = bdrvopenchild(qemuoptget(opts, \"x-image\"), options, \"image\", bs, &childfile, false, &localerr); if (localerr) { ret = -EINVAL; errorpropagate(errp, localerr); goto out; } bs->supportedwriteflags = BDRVREQFUA & bs->file->bs->supportedwriteflags; bs->supportedzeroflags = (BDRVREQFUA | BDRVREQMAYUNMAP) & bs->file->bs->supportedzeroflags; ret = -EINVAL; /* Set request alignment */ s->align = qemuoptgetsize(opts, \"align\", 0); if (s->align && (s->align >= INTMAX || !ispowerof2(s->align))) { errorsetg(errp, \"Cannot meet constraints with align %\" PRIu64, s->align); goto out; } ret = 0; out: if (ret < 0) { gfree(s->configfile); } qemuoptsdel(opts); return ret; } ", "target": 0}
{"func": "static void testqemustrtoullfullnegative(void) { const char *str = \" \\t -321\"; uint64t res = 999; int err; err = qemustrtoull(str, NULL, 0, &res); gassertcmpint(err, ==, 0); gassertcmpint(res, ==, 18446744073709551295LLU); } ", "target": 0}
{"func": "static uint64t exynos4210fimdread(void *opaque, targetphysaddrt offset, unsigned size) { Exynos4210fimdState *s = (Exynos4210fimdState *)opaque; int w, i; uint32t ret = 0; DPRINTL2(\"read offset 0x%08x\\n\", offset); switch (offset) { case FIMDVIDCON0 ... FIMDVIDCON3: return s->vidcon[(offset - FIMDVIDCON0) >> 2]; case FIMDVIDTCONSTART ... FIMDVIDTCONEND: return s->vidtcon[(offset - FIMDVIDTCONSTART) >> 2]; case FIMDWINCONSTART ... FIMDWINCONEND: return s->window[(offset - FIMDWINCONSTART) >> 2].wincon; case FIMDSHADOWCON: return s->shadowcon; case FIMDWINCHMAP: return s->winchmap; case FIMDVIDOSDSTART ... FIMDVIDOSDEND: w = (offset - FIMDVIDOSDSTART) >> 4; i = ((offset - FIMDVIDOSDSTART) & 0xF) >> 2; switch (i) { case 0: ret = ((s->window[w].lefttopx & FIMDVIDOSDCOORDMASK) << FIMDVIDOSDHORSHIFT) | (s->window[w].lefttopy & FIMDVIDOSDCOORDMASK); break; case 1: ret = ((s->window[w].rightbotx & FIMDVIDOSDCOORDMASK) << FIMDVIDOSDHORSHIFT) | (s->window[w].rightboty & FIMDVIDOSDCOORDMASK); break; case 2: if (w == 0) { ret = s->window[w].osdsize; } else { ret = (packupper4(s->window[w].alphaval[0]) << FIMDVIDOSDAEN0SHIFT) | packupper4(s->window[w].alphaval[1]); } break; case 3: if (w != 1 && w != 2) { DPRINTERROR(\"bad read offset 0x%08x\\n\", offset); return 0xBAADBAAD; } ret = s->window[w].osdsize; break; } return ret; case FIMDVIDWADD0START ... FIMDVIDWADD0END: w = (offset - FIMDVIDWADD0START) >> 3; i = ((offset - FIMDVIDWADD0START) >> 2) & 1; return s->window[w].bufstart[i]; case FIMDVIDWADD1START ... FIMDVIDWADD1END: w = (offset - FIMDVIDWADD1START) >> 3; i = ((offset - FIMDVIDWADD1START) >> 2) & 1; return s->window[w].bufend[i]; case FIMDVIDWADD2START ... FIMDVIDWADD2END: w = (offset - FIMDVIDWADD2START) >> 2; return s->window[w].virtpagewidth | (s->window[w].virtpageoffsize << FIMDVIDWADD2OFFSIZESHIFT); case FIMDVIDINTCON0 ... FIMDVIDINTCON1: return s->vidintcon[(offset - FIMDVIDINTCON0) >> 2]; case FIMDWKEYCONSTART ... FIMDWKEYCONEND: w = ((offset - FIMDWKEYCONSTART) >> 3) + 1; i = ((offset - FIMDWKEYCONSTART) >> 2) & 1; return s->window[w].keycon[i]; case FIMDWKEYALPHASTART ... FIMDWKEYALPHAEND: w = ((offset - FIMDWKEYALPHASTART) >> 2) + 1; return s->window[w].keyalpha; case FIMDDITHMODE: return s->dithmode; case FIMDWINMAPSTART ... FIMDWINMAPEND: return s->window[(offset - FIMDWINMAPSTART) >> 2].winmap; case FIMDWPALCONHIGH ... FIMDWPALCONLOW: return s->wpalcon[(offset - FIMDWPALCONHIGH) >> 2]; case FIMDTRIGCON: return s->trigcon; case FIMDI80IFCONSTART ... FIMDI80IFCONEND: return s->i80ifcon[(offset - FIMDI80IFCONSTART) >> 2]; case FIMDCOLORGAINCON: return s->colorgaincon; case FIMDLDICMDCON0 ... FIMDLDICMDCON1: return s->ldicmdcon[(offset - FIMDLDICMDCON0) >> 2]; case FIMDSIFCCON0 ... FIMDSIFCCON2: i = (offset - FIMDSIFCCON0) >> 2; return s->sifccon[i]; case FIMDHUECOEFCRSTART ... FIMDHUECOEFCREND: i = (offset - FIMDHUECOEFCRSTART) >> 2; return s->huecoefcr[i]; case FIMDHUECOEFCBSTART ... FIMDHUECOEFCBEND: i = (offset - FIMDHUECOEFCBSTART) >> 2; return s->huecoefcb[i]; case FIMDHUEOFFSET: return s->hueoffset; case FIMDVIDWALPHASTART ... FIMDVIDWALPHAEND: w = ((offset - FIMDVIDWALPHASTART) >> 3); i = ((offset - FIMDVIDWALPHASTART) >> 2) & 1; return s->window[w].alphaval[i] & (w == 0 ? 0xFFFFFF : FIMDVIDALPHAALPHALOWER); case FIMDBLENDEQSTART ... FIMDBLENDEQEND: return s->window[(offset - FIMDBLENDEQSTART) >> 2].blendeq; case FIMDBLENDCON: return s->blendcon; case FIMDWRTQOSCONSTART ... FIMDWRTQOSCONEND: return s->window[(offset - FIMDWRTQOSCONSTART) >> 2].rtqoscon; case FIMDI80IFCMDSTART ... FIMDI80IFCMDEND: return s->i80ifcmd[(offset - FIMDI80IFCMDSTART) >> 2]; case FIMDVIDW0ADD0B2 ... FIMDVIDW4ADD0B2: if (offset & 0x0004) { break; } return s->window[(offset - FIMDVIDW0ADD0B2) >> 3].bufstart[2]; case FIMDSHDADD0START ... FIMDSHDADD0END: if (offset & 0x0004) { break; } return s->window[(offset - FIMDSHDADD0START) >> 3].shadowbufstart; case FIMDSHDADD1START ... FIMDSHDADD1END: if (offset & 0x0004) { break; } return s->window[(offset - FIMDSHDADD1START) >> 3].shadowbufend; case FIMDSHDADD2START ... FIMDSHDADD2END: return s->window[(offset - FIMDSHDADD2START) >> 2].shadowbufsize; case FIMDPALMEMSTART ... FIMDPALMEMEND: w = (offset - FIMDPALMEMSTART) >> 10; i = ((offset - FIMDPALMEMSTART) >> 2) & 0xFF; return s->window[w].palette[i]; case FIMDPALMEMALSTART ... FIMDPALMEMALEND: /* Palette aliases for win 0,1 */ w = (offset - FIMDPALMEMALSTART) >> 10; i = ((offset - FIMDPALMEMALSTART) >> 2) & 0xFF; return s->window[w].palette[i]; } DPRINTERROR(\"bad read offset 0x%08x\\n\", offset); return 0xBAADBAAD; } ", "target": 0}
{"func": "float64 HELPER(ucf64absd)(float64 a) { return float64abs(a); } ", "target": 0}
{"func": "static CharDriverState *qemuchropennull(const char *id, ChardevBackend *backend, ChardevReturn *ret, Error **errp) { CharDriverState *chr; ChardevCommon *common = backend->u.null; chr = qemuchralloc(common, errp); if (!chr) { return NULL; } chr->chrwrite = nullchrwrite; chr->explicitbeopen = true; return chr; } ", "target": 0}
{"func": "static int packetenqueue(CompareState *s, int mode) { ConnectionKey key; Packet *pkt = NULL; Connection *conn; if (mode == PRIMARYIN) { pkt = packetnew(s->prirs.buf, s->prirs.packetlen, s->prirs.vnethdrlen); } else { pkt = packetnew(s->secrs.buf, s->secrs.packetlen, s->secrs.vnethdrlen); } if (parsepacketearly(pkt)) { packetdestroy(pkt, NULL); pkt = NULL; return -1; } fillconnectionkey(pkt, &key); conn = connectionget(s->connectiontracktable, &key, &s->connlist); if (!conn->processing) { gqueuepushtail(&s->connlist, conn); conn->processing = true; } if (mode == PRIMARYIN) { if (!coloinsertpacket(&conn->primarylist, pkt)) { errorreport(\"colo compare primary queue size too big,\" \"drop packet\"); } } else { if (!coloinsertpacket(&conn->secondarylist, pkt)) { errorreport(\"colo compare secondary queue size too big,\" \"drop packet\"); } } return 0; } ", "target": 0}
{"func": "enum CodecID avcodecgetid(const AVCodecTag *tags[4], unsigned int tag) { int i; for(i=0; i<4 && tags[i]; i++){ enum CodecID id= codecgetid(tags[i], tag); if(id!=CODECIDNONE) return id; } return CODECIDNONE; } ", "target": 0}
{"func": "static void ideatapiidentify(IDEState *s) { uint16t *p; if (s->identifyset) { \tmemcpy(s->iobuffer, s->identifydata, sizeof(s->identifydata)); \treturn; } memset(s->iobuffer, 0, 512); p = (uint16t *)s->iobuffer; /* Removable CDROM, 50us response, 12 byte packets */ putle16(p + 0, (2 << 14) | (5 << 8) | (1 << 7) | (2 << 5) | (0 << 0)); padstr((char *)(p + 10), s->driveserialstr, 20); /* serial number */ putle16(p + 20, 3); /* buffer type */ putle16(p + 21, 512); /* cache size in sectors */ putle16(p + 22, 4); /* ecc bytes */ padstr((char *)(p + 23), s->version, 8); /* firmware version */ padstr((char *)(p + 27), \"QEMU DVD-ROM\", 40); /* model */ putle16(p + 48, 1); /* dword I/O (XXX: should not be set on CDROM) */ #ifdef USEDMACDROM putle16(p + 49, 1 << 9 | 1 << 8); /* DMA and LBA supported */ putle16(p + 53, 7); /* words 64-70, 54-58, 88 valid */ putle16(p + 62, 7); /* single word dma0-2 supported */ putle16(p + 63, 7); /* mdma0-2 supported */ #else putle16(p + 49, 1 << 9); /* LBA supported, no DMA */ putle16(p + 53, 3); /* words 64-70, 54-58 valid */ putle16(p + 63, 0x103); /* DMA modes XXX: may be incorrect */ #endif putle16(p + 64, 3); /* pio3-4 supported */ putle16(p + 65, 0xb4); /* minimum DMA multiword tx cycle time */ putle16(p + 66, 0xb4); /* recommended DMA multiword tx cycle time */ putle16(p + 67, 0x12c); /* minimum PIO cycle time without flow control */ putle16(p + 68, 0xb4); /* minimum PIO cycle time with IORDY flow control */ putle16(p + 71, 30); /* in ns */ putle16(p + 72, 30); /* in ns */ if (s->ncqqueues) { putle16(p + 75, s->ncqqueues - 1); /* NCQ supported */ putle16(p + 76, (1 << 8)); } putle16(p + 80, 0x1e); /* support up to ATA/ATAPI-4 */ #ifdef USEDMACDROM putle16(p + 88, 0x3f | (1 << 13)); /* udma5 set and supported */ #endif memcpy(s->identifydata, p, sizeof(s->identifydata)); s->identifyset = 1; } ", "target": 0}
{"func": "static int kvmputxsave(CPUState *env) { #ifdef KVMCAPXSAVE int i, r; struct kvmxsave* xsave; uint16t cwd, swd, twd, fop; if (!kvmhasxsave()) return kvmputfpu(env); xsave = qemumemalign(4096, sizeof(struct kvmxsave)); memset(xsave, 0, sizeof(struct kvmxsave)); cwd = swd = twd = fop = 0; swd = env->fpus & ~(7 << 11); swd |= (env->fpstt & 7) << 11; cwd = env->fpuc; for (i = 0; i < 8; ++i) twd |= (!env->fptags[i]) << i; xsave->region[0] = (uint32t)(swd << 16) + cwd; xsave->region[1] = (uint32t)(fop << 16) + twd; memcpy(&xsave->region[XSAVESTSPACE], env->fpregs, sizeof env->fpregs); memcpy(&xsave->region[XSAVEXMMSPACE], env->xmmregs, sizeof env->xmmregs); xsave->region[XSAVEMXCSR] = env->mxcsr; *(uint64t *)&xsave->region[XSAVEXSTATEBV] = env->xstatebv; memcpy(&xsave->region[XSAVEYMMHSPACE], env->ymmhregs, sizeof env->ymmhregs); r = kvmvcpuioctl(env, KVMSETXSAVE, xsave); qemufree(xsave); return r; #else return kvmputfpu(env); #endif } ", "target": 0}
{"func": "static inline void blockCopy(uint8t dst[], int dstStride, uint8t src[], int srcStride, \tint numLines, int levelFix) { \tint i; \tif(levelFix) \t{ #ifdef HAVEMMX \t\t\t\t\tasm volatile( \t\t\t\t\t\t\"movl %4, %%eax \\n\\t\" \t\t\t\t\t\t\"movl %%eax, temp0\\n\\t\" \t\t\t\t\t\t\"pushl %0 \\n\\t\" \t\t\t\t\t\t\"pushl %1 \\n\\t\" \t\t\t\t\t\t\"leal (%2,%2), %%eax\t\\n\\t\" \t\t\t\t\t\t\"leal (%3,%3), %%ebx\t\\n\\t\" \t\t\t\t\t\t\"movq packedYOffset, %%mm2\t\\n\\t\" \t\t\t\t\t\t\"movq packedYScale, %%mm3\t\\n\\t\" \t\t\t\t\t\t\"pxor %%mm4, %%mm4\t\\n\\t\" #define SCALEDCPY\t\t\t\t\t\\ \t\t\t\t\t\t\"movq (%0), %%mm0\t\\n\\t\"\\ \t\t\t\t\t\t\"movq (%0,%2), %%mm1\t\\n\\t\"\\ \t\t\t\t\t\t\"psubusb %%mm2, %%mm0\t\\n\\t\"\\ \t\t\t\t\t\t\"psubusb %%mm2, %%mm1\t\\n\\t\"\\ \t\t\t\t\t\t\"movq %%mm0, %%mm5\t\\n\\t\"\\ \t\t\t\t\t\t\"punpcklbw %%mm4, %%mm0 \\n\\t\"\\ \t\t\t\t\t\t\"punpckhbw %%mm4, %%mm5 \\n\\t\"\\ \t\t\t\t\t\t\"psllw $7, %%mm0\t\\n\\t\"\\ \t\t\t\t\t\t\"psllw $7, %%mm5\t\\n\\t\"\\ \t\t\t\t\t\t\"pmulhw %%mm3, %%mm0\t\\n\\t\"\\ \t\t\t\t\t\t\"pmulhw %%mm3, %%mm5\t\\n\\t\"\\ \t\t\t\t\t\t\"packuswb %%mm5, %%mm0\t\\n\\t\"\\ \t\t\t\t\t\t\"movq %%mm0, (%1)\t\\n\\t\"\\ \t\t\t\t\t\t\"movq %%mm1, %%mm5\t\\n\\t\"\\ \t\t\t\t\t\t\"punpcklbw %%mm4, %%mm1 \\n\\t\"\\ \t\t\t\t\t\t\"punpckhbw %%mm4, %%mm5 \\n\\t\"\\ \t\t\t\t\t\t\"psllw $7, %%mm1\t\\n\\t\"\\ \t\t\t\t\t\t\"psllw $7, %%mm5\t\\n\\t\"\\ \t\t\t\t\t\t\"pmulhw %%mm3, %%mm1\t\\n\\t\"\\ \t\t\t\t\t\t\"pmulhw %%mm3, %%mm5\t\\n\\t\"\\ \t\t\t\t\t\t\"packuswb %%mm5, %%mm1\t\\n\\t\"\\ \t\t\t\t\t\t\"movq %%mm1, (%1, %3)\t\\n\\t\"\\ \t\t\t\t\t\t\"1:\t\t\t\\n\\t\" SCALEDCPY \t\t\t\t\t\t\"addl %%eax, %0\t\t\\n\\t\" \t\t\t\t\t\t\"addl %%ebx, %1\t\t\\n\\t\" SCALEDCPY \t\t\t\t\t\t\"addl %%eax, %0\t\t\\n\\t\" \t\t\t\t\t\t\"addl %%ebx, %1\t\t\\n\\t\" \t\t\t\t\t\t\"decl temp0\t\t\\n\\t\" \t\t\t\t\t\t\"jnz 1b\t\t\t\\n\\t\" \t\t\t\t\t\t\"popl %1 \\n\\t\" \t\t\t\t\t\t\"popl %0 \\n\\t\" \t\t\t\t\t\t: : \"r\" (src), \t\t\t\t\t\t\"r\" (dst), \t\t\t\t\t\t\"r\" (srcStride), \t\t\t\t\t\t\"r\" (dstStride), \t\t\t\t\t\t\"m\" (numLines>>2) \t\t\t\t\t\t: \"%eax\", \"%ebx\" \t\t\t\t\t); #else \t\t\t\tfor(i=0; i<numLines; i++) \t\t\t\t\tmemcpy(\t&(dst[dstStride*i]), \t\t\t\t\t\t&(src[srcStride*i]), BLOCKSIZE); #endif \t} \telse \t{ #ifdef HAVEMMX \t\t\t\t\tasm volatile( \t\t\t\t\t\t\"movl %4, %%eax \\n\\t\" \t\t\t\t\t\t\"movl %%eax, temp0\\n\\t\" \t\t\t\t\t\t\"pushl %0 \\n\\t\" \t\t\t\t\t\t\"pushl %1 \\n\\t\" \t\t\t\t\t\t\"leal (%2,%2), %%eax\t\\n\\t\" \t\t\t\t\t\t\"leal (%3,%3), %%ebx\t\\n\\t\" \t\t\t\t\t\t\"movq packedYOffset, %%mm2\t\\n\\t\" \t\t\t\t\t\t\"movq packedYScale, %%mm3\t\\n\\t\" #define SIMPLECPY\t\t\t\t\t\\ \t\t\t\t\t\t\"movq (%0), %%mm0\t\\n\\t\"\\ \t\t\t\t\t\t\"movq (%0,%2), %%mm1\t\\n\\t\"\\ \t\t\t\t\t\t\"movq %%mm0, (%1)\t\\n\\t\"\\ \t\t\t\t\t\t\"movq %%mm1, (%1, %3)\t\\n\\t\"\\ \t\t\t\t\t\t\"1:\t\t\t\\n\\t\" SIMPLECPY \t\t\t\t\t\t\"addl %%eax, %0\t\t\\n\\t\" \t\t\t\t\t\t\"addl %%ebx, %1\t\t\\n\\t\" SIMPLECPY \t\t\t\t\t\t\"addl %%eax, %0\t\t\\n\\t\" \t\t\t\t\t\t\"addl %%ebx, %1\t\t\\n\\t\" \t\t\t\t\t\t\"decl temp0\t\t\\n\\t\" \t\t\t\t\t\t\"jnz 1b\t\t\t\\n\\t\" \t\t\t\t\t\t\"popl %1 \\n\\t\" \t\t\t\t\t\t\"popl %0 \\n\\t\" \t\t\t\t\t\t: : \"r\" (src), \t\t\t\t\t\t\"r\" (dst), \t\t\t\t\t\t\"r\" (srcStride), \t\t\t\t\t\t\"r\" (dstStride), \t\t\t\t\t\t\"m\" (numLines>>2) \t\t\t\t\t\t: \"%eax\", \"%ebx\" \t\t\t\t\t); #else \t\t\t\tfor(i=0; i<numLines; i++) \t\t\t\t\tmemcpy(\t&(dst[dstStride*i]), \t\t\t\t\t\t&(src[srcStride*i]), BLOCKSIZE); #endif \t} } ", "target": 1}
{"func": "buildtpm2(GArray *tabledata, BIOSLinker *linker) { Acpi20TPM2 *tpm2ptr; tpm2ptr = acpidatapush(tabledata, sizeof *tpm2ptr); tpm2ptr->platformclass = cputole16(TPM2ACPICLASSCLIENT); tpm2ptr->controlareaaddress = cputole64(0); tpm2ptr->startmethod = cputole32(TPM2STARTMETHODMMIO); buildheader(linker, tabledata, (void *)tpm2ptr, \"TPM2\", sizeof(*tpm2ptr), 4, NULL, NULL); } ", "target": 1}
{"func": "int ffhevcoutputframe(HEVCContext *s, AVFrame *out, int flush) { do { int nboutput = 0; int minpoc = INTMAX; int i, minidx, ret; if (s->sh.nooutputofpriorpicsflag == 1) { for (i = 0; i < FFARRAYELEMS(s->DPB); i++) { HEVCFrame *frame = &s->DPB[i]; if (!(frame->flags & HEVCFRAMEFLAGBUMPING) && frame->poc != s->poc && frame->sequence == s->seqoutput) { ffhevcunrefframe(s, frame, HEVCFRAMEFLAGOUTPUT); } } } for (i = 0; i < FFARRAYELEMS(s->DPB); i++) { HEVCFrame *frame = &s->DPB[i]; if ((frame->flags & HEVCFRAMEFLAGOUTPUT) && frame->sequence == s->seqoutput) { nboutput++; if (frame->poc < minpoc) { minpoc = frame->poc; minidx = i; } } } /* wait for more frames before output */ if (!flush && s->seqoutput == s->seqdecode && s->sps && nboutput <= s->sps->temporallayer[s->sps->maxsublayers - 1].numreorderpics) return 0; if (nboutput) { HEVCFrame *frame = &s->DPB[minidx]; AVFrame *dst = out; AVFrame *src = frame->frame; const AVPixFmtDescriptor *desc = avpixfmtdescget(src->format); int pixelshift = !!(desc->comp[0].depthminus1 > 7); ret = avframeref(out, src); if (frame->flags & HEVCFRAMEFLAGBUMPING) ffhevcunrefframe(s, frame, HEVCFRAMEFLAGOUTPUT | HEVCFRAMEFLAGBUMPING); else ffhevcunrefframe(s, frame, HEVCFRAMEFLAGOUTPUT); if (ret < 0) return ret; for (i = 0; i < 3; i++) { int hshift = (i > 0) ? desc->log2chromaw : 0; int vshift = (i > 0) ? desc->log2chromah : 0; int off = ((frame->window.leftoffset >> hshift) << pixelshift) + (frame->window.topoffset >> vshift) * dst->linesize[i]; dst->data[i] += off; } avlog(s->avctx, AVLOGDEBUG, \"Output frame with POC %d.\\n\", frame->poc); return 1; } if (s->seqoutput != s->seqdecode) s->seqoutput = (s->seqoutput + 1) & 0xff; else break; } while (1); return 0; } ", "target": 1}
{"func": "static int mpegaudioparse(AVCodecParserContext *s1, AVCodecContext *avctx, uint8t **poutbuf, int *poutbufsize, const uint8t *buf, int bufsize) { MpegAudioParseContext *s = s1->privdata; int len, ret; uint32t header; const uint8t *bufptr; *poutbuf = NULL; *poutbufsize = 0; bufptr = buf; while (bufsize > 0) { \tlen = s->inbufptr - s->inbuf; \tif (s->framesize == 0) { /* special case for next header for first frame in free format case (XXX: find a simpler method) */ if (s->freeformatnextheader != 0) { s->inbuf[0] = s->freeformatnextheader >> 24; s->inbuf[1] = s->freeformatnextheader >> 16; s->inbuf[2] = s->freeformatnextheader >> 8; s->inbuf[3] = s->freeformatnextheader; s->inbufptr = s->inbuf + 4; s->freeformatnextheader = 0; goto gotheader; } \t /* no header seen : find one. We need at least MPAHEADERSIZE bytes to parse it */ \t len = MPAHEADERSIZE - len; \t if (len > bufsize) \t\tlen = bufsize; \t if (len > 0) { \t\tmemcpy(s->inbufptr, bufptr, len); \t\tbufptr += len; \t\tbufsize -= len; \t\ts->inbufptr += len; \t } \t if ((s->inbufptr - s->inbuf) >= MPAHEADERSIZE) { gotheader: \t\theader = (s->inbuf[0] << 24) | (s->inbuf[1] << 16) | \t\t (s->inbuf[2] << 8) | s->inbuf[3]; ret = mpadecodeheader(avctx, header); if (ret < 0) { \t\t /* no sync found : move by one byte (inefficient, but simple!) */ \t\t memmove(s->inbuf, s->inbuf + 1, s->inbufptr - s->inbuf - 1); \t\t s->inbufptr--; dprintf(\"skip %x\\n\", header); /* reset free format frame size to give a chance to get a new bitrate */ s->freeformatframesize = 0; \t\t} else { s->framesize = ret; #if 0 /* free format: prepare to compute frame size */ \t\t if (decodeheader(s, header) == 1) { \t\t\ts->framesize = -1; } #endif \t\t} \t } } else #if 0 if (s->framesize == -1) { /* free format : find next sync to compute frame size */ \t len = MPAMAXCODEDFRAMESIZE - len; \t if (len > bufsize) \t\tlen = bufsize; if (len == 0) { \t\t/* frame too long: resync */ s->framesize = 0; \t\tmemmove(s->inbuf, s->inbuf + 1, s->inbufptr - s->inbuf - 1); \t\ts->inbufptr--; } else { uint8t *p, *pend; uint32t header1; int padding; memcpy(s->inbufptr, bufptr, len); /* check for header */ p = s->inbufptr - 3; pend = s->inbufptr + len - 4; while (p <= pend) { header = (p[0] << 24) | (p[1] << 16) | (p[2] << 8) | p[3]; header1 = (s->inbuf[0] << 24) | (s->inbuf[1] << 16) | (s->inbuf[2] << 8) | s->inbuf[3]; /* check with high probability that we have a valid header */ if ((header & SAMEHEADERMASK) == (header1 & SAMEHEADERMASK)) { /* header found: update pointers */ len = (p + 4) - s->inbufptr; bufptr += len; bufsize -= len; s->inbufptr = p; /* compute frame size */ s->freeformatnextheader = header; s->freeformatframesize = s->inbufptr - s->inbuf; padding = (header1 >> 9) & 1; if (s->layer == 1) s->freeformatframesize -= padding * 4; else s->freeformatframesize -= padding; dprintf(\"free frame size=%d padding=%d\\n\", s->freeformatframesize, padding); decodeheader(s, header1); goto nextdata; } p++; } /* not found: simply increase pointers */ bufptr += len; s->inbufptr += len; bufsize -= len; } \t} else #endif if (len < s->framesize) { if (s->framesize > MPAMAXCODEDFRAMESIZE) s->framesize = MPAMAXCODEDFRAMESIZE; \t len = s->framesize - len; \t if (len > bufsize) \t\tlen = bufsize; \t memcpy(s->inbufptr, bufptr, len); \t bufptr += len; \t s->inbufptr += len; \t bufsize -= len; \t} // nextdata: if (s->framesize > 0 && (s->inbufptr - s->inbuf) >= s->framesize) { *poutbuf = s->inbuf; *poutbufsize = s->inbufptr - s->inbuf; \t s->inbufptr = s->inbuf; \t s->framesize = 0; \t break; \t} } return bufptr - buf; } ", "target": 0}
{"func": "JNIEnv *ffjniattachenv(int *attached, void *logctx) { int ret = 0; JNIEnv *env = NULL; *attached = 0; pthreadmutexlock(&lock); if (javavm == NULL && (javavm = avjnigetjavavm(logctx)) == NULL) { avlog(logctx, AVLOGINFO, \"Retrieving current Java virtual machine using Android JniInvocation wrapper\\n\"); if (checkjniinvocation(logctx) == 0) { if ((javavm = getjavavm(NULL, logctx)) != NULL || (javavm = getjavavm(\"libdvm.so\", logctx)) != NULL || (javavm = getjavavm(\"libart.so\", logctx)) != NULL) { avlog(logctx, AVLOGINFO, \"Found Java virtual machine using Android JniInvocation wrapper\\n\"); } } } pthreadmutexunlock(&lock); if (!javavm) { avlog(logctx, AVLOGERROR, \"Could not retrieve a Java virtual machine\\n\"); return NULL; } ret = (*javavm)->GetEnv(javavm, (void **)&env, JNIVERSION16); switch(ret) { case JNIEDETACHED: if ((*javavm)->AttachCurrentThread(javavm, &env, NULL) != 0) { avlog(logctx, AVLOGERROR, \"Failed to attach the JNI environment to the current thread\\n\"); env = NULL; } else { *attached = 1; } break; case JNIOK: break; case JNIEVERSION: avlog(logctx, AVLOGERROR, \"The specified JNI version is not supported\\n\"); break; default: avlog(logctx, AVLOGERROR, \"Failed to get the JNI environment attached to this thread\"); break; } return env; } ", "target": 0}
{"func": "static int performcow(BlockDriverState *bs, QCowL2Meta *m) { BDRVQcow2State *s = bs->opaque; Qcow2COWRegion *start = &m->cowstart; Qcow2COWRegion *end = &m->cowend; unsigned buffersize; unsigned databytes = end->offset - (start->offset + start->nbbytes); bool mergereads; uint8t *startbuffer, *endbuffer; QEMUIOVector qiov; int ret; assert(start->nbbytes <= UINTMAX - end->nbbytes); assert(start->nbbytes + end->nbbytes <= UINTMAX - databytes); assert(start->offset + start->nbbytes <= end->offset); assert(!m->dataqiov || m->dataqiov->size == databytes); if (start->nbbytes == 0 && end->nbbytes == 0) { return 0; } /* If we have to read both the start and end COW regions and the * middle region is not too large then perform just one read * operation */ mergereads = start->nbbytes && end->nbbytes && databytes <= 16384; if (mergereads) { buffersize = start->nbbytes + databytes + end->nbbytes; } else { /* If we have to do two reads, add some padding in the middle * if necessary to make sure that the end region is optimally * aligned. */ sizet align = bdrvoptmemalign(bs); assert(align > 0 && align <= UINTMAX); assert(QEMUALIGNUP(start->nbbytes, align) <= UINTMAX - end->nbbytes); buffersize = QEMUALIGNUP(start->nbbytes, align) + end->nbbytes; } /* Reserve a buffer large enough to store all the data that we're * going to read */ startbuffer = qemutryblockalign(bs, buffersize); if (startbuffer == NULL) { return -ENOMEM; } /* The part of the buffer where the end region is located */ endbuffer = startbuffer + buffersize - end->nbbytes; qemuiovecinit(&qiov, 2 + (m->dataqiov ? m->dataqiov->niov : 0)); qemucomutexunlock(&s->lock); /* First we read the existing data from both COW regions. We * either read the whole region in one go, or the start and end * regions separately. */ if (mergereads) { qemuiovecadd(&qiov, startbuffer, buffersize); ret = doperformcowread(bs, m->offset, start->offset, &qiov); } else { qemuiovecadd(&qiov, startbuffer, start->nbbytes); ret = doperformcowread(bs, m->offset, start->offset, &qiov); if (ret < 0) { goto fail; } qemuiovecreset(&qiov); qemuiovecadd(&qiov, endbuffer, end->nbbytes); ret = doperformcowread(bs, m->offset, end->offset, &qiov); } if (ret < 0) { goto fail; } /* Encrypt the data if necessary before writing it */ if (bs->encrypted) { if (!doperformcowencrypt(bs, m->offset, start->offset, startbuffer, start->nbbytes) || !doperformcowencrypt(bs, m->offset, end->offset, endbuffer, end->nbbytes)) { ret = -EIO; goto fail; } } /* And now we can write everything. If we have the guest data we * can write everything in one single operation */ if (m->dataqiov) { qemuiovecreset(&qiov); if (start->nbbytes) { qemuiovecadd(&qiov, startbuffer, start->nbbytes); } qemuiovecconcat(&qiov, m->dataqiov, 0, databytes); if (end->nbbytes) { qemuiovecadd(&qiov, endbuffer, end->nbbytes); } /* NOTE: we have a writeaio blkdebug event here followed by * a cowwrite one in doperformcowwrite(), but there's only * one single I/O operation */ BLKDBGEVENT(bs->file, BLKDBGWRITEAIO); ret = doperformcowwrite(bs, m->allocoffset, start->offset, &qiov); } else { /* If there's no guest data then write both COW regions separately */ qemuiovecreset(&qiov); qemuiovecadd(&qiov, startbuffer, start->nbbytes); ret = doperformcowwrite(bs, m->allocoffset, start->offset, &qiov); if (ret < 0) { goto fail; } qemuiovecreset(&qiov); qemuiovecadd(&qiov, endbuffer, end->nbbytes); ret = doperformcowwrite(bs, m->allocoffset, end->offset, &qiov); } fail: qemucomutexlock(&s->lock); /* * Before we update the L2 table to actually point to the new cluster, we * need to be sure that the refcounts have been increased and COW was * handled. */ if (ret == 0) { qcow2cachedependsonflush(s->l2tablecache); } qemuvfree(startbuffer); qemuiovecdestroy(&qiov); return ret; } ", "target": 1}
{"func": "void swsrgb2rgbinit(int flags) { #if HAVESSE2 || HAVEMMX2 || HAVEAMD3DNOW || HAVEMMX if (flags & SWSCPUCAPSSSE2) rgb2rgbinitSSE2(); else if (flags & SWSCPUCAPSMMX2) rgb2rgbinitMMX2(); else if (flags & SWSCPUCAPS3DNOW) rgb2rgbinit3DNOW(); else if (flags & SWSCPUCAPSMMX) rgb2rgbinitMMX(); else #endif /* HAVEMMX2 || HAVEAMD3DNOW || HAVEMMX */ rgb2rgbinitC(); } ", "target": 0}
{"func": "static double tgetdouble(GetByteContext *gb, int le) { avalias64 i = { .u64 = le ? bytestream2getle64(gb) : bytestream2getbe64(gb)}; return i.f64; } ", "target": 0}
{"func": "static void initprocpower5plus(CPUPPCState *env) { gensprne601(env); genspr7xx(env); /* Time base */ gentbl(env); /* Hardware implementation registers */ /* XXX : not implemented */ sprregister(env, SPRHID0, \"HID0\", SPRNOACCESS, SPRNOACCESS, &sprreadgeneric, &sprwriteclear, 0x60000000); /* XXX : not implemented */ sprregister(env, SPRHID1, \"HID1\", SPRNOACCESS, SPRNOACCESS, &sprreadgeneric, &sprwritegeneric, 0x00000000); /* XXX : not implemented */ sprregister(env, SPR750FXHID2, \"HID2\", SPRNOACCESS, SPRNOACCESS, &sprreadgeneric, &sprwritegeneric, 0x00000000); /* XXX : not implemented */ sprregister(env, SPR970HID5, \"HID5\", SPRNOACCESS, SPRNOACCESS, &sprreadgeneric, &sprwritegeneric, POWERPC970HID5INIT); /* XXX : not implemented */ sprregister(env, SPRL2CR, \"L2CR\", SPRNOACCESS, SPRNOACCESS, &sprreadgeneric, NULL, 0x00000000); /* Memory management */ /* XXX: not correct */ genlowBATs(env); /* XXX : not implemented */ sprregister(env, SPRMMUCFG, \"MMUCFG\", SPRNOACCESS, SPRNOACCESS, &sprreadgeneric, SPRNOACCESS, 0x00000000); /* TOFIX */ /* XXX : not implemented */ sprregister(env, SPRMMUCSR0, \"MMUCSR0\", SPRNOACCESS, SPRNOACCESS, &sprreadgeneric, &sprwritegeneric, 0x00000000); /* TOFIX */ sprregister(env, SPRHIOR, \"SPRHIOR\", SPRNOACCESS, SPRNOACCESS, &sprreadhior, &sprwritehior, 0x00000000); sprregister(env, SPRCTRL, \"SPRCTRL\", SPRNOACCESS, SPRNOACCESS, &sprreadgeneric, &sprwritegeneric, 0x00000000); sprregister(env, SPRUCTRL, \"SPRUCTRL\", SPRNOACCESS, SPRNOACCESS, &sprreadgeneric, &sprwritegeneric, 0x00000000); sprregister(env, SPRVRSAVE, \"SPRVRSAVE\", &sprreadgeneric, &sprwritegeneric, &sprreadgeneric, &sprwritegeneric, 0x00000000); #if !defined(CONFIGUSERONLY) env->slbnr = 64; #endif initexcp970(env); env->dcachelinesize = 128; env->icachelinesize = 128; /* Allocate hardware IRQ controller */ ppc970irqinit(env); /* Can't find information on what this should be on reset. This * value is the one used by 74xx processors. */ vscrinit(env, 0x00010000); } ", "target": 1}
{"func": "static int64t getbitrate(AVCodecContext *ctx) { int64t bitrate; int bitspersample; switch (ctx->codectype) { case AVMEDIATYPEVIDEO: case AVMEDIATYPEDATA: case AVMEDIATYPESUBTITLE: case AVMEDIATYPEATTACHMENT: bitrate = ctx->bitrate; break; case AVMEDIATYPEAUDIO: bitspersample = avgetbitspersample(ctx->codecid); bitrate = bitspersample ? ctx->samplerate * ctx->channels * bitspersample : ctx->bitrate; break; default: bitrate = 0; break; } return bitrate; } ", "target": 1}
{"func": "static int mkvwritecodecprivate(AVFormatContext *s, AVIOContext *pb, AVCodecParameters *par, int nativeid, int qtid) { AVIOContext *dyncp; uint8t *codecpriv; int ret, codecprivsize; ret = avioopendynbuf(&dyncp); if (ret < 0) return ret; if (nativeid) { ret = mkvwritenativecodecprivate(s, par, dyncp); } else if (par->codectype == AVMEDIATYPEVIDEO) { if (qtid) { if (!par->codectag) par->codectag = ffcodecgettag(ffcodecmovvideotags, par->codecid); if ( ffcodecgetid(ffcodecmovvideotags, par->codectag) == par->codecid && (!par->extradatasize || ffcodecgetid(ffcodecmovvideotags, AVRL32(par->extradata + 4)) != par->codecid) ) { int i; aviowb32(dyncp, 0x5a + par->extradatasize); aviowl32(dyncp, par->codectag); for(i = 0; i < 0x5a - 8; i++) aviow8(dyncp, 0); } aviowrite(dyncp, par->extradata, par->extradatasize); } else { if (!ffcodecgettag(ffcodecbmptags, par->codecid)) avlog(s, AVLOGWARNING, \"codec %s is not supported by this format\\n\", avcodecgetname(par->codecid)); if (!par->codectag) par->codectag = ffcodecgettag(ffcodecbmptags, par->codecid); if (!par->codectag && par->codecid != AVCODECIDRAWVIDEO) { avlog(s, AVLOGERROR, \"No bmp codec tag found for codec %s\\n\", avcodecgetname(par->codecid)); ret = AVERROR(EINVAL); } ffputbmpheader(dyncp, par, ffcodecbmptags, 0, 0); } } else if (par->codectype == AVMEDIATYPEAUDIO) { unsigned int tag; tag = ffcodecgettag(ffcodecwavtags, par->codecid); if (!tag) { avlog(s, AVLOGERROR, \"No wav codec tag found for codec %s\\n\", avcodecgetname(par->codecid)); ret = AVERROR(EINVAL); } if (!par->codectag) par->codectag = tag; ffputwavheader(s, dyncp, par, FFPUTWAVHEADERFORCEWAVEFORMATEX); } codecprivsize = avioclosedynbuf(dyncp, &codecpriv); if (codecprivsize) putebmlbinary(pb, MATROSKAIDCODECPRIVATE, codecpriv, codecprivsize); avfree(codecpriv); return ret; } ", "target": 0}
{"func": "void ffvp3idctdcaddc(uint8t *dest/*align 8*/, int linesize, const DCTELEM *block/*align 16*/){ int i, dc = (block[0] + 15) >> 5; const uint8t *cm = ffcropTbl + MAXNEGCROP + dc; for(i = 0; i < 8; i++){ dest[0] = cm[dest[0]]; dest[1] = cm[dest[1]]; dest[2] = cm[dest[2]]; dest[3] = cm[dest[3]]; dest[4] = cm[dest[4]]; dest[5] = cm[dest[5]]; dest[6] = cm[dest[6]]; dest[7] = cm[dest[7]]; dest += linesize; } } ", "target": 1}
{"func": "void objectpropertyaddbool(Object *obj, const char *name, bool (*get)(Object *, Error **), void (*set)(Object *, bool, Error **), Error **errp) { BoolProperty *prop = gmalloc0(sizeof(*prop)); prop->get = get; prop->set = set; objectpropertyadd(obj, name, \"bool\", get ? propertygetbool : NULL, set ? propertysetbool : NULL, propertyreleasebool, prop, errp); } ", "target": 1}
{"func": "static inline int mirror(int v, int m){ if (v<0) return -v; else if(v>m) return 2*m-v; else return v; } ", "target": 1}
{"func": "void virtioblkdataplanestop(VirtIOBlockDataPlane *s) { if (!s->started) { return; } s->started = false; tracevirtioblkdataplanestop(s); /* Stop thread or cancel pending thread creation BH */ if (s->startbh) { qemubhdelete(s->startbh); s->startbh = NULL; } else { eventpollnotify(&s->eventpoll); qemuthreadjoin(&s->thread); } ioqcleanup(&s->ioqueue); s->vdev->binding->sethostnotifier(s->vdev->bindingopaque, 0, false); eventpollcleanup(&s->eventpoll); /* Clean up guest notifier (irq) */ s->vdev->binding->setguestnotifiers(s->vdev->bindingopaque, 1, false); vringteardown(&s->vring); } ", "target": 1}
{"func": "static int movwritetkhdtag(AVIOContext *pb, MOVMuxContext *mov, MOVTrack *track, AVStream *st) { int64t duration = avrescalernd(track->trackduration, MOVTIMESCALE, track->timescale, AVROUNDUP); int version = duration < INT32MAX ? 0 : 1; int flags = MOVTKHDFLAGINMOVIE; int rotation = 0; int group = 0; uint32t *displaymatrix = NULL; int displaymatrixsize, i; if (st) { if (mov->perstreamgrouping) group = st->index; else group = st->codecpar->codectype; displaymatrix = (uint32t*)avstreamgetsidedata(st, AVPKTDATADISPLAYMATRIX, &displaymatrixsize); if (displaymatrix && displaymatrixsize < 9 * sizeof(*displaymatrix)) displaymatrix = NULL; } if (track->flags & MOVTRACKENABLED) flags |= MOVTKHDFLAGENABLED; if (track->mode == MODEISM) version = 1; (version == 1) ? aviowb32(pb, 104) : aviowb32(pb, 92); /* size */ ffiowfourcc(pb, \"tkhd\"); aviow8(pb, version); aviowb24(pb, flags); if (version == 1) { aviowb64(pb, track->time); aviowb64(pb, track->time); } else { aviowb32(pb, track->time); /* creation time */ aviowb32(pb, track->time); /* modification time */ } aviowb32(pb, track->trackid); /* track-id */ aviowb32(pb, 0); /* reserved */ if (!track->entry && mov->mode == MODEISM) (version == 1) ? aviowb64(pb, UINT64C(0xffffffffffffffff)) : aviowb32(pb, 0xffffffff); else if (!track->entry) (version == 1) ? aviowb64(pb, 0) : aviowb32(pb, 0); else (version == 1) ? aviowb64(pb, duration) : aviowb32(pb, duration); aviowb32(pb, 0); /* reserved */ aviowb32(pb, 0); /* reserved */ aviowb16(pb, 0); /* layer */ aviowb16(pb, group); /* alternate group) */ /* Volume, only for audio */ if (track->par->codectype == AVMEDIATYPEAUDIO) aviowb16(pb, 0x0100); else aviowb16(pb, 0); aviowb16(pb, 0); /* reserved */ /* Matrix structure */ if (st && st->metadata) { AVDictionaryEntry *rot = avdictget(st->metadata, \"rotate\", NULL, 0); rotation = (rot && rot->value) ? atoi(rot->value) : 0; } if (displaymatrix) { for (i = 0; i < 9; i++) aviowb32(pb, displaymatrix[i]); } else if (rotation == 90) { writematrix(pb, 0, 1, -1, 0, track->par->height, 0); } else if (rotation == 180) { writematrix(pb, -1, 0, 0, -1, track->par->width, track->par->height); } else if (rotation == 270) { writematrix(pb, 0, -1, 1, 0, 0, track->par->width); } else { writematrix(pb, 1, 0, 0, 1, 0, 0); } /* Track width and height, for visual only */ if (st && (track->par->codectype == AVMEDIATYPEVIDEO || track->par->codectype == AVMEDIATYPESUBTITLE)) { int64t trackwidth1616; if (track->mode == MODEMOV) { trackwidth1616 = track->par->width * 0x10000ULL; } else { trackwidth1616 = avrescale(st->sampleaspectratio.num, track->par->width * 0x10000LL, st->sampleaspectratio.den); if (!trackwidth1616 || track->height != track->par->height || trackwidth1616 > UINT32MAX) trackwidth1616 = track->par->width * 0x10000ULL; } if (trackwidth1616 > UINT32MAX) { avlog(mov->fc, AVLOGWARNING, \"track width is too large\\n\"); trackwidth1616 = 0; } aviowb32(pb, trackwidth1616); if (track->height > 0xFFFF) { avlog(mov->fc, AVLOGWARNING, \"track height is too large\\n\"); aviowb32(pb, 0); } else aviowb32(pb, track->height * 0x10000U); } else { aviowb32(pb, 0); aviowb32(pb, 0); } return 0x5c; }", "target": 1}
{"func": "static int vobsubreadseek(AVFormatContext *s, int streamindex, int64t mints, int64t ts, int64t maxts, int flags) { MpegDemuxContext *vobsub = s->privdata; /* Rescale requested timestamps based on the first stream (timebase is the * same for all subtitles stream within a .idx/.sub). Rescaling is done just * like in avformatseekfile(). */ if (streamindex == -1 && s->nbstreams != 1) { int i, ret = 0; AVRational timebase = s->streams[0]->timebase; ts = avrescaleq(ts, AVTIMEBASEQ, timebase); mints = avrescalernd(mints, timebase.den, timebase.num * (int64t)AVTIMEBASE, AVROUNDUP | AVROUNDPASSMINMAX); maxts = avrescalernd(maxts, timebase.den, timebase.num * (int64t)AVTIMEBASE, AVROUNDDOWN | AVROUNDPASSMINMAX); for (i = 0; i < s->nbstreams; i++) { int r = ffsubtitlesqueueseek(&vobsub->q[i], s, streamindex, mints, ts, maxts, flags); if (r < 0) ret = r; } return ret; } return ffsubtitlesqueueseek(&vobsub->q[streamindex], s, streamindex, mints, ts, maxts, flags); }", "target": 1}
{"func": "static avcold int aacencodeinit(AVCodecContext *avctx) { AACContext *s = avctx->privdata; int ret = AVERROR(EINVAL); AACENCInfoStruct info = { 0 }; CHANNELMODE mode; AACENCERROR err; int aot = FFPROFILEAACLOW + 1; int sce = 0, cpe = 0; if ((err = aacEncOpen(&s->handle, 0, avctx->channels)) != AACENCOK) { avlog(avctx, AVLOGERROR, \"Unable to open the encoder: %s\\n\", aacgeterror(err)); goto error; } if (avctx->profile != FFPROFILEUNKNOWN) aot = avctx->profile + 1; if ((err = aacEncoderSetParam(s->handle, AACENCAOT, aot)) != AACENCOK) { avlog(avctx, AVLOGERROR, \"Unable to set the AOT %d: %s\\n\", aot, aacgeterror(err)); goto error; } if (aot == FFPROFILEAACELD + 1 && s->eldsbr) { if ((err = aacEncoderSetParam(s->handle, AACENCSBRMODE, 1)) != AACENCOK) { avlog(avctx, AVLOGERROR, \"Unable to enable SBR for ELD: %s\\n\", aacgeterror(err)); goto error; } } if ((err = aacEncoderSetParam(s->handle, AACENCSAMPLERATE, avctx->samplerate)) != AACENCOK) { avlog(avctx, AVLOGERROR, \"Unable to set the sample rate %d: %s\\n\", avctx->samplerate, aacgeterror(err)); goto error; } switch (avctx->channels) { case 1: mode = MODE1; sce = 1; cpe = 0; break; case 2: mode = MODE2; sce = 0; cpe = 1; break; case 3: mode = MODE12; sce = 1; cpe = 1; break; case 4: mode = MODE121; sce = 2; cpe = 1; break; case 5: mode = MODE122; sce = 1; cpe = 2; break; case 6: mode = MODE1221; sce = 2; cpe = 2; break; default: avlog(avctx, AVLOGERROR, \"Unsupported number of channels %d\\n\", avctx->channels); goto error; } if ((err = aacEncoderSetParam(s->handle, AACENCCHANNELMODE, mode)) != AACENCOK) { avlog(avctx, AVLOGERROR, \"Unable to set channel mode %d: %s\\n\", mode, aacgeterror(err)); goto error; } if ((err = aacEncoderSetParam(s->handle, AACENCCHANNELORDER, 1)) != AACENCOK) { avlog(avctx, AVLOGERROR, \"Unable to set wav channel order %d: %s\\n\", mode, aacgeterror(err)); goto error; } if (avctx->flags & CODECFLAGQSCALE || s->vbr) { int mode = s->vbr ? s->vbr : avctx->globalquality; if (mode < 1 || mode > 5) { avlog(avctx, AVLOGWARNING, \"VBR quality %d out of range, should be 1-5\\n\", mode); mode = avclip(mode, 1, 5); } avlog(avctx, AVLOGWARNING, \"Note, the VBR setting is unsupported and only works with \" \"some parameter combinations\\n\"); if ((err = aacEncoderSetParam(s->handle, AACENCBITRATEMODE, mode)) != AACENCOK) { avlog(avctx, AVLOGERROR, \"Unable to set the VBR bitrate mode %d: %s\\n\", mode, aacgeterror(err)); goto error; } } else { if (avctx->bitrate <= 0) { if (avctx->profile == FFPROFILEAACHEV2) { sce = 1; cpe = 0; } avctx->bitrate = (96*sce + 128*cpe) * avctx->samplerate / 44; if (avctx->profile == FFPROFILEAACHE || avctx->profile == FFPROFILEAACHEV2 || s->eldsbr) avctx->bitrate /= 2; } if ((err = aacEncoderSetParam(s->handle, AACENCBITRATE, avctx->bitrate)) != AACENCOK) { avlog(avctx, AVLOGERROR, \"Unable to set the bitrate %d: %s\\n\", avctx->bitrate, aacgeterror(err)); goto error; } } /* Choose bitstream format - if global header is requested, use * raw access units, otherwise use ADTS. */ if ((err = aacEncoderSetParam(s->handle, AACENCTRANSMUX, avctx->flags & CODECFLAGGLOBALHEADER ? 0 : s->latm ? 10 : 2)) != AACENCOK) { avlog(avctx, AVLOGERROR, \"Unable to set the transmux format: %s\\n\", aacgeterror(err)); goto error; } if (s->latm && s->headerperiod) { if ((err = aacEncoderSetParam(s->handle, AACENCHEADERPERIOD, s->headerperiod)) != AACENCOK) { avlog(avctx, AVLOGERROR, \"Unable to set header period: %s\\n\", aacgeterror(err)); goto error; } } /* If no signaling mode is chosen, use explicit hierarchical signaling * if using mp4 mode (raw access units, with global header) and * implicit signaling if using ADTS. */ if (s->signaling < 0) s->signaling = avctx->flags & CODECFLAGGLOBALHEADER ? 2 : 0; if ((err = aacEncoderSetParam(s->handle, AACENCSIGNALINGMODE, s->signaling)) != AACENCOK) { avlog(avctx, AVLOGERROR, \"Unable to set signaling mode %d: %s\\n\", s->signaling, aacgeterror(err)); goto error; } if ((err = aacEncoderSetParam(s->handle, AACENCAFTERBURNER, s->afterburner)) != AACENCOK) { avlog(avctx, AVLOGERROR, \"Unable to set afterburner to %d: %s\\n\", s->afterburner, aacgeterror(err)); goto error; } if (avctx->cutoff > 0) { if (avctx->cutoff < (avctx->samplerate + 255) >> 8) { avlog(avctx, AVLOGERROR, \"cutoff valid range is %d-20000\\n\", (avctx->samplerate + 255) >> 8); goto error; } if ((err = aacEncoderSetParam(s->handle, AACENCBANDWIDTH, avctx->cutoff)) != AACENCOK) { avlog(avctx, AVLOGERROR, \"Unable to set the encoder bandwidth to %d: %s\\n\", avctx->cutoff, aacgeterror(err)); goto error; } } if ((err = aacEncEncode(s->handle, NULL, NULL, NULL, NULL)) != AACENCOK) { avlog(avctx, AVLOGERROR, \"Unable to initialize the encoder: %s\\n\", aacgeterror(err)); return AVERROR(EINVAL); } if ((err = aacEncInfo(s->handle, &info)) != AACENCOK) { avlog(avctx, AVLOGERROR, \"Unable to get encoder info: %s\\n\", aacgeterror(err)); goto error; } #if FFAPIOLDENCODEAUDIO avctx->codedframe = avcodecallocframe(); if (!avctx->codedframe) { ret = AVERROR(ENOMEM); goto error; } #endif avctx->framesize = info.frameLength; avctx->delay = info.encoderDelay; ffafqueueinit(avctx, &s->afq); if (avctx->flags & CODECFLAGGLOBALHEADER) { avctx->extradatasize = info.confSize; avctx->extradata = avmallocz(avctx->extradatasize + FFINPUTBUFFERPADDINGSIZE); if (!avctx->extradata) { ret = AVERROR(ENOMEM); goto error; } memcpy(avctx->extradata, info.confBuf, info.confSize); } return 0; error: aacencodeclose(avctx); return ret; } ", "target": 0}
{"func": "static int vorbisfloor1decode(vorbiscontext *vc, vorbisfloordata *vfu, float *vec) { vorbisfloor1 *vf = &vfu->t1; GetBitContext *gb = &vc->gb; uint16t rangev[4] = { 256, 128, 86, 64 }; unsigned range = rangev[vf->multiplier - 1]; uint16t floor1Y[258]; uint16t floor1Yfinal[258]; int floor1flag[258]; unsigned class, cdim, cbits, csub, cval, offset, i, j; int book, adx, ady, dy, off, predicted, err; if (!getbits1(gb)) // silence return 1; // Read values (or differences) for the floor's points floor1Y[0] = getbits(gb, ilog(range - 1)); floor1Y[1] = getbits(gb, ilog(range - 1)); avdlog(NULL, \"floor 0 Y %d floor 1 Y %d \\n\", floor1Y[0], floor1Y[1]); offset = 2; for (i = 0; i < vf->partitions; ++i) { class = vf->partitionclass[i]; cdim = vf->classdimensions[class]; cbits = vf->classsubclasses[class]; csub = (1 << cbits) - 1; cval = 0; avdlog(NULL, \"Cbits %u\\n\", cbits); if (cbits) // this reads all subclasses for this partition's class cval = getvlc2(gb, vc->codebooks[vf->classmasterbook[class]].vlc.table, vc->codebooks[vf->classmasterbook[class]].nbbits, 3); for (j = 0; j < cdim; ++j) { book = vf->subclassbooks[class][cval & csub]; avdlog(NULL, \"book %d Cbits %u cval %u bits:%d\\n\", book, cbits, cval, getbitscount(gb)); cval = cval >> cbits; if (book > -1) { floor1Y[offset+j] = getvlc2(gb, vc->codebooks[book].vlc.table, vc->codebooks[book].nbbits, 3); } else { floor1Y[offset+j] = 0; } avdlog(NULL, \" floor(%d) = %d \\n\", vf->list[offset+j].x, floor1Y[offset+j]); } offset+=cdim; } // Amplitude calculation from the differences floor1flag[0] = 1; floor1flag[1] = 1; floor1Yfinal[0] = floor1Y[0]; floor1Yfinal[1] = floor1Y[1]; for (i = 2; i < vf->xlistdim; ++i) { unsigned val, highroom, lowroom, room, highneighoffs, lowneighoffs; lowneighoffs = vf->list[i].low; highneighoffs = vf->list[i].high; dy = floor1Yfinal[highneighoffs] - floor1Yfinal[lowneighoffs]; // renderpoint begin adx = vf->list[highneighoffs].x - vf->list[lowneighoffs].x; ady = FFABS(dy); err = ady * (vf->list[i].x - vf->list[lowneighoffs].x); off = err / adx; if (dy < 0) { predicted = floor1Yfinal[lowneighoffs] - off; } else { predicted = floor1Yfinal[lowneighoffs] + off; } // renderpoint end val = floor1Y[i]; highroom = range-predicted; lowroom = predicted; if (highroom < lowroom) { room = highroom * 2; } else { room = lowroom * 2; // SPEC mispelling } if (val) { floor1flag[lowneighoffs] = 1; floor1flag[highneighoffs] = 1; floor1flag[i] = 1; if (val >= room) { if (highroom > lowroom) { floor1Yfinal[i] = val - lowroom + predicted; } else { floor1Yfinal[i] = predicted - val + highroom - 1; } } else { if (val & 1) { floor1Yfinal[i] = predicted - (val + 1) / 2; } else { floor1Yfinal[i] = predicted + val / 2; } } } else { floor1flag[i] = 0; floor1Yfinal[i] = predicted; } avdlog(NULL, \" Decoded floor(%d) = %u / val %u\\n\", vf->list[i].x, floor1Yfinal[i], val); } // Curve synth - connect the calculated dots and convert from dB scale FIXME optimize ? ffvorbisfloor1renderlist(vf->list, vf->xlistdim, floor1Yfinal, floor1flag, vf->multiplier, vec, vf->list[1].x); avdlog(NULL, \" Floor decoded\\n\"); return 0; } ", "target": 1}
{"func": "static void coloprocesscheckpoint(MigrationState *s) { QIOChannelBuffer *bioc; QEMUFile *fb = NULL; int64t currenttime, checkpointtime = qemuclockgetms(QEMUCLOCKHOST); Error *localerr = NULL; int ret; failoverinitstate(); s->rpstate.fromdstfile = qemufilegetreturnpath(s->todstfile); if (!s->rpstate.fromdstfile) { errorreport(\"Open QEMUFile fromdstfile failed\"); /* * Wait for Secondary finish loading VM states and enter COLO * restore. */ coloreceivecheckmessage(s->rpstate.fromdstfile, COLOMESSAGECHECKPOINTREADY, &localerr); if (localerr) { bioc = qiochannelbuffernew(COLOBUFFERBASESIZE); fb = qemufopenchanneloutput(QIOCHANNEL(bioc)); objectunref(OBJECT(bioc)); qemumutexlockiothread(); vmstart(); qemumutexunlockiothread(); tracecolovmstatechange(\"stop\", \"run\"); while (s->state == MIGRATIONSTATUSCOLO) { currenttime = qemuclockgetms(QEMUCLOCKHOST); if (currenttime - checkpointtime < s->parameters.xcheckpointdelay) { int64t delayms; delayms = s->parameters.xcheckpointdelay - (currenttime - checkpointtime); gusleep(delayms * 1000); ret = colodocheckpointtransaction(s, bioc, fb); if (ret < 0) { checkpointtime = qemuclockgetms(QEMUCLOCKHOST); out: /* Throw the unreported error message after exited from loop */ if (localerr) { errorreporterr(localerr); if (fb) { qemufclose(fb); if (s->rpstate.fromdstfile) { qemufclose(s->rpstate.fromdstfile);", "target": 1}
{"func": "static void pcinit1(QEMUMachineInitArgs *args, int pcienabled, int kvmclockenabled) { MemoryRegion *systemmemory = getsystemmemory(); MemoryRegion *systemio = getsystemio(); int i; ramaddrt below4gmemsize, above4gmemsize; PCIBus *pcibus; ISABus *isabus; PCII440FXState *i440fxstate; int piix3devfn = -1; qemuirq *cpuirq; qemuirq *gsi; qemuirq *i8259; qemuirq *smiirq; GSIState *gsistate; DriveInfo *hd[MAXIDEBUS * MAXIDEDEVS]; BusState *idebus[MAXIDEBUS]; ISADevice *rtcstate; ISADevice *floppy; MemoryRegion *rammemory; MemoryRegion *pcimemory; MemoryRegion *rommemory; DeviceState *iccbridge; FWCfgState *fwcfg = NULL; PcGuestInfo *guestinfo; if (xenenabled() && xenhvminit(&rammemory) != 0) { fprintf(stderr, \"xen hardware virtual machine initialisation failed\\n\"); exit(1); } iccbridge = qdevcreate(NULL, TYPEICCBRIDGE); objectpropertyaddchild(qdevgetmachine(), \"icc-bridge\", OBJECT(iccbridge), NULL); pccpusinit(args->cpumodel, iccbridge); if (kvmenabled() && kvmclockenabled) { kvmclockcreate(); } /* Check whether RAM fits below 4G (leaving 1/2 GByte for IO memory). * If it doesn't, we need to split it in chunks below and above 4G. * In any case, try to make sure that guest addresses aligned at * 1G boundaries get mapped to host addresses aligned at 1G boundaries. * For old machine types, use whatever split we used historically to avoid * breaking migration. */ if (args->ramsize >= 0xe0000000) { ramaddrt lowmem = gigabytealign ? 0xc0000000 : 0xe0000000; above4gmemsize = args->ramsize - lowmem; below4gmemsize = lowmem; } else { above4gmemsize = 0; below4gmemsize = args->ramsize; } if (pcienabled) { pcimemory = gnew(MemoryRegion, 1); memoryregioninit(pcimemory, NULL, \"pci\", UINT64MAX); rommemory = pcimemory; } else { pcimemory = NULL; rommemory = systemmemory; } guestinfo = pcguestinfoinit(below4gmemsize, above4gmemsize); guestinfo->hasacpibuild = hasacpibuild; guestinfo->haspciinfo = haspciinfo; guestinfo->isapcramfw = !pcienabled; if (smbiosdefaults) { /* These values are guest ABI, do not change */ smbiossetdefaults(\"QEMU\", \"Standard PC (i440FX + PIIX, 1996)\", args->machine->name); } /* allocate ram and load rom/bios */ if (!xenenabled()) { fwcfg = pcmemoryinit(systemmemory, args->kernelfilename, args->kernelcmdline, args->initrdfilename, below4gmemsize, above4gmemsize, rommemory, &rammemory, guestinfo); } gsistate = gmalloc0(sizeof(*gsistate)); if (kvmirqchipinkernel()) { kvmpcsetupirqrouting(pcienabled); gsi = qemuallocateirqs(kvmpcgsihandler, gsistate, GSINUMPINS); } else { gsi = qemuallocateirqs(gsihandler, gsistate, GSINUMPINS); } if (pcienabled) { pcibus = i440fxinit(&i440fxstate, &piix3devfn, &isabus, gsi, systemmemory, systemio, args->ramsize, below4gmemsize, above4gmemsize, pcimemory, rammemory); } else { pcibus = NULL; i440fxstate = NULL; isabus = isabusnew(NULL, systemio); nohpet = 1; } isabusirqs(isabus, gsi); if (kvmirqchipinkernel()) { i8259 = kvmi8259init(isabus); } else if (xenenabled()) { i8259 = xeninterruptcontrollerinit(); } else { cpuirq = pcallocatecpuirq(); i8259 = i8259init(isabus, cpuirq[0]); } for (i = 0; i < ISANUMIRQS; i++) { gsistate->i8259irq[i] = i8259[i]; } if (pcienabled) { ioapicinitgsi(gsistate, \"i440fx\"); } qdevinitnofail(iccbridge); pcregisterferrirq(gsi[13]); pcvgainit(isabus, pcienabled ? pcibus : NULL); /* init basic PC hardware */ pcbasicdeviceinit(isabus, gsi, &rtcstate, &floppy, xenenabled(), 0x4); pcnicinit(isabus, pcibus); idedriveget(hd, MAXIDEBUS); if (pcienabled) { PCIDevice *dev; if (xenenabled()) { dev = pcipiix3xenideinit(pcibus, hd, piix3devfn + 1); } else { dev = pcipiix3ideinit(pcibus, hd, piix3devfn + 1); } idebus[0] = qdevgetchildbus(&dev->qdev, \"ide.0\"); idebus[1] = qdevgetchildbus(&dev->qdev, \"ide.1\"); } else { for(i = 0; i < MAXIDEBUS; i++) { ISADevice *dev; char busname[] = \"ide.0\"; dev = isaideinit(isabus, ideiobase[i], ideiobase2[i], ideirq[i], hd[MAXIDEDEVS * i], hd[MAXIDEDEVS * i + 1]); /* * The ide bus name is ide.0 for the first bus and ide.1 for the * second one. */ busname[4] = '0' + i; idebus[i] = qdevgetchildbus(DEVICE(dev), busname); } } pccmosinit(below4gmemsize, above4gmemsize, args->bootorder, floppy, idebus[0], idebus[1], rtcstate); if (pcienabled && usbenabled(false)) { pcicreatesimple(pcibus, piix3devfn + 2, \"piix3-usb-uhci\"); } if (pcienabled && acpienabled) { I2CBus *smbus; smiirq = qemuallocateirqs(pcacpismiinterrupt, firstcpu, 1); /* TODO: Populate SPD eeprom data. */ smbus = piix4pminit(pcibus, piix3devfn + 3, 0xb100, gsi[9], *smiirq, kvmenabled(), fwcfg); smbuseeprominit(smbus, 8, NULL, 0); } if (pcienabled) { pcpcideviceinit(pcibus); } } ", "target": 0}
{"func": "uint32t wm8750adcdat(void *opaque) { WM8750State *s = (WM8750State *) opaque; uint32t *data; if (s->idxin >= sizeof(s->datain)) wm8750inload(s); data = (uint32t *) &s->datain[s->idxin]; s->reqin -= 4; s->idxin += 4; return *data; } ", "target": 0}
{"func": "static QmpInputVisitor *toqiv(Visitor *v) { return containerof(v, QmpInputVisitor, visitor); } ", "target": 0}
{"func": "static int v4l2readpacket(AVFormatContext *s1, AVPacket *pkt) { #if FFAPICODEDFRAME FFDISABLEDEPRECATIONWARNINGS struct videodata *s = s1->privdata; AVFrame *frame = s1->streams[0]->codec->codedframe; FFENABLEDEPRECATIONWARNINGS #endif int res; avinitpacket(pkt); if ((res = mmapreadframe(s1, pkt)) < 0) { return res; } #if FFAPICODEDFRAME FFDISABLEDEPRECATIONWARNINGS if (frame && s->interlaced) { frame->interlacedframe = 1; frame->topfieldfirst = s->topfieldfirst; } FFENABLEDEPRECATIONWARNINGS #endif return pkt->size; } ", "target": 0}
{"func": "static void bonitopcihostclassinit(ObjectClass *klass, void *data) { DeviceClass *dc = DEVICECLASS(klass); SysBusDeviceClass *k = SYSBUSDEVICECLASS(klass); k->init = bonitopcihostinitfn; dc->nouser = 1; } ", "target": 1}
{"func": "static int mp3parsevbrtags(AVFormatContext *s, AVStream *st, int64t base) { uint32t v, spf; MPADecodeHeader c; int vbrtagsize = 0; MP3DecContext *mp3 = s->privdata; ffioinitchecksum(s->pb, ffcrcA001update, 0); v = aviorb32(s->pb); if(ffmpacheckheader(v) < 0) return -1; if (avprivmpegaudiodecodeheader(&c, v) == 0) vbrtagsize = c.framesize; if(c.layer != 3) return -1; spf = c.lsf ? 576 : 1152; /* Samples per frame, layer 3 */ mp3->frames = 0; mp3->size = 0; mp3parseinfotag(s, st, &c, spf); mp3parsevbritag(s, st, base); if (!mp3->frames && !mp3->size) return -1; /* Skip the vbr tag frame */ avioseek(s->pb, base + vbrtagsize, SEEKSET); if (mp3->frames) st->duration = avrescaleq(mp3->frames, (AVRational){spf, c.samplerate}, st->timebase); if (mp3->size && mp3->frames && !mp3->iscbr) st->codec->bitrate = avrescale(mp3->size, 8 * c.samplerate, mp3->frames * (int64t)spf); return 0; } ", "target": 0}
{"func": "void memoryregioniommureplayall(MemoryRegion *mr) { IOMMUNotifier *notifier; IOMMUNOTIFIERFOREACH(notifier, mr) { memoryregioniommureplay(mr, notifier, false); } } ", "target": 0}
{"func": "static int usbuhcipiix3initfn(PCIDevice *dev) { UHCIState *s = DOUPCAST(UHCIState, dev, dev); uint8t *pciconf = s->dev.config; pciconfigsetvendorid(pciconf, PCIVENDORIDINTEL); pciconfigsetdeviceid(pciconf, PCIDEVICEIDINTEL82371SB2); return usbuhcicommoninitfn(s); } ", "target": 0}
{"func": "static void mpegtswritepmt(AVFormatContext *s, MpegTSService *service) { MpegTSWrite *ts = s->privdata; uint8t data[1012], *q, *desclengthptr, *programinfolengthptr; int val, streamtype, i; q = data; put16(&q, 0xe000 | service->pcrpid); programinfolengthptr = q; q += 2; /* patched after */ /* put program info here */ val = 0xf000 | (q - programinfolengthptr - 2); programinfolengthptr[0] = val >> 8; programinfolengthptr[1] = val; for(i = 0; i < s->nbstreams; i++) { AVStream *st = s->streams[i]; MpegTSWriteStream *tsst = st->privdata; AVDictionaryEntry *lang = avdictget(st->metadata, \"language\", NULL,0); switch(st->codec->codecid) { case AVCODECIDMPEG1VIDEO: case AVCODECIDMPEG2VIDEO: streamtype = STREAMTYPEVIDEOMPEG2; break; case AVCODECIDMPEG4: streamtype = STREAMTYPEVIDEOMPEG4; break; case AVCODECIDH264: streamtype = STREAMTYPEVIDEOH264; break; case AVCODECIDCAVS: streamtype = STREAMTYPEVIDEOCAVS; break; case AVCODECIDDIRAC: streamtype = STREAMTYPEVIDEODIRAC; break; case AVCODECIDMP2: case AVCODECIDMP3: streamtype = STREAMTYPEAUDIOMPEG1; break; case AVCODECIDAAC: streamtype = (ts->flags & MPEGTSFLAGAACLATM) ? STREAMTYPEAUDIOAACLATM : STREAMTYPEAUDIOAAC; break; case AVCODECIDAACLATM: streamtype = STREAMTYPEAUDIOAACLATM; break; case AVCODECIDAC3: streamtype = STREAMTYPEAUDIOAC3; break; default: streamtype = STREAMTYPEPRIVATEDATA; break; } *q++ = streamtype; put16(&q, 0xe000 | tsst->pid); desclengthptr = q; q += 2; /* patched after */ /* write optional descriptors here */ switch(st->codec->codectype) { case AVMEDIATYPEAUDIO: if(st->codec->codecid==AVCODECIDEAC3){ *q++=0x7a; // EAC3 descriptor see A038 DVB SI *q++=1; // 1 byte, all flags sets to 0 *q++=0; // omit all fields... } if(st->codec->codecid==AVCODECIDS302M){ *q++ = 0x05; /* MPEG-2 registration descriptor*/ *q++ = 4; *q++ = 'B'; *q++ = 'S'; *q++ = 'S'; *q++ = 'D'; } if (lang) { char *p; char *next = lang->value; uint8t *lenptr; *q++ = 0x0a; /* ISO 639 language descriptor */ lenptr = q++; *lenptr = 0; for (p = lang->value; next && *lenptr < 255 / 4 * 4; p = next + 1) { next = strchr(p, ','); if (strlen(p) != 3 && (!next || next != p + 3)) continue; /* not a 3-letter code */ *q++ = *p++; *q++ = *p++; *q++ = *p++; if (st->disposition & AVDISPOSITIONCLEANEFFECTS) *q++ = 0x01; else if (st->disposition & AVDISPOSITIONHEARINGIMPAIRED) *q++ = 0x02; else if (st->disposition & AVDISPOSITIONVISUALIMPAIRED) *q++ = 0x03; else *q++ = 0; /* undefined type */ *lenptr += 4; } if (*lenptr == 0) q -= 2; /* no language codes were written */ } break; case AVMEDIATYPESUBTITLE: { const char defaultlanguage[] = \"und\"; const char *language = lang && strlen(lang->value) >= 3 ? lang->value : defaultlanguage; if (st->codec->codecid == AVCODECIDDVBSUBTITLE) { uint8t *lenptr; int extradatacopied = 0; *q++ = 0x59; /* subtitlingdescriptor */ lenptr = q++; while (strlen(language) >= 3 && (sizeof(data) - (q - data)) >= 8) { /* 8 bytes per DVB subtitle substream data */ *q++ = *language++; *q++ = *language++; *q++ = *language++; /* Skip comma */ if (*language != '\\0') language++; if (st->codec->extradatasize - extradatacopied >= 5) { *q++ = st->codec->extradata[extradatacopied + 4]; /* subtitlingtype */ memcpy(q, st->codec->extradata + extradatacopied, 4); /* compositionpageid and ancillarypageid */ extradatacopied += 5; q += 4; } else { /* subtitlingtype: * 0x10 - normal with no monitor aspect ratio criticality * 0x20 - for the hard of hearing with no monitor aspect ratio criticality */ *q++ = (st->disposition & AVDISPOSITIONHEARINGIMPAIRED) ? 0x20 : 0x10; if ((st->codec->extradatasize == 4) && (extradatacopied == 0)) { /* support of old 4-byte extradata format */ memcpy(q, st->codec->extradata, 4); /* compositionpageid and ancillarypageid */ extradatacopied += 4; q += 4; } else { put16(&q, 1); /* compositionpageid */ put16(&q, 1); /* ancillarypageid */ } } } *lenptr = q - lenptr - 1; } else if (st->codec->codecid == AVCODECIDDVBTELETEXT) { uint8t *lenptr = NULL; int extradatacopied = 0; /* The descriptor tag. teletextdescriptor */ *q++ = 0x56; lenptr = q++; while (strlen(language) >= 3) { *q++ = *language++; *q++ = *language++; *q++ = *language++; /* Skip comma */ if (*language != '\\0') language++; if (st->codec->extradatasize - 1 > extradatacopied) { memcpy(q, st->codec->extradata + extradatacopied, 2); extradatacopied += 2; q += 2; } else { /* The Teletext descriptor: * teletexttype: This 5-bit field indicates the type of Teletext page indicated. (0x01 Initial Teletext page) * teletextmagazinenumber: This is a 3-bit field which identifies the magazine number. * teletextpagenumber: This is an 8-bit field giving two 4-bit hex digits identifying the page number. */ *q++ = 0x08; *q++ = 0x00; } } *lenptr = q - lenptr - 1; } } break; case AVMEDIATYPEVIDEO: if (streamtype == STREAMTYPEVIDEODIRAC) { *q++ = 0x05; /*MPEG-2 registration descriptor*/ *q++ = 4; *q++ = 'd'; *q++ = 'r'; *q++ = 'a'; *q++ = 'c'; } break; case AVMEDIATYPEDATA: if (st->codec->codecid == AVCODECIDSMPTEKLV) { *q++ = 0x05; /* MPEG-2 registration descriptor */ *q++ = 4; *q++ = 'K'; *q++ = 'L'; *q++ = 'V'; *q++ = 'A'; } break; } val = 0xf000 | (q - desclengthptr - 2); desclengthptr[0] = val >> 8; desclengthptr[1] = val; } mpegtswritesection1(&service->pmt, PMTTID, service->sid, ts->tablesversion, 0, 0, data, q - data); } ", "target": 0}
{"func": "static unsigned int decaddir(DisasContext *dc) { \tTCGv t0; \tDIS(fprintf (logfile, \"addi.%c $r%u, $r%u\\n\", \t\t memsizechar(memsizezz(dc)), dc->op2, dc->op1)); \tcrisccmask(dc, 0); \tt0 = tcgtempnew(TCGTYPETL); \ttcggenshltl(t0, cpuR[dc->op2], tcgconsttl(dc->zzsize)); \ttcggenaddtl(cpuR[dc->op1], cpuR[dc->op1], t0); \ttcgtempfree(t0); \treturn 2; } ", "target": 0}
{"func": "static void gentrap (DisasContext *ctx, uint32t opc, int rs, int rt, int16t imm) { int cond; TCGv t0 = tcgtempnew(); TCGv t1 = tcgtempnew(); cond = 0; /* Load needed operands */ switch (opc) { case OPCTEQ: case OPCTGE: case OPCTGEU: case OPCTLT: case OPCTLTU: case OPCTNE: /* Compare two registers */ if (rs != rt) { genloadgpr(t0, rs); genloadgpr(t1, rt); cond = 1; } break; case OPCTEQI: case OPCTGEI: case OPCTGEIU: case OPCTLTI: case OPCTLTIU: case OPCTNEI: /* Compare register to immediate */ if (rs != 0 || imm != 0) { genloadgpr(t0, rs); tcggenmovitl(t1, (int32t)imm); cond = 1; } break; } if (cond == 0) { switch (opc) { case OPCTEQ: /* rs == rs */ case OPCTEQI: /* r0 == 0 */ case OPCTGE: /* rs >= rs */ case OPCTGEI: /* r0 >= 0 */ case OPCTGEU: /* rs >= rs unsigned */ case OPCTGEIU: /* r0 >= 0 unsigned */ /* Always trap */ generateexception(ctx, EXCPTRAP); break; case OPCTLT: /* rs < rs */ case OPCTLTI: /* r0 < 0 */ case OPCTLTU: /* rs < rs unsigned */ case OPCTLTIU: /* r0 < 0 unsigned */ case OPCTNE: /* rs != rs */ case OPCTNEI: /* r0 != 0 */ /* Never trap: treat as NOP. */ break; } } else { int l1 = gennewlabel(); switch (opc) { case OPCTEQ: case OPCTEQI: tcggenbrcondtl(TCGCONDNE, t0, t1, l1); break; case OPCTGE: case OPCTGEI: tcggenbrcondtl(TCGCONDLT, t0, t1, l1); break; case OPCTGEU: case OPCTGEIU: tcggenbrcondtl(TCGCONDLTU, t0, t1, l1); break; case OPCTLT: case OPCTLTI: tcggenbrcondtl(TCGCONDGE, t0, t1, l1); break; case OPCTLTU: case OPCTLTIU: tcggenbrcondtl(TCGCONDGEU, t0, t1, l1); break; case OPCTNE: case OPCTNEI: tcggenbrcondtl(TCGCONDEQ, t0, t1, l1); break; } generateexception(ctx, EXCPTRAP); gensetlabel(l1); } tcgtempfree(t0); tcgtempfree(t1); } ", "target": 0}
{"func": "static uint64t pxa2xxgpioread(void *opaque, hwaddr offset, unsigned size) { PXA2xxGPIOInfo *s = (PXA2xxGPIOInfo *) opaque; uint32t ret; int bank; if (offset >= 0x200) return 0; bank = pxa2xxgpioregs[offset].bank; switch (pxa2xxgpioregs[offset].reg) { case GPDR:\t\t/* GPIO Pin-Direction registers */ return s->dir[bank]; case GPSR:\t\t/* GPIO Pin-Output Set registers */ qemulogmask(LOGGUESTERROR, \"pxa2xx GPIO: read from write only register GPSR\\n\"); return 0; case GPCR:\t\t/* GPIO Pin-Output Clear registers */ qemulogmask(LOGGUESTERROR, \"pxa2xx GPIO: read from write only register GPCR\\n\"); return 0; case GRER:\t\t/* GPIO Rising-Edge Detect Enable registers */ return s->rising[bank]; case GFER:\t\t/* GPIO Falling-Edge Detect Enable registers */ return s->falling[bank]; case GAFRL:\t/* GPIO Alternate Function registers */ return s->gafr[bank * 2]; case GAFRU:\t/* GPIO Alternate Function registers */ return s->gafr[bank * 2 + 1]; case GPLR:\t\t/* GPIO Pin-Level registers */ ret = (s->olevel[bank] & s->dir[bank]) | (s->ilevel[bank] & ~s->dir[bank]); qemuirqraise(s->readnotify); return ret; case GEDR:\t\t/* GPIO Edge Detect Status registers */ return s->status[bank]; default: hwerror(\"%s: Bad offset \" REGFMT \"\\n\", FUNCTION, offset); } return 0; } ", "target": 0}
{"func": "static int ipvideodecodeblockopcode0xD(IpvideoContext *s, AVFrame *frame) { int y; unsigned char P[2]; /* 4-color block encoding: each 4x4 block is a different color */ for (y = 0; y < 8; y++) { if (!(y & 3)) { P[0] = bytestream2getbyte(&s->streamptr); P[1] = bytestream2getbyte(&s->streamptr); memset(s->pixelptr, P[0], 4); memset(s->pixelptr + 4, P[1], 4); s->pixelptr += s->stride; /* report success */ return 0;", "target": 1}
{"func": "static int64t migrationsetratelimit(void *opaque, int64t newrate) { MigrationState *s = opaque; if (qemufilegeterror(s->file)) { goto out; } s->xferlimit = newrate; out: return s->xferlimit; } ", "target": 0}
{"func": "static void reversematrixing(float *su1, float *su2, int *prevcode, int *currcode) { int i, nsample, band; float mc1l, mc1r, mc2l, mc2r; for (i = 0, band = 0; band < 4 * 256; band += 256, i++) { int s1 = prevcode[i]; int s2 = currcode[i]; nsample = 0; if (s1 != s2) { /* Selector value changed, interpolation needed. */ mc1l = matrixcoeffs[s1 * 2 ]; mc1r = matrixcoeffs[s1 * 2 + 1]; mc2l = matrixcoeffs[s2 * 2 ]; mc2r = matrixcoeffs[s2 * 2 + 1]; /* Interpolation is done over the first eight samples. */ for (; nsample < 8; nsample++) { float c1 = su1[band + nsample]; float c2 = su2[band + nsample]; c2 = c1 * INTERPOLATE(mc1l, mc2l, nsample) + c2 * INTERPOLATE(mc1r, mc2r, nsample); su1[band + nsample] = c2; su2[band + nsample] = c1 * 2.0 - c2; } } /* Apply the matrix without interpolation. */ switch (s2) { case 0: /* M/S decoding */ for (; nsample < 256; nsample++) { float c1 = su1[band + nsample]; float c2 = su2[band + nsample]; su1[band + nsample] = c2 * 2.0; su2[band + nsample] = (c1 - c2) * 2.0; } break; case 1: for (; nsample < 256; nsample++) { float c1 = su1[band + nsample]; float c2 = su2[band + nsample]; su1[band + nsample] = (c1 + c2) * 2.0; su2[band + nsample] = c2 * -2.0; } break; case 2: case 3: for (; nsample < 256; nsample++) { float c1 = su1[band + nsample]; float c2 = su2[band + nsample]; su1[band + nsample] = c1 + c2; su2[band + nsample] = c1 - c2; } break; default: assert(0); } } } ", "target": 0}
{"func": "static void scsidiskreset(DeviceState *dev) { SCSIDiskState *s = DOUPCAST(SCSIDiskState, qdev.qdev, dev); uint64t nbsectors; scsidevicepurgerequests(&s->qdev, SENSECODE(RESET)); bdrvgetgeometry(s->qdev.conf.bs, &nbsectors); nbsectors /= s->qdev.blocksize / 512; if (nbsectors) { nbsectors--; } s->qdev.maxlba = nbsectors; /* reset tray statuses */ s->traylocked = 0; s->trayopen = 0; } ", "target": 0}
{"func": "static int readpartofpacket(AVFormatContext *s, int64t *pts, int *len, int *strid, int readpacket) { AVIOContext *pb = s->pb; PVAContext *pvactx = s->privdata; int syncword, streamid, reserved, flags, length, ptsflag; int64t pvapts = AVNOPTSVALUE, startpos; int ret; recover: startpos = aviotell(pb); syncword = aviorb16(pb); streamid = avior8(pb); avior8(pb); /* counter not used */ reserved = avior8(pb); flags = avior8(pb); length = aviorb16(pb); ptsflag = flags & 0x10; if (syncword != PVAMAGIC) { pvalog(s, AVLOGERROR, \"invalid syncword\\n\"); return AVERROR(EIO); } if (streamid != PVAVIDEOPAYLOAD && streamid != PVAAUDIOPAYLOAD) { pvalog(s, AVLOGERROR, \"invalid streamid\\n\"); return AVERROR(EIO); } if (reserved != 0x55) { pvalog(s, AVLOGWARNING, \"expected reserved byte to be 0x55\\n\"); } if (length > PVAMAXPAYLOADLENGTH) { pvalog(s, AVLOGERROR, \"invalid payload length %u\\n\", length); return AVERROR(EIO); } if (streamid == PVAVIDEOPAYLOAD && ptsflag) { pvapts = aviorb32(pb); length -= 4; } else if (streamid == PVAAUDIOPAYLOAD) { /* PVA Audio Packets either start with a signaled PES packet or * are a continuation of the previous PES packet. New PES packets * always start at the beginning of a PVA Packet, never somewhere in * the middle. */ if (!pvactx->continuepes) { int pessignal, pesheaderdatalength, pespacketlength, pesflags; unsigned char pesheaderdata[256]; pessignal = aviorb24(pb); avior8(pb); pespacketlength = aviorb16(pb); pesflags = aviorb16(pb); pesheaderdatalength = avior8(pb); if (pessignal != 1 || pesheaderdatalength == 0) { pvalog(s, AVLOGWARNING, \"expected non empty signaled PES packet, \" \"trying to recover\\n\"); avioskip(pb, length - 9); if (!readpacket) return AVERROR(EIO); goto recover; } ret = avioread(pb, pesheaderdata, pesheaderdatalength); if (ret != pesheaderdatalength) return ret < 0 ? ret : AVERRORINVALIDDATA; length -= 9 + pesheaderdatalength; pespacketlength -= 3 + pesheaderdatalength; pvactx->continuepes = pespacketlength; if (pesflags & 0x80 && (pesheaderdata[0] & 0xf0) == 0x20) pvapts = ffparsepespts(pesheaderdata); } pvactx->continuepes -= length; if (pvactx->continuepes < 0) { pvalog(s, AVLOGWARNING, \"audio data corruption\\n\"); pvactx->continuepes = 0; } } if (pvapts != AVNOPTSVALUE) avaddindexentry(s->streams[streamid-1], startpos, pvapts, 0, 0, AVINDEXKEYFRAME); *pts = pvapts; *len = length; *strid = streamid; return 0; } ", "target": 1}
{"func": "static void pred8x8topdcrv40c(uint8t *src, int stride){ int i; int dc0; dc0=0; for(i=0;i<8; i++) dc0+= src[i-stride]; dc0= 0x01010101*((dc0 + 4)>>3); for(i=0; i<8; i++){ ((uint32t*)(src+i*stride))[0]= ((uint32t*)(src+i*stride))[1]= dc0; } } ", "target": 1}
{"func": "static int virtioccwsetvqs(SubchDev *sch, uint64t addr, uint32t align, uint16t index, uint16t num) { VirtIODevice *vdev = virtioccwgetvdev(sch); if (index >= VIRTIOPCIQUEUEMAX) { return -EINVAL; } /* Current code in virtio.c relies on 4K alignment. */ if (addr && (align != 4096)) { return -EINVAL; } if (!vdev) { return -EINVAL; } virtioqueuesetaddr(vdev, index, addr); if (!addr) { virtioqueuesetvector(vdev, index, 0); } else { /* Fail if we don't have a big enough queue. */ /* TODO: Add interface to handle vring.num changing */ if (virtioqueuegetnum(vdev, index) > num) { return -EINVAL; } virtioqueuesetvector(vdev, index, index); } /* tell notify handler in case of config change */ vdev->configvector = VIRTIOPCIQUEUEMAX; return 0; } ", "target": 0}
{"func": "static void rtl8139receive(void *opaque, const uint8t *buf, sizet size) { rtl8139doreceive(opaque, buf, size, 1); } ", "target": 0}
{"func": "static int localchown(FsContext *fsctx, V9fsPath *fspath, FsCred *credp) { char buffer[PATHMAX]; char *path = fspath->data; if ((credp->fcuid == -1 && credp->fcgid == -1) || (fsctx->exportflags & V9FSSMPASSTHROUGH) || (fsctx->exportflags & V9FSSMNONE)) { return lchown(rpath(fsctx, path, buffer), credp->fcuid, credp->fcgid); } else if (fsctx->exportflags & V9FSSMMAPPED) { return localsetxattr(rpath(fsctx, path, buffer), credp); } else if (fsctx->exportflags & V9FSSMMAPPEDFILE) { return localsetmappedfileattr(fsctx, path, credp); } return -1; } ", "target": 0}
{"func": "static void qdictcrumpletestrecursive(void) { QDict *src, *dst, *rule, *vnc, *acl, *listen; QObject *child, *res; QList *rules; src = qdictnew(); qdictput(src, \"vnc.listen.addr\", qstringfromstr(\"127.0.0.1\")); qdictput(src, \"vnc.listen.port\", qstringfromstr(\"5901\")); qdictput(src, \"vnc.acl.rules.0.match\", qstringfromstr(\"fred\")); qdictput(src, \"vnc.acl.rules.0.policy\", qstringfromstr(\"allow\")); qdictput(src, \"vnc.acl.rules.1.match\", qstringfromstr(\"bob\")); qdictput(src, \"vnc.acl.rules.1.policy\", qstringfromstr(\"deny\")); qdictput(src, \"vnc.acl.default\", qstringfromstr(\"deny\")); qdictput(src, \"vnc.acl..name\", qstringfromstr(\"acl0\")); qdictput(src, \"vnc.acl.rule..name\", qstringfromstr(\"acl0\")); res = qdictcrumple(src, &errorabort); gassertcmpint(qobjecttype(res), ==, QTYPEQDICT); dst = qobjecttoqdict(res); gassertcmpint(qdictsize(dst), ==, 1); child = qdictget(dst, \"vnc\"); gassertcmpint(qobjecttype(child), ==, QTYPEQDICT); vnc = qobjecttoqdict(child); child = qdictget(vnc, \"listen\"); gassertcmpint(qobjecttype(child), ==, QTYPEQDICT); listen = qobjecttoqdict(child); gassertcmpstr(\"127.0.0.1\", ==, qdictgetstr(listen, \"addr\")); gassertcmpstr(\"5901\", ==, qdictgetstr(listen, \"port\")); child = qdictget(vnc, \"acl\"); gassertcmpint(qobjecttype(child), ==, QTYPEQDICT); acl = qobjecttoqdict(child); child = qdictget(acl, \"rules\"); gassertcmpint(qobjecttype(child), ==, QTYPEQLIST); rules = qobjecttoqlist(child); gassertcmpint(qlistsize(rules), ==, 2); rule = qobjecttoqdict(qlistpop(rules)); gassertcmpint(qdictsize(rule), ==, 2); gassertcmpstr(\"fred\", ==, qdictgetstr(rule, \"match\")); gassertcmpstr(\"allow\", ==, qdictgetstr(rule, \"policy\")); QDECREF(rule); rule = qobjecttoqdict(qlistpop(rules)); gassertcmpint(qdictsize(rule), ==, 2); gassertcmpstr(\"bob\", ==, qdictgetstr(rule, \"match\")); gassertcmpstr(\"deny\", ==, qdictgetstr(rule, \"policy\")); QDECREF(rule); /* With recursive crumpling, we should see all names unescaped */ gassertcmpstr(\"acl0\", ==, qdictgetstr(vnc, \"acl.name\")); child = qdictget(vnc, \"acl\"); gassertcmpint(qobjecttype(child), ==, QTYPEQDICT); acl = qdictgetqdict(vnc, \"acl\"); gassertcmpstr(\"acl0\", ==, qdictgetstr(acl, \"rule.name\")); QDECREF(src); QDECREF(dst); } ", "target": 0}
{"func": "static void testvalidatefailalternate(TestInputVisitorData *data, const void *unused) { UserDefAlternate *tmp; Visitor *v; Error *err = NULL; v = validatetestinit(data, \"3.14\"); visittypeUserDefAlternate(v, NULL, &tmp, &err); errorfreeorabort(&err); qapifreeUserDefAlternate(tmp); } ", "target": 1}
{"func": "static int qcow2coflush(BlockDriverState *bs) { BDRVQcowState *s = bs->opaque; int ret; qemucomutexlock(&s->lock); ret = qcow2cacheflush(bs, s->l2tablecache); if (ret < 0) { return ret; } ret = qcow2cacheflush(bs, s->refcountblockcache); if (ret < 0) { return ret; } return bdrvcoflush(bs->file); }", "target": 1}
{"func": "static int vc1initcommon(VC1Context *v) { static int done = 0; int i = 0; v->hrdrate = v->hrdbuffer = NULL; /* VLC tables */ if(!done) { done = 1; initvlc(&ffvc1bfractionvlc, VC1BFRACTIONVLCBITS, 23, ffvc1bfractionbits, 1, 1, ffvc1bfractioncodes, 1, 1, INITVLCUSESTATIC); initvlc(&ffvc1norm2vlc, VC1NORM2VLCBITS, 4, ffvc1norm2bits, 1, 1, ffvc1norm2codes, 1, 1, INITVLCUSESTATIC); initvlc(&ffvc1norm6vlc, VC1NORM6VLCBITS, 64, ffvc1norm6bits, 1, 1, ffvc1norm6codes, 2, 2, INITVLCUSESTATIC); initvlc(&ffvc1imodevlc, VC1IMODEVLCBITS, 7, ffvc1imodebits, 1, 1, ffvc1imodecodes, 1, 1, INITVLCUSESTATIC); for (i=0; i<3; i++) { initvlc(&ffvc1ttmbvlc[i], VC1TTMBVLCBITS, 16, ffvc1ttmbbits[i], 1, 1, ffvc1ttmbcodes[i], 2, 2, INITVLCUSESTATIC); initvlc(&ffvc1ttblkvlc[i], VC1TTBLKVLCBITS, 8, ffvc1ttblkbits[i], 1, 1, ffvc1ttblkcodes[i], 1, 1, INITVLCUSESTATIC); initvlc(&ffvc1subblkpatvlc[i], VC1SUBBLKPATVLCBITS, 15, ffvc1subblkpatbits[i], 1, 1, ffvc1subblkpatcodes[i], 1, 1, INITVLCUSESTATIC); } for(i=0; i<4; i++) { initvlc(&ffvc14mvblockpatternvlc[i], VC14MVBLOCKPATTERNVLCBITS, 16, ffvc14mvblockpatternbits[i], 1, 1, ffvc14mvblockpatterncodes[i], 1, 1, INITVLCUSESTATIC); initvlc(&ffvc1cbpcypvlc[i], VC1CBPCYPVLCBITS, 64, ffvc1cbpcypbits[i], 1, 1, ffvc1cbpcypcodes[i], 2, 2, INITVLCUSESTATIC); initvlc(&ffvc1mvdiffvlc[i], VC1MVDIFFVLCBITS, 73, ffvc1mvdiffbits[i], 1, 1, ffvc1mvdiffcodes[i], 2, 2, INITVLCUSESTATIC); } for(i=0; i<8; i++) initvlc(&ffvc1accoefftable[i], ACVLCBITS, vc1acsizes[i], &vc1actables[i][0][1], 8, 4, &vc1actables[i][0][0], 8, 4, INITVLCUSESTATIC); initvlc(&ffmsmp4mbivlc, MBINTRAVLCBITS, 64, &ffmsmp4mbitable[0][1], 4, 2, &ffmsmp4mbitable[0][0], 4, 2, INITVLCUSESTATIC); } /* Other defaults */ v->pq = -1; v->mvrange = 0; /* 7.1.1.18, p80 */ return 0; } ", "target": 1}
{"func": "int avreadpacket(AVFormatContext *s, AVPacket *pkt) { int ret, i; AVStream *st; for(;;){ AVPacketList *pktl = s->rawpacketbuffer; if (pktl) { *pkt = pktl->pkt; if(s->streams[pkt->streamindex]->codec->codecid != CODECIDPROBE || !s->streams[pkt->streamindex]->probepackets || s->rawpacketbufferremainingsize < pkt->size){ AVProbeData *pd = &s->streams[pkt->streamindex]->probedata; avfreep(&pd->buf); pd->bufsize = 0; s->rawpacketbuffer = pktl->next; s->rawpacketbufferremainingsize += pkt->size; avfree(pktl); return 0; avinitpacket(pkt); ret= s->iformat->readpacket(s, pkt); if (ret < 0) { if (!pktl || ret == AVERROR(EAGAIN)) return ret; for (i = 0; i < s->nbstreams; i++) s->streams[i]->probepackets = 0; st= s->streams[pkt->streamindex]; switch(st->codec->codectype){ case AVMEDIATYPEVIDEO: if(s->videocodecid) st->codec->codecid= s->videocodecid; break; case AVMEDIATYPEAUDIO: if(s->audiocodecid) st->codec->codecid= s->audiocodecid; break; case AVMEDIATYPESUBTITLE: if(s->subtitlecodecid)st->codec->codecid= s->subtitlecodecid; break; if(!pktl && (st->codec->codecid != CODECIDPROBE || !st->probepackets)) return ret; addtopktbuf(&s->rawpacketbuffer, pkt, &s->rawpacketbufferend); s->rawpacketbufferremainingsize -= pkt->size; if(st->codec->codecid == CODECIDPROBE){ AVProbeData *pd = &st->probedata; avlog(s, AVLOGDEBUG, \"probing stream %d\\n\", st->index); --st->probepackets; pd->buf = avrealloc(pd->buf, pd->bufsize+pkt->size+AVPROBEPADDINGSIZE); memcpy(pd->buf+pd->bufsize, pkt->data, pkt->size); pd->bufsize += pkt->size; memset(pd->buf+pd->bufsize, 0, AVPROBEPADDINGSIZE); if(avlog2(pd->bufsize) != avlog2(pd->bufsize - pkt->size)){ //FIXME we dont reduce score to 0 for the case of running out of buffer space in bytes setcodecfromprobedata(s, st, pd, st->probepackets > 0 ? AVPROBESCOREMAX/4 : 0); if(st->codec->codecid != CODECIDPROBE){ pd->bufsize=0; avfreep(&pd->buf); avlog(s, AVLOGDEBUG, \"probed stream %d\\n\", st->index);", "target": 1}
{"func": "static int nbdcanaccept(void) { return nbfds < shared; } ", "target": 1}
{"func": "static int netconnect(struct XenDevice *xendev) { struct XenNetDev *netdev = containerof(xendev, struct XenNetDev, xendev); int rxcopy; if (xenstorereadfeint(&netdev->xendev, \"tx-ring-ref\", &netdev->txringref) == -1) { return -1; } if (xenstorereadfeint(&netdev->xendev, \"rx-ring-ref\", &netdev->rxringref) == -1) { return 1; } if (xenstorereadfeint(&netdev->xendev, \"event-channel\", &netdev->xendev.remoteport) == -1) { return -1; } if (xenstorereadfeint(&netdev->xendev, \"request-rx-copy\", &rxcopy) == -1) { rxcopy = 0; } if (rxcopy == 0) { xenbeprintf(&netdev->xendev, 0, \"frontend doesn't support rx-copy.\\n\"); return -1; } netdev->txs = xcgnttabmapgrantref(netdev->xendev.gnttabdev, netdev->xendev.dom, netdev->txringref, PROTREAD | PROTWRITE); netdev->rxs = xcgnttabmapgrantref(netdev->xendev.gnttabdev, netdev->xendev.dom, netdev->rxringref, PROTREAD | PROTWRITE); if (!netdev->txs || !netdev->rxs) { return -1; } BACKRINGINIT(&netdev->txring, netdev->txs, XCPAGESIZE); BACKRINGINIT(&netdev->rxring, netdev->rxs, XCPAGESIZE); xenbebindevtchn(&netdev->xendev); xenbeprintf(&netdev->xendev, 1, \"ok: tx-ring-ref %d, rx-ring-ref %d, \" \"remote port %d, local port %d\\n\", netdev->txringref, netdev->rxringref, netdev->xendev.remoteport, netdev->xendev.localport); nettxpackets(netdev); return 0; } ", "target": 1}
{"func": "static bool domodifysoftint(CPUSPARCState *env, uint32t value) { if (env->softint != value) { env->softint = value; #if !defined(CONFIGUSERONLY) if (cpuinterruptsenabled(env)) { cpucheckirqs(env); } #endif return true; } return false; }", "target": 1}
{"func": "static int decodeTonalComponents (GetBitContext *gb, tonalcomponent *pComponent, int numBands) { int i,j,k,cnt; int components, codingmodeselector, codingmode, codedvaluespercomponent; int sfIndx, codedvalues, maxcodedvalues, quantstepindex, codedcomponents; int bandflags[4], mantissa[8]; float *pCoef; float scalefactor; int componentcount = 0; components = getbits(gb,5); /* no tonal components */ if (components == 0) return 0; codingmodeselector = getbits(gb,2); if (codingmodeselector == 2) codingmode = codingmodeselector & 1; for (i = 0; i < components; i++) { for (cnt = 0; cnt <= numBands; cnt++) bandflags[cnt] = getbits1(gb); codedvaluespercomponent = getbits(gb,3); quantstepindex = getbits(gb,3); if (quantstepindex <= 1) if (codingmodeselector == 3) codingmode = getbits1(gb); for (j = 0; j < (numBands + 1) * 4; j++) { if (bandflags[j >> 2] == 0) continue; codedcomponents = getbits(gb,3); for (k=0; k<codedcomponents; k++) { sfIndx = getbits(gb,6); pComponent[componentcount].pos = j * 64 + (getbits(gb,6)); maxcodedvalues = SAMPLESPERFRAME - pComponent[componentcount].pos; codedvalues = codedvaluespercomponent + 1; codedvalues = FFMIN(maxcodedvalues,codedvalues); scalefactor = ffatracsftable[sfIndx] * iMaxQuant[quantstepindex]; readQuantSpectralCoeffs(gb, quantstepindex, codingmode, mantissa, codedvalues); pComponent[componentcount].numCoefs = codedvalues; /* inverse quant */ pCoef = pComponent[componentcount].coef; for (cnt = 0; cnt < codedvalues; cnt++) pCoef[cnt] = mantissa[cnt] * scalefactor; componentcount++; } } } return componentcount; }", "target": 1}
{"func": "static void dosendkey(const char *string) { char keybuf[16], *q; uint8t keycodes[16]; const char *p; int nbkeycodes, keycode, i; nbkeycodes = 0; p = string; while (*p != '\\0') { q = keybuf; while (*p != '\\0' && *p != '-') { if ((q - keybuf) < sizeof(keybuf) - 1) { *q++ = *p; } p++; } *q = '\\0'; keycode = getkeycode(keybuf); if (keycode < 0) { termprintf(\"unknown key: '%s'\\n\", keybuf); return; } keycodes[nbkeycodes++] = keycode; if (*p == '\\0') break; p++; } /* key down events */ for(i = 0; i < nbkeycodes; i++) { keycode = keycodes[i]; if (keycode & 0x80) kbdputkeycode(0xe0); kbdputkeycode(keycode & 0x7f); } /* key up events */ for(i = nbkeycodes - 1; i >= 0; i--) { keycode = keycodes[i]; if (keycode & 0x80) kbdputkeycode(0xe0); kbdputkeycode(keycode | 0x80); } } ", "target": 1}
{"func": "void domigratesetspeed(Monitor *mon, const QDict *qdict, QObject **retdata) { double d; char *ptr; FdMigrationState *s; const char *value = qdictgetstr(qdict, \"value\"); d = strtod(value, &ptr); switch (*ptr) { case 'G': case 'g': d *= 1024; case 'M': case 'm': d *= 1024; case 'K': case 'k': d *= 1024; default: break; } maxthrottle = (uint32t)d; s = migratetofms(currentmigration); if (s) { qemufilesetratelimit(s->file, maxthrottle); } } ", "target": 0}
{"func": "static inline void genefdneg(DisasContext *ctx) { if (unlikely(!ctx->speenabled)) { genexception(ctx, POWERPCEXCPAPU); return; } #if defined(TARGETPPC64) tcggenxoritl(cpugpr[rD(ctx->opcode)], cpugpr[rA(ctx->opcode)], 0x8000000000000000LL); #else tcggenmovtl(cpugpr[rD(ctx->opcode)], cpugpr[rA(ctx->opcode)]); tcggenxoritl(cpugprh[rD(ctx->opcode)], cpugprh[rA(ctx->opcode)], 0x80000000); #endif } ", "target": 0}
{"func": "static void gensrlq(DisasContext *ctx) { int l1 = gennewlabel(); int l2 = gennewlabel(); TCGv t0 = tcgtemplocalnew(); TCGv t1 = tcgtemplocalnew(); TCGv t2 = tcgtemplocalnew(); tcggenanditl(t2, cpugpr[rB(ctx->opcode)], 0x1F); tcggenmovitl(t1, 0xFFFFFFFF); tcggenshrtl(t2, t1, t2); tcggenanditl(t0, cpugpr[rB(ctx->opcode)], 0x20); tcggenbrconditl(TCGCONDEQ, t0, 0, l1); genloadspr(t0, SPRMQ); tcggenandtl(cpugpr[rA(ctx->opcode)], t0, t2); tcggenbr(l2); gensetlabel(l1); tcggenshrtl(t0, cpugpr[rS(ctx->opcode)], t2); tcggenandtl(t0, t0, t2); genloadspr(t1, SPRMQ); tcggenandctl(t1, t1, t2); tcggenortl(cpugpr[rA(ctx->opcode)], t0, t1); gensetlabel(l2); tcgtempfree(t0); tcgtempfree(t1); tcgtempfree(t2); if (unlikely(Rc(ctx->opcode) != 0)) gensetRc0(ctx, cpugpr[rA(ctx->opcode)]); } ", "target": 0}
{"func": "static sizet sendcontrolmsg(VirtIOSerial *vser, void *buf, sizet len) { VirtQueueElement elem; VirtQueue *vq; vq = vser->civq; if (!virtioqueueready(vq)) { return 0; } if (!virtqueuepop(vq, &elem)) { return 0; } /* TODO: detect a buffer that's too short, set NEEDSRESET */ iovfrombuf(elem.insg, elem.innum, 0, buf, len); virtqueuepush(vq, &elem, len); virtionotify(VIRTIODEVICE(vser), vq); return len; } ", "target": 0}
{"func": "void ich9pminit(PCIDevice *lpcpci, ICH9LPCPMRegs *pm, qemuirq sciirq) { memoryregioninit(&pm->io, OBJECT(lpcpci), \"ich9-pm\", ICH9PMIOSIZE); memoryregionsetenabled(&pm->io, false); memoryregionaddsubregion(pciaddressspaceio(lpcpci), 0, &pm->io); acpipmtmrinit(&pm->acpiregs, ich9pmupdatescifn, &pm->io); acpipm1evtinit(&pm->acpiregs, ich9pmupdatescifn, &pm->io); acpipm1cntinit(&pm->acpiregs, &pm->io, pm->s4val); acpigpeinit(&pm->acpiregs, ICH9PMIOGPE0LEN); memoryregioninitio(&pm->iogpe, OBJECT(lpcpci), &ich9gpeops, pm, \"acpi-gpe0\", ICH9PMIOGPE0LEN); memoryregionaddsubregion(&pm->io, ICH9PMIOGPE0STS, &pm->iogpe); memoryregioninitio(&pm->iosmi, OBJECT(lpcpci), &ich9smiops, pm, \"acpi-smi\", 8); memoryregionaddsubregion(&pm->io, ICH9PMIOSMIEN, &pm->iosmi); pm->irq = sciirq; qemuregisterreset(pmreset, pm); pm->powerdownnotifier.notify = pmpowerdownreq; qemuregisterpowerdownnotifier(&pm->powerdownnotifier); acpicpuhotpluginit(pciaddressspaceio(lpcpci), OBJECT(lpcpci), &pm->gpecpu, ICH9CPUHOTPLUGIOBASE); if (pm->acpimemoryhotplug.isenabled) { acpimemoryhotpluginit(pciaddressspaceio(lpcpci), OBJECT(lpcpci), &pm->acpimemoryhotplug); } } ", "target": 0}
{"func": "uint32t omapbadwidthread8(void *opaque, targetphysaddrt addr) { uint8t ret; OMAP8BREG(addr); cpuphysicalmemoryread(addr, (void *) &ret, 1); return ret; } ", "target": 0}
{"func": "static inline void IRQsetbit(IRQqueuet *q, int nIRQ) { q->pending++; setbit(q->queue, nIRQ); } ", "target": 1}
{"func": "static int matroskadecodebuffer(uint8t** buf, int* bufsize, MatroskaTrack *track) { MatroskaTrackEncoding *encodings = track->encodings.elem; uint8t* data = *buf; int isize = *bufsize; uint8t* pktdata = NULL; int pktsize = isize; int result = 0; int olen; if (pktsize >= 10000000) return -1; switch (encodings[0].compression.algo) { case MATROSKATRACKENCODINGCOMPHEADERSTRIP: return encodings[0].compression.settings.size; case MATROSKATRACKENCODINGCOMPLZO: do { olen = pktsize *= 3; pktdata = avrealloc(pktdata, pktsize+AVLZOOUTPUTPADDING); result = avlzo1xdecode(pktdata, &olen, data, &isize); } while (result==AVLZOOUTPUTFULL && pktsize<10000000); if (result) goto failed; pktsize -= olen; break; #if CONFIGZLIB case MATROSKATRACKENCODINGCOMPZLIB: { zstream zstream = {0}; if (inflateInit(&zstream) != ZOK) return -1; zstream.nextin = data; zstream.availin = isize; do { pktsize *= 3; pktdata = avrealloc(pktdata, pktsize); zstream.availout = pktsize - zstream.totalout; zstream.nextout = pktdata + zstream.totalout; result = inflate(&zstream, ZNOFLUSH); } while (result==ZOK && pktsize<10000000); pktsize = zstream.totalout; inflateEnd(&zstream); if (result != ZSTREAMEND) goto failed; break; } #endif #if CONFIGBZLIB case MATROSKATRACKENCODINGCOMPBZLIB: { bzstream bzstream = {0}; if (BZ2bzDecompressInit(&bzstream, 0, 0) != BZOK) return -1; bzstream.nextin = data; bzstream.availin = isize; do { pktsize *= 3; pktdata = avrealloc(pktdata, pktsize); bzstream.availout = pktsize - bzstream.totaloutlo32; bzstream.nextout = pktdata + bzstream.totaloutlo32; result = BZ2bzDecompress(&bzstream); } while (result==BZOK && pktsize<10000000); pktsize = bzstream.totaloutlo32; BZ2bzDecompressEnd(&bzstream); if (result != BZSTREAMEND) goto failed; break; } #endif default: return -1; } *buf = pktdata; *bufsize = pktsize; return 0; failed: avfree(pktdata); return -1; } ", "target": 1}
{"func": "static void ac3extractexponentsc(uint8t *exp, int32t *coef, int nbcoefs) { int i; for (i = 0; i < nbcoefs; i++) { int e; int v = abs(coef[i]); if (v == 0) e = 24; else { e = 23 - avlog2(v); if (e >= 24) { e = 24; coef[i] = 0; } avassert2(e >= 0); } exp[i] = e; } } ", "target": 0}
{"func": "static void vhostlogstop(MemoryListener *listener, MemoryRegionSection *section) { /* FIXME: implement */ } ", "target": 0}
{"func": "static void spaprhotplugreqevent(sPAPRDRConnector *drc, uint8t hpaction) { struct hplogfull *newhp; struct rtaserrorlog *hdr; struct rtaseventlogv6 *v6hdr; struct rtaseventlogv6maina *maina; struct rtaseventlogv6mainb *mainb; struct rtaseventlogv6hp *hp; sPAPRDRConnectorClass *drck = SPAPRDRCONNECTORGETCLASS(drc); sPAPRDRConnectorType drctype = drck->gettype(drc); newhp = gmalloc0(sizeof(struct hplogfull)); hdr = &newhp->hdr; v6hdr = &newhp->v6hdr; maina = &newhp->maina; mainb = &newhp->mainb; hp = &newhp->hp; hdr->summary = cputobe32(RTASLOGVERSION6 | RTASLOGSEVERITYEVENT | RTASLOGDISPOSITIONNOTRECOVERED | RTASLOGOPTIONALPARTPRESENT | RTASLOGINITIATORHOTPLUG | RTASLOGTYPEHOTPLUG); hdr->extendedlength = cputobe32(sizeof(*newhp) - sizeof(newhp->hdr)); spaprinitv6hdr(v6hdr); spaprinitmaina(maina, 3 /* Main-A, Main-B, HP */); mainb->hdr.sectionid = cputobe16(RTASLOGV6SECTIONIDMAINB); mainb->hdr.sectionlength = cputobe16(sizeof(*mainb)); mainb->subsystemid = 0x80; /* External environment */ mainb->eventseverity = 0x00; /* Informational / non-error */ mainb->eventsubtype = 0x00; /* Normal shutdown */ hp->hdr.sectionid = cputobe16(RTASLOGV6SECTIONIDHOTPLUG); hp->hdr.sectionlength = cputobe16(sizeof(*hp)); hp->hdr.sectionversion = 1; /* includes extended modifier */ hp->hotplugaction = hpaction; switch (drctype) { case SPAPRDRCONNECTORTYPEPCI: hp->drc.index = cputobe32(drck->getindex(drc)); hp->hotplugidentifier = RTASLOGV6HPIDDRCINDEX; hp->hotplugtype = RTASLOGV6HPTYPEPCI; break; default: /* we shouldn't be signaling hotplug events for resources * that don't support them */ gassert(false); return; } rtaseventlogqueue(RTASLOGTYPEHOTPLUG, newhp); qemuirqpulse(xicsgetqirq(spapr->icp, spapr->checkexceptionirq)); } ", "target": 0}
{"func": "static TCGReg tcgouttlbload(TCGContext *s, TCGReg addr, int memindex, TCGMemOp sbits, int which) { const TCGReg r0 = TCGREGO0; const TCGReg r1 = TCGREGO1; const TCGReg r2 = TCGREGO2; int tlbofs; /* Shift the page number down. */ tcgoutarithi(s, r1, addr, TARGETPAGEBITS, SHIFTSRL); /* Mask out the page offset, except for the required alignment. */ tcgoutmovi(s, TCGTYPETL, TCGREGT1, TARGETPAGEMASK | ((1 << sbits) - 1)); /* Mask the tlb index. */ tcgoutarithi(s, r1, r1, CPUTLBSIZE - 1, ARITHAND); /* Mask page, part 2. */ tcgoutarith(s, r0, addr, TCGREGT1, ARITHAND); /* Shift the tlb index into place. */ tcgoutarithi(s, r1, r1, CPUTLBENTRYBITS, SHIFTSLL); /* Relative to the current ENV. */ tcgoutarith(s, r1, TCGAREG0, r1, ARITHADD); /* Find a base address that can load both tlb comparator and addend. */ tlbofs = offsetof(CPUArchState, tlbtable[memindex][0]); if (!checkfittl(tlbofs + sizeof(CPUTLBEntry), 13)) { tcgoutaddi(s, r1, tlbofs & ~0x3ff); tlbofs &= 0x3ff; } /* Load the tlb comparator and the addend. */ tcgoutld(s, TCGTYPETL, r2, r1, tlbofs + which); tcgoutld(s, TCGTYPEPTR, r1, r1, tlbofs+offsetof(CPUTLBEntry, addend)); /* subcc arg0, arg2, %g0 */ tcgoutcmp(s, r0, r2, 0); /* If the guest address must be zero-extended, do so now. */ if (SPARC64 && TARGETLONGBITS == 32) { tcgoutarithi(s, r0, addr, 0, SHIFTSRL); return r0; } return addr; } ", "target": 0}
{"func": "static int curlsockcb(CURL *curl, curlsockett fd, int action, void *s, void *sp) { DPRINTF(\"CURL (AIO): Sock action %d on fd %d\\n\", action, fd); switch (action) { case CURLPOLLIN: qemuaiosetfdhandler(fd, curlmultido, NULL, s); break; case CURLPOLLOUT: qemuaiosetfdhandler(fd, NULL, curlmultido, s); break; case CURLPOLLINOUT: qemuaiosetfdhandler(fd, curlmultido, curlmultido, s); break; case CURLPOLLREMOVE: qemuaiosetfdhandler(fd, NULL, NULL, NULL); break; } return 0; } ", "target": 0}
{"func": "SwsFunc yuv2rgbgetfuncptr (SwsContext *c) { #if defined(HAVEMMX2) || defined(HAVEMMX) if(c->flags & SWSCPUCAPSMMX2){ \tswitch(c->dstFormat){ \tcase PIXFMTRGB32: return yuv420rgb32MMX2; \tcase PIXFMTBGR24: return yuv420rgb24MMX2; \tcase PIXFMTBGR565: return yuv420rgb16MMX2; \tcase PIXFMTBGR555: return yuv420rgb15MMX2; \t} } if(c->flags & SWSCPUCAPSMMX){ \tswitch(c->dstFormat){ \tcase PIXFMTRGB32: return yuv420rgb32MMX; \tcase PIXFMTBGR24: return yuv420rgb24MMX; \tcase PIXFMTBGR565: return yuv420rgb16MMX; \tcase PIXFMTBGR555: return yuv420rgb15MMX; \t} } #endif #ifdef HAVEMLIB { \tSwsFunc t= yuv2rgbinitmlib(c); \tif(t) return t; } #endif #ifdef HAVEALTIVEC if (c->flags & SWSCPUCAPSALTIVEC) { \tSwsFunc t = yuv2rgbinitaltivec(c); \tif(t) return t; } #endif avlog(c, AVLOGWARNING, \"No accelerated colorspace conversion found\\n\"); switch(c->dstFormat){ case PIXFMTBGR32: case PIXFMTRGB32: return yuv2rgbc32; case PIXFMTRGB24: return yuv2rgbc24rgb; case PIXFMTBGR24: return yuv2rgbc24bgr; case PIXFMTRGB565: case PIXFMTBGR565: case PIXFMTRGB555: case PIXFMTBGR555: return yuv2rgbc16; case PIXFMTRGB8: case PIXFMTBGR8: return yuv2rgbc8ordereddither; case PIXFMTRGB4: case PIXFMTBGR4: return yuv2rgbc4ordereddither; case PIXFMTRGB4BYTE: case PIXFMTBGR4BYTE: return yuv2rgbc4bordereddither; case PIXFMTMONOBLACK: return yuv2rgbc1ordereddither; default: \tassert(0); } return NULL; } ", "target": 1}
{"func": "static void vncsetsharemode(VncState *vs, VncShareMode mode) { #ifdef VNCDEBUG static const char *mn[] = { [0] = \"undefined\", [VNCSHAREMODECONNECTING] = \"connecting\", [VNCSHAREMODESHARED] = \"shared\", [VNCSHAREMODEEXCLUSIVE] = \"exclusive\", [VNCSHAREMODEDISCONNECTED] = \"disconnected\", }; fprintf(stderr, \"%s/%d: %s -> %s\\n\", func, vs->csock, mn[vs->sharemode], mn[mode]); #endif if (vs->sharemode == VNCSHAREMODEEXCLUSIVE) { vs->vd->numexclusive--; } vs->sharemode = mode; if (vs->sharemode == VNCSHAREMODEEXCLUSIVE) { vs->vd->numexclusive++; } } ", "target": 1}
{"func": "uint8t ffmlpcalculateparity(const uint8t *buf, unsigned int bufsize) { uint32t scratch = 0; const uint8t *bufend = buf + bufsize; for (; buf < bufend - 3; buf += 4) scratch ^= *((const uint32t*)buf); scratch = xor32to8(scratch); for (; buf < bufend; buf++) return scratch; }", "target": 1}
{"func": "void fferframestart(ERContext *s) { if (!s->avctx->errrecognition) return; memset(s->errorstatustable, ERMBERROR | VPSTART | ERMBEND, s->mbstride * s->mbheight * sizeof(uint8t)); s->errorcount = 3 * s->mbnum; s->erroroccurred = 0; } ", "target": 0}
{"func": "avcold int MPVcommoninit(MpegEncContext *s) { int ysize, csize, ycsize, i, mbarraysize, mvtablesize, x, y, threads; if(s->codecid == CODECIDMPEG2VIDEO && !s->progressivesequence) s->mbheight = (s->height + 31) / 32 * 2; else if (s->codecid != CODECIDH264) s->mbheight = (s->height + 15) / 16; if(s->avctx->pixfmt == PIXFMTNONE){ avlog(s->avctx, AVLOGERROR, \"decoding to PIXFMTNONE is not supported.\\n\"); return -1; } if((s->encoding || (s->avctx->activethreadtype & FFTHREADSLICE)) && (s->avctx->threadcount > MAXTHREADS || (s->avctx->threadcount > s->mbheight && s->mbheight))){ avlog(s->avctx, AVLOGERROR, \"too many threads\\n\"); return -1; } if((s->width || s->height) && avimagechecksize(s->width, s->height, 0, s->avctx)) return -1; dsputilinit(&s->dsp, s->avctx); ffdctcommoninit(s); s->flags= s->avctx->flags; s->flags2= s->avctx->flags2; if (s->width && s->height) { s->mbwidth = (s->width + 15) / 16; s->mbstride = s->mbwidth + 1; s->b8stride = s->mbwidth*2 + 1; s->b4stride = s->mbwidth*4 + 1; mbarraysize= s->mbheight * s->mbstride; mvtablesize= (s->mbheight+2) * s->mbstride + 1; /* set chroma shifts */ avcodecgetchromasubsample(s->avctx->pixfmt,&(s->chromaxshift), &(s->chromayshift) ); /* set default edge pos, will be overriden in decodeheader if needed */ s->hedgepos= s->mbwidth*16; s->vedgepos= s->mbheight*16; s->mbnum = s->mbwidth * s->mbheight; s->blockwrap[0]= s->blockwrap[1]= s->blockwrap[2]= s->blockwrap[3]= s->b8stride; s->blockwrap[4]= s->blockwrap[5]= s->mbstride; ysize = s->b8stride * (2 * s->mbheight + 1); csize = s->mbstride * (s->mbheight + 1); ycsize = ysize + 2 * csize; /* convert fourcc to upper case */ s->codectag = fftoupper4(s->avctx->codectag); s->streamcodectag = fftoupper4(s->avctx->streamcodectag); s->avctx->codedframe= (AVFrame*)&s->currentpicture; FFALLOCZORGOTO(s->avctx, s->mbindex2xy, (s->mbnum+1)*sizeof(int), fail) //error ressilience code looks cleaner with this for(y=0; y<s->mbheight; y++){ for(x=0; x<s->mbwidth; x++){ s->mbindex2xy[ x + y*s->mbwidth ] = x + y*s->mbstride; } } s->mbindex2xy[ s->mbheight*s->mbwidth ] = (s->mbheight-1)*s->mbstride + s->mbwidth; //FIXME really needed? if (s->encoding) { /* Allocate MV tables */ FFALLOCZORGOTO(s->avctx, s->pmvtablebase , mvtablesize * 2 * sizeof(int16t), fail) FFALLOCZORGOTO(s->avctx, s->bforwmvtablebase , mvtablesize * 2 * sizeof(int16t), fail) FFALLOCZORGOTO(s->avctx, s->bbackmvtablebase , mvtablesize * 2 * sizeof(int16t), fail) FFALLOCZORGOTO(s->avctx, s->bbidirforwmvtablebase , mvtablesize * 2 * sizeof(int16t), fail) FFALLOCZORGOTO(s->avctx, s->bbidirbackmvtablebase , mvtablesize * 2 * sizeof(int16t), fail) FFALLOCZORGOTO(s->avctx, s->bdirectmvtablebase , mvtablesize * 2 * sizeof(int16t), fail) s->pmvtable = s->pmvtablebase + s->mbstride + 1; s->bforwmvtable = s->bforwmvtablebase + s->mbstride + 1; s->bbackmvtable = s->bbackmvtablebase + s->mbstride + 1; s->bbidirforwmvtable= s->bbidirforwmvtablebase + s->mbstride + 1; s->bbidirbackmvtable= s->bbidirbackmvtablebase + s->mbstride + 1; s->bdirectmvtable = s->bdirectmvtablebase + s->mbstride + 1; if(s->msmpeg4version){ FFALLOCZORGOTO(s->avctx, s->acstats, 2*2*(MAXLEVEL+1)*(MAXRUN+1)*2*sizeof(int), fail); } FFALLOCZORGOTO(s->avctx, s->avctx->statsout, 256, fail); /* Allocate MB type table */ FFALLOCZORGOTO(s->avctx, s->mbtype , mbarraysize * sizeof(uint16t), fail) //needed for encoding FFALLOCZORGOTO(s->avctx, s->lambdatable, mbarraysize * sizeof(int), fail) FFALLOCZORGOTO(s->avctx, s->qintramatrix , 64*32 * sizeof(int), fail) FFALLOCZORGOTO(s->avctx, s->qintermatrix , 64*32 * sizeof(int), fail) FFALLOCZORGOTO(s->avctx, s->qintramatrix16, 64*32*2 * sizeof(uint16t), fail) FFALLOCZORGOTO(s->avctx, s->qintermatrix16, 64*32*2 * sizeof(uint16t), fail) FFALLOCZORGOTO(s->avctx, s->inputpicture, MAXPICTURECOUNT * sizeof(Picture*), fail) FFALLOCZORGOTO(s->avctx, s->reorderedinputpicture, MAXPICTURECOUNT * sizeof(Picture*), fail) if(s->avctx->noisereduction){ FFALLOCZORGOTO(s->avctx, s->dctoffset, 2 * 64 * sizeof(uint16t), fail) } } } s->picturecount = MAXPICTURECOUNT * FFMAX(1, s->avctx->threadcount); FFALLOCZORGOTO(s->avctx, s->picture, s->picturecount * sizeof(Picture), fail) for(i = 0; i < s->picturecount; i++) { avcodecgetframedefaults((AVFrame *)&s->picture[i]); } if (s->width && s->height) { FFALLOCZORGOTO(s->avctx, s->errorstatustable, mbarraysize*sizeof(uint8t), fail) if(s->codecid==CODECIDMPEG4 || (s->flags & CODECFLAGINTERLACEDME)){ /* interlaced direct mode decoding tables */ for(i=0; i<2; i++){ int j, k; for(j=0; j<2; j++){ for(k=0; k<2; k++){ FFALLOCZORGOTO(s->avctx, s->bfieldmvtablebase[i][j][k], mvtablesize * 2 * sizeof(int16t), fail) s->bfieldmvtable[i][j][k] = s->bfieldmvtablebase[i][j][k] + s->mbstride + 1; } FFALLOCZORGOTO(s->avctx, s->bfieldselecttable [i][j], mbarraysize * 2 * sizeof(uint8t), fail) FFALLOCZORGOTO(s->avctx, s->pfieldmvtablebase[i][j], mvtablesize * 2 * sizeof(int16t), fail) s->pfieldmvtable[i][j] = s->pfieldmvtablebase[i][j]+ s->mbstride + 1; } FFALLOCZORGOTO(s->avctx, s->pfieldselecttable[i], mbarraysize * 2 * sizeof(uint8t), fail) } } if (s->outformat == FMTH263) { /* cbp values */ FFALLOCZORGOTO(s->avctx, s->codedblockbase, ysize, fail); s->codedblock= s->codedblockbase + s->b8stride + 1; /* cbp, acpred, preddir */ FFALLOCZORGOTO(s->avctx, s->cbptable , mbarraysize * sizeof(uint8t), fail) FFALLOCZORGOTO(s->avctx, s->preddirtable, mbarraysize * sizeof(uint8t), fail) } if (s->h263pred || s->h263plus || !s->encoding) { /* dc values */ //MN: we need these for error resilience of intra-frames FFALLOCZORGOTO(s->avctx, s->dcvalbase, ycsize * sizeof(int16t), fail); s->dcval[0] = s->dcvalbase + s->b8stride + 1; s->dcval[1] = s->dcvalbase + ysize + s->mbstride + 1; s->dcval[2] = s->dcval[1] + csize; for(i=0;i<ycsize;i++) s->dcvalbase[i] = 1024; } /* which mb is a intra block */ FFALLOCZORGOTO(s->avctx, s->mbintratable, mbarraysize, fail); memset(s->mbintratable, 1, mbarraysize); /* init macroblock skip table */ FFALLOCZORGOTO(s->avctx, s->mbskiptable, mbarraysize+2, fail); //Note the +1 is for a quicker mpeg4 sliceend detection FFALLOCZORGOTO(s->avctx, s->prevpicttypes, PREVPICTTYPESBUFFERSIZE, fail); s->parsecontext.state= -1; if((s->avctx->debug&(FFDEBUGVISQP|FFDEBUGVISMBTYPE)) || (s->avctx->debugmv)){ s->visualizationbuffer[0] = avmalloc((s->mbwidth*16 + 2*EDGEWIDTH) * s->mbheight*16 + 2*EDGEWIDTH); s->visualizationbuffer[1] = avmalloc((s->mbwidth*16 + 2*EDGEWIDTH) * s->mbheight*16 + 2*EDGEWIDTH); s->visualizationbuffer[2] = avmalloc((s->mbwidth*16 + 2*EDGEWIDTH) * s->mbheight*16 + 2*EDGEWIDTH); } } s->contextinitialized = 1; s->threadcontext[0]= s; if (s->width && s->height) { if (s->encoding || (HAVETHREADS && s->avctx->activethreadtype&FFTHREADSLICE)) { threads = s->avctx->threadcount; for(i=1; i<threads; i++){ s->threadcontext[i]= avmalloc(sizeof(MpegEncContext)); memcpy(s->threadcontext[i], s, sizeof(MpegEncContext)); } for(i=0; i<threads; i++){ if(initduplicatecontext(s->threadcontext[i], s) < 0) goto fail; s->threadcontext[i]->startmby= (s->mbheight*(i ) + s->avctx->threadcount/2) / s->avctx->threadcount; s->threadcontext[i]->endmby = (s->mbheight*(i+1) + s->avctx->threadcount/2) / s->avctx->threadcount; } } else { if(initduplicatecontext(s, s) < 0) goto fail; s->startmby = 0; s->endmby = s->mbheight; } } return 0; fail: MPVcommonend(s); return -1; } ", "target": 0}
{"func": "int avprobeinputbuffer(AVIOContext *pb, AVInputFormat **fmt, const char *filename, void *logctx, unsigned int offset, unsigned int maxprobesize) { AVProbeData pd = { filename ? filename : \"\", NULL, -offset }; unsigned char *buf = NULL; int ret = 0, probesize; if (!maxprobesize) { maxprobesize = PROBEBUFMAX; } else if (maxprobesize > PROBEBUFMAX) { maxprobesize = PROBEBUFMAX; } else if (maxprobesize < PROBEBUFMIN) { return AVERROR(EINVAL); } if (offset >= maxprobesize) { return AVERROR(EINVAL); } for(probesize= PROBEBUFMIN; probesize<=maxprobesize && !*fmt; probesize = FFMIN(probesize<<1, FFMAX(maxprobesize, probesize+1))) { int score = probesize < maxprobesize ? AVPROBESCORERETRY : 0; int bufoffset = (probesize == PROBEBUFMIN) ? 0 : probesize>>1; void *buftmp; if (probesize < offset) { continue; } /* read probe data */ buftmp = avrealloc(buf, probesize + AVPROBEPADDINGSIZE); if(!buftmp){ avfree(buf); return AVERROR(ENOMEM); } buf=buftmp; if ((ret = avioread(pb, buf + bufoffset, probesize - bufoffset)) < 0) { /* fail if error was not end of file, otherwise, lower score */ if (ret != AVERROREOF) { avfree(buf); return ret; } score = 0; ret = 0; /* error was end of file, nothing read */ } pd.bufsize += ret; pd.buf = &buf[offset]; memset(pd.buf + pd.bufsize, 0, AVPROBEPADDINGSIZE); /* guess file format */ *fmt = avprobeinputformat2(&pd, 1, &score); if(*fmt){ if(score <= AVPROBESCORERETRY){ //this can only be true in the last iteration avlog(logctx, AVLOGWARNING, \"Format %s detected only with low score of %d, misdetection possible!\\n\", (*fmt)->name, score); }else avlog(logctx, AVLOGDEBUG, \"Format %s probed with size=%d and score=%d\\n\", (*fmt)->name, probesize, score); } } if (!*fmt) { avfree(buf); return AVERRORINVALIDDATA; } /* rewind. reuse probe buffer to avoid seeking */ ret = ffiorewindwithprobedata(pb, &buf, pd.bufsize); return ret; } ", "target": 0}
{"func": "static void slirpsmb(SlirpState* s, Monitor *mon, const char *exporteddir, struct inaddr vserveraddr) { static int instance; char smbconf[128]; char smbcmdline[128]; FILE *f; snprintf(s->smbdir, sizeof(s->smbdir), \"/tmp/qemu-smb.%ld-%d\", (long)getpid(), instance++); if (mkdir(s->smbdir, 0700) < 0) { configerror(mon, \"could not create samba server dir '%s'\\n\", s->smbdir); return; } snprintf(smbconf, sizeof(smbconf), \"%s/%s\", s->smbdir, \"smb.conf\"); f = fopen(smbconf, \"w\"); if (!f) { slirpsmbcleanup(s); configerror(mon, \"could not create samba server \" \"configuration file '%s'\\n\", smbconf); return; } fprintf(f, \"[global]\\n\" \"private dir=%s\\n\" \"smb ports=0\\n\" \"socket address=127.0.0.1\\n\" \"pid directory=%s\\n\" \"lock directory=%s\\n\" \"log file=%s/log.smbd\\n\" \"smb passwd file=%s/smbpasswd\\n\" \"security = share\\n\" \"[qemu]\\n\" \"path=%s\\n\" \"read only=no\\n\" \"guest ok=yes\\n\", s->smbdir, s->smbdir, s->smbdir, s->smbdir, s->smbdir, exporteddir ); fclose(f); snprintf(smbcmdline, sizeof(smbcmdline), \"%s -s %s\", SMBDCOMMAND, smbconf); if (slirpaddexec(s->slirp, 0, smbcmdline, &vserveraddr, 139) < 0) { slirpsmbcleanup(s); configerror(mon, \"conflicting/invalid smbserver address\\n\"); } } ", "target": 1}
{"func": "void tlbsetpage(CPUState *env, targetulong vaddr, targetphysaddrt paddr, int prot, int mmuidx, targetulong size) { PhysPageDesc *p; unsigned long pd; unsigned int index; targetulong address; targetulong codeaddress; unsigned long addend; CPUTLBEntry *te; CPUWatchpoint *wp; targetphysaddrt iotlb; assert(size >= TARGETPAGESIZE); if (size != TARGETPAGESIZE) { tlbaddlargepage(env, vaddr, size); } p = physpagefind(paddr >> TARGETPAGEBITS); if (!p) { pd = IOMEMUNASSIGNED; } else { pd = p->physoffset; } #if defined(DEBUGTLB) printf(\"tlbsetpage: vaddr=\" TARGETFMTlx \" paddr=0x%08x prot=%x idx=%d smmu=%d pd=0x%08lx\\n\", vaddr, (int)paddr, prot, mmuidx, issoftmmu, pd); #endif address = vaddr; if ((pd & ~TARGETPAGEMASK) > IOMEMROM && !(pd & IOMEMROMD)) { /* IO memory case (romd handled later) */ address |= TLBMMIO; } addend = (unsigned long)qemugetramptr(pd & TARGETPAGEMASK); if ((pd & ~TARGETPAGEMASK) <= IOMEMROM) { /* Normal RAM. */ iotlb = pd & TARGETPAGEMASK; if ((pd & ~TARGETPAGEMASK) == IOMEMRAM) iotlb |= IOMEMNOTDIRTY; else iotlb |= IOMEMROM; } else { /* IO handlers are currently passed a physical address. It would be nice to pass an offset from the base address of that region. This would avoid having to special case RAM, and avoid full address decoding in every device. We can't use the high bits of pd for this because IOMEMROMD uses these as a ram address. */ iotlb = (pd & ~TARGETPAGEMASK); if (p) { iotlb += p->regionoffset; } else { iotlb += paddr; } } codeaddress = address; /* Make accesses to pages with watchpoints go via the watchpoint trap routines. */ QTAILQFOREACH(wp, &env->watchpoints, entry) { if (vaddr == (wp->vaddr & TARGETPAGEMASK)) { iotlb = iomemwatch + paddr; /* TODO: The memory case can be optimized by not trapping reads of pages with a write breakpoint. */ address |= TLBMMIO; } } index = (vaddr >> TARGETPAGEBITS) & (CPUTLBSIZE - 1); env->iotlb[mmuidx][index] = iotlb - vaddr; te = &env->tlbtable[mmuidx][index]; te->addend = addend - vaddr; if (prot & PAGEREAD) { te->addrread = address; } else { te->addrread = -1; } if (prot & PAGEEXEC) { te->addrcode = codeaddress; } else { te->addrcode = -1; } if (prot & PAGEWRITE) { if ((pd & ~TARGETPAGEMASK) == IOMEMROM || (pd & IOMEMROMD)) { /* Write access calls the I/O callback. */ te->addrwrite = address | TLBMMIO; } else if ((pd & ~TARGETPAGEMASK) == IOMEMRAM && !cpuphysicalmemoryisdirty(pd)) { te->addrwrite = address | TLBNOTDIRTY; } else { te->addrwrite = address; } } else { te->addrwrite = -1; } } ", "target": 0}
{"func": "void *slaviointctlinit(targetphysaddrt addr, targetphysaddrt addrg, const uint32t *intbittolevel, qemuirq **irq, qemuirq **cpuirq, unsigned int cputimer) { int slaviointctliomemory, slaviointctlmiomemory, i; SLAVIOINTCTLState *s; s = qemumallocz(sizeof(SLAVIOINTCTLState)); if (!s) return NULL; s->intbittolevel = intbittolevel; for (i = 0; i < MAXCPUS; i++) { \tslaviointctliomemory = cpuregisteriomemory(0, slaviointctlmemread, slaviointctlmemwrite, s); \tcpuregisterphysicalmemory(addr + i * TARGETPAGESIZE, INTCTLSIZE, slaviointctliomemory); } slaviointctlmiomemory = cpuregisteriomemory(0, slaviointctlmmemread, slaviointctlmmemwrite, s); cpuregisterphysicalmemory(addrg, INTCTLMSIZE, slaviointctlmiomemory); registersavevm(\"slaviointctl\", addr, 1, slaviointctlsave, slaviointctlload, s); qemuregisterreset(slaviointctlreset, s); *irq = qemuallocateirqs(slaviosetirq, s, 32); *cpuirq = qemuallocateirqs(slaviosettimerirqcpu, s, MAXCPUS); s->cputimerbit = 1 << s->intbittolevel[cputimer]; slaviointctlreset(s); return s; } ", "target": 0}
{"func": "void helperfrndint(void) { ST0 = rint(ST0); } ", "target": 1}
{"func": "static void startchildren(FFStream *feed) { if (nolaunch) return; for (; feed; feed = feed->next) { if (feed->childargv && !feed->pid) { feed->pidstart = time(0); feed->pid = fork(); if (feed->pid < 0) { httplog(\"Unable to create children\\n\"); exit(1); } if (!feed->pid) { /* In child */ char pathname[1024]; char *slash; int i; avstrlcpy(pathname, myprogramname, sizeof(pathname)); slash = strrchr(pathname, '/'); if (!slash) slash = pathname; else slash++; strcpy(slash, \"ffmpeg\"); httplog(\"Launch command line: \"); httplog(\"%s \", pathname); for (i = 1; feed->childargv[i] && feed->childargv[i][0]; i++) httplog(\"%s \", feed->childargv[i]); httplog(\"\\n\"); for (i = 3; i < 256; i++) close(i); if (!ffserverdebug) { i = open(\"/dev/null\", ORDWR); if (i != -1) { dup2(i, 0); dup2(i, 1); dup2(i, 2); close(i); } } /* This is needed to make relative pathnames work */ chdir(myprogramdir); signal(SIGPIPE, SIGDFL); execvp(pathname, feed->childargv); exit(1); } } } } ", "target": 0}
{"func": "static int movseekfragment(AVFormatContext *s, AVStream *st, int64t timestamp) { MOVContext *mov = s->privdata; int i, j; if (!mov->fragmentindexcomplete) return 0; for (i = 0; i < mov->fragmentindexcount; i++) { if (mov->fragmentindexdata[i]->trackid == st->id) { MOVFragmentIndex *index = index = mov->fragmentindexdata[i]; for (j = index->itemcount - 1; j >= 0; j--) { if (index->items[j].time <= timestamp) { if (index->items[j].headersread) return 0; return movswitchroot(s, index->items[j].moofoffset); } } } } return 0; } ", "target": 1}
{"func": "static int mxfreadtrack(MXFTrack *track, ByteIOContext *pb, int tag) { switch(tag) { case 0x4801: track->trackid = getbe32(pb); break; case 0x4804: getbuffer(pb, track->tracknumber, 4); break; case 0x4B01: track->editrate.den = getbe32(pb); track->editrate.num = getbe32(pb); break; case 0x4803: getbuffer(pb, track->sequenceref, 16); break; } return 0; } ", "target": 1}
{"func": "int ffwmsparsesdpaline(AVFormatContext *s, const char *p) { int ret = 0; if (avstrstart(p, \"pgmpu:data:application/vnd.ms.wms-hdr.asfv1;base64,\", &p)) { AVIOContext pb; RTSPState *rt = s->privdata; AVDictionary *opts = NULL; int len = strlen(p) * 6 / 8; char *buf = avmallocz(len); AVInputFormat *iformat; if (!buf) return AVERROR(ENOMEM); avbase64decode(buf, p, len); if (rtpasffixheader(buf, len) < 0) avlog(s, AVLOGERROR, \"Failed to fix invalid RTSP-MS/ASF minpktsize\\n\"); initpacketizer(&pb, buf, len); if (rt->asfctx) { avformatcloseinput(&rt->asfctx); } if (!(iformat = avfindinputformat(\"asf\"))) return AVERRORDEMUXERNOTFOUND; rt->asfctx = avformatalloccontext(); if (!rt->asfctx) { avfree(buf); return AVERROR(ENOMEM); } rt->asfctx->pb = &pb; avdictset(&opts, \"noresyncsearch\", \"1\", 0); if ((ret = ffcopywhiteblacklists(rt->asfctx, s)) < 0) { avdictfree(&opts); return ret; } ret = avformatopeninput(&rt->asfctx, \"\", iformat, &opts); avdictfree(&opts); if (ret < 0) { avfree(buf); return ret; } avdictcopy(&s->metadata, rt->asfctx->metadata, 0); rt->asfpbpos = aviotell(&pb); avfree(buf); rt->asfctx->pb = NULL; } return ret; } ", "target": 1}
{"func": "static int ra144encodeframe(AVCodecContext *avctx, uint8t *frame, int bufsize, void *data) { static const uint8t sizes[LPCORDER] = {64, 32, 32, 16, 16, 8, 8, 8, 8, 4}; static const uint8t bitsizes[LPCORDER] = {6, 5, 5, 4, 4, 3, 3, 3, 3, 2}; RA144Context *ractx; PutBitContext pb; int32t lpcdata[NBLOCKS * BLOCKSIZE]; int32t lpccoefs[LPCORDER][MAXLPCORDER]; int shift[LPCORDER]; int16t blockcoefs[NBLOCKS][LPCORDER]; int lpcrefl[LPCORDER]; /**< reflection coefficients of the frame */ unsigned int reflrms[NBLOCKS]; /**< RMS of the reflection coefficients */ int energy = 0; int i, idx; if (bufsize < FRAMESIZE) { avlog(avctx, AVLOGERROR, \"output buffer too small\\n\"); return 0; } ractx = avctx->privdata; /** * Since the LPC coefficients are calculated on a frame centered over the * fourth subframe, to encode a given frame, data from the next frame is * needed. In each call to this function, the previous frame (whose data are * saved in the encoder context) is encoded, and data from the current frame * are saved in the encoder context to be used in the next function call. */ for (i = 0; i < (2 * BLOCKSIZE + BLOCKSIZE / 2); i++) { lpcdata[i] = ractx->currblock[BLOCKSIZE + BLOCKSIZE / 2 + i]; energy += (lpcdata[i] * lpcdata[i]) >> 4; } for (i = 2 * BLOCKSIZE + BLOCKSIZE / 2; i < NBLOCKS * BLOCKSIZE; i++) { lpcdata[i] = *((int16t *)data + i - 2 * BLOCKSIZE - BLOCKSIZE / 2) >> 2; energy += (lpcdata[i] * lpcdata[i]) >> 4; } energy = ffenergytab[quantize(fftsqrt(energy >> 5) >> 10, ffenergytab, 32)]; fflpccalccoefs(&ractx->lpcctx, lpcdata, NBLOCKS * BLOCKSIZE, LPCORDER, LPCORDER, 16, lpccoefs, shift, FFLPCTYPELEVINSON, 0, ORDERMETHODEST, 12, 0); for (i = 0; i < LPCORDER; i++) blockcoefs[NBLOCKS - 1][i] = -(lpccoefs[LPCORDER - 1][i] << (12 - shift[LPCORDER - 1])); /** * TODO: apply perceptual weighting of the input speech through bandwidth * expansion of the LPC filter. */ if (ffevalrefl(lpcrefl, blockcoefs[NBLOCKS - 1], avctx)) { /** * The filter is unstable: use the coefficients of the previous frame. */ ffinttoint16(blockcoefs[NBLOCKS - 1], ractx->lpccoef[1]); ffevalrefl(lpcrefl, blockcoefs[NBLOCKS - 1], avctx); } initputbits(&pb, frame, bufsize); for (i = 0; i < LPCORDER; i++) { idx = quantize(lpcrefl[i], fflpcreflcb[i], sizes[i]); putbits(&pb, bitsizes[i], idx); lpcrefl[i] = fflpcreflcb[i][idx]; } ractx->lpcreflrms[0] = ffrms(lpcrefl); ffevalcoefs(ractx->lpccoef[0], lpcrefl); reflrms[0] = ffinterp(ractx, blockcoefs[0], 1, 1, ractx->oldenergy); reflrms[1] = ffinterp(ractx, blockcoefs[1], 2, energy <= ractx->oldenergy, fftsqrt(energy * ractx->oldenergy) >> 12); reflrms[2] = ffinterp(ractx, blockcoefs[2], 3, 0, energy); reflrms[3] = ffrescalerms(ractx->lpcreflrms[0], energy); ffinttoint16(blockcoefs[NBLOCKS - 1], ractx->lpccoef[0]); putbits(&pb, 5, quantize(energy, ffenergytab, 32)); for (i = 0; i < NBLOCKS; i++) ra144encodesubblock(ractx, ractx->currblock + i * BLOCKSIZE, blockcoefs[i], reflrms[i], &pb); flushputbits(&pb); ractx->oldenergy = energy; ractx->lpcreflrms[1] = ractx->lpcreflrms[0]; FFSWAP(unsigned int *, ractx->lpccoef[0], ractx->lpccoef[1]); for (i = 0; i < NBLOCKS * BLOCKSIZE; i++) ractx->currblock[i] = *((int16t *)data + i) >> 2; return FRAMESIZE; } ", "target": 1}
{"func": "static void decode0(GetByteContext *gb, RangeCoder *rc, unsigned cumFreq, unsigned freq, unsigned totalfreq) { int t = rc->range * (uint64t)cumFreq / totalfreq; rc->code1 += t + 1; rc->range = rc->range * (uint64t)(freq + cumFreq) / totalfreq - (t + 1); while (rc->range < TOP && bytestream2getbytesleft(gb) > 0) { unsigned byte = bytestream2getbyte(gb); rc->code = (rc->code << 8) | byte; rc->code1 <<= 8; rc->range <<= 8; } } ", "target": 0}
{"func": "static int dmgopen(BlockDriverState *bs, const char *filename, int flags) { BDRVDMGState *s = bs->opaque; offt infobegin,infoend,lastinoffset,lastoutoffset; uint32t count; uint32t maxcompressedsize=1,maxsectorsperchunk=1,i; int64t offset; s->fd = open(filename, ORDONLY | OBINARY); if (s->fd < 0) return -errno; bs->readonly = 1; s->nchunks = 0; s->offsets = s->lengths = s->sectors = s->sectorcounts = NULL; /* read offset of info blocks */ offset = lseek(s->fd, -0x1d8, SEEKEND); if (offset < 0) { goto fail; } infobegin = readoff(s->fd, offset); if (infobegin == 0) { \tgoto fail; } if (readuint32(s->fd, infobegin) != 0x100) { goto fail; } count = readuint32(s->fd, infobegin + 4); if (count == 0) { goto fail; } infoend = infobegin + count; offset = infobegin + 0x100; /* read offsets */ lastinoffset = lastoutoffset = 0; while (offset < infoend) { uint32t type; \tcount = readuint32(s->fd, offset); \tif(count==0) \t goto fail; offset += 4; \ttype = readuint32(s->fd, offset); \tif (type == 0x6d697368 && count >= 244) { \t int newsize, chunkcount; offset += 4; offset += 200; \t chunkcount = (count-204)/40; \t newsize = sizeof(uint64t) * (s->nchunks + chunkcount); \t s->types = qemurealloc(s->types, newsize/2); \t s->offsets = qemurealloc(s->offsets, newsize); \t s->lengths = qemurealloc(s->lengths, newsize); \t s->sectors = qemurealloc(s->sectors, newsize); \t s->sectorcounts = qemurealloc(s->sectorcounts, newsize); \t for(i=s->nchunks;i<s->nchunks+chunkcount;i++) { \t\ts->types[i] = readuint32(s->fd, offset); \t\toffset += 4; \t\tif(s->types[i]!=0x80000005 && s->types[i]!=1 && s->types[i]!=2) { \t\t if(s->types[i]==0xffffffff) { \t\t\tlastinoffset = s->offsets[i-1]+s->lengths[i-1]; \t\t\tlastoutoffset = s->sectors[i-1]+s->sectorcounts[i-1]; \t\t } \t\t chunkcount--; \t\t i--; \t\t offset += 36; \t\t continue; \t\t} \t\toffset += 4; \t\ts->sectors[i] = lastoutoffset+readoff(s->fd, offset); \t\toffset += 8; \t\ts->sectorcounts[i] = readoff(s->fd, offset); \t\toffset += 8; \t\ts->offsets[i] = lastinoffset+readoff(s->fd, offset); \t\toffset += 8; \t\ts->lengths[i] = readoff(s->fd, offset); \t\toffset += 8; \t\tif(s->lengths[i]>maxcompressedsize) \t\t maxcompressedsize = s->lengths[i]; \t\tif(s->sectorcounts[i]>maxsectorsperchunk) \t\t maxsectorsperchunk = s->sectorcounts[i]; \t } \t s->nchunks+=chunkcount; \t} } /* initialize zlib engine */ s->compressedchunk = qemumalloc(maxcompressedsize+1); s->uncompressedchunk = qemumalloc(512*maxsectorsperchunk); if(inflateInit(&s->zstream) != ZOK) \tgoto fail; s->currentchunk = s->nchunks; return 0; fail: close(s->fd); return -1; } ", "target": 0}
{"func": "bool netrxpktisvlanstripped(struct NetRxPkt *pkt) { assert(pkt); return pkt->vlanstripped; } ", "target": 1}
{"func": "static Visitor *validatetestinitraw(TestInputVisitorData *data, const char *jsonstring) { Visitor *v; data->obj = qobjectfromjson(jsonstring); gassert(data->obj != NULL); data->qiv = qmpinputvisitornewstrict(data->obj); gassert(data->qiv != NULL); v = qmpinputgetvisitor(data->qiv); gassert(v != NULL); return v; } ", "target": 1}
{"func": "static int connectnamedsocket(const char *path) { int sockfd, size; struct sockaddrun helper; sockfd = socket(AFUNIX, SOCKSTREAM, 0); if (sockfd < 0) { fprintf(stderr, \"socket %s\\n\", strerror(errno)); return -1; } strcpy(helper.sunpath, path); helper.sunfamily = AFUNIX; size = strlen(helper.sunpath) + sizeof(helper.sunfamily); if (connect(sockfd, (struct sockaddr *)&helper, size) < 0) { fprintf(stderr, \"socket error\\n\"); return -1; } /* remove the socket for security reasons */ unlink(path); return sockfd; }", "target": 1}
{"func": "static void ehcimemwritel(void *ptr, targetphysaddrt addr, uint32t val) { EHCIState *s = ptr; uint32t *mmio = (uint32t *)(&s->mmio[addr]); uint32t old = *mmio; int i; traceusbehcimmiowritel(addr, addr2str(addr), val); /* Only aligned reads are allowed on OHCI */ if (addr & 3) { fprintf(stderr, \"usb-ehci: Mis-aligned write to addr 0x\" TARGETFMTplx \"\\n\", addr); return; if (addr >= PORTSC && addr < PORTSC + 4 * NBPORTS) { handleportstatuswrite(s, (addr-PORTSC)/4, val); traceusbehcimmiochange(addr, addr2str(addr), *mmio, old); return; if (addr < OPREGBASE) { fprintf(stderr, \"usb-ehci: write attempt to read-only register\" TARGETFMTplx \"\\n\", addr); return; /* Do any register specific pre-write processing here. */ switch(addr) { case USBCMD: if (val & USBCMDHCRESET) { ehcireset(s); val = s->usbcmd; break; /* not supporting dynamic frame list size at the moment */ if ((val & USBCMDFLS) && !(s->usbcmd & USBCMDFLS)) { fprintf(stderr, \"attempt to set frame list size -- value %d\\n\", val & USBCMDFLS); val &= ~USBCMDFLS; if (((USBCMDRUNSTOP | USBCMDPSE | USBCMDASE) & val) != ((USBCMDRUNSTOP | USBCMDPSE | USBCMDASE) & s->usbcmd)) { if (s->pstate == ESTINACTIVE) { SETLASTRUNCLOCK(s); s->usbcmd = val; /* Set usbcmd for ehciupdatehalt() */ ehciupdatehalt(s); qemumodtimer(s->frametimer, qemugetclockns(vmclock)); break; case USBSTS: val &= USBSTSROMASK; // bits 6 through 31 are RO ehciclearusbsts(s, val); // bits 0 through 5 are R/WC val = s->usbsts; ehciupdateirq(s); break; case USBINTR: val &= USBINTRMASK; break; case FRINDEX: val &= 0x00003ff8; /* frindex is 14bits and always a multiple of 8 */ break; case CONFIGFLAG: val &= 0x1; if (val) { for(i = 0; i < NBPORTS; i++) handleportownerwrite(s, i, 0); break; case PERIODICLISTBASE: if (ehciperiodicenabled(s)) { fprintf(stderr, \"ehci: PERIODIC list base register set while periodic schedule\\n\" \" is enabled and HC is enabled\\n\"); break; case ASYNCLISTADDR: if (ehciasyncenabled(s)) { fprintf(stderr, \"ehci: ASYNC list address register set while async schedule\\n\" \" is enabled and HC is enabled\\n\"); break; *mmio = val; traceusbehcimmiochange(addr, addr2str(addr), *mmio, old);", "target": 1}
{"func": "static avcold int dnxhdencodeinit(AVCodecContext *avctx) { DNXHDEncContext *ctx = avctx->privdata; int i, index, bitdepth, ret; switch (avctx->pixfmt) { case AVPIXFMTYUV422P: bitdepth = 8; break; case AVPIXFMTYUV422P10: bitdepth = 10; break; default: avlog(avctx, AVLOGERROR, \"pixel format is incompatible with DNxHD\\n\"); return AVERROR(EINVAL); } ctx->cid = ffdnxhdfindcid(avctx, bitdepth); if (!ctx->cid) { avlog(avctx, AVLOGERROR, \"video parameters incompatible with DNxHD\\n\"); return AVERROR(EINVAL); } avlog(avctx, AVLOGDEBUG, \"cid %d\\n\", ctx->cid); index = ffdnxhdgetcidtable(ctx->cid); if (index < 0) return index; ctx->cidtable = &ffdnxhdcidtable[index]; ctx->m.avctx = avctx; ctx->m.mbintra = 1; ctx->m.h263aic = 1; avctx->bitsperrawsample = ctx->cidtable->bitdepth; ffblockdspinit(&ctx->bdsp, avctx); fffdctdspinit(&ctx->m.fdsp, avctx); ffmpvidctinit(&ctx->m); ffmpegvideoencdspinit(&ctx->m.mpvencdsp, avctx); ffpixblockdspinit(&ctx->m.pdsp, avctx); if (!ctx->m.dctquantize) ctx->m.dctquantize = ffdctquantizec; if (ctx->cidtable->bitdepth == 10) { ctx->m.dctquantize = dnxhd10bitdctquantize; ctx->getpixels8x4sym = dnxhd10bitgetpixels8x4sym; ctx->blockwidthl2 = 4; } else { ctx->getpixels8x4sym = dnxhd8bitgetpixels8x4sym; ctx->blockwidthl2 = 3; } if (ARCHX86) ffdnxhdencinitx86(ctx); ctx->m.mbheight = (avctx->height + 15) / 16; ctx->m.mbwidth = (avctx->width + 15) / 16; if (avctx->flags & AVCODECFLAGINTERLACEDDCT) { ctx->interlaced = 1; ctx->m.mbheight /= 2; } ctx->m.mbnum = ctx->m.mbheight * ctx->m.mbwidth; #if FFAPIQUANTBIAS FFDISABLEDEPRECATIONWARNINGS if (ctx->intraquantbias == FFDEFAULTQUANTBIAS && avctx->intraquantbias != FFDEFAULTQUANTBIAS) ctx->intraquantbias = avctx->intraquantbias; FFENABLEDEPRECATIONWARNINGS #endif // XXX tune lbias/cbias if ((ret = dnxhdinitqmat(ctx, ctx->intraquantbias, 0)) < 0) return ret; /* Avid Nitris hardware decoder requires a minimum amount of padding * in the coding unit payload */ if (ctx->nitriscompat) ctx->minpadding = 1600; if ((ret = dnxhdinitvlc(ctx)) < 0) return ret; if ((ret = dnxhdinitrc(ctx)) < 0) return ret; FFALLOCZORGOTO(ctx->m.avctx, ctx->slicesize, ctx->m.mbheight * sizeof(uint32t), fail); FFALLOCZORGOTO(ctx->m.avctx, ctx->sliceoffs, ctx->m.mbheight * sizeof(uint32t), fail); FFALLOCZORGOTO(ctx->m.avctx, ctx->mbbits, ctx->m.mbnum * sizeof(uint16t), fail); FFALLOCZORGOTO(ctx->m.avctx, ctx->mbqscale, ctx->m.mbnum * sizeof(uint8t), fail); #if FFAPICODEDFRAME FFDISABLEDEPRECATIONWARNINGS avctx->codedframe->keyframe = 1; avctx->codedframe->picttype = AVPICTURETYPEI; FFENABLEDEPRECATIONWARNINGS #endif if (avctx->threadcount > MAXTHREADS) { avlog(avctx, AVLOGERROR, \"too many threads\\n\"); return AVERROR(EINVAL); } ctx->thread[0] = ctx; for (i = 1; i < avctx->threadcount; i++) { ctx->thread[i] = avmalloc(sizeof(DNXHDEncContext)); memcpy(ctx->thread[i], ctx, sizeof(DNXHDEncContext)); } return 0; fail: // for FFALLOCZORGOTO return AVERROR(ENOMEM); } ", "target": 0}
{"func": "static int vc1decodeframe(AVCodecContext *avctx, void *data, int *datasize, AVPacket *avpkt) { const uint8t *buf = avpkt->data; int bufsize = avpkt->size, nslices = 0, i; VC1Context *v = avctx->privdata; MpegEncContext *s = &v->s; AVFrame *pict = data; uint8t *buf2 = NULL; const uint8t *bufstart = buf, *bufstartsecondfield = NULL; int mbheight, nslices1=-1; struct { uint8t *buf; GetBitContext gb; int mbystart; } *slices = NULL, *tmp; v->secondfield = 0; if(s->flags & CODECFLAGLOWDELAY) s->lowdelay = 1; /* no supplementary picture */ if (bufsize == 0 || (bufsize == 4 && AVRB32(buf) == VC1CODEENDOFSEQ)) { /* special case for last picture */ if (s->lowdelay == 0 && s->nextpictureptr) { *pict = s->nextpictureptr->f; s->nextpictureptr = NULL; *datasize = sizeof(AVFrame); } return bufsize; } if (s->avctx->codec->capabilities&CODECCAPHWACCELVDPAU) { if (v->profile < PROFILEADVANCED) avctx->pixfmt = AVPIXFMTVDPAUWMV3; else avctx->pixfmt = AVPIXFMTVDPAUVC1; } //for advanced profile we may need to parse and unescape data if (avctx->codecid == AVCODECIDVC1 || avctx->codecid == AVCODECIDVC1IMAGE) { int bufsize2 = 0; buf2 = avmallocz(bufsize + FFINPUTBUFFERPADDINGSIZE); if (ISMARKER(AVRB32(buf))) { /* frame starts with marker and needs to be parsed */ const uint8t *start, *end, *next; int size; next = buf; for (start = buf, end = buf + bufsize; next < end; start = next) { next = findnextmarker(start + 4, end); size = next - start - 4; if (size <= 0) continue; switch (AVRB32(start)) { case VC1CODEFRAME: if (avctx->hwaccel || s->avctx->codec->capabilities&CODECCAPHWACCELVDPAU) bufstart = start; bufsize2 = vc1unescapebuffer(start + 4, size, buf2); break; case VC1CODEFIELD: { int bufsize3; if (avctx->hwaccel || s->avctx->codec->capabilities&CODECCAPHWACCELVDPAU) bufstartsecondfield = start; tmp = avrealloc(slices, sizeof(*slices) * (nslices+1)); if (!tmp) goto err; slices = tmp; slices[nslices].buf = avmallocz(bufsize + FFINPUTBUFFERPADDINGSIZE); if (!slices[nslices].buf) goto err; bufsize3 = vc1unescapebuffer(start + 4, size, slices[nslices].buf); initgetbits(&slices[nslices].gb, slices[nslices].buf, bufsize3 << 3); /* assuming that the field marker is at the exact middle, hope it's correct */ slices[nslices].mbystart = s->mbheight >> 1; nslices1 = nslices - 1; // index of the last slice of the first field nslices++; break; } case VC1CODEENTRYPOINT: /* it should be before frame data */ bufsize2 = vc1unescapebuffer(start + 4, size, buf2); initgetbits(&s->gb, buf2, bufsize2 * 8); ffvc1decodeentrypoint(avctx, v, &s->gb); break; case VC1CODESLICE: { int bufsize3; tmp = avrealloc(slices, sizeof(*slices) * (nslices+1)); if (!tmp) goto err; slices = tmp; slices[nslices].buf = avmallocz(bufsize + FFINPUTBUFFERPADDINGSIZE); if (!slices[nslices].buf) goto err; bufsize3 = vc1unescapebuffer(start + 4, size, slices[nslices].buf); initgetbits(&slices[nslices].gb, slices[nslices].buf, bufsize3 << 3); slices[nslices].mbystart = getbits(&slices[nslices].gb, 9); nslices++; break; } } } } else if (v->interlace && ((buf[0] & 0xC0) == 0xC0)) { /* WVC1 interlaced stores both fields divided by marker */ const uint8t *divider; int bufsize3; divider = findnextmarker(buf, buf + bufsize); if ((divider == (buf + bufsize)) || AVRB32(divider) != VC1CODEFIELD) { avlog(avctx, AVLOGERROR, \"Error in WVC1 interlaced frame\\n\"); goto err; } else { // found field marker, unescape second field if (avctx->hwaccel || s->avctx->codec->capabilities&CODECCAPHWACCELVDPAU) bufstartsecondfield = divider; tmp = avrealloc(slices, sizeof(*slices) * (nslices+1)); if (!tmp) goto err; slices = tmp; slices[nslices].buf = avmallocz(bufsize + FFINPUTBUFFERPADDINGSIZE); if (!slices[nslices].buf) goto err; bufsize3 = vc1unescapebuffer(divider + 4, buf + bufsize - divider - 4, slices[nslices].buf); initgetbits(&slices[nslices].gb, slices[nslices].buf, bufsize3 << 3); slices[nslices].mbystart = s->mbheight >> 1; nslices1 = nslices - 1; nslices++; } bufsize2 = vc1unescapebuffer(buf, divider - buf, buf2); } else { bufsize2 = vc1unescapebuffer(buf, bufsize, buf2); } initgetbits(&s->gb, buf2, bufsize2*8); } else initgetbits(&s->gb, buf, bufsize*8); if (v->ressprite) { v->newsprite = !getbits1(&s->gb); v->twosprites = getbits1(&s->gb); /* ressprite means a Windows Media Image stream, AVCODECID*IMAGE means we're using the sprite compositor. These are intentionally kept separate so you can get the raw sprites by using the wmv3 decoder for WMVP or the vc1 one for WVP2 */ if (avctx->codecid == AVCODECIDWMV3IMAGE || avctx->codecid == AVCODECIDVC1IMAGE) { if (v->newsprite) { // switch AVCodecContext parameters to those of the sprites avctx->width = avctx->codedwidth = v->spritewidth; avctx->height = avctx->codedheight = v->spriteheight; } else { goto image; } } } if (s->contextinitialized && (s->width != avctx->codedwidth || s->height != avctx->codedheight)) { ffvc1decodeend(avctx); } if (!s->contextinitialized) { if (ffmsmpeg4decodeinit(avctx) < 0 || ffvc1decodeinitalloctables(v) < 0) goto err; s->lowdelay = !avctx->hasbframes || v->ressprite; if (v->profile == PROFILEADVANCED) { s->hedgepos = avctx->codedwidth; s->vedgepos = avctx->codedheight; } } /* We need to set currentpictureptr before reading the header, * otherwise we cannot store anything in there. */ if (s->currentpictureptr == NULL || s->currentpictureptr->f.data[0]) { int i = fffindunusedpicture(s, 0); if (i < 0) goto err; s->currentpictureptr = &s->picture[i]; } // do parse frame header v->picheaderflag = 0; if (v->profile < PROFILEADVANCED) { if (ffvc1parseframeheader(v, &s->gb) < 0) { goto err; } } else { if (ffvc1parseframeheaderadv(v, &s->gb) < 0) { goto err; } } if (avctx->debug & FFDEBUGPICTINFO) avlog(v->s.avctx, AVLOGDEBUG, \"picttype: %c\\n\", avgetpicturetypechar(s->picttype)); if ((avctx->codecid == AVCODECIDWMV3IMAGE || avctx->codecid == AVCODECIDVC1IMAGE) && s->picttype != AVPICTURETYPEI) { avlog(v->s.avctx, AVLOGERROR, \"Sprite decoder: expected I-frame\\n\"); goto err; } if ((s->mbheight >> v->fieldmode) == 0) { avlog(v->s.avctx, AVLOGERROR, \"image too short\\n\"); goto err; } // process pulldown flags s->currentpictureptr->f.repeatpict = 0; // Pulldown flags are only valid when 'broadcast' has been set. // So ticksperframe will be 2 if (v->rff) { // repeat field s->currentpictureptr->f.repeatpict = 1; } else if (v->rptfrm) { // repeat frames s->currentpictureptr->f.repeatpict = v->rptfrm * 2; } // for skipping the frame s->currentpicture.f.picttype = s->picttype; s->currentpicture.f.keyframe = s->picttype == AVPICTURETYPEI; /* skip B-frames if we don't have reference frames */ if (s->lastpictureptr == NULL && (s->picttype == AVPICTURETYPEB || s->dropable)) { goto err; } if ((avctx->skipframe >= AVDISCARDNONREF && s->picttype == AVPICTURETYPEB) || (avctx->skipframe >= AVDISCARDNONKEY && s->picttype != AVPICTURETYPEI) || avctx->skipframe >= AVDISCARDALL) { goto end; } if (s->nextpframedamaged) { if (s->picttype == AVPICTURETYPEB) goto end; else s->nextpframedamaged = 0; } if (ffMPVframestart(s, avctx) < 0) { goto err; } v->s.currentpictureptr->f.interlacedframe = (v->fcm != PROGRESSIVE); v->s.currentpictureptr->f.topfieldfirst = v->tff; s->me.qpelput = s->dsp.putqpelpixelstab; s->me.qpelavg = s->dsp.avgqpelpixelstab; if ((CONFIGVC1VDPAUDECODER) &&s->avctx->codec->capabilities&CODECCAPHWACCELVDPAU) ffvdpauvc1decodepicture(s, bufstart, (buf + bufsize) - bufstart); else if (avctx->hwaccel) { if (v->fieldmode && bufstartsecondfield) { // decode first field s->picturestructure = PICTBOTTOMFIELD - v->tff; if (avctx->hwaccel->startframe(avctx, bufstart, bufstartsecondfield - bufstart) < 0) goto err; if (avctx->hwaccel->decodeslice(avctx, bufstart, bufstartsecondfield - bufstart) < 0) goto err; if (avctx->hwaccel->endframe(avctx) < 0) goto err; // decode second field s->gb = slices[nslices1 + 1].gb; s->picturestructure = PICTTOPFIELD + v->tff; v->secondfield = 1; v->picheaderflag = 0; if (ffvc1parseframeheaderadv(v, &s->gb) < 0) { avlog(avctx, AVLOGERROR, \"parsing header for second field failed\"); goto err; } v->s.currentpictureptr->f.picttype = v->s.picttype; if (avctx->hwaccel->startframe(avctx, bufstartsecondfield, (buf + bufsize) - bufstartsecondfield) < 0) goto err; if (avctx->hwaccel->decodeslice(avctx, bufstartsecondfield, (buf + bufsize) - bufstartsecondfield) < 0) goto err; if (avctx->hwaccel->endframe(avctx) < 0) goto err; } else { s->picturestructure = PICTFRAME; if (avctx->hwaccel->startframe(avctx, bufstart, (buf + bufsize) - bufstart) < 0) goto err; if (avctx->hwaccel->decodeslice(avctx, bufstart, (buf + bufsize) - bufstart) < 0) goto err; if (avctx->hwaccel->endframe(avctx) < 0) goto err; } } else { if (v->fcm == ILACEFRAME && s->picttype == AVPICTURETYPEB) goto err; // This codepath is still incomplete thus it is disabled fferframestart(s); v->bits = bufsize * 8; v->endmbx = s->mbwidth; if (v->fieldmode) { uint8t *tmp[2]; s->currentpicture.f.linesize[0] <<= 1; s->currentpicture.f.linesize[1] <<= 1; s->currentpicture.f.linesize[2] <<= 1; s->linesize <<= 1; s->uvlinesize <<= 1; tmp[0] = v->mvflast[0]; tmp[1] = v->mvflast[1]; v->mvflast[0] = v->mvfnext[0]; v->mvflast[1] = v->mvfnext[1]; v->mvfnext[0] = v->mvf[0]; v->mvfnext[1] = v->mvf[1]; v->mvf[0] = tmp[0]; v->mvf[1] = tmp[1]; } mbheight = s->mbheight >> v->fieldmode; for (i = 0; i <= nslices; i++) { if (i > 0 && slices[i - 1].mbystart >= mbheight) { if (v->fieldmode <= 0) { avlog(v->s.avctx, AVLOGERROR, \"Slice %d starts beyond \" \"picture boundary (%d >= %d)\\n\", i, slices[i - 1].mbystart, mbheight); continue; } v->secondfield = 1; v->blocksoff = s->mbwidth * s->mbheight << 1; v->mboff = s->mbstride * s->mbheight >> 1; } else { v->secondfield = 0; v->blocksoff = 0; v->mboff = 0; } if (i) { v->picheaderflag = 0; if (v->fieldmode && i == nslices1 + 2) { if (ffvc1parseframeheaderadv(v, &s->gb) < 0) { avlog(v->s.avctx, AVLOGERROR, \"Field header damaged\\n\"); continue; } } else if (getbits1(&s->gb)) { v->picheaderflag = 1; if (ffvc1parseframeheaderadv(v, &s->gb) < 0) { avlog(v->s.avctx, AVLOGERROR, \"Slice header damaged\\n\"); continue; } } } s->startmby = (i == 0) ? 0 : FFMAX(0, slices[i-1].mbystart % mbheight); if (!v->fieldmode || v->secondfield) s->endmby = (i == nslices ) ? mbheight : FFMIN(mbheight, slices[i].mbystart % mbheight); else s->endmby = (i <= nslices1 + 1) ? mbheight : FFMIN(mbheight, slices[i].mbystart % mbheight); if (s->endmby <= s->startmby) { avlog(v->s.avctx, AVLOGERROR, \"end mb y %d %d invalid\\n\", s->endmby, s->startmby); continue; } ffvc1decodeblocks(v); if (i != nslices) s->gb = slices[i].gb; } if (v->fieldmode) { v->secondfield = 0; if (s->picttype == AVPICTURETYPEB) { memcpy(v->mvfbase, v->mvfnextbase, 2 * (s->b8stride * (s->mbheight * 2 + 1) + s->mbstride * (s->mbheight + 1) * 2)); } s->currentpicture.f.linesize[0] >>= 1; s->currentpicture.f.linesize[1] >>= 1; s->currentpicture.f.linesize[2] >>= 1; s->linesize >>= 1; s->uvlinesize >>= 1; } avdlog(s->avctx, \"Consumed %i/%i bits\\n\", getbitscount(&s->gb), s->gb.sizeinbits); // if (getbitscount(&s->gb) > bufsize * 8) // return -1; if(s->erroroccurred && s->picttype == AVPICTURETYPEB) goto err; if(!v->fieldmode) fferframeend(s); } ffMPVframeend(s); if (avctx->codecid == AVCODECIDWMV3IMAGE || avctx->codecid == AVCODECIDVC1IMAGE) { image: avctx->width = avctx->codedwidth = v->outputwidth; avctx->height = avctx->codedheight = v->outputheight; if (avctx->skipframe >= AVDISCARDNONREF) goto end; #if CONFIGWMV3IMAGEDECODER || CONFIGVC1IMAGEDECODER if (vc1decodesprites(v, &s->gb)) goto err; #endif *pict = v->spriteoutputframe; *datasize = sizeof(AVFrame); } else { if (s->picttype == AVPICTURETYPEB || s->lowdelay) { *pict = s->currentpictureptr->f; } else if (s->lastpictureptr != NULL) { *pict = s->lastpictureptr->f; } if (s->lastpictureptr || s->lowdelay) { *datasize = sizeof(AVFrame); ffprintdebuginfo(s, pict); } } end: avfree(buf2); for (i = 0; i < nslices; i++) avfree(slices[i].buf); avfree(slices); return bufsize; err: avfree(buf2); for (i = 0; i < nslices; i++) avfree(slices[i].buf); avfree(slices); return -1; } ", "target": 0}
{"func": "void blkapplyrootstate(BlockBackend *blk, BlockDriverState *bs) { bs->detectzeroes = blk->rootstate.detectzeroes; } ", "target": 0}
{"func": "vcardemulmirrorcard(VReader *vreader) { /* * lookup certs using the CFindObjects. The Stan Cert handle won't give * us the real certs until we log in. */ PK11GenericObject *firstObj, *thisObj; int certcount; unsigned char **certs; int *certlen; VCardKey **keys; PK11SlotInfo *slot; VCard *card; slot = vcardemulreadergetslot(vreader); if (slot == NULL) { return NULL; } firstObj = PK11FindGenericObjects(slot, CKOCERTIFICATE); if (firstObj == NULL) { return NULL; } /* count the certs */ certcount = 0; for (thisObj = firstObj; thisObj; thisObj = PK11GetNextGenericObject(thisObj)) { certcount++; } if (certcount == 0) { PK11DestroyGenericObjects(firstObj); return NULL; } /* allocate the arrays */ vcardemulallocarrays(&certs, &certlen, &keys, certcount); /* fill in the arrays */ certcount = 0; for (thisObj = firstObj; thisObj; thisObj = PK11GetNextGenericObject(thisObj)) { SECItem derCert; CERTCertificate *cert; SECStatus rv; rv = PK11ReadRawAttribute(PK11TypeGeneric, thisObj, CKAVALUE, &derCert); if (rv != SECSuccess) { continue; } /* create floating temp cert. This gives us a cert structure even if * the token isn't logged in */ cert = CERTNewTempCertificate(CERTGetDefaultCertDB(), &derCert, NULL, PRFALSE, PRTRUE); SECITEMFreeItem(&derCert, PRFALSE); if (cert == NULL) { continue; } certs[certcount] = cert->derCert.data; certlen[certcount] = cert->derCert.len; keys[certcount] = vcardemulmakekey(slot, cert); certcount++; CERTDestroyCertificate(cert); /* key obj still has a reference */ } /* now create the card */ card = vcardemulmakecard(vreader, certs, certlen, keys, certcount); gfree(certs); gfree(certlen); gfree(keys); return card; } ", "target": 0}
{"func": "static uint64t megasasfwtime(void) { struct tm curtime; uint64t bcdtime; qemugettimedate(&curtime, 0); bcdtime = ((uint64t)curtime.tmsec & 0xff) << 48 | ((uint64t)curtime.tmmin & 0xff) << 40 | ((uint64t)curtime.tmhour & 0xff) << 32 | ((uint64t)curtime.tmmday & 0xff) << 24 | ((uint64t)curtime.tmmon & 0xff) << 16 | ((uint64t)(curtime.tmyear + 1900) & 0xffff); return bcdtime; } ", "target": 0}
{"func": "static OfDpaFlow *ofdpaflowalloc(uint64t cookie) { OfDpaFlow *flow; int64t now = qemuclockgetms(QEMUCLOCKVIRTUAL) / 1000; flow = gnew0(OfDpaFlow, 1); if (!flow) { return NULL; } flow->cookie = cookie; flow->mask.tblid = 0xffffffff; flow->stats.installtime = flow->stats.refreshtime = now; return flow; } ", "target": 1}
{"func": "static int rtpopen(URLContext *h, const char *uri, int flags) { RTPContext *s; int port, isoutput, ttl, localport; char hostname[256]; char buf[1024]; char path[1024]; const char *p; isoutput = (flags & URLWRONLY); s = avmallocz(sizeof(RTPContext)); if (!s) return AVERROR(ENOMEM); h->privdata = s; urlsplit(NULL, 0, NULL, 0, hostname, sizeof(hostname), &port, path, sizeof(path), uri); /* extract parameters */ ttl = -1; localport = -1; p = strchr(uri, '?'); if (p) { if (findinfotag(buf, sizeof(buf), \"ttl\", p)) { ttl = strtol(buf, NULL, 10); } if (findinfotag(buf, sizeof(buf), \"localport\", p)) { localport = strtol(buf, NULL, 10); } } buildudpurl(buf, sizeof(buf), hostname, port, localport, ttl); if (urlopen(&s->rtphd, buf, flags) < 0) goto fail; localport = udpgetlocalport(s->rtphd); /* XXX: need to open another connection if the port is not even */ /* well, should suppress localport in path */ buildudpurl(buf, sizeof(buf), hostname, port + 1, localport + 1, ttl); if (urlopen(&s->rtcphd, buf, flags) < 0) goto fail; /* just to ease handle access. XXX: need to suppress direct handle access */ s->rtpfd = udpgetfilehandle(s->rtphd); s->rtcpfd = udpgetfilehandle(s->rtcphd); h->maxpacketsize = urlgetmaxpacketsize(s->rtphd); h->isstreamed = 1; return 0; fail: if (s->rtphd) urlclose(s->rtphd); if (s->rtcphd) urlclose(s->rtcphd); avfree(s); return AVERROR(EIO); } ", "target": 0}
{"func": "static float getbandcostUPAIR7mips(struct AACEncContext *s, PutBitContext *pb, const float *in, const float *scaled, int size, int scaleidx, int cb, const float lambda, const float uplim, int *bits) { const float Q34 = ffaacpow34sftab[POWSF2ZERO - scaleidx + SCALEONEPOS - SCALEDIV512]; const float IQ = ffaacpow2sftab [POWSF2ZERO + scaleidx - SCALEONEPOS + SCALEDIV512]; int i; float cost = 0; int qc1, qc2, qc3, qc4; int curbits = 0; uint8t *pbits = (uint8t *)ffaacspectralbits[cb-1]; float *pcodes = (float *)ffaaccodebookvectors[cb-1]; for (i = 0; i < size; i += 4) { const float *vec, *vec2; int curidx, curidx2, sign1, count1, sign2, count2; int *inint = (int *)&in[i]; float *inpos = (float *)&in[i]; float di0, di1, di2, di3; int t0, t1, t2, t3, t4; qc1 = scaled[i ] * Q34 + ROUNDSTANDARD; qc2 = scaled[i+1] * Q34 + ROUNDSTANDARD; qc3 = scaled[i+2] * Q34 + ROUNDSTANDARD; qc4 = scaled[i+3] * Q34 + ROUNDSTANDARD; asm volatile ( \".set push \\n\\t\" \".set noreorder \\n\\t\" \"ori %[t4], $zero, 7 \\n\\t\" \"ori %[sign1], $zero, 0 \\n\\t\" \"ori %[sign2], $zero, 0 \\n\\t\" \"slt %[t0], %[t4], %[qc1] \\n\\t\" \"slt %[t1], %[t4], %[qc2] \\n\\t\" \"slt %[t2], %[t4], %[qc3] \\n\\t\" \"slt %[t3], %[t4], %[qc4] \\n\\t\" \"movn %[qc1], %[t4], %[t0] \\n\\t\" \"movn %[qc2], %[t4], %[t1] \\n\\t\" \"movn %[qc3], %[t4], %[t2] \\n\\t\" \"movn %[qc4], %[t4], %[t3] \\n\\t\" \"lw %[t0], 0(%[inint]) \\n\\t\" \"lw %[t1], 4(%[inint]) \\n\\t\" \"lw %[t2], 8(%[inint]) \\n\\t\" \"lw %[t3], 12(%[inint]) \\n\\t\" \"slt %[t0], %[t0], $zero \\n\\t\" \"movn %[sign1], %[t0], %[qc1] \\n\\t\" \"slt %[t2], %[t2], $zero \\n\\t\" \"movn %[sign2], %[t2], %[qc3] \\n\\t\" \"slt %[t1], %[t1], $zero \\n\\t\" \"sll %[t0], %[sign1], 1 \\n\\t\" \"or %[t0], %[t0], %[t1] \\n\\t\" \"movn %[sign1], %[t0], %[qc2] \\n\\t\" \"slt %[t3], %[t3], $zero \\n\\t\" \"sll %[t0], %[sign2], 1 \\n\\t\" \"or %[t0], %[t0], %[t3] \\n\\t\" \"movn %[sign2], %[t0], %[qc4] \\n\\t\" \"slt %[count1], $zero, %[qc1] \\n\\t\" \"slt %[t1], $zero, %[qc2] \\n\\t\" \"slt %[count2], $zero, %[qc3] \\n\\t\" \"slt %[t2], $zero, %[qc4] \\n\\t\" \"addu %[count1], %[count1], %[t1] \\n\\t\" \"addu %[count2], %[count2], %[t2] \\n\\t\" \".set pop \\n\\t\" : [qc1]\"+r\"(qc1), [qc2]\"+r\"(qc2), [qc3]\"+r\"(qc3), [qc4]\"+r\"(qc4), [sign1]\"=&r\"(sign1), [count1]\"=&r\"(count1), [sign2]\"=&r\"(sign2), [count2]\"=&r\"(count2), [t0]\"=&r\"(t0), [t1]\"=&r\"(t1), [t2]\"=&r\"(t2), [t3]\"=&r\"(t3), [t4]\"=&r\"(t4) : [inint]\"r\"(inint) : \"memory\" ); curidx = 8 * qc1; curidx += qc2; curidx2 = 8 * qc3; curidx2 += qc4; curbits += pbits[curidx]; curbits += upair7signbits[curidx]; vec = &pcodes[curidx*2]; curbits += pbits[curidx2]; curbits += upair7signbits[curidx2]; vec2 = &pcodes[curidx2*2]; asm volatile ( \".set push \\n\\t\" \".set noreorder \\n\\t\" \"lwc1 %[di0], 0(%[inpos]) \\n\\t\" \"lwc1 %[di1], 4(%[inpos]) \\n\\t\" \"lwc1 %[di2], 8(%[inpos]) \\n\\t\" \"lwc1 %[di3], 12(%[inpos]) \\n\\t\" \"abs.s %[di0], %[di0] \\n\\t\" \"abs.s %[di1], %[di1] \\n\\t\" \"abs.s %[di2], %[di2] \\n\\t\" \"abs.s %[di3], %[di3] \\n\\t\" \"lwc1 $f0, 0(%[vec]) \\n\\t\" \"lwc1 $f1, 4(%[vec]) \\n\\t\" \"lwc1 $f2, 0(%[vec2]) \\n\\t\" \"lwc1 $f3, 4(%[vec2]) \\n\\t\" \"nmsub.s %[di0], %[di0], $f0, %[IQ] \\n\\t\" \"nmsub.s %[di1], %[di1], $f1, %[IQ] \\n\\t\" \"nmsub.s %[di2], %[di2], $f2, %[IQ] \\n\\t\" \"nmsub.s %[di3], %[di3], $f3, %[IQ] \\n\\t\" \".set pop \\n\\t\" : [di0]\"=&f\"(di0), [di1]\"=&f\"(di1), [di2]\"=&f\"(di2), [di3]\"=&f\"(di3) : [inpos]\"r\"(inpos), [vec]\"r\"(vec), [vec2]\"r\"(vec2), [IQ]\"f\"(IQ) : \"$f0\", \"$f1\", \"$f2\", \"$f3\", \"memory\" ); cost += di0 * di0 + di1 * di1 + di2 * di2 + di3 * di3; } if (bits) *bits = curbits; return cost * lambda + curbits; } ", "target": 1}
{"func": "QObject *jsonparserparseerr(QList *tokens, valist *ap, Error **errp) { JSONParserContext ctxt = {}; QList *working = qlistcopy(tokens); QObject *result; result = parsevalue(&ctxt, &working, ap); QDECREF(working); errorpropagate(errp, ctxt.err); return result; } ", "target": 1}
{"func": "static int initdirectories(BDRVVVFATState* s, const char *dirname, int heads, int secs, Error **errp) { bootsectort* bootsector; mappingt* mapping; unsigned int i; unsigned int cluster; memset(&(s->firstsectors[0]),0,0x40*0x200); s->clustersize=s->sectorspercluster*0x200; s->clusterbuffer=gmalloc(s->clustersize); /* * The formula: sc = spf+1+spf*spc*(512*8/fattype), * where sc is sectorcount, * spf is sectorsperfat, * spc is sectorsperclusters, and * fattype = 12, 16 or 32. */ i = 1+s->sectorspercluster*0x200*8/s->fattype; s->sectorsperfat=(s->sectorcount+i)/i; /* round up */ s->offsettofat = s->offsettobootsector + 1; s->offsettorootdir = s->offsettofat + s->sectorsperfat * 2; arrayinit(&(s->mapping),sizeof(mappingt)); arrayinit(&(s->directory),sizeof(direntryt)); /* add volume label */ { direntryt* entry=arraygetnext(&(s->directory)); entry->attributes=0x28; /* archive | volume label */ memcpy(entry->name, s->volumelabel, sizeof(entry->name)); } /* Now build FAT, and write back information into directory */ initfat(s); s->clustercount=sector2cluster(s, s->sectorcount); mapping = arraygetnext(&(s->mapping)); mapping->begin = 0; mapping->dirindex = 0; mapping->info.dir.parentmappingindex = -1; mapping->firstmappingindex = -1; mapping->path = gstrdup(dirname); i = strlen(mapping->path); if (i > 0 && mapping->path[i - 1] == '/') mapping->path[i - 1] = '\\0'; mapping->mode = MODEDIRECTORY; mapping->readonly = 0; s->path = mapping->path; for (i = 0, cluster = 0; i < s->mapping.next; i++) { /* MS-DOS expects the FAT to be 0 for the root directory * (except for the media byte). */ /* LATER TODO: still true for FAT32? */ int fixfat = (i != 0); mapping = arrayget(&(s->mapping), i); if (mapping->mode & MODEDIRECTORY) { mapping->begin = cluster; if(readdirectory(s, i)) { errorsetg(errp, \"Could not read directory %s\", mapping->path); return -1; } mapping = arrayget(&(s->mapping), i); } else { assert(mapping->mode == MODEUNDEFINED); mapping->mode=MODENORMAL; mapping->begin = cluster; if (mapping->end > 0) { direntryt* direntry = arrayget(&(s->directory), mapping->dirindex); mapping->end = cluster + 1 + (mapping->end-1)/s->clustersize; setbeginofdirentry(direntry, mapping->begin); } else { mapping->end = cluster + 1; fixfat = 0; } } assert(mapping->begin < mapping->end); /* next free cluster */ cluster = mapping->end; if(cluster > s->clustercount) { errorsetg(errp, \"Directory does not fit in FAT%d (capacity %.2f MB)\", s->fattype, s->sectorcount / 2000.0); return -1; } /* fix fat for entry */ if (fixfat) { int j; for(j = mapping->begin; j < mapping->end - 1; j++) fatset(s, j, j+1); fatset(s, mapping->end - 1, s->maxfatvalue); } } mapping = arrayget(&(s->mapping), 0); s->sectorsofrootdirectory = mapping->end * s->sectorspercluster; s->lastclusterofrootdirectory = mapping->end; /* the FAT signature */ fatset(s,0,s->maxfatvalue); fatset(s,1,s->maxfatvalue); s->currentmapping = NULL; bootsector = (bootsectort *)(s->firstsectors + s->offsettobootsector * 0x200); bootsector->jump[0]=0xeb; bootsector->jump[1]=0x3e; bootsector->jump[2]=0x90; memcpy(bootsector->name,\"QEMU \",8); bootsector->sectorsize=cputole16(0x200); bootsector->sectorspercluster=s->sectorspercluster; bootsector->reservedsectors=cputole16(1); bootsector->numberoffats=0x2; /* number of FATs */ bootsector->rootentries=cputole16(s->sectorsofrootdirectory*0x10); bootsector->totalsectors16=s->sectorcount>0xffff?0:cputole16(s->sectorcount); /* media descriptor: hard disk=0xf8, floppy=0xf0 */ bootsector->mediatype = (s->offsettobootsector > 0 ? 0xf8 : 0xf0); s->fat.pointer[0] = bootsector->mediatype; bootsector->sectorsperfat=cputole16(s->sectorsperfat); bootsector->sectorspertrack = cputole16(secs); bootsector->numberofheads = cputole16(heads); bootsector->hiddensectors = cputole32(s->offsettobootsector); bootsector->totalsectors=cputole32(s->sectorcount>0xffff?s->sectorcount:0); /* LATER TODO: if FAT32, this is wrong */ /* drivenumber: fda=0, hda=0x80 */ bootsector->u.fat16.drivenumber = s->offsettobootsector == 0 ? 0 : 0x80; bootsector->u.fat16.signature=0x29; bootsector->u.fat16.id=cputole32(0xfabe1afd); memcpy(bootsector->u.fat16.volumelabel, s->volumelabel, sizeof(bootsector->u.fat16.volumelabel)); memcpy(bootsector->u.fat16.fattype, s->fattype == 12 ? \"FAT12 \" : \"FAT16 \", 8); bootsector->magic[0]=0x55; bootsector->magic[1]=0xaa; return 0; } ", "target": 1}
{"func": "void pxa25xtimerinit(targetphysaddrt base, qemuirq *irqs) { pxa2xxtimerinfo *s = pxa2xxtimerinit(base, irqs); s->freq = PXA25XFREQ; s->tm4 = NULL; } ", "target": 0}
{"func": "struct omapmpustates *omap2420mpuinit(unsigned long sdramsize, const char *core) { struct omapmpustates *s = (struct omapmpustates *) gmalloc0(sizeof(struct omapmpustates)); ramaddrt srambase, q2base; qemuirq *cpuirq; qemuirq dmairqs[4]; DriveInfo *dinfo; int i; SysBusDevice *busdev; struct omaptargetagents *ta; /* Core */ s->mpumodel = omap2420; s->env = cpuinit(core ?: \"arm1136-r2\"); if (!s->env) { fprintf(stderr, \"Unable to find CPU definition\\n\"); exit(1); } s->sdramsize = sdramsize; s->sramsize = OMAP242XSRAMSIZE; s->wakeup = qemuallocateirqs(omapmpuwakeup, s, 1)[0]; /* Clocks */ omapclkinit(s); /* Memory-mapped stuff */ cpuregisterphysicalmemory(OMAP2Q2BASE, s->sdramsize, (q2base = qemuramalloc(NULL, \"omap2.dram\", s->sdramsize)) | IOMEMRAM); cpuregisterphysicalmemory(OMAP2SRAMBASE, s->sramsize, (srambase = qemuramalloc(NULL, \"omap2.sram\", s->sramsize)) | IOMEMRAM); s->l4 = omapl4init(OMAP2L4BASE, 54); /* Actually mapped at any 2K boundary in the ARM11 private-peripheral if */ cpuirq = armpicinitcpu(s->env); s->ih[0] = omap2inthinit(0x480fe000, 0x1000, 3, &s->irq[0], cpuirq[ARMPICCPUIRQ], cpuirq[ARMPICCPUFIQ], omapfindclk(s, \"mpuintcfclk\"), omapfindclk(s, \"mpuintciclk\")); s->prcm = omapprcminit(omapl4tao(s->l4, 3), s->irq[0][OMAPINT24XXPRCMMPUIRQ], NULL, NULL, s); s->sysc = omapsysctlinit(omapl4tao(s->l4, 1), omapfindclk(s, \"omapctrliclk\"), s); for (i = 0; i < 4; i ++) dmairqs[i] = s->irq[omap2dmairqmap[i].ih][omap2dmairqmap[i].intr]; s->dma = omapdma4init(0x48056000, dmairqs, s, 256, 32, omapfindclk(s, \"sdmaiclk\"), omapfindclk(s, \"sdmafclk\")); s->port->addrvalid = omap2validateaddr; /* Register SDRAM and SRAM ports for fast DMA transfers. */ socdmaportaddmem(s->dma, qemugetramptr(q2base), OMAP2Q2BASE, s->sdramsize); socdmaportaddmem(s->dma, qemugetramptr(srambase), OMAP2SRAMBASE, s->sramsize); s->uart[0] = omap2uartinit(omapl4ta(s->l4, 19), s->irq[0][OMAPINT24XXUART1IRQ], omapfindclk(s, \"uart1fclk\"), omapfindclk(s, \"uart1iclk\"), s->drq[OMAP24XXDMAUART1TX], s->drq[OMAP24XXDMAUART1RX], \"uart1\", serialhds[0]); s->uart[1] = omap2uartinit(omapl4ta(s->l4, 20), s->irq[0][OMAPINT24XXUART2IRQ], omapfindclk(s, \"uart2fclk\"), omapfindclk(s, \"uart2iclk\"), s->drq[OMAP24XXDMAUART2TX], s->drq[OMAP24XXDMAUART2RX], \"uart2\", serialhds[0] ? serialhds[1] : NULL); s->uart[2] = omap2uartinit(omapl4ta(s->l4, 21), s->irq[0][OMAPINT24XXUART3IRQ], omapfindclk(s, \"uart3fclk\"), omapfindclk(s, \"uart3iclk\"), s->drq[OMAP24XXDMAUART3TX], s->drq[OMAP24XXDMAUART3RX], \"uart3\", serialhds[0] && serialhds[1] ? serialhds[2] : NULL); s->gptimer[0] = omapgptimerinit(omapl4ta(s->l4, 7), s->irq[0][OMAPINT24XXGPTIMER1], omapfindclk(s, \"wugpt1clk\"), omapfindclk(s, \"wul4iclk\")); s->gptimer[1] = omapgptimerinit(omapl4ta(s->l4, 8), s->irq[0][OMAPINT24XXGPTIMER2], omapfindclk(s, \"coregpt2clk\"), omapfindclk(s, \"corel4iclk\")); s->gptimer[2] = omapgptimerinit(omapl4ta(s->l4, 22), s->irq[0][OMAPINT24XXGPTIMER3], omapfindclk(s, \"coregpt3clk\"), omapfindclk(s, \"corel4iclk\")); s->gptimer[3] = omapgptimerinit(omapl4ta(s->l4, 23), s->irq[0][OMAPINT24XXGPTIMER4], omapfindclk(s, \"coregpt4clk\"), omapfindclk(s, \"corel4iclk\")); s->gptimer[4] = omapgptimerinit(omapl4ta(s->l4, 24), s->irq[0][OMAPINT24XXGPTIMER5], omapfindclk(s, \"coregpt5clk\"), omapfindclk(s, \"corel4iclk\")); s->gptimer[5] = omapgptimerinit(omapl4ta(s->l4, 25), s->irq[0][OMAPINT24XXGPTIMER6], omapfindclk(s, \"coregpt6clk\"), omapfindclk(s, \"corel4iclk\")); s->gptimer[6] = omapgptimerinit(omapl4ta(s->l4, 26), s->irq[0][OMAPINT24XXGPTIMER7], omapfindclk(s, \"coregpt7clk\"), omapfindclk(s, \"corel4iclk\")); s->gptimer[7] = omapgptimerinit(omapl4ta(s->l4, 27), s->irq[0][OMAPINT24XXGPTIMER8], omapfindclk(s, \"coregpt8clk\"), omapfindclk(s, \"corel4iclk\")); s->gptimer[8] = omapgptimerinit(omapl4ta(s->l4, 28), s->irq[0][OMAPINT24XXGPTIMER9], omapfindclk(s, \"coregpt9clk\"), omapfindclk(s, \"corel4iclk\")); s->gptimer[9] = omapgptimerinit(omapl4ta(s->l4, 29), s->irq[0][OMAPINT24XXGPTIMER10], omapfindclk(s, \"coregpt10clk\"), omapfindclk(s, \"corel4iclk\")); s->gptimer[10] = omapgptimerinit(omapl4ta(s->l4, 30), s->irq[0][OMAPINT24XXGPTIMER11], omapfindclk(s, \"coregpt11clk\"), omapfindclk(s, \"corel4iclk\")); s->gptimer[11] = omapgptimerinit(omapl4ta(s->l4, 31), s->irq[0][OMAPINT24XXGPTIMER12], omapfindclk(s, \"coregpt12clk\"), omapfindclk(s, \"corel4iclk\")); omaptapinit(omapl4ta(s->l4, 2), s); s->synctimer = omapsynctimerinit(omapl4tao(s->l4, 2), s, omapfindclk(s, \"clk32-kHz\"), omapfindclk(s, \"corel4iclk\")); s->i2c[0] = omap2i2cinit(omapl4tao(s->l4, 5), s->irq[0][OMAPINT24XXI2C1IRQ], &s->drq[OMAP24XXDMAI2C1TX], omapfindclk(s, \"i2c1.fclk\"), omapfindclk(s, \"i2c1.iclk\")); s->i2c[1] = omap2i2cinit(omapl4tao(s->l4, 6), s->irq[0][OMAPINT24XXI2C2IRQ], &s->drq[OMAP24XXDMAI2C2TX], omapfindclk(s, \"i2c2.fclk\"), omapfindclk(s, \"i2c2.iclk\")); s->gpio = qdevcreate(NULL, \"omap2-gpio\"); qdevpropsetint32(s->gpio, \"mpumodel\", s->mpumodel); qdevpropsetptr(s->gpio, \"iclk\", omapfindclk(s, \"gpioiclk\")); qdevpropsetptr(s->gpio, \"fclk0\", omapfindclk(s, \"gpio1dbclk\")); qdevpropsetptr(s->gpio, \"fclk1\", omapfindclk(s, \"gpio2dbclk\")); qdevpropsetptr(s->gpio, \"fclk2\", omapfindclk(s, \"gpio3dbclk\")); qdevpropsetptr(s->gpio, \"fclk3\", omapfindclk(s, \"gpio4dbclk\")); if (s->mpumodel == omap2430) { qdevpropsetptr(s->gpio, \"fclk4\", omapfindclk(s, \"gpio5dbclk\")); } qdevinitnofail(s->gpio); busdev = sysbusfromqdev(s->gpio); sysbusconnectirq(busdev, 0, s->irq[0][OMAPINT24XXGPIOBANK1]); sysbusconnectirq(busdev, 3, s->irq[0][OMAPINT24XXGPIOBANK2]); sysbusconnectirq(busdev, 6, s->irq[0][OMAPINT24XXGPIOBANK3]); sysbusconnectirq(busdev, 9, s->irq[0][OMAPINT24XXGPIOBANK4]); ta = omapl4ta(s->l4, 3); sysbusmmiomap(busdev, 0, omapl4regionbase(ta, 1)); sysbusmmiomap(busdev, 1, omapl4regionbase(ta, 0)); sysbusmmiomap(busdev, 2, omapl4regionbase(ta, 2)); sysbusmmiomap(busdev, 3, omapl4regionbase(ta, 4)); sysbusmmiomap(busdev, 4, omapl4regionbase(ta, 5)); s->sdrc = omapsdrcinit(0x68009000); s->gpmc = omapgpmcinit(s, 0x6800a000, s->irq[0][OMAPINT24XXGPMCIRQ], s->drq[OMAP24XXDMAGPMC]); dinfo = driveget(IFSD, 0, 0); if (!dinfo) { fprintf(stderr, \"qemu: missing SecureDigital device\\n\"); exit(1); } s->mmc = omap2mmcinit(omapl4tao(s->l4, 9), dinfo->bdrv, s->irq[0][OMAPINT24XXMMCIRQ], &s->drq[OMAP24XXDMAMMC1TX], omapfindclk(s, \"mmcfclk\"), omapfindclk(s, \"mmciclk\")); s->mcspi[0] = omapmcspiinit(omapl4ta(s->l4, 35), 4, s->irq[0][OMAPINT24XXMCSPI1IRQ], &s->drq[OMAP24XXDMASPI1TX0], omapfindclk(s, \"spi1fclk\"), omapfindclk(s, \"spi1iclk\")); s->mcspi[1] = omapmcspiinit(omapl4ta(s->l4, 36), 2, s->irq[0][OMAPINT24XXMCSPI2IRQ], &s->drq[OMAP24XXDMASPI2TX0], omapfindclk(s, \"spi2fclk\"), omapfindclk(s, \"spi2iclk\")); s->dss = omapdssinit(omapl4ta(s->l4, 10), 0x68000800, /* XXX wire MIRQ25, DL2IRQ30 and IIRQ13 together */ s->irq[0][OMAPINT24XXDSSIRQ], s->drq[OMAP24XXDMADSS], omapfindclk(s, \"dssclk1\"), omapfindclk(s, \"dssclk2\"), omapfindclk(s, \"dss54mclk\"), omapfindclk(s, \"dssl3iclk\"), omapfindclk(s, \"dssl4iclk\")); omapstiinit(omapl4ta(s->l4, 18), 0x54000000, s->irq[0][OMAPINT24XXSTI], omapfindclk(s, \"emulck\"), serialhds[0] && serialhds[1] && serialhds[2] ? serialhds[3] : NULL); s->eac = omapeacinit(omapl4ta(s->l4, 32), s->irq[0][OMAPINT24XXEACIRQ], /* Ten consecutive lines */ &s->drq[OMAP24XXDMAEACACRD], omapfindclk(s, \"func96mclk\"), omapfindclk(s, \"corel4iclk\")); /* All register mappings (includin those not currenlty implemented): * SystemControlMod\t48000000 - 48000fff * SystemControlL4\t48001000 - 48001fff * 32kHz Timer Mod\t48004000 - 48004fff * 32kHz Timer L4\t48005000 - 48005fff * PRCM ModA\t48008000 - 480087ff * PRCM ModB\t48008800 - 48008fff * PRCM L4\t\t48009000 - 48009fff * TEST-BCM Mod\t48012000 - 48012fff * TEST-BCM L4\t48013000 - 48013fff * TEST-TAP Mod\t48014000 - 48014fff * TEST-TAP L4\t48015000 - 48015fff * GPIO1 Mod\t48018000 - 48018fff * GPIO Top\t\t48019000 - 48019fff * GPIO2 Mod\t4801a000 - 4801afff * GPIO L4\t\t4801b000 - 4801bfff * GPIO3 Mod\t4801c000 - 4801cfff * GPIO4 Mod\t4801e000 - 4801efff * WDTIMER1 Mod\t48020000 - 48010fff * WDTIMER Top\t48021000 - 48011fff * WDTIMER2 Mod\t48022000 - 48012fff * WDTIMER L4\t48023000 - 48013fff * WDTIMER3 Mod\t48024000 - 48014fff * WDTIMER3 L4\t48025000 - 48015fff * WDTIMER4 Mod\t48026000 - 48016fff * WDTIMER4 L4\t48027000 - 48017fff * GPTIMER1 Mod\t48028000 - 48018fff * GPTIMER1 L4\t48029000 - 48019fff * GPTIMER2 Mod\t4802a000 - 4801afff * GPTIMER2 L4\t4802b000 - 4801bfff * L4-Config AP\t48040000 - 480407ff * L4-Config IP\t48040800 - 48040fff * L4-Config LA\t48041000 - 48041fff * ARM11ETB Mod\t48048000 - 48049fff * ARM11ETB L4\t4804a000 - 4804afff * DISPLAY Top\t48050000 - 480503ff * DISPLAY DISPC\t48050400 - 480507ff * DISPLAY RFBI\t48050800 - 48050bff * DISPLAY VENC\t48050c00 - 48050fff * DISPLAY L4\t48051000 - 48051fff * CAMERA Top\t48052000 - 480523ff * CAMERA core\t48052400 - 480527ff * CAMERA DMA\t48052800 - 48052bff * CAMERA MMU\t48052c00 - 48052fff * CAMERA L4\t48053000 - 48053fff * SDMA Mod\t\t48056000 - 48056fff * SDMA L4\t\t48057000 - 48057fff * SSI Top\t\t48058000 - 48058fff * SSI GDD\t\t48059000 - 48059fff * SSI Port1\t4805a000 - 4805afff * SSI Port2\t4805b000 - 4805bfff * SSI L4\t\t4805c000 - 4805cfff * USB Mod\t\t4805e000 - 480fefff * USB L4\t\t4805f000 - 480fffff * WINTRACER1 Mod\t48060000 - 48060fff * WINTRACER1 L4\t48061000 - 48061fff * WINTRACER2 Mod\t48062000 - 48062fff * WINTRACER2 L4\t48063000 - 48063fff * WINTRACER3 Mod\t48064000 - 48064fff * WINTRACER3 L4\t48065000 - 48065fff * WINTRACER4 Top\t48066000 - 480660ff * WINTRACER4 ETT\t48066100 - 480661ff * WINTRACER4 WT\t48066200 - 480662ff * WINTRACER4 L4\t48067000 - 48067fff * XTI Mod\t\t48068000 - 48068fff * XTI L4\t\t48069000 - 48069fff * UART1 Mod\t4806a000 - 4806afff * UART1 L4\t\t4806b000 - 4806bfff * UART2 Mod\t4806c000 - 4806cfff * UART2 L4\t\t4806d000 - 4806dfff * UART3 Mod\t4806e000 - 4806efff * UART3 L4\t\t4806f000 - 4806ffff * I2C1 Mod\t\t48070000 - 48070fff * I2C1 L4\t\t48071000 - 48071fff * I2C2 Mod\t\t48072000 - 48072fff * I2C2 L4\t\t48073000 - 48073fff * McBSP1 Mod\t48074000 - 48074fff * McBSP1 L4\t48075000 - 48075fff * McBSP2 Mod\t48076000 - 48076fff * McBSP2 L4\t48077000 - 48077fff * GPTIMER3 Mod\t48078000 - 48078fff * GPTIMER3 L4\t48079000 - 48079fff * GPTIMER4 Mod\t4807a000 - 4807afff * GPTIMER4 L4\t4807b000 - 4807bfff * GPTIMER5 Mod\t4807c000 - 4807cfff * GPTIMER5 L4\t4807d000 - 4807dfff * GPTIMER6 Mod\t4807e000 - 4807efff * GPTIMER6 L4\t4807f000 - 4807ffff * GPTIMER7 Mod\t48080000 - 48080fff * GPTIMER7 L4\t48081000 - 48081fff * GPTIMER8 Mod\t48082000 - 48082fff * GPTIMER8 L4\t48083000 - 48083fff * GPTIMER9 Mod\t48084000 - 48084fff * GPTIMER9 L4\t48085000 - 48085fff * GPTIMER10 Mod\t48086000 - 48086fff * GPTIMER10 L4\t48087000 - 48087fff * GPTIMER11 Mod\t48088000 - 48088fff * GPTIMER11 L4\t48089000 - 48089fff * GPTIMER12 Mod\t4808a000 - 4808afff * GPTIMER12 L4\t4808b000 - 4808bfff * EAC Mod\t\t48090000 - 48090fff * EAC L4\t\t48091000 - 48091fff * FAC Mod\t\t48092000 - 48092fff * FAC L4\t\t48093000 - 48093fff * MAILBOX Mod\t48094000 - 48094fff * MAILBOX L4\t48095000 - 48095fff * SPI1 Mod\t\t48098000 - 48098fff * SPI1 L4\t\t48099000 - 48099fff * SPI2 Mod\t\t4809a000 - 4809afff * SPI2 L4\t\t4809b000 - 4809bfff * MMC/SDIO Mod\t4809c000 - 4809cfff * MMC/SDIO L4\t4809d000 - 4809dfff * MSPRO Mod\t4809e000 - 4809efff * MSPRO L4\t4809f000 - 4809ffff * RNG Mod\t\t480a0000 - 480a0fff * RNG L4\t\t480a1000 - 480a1fff * DES3DES Mod\t480a2000 - 480a2fff * DES3DES L4\t480a3000 - 480a3fff * SHA1MD5 Mod\t480a4000 - 480a4fff * SHA1MD5 L4\t480a5000 - 480a5fff * AES Mod\t\t480a6000 - 480a6fff * AES L4\t\t480a7000 - 480a7fff * PKA Mod\t\t480a8000 - 480a9fff * PKA L4\t\t480aa000 - 480aafff * MG Mod\t\t480b0000 - 480b0fff * MG L4\t\t480b1000 - 480b1fff * HDQ/1-wire Mod\t480b2000 - 480b2fff * HDQ/1-wire L4\t480b3000 - 480b3fff * MPU interrupt\t480fe000 - 480fefff * STI channel base\t54000000 - 5400ffff * IVA RAM\t\t5c000000 - 5c01ffff * IVA ROM\t\t5c020000 - 5c027fff * IMGBUFA\t5c040000 - 5c040fff * IMGBUFB\t5c042000 - 5c042fff * VLCDS\t\t5c048000 - 5c0487ff * IMXCOEF\t\t5c049000 - 5c04afff * IMXCMD\t\t5c051000 - 5c051fff * VLCDQ\t\t5c053000 - 5c0533ff * VLCDH\t\t5c054000 - 5c054fff * SEQCMD\t\t5c055000 - 5c055fff * IMXREG\t\t5c056000 - 5c0560ff * VLCDREG\t\t5c056100 - 5c0561ff * SEQREG\t\t5c056200 - 5c0562ff * IMGBUFREG\t5c056300 - 5c0563ff * SEQIRQREG\t5c056400 - 5c0564ff * OCPREG\t\t5c060000 - 5c060fff * SYSCREG\t\t5c070000 - 5c070fff * MMUREG\t\t5d000000 - 5d000fff * sDMA R\t\t68000400 - 680005ff * sDMA W\t\t68000600 - 680007ff * Display Control\t68000800 - 680009ff * DSP subsystem\t68000a00 - 68000bff * MPU subsystem\t68000c00 - 68000dff * IVA subsystem\t68001000 - 680011ff * USB\t\t68001200 - 680013ff * Camera\t\t68001400 - 680015ff * VLYNQ (firewall)\t68001800 - 68001bff * VLYNQ\t\t68001e00 - 68001fff * SSI\t\t68002000 - 680021ff * L4\t\t68002400 - 680025ff * DSP (firewall)\t68002800 - 68002bff * DSP subsystem\t68002e00 - 68002fff * IVA (firewall)\t68003000 - 680033ff * IVA\t\t68003600 - 680037ff * GFX\t\t68003a00 - 68003bff * CMDWR emulation\t68003c00 - 68003dff * SMS\t\t68004000 - 680041ff * OCM\t\t68004200 - 680043ff * GPMC\t\t68004400 - 680045ff * RAM (firewall)\t68005000 - 680053ff * RAM (err login)\t68005400 - 680057ff * ROM (firewall)\t68005800 - 68005bff * ROM (err login)\t68005c00 - 68005fff * GPMC (firewall)\t68006000 - 680063ff * GPMC (err login)\t68006400 - 680067ff * SMS (err login)\t68006c00 - 68006fff * SMS registers\t68008000 - 68008fff * SDRC registers\t68009000 - 68009fff * GPMC registers\t6800a000 6800afff */ qemuregisterreset(omap2mpureset, s); return s; } ", "target": 0}
{"func": "static void tcgoutqemuldslowpath (TCGContext *s, TCGLabelQemuLdst *label) { int sbits; int ir; int opc = label->opc; int memindex = label->memindex; int datareg = label->dataloreg; int datareg2 = label->datahireg; int addrreg = label->addrloreg; uint8t *raddr = label->raddr; uint8t **labelptr = &label->labelptr[0]; sbits = opc & 3; /* resolve label address */ relocpc14 (labelptr[0], (tcgtargetlong) s->codeptr); /* slow path */ ir = 3; tcgoutmov (s, TCGTYPEI32, ir++, TCGAREG0); #if TARGETLONGBITS == 32 tcgoutmov (s, TCGTYPEI32, ir++, addrreg); #else #ifdef TCGTARGETCALLALIGNARGS ir |= 1; #endif tcgoutmov (s, TCGTYPEI32, ir++, label->addrhireg); tcgoutmov (s, TCGTYPEI32, ir++, addrreg); #endif tcgoutmovi (s, TCGTYPEI32, ir, memindex); tcgoutcall (s, (tcgtargetlong) qemuldhelpers[sbits], 1); tcgout32 (s, B | 8); tcgout32 (s, (tcgtargetlong) raddr); switch (opc) { case 0|4: tcgout32 (s, EXTSB | RA (datareg) | RS (3)); break; case 1|4: tcgout32 (s, EXTSH | RA (datareg) | RS (3)); break; case 0: case 1: case 2: if (datareg != 3) tcgoutmov (s, TCGTYPEI32, datareg, 3); break; case 3: if (datareg == 3) { if (datareg2 == 4) { tcgoutmov (s, TCGTYPEI32, 0, 4); tcgoutmov (s, TCGTYPEI32, 4, 3); tcgoutmov (s, TCGTYPEI32, 3, 0); } else { tcgoutmov (s, TCGTYPEI32, datareg2, 3); tcgoutmov (s, TCGTYPEI32, 3, 4); } } else { if (datareg != 4) tcgoutmov (s, TCGTYPEI32, datareg, 4); if (datareg2 != 3) tcgoutmov (s, TCGTYPEI32, datareg2, 3); } break; } /* Jump to the code corresponding to next IR of qemust */ tcgoutb (s, 0, (tcgtargetlong) raddr); } ", "target": 0}
{"func": "static int nbdnegotiatehandleinfo(NBDClient *client, uint32t length, uint32t opt, uint16t myflags, Error **errp) { int rc; char name[NBDMAXNAMESIZE + 1]; NBDExport *exp; uint16t requests; uint16t request; uint32t namelen; bool sendname = false; bool blocksize = false; uint32t sizes[3]; char buf[sizeof(uint64t) + sizeof(uint16t)]; const char *msg; /* Client sends: 4 bytes: L, name length (can be 0) L bytes: export name 2 bytes: N, number of requests (can be 0) N * 2 bytes: N requests */ if (length < sizeof(namelen) + sizeof(requests)) { msg = \"overall request too short\"; goto invalid; } if (nbdread(client->ioc, &namelen, sizeof(namelen), errp) < 0) { return -EIO; } be32tocpus(&namelen); length -= sizeof(namelen); if (namelen > length - sizeof(requests) || (length - namelen) % 2) { msg = \"name length is incorrect\"; goto invalid; } if (nbdread(client->ioc, name, namelen, errp) < 0) { return -EIO; } name[namelen] = '\\0'; length -= namelen; tracenbdnegotiatehandleexportnamerequest(name); if (nbdread(client->ioc, &requests, sizeof(requests), errp) < 0) { return -EIO; } be16tocpus(&requests); length -= sizeof(requests); tracenbdnegotiatehandleinforequests(requests); if (requests != length / sizeof(request)) { msg = \"incorrect number of requests for overall length\"; goto invalid; } while (requests--) { if (nbdread(client->ioc, &request, sizeof(request), errp) < 0) { return -EIO; } be16tocpus(&request); length -= sizeof(request); tracenbdnegotiatehandleinforequest(request, nbdinfolookup(request)); /* We care about NBDINFONAME and NBDINFOBLOCKSIZE; * everything else is either a request we don't know or * something we send regardless of request */ switch (request) { case NBDINFONAME: sendname = true; break; case NBDINFOBLOCKSIZE: blocksize = true; break; } } exp = nbdexportfind(name); if (!exp) { return nbdnegotiatesendreperr(client->ioc, NBDREPERRUNKNOWN, opt, errp, \"export '%s' not present\", name); } /* Don't bother sending NBDINFONAME unless client requested it */ if (sendname) { rc = nbdnegotiatesendinfo(client, opt, NBDINFONAME, length, name, errp); if (rc < 0) { return rc; } } /* Send NBDINFODESCRIPTION only if available, regardless of * client request */ if (exp->description) { sizet len = strlen(exp->description); rc = nbdnegotiatesendinfo(client, opt, NBDINFODESCRIPTION, len, exp->description, errp); if (rc < 0) { return rc; } } /* Send NBDINFOBLOCKSIZE always, but tweak the minimum size * according to whether the client requested it, and according to * whether this is OPTINFO or OPTGO. */ /* minimum - 1 for back-compat, or 512 if client is new enough. * TODO: consult blkbs(blk)->bl.requestalignment? */ sizes[0] = (opt == NBDOPTINFO || blocksize) ? BDRVSECTORSIZE : 1; /* preferred - Hard-code to 4096 for now. * TODO: is blkbs(blk)->bl.opttransfer appropriate? */ sizes[1] = 4096; /* maximum - At most 32M, but smaller as appropriate. */ sizes[2] = MIN(blkgetmaxtransfer(exp->blk), NBDMAXBUFFERSIZE); tracenbdnegotiatehandleinfoblocksize(sizes[0], sizes[1], sizes[2]); cputobe32s(&sizes[0]); cputobe32s(&sizes[1]); cputobe32s(&sizes[2]); rc = nbdnegotiatesendinfo(client, opt, NBDINFOBLOCKSIZE, sizeof(sizes), sizes, errp); if (rc < 0) { return rc; } /* Send NBDINFOEXPORT always */ tracenbdnegotiatenewstylesizeflags(exp->size, exp->nbdflags | myflags); stqbep(buf, exp->size); stwbep(buf + 8, exp->nbdflags | myflags); rc = nbdnegotiatesendinfo(client, opt, NBDINFOEXPORT, sizeof(buf), buf, errp); if (rc < 0) { return rc; } /* If the client is just asking for NBDOPTINFO, but forgot to * request block sizes, return an error. * TODO: consult blkbs(blk)->requestalign, and only error if it * is not 1? */ if (opt == NBDOPTINFO && !blocksize) { return nbdnegotiatesendreperr(client->ioc, NBDREPERRBLOCKSIZEREQD, opt, errp, \"request NBDINFOBLOCKSIZE to \" \"use this export\"); } /* Final reply */ rc = nbdnegotiatesendrep(client->ioc, NBDREPACK, opt, errp); if (rc < 0) { return rc; } if (opt == NBDOPTGO) { client->exp = exp; QTAILQINSERTTAIL(&client->exp->clients, client, next); nbdexportget(client->exp); rc = 1; } return rc; invalid: if (nbddrop(client->ioc, length, errp) < 0) { return -EIO; } return nbdnegotiatesendreperr(client->ioc, NBDREPERRINVALID, opt, errp, \"%s\", msg); } ", "target": 0}
{"func": "static int scsireqstreamlength(SCSICommand *cmd, SCSIDevice *dev, uint8t *buf) { switch (buf[0]) { /* stream commands */ case ERASE12: case ERASE16: cmd->xfer = 0; break; case READ6: case READREVERSE: case RECOVERBUFFEREDDATA: case WRITE6: cmd->len = 6; cmd->xfer = buf[4] | (buf[3] << 8) | (buf[2] << 16); if (buf[1] & 0x01) { /* fixed */ cmd->xfer *= dev->blocksize; } break; case READ16: case READREVERSE16: case VERIFY16: case WRITE16: cmd->len = 16; cmd->xfer = buf[14] | (buf[13] << 8) | (buf[12] << 16); if (buf[1] & 0x01) { /* fixed */ cmd->xfer *= dev->blocksize; } break; case REWIND: case LOADUNLOAD: cmd->len = 6; cmd->xfer = 0; break; case SPACE16: cmd->xfer = buf[13] | (buf[12] << 8); break; case READPOSITION: cmd->xfer = buf[8] | (buf[7] << 8); break; case FORMATUNIT: cmd->xfer = buf[4] | (buf[3] << 8); break; /* generic commands */ default: return scsireqlength(cmd, dev, buf); } return 0; } ", "target": 0}
{"func": "static void gentstcc (DisasContext *dc, TCGv cc, int cond) { \tint arithopt, moveopt; \t/* TODO: optimize more condition codes. */ \t/* \t * If the flags are live, we've gotta look into the bits of CCS. \t * Otherwise, if we just did an arithmetic operation we try to \t * evaluate the condition code faster. \t * \t * When this function is done, T0 should be non-zero if the condition \t * code is true. \t */ \tarithopt = arithcc(dc) && !dc->flagsuptodate; \tmoveopt = (dc->ccop == CCOPMOVE) && dc->flagsuptodate; \tswitch (cond) { \t\tcase CCEQ: \t\t\tif (arithopt || moveopt) { \t\t\t\t/* If ccresult is zero, T0 should be \t\t\t\t non-zero otherwise T0 should be zero. */ \t\t\t\tint l1; \t\t\t\tl1 = gennewlabel(); \t\t\t\ttcggenmovitl(cc, 0); \t\t\t\ttcggenbrconditl(TCGCONDNE, ccresult, \t\t\t\t\t\t 0, l1); \t\t\t\ttcggenmovitl(cc, 1); \t\t\t\tgensetlabel(l1); \t\t\t} \t\t\telse { \t\t\t\tcrisevaluateflags(dc); \t\t\t\ttcggenanditl(cc, \t\t\t\t\t\tcpuPR[PRCCS], ZFLAG); \t\t\t} \t\t\tbreak; \t\tcase CCNE: \t\t\tif (arithopt || moveopt) \t\t\t\ttcggenmovtl(cc, ccresult); \t\t\telse { \t\t\t\tcrisevaluateflags(dc); \t\t\t\ttcggenxoritl(cc, cpuPR[PRCCS], \t\t\t\t\t\tZFLAG); \t\t\t\ttcggenanditl(cc, cc, ZFLAG); \t\t\t} \t\t\tbreak; \t\tcase CCCS: \t\t\tcrisevaluateflags(dc); \t\t\ttcggenanditl(cc, cpuPR[PRCCS], CFLAG); \t\t\tbreak; \t\tcase CCCC: \t\t\tcrisevaluateflags(dc); \t\t\ttcggenxoritl(cc, cpuPR[PRCCS], CFLAG); \t\t\ttcggenanditl(cc, cc, CFLAG); \t\t\tbreak; \t\tcase CCVS: \t\t\tcrisevaluateflags(dc); \t\t\ttcggenanditl(cc, cpuPR[PRCCS], VFLAG); \t\t\tbreak; \t\tcase CCVC: \t\t\tcrisevaluateflags(dc); \t\t\ttcggenxoritl(cc, cpuPR[PRCCS], \t\t\t\t\tVFLAG); \t\t\ttcggenanditl(cc, cc, VFLAG); \t\t\tbreak; \t\tcase CCPL: \t\t\tif (arithopt || moveopt) { \t\t\t\tint bits = 31; \t\t\t\tif (dc->ccsize == 1) \t\t\t\t\tbits = 7; \t\t\t\telse if (dc->ccsize == 2) \t\t\t\t\tbits = 15;\t \t\t\t\ttcggenshritl(cc, ccresult, bits); \t\t\t\ttcggenxoritl(cc, cc, 1); \t\t\t} else { \t\t\t\tcrisevaluateflags(dc); \t\t\t\ttcggenxoritl(cc, cpuPR[PRCCS], \t\t\t\t\t\tNFLAG); \t\t\t\ttcggenanditl(cc, cc, NFLAG); \t\t\t} \t\t\tbreak; \t\tcase CCMI: \t\t\tif (arithopt || moveopt) { \t\t\t\tint bits = 31; \t\t\t\tif (dc->ccsize == 1) \t\t\t\t\tbits = 7; \t\t\t\telse if (dc->ccsize == 2) \t\t\t\t\tbits = 15;\t \t\t\t\ttcggenshritl(cc, ccresult, 31); \t\t\t} \t\t\telse { \t\t\t\tcrisevaluateflags(dc); \t\t\t\ttcggenanditl(cc, cpuPR[PRCCS], \t\t\t\t\t\tNFLAG); \t\t\t} \t\t\tbreak; \t\tcase CCLS: \t\t\tcrisevaluateflags(dc); \t\t\ttcggenanditl(cc, cpuPR[PRCCS], \t\t\t\t\tCFLAG | ZFLAG); \t\t\tbreak; \t\tcase CCHI: \t\t\tcrisevaluateflags(dc); \t\t\t{ \t\t\t\tTCGv tmp; \t\t\t\ttmp = tcgtempnew(TCGTYPETL); \t\t\t\ttcggenxoritl(tmp, cpuPR[PRCCS], \t\t\t\t\t\tCFLAG | ZFLAG); \t\t\t\t/* Overlay the C flag on top of the Z. */ \t\t\t\ttcggenshlitl(cc, tmp, 2); \t\t\t\ttcggenandtl(cc, tmp, cc); \t\t\t\ttcggenanditl(cc, cc, ZFLAG); \t\t\t\ttcgtempfree(tmp); \t\t\t} \t\t\tbreak; \t\tcase CCGE: \t\t\tcrisevaluateflags(dc); \t\t\t/* Overlay the V flag on top of the N. */ \t\t\ttcggenshlitl(cc, cpuPR[PRCCS], 2); \t\t\ttcggenxortl(cc, \t\t\t\t cpuPR[PRCCS], cc); \t\t\ttcggenanditl(cc, cc, NFLAG); \t\t\ttcggenxoritl(cc, cc, NFLAG); \t\t\tbreak; \t\tcase CCLT: \t\t\tcrisevaluateflags(dc); \t\t\t/* Overlay the V flag on top of the N. */ \t\t\ttcggenshlitl(cc, cpuPR[PRCCS], 2); \t\t\ttcggenxortl(cc, \t\t\t\t cpuPR[PRCCS], cc); \t\t\ttcggenanditl(cc, cc, NFLAG); \t\t\tbreak; \t\tcase CCGT: \t\t\tcrisevaluateflags(dc); \t\t\t{ \t\t\t\tTCGv n, z; \t\t\t\tn = tcgtempnew(TCGTYPETL); \t\t\t\tz = tcgtempnew(TCGTYPETL); \t\t\t\t/* To avoid a shift we overlay everything on \t\t\t\t the V flag. */ \t\t\t\ttcggenshritl(n, cpuPR[PRCCS], 2); \t\t\t\ttcggenshritl(z, cpuPR[PRCCS], 1); \t\t\t\t/* invert Z. */ \t\t\t\ttcggenxoritl(z, z, 2); \t\t\t\ttcggenxortl(n, n, cpuPR[PRCCS]); \t\t\t\ttcggenxoritl(n, n, 2); \t\t\t\ttcggenandtl(cc, z, n); \t\t\t\ttcggenanditl(cc, cc, 2); \t\t\t\ttcgtempfree(n); \t\t\t\ttcgtempfree(z); \t\t\t} \t\t\tbreak; \t\tcase CCLE: \t\t\tcrisevaluateflags(dc); \t\t\t{ \t\t\t\tTCGv n, z; \t\t\t\tn = tcgtempnew(TCGTYPETL); \t\t\t\tz = tcgtempnew(TCGTYPETL); \t\t\t\t/* To avoid a shift we overlay everything on \t\t\t\t the V flag. */ \t\t\t\ttcggenshritl(n, cpuPR[PRCCS], 2); \t\t\t\ttcggenshritl(z, cpuPR[PRCCS], 1); \t\t\t\ttcggenxortl(n, n, cpuPR[PRCCS]); \t\t\t\ttcggenortl(cc, z, n); \t\t\t\ttcggenanditl(cc, cc, 2); \t\t\t\ttcgtempfree(n); \t\t\t\ttcgtempfree(z); \t\t\t} \t\t\tbreak; \t\tcase CCP: \t\t\tcrisevaluateflags(dc); \t\t\ttcggenanditl(cc, cpuPR[PRCCS], PFLAG); \t\t\tbreak; \t\tcase CCA: \t\t\ttcggenmovitl(cc, 1); \t\t\tbreak; \t\tdefault: \t\t\tBUG(); \t\t\tbreak; \t}; } ", "target": 0}
{"func": "void dosmmenter(X86CPU *cpu) { CPUX86State *env = &cpu->env; CPUState *cs = CPU(cpu); targetulong smstate; SegmentCache *dt; int i, offset; qemulogmask(CPULOGINT, \"SMM: enter\\n\"); logcpustatemask(CPULOGINT, CPU(cpu), CPUDUMPCCOP); env->hflags |= HFSMMMASK; if (env->hflags2 & HF2NMIMASK) { env->hflags2 |= HF2SMMINSIDENMIMASK; } else { env->hflags2 |= HF2NMIMASK; } cpusmmupdate(env); smstate = env->smbase + 0x8000; #ifdef TARGETX8664 for (i = 0; i < 6; i++) { dt = &env->segs[i]; offset = 0x7e00 + i * 16; x86stwphys(cs, smstate + offset, dt->selector); x86stwphys(cs, smstate + offset + 2, (dt->flags >> 8) & 0xf0ff); x86stlphys(cs, smstate + offset + 4, dt->limit); x86stqphys(cs, smstate + offset + 8, dt->base); } x86stqphys(cs, smstate + 0x7e68, env->gdt.base); x86stlphys(cs, smstate + 0x7e64, env->gdt.limit); x86stwphys(cs, smstate + 0x7e70, env->ldt.selector); x86stqphys(cs, smstate + 0x7e78, env->ldt.base); x86stlphys(cs, smstate + 0x7e74, env->ldt.limit); x86stwphys(cs, smstate + 0x7e72, (env->ldt.flags >> 8) & 0xf0ff); x86stqphys(cs, smstate + 0x7e88, env->idt.base); x86stlphys(cs, smstate + 0x7e84, env->idt.limit); x86stwphys(cs, smstate + 0x7e90, env->tr.selector); x86stqphys(cs, smstate + 0x7e98, env->tr.base); x86stlphys(cs, smstate + 0x7e94, env->tr.limit); x86stwphys(cs, smstate + 0x7e92, (env->tr.flags >> 8) & 0xf0ff); x86stqphys(cs, smstate + 0x7ed0, env->efer); x86stqphys(cs, smstate + 0x7ff8, env->regs[REAX]); x86stqphys(cs, smstate + 0x7ff0, env->regs[RECX]); x86stqphys(cs, smstate + 0x7fe8, env->regs[REDX]); x86stqphys(cs, smstate + 0x7fe0, env->regs[REBX]); x86stqphys(cs, smstate + 0x7fd8, env->regs[RESP]); x86stqphys(cs, smstate + 0x7fd0, env->regs[REBP]); x86stqphys(cs, smstate + 0x7fc8, env->regs[RESI]); x86stqphys(cs, smstate + 0x7fc0, env->regs[REDI]); for (i = 8; i < 16; i++) { x86stqphys(cs, smstate + 0x7ff8 - i * 8, env->regs[i]); } x86stqphys(cs, smstate + 0x7f78, env->eip); x86stlphys(cs, smstate + 0x7f70, cpucomputeeflags(env)); x86stlphys(cs, smstate + 0x7f68, env->dr[6]); x86stlphys(cs, smstate + 0x7f60, env->dr[7]); x86stlphys(cs, smstate + 0x7f48, env->cr[4]); x86stqphys(cs, smstate + 0x7f50, env->cr[3]); x86stlphys(cs, smstate + 0x7f58, env->cr[0]); x86stlphys(cs, smstate + 0x7efc, SMMREVISIONID); x86stlphys(cs, smstate + 0x7f00, env->smbase); #else x86stlphys(cs, smstate + 0x7ffc, env->cr[0]); x86stlphys(cs, smstate + 0x7ff8, env->cr[3]); x86stlphys(cs, smstate + 0x7ff4, cpucomputeeflags(env)); x86stlphys(cs, smstate + 0x7ff0, env->eip); x86stlphys(cs, smstate + 0x7fec, env->regs[REDI]); x86stlphys(cs, smstate + 0x7fe8, env->regs[RESI]); x86stlphys(cs, smstate + 0x7fe4, env->regs[REBP]); x86stlphys(cs, smstate + 0x7fe0, env->regs[RESP]); x86stlphys(cs, smstate + 0x7fdc, env->regs[REBX]); x86stlphys(cs, smstate + 0x7fd8, env->regs[REDX]); x86stlphys(cs, smstate + 0x7fd4, env->regs[RECX]); x86stlphys(cs, smstate + 0x7fd0, env->regs[REAX]); x86stlphys(cs, smstate + 0x7fcc, env->dr[6]); x86stlphys(cs, smstate + 0x7fc8, env->dr[7]); x86stlphys(cs, smstate + 0x7fc4, env->tr.selector); x86stlphys(cs, smstate + 0x7f64, env->tr.base); x86stlphys(cs, smstate + 0x7f60, env->tr.limit); x86stlphys(cs, smstate + 0x7f5c, (env->tr.flags >> 8) & 0xf0ff); x86stlphys(cs, smstate + 0x7fc0, env->ldt.selector); x86stlphys(cs, smstate + 0x7f80, env->ldt.base); x86stlphys(cs, smstate + 0x7f7c, env->ldt.limit); x86stlphys(cs, smstate + 0x7f78, (env->ldt.flags >> 8) & 0xf0ff); x86stlphys(cs, smstate + 0x7f74, env->gdt.base); x86stlphys(cs, smstate + 0x7f70, env->gdt.limit); x86stlphys(cs, smstate + 0x7f58, env->idt.base); x86stlphys(cs, smstate + 0x7f54, env->idt.limit); for (i = 0; i < 6; i++) { dt = &env->segs[i]; if (i < 3) { offset = 0x7f84 + i * 12; } else { offset = 0x7f2c + (i - 3) * 12; } x86stlphys(cs, smstate + 0x7fa8 + i * 4, dt->selector); x86stlphys(cs, smstate + offset + 8, dt->base); x86stlphys(cs, smstate + offset + 4, dt->limit); x86stlphys(cs, smstate + offset, (dt->flags >> 8) & 0xf0ff); } x86stlphys(cs, smstate + 0x7f14, env->cr[4]); x86stlphys(cs, smstate + 0x7efc, SMMREVISIONID); x86stlphys(cs, smstate + 0x7ef8, env->smbase); #endif /* init SMM cpu state */ #ifdef TARGETX8664 cpuloadefer(env, 0); #endif cpuloadeflags(env, 0, ~(CCO | CCS | CCZ | CCA | CCP | CCC | DFMASK)); env->eip = 0x00008000; cpux86updatecr0(env, env->cr[0] & ~(CR0PEMASK | CR0EMMASK | CR0TSMASK | CR0PGMASK)); cpux86updatecr4(env, 0); env->dr[7] = 0x00000400; cpux86loadsegcache(env, RCS, (env->smbase >> 4) & 0xffff, env->smbase, 0xffffffff, DESCPMASK | DESCSMASK | DESCWMASK | DESCAMASK); cpux86loadsegcache(env, RDS, 0, 0, 0xffffffff, DESCPMASK | DESCSMASK | DESCWMASK | DESCAMASK); cpux86loadsegcache(env, RES, 0, 0, 0xffffffff, DESCPMASK | DESCSMASK | DESCWMASK | DESCAMASK); cpux86loadsegcache(env, RSS, 0, 0, 0xffffffff, DESCPMASK | DESCSMASK | DESCWMASK | DESCAMASK); cpux86loadsegcache(env, RFS, 0, 0, 0xffffffff, DESCPMASK | DESCSMASK | DESCWMASK | DESCAMASK); cpux86loadsegcache(env, RGS, 0, 0, 0xffffffff, DESCPMASK | DESCSMASK | DESCWMASK | DESCAMASK); } ", "target": 0}
{"func": "PCIDevice *pcinicinit(NICInfo *nd, const char *defaultmodel, const char *defaultdevaddr) { const char *devaddr = nd->devaddr ? nd->devaddr : defaultdevaddr; PCIDevice *pcidev; DeviceState *dev; int i; i = qemuchecknicmodellist(nd, pcinicmodels, defaultmodel); pcidev = pcicreate(pcinicnames[i], devaddr); dev = &pcidev->qdev; if (nd->id) dev->id = qemustrdup(nd->id); dev->nd = nd; qdevinit(dev); nd->private = dev; return pcidev; } ", "target": 1}
{"func": "void ffmlpinitx86(DSPContext* c, AVCodecContext *avctx) { #if HAVE7REGS && HAVETENOPERANDS c->mlpfilterchannel = mlpfilterchannelx86; #endif } ", "target": 1}
{"func": "static avcold int roqencodeinit(AVCodecContext *avctx) { RoqContext *enc = avctx->privdata; avlfginit(&enc->randctx, 1); enc->framesSinceKeyframe = 0; if ((avctx->width & 0xf) || (avctx->height & 0xf)) { avlog(avctx, AVLOGERROR, \"Dimensions must be divisible by 16\\n\"); return AVERROR(EINVAL); if (avctx->width > 65535 || avctx->height > 65535) { avlog(avctx, AVLOGERROR, \"Dimensions are max %d\\n\", enc->quake3compat ? 32768 : 65535); return AVERROR(EINVAL); if (((avctx->width)&(avctx->width-1))||((avctx->height)&(avctx->height-1))) avlog(avctx, AVLOGERROR, \"Warning: dimensions not power of two, this is not supported by quake\\n\"); enc->width = avctx->width; enc->height = avctx->height; enc->framesSinceKeyframe = 0; enc->firstframe = 1; enc->lastframe = avframealloc(); enc->currentframe = avframealloc(); if (!enc->lastframe || !enc->currentframe) { enc->tmpData = avmalloc(sizeof(RoqTempdata)); enc->thismotion4 = avmalloczarray((enc->width*enc->height/16), sizeof(motionvect)); enc->lastmotion4 = avmallocarray ((enc->width*enc->height/16), sizeof(motionvect)); enc->thismotion8 = avmalloczarray((enc->width*enc->height/64), sizeof(motionvect)); enc->lastmotion8 = avmallocarray ((enc->width*enc->height/64), sizeof(motionvect)); return 0;", "target": 1}
{"func": "void ffh264flushchange(H264Context *h) { int i, j; h->nextoutputedpoc = INTMIN; h->previnterlacedframe = 1; idr(h); h->poc.prevframenum = -1; if (h->curpicptr) { h->curpicptr->reference = 0; for (j=i=0; h->delayedpic[i]; i++) if (h->delayedpic[i] != h->curpicptr) h->delayedpic[j++] = h->delayedpic[i]; h->delayedpic[j] = NULL; } ffh264unrefpicture(h, &h->lastpicforec); h->firstfield = 0; ffh264seiuninit(&h->sei); h->recoveryframe = -1; h->framerecovered = 0; h->currentslice = 0; h->mmcoreset = 1; for (i = 0; i < h->nbslicectx; i++) h->slicectx[i].listcount = 0; } ", "target": 1}
{"func": "static int avsetnumber2(void *obj, const char *name, double num, int den, int64t intnum, const AVOption **oout) { const AVOption *o = avoptfind(obj, name, NULL, 0, 0); void *dst; if (oout) *oout= o; if (!o || o->offset<=0) return AVERROROPTIONNOTFOUND; if (o->max*den < num*intnum || o->min*den > num*intnum) { avlog(obj, AVLOGERROR, \"Value %lf for parameter '%s' out of range\\n\", num, name); return AVERROR(ERANGE); } dst= ((uint8t*)obj) + o->offset; switch (o->type) { case FFOPTTYPEFLAGS: case FFOPTTYPEINT: *(int *)dst= llrint(num/den)*intnum; break; case FFOPTTYPEINT64: *(int64t *)dst= llrint(num/den)*intnum; break; case FFOPTTYPEFLOAT: *(float *)dst= num*intnum/den; break; case FFOPTTYPEDOUBLE:*(double *)dst= num*intnum/den; break; case FFOPTTYPERATIONAL: if ((int)num == num) *(AVRational*)dst= (AVRational){num*intnum, den}; else *(AVRational*)dst= avd2q(num*intnum/den, 1<<24); break; default: return AVERROR(EINVAL); } return 0; } ", "target": 0}
{"func": "static void qxlrealizecommon(PCIQXLDevice *qxl, Error **errp) { uint8t* config = qxl->pci.config; uint32t pcidevicerev; uint32t iosize; qxl->mode = QXLMODEUNDEFINED; qxl->generation = 1; qxl->nummemslots = NUMMEMSLOTS; qemumutexinit(&qxl->tracklock); qemumutexinit(&qxl->asynclock); qxl->currentasync = QXLUNDEFINEDIO; qxl->guestbug = 0; switch (qxl->revision) { case 1: /* spice 0.4 -- qxl-1 */ pcidevicerev = QXLREVISIONSTABLEV04; iosize = 8; break; case 2: /* spice 0.6 -- qxl-2 */ pcidevicerev = QXLREVISIONSTABLEV06; iosize = 16; break; case 3: /* qxl-3 */ pcidevicerev = QXLREVISIONSTABLEV10; iosize = 32; /* PCI region size must be pow2 */ break; case 4: /* qxl-4 */ pcidevicerev = QXLREVISIONSTABLEV12; iosize = pow2ceil(QXLIORANGESIZE); break; default: errorsetg(errp, \"Invalid revision %d for qxl device (max %d)\", qxl->revision, QXLDEFAULTREVISION); return; } pcisetbyte(&config[PCIREVISIONID], pcidevicerev); pcisetbyte(&config[PCIINTERRUPTPIN], 1); qxl->romsize = qxlromsize(); memoryregioninitram(&qxl->rombar, OBJECT(qxl), \"qxl.vrom\", qxl->romsize, &errorabort); vmstateregisterram(&qxl->rombar, &qxl->pci.qdev); initqxlrom(qxl); initqxlram(qxl); qxl->guestsurfaces.cmds = gnew0(QXLPHYSICAL, qxl->ssd.numsurfaces); memoryregioninitram(&qxl->vrambar, OBJECT(qxl), \"qxl.vram\", qxl->vramsize, &errorabort); vmstateregisterram(&qxl->vrambar, &qxl->pci.qdev); memoryregioninitalias(&qxl->vram32bar, OBJECT(qxl), \"qxl.vram32\", &qxl->vrambar, 0, qxl->vram32size); memoryregioninitio(&qxl->iobar, OBJECT(qxl), &qxlioops, qxl, \"qxl-ioports\", iosize); if (qxl->id == 0) { vgadirtylogstart(&qxl->vga); } memoryregionsetflushcoalesced(&qxl->iobar); pciregisterbar(&qxl->pci, QXLIORANGEINDEX, PCIBASEADDRESSSPACEIO, &qxl->iobar); pciregisterbar(&qxl->pci, QXLROMRANGEINDEX, PCIBASEADDRESSSPACEMEMORY, &qxl->rombar); pciregisterbar(&qxl->pci, QXLRAMRANGEINDEX, PCIBASEADDRESSSPACEMEMORY, &qxl->vga.vram); pciregisterbar(&qxl->pci, QXLVRAMRANGEINDEX, PCIBASEADDRESSSPACEMEMORY, &qxl->vram32bar); if (qxl->vram32size < qxl->vramsize) { /* * Make the 64bit vram bar show up only in case it is * configured to be larger than the 32bit vram bar. */ pciregisterbar(&qxl->pci, QXLVRAM64RANGEINDEX, PCIBASEADDRESSSPACEMEMORY | PCIBASEADDRESSMEMTYPE64 | PCIBASEADDRESSMEMPREFETCH, &qxl->vrambar); } /* print pci bar details */ dprint(qxl, 1, \"ram/%s: %d MB [region 0]\\n\", qxl->id == 0 ? \"pri\" : \"sec\", qxl->vga.vramsize / (1024*1024)); dprint(qxl, 1, \"vram/32: %d MB [region 1]\\n\", qxl->vram32size / (1024*1024)); dprint(qxl, 1, \"vram/64: %d MB %s\\n\", qxl->vramsize / (1024*1024), qxl->vram32size < qxl->vramsize ? \"[region 4]\" : \"[unmapped]\"); qxl->ssd.qxl.base.sif = &qxlinterface.base; if (qemuspiceadddisplayinterface(&qxl->ssd.qxl, qxl->vga.con) != 0) { errorsetg(errp, \"qxl interface %d.%d not supported by spice-server\", SPICEINTERFACEQXLMAJOR, SPICEINTERFACEQXLMINOR); return; } qemuaddvmchangestatehandler(qxlvmchangestatehandler, qxl); qxl->updateirq = qemubhnew(qxlupdateirqbh, qxl); qxlresetstate(qxl); qxl->updateareabh = qemubhnew(qxlrenderupdateareabh, qxl); qxl->ssd.cursorbh = qemubhnew(qemuspicecursorrefreshbh, &qxl->ssd); } ", "target": 1}
{"func": "static void vc1invtrans8x4dcc(uint8t *dest, int linesize, DCTELEM *block) { int i; int dc = block[0]; const uint8t *cm; dc = ( 3 * dc + 1) >> 1; dc = (17 * dc + 64) >> 7; cm = ffcropTbl + MAXNEGCROP + dc; for(i = 0; i < 4; i++){ dest[0] = cm[dest[0]]; dest[1] = cm[dest[1]]; dest[2] = cm[dest[2]]; dest[3] = cm[dest[3]]; dest[4] = cm[dest[4]]; dest[5] = cm[dest[5]]; dest[6] = cm[dest[6]]; dest[7] = cm[dest[7]]; dest += linesize; } } ", "target": 1}
{"func": "static alwaysinline uint8t vc1mspelfilter(const uint8t *src, int stride, int mode, int r) { switch(mode){ case 0: //no shift return src[0]; case 1: // 1/4 shift return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6; case 2: // 1/2 shift return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4; case 3: // 3/4 shift return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6; } return 0; //should not occur } ", "target": 1}
{"func": "static uint64t openpictmrread(void *opaque, hwaddr addr, unsigned len) { OpenPICState *opp = opaque; uint32t retval = -1; int idx; DPRINTF(\"%s: addr %08x\\n\", func, addr); if (addr & 0xF) { goto out; } idx = (addr >> 6) & 0x3; if (addr == 0x0) { /* TIFR (TFRR) */ retval = opp->tifr; goto out; } switch (addr & 0x30) { case 0x00: /* TICC (GTCCR) */ retval = opp->timers[idx].ticc; break; case 0x10: /* TIBC (GTBCR) */ retval = opp->timers[idx].tibc; break; case 0x20: /* TIPV (TIPV) */ retval = readIRQregipvp(opp, opp->irqtim0 + idx); break; case 0x30: /* TIDE (TIDR) */ retval = readIRQregide(opp, opp->irqtim0 + idx); break; } out: DPRINTF(\"%s: => %08x\\n\", func, retval); return retval; } ", "target": 1}
{"func": "static void genexceptioninsn(DisasContext *s, int offset, int excp) { gena64setpcim(s->pc - offset); genexception(excp); s->isjmp = DISASJUMP; } ", "target": 0}
{"func": "static QDict *qmpdispatchcheckobj(const QObject *request, Error **errp) { const QDictEntry *ent; const char *argname; const QObject *argobj; bool hasexeckey = false; QDict *dict = NULL; if (qobjecttype(request) != QTYPEQDICT) { errorsetg(errp, QERRQMPBADINPUTOBJECT, \"request is not a dictionary\"); return NULL; } dict = qobjecttoqdict(request); for (ent = qdictfirst(dict); ent; ent = qdictnext(dict, ent)) { argname = qdictentrykey(ent); argobj = qdictentryvalue(ent); if (!strcmp(argname, \"execute\")) { if (qobjecttype(argobj) != QTYPEQSTRING) { errorsetg(errp, QERRQMPBADINPUTOBJECTMEMBER, \"execute\", \"string\"); return NULL; } hasexeckey = true; } else if (strcmp(argname, \"arguments\")) { errorsetg(errp, QERRQMPEXTRAMEMBER, argname); return NULL; } } if (!hasexeckey) { errorsetg(errp, QERRQMPBADINPUTOBJECT, \"execute\"); return NULL; } return dict; } ", "target": 0}
{"func": "static void sha1transform(uint32t state[5], const uint8t buffer[64]) { uint32t block[80]; unsigned int i, a, b, c, d, e; a = state[0]; b = state[1]; c = state[2]; d = state[3]; e = state[4]; #if CONFIGSMALL for (i = 0; i < 80; i++) { int t; if (i < 16) t = AVRB32(buffer + 4 * i); else t = rol(block[i-3] ^ block[i-8] ^ block[i-14] ^ block[i-16], 1); block[i] = t; t += e + rol(a, 5); if (i < 40) { if (i < 20) t += ((b&(c^d))^d) + 0x5A827999; else t += ( b^c ^d) + 0x6ED9EBA1; } else { if (i < 60) t += (((b|c)&d)|(b&c)) + 0x8F1BBCDC; else t += ( b^c ^d) + 0xCA62C1D6; } e = d; d = c; c = rol(b, 30); b = a; a = t; } #else for (i = 0; i < 15; i += 5) { R0(a, b, c, d, e, 0 + i); R0(e, a, b, c, d, 1 + i); R0(d, e, a, b, c, 2 + i); R0(c, d, e, a, b, 3 + i); R0(b, c, d, e, a, 4 + i); } R0(a, b, c, d, e, 15); R1(e, a, b, c, d, 16); R1(d, e, a, b, c, 17); R1(c, d, e, a, b, 18); R1(b, c, d, e, a, 19); for (i = 20; i < 40; i += 5) { R2(a, b, c, d, e, 0 + i); R2(e, a, b, c, d, 1 + i); R2(d, e, a, b, c, 2 + i); R2(c, d, e, a, b, 3 + i); R2(b, c, d, e, a, 4 + i); } for (; i < 60; i += 5) { R3(a, b, c, d, e, 0 + i); R3(e, a, b, c, d, 1 + i); R3(d, e, a, b, c, 2 + i); R3(c, d, e, a, b, 3 + i); R3(b, c, d, e, a, 4 + i); } for (; i < 80; i += 5) { R4(a, b, c, d, e, 0 + i); R4(e, a, b, c, d, 1 + i); R4(d, e, a, b, c, 2 + i); R4(c, d, e, a, b, 3 + i); R4(b, c, d, e, a, 4 + i); } #endif state[0] += a; state[1] += b; state[2] += c; state[3] += d; state[4] += e; } ", "target": 0}
{"func": "static int getint64(QEMUFile *f, void *pv, sizet size) { int64t *v = pv; qemugetsbe64s(f, v); return 0; } ", "target": 1}
{"func": "static void acpibuildupdate(void *buildopaque, uint32t offset) { AcpiBuildState *buildstate = buildopaque; AcpiBuildTables tables; /* No state to update or already patched? Nothing to do. */ if (!buildstate || buildstate->patched) { return; } buildstate->patched = 1; acpibuildtablesinit(&tables); acpibuild(buildstate->guestinfo, &tables); assert(acpidatalen(tables.tabledata) == buildstate->tablesize); memcpy(buildstate->tableram, tables.tabledata->data, buildstate->tablesize); acpibuildtablescleanup(&tables, true); } ", "target": 1}
{"func": "static avcold int amrnbencodeinit(AVCodecContext *avctx) { AMRContext *s = avctx->privdata; if (avctx->samplerate != 8000) { avlog(avctx, AVLOGERROR, \"Only 8000Hz sample rate supported\\n\"); return AVERROR(ENOSYS); } if (avctx->channels != 1) { avlog(avctx, AVLOGERROR, \"Only mono supported\\n\"); return AVERROR(ENOSYS); } avctx->framesize = 160; avctx->codedframe = avcodecallocframe(); s->encstate = EncoderInterfaceinit(s->encdtx); if (!s->encstate) { avlog(avctx, AVLOGERROR, \"EncoderInterfaceinit error\\n\"); return -1; } s->encmode = getbitratemode(avctx->bitrate, avctx); s->encbitrate = avctx->bitrate; return 0; }", "target": 1}
{"func": "void help(void) { printf(\"dct-test [-i] [<test-number>]\\n\" \"test-number 0 -> test with random matrixes\\n\" \" 1 -> test with random sparse matrixes\\n\" \" 2 -> do 3. test from mpeg4 std\\n\" \"-i test IDCT implementations\\n\" \"-4 test IDCT248 implementations\\n\"); exit(1); } ", "target": 1}
{"func": "PPCOP(slw) { if (T1 & 0x20) { T0 = 0; } else { T0 = T0 << T1; } RETURN(); } ", "target": 1}
{"func": "static int getnum(ByteIOContext *pb, int *len) { int n, n1; n = getbe16(pb); (*len)-=2; // n &= 0x7FFF; if (n >= 0x4000) { return n - 0x4000; } else { n1 = getbe16(pb); (*len)-=2; return (n << 16) | n1; } } ", "target": 1}
{"func": "CPUState *ppc440epinit(MemoryRegion *addressspacemem, ramaddrt *ramsize, PCIBus **pcip, const unsigned int pciirqnrs[4], int doinit, const char *cpumodel) { MemoryRegion *rammemories = gmalloc(PPC440EPSDRAMNRBANKS * sizeof(*rammemories)); targetphysaddrt rambases[PPC440EPSDRAMNRBANKS]; targetphysaddrt ramsizes[PPC440EPSDRAMNRBANKS]; CPUState *env; qemuirq *pic; qemuirq *irqs; qemuirq *pciirqs; if (cpumodel == NULL) { cpumodel = \"440-Xilinx\"; // XXX: should be 440EP } env = cpuinit(cpumodel); if (!env) { fprintf(stderr, \"Unable to initialize CPU!\\n\"); exit(1); } ppcbooketimersinit(env, 400000000, 0); ppcdcrinit(env, NULL, NULL); /* interrupt controller */ irqs = gmalloc0(sizeof(qemuirq) * PPCUICOUTPUTNB); irqs[PPCUICOUTPUTINT] = ((qemuirq *)env->irqinputs)[PPC40xINPUTINT]; irqs[PPCUICOUTPUTCINT] = ((qemuirq *)env->irqinputs)[PPC40xINPUTCINT]; pic = ppcuicinit(env, irqs, 0x0C0, 0, 1); /* SDRAM controller */ memset(rambases, 0, sizeof(rambases)); memset(ramsizes, 0, sizeof(ramsizes)); *ramsize = ppc4xxsdramadjust(*ramsize, PPC440EPSDRAMNRBANKS, rammemories, rambases, ramsizes, ppc440epsdrambanksizes); /* XXX 440EP's ECC interrupts are on UIC1, but we've only created UIC0. */ ppc4xxsdraminit(env, pic[14], PPC440EPSDRAMNRBANKS, rammemories, rambases, ramsizes, doinit); /* PCI */ pciirqs = gmalloc(sizeof(qemuirq) * 4); pciirqs[0] = pic[pciirqnrs[0]]; pciirqs[1] = pic[pciirqnrs[1]]; pciirqs[2] = pic[pciirqnrs[2]]; pciirqs[3] = pic[pciirqnrs[3]]; *pcip = ppc4xxpciinit(env, pciirqs, PPC440EPPCICONFIG, PPC440EPPCIINTACK, PPC440EPPCISPECIAL, PPC440EPPCIREGS); if (!*pcip) printf(\"couldn't create PCI controller!\\n\"); isammioinit(PPC440EPPCIIO, PPC440EPPCIIOLEN); if (serialhds[0] != NULL) { serialmminit(addressspacemem, 0xef600300, 0, pic[0], PPCSERIALMMBAUDBASE, serialhds[0], DEVICEBIGENDIAN); } if (serialhds[1] != NULL) { serialmminit(addressspacemem, 0xef600400, 0, pic[1], PPCSERIALMMBAUDBASE, serialhds[1], DEVICEBIGENDIAN); } return env; } ", "target": 0}
{"func": "static int piix4initfn(PCIDevice *dev) { PIIX4State *d = DOUPCAST(PIIX4State, dev, dev); uint8t *pciconf; isabusnew(&d->dev.qdev); pciconf = d->dev.config; pciconfigsetvendorid(pciconf, PCIVENDORIDINTEL); pciconfigsetdeviceid(pciconf, PCIDEVICEIDINTEL82371AB0); // 82371AB/EB/MB PIIX4 PCI-to-ISA bridge pciconfigsetclass(pciconf, PCICLASSBRIDGEISA); piix4dev = &d->dev; qemuregisterreset(piix4reset, d); return 0; } ", "target": 0}
{"func": "static void FUNCC(ffh264addpixels8)(uint8t *dst, int16t *src, int stride) { int i; pixel *dst = (pixel *) dst; dctcoef *src = (dctcoef *) src; stride /= sizeof(pixel); for (i = 0; i < 8; i++) { dst[0] += src[0]; dst[1] += src[1]; dst[2] += src[2]; dst[3] += src[3]; dst[4] += src[4]; dst[5] += src[5]; dst[6] += src[6]; dst[7] += src[7]; dst += stride; src += 8; } memset(src, 0, sizeof(dctcoef) * 64); } ", "target": 1}
{"func": "static int outputframe(H264Context *h, AVFrame *dst, AVFrame *src) { int i; int ret = avframeref(dst, src); if (ret < 0) return ret; if (!h->sps.crop) return 0; for (i = 0; i < 3; i++) { int hshift = (i > 0) ? h->chromaxshift : 0; int vshift = (i > 0) ? h->chromayshift : 0; int off = ((h->sps.cropleft >> hshift) << h->pixelshift) + (h->sps.croptop >> vshift) * dst->linesize[i]; dst->data[i] += off; } return 0; } ", "target": 1}
{"func": "void throttleaccount(ThrottleState *ts, bool iswrite, uint64t size) { double units = 1.0; /* if cfg.opsize is defined and smaller than size we compute unit count */ if (ts->cfg.opsize && size > ts->cfg.opsize) { units = (double) size / ts->cfg.opsize; } ts->cfg.buckets[THROTTLEBPSTOTAL].level += size; ts->cfg.buckets[THROTTLEOPSTOTAL].level += units; if (iswrite) { ts->cfg.buckets[THROTTLEBPSWRITE].level += size; ts->cfg.buckets[THROTTLEOPSWRITE].level += units; } else { ts->cfg.buckets[THROTTLEBPSREAD].level += size; ts->cfg.buckets[THROTTLEOPSREAD].level += units; } } ", "target": 1}
{"func": "void bdrvremoveaiocontextnotifier(BlockDriverState *bs, void (*attachedaiocontext)(AioContext *, void *), void (*detachaiocontext)(void *), void *opaque) { BdrvAioNotifier *ban, *bannext; QLISTFOREACHSAFE(ban, &bs->aionotifiers, list, bannext) { if (ban->attachedaiocontext == attachedaiocontext && ban->detachaiocontext == detachaiocontext && ban->opaque == opaque) { QLISTREMOVE(ban, list); gfree(ban); return; } } abort(); } ", "target": 1}
{"func": "static void genaddqlo(DisasContext *s, TCGvi64 val, int rlow) { TCGvi64 tmp; TCGv tmp2; /* Load value and extend to 64 bits. */ tmp = tcgtempnewi64(); tmp2 = loadreg(s, rlow); tcggenextui32i64(tmp, tmp2); deadtmp(tmp2); tcggenaddi64(val, val, tmp); tcgtempfreei64(tmp); } ", "target": 1}
{"func": "static void testbmdmasimplerw(void) { QPCIDevice *dev; void *bmdmabase, *idebase; uint8t status; uint8t *buf; uint8t *cmpbuf; sizet len = 512; uintptrt guestbuf = guestalloc(guestmalloc, len); PrdtEntry prdt[] = { { .addr = cputole32(guestbuf), .size = cputole32(len | PRDTEOT), }, }; dev = getpcidevice(&bmdmabase, &idebase); buf = gmalloc(len); cmpbuf = gmalloc(len); /* Write 0x55 pattern to sector 0 */ memset(buf, 0x55, len); memwrite(guestbuf, buf, len); status = senddmarequest(CMDWRITEDMA, 0, 1, prdt, ARRAYSIZE(prdt), NULL); gassertcmphex(status, ==, BMSTSINTR); assertbitclear(qpciioreadb(dev, idebase + regstatus), DF | ERR); /* Write 0xaa pattern to sector 1 */ memset(buf, 0xaa, len); memwrite(guestbuf, buf, len); status = senddmarequest(CMDWRITEDMA, 1, 1, prdt, ARRAYSIZE(prdt), NULL); gassertcmphex(status, ==, BMSTSINTR); assertbitclear(qpciioreadb(dev, idebase + regstatus), DF | ERR); /* Read and verify 0x55 pattern in sector 0 */ memset(cmpbuf, 0x55, len); status = senddmarequest(CMDREADDMA, 0, 1, prdt, ARRAYSIZE(prdt), NULL); gassertcmphex(status, ==, BMSTSINTR); assertbitclear(qpciioreadb(dev, idebase + regstatus), DF | ERR); memread(guestbuf, buf, len); gassert(memcmp(buf, cmpbuf, len) == 0); /* Read and verify 0xaa pattern in sector 1 */ memset(cmpbuf, 0xaa, len); status = senddmarequest(CMDREADDMA, 1, 1, prdt, ARRAYSIZE(prdt), NULL); gassertcmphex(status, ==, BMSTSINTR); assertbitclear(qpciioreadb(dev, idebase + regstatus), DF | ERR); memread(guestbuf, buf, len); gassert(memcmp(buf, cmpbuf, len) == 0); gfree(buf); gfree(cmpbuf); } ", "target": 1}
{"func": "static int idcinreadpacket(AVFormatContext *s, AVPacket *pkt) { int ret; unsigned int command; unsigned int chunksize; IdcinDemuxContext *idcin = s->privdata; AVIOContext *pb = s->pb; int i; int palettescale; unsigned char r, g, b; unsigned char palettebuffer[768]; uint32t palette[256]; if (s->pb->eofreached) return AVERROR(EIO); if (idcin->nextchunkisvideo) { command = aviorl32(pb); if (command == 2) { return AVERROR(EIO); } else if (command == 1) { /* trigger a palette change */ if (avioread(pb, palettebuffer, 768) != 768) return AVERROR(EIO); /* scale the palette as necessary */ palettescale = 2; for (i = 0; i < 768; i++) if (palettebuffer[i] > 63) { palettescale = 0; break; for (i = 0; i < 256; i++) { r = palettebuffer[i * 3 ] << palettescale; g = palettebuffer[i * 3 + 1] << palettescale; b = palettebuffer[i * 3 + 2] << palettescale; palette[i] = (r << 16) | (g << 8) | (b); chunksize = aviorl32(pb); /* skip the number of decoded bytes (always equal to width * height) */ avioskip(pb, 4); chunksize -= 4; ret= avgetpacket(pb, pkt, chunksize); if (ret < 0) return ret; if (command == 1) { uint8t *pal; pal = avpacketnewsidedata(pkt, AVPKTDATAPALETTE, AVPALETTESIZE); if (ret < 0) return ret; memcpy(pal, palette, AVPALETTESIZE); pkt->flags |= AVPKTFLAGKEY; pkt->streamindex = idcin->videostreamindex; pkt->duration = 1; } else { /* send out the audio chunk */ if (idcin->currentaudiochunk) chunksize = idcin->audiochunksize2; else chunksize = idcin->audiochunksize1; ret= avgetpacket(pb, pkt, chunksize); if (ret < 0) return ret; pkt->streamindex = idcin->audiostreamindex; pkt->duration = chunksize / idcin->blockalign; idcin->currentaudiochunk ^= 1; if (idcin->audiopresent) idcin->nextchunkisvideo ^= 1; return ret; ", "target": 1}
{"func": "static inline void RENAME(yuv2rgb5552)(SwsContext *c, const uint16t *buf0, const uint16t *buf1, const uint16t *ubuf0, const uint16t *ubuf1, const uint16t *vbuf0, const uint16t *vbuf1, const uint16t *abuf0, const uint16t *abuf1, uint8t *dest, int dstW, int yalpha, int uvalpha, int y) { x86reg uvoff = c->uvoff << 1; //Note 8280 == DSTWOFFSET but the preprocessor can't handle that there :( asm volatile( \"mov %%\"REGb\", \"ESPOFFSET\"(%5) \\n\\t\" \"mov %4, %%\"REGb\" \\n\\t\" \"push %%\"REGBP\" \\n\\t\" YSCALEYUV2RGB(%%REGBP, %5, %6) \"pxor %%mm7, %%mm7 \\n\\t\" /* mm2=B, %%mm4=G, %%mm5=R, %%mm7=0 */ #ifdef DITHER1XBPP \"paddusb \"BLUEDITHER\"(%5), %%mm2 \\n\\t\" \"paddusb \"GREENDITHER\"(%5), %%mm4 \\n\\t\" \"paddusb \"REDDITHER\"(%5), %%mm5 \\n\\t\" #endif WRITERGB15(%%REGb, 8280(%5), %%REGBP) \"pop %%\"REGBP\" \\n\\t\" \"mov \"ESPOFFSET\"(%5), %%\"REGb\" \\n\\t\" :: \"c\" (buf0), \"d\" (buf1), \"S\" (ubuf0), \"D\" (ubuf1), \"m\" (dest), \"a\" (&c->redDither), \"m\"(uvoff) ); } ", "target": 1}
{"func": "static VirtIOBlockReq *virtioblkgetrequest(VirtIOBlock *s) { VirtIOBlockReq *req = virtioblkallocrequest(s); if (!virtqueuepop(s->vq, &req->elem)) { virtioblkfreerequest(req); return NULL; } return req; } ", "target": 0}
{"func": "static int outputpacket(InputStream *ist, const AVPacket *pkt) { int ret = 0, i; int gotoutput; AVPacket avpkt; if (!ist->sawfirstts) { ist->dts = ist->st->avgframerate.num ? - ist->st->codec->hasbframes * AVTIMEBASE / avq2d(ist->st->avgframerate) : 0; ist->pts = 0; if (pkt != NULL && pkt->pts != AVNOPTSVALUE && !ist->decodingneeded) { ist->dts += avrescaleq(pkt->pts, ist->st->timebase, AVTIMEBASEQ); ist->pts = ist->dts; //unused but better to set it to a value thats not totally wrong } ist->sawfirstts = 1; } if (ist->nextdts == AVNOPTSVALUE) ist->nextdts = ist->dts; if (ist->nextpts == AVNOPTSVALUE) ist->nextpts = ist->pts; if (pkt == NULL) { /* EOF handling */ avinitpacket(&avpkt); avpkt.data = NULL; avpkt.size = 0; goto handleeof; } else { avpkt = *pkt; } if (pkt->dts != AVNOPTSVALUE) { ist->nextdts = ist->dts = avrescaleq(pkt->dts, ist->st->timebase, AVTIMEBASEQ); if (ist->st->codec->codectype != AVMEDIATYPEVIDEO || !ist->decodingneeded) ist->nextpts = ist->pts = ist->dts; } // while we have more to decode or while the decoder did output something on EOF while (ist->decodingneeded && (avpkt.size > 0 || (!pkt && gotoutput))) { int duration; handleeof: ist->pts = ist->nextpts; ist->dts = ist->nextdts; if (avpkt.size && avpkt.size != pkt->size) { avlog(NULL, ist->showedmultipacketwarning ? AVLOGVERBOSE : AVLOGWARNING, \"Multiple frames in a packet from stream %d\\n\", pkt->streamindex); ist->showedmultipacketwarning = 1; } switch (ist->st->codec->codectype) { case AVMEDIATYPEAUDIO: ret = decodeaudio (ist, &avpkt, &gotoutput); break; case AVMEDIATYPEVIDEO: ret = decodevideo (ist, &avpkt, &gotoutput); if (avpkt.duration) { duration = avrescaleq(avpkt.duration, ist->st->timebase, AVTIMEBASEQ); } else if(ist->st->codec->timebase.num != 0 && ist->st->codec->timebase.den != 0) { int ticks= ist->st->parser ? ist->st->parser->repeatpict+1 : ist->st->codec->ticksperframe; duration = ((int64t)AVTIMEBASE * ist->st->codec->timebase.num * ticks) / ist->st->codec->timebase.den; } else duration = 0; if(ist->dts != AVNOPTSVALUE && duration) { ist->nextdts += duration; }else ist->nextdts = AVNOPTSVALUE; if (gotoutput) ist->nextpts += duration; //FIXME the duration is not correct in some cases break; case AVMEDIATYPESUBTITLE: ret = transcodesubtitles(ist, &avpkt, &gotoutput); break; default: return -1; } if (ret < 0) return ret; avpkt.dts= avpkt.pts= AVNOPTSVALUE; // touch data and size only if not EOF if (pkt) { if(ist->st->codec->codectype != AVMEDIATYPEAUDIO) ret = avpkt.size; avpkt.data += ret; avpkt.size -= ret; } if (!gotoutput) { continue; } } /* handle stream copy */ if (!ist->decodingneeded) { rateemusleep(ist); ist->dts = ist->nextdts; switch (ist->st->codec->codectype) { case AVMEDIATYPEAUDIO: ist->nextdts += ((int64t)AVTIMEBASE * ist->st->codec->framesize) / ist->st->codec->samplerate; break; case AVMEDIATYPEVIDEO: if (pkt->duration) { ist->nextdts += avrescaleq(pkt->duration, ist->st->timebase, AVTIMEBASEQ); } else if(ist->st->codec->timebase.num != 0) { int ticks= ist->st->parser ? ist->st->parser->repeatpict + 1 : ist->st->codec->ticksperframe; ist->nextdts += ((int64t)AVTIMEBASE * ist->st->codec->timebase.num * ticks) / ist->st->codec->timebase.den; } break; } ist->pts = ist->dts; ist->nextpts = ist->nextdts; } for (i = 0; pkt && i < nboutputstreams; i++) { OutputStream *ost = outputstreams[i]; if (!checkoutputconstraints(ist, ost) || ost->encodingneeded) continue; dostreamcopy(ist, ost, pkt); } return 0; } ", "target": 0}
{"func": "void qemusystemreset(void) { QEMUResetEntry *re, *nre; /* reset all devices */ QTAILQFOREACHSAFE(re, &resethandlers, entry, nre) { re->func(re->opaque); } }", "target": 1}
{"func": "static void sdreset(SDState *sd, BlockDriverState *bdrv) { uint64t size; uint64t sect; if (bdrv) { bdrvgetgeometry(bdrv, &sect); } else { sect = 0; } size = sect << 9; sect = (size >> (HWBLOCKSHIFT + SECTORSHIFT + WPGROUPSHIFT)) + 1; sd->state = sdidlestate; sd->rca = 0x0000; sdsetocr(sd); sdsetscr(sd); sdsetcid(sd); sdsetcsd(sd, size); sdsetcardstatus(sd); sdsetsdstatus(sd); sd->bdrv = bdrv; if (sd->wpgroups) gfree(sd->wpgroups); sd->wpswitch = bdrv ? bdrvisreadonly(bdrv) : 0; sd->wpgroups = (int *) gmalloc0(sizeof(int) * sect); memset(sd->functiongroup, 0, sizeof(int) * 6); sd->erasestart = 0; sd->eraseend = 0; sd->size = size; sd->blklen = 0x200; sd->pwdlen = 0; sd->expectingacmd = 0; } ", "target": 0}
{"func": "static void physpageset(AddressSpaceDispatch *d, targetphysaddrt index, targetphysaddrt nb, uint16t leaf) { /* Wildly overreserve - it doesn't matter much. */ physmapnodereserve(3 * PL2LEVELS); physpagesetlevel(&d->physmap, &index, &nb, leaf, PL2LEVELS - 1); } ", "target": 0}
{"func": "static inline void tcgoutop(TCGContext *s, TCGOpcode opc, const TCGArg *args, const int *constargs) { int c; switch (opc) { case INDEXopexittb: if (checkfittl(args[0], 13)) { tcgoutarithi(s, TCGREGG0, TCGREGI7, 8, RETURN); tcgoutmoviimm13(s, TCGREGO0, args[0]); } else { tcgoutmovi(s, TCGTYPEPTR, TCGREGI0, args[0] & ~0x3ff); tcgoutarithi(s, TCGREGG0, TCGREGI7, 8, RETURN); tcgoutarithi(s, TCGREGO0, TCGREGO0, args[0] & 0x3ff, ARITHOR); } break; case INDEXopgototb: if (s->tbjmpoffset) { /* direct jump method */ uint32t oldinsn = *(uint32t *)s->codeptr; s->tbjmpoffset[args[0]] = s->codeptr - s->codebuf; /* Make sure to preserve links during retranslation. */ tcgout32(s, CALL | (oldinsn & ~INSNOP(-1))); } else { /* indirect jump method */ tcgoutldptr(s, TCGREGT1, (uintptrt)(s->tbnext + args[0])); tcgoutarithi(s, TCGREGG0, TCGREGT1, 0, JMPL); } tcgoutnop(s); s->tbnextoffset[args[0]] = s->codeptr - s->codebuf; break; case INDEXopcall: if (constargs[0]) { tcgoutcalli(s, args[0]); } else { tcgoutarithi(s, TCGREGO7, args[0], 0, JMPL); } /* delay slot */ tcgoutnop(s); break; case INDEXopbr: tcgoutbpcc(s, CONDA, BPCCPT, args[0]); tcgoutnop(s); break; case INDEXopmovii32: tcgoutmovi(s, TCGTYPEI32, args[0], (uint32t)args[1]); break; #define OP3264(x) \\ glue(glue(case INDEXop, x), i32): \\ glue(glue(case INDEXop, x), i64) OP3264(ld8u): tcgoutldst(s, args[0], args[1], args[2], LDUB); break; OP3264(ld8s): tcgoutldst(s, args[0], args[1], args[2], LDSB); break; OP3264(ld16u): tcgoutldst(s, args[0], args[1], args[2], LDUH); break; OP3264(ld16s): tcgoutldst(s, args[0], args[1], args[2], LDSH); break; case INDEXopldi32: case INDEXopld32ui64: tcgoutldst(s, args[0], args[1], args[2], LDUW); break; OP3264(st8): tcgoutldst(s, args[0], args[1], args[2], STB); break; OP3264(st16): tcgoutldst(s, args[0], args[1], args[2], STH); break; case INDEXopsti32: case INDEXopst32i64: tcgoutldst(s, args[0], args[1], args[2], STW); break; OP3264(add): c = ARITHADD; goto genarith; OP3264(sub): c = ARITHSUB; goto genarith; OP3264(and): c = ARITHAND; goto genarith; OP3264(andc): c = ARITHANDN; goto genarith; OP3264(or): c = ARITHOR; goto genarith; OP3264(orc): c = ARITHORN; goto genarith; OP3264(xor): c = ARITHXOR; goto genarith; case INDEXopshli32: c = SHIFTSLL; doshift32: /* Limit immediate shift count lest we create an illegal insn. */ tcgoutarithc(s, args[0], args[1], args[2] & 31, constargs[2], c); break; case INDEXopshri32: c = SHIFTSRL; goto doshift32; case INDEXopsari32: c = SHIFTSRA; goto doshift32; case INDEXopmuli32: c = ARITHUMUL; goto genarith; OP3264(neg): \tc = ARITHSUB; \tgoto genarith1; OP3264(not): \tc = ARITHORN; \tgoto genarith1; case INDEXopdivi32: tcgoutdiv32(s, args[0], args[1], args[2], constargs[2], 0); break; case INDEXopdivui32: tcgoutdiv32(s, args[0], args[1], args[2], constargs[2], 1); break; case INDEXopbrcondi32: tcgoutbrcondi32(s, args[2], args[0], args[1], constargs[1], args[3]); break; case INDEXopsetcondi32: tcgoutsetcondi32(s, args[3], args[0], args[1], args[2], constargs[2]); break; case INDEXopmovcondi32: tcgoutmovcondi32(s, args[5], args[0], args[1], args[2], constargs[2], args[3], constargs[3]); break; case INDEXopadd2i32: tcgoutaddsub2(s, args[0], args[1], args[2], args[3], args[4], constargs[4], args[5], constargs[5], ARITHADDCC, ARITHADDX); break; case INDEXopsub2i32: tcgoutaddsub2(s, args[0], args[1], args[2], args[3], args[4], constargs[4], args[5], constargs[5], ARITHSUBCC, ARITHSUBX); break; case INDEXopmulu2i32: c = ARITHUMUL; goto domul2; case INDEXopmuls2i32: c = ARITHSMUL; domul2: /* The 32-bit multiply insns produce a full 64-bit result. If the destination register can hold it, we can avoid the slower RDY. */ tcgoutarithc(s, args[0], args[2], args[3], constargs[3], c); if (SPARC64 || args[0] <= TCGREGO7) { tcgoutarithi(s, args[1], args[0], 32, SHIFTSRLX); } else { tcgoutrdy(s, args[1]); } break; case INDEXopqemuldi32: tcgoutqemuld(s, args[0], args[1], args[2], args[3], false); break; case INDEXopqemuldi64: tcgoutqemuld(s, args[0], args[1], args[2], args[3], true); break; case INDEXopqemusti32: tcgoutqemust(s, args[0], args[1], args[2], args[3]); break; case INDEXopqemusti64: tcgoutqemust(s, args[0], args[1], args[2], args[3]); break; case INDEXopmovii64: tcgoutmovi(s, TCGTYPEI64, args[0], args[1]); break; case INDEXopld32si64: tcgoutldst(s, args[0], args[1], args[2], LDSW); break; case INDEXopldi64: tcgoutldst(s, args[0], args[1], args[2], LDX); break; case INDEXopsti64: tcgoutldst(s, args[0], args[1], args[2], STX); break; case INDEXopshli64: c = SHIFTSLLX; doshift64: /* Limit immediate shift count lest we create an illegal insn. */ tcgoutarithc(s, args[0], args[1], args[2] & 63, constargs[2], c); break; case INDEXopshri64: c = SHIFTSRLX; goto doshift64; case INDEXopsari64: c = SHIFTSRAX; goto doshift64; case INDEXopmuli64: c = ARITHMULX; goto genarith; case INDEXopdivi64: c = ARITHSDIVX; goto genarith; case INDEXopdivui64: c = ARITHUDIVX; goto genarith; case INDEXopext32si64: tcgoutarithi(s, args[0], args[1], 0, SHIFTSRA); break; case INDEXopext32ui64: tcgoutarithi(s, args[0], args[1], 0, SHIFTSRL); break; case INDEXoptruncshri32: if (args[2] == 0) { tcgoutmov(s, TCGTYPEI32, args[0], args[1]); } else { tcgoutarithi(s, args[0], args[1], args[2], SHIFTSRLX); } break; case INDEXopbrcondi64: tcgoutbrcondi64(s, args[2], args[0], args[1], constargs[1], args[3]); break; case INDEXopsetcondi64: tcgoutsetcondi64(s, args[3], args[0], args[1], args[2], constargs[2]); break; case INDEXopmovcondi64: tcgoutmovcondi64(s, args[5], args[0], args[1], args[2], constargs[2], args[3], constargs[3]); break; genarith: tcgoutarithc(s, args[0], args[1], args[2], constargs[2], c); break; genarith1: \ttcgoutarithc(s, args[0], TCGREGG0, args[1], constargs[1], c); \tbreak; default: fprintf(stderr, \"unknown opcode 0x%x\\n\", opc); tcgabort(); } } ", "target": 0}
{"func": "static int eightsvxdecodeframe(AVCodecContext *avctx, void *data, int *gotframeptr, AVPacket *avpkt) { EightSvxContext *esc = avctx->privdata; int n, outdatasize; int ch, ret; uint8t *src; /* decode and interleave the first packet */ if (!esc->samples && avpkt) { int packetsize = avpkt->size; if (packetsize % avctx->channels) { avlog(avctx, AVLOGWARNING, \"Packet with odd size, ignoring last byte\\n\"); if (packetsize < avctx->channels) return packetsize; packetsize -= packetsize % avctx->channels; } esc->samplessize = !esc->table ? packetsize : avctx->channels + (packetsize-avctx->channels) * 2; if (!(esc->samples = avmalloc(esc->samplessize))) return AVERROR(ENOMEM); /* decompress */ if (esc->table) { const uint8t *buf = avpkt->data; uint8t *dst; int bufsize = avpkt->size; int i, n = esc->samplessize; if (bufsize < 2) { avlog(avctx, AVLOGERROR, \"packet size is too small\\n\"); return AVERROR(EINVAL); } /* the uncompressed starting value is contained in the first byte */ dst = esc->samples; for (i = 0; i < avctx->channels; i++) { *(dst++) = buf[0]+128; deltadecode(dst, buf + 1, bufsize / avctx->channels - 1, (buf[0]+128)&0xFF, esc->table); buf += bufsize / avctx->channels; dst += n / avctx->channels - 1; } } else { rawdecode(esc->samples, avpkt->data, esc->samplessize); } } /* get output buffer */ avassert1(!(esc->samplessize % avctx->channels || esc->samplesidx % avctx->channels)); esc->frame.nbsamples = FFMIN(MAXFRAMESIZE, esc->samplessize - esc->samplesidx) / avctx->channels; if ((ret = avctx->getbuffer(avctx, &esc->frame)) < 0) { avlog(avctx, AVLOGERROR, \"getbuffer() failed\\n\"); return ret; } *gotframeptr = 1; *(AVFrame *)data = esc->frame; outdatasize = esc->frame.nbsamples; for (ch = 0; ch<avctx->channels; ch++) { src = esc->samples + esc->samplesidx / avctx->channels + ch * esc->samplessize / avctx->channels; memcpy(esc->frame.data[ch], src, outdatasize); } outdatasize *= avctx->channels; esc->samplesidx += outdatasize; return esc->table ? (avctx->framenumber == 0)*2 + outdatasize / 2 : outdatasize; } ", "target": 0}
{"func": "static int virtioserialload(QEMUFile *f, void *opaque, int versionid) { VirtIOSerial *s = opaque; VirtIOSerialPort *port; uint32t maxnrports, nractiveports, portsmap; unsigned int i; int ret; if (versionid > 3) { return -EINVAL; } /* The virtio device */ ret = virtioload(&s->vdev, f); if (ret) { return ret; } if (versionid < 2) { return 0; } /* The config space */ qemugetbe16s(f, &s->config.cols); qemugetbe16s(f, &s->config.rows); qemugetbe32s(f, &maxnrports); tswap32s(&maxnrports); if (maxnrports > tswap32(s->config.maxnrports)) { /* Source could have had more ports than us. Fail migration. */ return -EINVAL; } for (i = 0; i < (maxnrports + 31) / 32; i++) { qemugetbe32s(f, &portsmap); if (portsmap != s->portsmap[i]) { /* * Ports active on source and destination don't * match. Fail migration. */ return -EINVAL; } } qemugetbe32s(f, &nractiveports); /* Items in struct VirtIOSerialPort */ for (i = 0; i < nractiveports; i++) { uint32t id; bool hostconnected; id = qemugetbe32(f); port = findportbyid(s, id); if (!port) { return -EINVAL; } port->guestconnected = qemugetbyte(f); hostconnected = qemugetbyte(f); if (hostconnected != port->hostconnected) { /* * We have to let the guest know of the host connection * status change */ sendcontrolevent(port, VIRTIOCONSOLEPORTOPEN, port->hostconnected); } if (versionid > 2) { uint32t elempopped; qemugetbe32s(f, &elempopped); if (elempopped) { qemugetbe32s(f, &port->iovidx); qemugetbe64s(f, &port->iovoffset); qemugetbuffer(f, (unsigned char *)&port->elem, sizeof(port->elem)); virtqueuemapsg(port->elem.insg, port->elem.inaddr, port->elem.innum, 1); virtqueuemapsg(port->elem.outsg, port->elem.outaddr, port->elem.outnum, 1); /* * Port was throttled on source machine. Let's * unthrottle it here so data starts flowing again. */ virtioserialthrottleport(port, false); } } } return 0; } ", "target": 0}
{"func": "static CharDriverState *qemuchropenspiceport(const char *id, ChardevBackend *backend, ChardevReturn *ret, Error **errp) { const char *name = backend->spiceport->fqdn; CharDriverState *chr; SpiceCharDriver *s; if (name == NULL) { fprintf(stderr, \"spice-qemu-char: missing name parameter\\n\"); return NULL; } chr = chropen(\"port\", spiceportsetfeopen); s = chr->opaque; s->sin.portname = gstrdup(name); return chr; } ", "target": 0}
{"func": "void cpubreakpointremovebyref(CPUState *cpu, CPUBreakpoint *breakpoint) { #if defined(TARGETHASICE) QTAILQREMOVE(&cpu->breakpoints, breakpoint, entry); breakpointinvalidate(cpu, breakpoint->pc); gfree(breakpoint); #endif } ", "target": 0}
{"func": "static int flvwritetrailer(AVFormatContext *s) { int64t filesize; AVIOContext *pb = s->pb; FLVContext *flv = s->privdata; int i; /* Add EOS tag */ for (i = 0; i < s->nbstreams; i++) { AVCodecContext *enc = s->streams[i]->codec; FLVStreamContext *sc = s->streams[i]->privdata; if (enc->codectype == AVMEDIATYPEVIDEO && enc->codecid == AVCODECIDH264) putavceostag(pb, sc->lastts); } filesize = aviotell(pb); /* update information */ avioseek(pb, flv->durationoffset, SEEKSET); putamfdouble(pb, flv->duration / (double)1000); avioseek(pb, flv->filesizeoffset, SEEKSET); putamfdouble(pb, filesize); avioseek(pb, filesize, SEEKSET); return 0; } ", "target": 1}
{"func": "static const void *bostonfdtfilter(void *opaque, const void *fdtorig, const void *matchdata, hwaddr *loadaddr) { BostonState *s = BOSTON(opaque); MachineState *machine = s->mach; const char *cmdline; int err; void *fdt; sizet fdtsz, ramlowsz, ramhighsz; fdtsz = fdttotalsize(fdtorig) * 2; fdt = gmalloc0(fdtsz); err = fdtopeninto(fdtorig, fdt, fdtsz); if (err) { fprintf(stderr, \"unable to open FDT\\n\"); return NULL; } cmdline = (machine->kernelcmdline && machine->kernelcmdline[0]) ? machine->kernelcmdline : \" \"; err = qemufdtsetpropstring(fdt, \"/chosen\", \"bootargs\", cmdline); if (err < 0) { fprintf(stderr, \"couldn't set /chosen/bootargs\\n\"); return NULL; } ramlowsz = MIN(256 * MBYTE, machine->ramsize); ramhighsz = machine->ramsize - ramlowsz; qemufdtsetpropsizedcells(fdt, \"/memory@0\", \"reg\", 1, 0x00000000, 1, ramlowsz, 1, 0x90000000, 1, ramhighsz); fdt = grealloc(fdt, fdttotalsize(fdt)); qemufdtdumpdtb(fdt, fdtsz); s->fdtbase = *loadaddr; return fdt; } ", "target": 1}
{"func": "static int movreadcmov(MOVContext *c, AVIOContext *pb, MOVAtom atom) { #if CONFIGZLIB AVIOContext ctx; uint8t *cmovdata; uint8t *moovdata; /* uncompressed data */ long cmovlen, moovlen; int ret = -1; aviorb32(pb); /* dcom atom */ if (aviorl32(pb) != MKTAG('d','c','o','m')) return AVERRORINVALIDDATA; if (aviorl32(pb) != MKTAG('z','l','i','b')) { avlog(c->fc, AVLOGERROR, \"unknown compression for cmov atom !\"); return AVERRORINVALIDDATA; } aviorb32(pb); /* cmvd atom */ if (aviorl32(pb) != MKTAG('c','m','v','d')) return AVERRORINVALIDDATA; moovlen = aviorb32(pb); /* uncompressed size */ cmovlen = atom.size - 6 * 4; cmovdata = avmalloc(cmovlen); if (!cmovdata) return AVERROR(ENOMEM); moovdata = avmalloc(moovlen); if (!moovdata) { avfree(cmovdata); return AVERROR(ENOMEM); } avioread(pb, cmovdata, cmovlen); if (uncompress (moovdata, (uLongf *) &moovlen, (const Bytef *)cmovdata, cmovlen) != ZOK) goto freeandreturn; if (ffioinitcontext(&ctx, moovdata, moovlen, 0, NULL, NULL, NULL, NULL) != 0) goto freeandreturn; atom.type = MKTAG('m','o','o','v'); atom.size = moovlen; ret = movreaddefault(c, &ctx, atom); freeandreturn: avfree(moovdata); avfree(cmovdata); return ret; #else avlog(c->fc, AVLOGERROR, \"this file requires zlib support compiled in\\n\"); return AVERROR(ENOSYS); #endif } ", "target": 1}
{"func": "static int sdpparsertpmap(AVFormatContext *s, AVCodecContext *codec, RTSPStream *rtspst, int payloadtype, const char *p) { char buf[256]; int i; AVCodec *c; const char *cname; /* Loop into AVRtpDynamicPayloadTypes[] and AVRtpPayloadTypes[] and * see if we can handle this kind of payload. * The space should normally not be there but some Real streams or * particular servers (\"RealServer Version 6.1.3.970\", see issue 1658) * have a trailing space. */ getwordsep(buf, sizeof(buf), \"/ \", &p); if (payloadtype >= RTPPTPRIVATE) { RTPDynamicProtocolHandler *handler; for (handler = RTPFirstDynamicPayloadHandler; handler; handler = handler->next) { if (!strcasecmp(buf, handler->encname) && codec->codectype == handler->codectype) { codec->codecid = handler->codecid; rtspst->dynamichandler = handler; if (handler->open) rtspst->dynamicprotocolcontext = handler->open(); break; } } } else { /* We are in a standard case * (from http://www.iana.org/assignments/rtp-parameters). */ /* search into AVRtpPayloadTypes[] */ codec->codecid = ffrtpcodecid(buf, codec->codectype); } c = avcodecfinddecoder(codec->codecid); if (c && c->name) cname = c->name; else cname = (char *) NULL; if (cname) { getwordsep(buf, sizeof(buf), \"/\", &p); i = atoi(buf); switch (codec->codectype) { case CODECTYPEAUDIO: avlog(s, AVLOGDEBUG, \"audio codec set to: %s\\n\", cname); codec->samplerate = RTSPDEFAULTAUDIOSAMPLERATE; codec->channels = RTSPDEFAULTNBAUDIOCHANNELS; if (i > 0) { codec->samplerate = i; getwordsep(buf, sizeof(buf), \"/\", &p); i = atoi(buf); if (i > 0) codec->channels = i; // TODO: there is a bug here; if it is a mono stream, and // less than 22000Hz, faad upconverts to stereo and twice // the frequency. No problem, but the sample rate is being // set here by the sdp line. Patch on its way. (rdm) } avlog(s, AVLOGDEBUG, \"audio samplerate set to: %i\\n\", codec->samplerate); avlog(s, AVLOGDEBUG, \"audio channels set to: %i\\n\", codec->channels); break; case CODECTYPEVIDEO: avlog(s, AVLOGDEBUG, \"video codec set to: %s\\n\", cname); break; default: break; } return 0; } return -1; } ", "target": 1}
{"func": "void ffmpvframeend(MpegEncContext *s) { #if FFAPIXVMC FFDISABLEDEPRECATIONWARNINGS /* redraw edges for the frame if decoding didn't complete */ // just to make sure that all data is rendered. if (CONFIGMPEGXVMCDECODER && s->avctx->xvmcacceleration) { ffxvmcfieldend(s); } else FFENABLEDEPRECATIONWARNINGS #endif /* FFAPIXVMC */ emmsc(); if (s->currentpicture.reference) ffthreadreportprogress(&s->currentpictureptr->tf, INTMAX, 0); } ", "target": 0}
{"func": "static int readffserverstreams(AVFormatContext *s, const char *filename) { int i, err; AVFormatContext *ic; int nopts = 0; err = avopeninputfile(&ic, filename, NULL, FFMPACKETSIZE, NULL); if (err < 0) return err; /* copy stream format */ s->nbstreams = ic->nbstreams; for(i=0;i<ic->nbstreams;i++) { AVStream *st; AVCodec *codec; // FIXME: a more elegant solution is needed st = avmallocz(sizeof(AVStream)); memcpy(st, ic->streams[i], sizeof(AVStream)); st->codec = avcodecalloccontext(); if (!st->codec) { printerror(filename, AVERROR(ENOMEM)); ffmpegexit(1); } avcodeccopycontext(st->codec, ic->streams[i]->codec); s->streams[i] = st; codec = avcodecfindencoder(st->codec->codecid); if (st->codec->codectype == AVMEDIATYPEAUDIO) { if (audiostreamcopy) { st->streamcopy = 1; } else choosesamplefmt(st, codec); } else if (st->codec->codectype == AVMEDIATYPEVIDEO) { if (videostreamcopy) { st->streamcopy = 1; } else choosepixelfmt(st, codec); } if(!st->codec->threadcount) st->codec->threadcount = 1; if(st->codec->threadcount>1) avcodecthreadinit(st->codec, st->codec->threadcount); if(st->codec->flags & CODECFLAGBITEXACT) nopts = 1; } if (!nopts) s->timestamp = avgettime(); avcloseinputfile(ic); return 0; } ", "target": 1}
{"func": "static void uninit(AVFilterContext *ctx) { ZScaleContext *s = ctx->priv; zimgfiltergraphfree(s->graph); avfreep(&s->tmp); s->tmpsize = 0; }", "target": 1}
{"func": "static void decodeboaddrmodepostprebase(CPUTriCoreState *env, DisasContext *ctx) { uint32t op2; uint32t off10; int32t r1, r2; TCGv temp; r1 = MASKOPBOS1D(ctx->opcode); r2 = MASKOPBOS2(ctx->opcode); off10 = MASKOPBOOFF10SEXT(ctx->opcode); op2 = MASKOPBOOP2(ctx->opcode); switch (op2) { case OPC232BOCACHEAWISHORTOFF: case OPC232BOCACHEAWSHORTOFF: case OPC232BOCACHEAISHORTOFF: /* instruction to access the cache */ break; case OPC232BOCACHEAWIPOSTINC: case OPC232BOCACHEAWPOSTINC: case OPC232BOCACHEAIPOSTINC: /* instruction to access the cache, but we still need to handle the addressing mode */ tcggenadditl(cpugprd[r2], cpugprd[r2], off10); break; case OPC232BOCACHEAWIPREINC: case OPC232BOCACHEAWPREINC: case OPC232BOCACHEAIPREINC: /* instruction to access the cache, but we still need to handle the addressing mode */ tcggenadditl(cpugprd[r2], cpugprd[r2], off10); break; case OPC232BOCACHEIWISHORTOFF: case OPC232BOCACHEIWSHORTOFF: /* TODO: Raise illegal opcode trap, if tricorefeature(TRICOREFEATURE13) */ break; case OPC232BOCACHEIWPOSTINC: case OPC232BOCACHEIWIPOSTINC: if (!tricorefeature(env, TRICOREFEATURE13)) { tcggenadditl(cpugprd[r2], cpugprd[r2], off10); } /* TODO: else raise illegal opcode trap */ break; case OPC232BOCACHEIWPREINC: case OPC232BOCACHEIWIPREINC: if (!tricorefeature(env, TRICOREFEATURE13)) { tcggenadditl(cpugprd[r2], cpugprd[r2], off10); } /* TODO: else raise illegal opcode trap */ break; case OPC232BOSTASHORTOFF: genoffsetst(ctx, cpugpra[r1], cpugpra[r2], off10, MOLESL); break; case OPC232BOSTAPOSTINC: tcggenqemusttl(cpugpra[r1], cpugpra[r2], ctx->memidx, MOLESL); tcggenadditl(cpugpra[r2], cpugpra[r2], off10); break; case OPC232BOSTAPREINC: genstpreincr(ctx, cpugpra[r1], cpugpra[r2], off10, MOLESL); break; case OPC232BOSTBSHORTOFF: genoffsetst(ctx, cpugprd[r1], cpugpra[r2], off10, MOUB); break; case OPC232BOSTBPOSTINC: tcggenqemusttl(cpugprd[r1], cpugpra[r2], ctx->memidx, MOUB); tcggenadditl(cpugpra[r2], cpugpra[r2], off10); break; case OPC232BOSTBPREINC: genstpreincr(ctx, cpugprd[r1], cpugpra[r2], off10, MOUB); break; case OPC232BOSTDSHORTOFF: genoffsetst2regs(cpugprd[r1+1], cpugprd[r1], cpugpra[r2], off10, ctx); break; case OPC232BOSTDPOSTINC: genst2regs64(cpugprd[r1+1], cpugprd[r1], cpugpra[r2], ctx); tcggenadditl(cpugpra[r2], cpugpra[r2], off10); break; case OPC232BOSTDPREINC: temp = tcgtempnew(); tcggenadditl(temp, cpugpra[r2], off10); genst2regs64(cpugprd[r1+1], cpugprd[r1], temp, ctx); tcggenmovtl(cpugpra[r2], temp); tcgtempfree(temp); break; case OPC232BOSTDASHORTOFF: genoffsetst2regs(cpugpra[r1+1], cpugpra[r1], cpugpra[r2], off10, ctx); break; case OPC232BOSTDAPOSTINC: genst2regs64(cpugpra[r1+1], cpugpra[r1], cpugpra[r2], ctx); tcggenadditl(cpugpra[r2], cpugpra[r2], off10); break; case OPC232BOSTDAPREINC: temp = tcgtempnew(); tcggenadditl(temp, cpugpra[r2], off10); genst2regs64(cpugpra[r1+1], cpugpra[r1], temp, ctx); tcggenmovtl(cpugpra[r2], temp); tcgtempfree(temp); break; case OPC232BOSTHSHORTOFF: genoffsetst(ctx, cpugprd[r1], cpugpra[r2], off10, MOLEUW); break; case OPC232BOSTHPOSTINC: tcggenqemusttl(cpugprd[r1], cpugpra[r2], ctx->memidx, MOLEUW); tcggenadditl(cpugpra[r2], cpugpra[r2], off10); break; case OPC232BOSTHPREINC: genstpreincr(ctx, cpugprd[r1], cpugpra[r2], off10, MOLEUW); break; case OPC232BOSTQSHORTOFF: temp = tcgtempnew(); tcggenshritl(temp, cpugprd[r1], 16); genoffsetst(ctx, temp, cpugpra[r2], off10, MOLEUW); tcgtempfree(temp); break; case OPC232BOSTQPOSTINC: temp = tcgtempnew(); tcggenshritl(temp, cpugprd[r1], 16); tcggenqemusttl(temp, cpugpra[r2], ctx->memidx, MOLEUW); tcggenadditl(cpugpra[r2], cpugpra[r2], off10); tcgtempfree(temp); break; case OPC232BOSTQPREINC: temp = tcgtempnew(); tcggenshritl(temp, cpugprd[r1], 16); genstpreincr(ctx, temp, cpugpra[r2], off10, MOLEUW); tcgtempfree(temp); break; case OPC232BOSTWSHORTOFF: genoffsetst(ctx, cpugprd[r1], cpugpra[r2], off10, MOLEUL); break; case OPC232BOSTWPOSTINC: tcggenqemusttl(cpugprd[r1], cpugpra[r2], ctx->memidx, MOLEUL); tcggenadditl(cpugpra[r2], cpugpra[r2], off10); break; case OPC232BOSTWPREINC: genstpreincr(ctx, cpugprd[r1], cpugpra[r2], off10, MOLEUL); break; } } ", "target": 0}
{"func": "static int kvmmipsgetfpuregisters(CPUState *cs) { MIPSCPU *cpu = MIPSCPU(cs); CPUMIPSState *env = &cpu->env; int err, ret = 0; unsigned int i; /* Only get FPU state if we're emulating a CPU with an FPU */ if (env->CP0Config1 & (1 << CP0C1FP)) { /* FPU Control Registers */ err = kvmmipsgetoneureg(cs, KVMREGMIPSFCRIR, &env->activefpu.fcr0); if (err < 0) { DPRINTF(\"%s: Failed to get FCRIR (%d)\\n\", func, err); ret = err; } err = kvmmipsgetoneureg(cs, KVMREGMIPSFCRCSR, &env->activefpu.fcr31); if (err < 0) { DPRINTF(\"%s: Failed to get FCRCSR (%d)\\n\", func, err); ret = err; } else { restorefpstatus(env); } /* Floating point registers */ for (i = 0; i < 32; ++i) { if (env->CP0Status & (1 << CP0StFR)) { err = kvmmipsgetoneureg64(cs, KVMREGMIPSFPR64(i), &env->activefpu.fpr[i].d); } else { err = kvmmipsgetoneureg(cs, KVMREGMIPSFPR32(i), &env->activefpu.fpr[i].w[FPENDIANIDX]); } if (err < 0) { DPRINTF(\"%s: Failed to get FPR%u (%d)\\n\", func, i, err); ret = err; } } } return ret; } ", "target": 0}
{"func": "static void genloongsoninteger(DisasContext *ctx, uint32t opc, int rd, int rs, int rt) { const char *opn = \"loongson\"; TCGv t0, t1; if (rd == 0) { /* Treat as NOP. */ MIPSDEBUG(\"NOP\"); return; } switch (opc) { case OPCMULTG2E: case OPCMULTG2F: case OPCMULTUG2E: case OPCMULTUG2F: #if defined(TARGETMIPS64) case OPCDMULTG2E: case OPCDMULTG2F: case OPCDMULTUG2E: case OPCDMULTUG2F: #endif t0 = tcgtempnew(); t1 = tcgtempnew(); break; default: t0 = tcgtemplocalnew(); t1 = tcgtemplocalnew(); break; } genloadgpr(t0, rs); genloadgpr(t1, rt); switch (opc) { case OPCMULTG2E: case OPCMULTG2F: tcggenmultl(cpugpr[rd], t0, t1); tcggenext32stl(cpugpr[rd], cpugpr[rd]); opn = \"mult.g\"; break; case OPCMULTUG2E: case OPCMULTUG2F: tcggenext32utl(t0, t0); tcggenext32utl(t1, t1); tcggenmultl(cpugpr[rd], t0, t1); tcggenext32stl(cpugpr[rd], cpugpr[rd]); opn = \"multu.g\"; break; case OPCDIVG2E: case OPCDIVG2F: { int l1 = gennewlabel(); int l2 = gennewlabel(); int l3 = gennewlabel(); tcggenext32stl(t0, t0); tcggenext32stl(t1, t1); tcggenbrconditl(TCGCONDNE, t1, 0, l1); tcggenmovitl(cpugpr[rd], 0); tcggenbr(l3); gensetlabel(l1); tcggenbrconditl(TCGCONDNE, t0, INTMIN, l2); tcggenbrconditl(TCGCONDNE, t1, -1, l2); tcggenmovtl(cpugpr[rd], t0); tcggenbr(l3); gensetlabel(l2); tcggendivtl(cpugpr[rd], t0, t1); tcggenext32stl(cpugpr[rd], cpugpr[rd]); gensetlabel(l3); } opn = \"div.g\"; break; case OPCDIVUG2E: case OPCDIVUG2F: { int l1 = gennewlabel(); int l2 = gennewlabel(); tcggenext32utl(t0, t0); tcggenext32utl(t1, t1); tcggenbrconditl(TCGCONDNE, t1, 0, l1); tcggenmovitl(cpugpr[rd], 0); tcggenbr(l2); gensetlabel(l1); tcggendivutl(cpugpr[rd], t0, t1); tcggenext32stl(cpugpr[rd], cpugpr[rd]); gensetlabel(l2); } opn = \"divu.g\"; break; case OPCMODG2E: case OPCMODG2F: { int l1 = gennewlabel(); int l2 = gennewlabel(); int l3 = gennewlabel(); tcggenext32utl(t0, t0); tcggenext32utl(t1, t1); tcggenbrconditl(TCGCONDEQ, t1, 0, l1); tcggenbrconditl(TCGCONDNE, t0, INTMIN, l2); tcggenbrconditl(TCGCONDNE, t1, -1, l2); gensetlabel(l1); tcggenmovitl(cpugpr[rd], 0); tcggenbr(l3); gensetlabel(l2); tcggenremtl(cpugpr[rd], t0, t1); tcggenext32stl(cpugpr[rd], cpugpr[rd]); gensetlabel(l3); } opn = \"mod.g\"; break; case OPCMODUG2E: case OPCMODUG2F: { int l1 = gennewlabel(); int l2 = gennewlabel(); tcggenext32utl(t0, t0); tcggenext32utl(t1, t1); tcggenbrconditl(TCGCONDNE, t1, 0, l1); tcggenmovitl(cpugpr[rd], 0); tcggenbr(l2); gensetlabel(l1); tcggenremutl(cpugpr[rd], t0, t1); tcggenext32stl(cpugpr[rd], cpugpr[rd]); gensetlabel(l2); } opn = \"modu.g\"; break; #if defined(TARGETMIPS64) case OPCDMULTG2E: case OPCDMULTG2F: tcggenmultl(cpugpr[rd], t0, t1); opn = \"dmult.g\"; break; case OPCDMULTUG2E: case OPCDMULTUG2F: tcggenmultl(cpugpr[rd], t0, t1); opn = \"dmultu.g\"; break; case OPCDDIVG2E: case OPCDDIVG2F: { int l1 = gennewlabel(); int l2 = gennewlabel(); int l3 = gennewlabel(); tcggenbrconditl(TCGCONDNE, t1, 0, l1); tcggenmovitl(cpugpr[rd], 0); tcggenbr(l3); gensetlabel(l1); tcggenbrconditl(TCGCONDNE, t0, -1LL << 63, l2); tcggenbrconditl(TCGCONDNE, t1, -1LL, l2); tcggenmovtl(cpugpr[rd], t0); tcggenbr(l3); gensetlabel(l2); tcggendivtl(cpugpr[rd], t0, t1); gensetlabel(l3); } opn = \"ddiv.g\"; break; case OPCDDIVUG2E: case OPCDDIVUG2F: { int l1 = gennewlabel(); int l2 = gennewlabel(); tcggenbrconditl(TCGCONDNE, t1, 0, l1); tcggenmovitl(cpugpr[rd], 0); tcggenbr(l2); gensetlabel(l1); tcggendivutl(cpugpr[rd], t0, t1); gensetlabel(l2); } opn = \"ddivu.g\"; break; case OPCDMODG2E: case OPCDMODG2F: { int l1 = gennewlabel(); int l2 = gennewlabel(); int l3 = gennewlabel(); tcggenbrconditl(TCGCONDEQ, t1, 0, l1); tcggenbrconditl(TCGCONDNE, t0, -1LL << 63, l2); tcggenbrconditl(TCGCONDNE, t1, -1LL, l2); gensetlabel(l1); tcggenmovitl(cpugpr[rd], 0); tcggenbr(l3); gensetlabel(l2); tcggenremtl(cpugpr[rd], t0, t1); gensetlabel(l3); } opn = \"dmod.g\"; break; case OPCDMODUG2E: case OPCDMODUG2F: { int l1 = gennewlabel(); int l2 = gennewlabel(); tcggenbrconditl(TCGCONDNE, t1, 0, l1); tcggenmovitl(cpugpr[rd], 0); tcggenbr(l2); gensetlabel(l1); tcggenremutl(cpugpr[rd], t0, t1); gensetlabel(l2); } opn = \"dmodu.g\"; break; #endif } (void)opn; /* avoid a compiler warning */ MIPSDEBUG(\"%s %s, %s\", opn, regnames[rd], regnames[rs]); tcgtempfree(t0); tcgtempfree(t1); } ", "target": 0}
{"func": "static void vfiopciloadrom(VFIOPCIDevice *vdev) { struct vfioregioninfo reginfo = { .argsz = sizeof(reginfo), .index = VFIOPCIROMREGIONINDEX }; uint64t size; offt off = 0; sizet bytes; if (ioctl(vdev->vbasedev.fd, VFIODEVICEGETREGIONINFO, &reginfo)) { errorreport(\"vfio: Error getting ROM info: %m\"); return; } tracevfiopciloadrom(vdev->vbasedev.name, (unsigned long)reginfo.size, (unsigned long)reginfo.offset, (unsigned long)reginfo.flags); vdev->romsize = size = reginfo.size; vdev->romoffset = reginfo.offset; if (!vdev->romsize) { vdev->romreadfailed = true; errorreport(\"vfio-pci: Cannot read device rom at \" \"%s\", vdev->vbasedev.name); errorprintf(\"Device option ROM contents are probably invalid \" \"(check dmesg).\\nSkip option ROM probe with rombar=0, \" \"or load from file with romfile=\\n\"); return; } vdev->rom = gmalloc(size); memset(vdev->rom, 0xff, size); while (size) { bytes = pread(vdev->vbasedev.fd, vdev->rom + off, size, vdev->romoffset + off); if (bytes == 0) { break; } else if (bytes > 0) { off += bytes; size -= bytes; } else { if (errno == EINTR || errno == EAGAIN) { continue; } errorreport(\"vfio: Error reading device ROM: %m\"); break; } } } ", "target": 0}
{"func": "static bool trypollmode(AioContext *ctx, bool blocking) { if (blocking && ctx->pollmaxns && ctx->polldisablecnt == 0) { /* See qemusoonesttimeout() uint64t hack */ int64t maxns = MIN((uint64t)aiocomputetimeout(ctx), (uint64t)ctx->pollmaxns); if (maxns) { if (runpollhandlers(ctx, maxns)) { return true; } } } return false; } ", "target": 1}
{"func": "static void pcibasic(gconstpointer data) { QVirtioPCIDevice *dev; QPCIBus *bus; QVirtQueuePCI *tx, *rx; QGuestAllocator *alloc; void (*func) (const QVirtioBus *bus, QVirtioDevice *dev, QGuestAllocator *alloc, QVirtQueue *rvq, QVirtQueue *tvq, int socket) = data; int sv[2], ret; ret = socketpair(PFUNIX, SOCKSTREAM, 0, sv); gassertcmpint(ret, !=, -1); bus = pciteststart(sv[1]); dev = virtionetpciinit(bus, PCISLOT); alloc = pcallocinit(); rx = (QVirtQueuePCI *)qvirtqueuesetup(&qvirtiopci, &dev->vdev, alloc, 0); tx = (QVirtQueuePCI *)qvirtqueuesetup(&qvirtiopci, &dev->vdev, alloc, 1); driverinit(&qvirtiopci, &dev->vdev); func(&qvirtiopci, &dev->vdev, alloc, &rx->vq, &tx->vq, sv[0]); /* End test */ close(sv[0]); guestfree(alloc, tx->vq.desc); pcallocuninit(alloc); qvirtiopcidevicedisable(dev); gfree(dev); qpcifreepc(bus); testend(); } ", "target": 1}
{"func": "static void testqemustrtoulfullnegative(void) { const char *str = \" \\t -321\"; unsigned long res = 999; int err; err = qemustrtoul(str, NULL, 0, &res); gassertcmpint(err, ==, 0); gassertcmpint(res, ==, -321ul); } ", "target": 0}
{"func": "static int vncvalidatecertificate(struct VncState *vs) { int ret; unsigned int status; const gnutlsdatumt *certs; unsigned int nCerts, i; timet now; VNCDEBUG(\"Validating client certificate\\n\"); if ((ret = gnutlscertificateverifypeers2 (vs->tlssession, &status)) < 0) { \tVNCDEBUG(\"Verify failed %s\\n\", gnutlsstrerror(ret)); \treturn -1; } if ((now = time(NULL)) == ((timet)-1)) { \treturn -1; } if (status != 0) { \tif (status & GNUTLSCERTINVALID) \t VNCDEBUG(\"The certificate is not trusted.\\n\"); \tif (status & GNUTLSCERTSIGNERNOTFOUND) \t VNCDEBUG(\"The certificate hasn't got a known issuer.\\n\"); \tif (status & GNUTLSCERTREVOKED) \t VNCDEBUG(\"The certificate has been revoked.\\n\"); \tif (status & GNUTLSCERTINSECUREALGORITHM) \t VNCDEBUG(\"The certificate uses an insecure algorithm\\n\"); \treturn -1; } else { \tVNCDEBUG(\"Certificate is valid!\\n\"); } /* Only support x509 for now */ if (gnutlscertificatetypeget(vs->tlssession) != GNUTLSCRTX509) \treturn -1; if (!(certs = gnutlscertificategetpeers(vs->tlssession, &nCerts))) \treturn -1; for (i = 0 ; i < nCerts ; i++) { \tgnutlsx509crtt cert; \tVNCDEBUG (\"Checking certificate chain %d\\n\", i); \tif (gnutlsx509crtinit (&cert) < 0) \t return -1; \tif (gnutlsx509crtimport(cert, &certs[i], GNUTLSX509FMTDER) < 0) { \t gnutlsx509crtdeinit (cert); \t return -1; \t} \tif (gnutlsx509crtgetexpirationtime (cert) < now) { \t VNCDEBUG(\"The certificate has expired\\n\"); \t gnutlsx509crtdeinit (cert); \t return -1; \t} \tif (gnutlsx509crtgetactivationtime (cert) > now) { \t VNCDEBUG(\"The certificate is not yet activated\\n\"); \t gnutlsx509crtdeinit (cert); \t return -1; \t} \tif (gnutlsx509crtgetactivationtime (cert) > now) { \t VNCDEBUG(\"The certificate is not yet activated\\n\"); \t gnutlsx509crtdeinit (cert); \t return -1; \t} \tgnutlsx509crtdeinit (cert); } return 0; } ", "target": 0}
{"func": "int fwcfgaddcallback(void *opaque, uint16t key, FWCfgCallback callback, void *callbackopaque, uint8t *data, sizet len) { FWCfgState *s = opaque; int arch = !!(key & FWCFGARCHLOCAL); key &= FWCFGENTRYMASK; if (key >= FWCFGMAXENTRY || !(key & FWCFGWRITECHANNEL) || len > 65535) return 0; s->entries[arch][key].data = data; s->entries[arch][key].len = len; s->entries[arch][key].callbackopaque = callbackopaque; s->entries[arch][key].callback = callback; return 1; } ", "target": 0}
{"func": "static void lpcanalyzeremodulate(int32t *decoded, const int coeffs[32], int order, int qlevel, int len, int bps) { int i, j; int ebps = 1 << (bps-1); unsigned sigma = 0; for (i = order; i < len; i++) sigma |= decoded[i] + ebps; if (sigma < 2*ebps) return; for (i = len - 1; i >= order; i--) { int64t p = 0; for (j = 0; j < order; j++) p += coeffs[j] * (int64t)decoded[i-order+j]; decoded[i] -= p >> qlevel; } for (i = order; i < len; i++, decoded++) { int32t p = 0; for (j = 0; j < order; j++) p += coeffs[j] * (uint32t)decoded[j]; decoded[j] += p >> qlevel; } } ", "target": 1}
{"func": "static int readthread(void *arg) { VideoState *is = arg; AVFormatContext *ic = NULL; int err, i, ret; int stindex[AVMEDIATYPENB]; AVPacket pkt1, *pkt = &pkt1; int eof = 0; int pktinplayrange = 0; AVDictionaryEntry *t; AVDictionary **opts; int orignbstreams; SDLmutex *waitmutex = SDLCreateMutex(); memset(stindex, -1, sizeof(stindex)); is->lastvideostream = is->videostream = -1; is->lastaudiostream = is->audiostream = -1; is->lastsubtitlestream = is->subtitlestream = -1; ic = avformatalloccontext(); ic->interruptcallback.callback = decodeinterruptcb; ic->interruptcallback.opaque = is; err = avformatopeninput(&ic, is->filename, is->iformat, &formatopts); if (err < 0) { printerror(is->filename, err); ret = -1; goto fail; } if ((t = avdictget(formatopts, \"\", NULL, AVDICTIGNORESUFFIX))) { avlog(NULL, AVLOGERROR, \"Option %s not found.\\n\", t->key); ret = AVERROROPTIONNOTFOUND; goto fail; } is->ic = ic; if (genpts) ic->flags |= AVFMTFLAGGENPTS; opts = setupfindstreaminfoopts(ic, codecopts); orignbstreams = ic->nbstreams; err = avformatfindstreaminfo(ic, opts); if (err < 0) { fprintf(stderr, \"%s: could not find codec parameters\\n\", is->filename); ret = -1; goto fail; } for (i = 0; i < orignbstreams; i++) avdictfree(&opts[i]); avfreep(&opts); if (ic->pb) ic->pb->eofreached = 0; // FIXME hack, ffplay maybe should not use urlfeof() to test for the end if (seekbybytes < 0) seekbybytes = !!(ic->iformat->flags & AVFMTTSDISCONT); is->maxframeduration = (ic->iformat->flags & AVFMTTSDISCONT) ? 10.0 : 3600.0; /* if seeking requested, we execute it */ if (starttime != AVNOPTSVALUE) { int64t timestamp; timestamp = starttime; /* add the stream start time */ if (ic->starttime != AVNOPTSVALUE) timestamp += ic->starttime; ret = avformatseekfile(ic, -1, INT64MIN, timestamp, INT64MAX, 0); if (ret < 0) { fprintf(stderr, \"%s: could not seek to position %0.3f\\n\", is->filename, (double)timestamp / AVTIMEBASE); } } is->realtime = isrealtime(ic); for (i = 0; i < ic->nbstreams; i++) ic->streams[i]->discard = AVDISCARDALL; if (!videodisable) stindex[AVMEDIATYPEVIDEO] = avfindbeststream(ic, AVMEDIATYPEVIDEO, wantedstream[AVMEDIATYPEVIDEO], -1, NULL, 0); if (!audiodisable) stindex[AVMEDIATYPEAUDIO] = avfindbeststream(ic, AVMEDIATYPEAUDIO, wantedstream[AVMEDIATYPEAUDIO], stindex[AVMEDIATYPEVIDEO], NULL, 0); if (!videodisable) stindex[AVMEDIATYPESUBTITLE] = avfindbeststream(ic, AVMEDIATYPESUBTITLE, wantedstream[AVMEDIATYPESUBTITLE], (stindex[AVMEDIATYPEAUDIO] >= 0 ? stindex[AVMEDIATYPEAUDIO] : stindex[AVMEDIATYPEVIDEO]), NULL, 0); if (showstatus) { avdumpformat(ic, 0, is->filename, 0); } is->showmode = showmode; /* open the streams */ if (stindex[AVMEDIATYPEAUDIO] >= 0) { streamcomponentopen(is, stindex[AVMEDIATYPEAUDIO]); } ret = -1; if (stindex[AVMEDIATYPEVIDEO] >= 0) { ret = streamcomponentopen(is, stindex[AVMEDIATYPEVIDEO]); } if (is->showmode == SHOWMODENONE) is->showmode = ret >= 0 ? SHOWMODEVIDEO : SHOWMODERDFT; is->refreshtid = SDLCreateThread(refreshthread, is); if (stindex[AVMEDIATYPESUBTITLE] >= 0) { streamcomponentopen(is, stindex[AVMEDIATYPESUBTITLE]); } if (is->videostream < 0 && is->audiostream < 0) { fprintf(stderr, \"%s: could not open codecs\\n\", is->filename); ret = -1; goto fail; } if (infinitebuffer < 0 && is->realtime) infinitebuffer = 1; for (;;) { if (is->abortrequest) break; if (is->paused != is->lastpaused) { is->lastpaused = is->paused; if (is->paused) is->readpausereturn = avreadpause(ic); else avreadplay(ic); } #if CONFIGRTSPDEMUXER || CONFIGMMSHPROTOCOL if (is->paused && (!strcmp(ic->iformat->name, \"rtsp\") || (ic->pb && !strncmp(inputfilename, \"mmsh:\", 5)))) { /* wait 10 ms to avoid trying to get another packet */ /* XXX: horrible */ SDLDelay(10); continue; } #endif if (is->seekreq) { int64t seektarget = is->seekpos; int64t seekmin = is->seekrel > 0 ? seektarget - is->seekrel + 2: INT64MIN; int64t seekmax = is->seekrel < 0 ? seektarget - is->seekrel - 2: INT64MAX; // FIXME the +-2 is due to rounding being not done in the correct direction in generation // of the seekpos/seekrel variables ret = avformatseekfile(is->ic, -1, seekmin, seektarget, seekmax, is->seekflags); if (ret < 0) { fprintf(stderr, \"%s: error while seeking\\n\", is->ic->filename); } else { if (is->audiostream >= 0) { packetqueueflush(&is->audioq); packetqueueput(&is->audioq, &flushpkt); } if (is->subtitlestream >= 0) { packetqueueflush(&is->subtitleq); packetqueueput(&is->subtitleq, &flushpkt); } if (is->videostream >= 0) { packetqueueflush(&is->videoq); packetqueueput(&is->videoq, &flushpkt); } if (is->seekflags & AVSEEKFLAGBYTE) { //FIXME: use a cleaner way to signal obsolete external clock... updateexternalclockpts(is, (double)AVNOPTSVALUE); } else { updateexternalclockpts(is, seektarget / (double)AVTIMEBASE); } } is->seekreq = 0; eof = 0; if (is->paused) steptonextframe(is); } if (is->queueattachmentsreq) { avformatqueueattachedpictures(ic); is->queueattachmentsreq = 0; } /* if the queue are full, no need to read more */ if (infinitebuffer<1 && (is->audioq.size + is->videoq.size + is->subtitleq.size > MAXQUEUESIZE || ( (is->audioq .nbpackets > MINFRAMES || is->audiostream < 0 || is->audioq.abortrequest) && (is->videoq .nbpackets > MINFRAMES || is->videostream < 0 || is->videoq.abortrequest) && (is->subtitleq.nbpackets > MINFRAMES || is->subtitlestream < 0 || is->subtitleq.abortrequest)))) { /* wait 10 ms */ SDLLockMutex(waitmutex); SDLCondWaitTimeout(is->continuereadthread, waitmutex, 10); SDLUnlockMutex(waitmutex); continue; } if (eof) { if (is->videostream >= 0) { avinitpacket(pkt); pkt->data = NULL; pkt->size = 0; pkt->streamindex = is->videostream; packetqueueput(&is->videoq, pkt); } if (is->audiostream >= 0 && is->audiost->codec->codec->capabilities & CODECCAPDELAY) { avinitpacket(pkt); pkt->data = NULL; pkt->size = 0; pkt->streamindex = is->audiostream; packetqueueput(&is->audioq, pkt); } SDLDelay(10); if (is->audioq.size + is->videoq.size + is->subtitleq.size == 0) { if (loop != 1 && (!loop || --loop)) { streamseek(is, starttime != AVNOPTSVALUE ? starttime : 0, 0, 0); } else if (autoexit) { ret = AVERROREOF; goto fail; } } eof=0; continue; } ret = avreadframe(ic, pkt); if (ret < 0) { if (ret == AVERROREOF || urlfeof(ic->pb)) eof = 1; if (ic->pb && ic->pb->error) break; SDLLockMutex(waitmutex); SDLCondWaitTimeout(is->continuereadthread, waitmutex, 10); SDLUnlockMutex(waitmutex); continue; } /* check if packet is in play range specified by user, then queue, otherwise discard */ pktinplayrange = duration == AVNOPTSVALUE || (pkt->pts - ic->streams[pkt->streamindex]->starttime) * avq2d(ic->streams[pkt->streamindex]->timebase) - (double)(starttime != AVNOPTSVALUE ? starttime : 0) / 1000000 <= ((double)duration / 1000000); if (pkt->streamindex == is->audiostream && pktinplayrange) { packetqueueput(&is->audioq, pkt); } else if (pkt->streamindex == is->videostream && pktinplayrange) { packetqueueput(&is->videoq, pkt); } else if (pkt->streamindex == is->subtitlestream && pktinplayrange) { packetqueueput(&is->subtitleq, pkt); } else { avfreepacket(pkt); } } /* wait until the end */ while (!is->abortrequest) { SDLDelay(100); } ret = 0; fail: /* close each stream */ if (is->audiostream >= 0) streamcomponentclose(is, is->audiostream); if (is->videostream >= 0) streamcomponentclose(is, is->videostream); if (is->subtitlestream >= 0) streamcomponentclose(is, is->subtitlestream); if (is->ic) { avformatcloseinput(&is->ic); } if (ret != 0) { SDLEvent event; event.type = FFQUITEVENT; event.user.data1 = is; SDLPushEvent(&event); } SDLDestroyMutex(waitmutex); return 0; } ", "target": 0}
{"func": "int ffxvmcfieldstart(MpegEncContext *s, AVCodecContext *avctx) { struct xvmcpixfmt *last, *next, *render = (struct xvmcpixfmt*)s->currentpicture.data[2]; const int mbblockcount = 4 + (1 << s->chromaformat); assert(avctx); if (!render || render->xvmcid != AVXVMCID || !render->datablocks || !render->mvblocks) { avlog(avctx, AVLOGERROR, \"Render token doesn't look as expected.\\n\"); return -1; // make sure that this is a render packet } if (render->filledmvblocksnum) { avlog(avctx, AVLOGERROR, \"Rendering surface contains %i unprocessed blocks.\\n\", render->filledmvblocksnum); return -1; } if (render->allocatedmvblocks < 1 || render->allocateddatablocks < render->allocatedmvblocks*mbblockcount || render->startmvblocksnum >= render->allocatedmvblocks || render->nextfreedatablocknum > render->allocateddatablocks - mbblockcount*(render->allocatedmvblocks-render->startmvblocksnum)) { avlog(avctx, AVLOGERROR, \"Rendering surface doesn't provide enough block structures to work with.\\n\"); return -1; } render->picturestructure = s->picturestructure; render->flags = s->firstfield ? 0 : XVMCSECONDFIELD; render->pfuturesurface = NULL; render->ppastsurface = NULL; switch(s->picttype) { case FFITYPE: return 0; // no prediction from other frames case FFBTYPE: next = (struct xvmcpixfmt*)s->nextpicture.data[2]; if (!next) return -1; if (next->xvmcid != AVXVMCID) return -1; render->pfuturesurface = next->psurface; // no return here, going to set forward prediction case FFPTYPE: last = (struct xvmcpixfmt*)s->lastpicture.data[2]; if (!last) last = render; // predict second field from the first if (last->xvmcid != AVXVMCID) return -1; render->ppastsurface = last->psurface; return 0; } return -1; } ", "target": 0}
{"func": "static int calculatebitrate(AVFormatContext *s) { AVIContext *avi = s->privdata; int i, j; int64t lensum = 0; int64t maxpos = 0; for (i = 0; i<s->nbstreams; i++) { int64t len = 0; AVStream *st = s->streams[i]; if (!st->nbindexentries) continue; for (j = 0; j < st->nbindexentries; j++) len += st->indexentries[j].size; maxpos = FFMAX(maxpos, st->indexentries[j-1].pos); lensum += len; } if (maxpos < avi->iofsize*9/10) // index does not cover the whole file return 0; if (lensum*9/10 > maxpos || lensum < maxpos*9/10) // frame sum and filesize mismatch return 0; for (i = 0; i<s->nbstreams; i++) { int64t len = 0; AVStream *st = s->streams[i]; int64t duration; for (j = 0; j < st->nbindexentries; j++) len += st->indexentries[j].size; if (st->nbindexentries < 2 || st->codec->bitrate > 0) continue; duration = st->indexentries[j-1].timestamp - st->indexentries[0].timestamp; st->codec->bitrate = avrescale(8*len, st->timebase.den, duration * st->timebase.num); } return 1; } ", "target": 1}
{"func": "static inline void genst16(TCGv val, TCGv addr, int index) { tcggenqemust16(val, addr, index); deadtmp(val); } ", "target": 1}
{"func": "static void q35hostclassinit(ObjectClass *klass, void *data) { DeviceClass *dc = DEVICECLASS(klass); PCIHostBridgeClass *hc = PCIHOSTBRIDGECLASS(klass); hc->rootbuspath = q35hostrootbuspath; dc->realize = q35hostrealize; dc->props = mchprops; /* Reason: needs to be wired up by pcq35init */ dc->usercreatable = false; setbit(DEVICECATEGORYBRIDGE, dc->categories); dc->fwname = \"pci\"; } ", "target": 1}
{"func": "static struct addrinfo *inetparseconnectsaddr(InetSocketAddress *saddr, Error **errp) { struct addrinfo ai, *res; int rc; Error *err = NULL; memset(&ai, 0, sizeof(ai)); ai.aiflags = AICANONNAME | AIV4MAPPED | AIADDRCONFIG; ai.aifamily = inetaifamilyfromaddress(saddr, &err); ai.aisocktype = SOCKSTREAM; if (err) { errorpropagate(errp, err); return NULL; } if (saddr->host == NULL || saddr->port == NULL) { errorsetg(errp, \"host and/or port not specified\"); return NULL; } /* lookup */ rc = getaddrinfo(saddr->host, saddr->port, &ai, &res); if (rc != 0) { errorsetg(errp, \"address resolution failed for %s:%s: %s\", saddr->host, saddr->port, gaistrerror(rc)); return NULL; } return res; } ", "target": 1}
{"func": "static void bambooinit(MachineState *machine) { ramaddrt ramsize = machine->ramsize; const char *kernelfilename = machine->kernelfilename; const char *kernelcmdline = machine->kernelcmdline; const char *initrdfilename = machine->initrdfilename; unsigned int pciirqnrs[4] = { 28, 27, 26, 25 }; MemoryRegion *addressspacemem = getsystemmemory(); MemoryRegion *isa = gnew(MemoryRegion, 1); MemoryRegion *rammemories = gmalloc(PPC440EPSDRAMNRBANKS * sizeof(*rammemories)); hwaddr rambases[PPC440EPSDRAMNRBANKS]; hwaddr ramsizes[PPC440EPSDRAMNRBANKS]; qemuirq *pic; qemuirq *irqs; PCIBus *pcibus; PowerPCCPU *cpu; CPUPPCState *env; uint64t elfentry; uint64t elflowaddr; hwaddr loadaddr = 0; targetlong initrdsize = 0; DeviceState *dev; int success; int i; /* Setup CPU. */ if (machine->cpumodel == NULL) { machine->cpumodel = \"440EP\"; } cpu = POWERPCCPU(cpugenericinit(TYPEPOWERPCCPU, machine->cpumodel)); if (cpu == NULL) { fprintf(stderr, \"Unable to initialize CPU!\\n\"); exit(1); } env = &cpu->env; if (env->mmumodel != POWERPCMMUBOOKE) { fprintf(stderr, \"MMU model %i not supported by this machine.\\n\", env->mmumodel); exit(1); } qemuregisterreset(maincpureset, cpu); ppcbooketimersinit(cpu, 400000000, 0); ppcdcrinit(env, NULL, NULL); /* interrupt controller */ irqs = gmalloc0(sizeof(qemuirq) * PPCUICOUTPUTNB); irqs[PPCUICOUTPUTINT] = ((qemuirq *)env->irqinputs)[PPC40xINPUTINT]; irqs[PPCUICOUTPUTCINT] = ((qemuirq *)env->irqinputs)[PPC40xINPUTCINT]; pic = ppcuicinit(env, irqs, 0x0C0, 0, 1); /* SDRAM controller */ memset(rambases, 0, sizeof(rambases)); memset(ramsizes, 0, sizeof(ramsizes)); ramsize = ppc4xxsdramadjust(ramsize, PPC440EPSDRAMNRBANKS, rammemories, rambases, ramsizes, ppc440epsdrambanksizes); /* XXX 440EP's ECC interrupts are on UIC1, but we've only created UIC0. */ ppc4xxsdraminit(env, pic[14], PPC440EPSDRAMNRBANKS, rammemories, rambases, ramsizes, 1); /* PCI */ dev = sysbuscreatevarargs(TYPEPPC4xxPCIHOSTBRIDGE, PPC440EPPCICONFIG, pic[pciirqnrs[0]], pic[pciirqnrs[1]], pic[pciirqnrs[2]], pic[pciirqnrs[3]], NULL); pcibus = (PCIBus *)qdevgetchildbus(dev, \"pci.0\"); if (!pcibus) { fprintf(stderr, \"couldn't create PCI controller!\\n\"); exit(1); } memoryregioninitalias(isa, NULL, \"isammio\", getsystemio(), 0, PPC440EPPCIIOLEN); memoryregionaddsubregion(getsystemmemory(), PPC440EPPCIIO, isa); if (serialhds[0] != NULL) { serialmminit(addressspacemem, 0xef600300, 0, pic[0], PPCSERIALMMBAUDBASE, serialhds[0], DEVICEBIGENDIAN); } if (serialhds[1] != NULL) { serialmminit(addressspacemem, 0xef600400, 0, pic[1], PPCSERIALMMBAUDBASE, serialhds[1], DEVICEBIGENDIAN); } if (pcibus) { /* Register network interfaces. */ for (i = 0; i < nbnics; i++) { /* There are no PCI NICs on the Bamboo board, but there are * PCI slots, so we can pick whatever default model we want. */ pcinicinitnofail(&ndtable[i], pcibus, \"e1000\", NULL); } } /* Load kernel. */ if (kernelfilename) { success = loaduimage(kernelfilename, &entry, &loadaddr, NULL, NULL, NULL); if (success < 0) { success = loadelf(kernelfilename, NULL, NULL, &elfentry, &elflowaddr, NULL, 1, PPCELFMACHINE, 0, 0); entry = elfentry; loadaddr = elflowaddr; } /* XXX try again as binary */ if (success < 0) { fprintf(stderr, \"qemu: could not load kernel '%s'\\n\", kernelfilename); exit(1); } } /* Load initrd. */ if (initrdfilename) { initrdsize = loadimagetargphys(initrdfilename, RAMDISKADDR, ramsize - RAMDISKADDR); if (initrdsize < 0) { fprintf(stderr, \"qemu: could not load ram disk '%s' at %x\\n\", initrdfilename, RAMDISKADDR); exit(1); } } /* If we're loading a kernel directly, we must load the device tree too. */ if (kernelfilename) { if (bambooloaddevicetree(FDTADDR, ramsize, RAMDISKADDR, initrdsize, kernelcmdline) < 0) { fprintf(stderr, \"couldn't load device tree\\n\"); exit(1); } } } ", "target": 1}
{"func": "void HELPER(stpq)(CPUS390XState *env, uint64t addr, uint64t low, uint64t high) { uintptrt ra = GETPC(); if (parallelcpus) { #ifndef CONFIGATOMIC128 cpuloopexitatomic(ENVGETCPU(env), ra); #else int memidx = cpummuindex(env, false); TCGMemOpIdx oi = makememopidx(MOTEQ | MOALIGN16, memidx); Int128 v = int128make128(low, high); helperatomicstobemmu(env, addr, v, oi, ra); #endif } else { checkalignment(env, addr, 16, ra); cpustqdatara(env, addr + 0, high, ra); cpustqdatara(env, addr + 8, low, ra); } } ", "target": 0}
{"func": "static inline void RENAME(yuy2ToUV)(uint8t *dstU, uint8t *dstV, uint8t *src1, uint8t *src2, long width) { #ifdef HAVEMMX \tasm volatile( \t\t\"movq \"MANGLE(bm01010101)\", %%mm4\\n\\t\" \t\t\"mov %0, %%\"REGa\"\t\t\\n\\t\" \t\t\"1:\t\t\t\t\\n\\t\" \t\t\"movq (%1, %%\"REGa\",4), %%mm0\t\\n\\t\" \t\t\"movq 8(%1, %%\"REGa\",4), %%mm1\t\\n\\t\" \t\t\"psrlw $8, %%mm0\t\t\\n\\t\" \t\t\"psrlw $8, %%mm1\t\t\\n\\t\" \t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\" \t\t\"movq %%mm0, %%mm1\t\t\\n\\t\" \t\t\"psrlw $8, %%mm0\t\t\\n\\t\" \t\t\"pand %%mm4, %%mm1\t\t\\n\\t\" \t\t\"packuswb %%mm0, %%mm0\t\t\\n\\t\" \t\t\"packuswb %%mm1, %%mm1\t\t\\n\\t\" \t\t\"movd %%mm0, (%3, %%\"REGa\")\t\\n\\t\" \t\t\"movd %%mm1, (%2, %%\"REGa\")\t\\n\\t\" \t\t\"add $4, %%\"REGa\"\t\t\\n\\t\" \t\t\" js 1b\t\t\t\t\\n\\t\" \t\t: : \"g\" (-width), \"r\" (src1+width*4), \"r\" (dstU+width), \"r\" (dstV+width) \t\t: \"%\"REGa \t); #else \tint i; \tfor(i=0; i<width; i++) \t{ \t\tdstU[i]= src1[4*i + 1]; \t\tdstV[i]= src1[4*i + 3]; \t} #endif assert(src1 == src2); } ", "target": 1}
{"func": "static void h261vloopfilterc(uint8t *dest,uint8t *src, int stride){ int i,j,xy,yz; int res; for(i=0; i<8; i++){ for(j=1; j<7; j++){ xy = j * stride + i; yz = j * 8 + i; res = (int)src[yz-1*8] + ((int)(src[yz+0*8]) * 2) + (int)src[yz+1*8]; res +=2; res >>=2; dest[xy] = (uint8t)res; } } } ", "target": 0}
{"func": "static inline void RENAME(uyvyToY)(uint8t *dst, const uint8t *src, int width, uint32t *unused) { #if COMPILETEMPLATEMMX asm volatile( \"mov %0, %%\"REGa\" \\n\\t\" \"1: \\n\\t\" \"movq (%1, %%\"REGa\",2), %%mm0 \\n\\t\" \"movq 8(%1, %%\"REGa\",2), %%mm1 \\n\\t\" \"psrlw $8, %%mm0 \\n\\t\" \"psrlw $8, %%mm1 \\n\\t\" \"packuswb %%mm1, %%mm0 \\n\\t\" \"movq %%mm0, (%2, %%\"REGa\") \\n\\t\" \"add $8, %%\"REGa\" \\n\\t\" \" js 1b \\n\\t\" : : \"g\" ((x86reg)-width), \"r\" (src+width*2), \"r\" (dst+width) : \"%\"REGa ); #else int i; for (i=0; i<width; i++) dst[i]= src[2*i+1]; #endif } ", "target": 1}
{"func": "static void simplenumber(void) { int i; struct { const char *encoded; int64t decoded; int skip; } testcases[] = { { \"0\", 0 }, { \"1234\", 1234 }, { \"1\", 1 }, { \"-32\", -32 }, { \"-0\", 0, .skip = 1 }, { }, }; for (i = 0; testcases[i].encoded; i++) { QInt *qint; qint = qobjecttoqint(qobjectfromjson(testcases[i].encoded, NULL)); gassert(qint); gassert(qintgetint(qint) == testcases[i].decoded); if (testcases[i].skip == 0) { QString *str; str = qobjecttojson(QOBJECT(qint)); gassert(strcmp(qstringgetstr(str), testcases[i].encoded) == 0); QDECREF(str); } QDECREF(qint); } } ", "target": 1}
{"func": "static int videothread(void *arg) { VideoState *is = arg; AVFrame *frame = avcodecallocframe(); int64t ptsint; double pts; int ret; #if CONFIGAVFILTER AVFilterGraph *graph = avfiltergraphalloc(); AVFilterContext *filtout = NULL; int64t pos; int lastw = is->videost->codec->width; int lasth = is->videost->codec->height; if ((ret = configurevideofilters(graph, is, vfilters)) < 0) goto theend; filtout = is->outvideofilter; #endif for (;;) { #if !CONFIGAVFILTER AVPacket pkt; #else AVFilterBufferRef *picref; AVRational tb; #endif while (is->paused && !is->videoq.abortrequest) SDLDelay(10); #if CONFIGAVFILTER if ( lastw != is->videost->codec->width || lasth != is->videost->codec->height) { avdlog(NULL, \"Changing size %dx%d -> %dx%d\\n\", lastw, lasth, is->videost->codec->width, is->videost->codec->height); avfiltergraphfree(&graph); graph = avfiltergraphalloc(); if ((ret = configurevideofilters(graph, is, vfilters)) < 0) goto theend; filtout = is->outvideofilter; lastw = is->videost->codec->width; lasth = is->videost->codec->height; } ret = getfilteredvideoframe(filtout, frame, &picref, &tb); if (picref) { ptsint = picref->pts; pos = picref->pos; frame->opaque = picref; } if (avcmpq(tb, is->videost->timebase)) { avunused int64t pts1 = ptsint; ptsint = avrescaleq(ptsint, tb, is->videost->timebase); avdlog(NULL, \"videothread(): \" \"tb:%d/%d pts:%\"PRId64\" -> tb:%d/%d pts:%\"PRId64\"\\n\", tb.num, tb.den, pts1, is->videost->timebase.num, is->videost->timebase.den, ptsint); } #else ret = getvideoframe(is, frame, &ptsint, &pkt); #endif if (ret < 0) goto theend; if (!ret) continue; pts = ptsint * avq2d(is->videost->timebase); #if CONFIGAVFILTER ret = outputpicture2(is, frame, pts, pos); #else ret = outputpicture2(is, frame, pts, pkt.pos); avfreepacket(&pkt); #endif if (ret < 0) goto theend; if (step) if (curstream) streampause(curstream); } theend: #if CONFIGAVFILTER avfiltergraphfree(&graph); #endif avfree(frame); return 0; } ", "target": 1}
{"func": "static int ccidinitfn(USBDevice *dev) { USBCCIDState *s = DOUPCAST(USBCCIDState, dev, dev); s->bus = ccidbusnew(&dev->qdev); s->card = NULL; s->cardinfo = NULL; s->migrationstate = MIGRATIONNONE; s->migrationtargetip = 0; s->migrationtargetport = 0; s->dev.speed = USBSPEEDFULL; s->notifyslotchange = false; s->powered = true; s->pendinganswersnum = 0; s->lastanswererror = 0; s->bulkinpendingstart = 0; s->bulkinpendingend = 0; s->currentbulkin = NULL; ccidreseterrorstatus(s); s->bulkoutpos = 0; ccidresetparameters(s); ccidreset(s); return 0; } ", "target": 1}
{"func": "static void ppc4xxpobreset (void *opaque) { ppc4xxpobt *pob; pob = opaque; /* No error */ pob->bear = 0x00000000; pob->besr[0] = 0x0000000; pob->besr[1] = 0x0000000; } ", "target": 1}
{"func": "int avaesinit(AVAES *a, const uint8t *key, int keybits, int decrypt) { int i, j, t, rconpointer = 0; uint8t tk[8][4]; int KC = keybits >> 5; int rounds = KC + 6; uint8t log8[256]; uint8t alog8[512]; if (!encmultbl[FFARRAYELEMS(encmultbl)-1][FFARRAYELEMS(encmultbl[0])-1]) { j = 1; for (i = 0; i < 255; i++) { alog8[i] = alog8[i + 255] = j; log8[j] = i; j ^= j + j; if (j > 255) j ^= 0x11B; } for (i = 0; i < 256; i++) { j = i ? alog8[255 - log8[i]] : 0; j ^= (j << 1) ^ (j << 2) ^ (j << 3) ^ (j << 4); j = (j ^ (j >> 8) ^ 99) & 255; invsbox[j] = i; sbox[i] = j; } initmultbl2(decmultbl[0], (const int[4]) { 0xe, 0x9, 0xd, 0xb }, log8, alog8, invsbox); initmultbl2(encmultbl[0], (const int[4]) { 0x2, 0x1, 0x1, 0x3 }, log8, alog8, sbox); } if (keybits != 128 && keybits != 192 && keybits != 256) return -1; a->rounds = rounds; memcpy(tk, key, KC * 4); for (t = 0; t < (rounds + 1) * 16;) { memcpy(a->roundkey[0].u8 + t, tk, KC * 4); t += KC * 4; for (i = 0; i < 4; i++) tk[0][i] ^= sbox[tk[KC - 1][(i + 1) & 3]]; tk[0][0] ^= rcon[rconpointer++]; for (j = 1; j < KC; j++) { if (KC != 8 || j != KC >> 1) for (i = 0; i < 4; i++) tk[j][i] ^= tk[j - 1][i]; else for (i = 0; i < 4; i++) tk[j][i] ^= sbox[tk[j - 1][i]]; } } if (decrypt) { for (i = 1; i < rounds; i++) { avaesblock tmp[3]; tmp[2] = a->roundkey[i]; subshift(&tmp[1], 0, sbox); mix(tmp, decmultbl, 1, 3); a->roundkey[i] = tmp[0]; } } else { for (i = 0; i < (rounds + 1) >> 1; i++) { FFSWAP(avaesblock, a->roundkey[i], a->roundkey[rounds-i]); } } return 0; } ", "target": 1}
{"func": "static inline void RENAME(yv12touyvy)(const uint8t *ysrc, const uint8t *usrc, const uint8t *vsrc, uint8t *dst, \tunsigned int width, unsigned int height, \tint lumStride, int chromStride, int dstStride) { \t//FIXME interpolate chroma \tRENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 2); } ", "target": 1}
{"func": "static void spaprpopulatecpudt(CPUState *cs, void *fdt, int offset, sPAPRMachineState *spapr) { PowerPCCPU *cpu = POWERPCCPU(cs); CPUPPCState *env = &cpu->env; PowerPCCPUClass *pcc = POWERPCCPUGETCLASS(cs); int index = ppcgetvcpudtid(cpu); uint32t segs[] = {cputobe32(28), cputobe32(40), 0xffffffff, 0xffffffff}; uint32t tbfreq = kvmenabled() ? kvmppcgettbfreq() : SPAPRTIMEBASEFREQ; uint32t cpufreq = kvmenabled() ? kvmppcgetclockfreq() : 1000000000; uint32t pagesizesprop[64]; sizet pagesizespropsize; uint32t vcpuspersocket = smpthreads * smpcores; uint32t pftsizeprop[] = {0, cputobe32(spapr->htabshift)}; int compatsmt = MIN(smpthreads, ppccompatmaxthreads(cpu)); sPAPRDRConnector *drc; int drcindex; uint32t radixAPencodings[PPCPAGESIZESMAXSZ]; int i; drc = spaprdrcbyid(TYPESPAPRDRCCPU, index); if (drc) { drcindex = spaprdrcindex(drc); FDT((fdtsetpropcell(fdt, offset, \"ibm,my-drc-index\", drcindex))); } FDT((fdtsetpropcell(fdt, offset, \"reg\", index))); FDT((fdtsetpropstring(fdt, offset, \"devicetype\", \"cpu\"))); FDT((fdtsetpropcell(fdt, offset, \"cpu-version\", env->spr[SPRPVR]))); FDT((fdtsetpropcell(fdt, offset, \"d-cache-block-size\", env->dcachelinesize))); FDT((fdtsetpropcell(fdt, offset, \"d-cache-line-size\", env->dcachelinesize))); FDT((fdtsetpropcell(fdt, offset, \"i-cache-block-size\", env->icachelinesize))); FDT((fdtsetpropcell(fdt, offset, \"i-cache-line-size\", env->icachelinesize))); if (pcc->l1dcachesize) { FDT((fdtsetpropcell(fdt, offset, \"d-cache-size\", pcc->l1dcachesize))); } else { errorreport(\"Warning: Unknown L1 dcache size for cpu\"); } if (pcc->l1icachesize) { FDT((fdtsetpropcell(fdt, offset, \"i-cache-size\", pcc->l1icachesize))); } else { errorreport(\"Warning: Unknown L1 icache size for cpu\"); } FDT((fdtsetpropcell(fdt, offset, \"timebase-frequency\", tbfreq))); FDT((fdtsetpropcell(fdt, offset, \"clock-frequency\", cpufreq))); FDT((fdtsetpropcell(fdt, offset, \"slb-size\", env->slbnr))); FDT((fdtsetpropcell(fdt, offset, \"ibm,slb-size\", env->slbnr))); FDT((fdtsetpropstring(fdt, offset, \"status\", \"okay\"))); FDT((fdtsetprop(fdt, offset, \"64-bit\", NULL, 0))); if (env->sprcb[SPRPURR].oearead) { FDT((fdtsetprop(fdt, offset, \"ibm,purr\", NULL, 0))); } if (env->mmumodel & POWERPCMMU1TSEG) { FDT((fdtsetprop(fdt, offset, \"ibm,processor-segment-sizes\", segs, sizeof(segs)))); } /* Advertise VMX/VSX (vector extensions) if available * 0 / no property == no vector extensions * 1 == VMX / Altivec available * 2 == VSX available */ if (env->insnsflags & PPCALTIVEC) { uint32t vmx = (env->insnsflags2 & PPC2VSX) ? 2 : 1; FDT((fdtsetpropcell(fdt, offset, \"ibm,vmx\", vmx))); } /* Advertise DFP (Decimal Floating Point) if available * 0 / no property == no DFP * 1 == DFP available */ if (env->insnsflags2 & PPC2DFP) { FDT((fdtsetpropcell(fdt, offset, \"ibm,dfp\", 1))); } pagesizespropsize = ppccreatepagesizesprop(env, pagesizesprop, sizeof(pagesizesprop)); if (pagesizespropsize) { FDT((fdtsetprop(fdt, offset, \"ibm,segment-page-sizes\", pagesizesprop, pagesizespropsize))); } spaprpopulatepafeatures(env, fdt, offset, false); FDT((fdtsetpropcell(fdt, offset, \"ibm,chip-id\", cs->cpuindex / vcpuspersocket))); FDT((fdtsetprop(fdt, offset, \"ibm,pft-size\", pftsizeprop, sizeof(pftsizeprop)))); if (nbnumanodes > 1) { FDT(spaprfixupcpunumadt(fdt, offset, cpu)); } FDT(spaprfixupcpusmtdt(fdt, offset, cpu, compatsmt)); if (pcc->radixpageinfo) { for (i = 0; i < pcc->radixpageinfo->count; i++) { radixAPencodings[i] = cputobe32(pcc->radixpageinfo->entries[i]); } FDT((fdtsetprop(fdt, offset, \"ibm,processor-radix-AP-encodings\", radixAPencodings, pcc->radixpageinfo->count * sizeof(radixAPencodings[0])))); } } ", "target": 0}
{"func": "static void xhcikickepctx(XHCIEPContext *epctx, unsigned int streamid) { XHCIState *xhci = epctx->xhci; XHCIStreamContext *stctx; XHCITransfer *xfer; XHCIRing *ring; USBEndpoint *ep = NULL; uint64t mfindex; int length; int i; traceusbxhciepkick(epctx->slotid, epctx->epid, streamid); /* If the device has been detached, but the guest has not noticed this yet the 2 above checks will succeed, but we must NOT continue */ if (!xhci->slots[epctx->slotid - 1].uport || !xhci->slots[epctx->slotid - 1].uport->dev || !xhci->slots[epctx->slotid - 1].uport->dev->attached) { return; } if (epctx->retry) { XHCITransfer *xfer = epctx->retry; traceusbxhcixferretry(xfer); assert(xfer->runningretry); if (xfer->timedxfer) { /* time to kick the transfer? */ mfindex = xhcimfindexget(xhci); xhcicheckintrisokick(xhci, xfer, epctx, mfindex); if (xfer->runningretry) { return; } xfer->timedxfer = 0; xfer->runningretry = 1; } if (xfer->isoxfer) { /* retry iso transfer */ if (xhcisetuppacket(xfer) < 0) { return; } usbhandlepacket(xfer->packet.ep->dev, &xfer->packet); assert(xfer->packet.status != USBRETNAK); xhcicompletepacket(xfer); } else { /* retry nak'ed transfer */ if (xhcisetuppacket(xfer) < 0) { return; } usbhandlepacket(xfer->packet.ep->dev, &xfer->packet); if (xfer->packet.status == USBRETNAK) { return; } xhcicompletepacket(xfer); } assert(!xfer->runningretry); xhciepfreexfer(epctx->retry); epctx->retry = NULL; } if (epctx->state == EPHALTED) { DPRINTF(\"xhci: ep halted, not running schedule\\n\"); return; } if (epctx->nrpstreams) { uint32t err; stctx = xhcifindstream(epctx, streamid, &err); if (stctx == NULL) { return; } ring = &stctx->ring; xhcisetepstate(xhci, epctx, stctx, EPRUNNING); } else { ring = &epctx->ring; streamid = 0; xhcisetepstate(xhci, epctx, NULL, EPRUNNING); } assert(ring->dequeue != 0); while (1) { length = xhciringchainlength(xhci, ring); if (length <= 0) { break; } xfer = xhciepallocxfer(epctx, length); if (xfer == NULL) { break; } for (i = 0; i < length; i++) { TRBType type; type = xhciringfetch(xhci, ring, &xfer->trbs[i], NULL); assert(type); } xfer->streamid = streamid; if (epctx->epid == 1) { xhcifirectltransfer(xhci, xfer); } else { xhcifiretransfer(xhci, xfer, epctx); } if (xfer->complete) { xhciepfreexfer(xfer); xfer = NULL; } if (epctx->state == EPHALTED) { break; } if (xfer != NULL && xfer->runningretry) { DPRINTF(\"xhci: xfer nacked, stopping schedule\\n\"); epctx->retry = xfer; break; } } ep = xhciepidtousbep(epctx); if (ep) { usbdeviceflushepqueue(ep->dev, ep); } } ", "target": 0}
{"func": "static int optpreset(const char *opt, const char *arg) { FILE *f=NULL; char filename[1000], tmp[1000], tmp2[1000], line[1000]; int i; const char *base[3]= { getenv(\"HOME\"), \"/usr/local/share\", \"/usr/share\", }; for(i=!base[0]; i<3 && !f; i++){ snprintf(filename, sizeof(filename), \"%s/%sffmpeg/%s.ffpreset\", base[i], i ? \"\" : \".\", arg); f= fopen(filename, \"r\"); if(!f){ char *codecname= *opt == 'v' ? videocodecname : *opt == 'a' ? audiocodecname : subtitlecodecname; snprintf(filename, sizeof(filename), \"%s/%sffmpeg/%s-%s.ffpreset\", base[i], i ? \"\" : \".\", codecname, arg); f= fopen(filename, \"r\"); } } if(!f && ((arg[0]=='.' && arg[1]=='/') || arg[0]=='/' || isdospath(arg))){ snprintf(filename, sizeof(filename), arg); f= fopen(filename, \"r\"); } if(!f){ fprintf(stderr, \"File for preset '%s' not found\\n\", arg); avexit(1); } while(!feof(f)){ int e= fscanf(f, \"%999[^\\n]\\n\", line) - 1; if(line[0] == '#' && !e) continue; e|= sscanf(line, \"%999[^=]=%999[^\\n]\\n\", tmp, tmp2) - 2; if(e){ fprintf(stderr, \"%s: Preset file invalid\\n\", filename); avexit(1); } if(!strcmp(tmp, \"acodec\")){ optaudiocodec(tmp2); }else if(!strcmp(tmp, \"vcodec\")){ optvideocodec(tmp2); }else if(!strcmp(tmp, \"scodec\")){ optsubtitlecodec(tmp2); }else if(optdefault(tmp, tmp2) < 0){ fprintf(stderr, \"%s: Invalid option or argument: %s=%s\\n\", filename, tmp, tmp2); avexit(1); } } fclose(f); return 0; } ", "target": 0}
{"func": "static int asfreadextcontent(AVFormatContext *s, const GUIDParseTable *g) { ASFContext *asf = s->privdata; AVIOContext *pb = s->pb; uint64t size = aviorl64(pb); uint16t nbdesc = aviorl16(pb); int i, ret; for (i = 0; i < nbdesc; i++) { uint16t namelen, type, vallen; uint8t *name = NULL; namelen = aviorl16(pb); if (!namelen) return AVERRORINVALIDDATA; name = avmalloc(namelen); if (!name) return AVERROR(ENOMEM); aviogetstr16le(pb, namelen, name, namelen); type = aviorl16(pb); vallen = aviorl16(pb); if ((ret = processmetadata(s, name, namelen, vallen, type, &s->metadata)) < 0) return ret; } alignposition(pb, asf->offset, size); return 0; } ", "target": 1}
{"func": "static int vhdxlogwrite(BlockDriverState *bs, BDRVVHDXState *s, void *data, uint32t length, uint64t offset) { int ret = 0; void *buffer = NULL; void *mergedsector = NULL; void *datatmp, *sectorwrite; unsigned int i; int sectoroffset; uint32t descsectors, sectors, totallength; uint32t sectorswritten = 0; uint32t alignedlength; uint32t leadinglength = 0; uint32t trailinglength = 0; uint32t partialsectors = 0; uint32t byteswritten = 0; uint64t fileoffset; VHDXHeader *header; VHDXLogEntryHeader newhdr; VHDXLogDescriptor *newdesc = NULL; VHDXLogDataSector *datasector = NULL; MSGUID newguid = { 0 }; header = s->headers[s->currheader]; /* need to have offset read data, and be on 4096 byte boundary */ if (length > header->loglength) { /* no log present. we could create a log here instead of failing */ ret = -EINVAL; goto exit; } if (guideq(header->logguid, zeroguid)) { vhdxguidgenerate(&newguid); vhdxupdateheaders(bs, s, false, &newguid); } else { /* currently, we require that the log be flushed after * every write. */ ret = -ENOTSUP; goto exit; } /* 0 is an invalid sequence number, but may also represent the first * log write (or a wrapped seq) */ if (s->log.sequence == 0) { s->log.sequence = 1; } sectoroffset = offset % VHDXLOGSECTORSIZE; fileoffset = (offset / VHDXLOGSECTORSIZE) * VHDXLOGSECTORSIZE; alignedlength = length; /* add in the unaligned head and tail bytes */ if (sectoroffset) { leadinglength = (VHDXLOGSECTORSIZE - sectoroffset); leadinglength = leadinglength > length ? length : leadinglength; alignedlength -= leadinglength; partialsectors++; } sectors = alignedlength / VHDXLOGSECTORSIZE; trailinglength = alignedlength - (sectors * VHDXLOGSECTORSIZE); if (trailinglength) { partialsectors++; } sectors += partialsectors; /* sectors is now how many sectors the data itself takes, not * including the header and descriptor metadata */ newhdr = (VHDXLogEntryHeader) { .signature = VHDXLOGSIGNATURE, .tail = s->log.tail, .sequencenumber = s->log.sequence, .descriptorcount = sectors, .reserved = 0, .flushedfileoffset = bdrvgetlength(bs->file->bs), .lastfileoffset = bdrvgetlength(bs->file->bs), }; newhdr.logguid = header->logguid; descsectors = vhdxcomputedescsectors(newhdr.descriptorcount); totallength = (descsectors + sectors) * VHDXLOGSECTORSIZE; newhdr.entrylength = totallength; vhdxlogentryhdrleexport(&newhdr); buffer = qemublockalign(bs, totallength); memcpy(buffer, &newhdr, sizeof(newhdr)); newdesc = buffer + sizeof(newhdr); datasector = buffer + (descsectors * VHDXLOGSECTORSIZE); datatmp = data; /* All log sectors are 4KB, so for any partial sectors we must * merge the data with preexisting data from the final file * destination */ mergedsector = qemublockalign(bs, VHDXLOGSECTORSIZE); for (i = 0; i < sectors; i++) { newdesc->signature = VHDXLOGDESCSIGNATURE; newdesc->sequencenumber = s->log.sequence; newdesc->fileoffset = fileoffset; if (i == 0 && leadinglength) { /* partial sector at the front of the buffer */ ret = bdrvpread(bs->file, fileoffset, mergedsector, VHDXLOGSECTORSIZE); if (ret < 0) { goto exit; } memcpy(mergedsector + sectoroffset, datatmp, leadinglength); byteswritten = leadinglength; sectorwrite = mergedsector; } else if (i == sectors - 1 && trailinglength) { /* partial sector at the end of the buffer */ ret = bdrvpread(bs->file, fileoffset, mergedsector + trailinglength, VHDXLOGSECTORSIZE - trailinglength); if (ret < 0) { goto exit; } memcpy(mergedsector, datatmp, trailinglength); byteswritten = trailinglength; sectorwrite = mergedsector; } else { byteswritten = VHDXLOGSECTORSIZE; sectorwrite = datatmp; } /* populate the raw sector data into the proper structures, * as well as update the descriptor, and convert to proper * endianness */ vhdxlograwtolesector(newdesc, datasector, sectorwrite, s->log.sequence); datatmp += byteswritten; datasector++; newdesc++; fileoffset += VHDXLOGSECTORSIZE; } /* checksum covers entire entry, from the log header through the * last data sector */ vhdxupdatechecksum(buffer, totallength, offsetof(VHDXLogEntryHeader, checksum)); /* now write to the log */ ret = vhdxlogwritesectors(bs, &s->log, &sectorswritten, buffer, descsectors + sectors); if (ret < 0) { goto exit; } if (sectorswritten != descsectors + sectors) { /* instead of failing, we could flush the log here */ ret = -EINVAL; goto exit; } s->log.sequence++; /* write new tail */ s->log.tail = s->log.write; exit: qemuvfree(buffer); qemuvfree(mergedsector); return ret; } ", "target": 1}
{"func": "static void vmxnet3netuninit(VMXNET3State *s) { gfree(s->mcastlist); vmxnettxpktreset(s->txpkt); vmxnettxpktuninit(s->txpkt); vmxnetrxpktuninit(s->rxpkt); qemudelnic(s->nic); } ", "target": 1}
{"func": "static int httppreparedata(HTTPContext *c) { int i; switch(c->state) { case HTTPSTATESENDDATAHEADER: memset(&c->fmtctx, 0, sizeof(c->fmtctx)); if (c->stream->feed) { /* open output stream by using specified codecs */ c->fmtctx.oformat = c->stream->fmt; c->fmtctx.nbstreams = c->stream->nbstreams; for(i=0;i<c->fmtctx.nbstreams;i++) { AVStream *st; st = avmallocz(sizeof(AVStream)); c->fmtctx.streams[i] = st; if (c->stream->feed == c->stream) memcpy(st, c->stream->streams[i], sizeof(AVStream)); else memcpy(st, c->stream->feed->streams[c->stream->feedstreams[i]], sizeof(AVStream)); st->codec.framenumber = 0; /* XXX: should be done in AVStream, not in codec */ } c->gotkeyframe = 0; } else { /* open output stream by using codecs in specified file */ c->fmtctx.oformat = c->stream->fmt; c->fmtctx.nbstreams = c->fmtin->nbstreams; for(i=0;i<c->fmtctx.nbstreams;i++) { AVStream *st; st = avmallocz(sizeof(AVStream)); c->fmtctx.streams[i] = st; memcpy(st, c->fmtin->streams[i], sizeof(AVStream)); st->codec.framenumber = 0; /* XXX: should be done in AVStream, not in codec */ } c->gotkeyframe = 0; } initputbyte(&c->fmtctx.pb, c->pbuffer, PACKETMAXSIZE, 1, c, NULL, httpwritepacket, NULL); c->fmtctx.pb.isstreamed = 1; /* prepare header */ avwriteheader(&c->fmtctx); c->state = HTTPSTATESENDDATA; c->lastpacketsent = 0; break; case HTTPSTATESENDDATA: /* find a new packet */ #if 0 fifototalsize = httpfifowritecount - c->lasthttpfifowritecount; if (fifototalsize >= ((3 * FIFOMAXSIZE) / 4)) { /* overflow : resync. We suppose that wptr is at this point a pointer to a valid packet */ c->rptr = httpfifo.wptr; c->gotkeyframe = 0; } startrptr = c->rptr; if (fiforead(&httpfifo, (UINT8 *)&hdr, sizeof(hdr), &c->rptr) < 0) return 0; payloadsize = ntohs(hdr.payloadsize); payload = avmalloc(payloadsize); if (fiforead(&httpfifo, payload, payloadsize, &c->rptr) < 0) { /* cannot read all the payload */ avfree(payload); c->rptr = startrptr; return 0; } c->lasthttpfifowritecount = httpfifowritecount - fifosize(&httpfifo, c->rptr); if (c->stream->streamtype != STREAMTYPEMASTER) { /* test if the packet can be handled by this format */ ret = 0; for(i=0;i<c->fmtctx.nbstreams;i++) { AVStream *st = c->fmtctx.streams[i]; if (testheader(&hdr, &st->codec)) { /* only begin sending when got a key frame */ if (st->codec.keyframe) c->gotkeyframe |= 1 << i; if (c->gotkeyframe & (1 << i)) { ret = c->fmtctx.format->writepacket(&c->fmtctx, i, payload, payloadsize); } break; } } if (ret) { /* must send trailer now */ c->state = HTTPSTATESENDDATATRAILER; } } else { /* master case : send everything */ char *q; q = c->buffer; memcpy(q, &hdr, sizeof(hdr)); q += sizeof(hdr); memcpy(q, payload, payloadsize); q += payloadsize; c->bufferptr = c->buffer; c->bufferend = q; } avfree(payload); #endif { AVPacket pkt; /* read a packet from the input stream */ if (c->stream->feed) { ffmsetwriteindex(c->fmtin, c->stream->feed->feedwriteindex, c->stream->feed->feedsize); } if (avreadpacket(c->fmtin, &pkt) < 0) { if (c->stream->feed && c->stream->feed->feedopened) { /* if coming from feed, it means we reached the end of the ffm file, so must wait for more data */ c->state = HTTPSTATEWAITFEED; return 1; /* state changed */ } else { /* must send trailer now because eof or error */ c->state = HTTPSTATESENDDATATRAILER; } } else { /* send it to the appropriate stream */ if (c->stream->feed) { /* if coming from a feed, select the right stream */ for(i=0;i<c->stream->nbstreams;i++) { if (c->stream->feedstreams[i] == pkt.streamindex) { pkt.streamindex = i; if (pkt.flags & PKTFLAGKEY) { c->gotkeyframe |= 1 << i; } /* See if we have all the key frames, then * we start to send. This logic is not quite * right, but it works for the case of a * single video stream with one or more * audio streams (for which every frame is * typically a key frame). */ if (!c->stream->sendonkey || ((c->gotkeyframe + 1) >> c->stream->nbstreams)) { goto sendit; } } } } else { AVCodecContext *codec; sendit: /* Fudge here */ codec = &c->fmtctx.streams[pkt.streamindex]->codec; codec->keyframe = ((pkt.flags & PKTFLAGKEY) != 0); #ifdef PJSG if (codec->codectype == CODECTYPEAUDIO) { codec->framesize = (codec->samplerate * pkt.duration + 500000) / 1000000; /* printf(\"Calculated size %d, from sr %d, duration %d\\n\", codec->framesize, codec->samplerate, pkt.duration); */ } #endif if (avwritepacket(&c->fmtctx, &pkt, 0)) c->state = HTTPSTATESENDDATATRAILER; codec->framenumber++; } avfreepacket(&pkt); } } break; default: case HTTPSTATESENDDATATRAILER: /* last packet test ? */ if (c->lastpacketsent) return -1; /* prepare header */ avwritetrailer(&c->fmtctx); c->lastpacketsent = 1; break; } return 0; } ", "target": 1}
{"func": "static void inputcallback(MMALPORTT *port, MMALBUFFERHEADERT *buffer) { if (!buffer->cmd) { AVBufferRef *buf = buffer->userdata; avbufferunref(&buf); } mmalbufferheaderrelease(buffer); } ", "target": 1}
{"func": "CPUArchState *cpucopy(CPUArchState *env) { CPUState *cpu = ENVGETCPU(env); CPUState *newcpu = cpuinit(cpumodel); CPUArchState *newenv = cpu->envptr; CPUBreakpoint *bp; CPUWatchpoint *wp; /* Reset non arch specific state */ cpureset(newcpu); memcpy(newenv, env, sizeof(CPUArchState)); /* Clone all break/watchpoints. Note: Once we support ptrace with hw-debug register access, make sure BPCPU break/watchpoints are handled correctly on clone. */ QTAILQINIT(&cpu->breakpoints); QTAILQINIT(&cpu->watchpoints); QTAILQFOREACH(bp, &cpu->breakpoints, entry) { cpubreakpointinsert(newcpu, bp->pc, bp->flags, NULL); } QTAILQFOREACH(wp, &cpu->watchpoints, entry) { cpuwatchpointinsert(newcpu, wp->vaddr, wp->len, wp->flags, NULL); } return newenv; } ", "target": 1}
{"func": "static void avclumavtandaverdst16x16msa(const uint8t *src, int32t srcstride, uint8t *dst, int32t dststride) { int32t loopcnt; int16t filtconst0 = 0xfb01; int16t filtconst1 = 0x1414; int16t filtconst2 = 0x1fb; v16u8 dst0, dst1, dst2, dst3; v16i8 src0, src1, src2, src3, src4, src5, src6, src7, src8; v16i8 src10r, src32r, src54r, src76r, src21r, src43r, src65r; v16i8 src87r, src10l, src32l, src54l, src76l, src21l, src43l; v16i8 src65l, src87l; v8i16 out0r, out1r, out2r, out3r, out0l, out1l, out2l, out3l; v16i8 filt0, filt1, filt2; v16u8 res0, res1, res2, res3; filt0 = (v16i8) msafillh(filtconst0); filt1 = (v16i8) msafillh(filtconst1); filt2 = (v16i8) msafillh(filtconst2); LDSB5(src, srcstride, src0, src1, src2, src3, src4); src += (5 * srcstride); XORIB5128SB(src0, src1, src2, src3, src4); ILVRB4SB(src1, src0, src2, src1, src3, src2, src4, src3, src10r, src21r, src32r, src43r); ILVLB4SB(src1, src0, src2, src1, src3, src2, src4, src3, src10l, src21l, src32l, src43l); for (loopcnt = 4; loopcnt--;) { LDSB4(src, srcstride, src5, src6, src7, src8); src += (4 * srcstride); XORIB4128SB(src5, src6, src7, src8); ILVRB4SB(src5, src4, src6, src5, src7, src6, src8, src7, src54r, src65r, src76r, src87r); ILVLB4SB(src5, src4, src6, src5, src7, src6, src8, src7, src54l, src65l, src76l, src87l); out0r = DPADDSH3SH(src10r, src32r, src54r, filt0, filt1, filt2); out1r = DPADDSH3SH(src21r, src43r, src65r, filt0, filt1, filt2); out2r = DPADDSH3SH(src32r, src54r, src76r, filt0, filt1, filt2); out3r = DPADDSH3SH(src43r, src65r, src87r, filt0, filt1, filt2); out0l = DPADDSH3SH(src10l, src32l, src54l, filt0, filt1, filt2); out1l = DPADDSH3SH(src21l, src43l, src65l, filt0, filt1, filt2); out2l = DPADDSH3SH(src32l, src54l, src76l, filt0, filt1, filt2); out3l = DPADDSH3SH(src43l, src65l, src87l, filt0, filt1, filt2); SRARIH4SH(out0r, out1r, out2r, out3r, 5); SRARIH4SH(out0l, out1l, out2l, out3l, 5); SATSH4SH(out0r, out1r, out2r, out3r, 7); SATSH4SH(out0l, out1l, out2l, out3l, 7); LDUB4(dst, dststride, dst0, dst1, dst2, dst3); PCKEVB4UB(out0l, out0r, out1l, out1r, out2l, out2r, out3l, out3r, res0, res1, res2, res3); XORIB4128UB(res0, res1, res2, res3); AVERUB4UB(res0, dst0, res1, dst1, res2, dst2, res3, dst3, res0, res1, res2, res3); STUB4(res0, res1, res2, res3, dst, dststride); dst += (4 * dststride); src10r = src54r; src32r = src76r; src21r = src65r; src43r = src87r; src10l = src54l; src32l = src76l; src21l = src65l; src43l = src87l; src4 = src8; } } ", "target": 0}
{"func": "static int netsocketcansend(void *opaque) { NetSocketState *s = opaque; return qemucansendpacket(&s->nc); } ", "target": 0}
{"func": "static void ppcprepinit (ramaddrt ramsize, const char *bootdevice, const char *kernelfilename, const char *kernelcmdline, const char *initrdfilename, const char *cpumodel) { CPUState *env = NULL; char *filename; nvramt nvram; M48t59State *m48t59; int PPCiomemory; int linuxboot, i, nbnics1, biossize; ramaddrt ramoffset, biosoffset; uint32t kernelbase, initrdbase; long kernelsize, initrdsize; PCIBus *pcibus; qemuirq *i8259; qemuirq *cpuexitirq; int ppcbootdevice; DriveInfo *hd[MAXIDEBUS * MAXIDEDEVS]; DriveInfo *fd[MAXFD]; sysctrl = qemumallocz(sizeof(sysctrlt)); linuxboot = (kernelfilename != NULL); /* init CPUs */ if (cpumodel == NULL) cpumodel = \"602\"; for (i = 0; i < smpcpus; i++) { env = cpuinit(cpumodel); if (!env) { fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\"); exit(1); } if (env->flags & POWERPCFLAGRTCCLK) { /* POWER / PowerPC 601 RTC clock frequency is 7.8125 MHz */ cpuppctbinit(env, 7812500UL); } else { /* Set time-base frequency to 100 Mhz */ cpuppctbinit(env, 100UL * 1000UL * 1000UL); } qemuregisterreset((QEMUResetHandler*)&cpureset, env); } /* allocate RAM */ ramoffset = qemuramalloc(NULL, \"ppcprep.ram\", ramsize); cpuregisterphysicalmemory(0, ramsize, ramoffset); /* allocate and load BIOS */ biosoffset = qemuramalloc(NULL, \"ppcprep.bios\", BIOSSIZE); if (biosname == NULL) biosname = BIOSFILENAME; filename = qemufindfile(QEMUFILETYPEBIOS, biosname); if (filename) { biossize = getimagesize(filename); } else { biossize = -1; } if (biossize > 0 && biossize <= BIOSSIZE) { targetphysaddrt biosaddr; biossize = (biossize + 0xfff) & ~0xfff; biosaddr = (uint32t)(-biossize); cpuregisterphysicalmemory(biosaddr, biossize, biosoffset | IOMEMROM); biossize = loadimagetargphys(filename, biosaddr, biossize); } if (biossize < 0 || biossize > BIOSSIZE) { hwerror(\"qemu: could not load PPC PREP bios '%s'\\n\", biosname); } if (filename) { qemufree(filename); } if (linuxboot) { kernelbase = KERNELLOADADDR; /* now we can load the kernel */ kernelsize = loadimagetargphys(kernelfilename, kernelbase, ramsize - kernelbase); if (kernelsize < 0) { hwerror(\"qemu: could not load kernel '%s'\\n\", kernelfilename); exit(1); } /* load initrd */ if (initrdfilename) { initrdbase = INITRDLOADADDR; initrdsize = loadimagetargphys(initrdfilename, initrdbase, ramsize - initrdbase); if (initrdsize < 0) { hwerror(\"qemu: could not load initial ram disk '%s'\\n\", initrdfilename); } } else { initrdbase = 0; initrdsize = 0; } ppcbootdevice = 'm'; } else { kernelbase = 0; kernelsize = 0; initrdbase = 0; initrdsize = 0; ppcbootdevice = '\\0'; /* For now, OHW cannot boot from the network. */ for (i = 0; bootdevice[i] != '\\0'; i++) { if (bootdevice[i] >= 'a' && bootdevice[i] <= 'f') { ppcbootdevice = bootdevice[i]; break; } } if (ppcbootdevice == '\\0') { fprintf(stderr, \"No valid boot device for Mac99 machine\\n\"); exit(1); } } isamembase = 0xc0000000; if (PPCINPUT(env) != PPCFLAGSINPUT6xx) { hwerror(\"Only 6xx bus is supported on PREP machine\\n\"); } i8259 = i8259init(firstcpu->irqinputs[PPC6xxINPUTINT]); pcibus = pciprepinit(i8259); /* Hmm, prep has no pci-isa bridge ??? */ isabusnew(NULL); isabusirqs(i8259); // pcibus = i440fxinit(); /* Register 8 MB of ISA IO space (needed for non-contiguous map) */ PPCiomemory = cpuregisteriomemory(PPCprepioread, PPCprepiowrite, sysctrl, DEVICELITTLEENDIAN); cpuregisterphysicalmemory(0x80000000, 0x00800000, PPCiomemory); /* init basic PC hardware */ pcivgainit(pcibus); // openpic = openpicinit(0x00000000, 0xF0000000, 1); // pit = pitinit(0x40, i8259[0]); rtcinit(2000, NULL); if (serialhds[0]) serialisainit(0, serialhds[0]); nbnics1 = nbnics; if (nbnics1 > NE2000NBMAX) nbnics1 = NE2000NBMAX; for(i = 0; i < nbnics1; i++) { if (ndtable[i].model == NULL) { \t ndtable[i].model = qemustrdup(\"ne2kisa\"); } if (strcmp(ndtable[i].model, \"ne2kisa\") == 0) { isane2000init(ne2000io[i], ne2000irq[i], &ndtable[i]); } else { pcinicinitnofail(&ndtable[i], \"ne2kpci\", NULL); } } if (drivegetmaxbus(IFIDE) >= MAXIDEBUS) { fprintf(stderr, \"qemu: too many IDE bus\\n\"); exit(1); } for(i = 0; i < MAXIDEBUS * MAXIDEDEVS; i++) { hd[i] = driveget(IFIDE, i / MAXIDEDEVS, i % MAXIDEDEVS); } for(i = 0; i < 1/*MAXIDEBUS*/; i++) { isaideinit(ideiobase[i], ideiobase2[i], ideirq[i], hd[2 * i], \t\t hd[2 * i + 1]); } isacreatesimple(\"i8042\"); cpuexitirq = qemuallocateirqs(cpurequestexit, NULL, 1); DMAinit(1, cpuexitirq); // SB16init(); for(i = 0; i < MAXFD; i++) { fd[i] = driveget(IFFLOPPY, 0, i); } fdctrlinitisa(fd); /* Register speaker port */ registerioportread(0x61, 1, 1, speakerioportread, NULL); registerioportwrite(0x61, 1, 1, speakerioportwrite, NULL); /* Register fake IO ports for PREP */ sysctrl->resetirq = firstcpu->irqinputs[PPC6xxINPUTHRESET]; registerioportread(0x398, 2, 1, &PREPioread, sysctrl); registerioportwrite(0x398, 2, 1, &PREPiowrite, sysctrl); /* System control ports */ registerioportread(0x0092, 0x01, 1, &PREPio800readb, sysctrl); registerioportwrite(0x0092, 0x01, 1, &PREPio800writeb, sysctrl); registerioportread(0x0800, 0x52, 1, &PREPio800readb, sysctrl); registerioportwrite(0x0800, 0x52, 1, &PREPio800writeb, sysctrl); /* PCI intack location */ PPCiomemory = cpuregisteriomemory(PPCintackread, PPCintackwrite, NULL, DEVICELITTLEENDIAN); cpuregisterphysicalmemory(0xBFFFFFF0, 0x4, PPCiomemory); /* PowerPC control and status register group */ #if 0 PPCiomemory = cpuregisteriomemory(PPCXCSRread, PPCXCSRwrite, NULL, DEVICELITTLEENDIAN); cpuregisterphysicalmemory(0xFEFF0000, 0x1000, PPCiomemory); #endif if (usbenabled) { usbohciinitpci(pcibus, -1); } m48t59 = m48t59init(i8259[8], 0, 0x0074, NVRAMSIZE, 59); if (m48t59 == NULL) return; sysctrl->nvram = m48t59; /* Initialise NVRAM */ nvram.opaque = m48t59; nvram.readfn = &m48t59read; nvram.writefn = &m48t59write; PPCNVRAMsetparams(&nvram, NVRAMSIZE, \"PREP\", ramsize, ppcbootdevice, kernelbase, kernelsize, kernelcmdline, initrdbase, initrdsize, /* XXX: need an option to load a NVRAM image */ 0, graphicwidth, graphicheight, graphicdepth); /* Special port to get debug messages from Open-Firmware */ registerioportwrite(0x0F00, 4, 1, &PPCdebugwrite, NULL); } ", "target": 0}
{"func": "static void copypicturefield(InterlaceContext *s, AVFrame *srcframe, AVFrame *dstframe, AVFilterLink *inlink, enum FieldType fieldtype, int lowpass) { const AVPixFmtDescriptor *desc = avpixfmtdescget(inlink->format); int hsub = desc->log2chromaw; int vsub = desc->log2chromah; int plane, j; for (plane = 0; plane < desc->nbcomponents; plane++) { int cols = (plane == 1 || plane == 2) ? -(-inlink->w) >> hsub : inlink->w; int lines = (plane == 1 || plane == 2) ? -(-inlink->h) >> vsub : inlink->h; uint8t *dstp = dstframe->data[plane]; const uint8t *srcp = srcframe->data[plane]; avassert0(cols >= 0 || lines >= 0); lines = (lines + (fieldtype == FIELDUPPER)) / 2; if (fieldtype == FIELDLOWER) srcp += srcframe->linesize[plane]; if (fieldtype == FIELDLOWER) dstp += dstframe->linesize[plane]; if (lowpass) { int srcplinesize = srcframe->linesize[plane] * 2; int dstplinesize = dstframe->linesize[plane] * 2; for (j = lines; j > 0; j--) { const uint8t *srcpabove = srcp - srcframe->linesize[plane]; const uint8t *srcpbelow = srcp + srcframe->linesize[plane]; if (j == lines) srcpabove = srcp; // there is no line above if (j == 1) srcpbelow = srcp; // there is no line below s->lowpassline(dstp, cols, srcp, srcpabove, srcpbelow); dstp += dstplinesize; srcp += srcplinesize; } } else { avimagecopyplane(dstp, dstframe->linesize[plane] * 2, srcp, srcframe->linesize[plane] * 2, cols, lines); } } } ", "target": 0}
{"func": "targetulong helperrdhwrcpunum(CPUMIPSState *env) { checkhwrena(env, 0); return env->CP0EBase & 0x3ff; } ", "target": 1}
{"func": "void qmpinjectnmi(Error **errp) { #if defined(TARGETI386) CPUState *cs; CPUFOREACH(cs) { X86CPU *cpu = X86CPU(cs); if (!cpu->apicstate) { cpuinterrupt(cs, CPUINTERRUPTNMI); } else { apicdelivernmi(cpu->apicstate); } } #elif defined(TARGETS390X) CPUState *cs; S390CPU *cpu; CPUFOREACH(cs) { cpu = S390CPU(cs); if (cpu->env.cpunum == monitorgetcpuindex()) { if (s390cpurestart(S390CPU(cs)) == -1) { errorset(errp, QERRUNSUPPORTED); return; } break; } } #else errorset(errp, QERRUNSUPPORTED); #endif } ", "target": 1}
{"func": "void helpersinglestep(CPUX86State *env) { #ifndef CONFIGUSERONLY checkhwbreakpoints(env, 1); env->dr[6] |= DR6BS; #endif raiseexception(env, EXCP01DB); } ", "target": 1}
{"func": "static avalwaysinline void rv40weakloopfilter(uint8t *src, const int step, const int stride, const int filterp1, const int filterq1, const int alpha, const int beta, const int limp0q0, const int limq1, const int limp1) { uint8t *cm = ffcropTbl + MAXNEGCROP; int i, t, u, diff; for (i = 0; i < 4; i++, src += stride) { int diffp1p0 = src[-2*step] - src[-1*step]; int diffq1q0 = src[ 1*step] - src[ 0*step]; int diffp1p2 = src[-2*step] - src[-3*step]; int diffq1q2 = src[ 1*step] - src[ 2*step]; t = src[0*step] - src[-1*step]; if (!t) continue; u = (alpha * FFABS(t)) >> 7; if (u > 3 - (filterp1 && filterq1)) continue; t <<= 2; if (filterp1 && filterq1) t += src[-2*step] - src[1*step]; diff = CLIPSYMM((t + 4) >> 3, limp0q0); src[-1*step] = cm[src[-1*step] + diff]; src[ 0*step] = cm[src[ 0*step] - diff]; if (filterp1 && FFABS(diffp1p2) <= beta) { t = (diffp1p0 + diffp1p2 - diff) >> 1; src[-2*step] = cm[src[-2*step] - CLIPSYMM(t, limp1)]; } if (filterq1 && FFABS(diffq1q2) <= beta) { t = (diffq1q0 + diffq1q2 + diff) >> 1; src[ 1*step] = cm[src[ 1*step] - CLIPSYMM(t, limq1)]; } } } ", "target": 1}
{"func": "static void condisconnect(struct XenDevice *xendev) { struct XenConsole *con = containerof(xendev, struct XenConsole, xendev); if (con->chr) { qemuchraddhandlers(con->chr, NULL, NULL, NULL, NULL); qemuchrferelease(con->chr); } xenbeunbindevtchn(&con->xendev); if (con->sring) { if (!xendev->dev) { munmap(con->sring, XCPAGESIZE); } else { xengnttabunmap(xendev->gnttabdev, con->sring, 1); } con->sring = NULL; } } ", "target": 1}
{"func": "static int normalizebits(int num, int width) { if (!num) return 0; if (num == -1) return width; if (num < 0) num = ~num; return width - avlog2(num); } ", "target": 1}
{"func": "static void xenpcipassthroughclassinit(ObjectClass *klass, void *data) { DeviceClass *dc = DEVICECLASS(klass); PCIDeviceClass *k = PCIDEVICECLASS(klass); k->realize = xenptrealize; k->exit = xenptunregisterdevice; k->configread = xenptpcireadconfig; k->configwrite = xenptpciwriteconfig; setbit(DEVICECATEGORYMISC, dc->categories); dc->desc = \"Assign an host PCI device with Xen\"; dc->props = xenpcipassthroughproperties; };", "target": 1}
{"func": "static int ohcibusstart(OHCIState *ohci) { ohci->eoftimer = timernewns(QEMUCLOCKVIRTUAL, ohciframeboundary, ohci); if (ohci->eoftimer == NULL) { traceusbohcibuseoftimerfailed(ohci->name); ohcidie(ohci); return 0; } traceusbohcistart(ohci->name); /* Delay the first SOF event by one frame time as * linux driver is not ready to receive it and * can meet some race conditions */ ohcieoftimer(ohci); return 1; } ", "target": 1}
{"func": "void bdrvimageinfospecificdump(fprintffunction funcfprintf, void *f, ImageInfoSpecific *infospec) { QObject *obj, *data; Visitor *v = qmpoutputvisitornew(&obj); visittypeImageInfoSpecific(v, NULL, &infospec, &errorabort); visitcomplete(v, &obj); assert(qobjecttype(obj) == QTYPEQDICT); data = qdictget(qobjecttoqdict(obj), \"data\"); dumpqobject(funcfprintf, f, 1, data); visitfree(v); }", "target": 1}
{"func": "static int srtdecodeframe(AVCodecContext *avctx, void *data, int *gotsubptr, AVPacket *avpkt) { AVSubtitle *sub = data; AVBPrint buffer; int x1 = -1, y1 = -1, x2 = -1, y2 = -1; int size, ret; const uint8t *p = avpacketgetsidedata(avpkt, AVPKTDATASUBTITLEPOSITION, &size); FFASSDecoderContext *s = avctx->privdata; if (p && size == 16) { x1 = AVRL32(p ); y1 = AVRL32(p + 4); x2 = AVRL32(p + 8); y2 = AVRL32(p + 12); } if (avpkt->size <= 0) return avpkt->size; avbprintinit(&buffer, 0, AVBPRINTSIZEUNLIMITED); srttoass(avctx, &buffer, avpkt->data, x1, y1, x2, y2); ret = ffassaddrect(sub, buffer.str, s->readorder++, 0, NULL, NULL); avbprintfinalize(&buffer, NULL); if (ret < 0) return ret; *gotsubptr = sub->numrects > 0; return avpkt->size; } ", "target": 0}
{"func": "static int filterslice(AVFilterContext *ctx, void *arg, int jobnr, int nbjobs) { YADIFContext *s = ctx->priv; ThreadData *td = arg; int refs = s->cur->linesize[td->plane]; int df = (s->csp->comp[td->plane].depthminus1 + 8) / 8; int pix3 = 3 * df; int sliceh = td->h / nbjobs; int slicestart = jobnr * sliceh; int sliceend = (jobnr == nbjobs - 1) ? td->h : (jobnr + 1) * sliceh; int y; /* filtering reads 3 pixels to the left/right; to avoid invalid reads, * we need to call the c variant which avoids this for border pixels */ for (y = slicestart; y < sliceend; y++) { if ((y ^ td->parity) & 1) { uint8t *prev = &s->prev->data[td->plane][y * refs]; uint8t *cur = &s->cur ->data[td->plane][y * refs]; uint8t *next = &s->next->data[td->plane][y * refs]; uint8t *dst = &td->frame->data[td->plane][y * td->frame->linesize[td->plane]]; int mode = y == 1 || y + 2 == td->h ? 2 : s->mode; s->filterline(dst + pix3, prev + pix3, cur + pix3, next + pix3, td->w - 6, y + 1 < td->h ? refs : -refs, y ? -refs : refs, td->parity ^ td->tff, mode); s->filteredges(dst, prev, cur, next, td->w, y + 1 < td->h ? refs : -refs, y ? -refs : refs, td->parity ^ td->tff, mode); } else { memcpy(&td->frame->data[td->plane][y * td->frame->linesize[td->plane]], &s->cur->data[td->plane][y * refs], td->w * df); } } return 0; } ", "target": 1}
{"func": "int ppc64v3handlemmufault(PowerPCCPU *cpu, vaddr eaddr, int rwx, int mmuidx) { if (ppc64radixguest(cpu)) { /* Guest uses radix */ /* TODO - Unsupported */ errorreport(\"Guest Radix Support Unimplemented\"); exit(1); } else { /* Guest uses hash */ return ppchash64handlemmufault(cpu, eaddr, rwx, mmuidx); } } ", "target": 0}
{"func": "int ffimgreadpacket(AVFormatContext *s1, AVPacket *pkt) { VideoDemuxData *s = s1->privdata; char filenamebytes[1024]; char *filename = filenamebytes; int i; int size[3] = { 0 }, ret[3] = { 0 }; AVIOContext *f[3] = { NULL }; AVCodecContext *codec = s1->streams[0]->codec; if (!s->ispipe) { /* loop over input */ if (s->loop && s->imgnumber > s->imglast) { s->imgnumber = s->imgfirst; } if (s->imgnumber > s->imglast) return AVERROREOF; if (s->useglob) { #if HAVEGLOB filename = s->globstate.glpathv[s->imgnumber]; #endif } else { if (avgetframefilename(filenamebytes, sizeof(filenamebytes), s->path, s->imgnumber) < 0 && s->imgnumber > 1) return AVERROR(EIO); } for (i = 0; i < 3; i++) { if (avioopen2(&f[i], filename, AVIOFLAGREAD, &s1->interruptcallback, NULL) < 0) { if (i >= 1) break; avlog(s1, AVLOGERROR, \"Could not open file : %s\\n\", filename); return AVERROR(EIO); } size[i] = aviosize(f[i]); if (!s->splitplanes) break; filename[strlen(filename) - 1] = 'U' + i; } if (codec->codecid == AVCODECIDNONE) { AVProbeData pd; AVInputFormat *ifmt; uint8t header[PROBEBUFMIN + AVPROBEPADDINGSIZE]; int ret; int score = 0; ret = avioread(f[0], header, PROBEBUFMIN); if (ret < 0) return ret; avioskip(f[0], -ret); pd.buf = header; pd.bufsize = ret; pd.filename = filename; ifmt = avprobeinputformat3(&pd, 1, &score); if (ifmt && ifmt->readpacket == ffimgreadpacket && ifmt->rawcodecid) codec->codecid = ifmt->rawcodecid; } if (codec->codecid == AVCODECIDRAWVIDEO && !codec->width) infersize(&codec->width, &codec->height, size[0]); } else { f[0] = s1->pb; if (urlfeof(f[0])) return AVERROR(EIO); if (s->framesize > 0) { size[0] = s->framesize; } else { size[0] = 4096; } } if (avnewpacket(pkt, size[0] + size[1] + size[2]) < 0) return AVERROR(ENOMEM); pkt->streamindex = 0; pkt->flags |= AVPKTFLAGKEY; if (s->tsfromfile) { struct stat imgstat; if (stat(filename, &imgstat)) return AVERROR(EIO); pkt->pts = (int64t)imgstat.stmtime; avaddindexentry(s1->streams[0], s->imgnumber, pkt->pts, 0, 0, AVINDEXKEYFRAME); } else if (!s->ispipe) { pkt->pts = s->pts; } pkt->size = 0; for (i = 0; i < 3; i++) { if (f[i]) { ret[i] = avioread(f[i], pkt->data + pkt->size, size[i]); if (!s->ispipe) avioclose(f[i]); if (ret[i] > 0) pkt->size += ret[i]; } } if (ret[0] <= 0 || ret[1] < 0 || ret[2] < 0) { avfreepacket(pkt); return AVERROR(EIO); /* signal EOF */ } else { s->imgcount++; s->imgnumber++; s->pts++; return 0; } }", "target": 1}
{"func": "void idedatawritew(void *opaque, uint32t addr, uint32t val) { IDEBus *bus = opaque; IDEState *s = idebusactiveif(bus); uint8t *p; /* PIO data access allowed only when DRQ bit is set */ if (!(s->status & DRQSTAT)) return; p = s->dataptr; *(uint16t *)p = le16tocpu(val); p += 2; s->dataptr = p; if (p >= s->dataend) s->endtransferfunc(s); } ", "target": 1}
{"func": "static void quantizeandencodebandcostSPAIRmips(struct AACEncContext *s, PutBitContext *pb, const float *in, float *out, const float *scaled, int size, int scaleidx, int cb, const float lambda, const float uplim, int *bits, const float ROUNDING) { const float Q34 = ffaacpow34sftab[POWSF2ZERO - scaleidx + SCALEONEPOS - SCALEDIV512]; const float IQ = ffaacpow2sftab [POWSF2ZERO + scaleidx - SCALEONEPOS + SCALEDIV512]; int i; int qc1, qc2, qc3, qc4; uint8t *pbits = (uint8t *)ffaacspectralbits[cb-1]; uint16t *pcodes = (uint16t *)ffaacspectralcodes[cb-1]; float *pvec = (float *)ffaaccodebookvectors[cb-1]; abspow34v(s->scoefs, in, size); scaled = s->scoefs; for (i = 0; i < size; i += 4) { int curidx, curidx2; int *inint = (int *)&in[i]; uint8t vbits; unsigned int vcodes; int t0, t1, t2, t3, t4, t5, t6, t7; const float *vec1, *vec2; qc1 = scaled[i ] * Q34 + ROUNDSTANDARD; qc2 = scaled[i+1] * Q34 + ROUNDSTANDARD; qc3 = scaled[i+2] * Q34 + ROUNDSTANDARD; qc4 = scaled[i+3] * Q34 + ROUNDSTANDARD; asm volatile ( \".set push \\n\\t\" \".set noreorder \\n\\t\" \"ori %[t4], $zero, 4 \\n\\t\" \"slt %[t0], %[t4], %[qc1] \\n\\t\" \"slt %[t1], %[t4], %[qc2] \\n\\t\" \"slt %[t2], %[t4], %[qc3] \\n\\t\" \"slt %[t3], %[t4], %[qc4] \\n\\t\" \"movn %[qc1], %[t4], %[t0] \\n\\t\" \"movn %[qc2], %[t4], %[t1] \\n\\t\" \"movn %[qc3], %[t4], %[t2] \\n\\t\" \"movn %[qc4], %[t4], %[t3] \\n\\t\" \"lw %[t0], 0(%[inint]) \\n\\t\" \"lw %[t1], 4(%[inint]) \\n\\t\" \"lw %[t2], 8(%[inint]) \\n\\t\" \"lw %[t3], 12(%[inint]) \\n\\t\" \"srl %[t0], %[t0], 31 \\n\\t\" \"srl %[t1], %[t1], 31 \\n\\t\" \"srl %[t2], %[t2], 31 \\n\\t\" \"srl %[t3], %[t3], 31 \\n\\t\" \"subu %[t4], $zero, %[qc1] \\n\\t\" \"subu %[t5], $zero, %[qc2] \\n\\t\" \"subu %[t6], $zero, %[qc3] \\n\\t\" \"subu %[t7], $zero, %[qc4] \\n\\t\" \"movn %[qc1], %[t4], %[t0] \\n\\t\" \"movn %[qc2], %[t5], %[t1] \\n\\t\" \"movn %[qc3], %[t6], %[t2] \\n\\t\" \"movn %[qc4], %[t7], %[t3] \\n\\t\" \".set pop \\n\\t\" : [qc1]\"+r\"(qc1), [qc2]\"+r\"(qc2), [qc3]\"+r\"(qc3), [qc4]\"+r\"(qc4), [t0]\"=&r\"(t0), [t1]\"=&r\"(t1), [t2]\"=&r\"(t2), [t3]\"=&r\"(t3), [t4]\"=&r\"(t4), [t5]\"=&r\"(t5), [t6]\"=&r\"(t6), [t7]\"=&r\"(t7) : [inint]\"r\"(inint) : \"memory\" ); curidx = 9 * qc1; curidx += qc2 + 40; curidx2 = 9 * qc3; curidx2 += qc4 + 40; vcodes = (pcodes[curidx] << pbits[curidx2]) | (pcodes[curidx2]); vbits = pbits[curidx] + pbits[curidx2]; putbits(pb, vbits, vcodes); if (out) { vec1 = &pvec[curidx*2 ]; vec2 = &pvec[curidx2*2]; out[i+0] = vec1[0] * IQ; out[i+1] = vec1[1] * IQ; out[i+2] = vec2[0] * IQ; out[i+3] = vec2[1] * IQ; } } } ", "target": 1}
{"func": "static int streamcomponentopen(PlayerState *is, int streamindex) { AVFormatContext *ic = is->ic; AVCodecContext *avctx; AVCodec *codec; SDLAudioSpec wantedspec, spec; AVDictionary *opts; AVDictionaryEntry *t = NULL; int ret = 0; if (streamindex < 0 || streamindex >= ic->nbstreams) return -1; avctx = ic->streams[streamindex]->codec; opts = filtercodecopts(codecopts, avctx->codecid, ic, ic->streams[streamindex], NULL); codec = avcodecfinddecoder(avctx->codecid); avctx->workaroundbugs = workaroundbugs; avctx->idctalgo = idct; avctx->skipframe = skipframe; avctx->skipidct = skipidct; avctx->skiploopfilter = skiploopfilter; avctx->errorconcealment = errorconcealment; if (fast) avctx->flags2 |= AVCODECFLAG2FAST; if (!avdictget(opts, \"threads\", NULL, 0)) avdictset(&opts, \"threads\", \"auto\", 0); if (avctx->codectype == AVMEDIATYPEVIDEO) avdictset(&opts, \"refcountedframes\", \"1\", 0); if (!codec || (ret = avcodecopen2(avctx, codec, &opts)) < 0) { goto fail; } if ((t = avdictget(opts, \"\", NULL, AVDICTIGNORESUFFIX))) { avlog(NULL, AVLOGERROR, \"Option %s not found.\\n\", t->key); ret = AVERROROPTIONNOTFOUND; goto fail; } /* prepare audio output */ if (avctx->codectype == AVMEDIATYPEAUDIO) { is->sdlsamplerate = avctx->samplerate; if (!avctx->channellayout) avctx->channellayout = avgetdefaultchannellayout(avctx->channels); if (!avctx->channellayout) { fprintf(stderr, \"unable to guess channel layout\\n\"); ret = AVERRORINVALIDDATA; goto fail; } if (avctx->channels == 1) is->sdlchannellayout = AVCHLAYOUTMONO; else is->sdlchannellayout = AVCHLAYOUTSTEREO; is->sdlchannels = avgetchannellayoutnbchannels(is->sdlchannellayout); wantedspec.format = AUDIOS16SYS; wantedspec.freq = is->sdlsamplerate; wantedspec.channels = is->sdlchannels; wantedspec.silence = 0; wantedspec.samples = SDLAUDIOBUFFERSIZE; wantedspec.callback = sdlaudiocallback; wantedspec.userdata = is; if (SDLOpenAudio(&wantedspec, &spec) < 0) { fprintf(stderr, \"SDLOpenAudio: %s\\n\", SDLGetError()); ret = AVERRORUNKNOWN; goto fail; } is->audiohwbufsize = spec.size; is->sdlsamplefmt = AVSAMPLEFMTS16; is->resamplesamplefmt = is->sdlsamplefmt; is->resamplechannellayout = avctx->channellayout; is->resamplesamplerate = avctx->samplerate; } ic->streams[streamindex]->discard = AVDISCARDDEFAULT; switch (avctx->codectype) { case AVMEDIATYPEAUDIO: is->audiostream = streamindex; is->audiost = ic->streams[streamindex]; is->audiobufsize = 0; is->audiobufindex = 0; /* init averaging filter */ is->audiodiffavgcoef = exp(log(0.01) / AUDIODIFFAVGNB); is->audiodiffavgcount = 0; /* since we do not have a precise anough audio fifo fullness, we correct audio sync only if larger than this threshold */ is->audiodiffthreshold = 2.0 * SDLAUDIOBUFFERSIZE / avctx->samplerate; memset(&is->audiopkt, 0, sizeof(is->audiopkt)); packetqueueinit(&is->audioq); SDLPauseAudio(0); break; case AVMEDIATYPEVIDEO: is->videostream = streamindex; is->videost = ic->streams[streamindex]; packetqueueinit(&is->videoq); is->videotid = SDLCreateThread(videothread, is); break; case AVMEDIATYPESUBTITLE: is->subtitlestream = streamindex; is->subtitlest = ic->streams[streamindex]; packetqueueinit(&is->subtitleq); is->subtitletid = SDLCreateThread(subtitlethread, is); break; default: break; } fail: avdictfree(&opts); return ret; } ", "target": 0}
{"func": "static void keywordliteral(void) { QObject *obj; QBool *qbool; QObject *null; QString *str; obj = qobjectfromjson(\"true\", NULL); qbool = qobjecttoqbool(obj); gassert(qbool); gassert(qboolgetbool(qbool) == true); str = qobjecttojson(obj); gassert(strcmp(qstringgetstr(str), \"true\") == 0); QDECREF(str); QDECREF(qbool); obj = qobjectfromjson(\"false\", NULL); qbool = qobjecttoqbool(obj); gassert(qbool); gassert(qboolgetbool(qbool) == false); str = qobjecttojson(obj); gassert(strcmp(qstringgetstr(str), \"false\") == 0); QDECREF(str); QDECREF(qbool); qbool = qobjecttoqbool(qobjectfromjsonf(\"%i\", false)); gassert(qbool); gassert(qboolgetbool(qbool) == false); QDECREF(qbool); /* Test that non-zero values other than 1 get collapsed to true */ qbool = qobjecttoqbool(qobjectfromjsonf(\"%i\", 2)); gassert(qbool); gassert(qboolgetbool(qbool) == true); QDECREF(qbool); obj = qobjectfromjson(\"null\", NULL); gassert(obj != NULL); gassert(qobjecttype(obj) == QTYPEQNULL); null = qnull(); gassert(null == obj); qobjectdecref(obj); qobjectdecref(null); } ", "target": 1}
{"func": "static void ppccore99init (ramaddrt ramsize, const char *bootdevice, const char *kernelfilename, const char *kernelcmdline, const char *initrdfilename, const char *cpumodel) { CPUState *env = NULL, *envs[MAXCPUS]; char *filename; qemuirq *pic, **openpicirqs; int uninmemory; int linuxboot, i; ramaddrt ramoffset, biosoffset, vgabiosoffset; uint32t kernelbase, kernelsize, initrdbase, initrdsize; PCIBus *pcibus; MacIONVRAMState *nvr; int nvrammemindex; int vgabiossize, biossize; int picmemindex, dbdmamemindex, cudamemindex, esccmemindex; int idememindex[3]; int ppcbootdevice; DriveInfo *hd[MAXIDEBUS * MAXIDEDEVS]; void *fwcfg; void *dbdma; uint8t *vgabiosptr; int machinearch; linuxboot = (kernelfilename != NULL); /* init CPUs */ if (cpumodel == NULL) #ifdef TARGETPPC64 cpumodel = \"970fx\"; #else cpumodel = \"G4\"; #endif for (i = 0; i < smpcpus; i++) { env = cpuinit(cpumodel); if (!env) { fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\"); exit(1); } /* Set time-base frequency to 100 Mhz */ cpuppctbinit(env, 100UL * 1000UL * 1000UL); #if 0 env->osicall = vgaosicall; #endif qemuregisterreset((QEMUResetHandler*)&cpureset, env); envs[i] = env; } /* allocate RAM */ ramoffset = qemuramalloc(NULL, \"ppccore99.ram\", ramsize); cpuregisterphysicalmemory(0, ramsize, ramoffset); /* allocate and load BIOS */ biosoffset = qemuramalloc(NULL, \"ppccore99.bios\", BIOSSIZE); if (biosname == NULL) biosname = PROMFILENAME; filename = qemufindfile(QEMUFILETYPEBIOS, biosname); cpuregisterphysicalmemory(PROMADDR, BIOSSIZE, biosoffset | IOMEMROM); /* Load OpenBIOS (ELF) */ if (filename) { biossize = loadelf(filename, NULL, NULL, NULL, NULL, NULL, 1, ELFMACHINE, 0); qemufree(filename); } else { biossize = -1; } if (biossize < 0 || biossize > BIOSSIZE) { hwerror(\"qemu: could not load PowerPC bios '%s'\\n\", biosname); exit(1); } /* allocate and load VGA BIOS */ vgabiosoffset = qemuramalloc(NULL, \"ppccore99.vbios\", VGABIOSSIZE); vgabiosptr = qemugetramptr(vgabiosoffset); filename = qemufindfile(QEMUFILETYPEBIOS, VGABIOSFILENAME); if (filename) { vgabiossize = loadimage(filename, vgabiosptr + 8); qemufree(filename); } else { vgabiossize = -1; } if (vgabiossize < 0) { /* if no bios is present, we can still work */ fprintf(stderr, \"qemu: warning: could not load VGA bios '%s'\\n\", VGABIOSFILENAME); vgabiossize = 0; } else { /* set a specific header (XXX: find real Apple format for NDRV drivers) */ vgabiosptr[0] = 'N'; vgabiosptr[1] = 'D'; vgabiosptr[2] = 'R'; vgabiosptr[3] = 'V'; cputobe32w((uint32t *)(vgabiosptr + 4), vgabiossize); vgabiossize += 8; /* Round to page boundary */ vgabiossize = (vgabiossize + TARGETPAGESIZE - 1) & TARGETPAGEMASK; } if (linuxboot) { uint64t lowaddr = 0; int bswapneeded; #ifdef BSWAPNEEDED bswapneeded = 1; #else bswapneeded = 0; #endif kernelbase = KERNELLOADADDR; kernelsize = loadelf(kernelfilename, translatekerneladdress, NULL, NULL, &lowaddr, NULL, 1, ELFMACHINE, 0); if (kernelsize < 0) kernelsize = loadaout(kernelfilename, kernelbase, ramsize - kernelbase, bswapneeded, TARGETPAGESIZE); if (kernelsize < 0) kernelsize = loadimagetargphys(kernelfilename, kernelbase, ramsize - kernelbase); if (kernelsize < 0) { hwerror(\"qemu: could not load kernel '%s'\\n\", kernelfilename); exit(1); } /* load initrd */ if (initrdfilename) { initrdbase = INITRDLOADADDR; initrdsize = loadimagetargphys(initrdfilename, initrdbase, ramsize - initrdbase); if (initrdsize < 0) { hwerror(\"qemu: could not load initial ram disk '%s'\\n\", initrdfilename); exit(1); } } else { initrdbase = 0; initrdsize = 0; } ppcbootdevice = 'm'; } else { kernelbase = 0; kernelsize = 0; initrdbase = 0; initrdsize = 0; ppcbootdevice = '\\0'; /* We consider that NewWorld PowerMac never have any floppy drive * For now, OHW cannot boot from the network. */ for (i = 0; bootdevice[i] != '\\0'; i++) { if (bootdevice[i] >= 'c' && bootdevice[i] <= 'f') { ppcbootdevice = bootdevice[i]; break; } } if (ppcbootdevice == '\\0') { fprintf(stderr, \"No valid boot device for Mac99 machine\\n\"); exit(1); } } isamembase = 0x80000000; /* Register 8 MB of ISA IO space */ isammioinit(0xf2000000, 0x00800000, 1); /* UniN init */ uninmemory = cpuregisteriomemory(uninread, uninwrite, NULL); cpuregisterphysicalmemory(0xf8000000, 0x00001000, uninmemory); openpicirqs = qemumallocz(smpcpus * sizeof(qemuirq *)); openpicirqs[0] = qemumallocz(smpcpus * sizeof(qemuirq) * OPENPICOUTPUTNB); for (i = 0; i < smpcpus; i++) { /* Mac99 IRQ connection between OpenPIC outputs pins * and PowerPC input pins */ switch (PPCINPUT(env)) { case PPCFLAGSINPUT6xx: openpicirqs[i] = openpicirqs[0] + (i * OPENPICOUTPUTNB); openpicirqs[i][OPENPICOUTPUTINT] = ((qemuirq *)env->irqinputs)[PPC6xxINPUTINT]; openpicirqs[i][OPENPICOUTPUTCINT] = ((qemuirq *)env->irqinputs)[PPC6xxINPUTINT]; openpicirqs[i][OPENPICOUTPUTMCK] = ((qemuirq *)env->irqinputs)[PPC6xxINPUTMCP]; /* Not connected ? */ openpicirqs[i][OPENPICOUTPUTDEBUG] = NULL; /* Check this */ openpicirqs[i][OPENPICOUTPUTRESET] = ((qemuirq *)env->irqinputs)[PPC6xxINPUTHRESET]; break; #if defined(TARGETPPC64) case PPCFLAGSINPUT970: openpicirqs[i] = openpicirqs[0] + (i * OPENPICOUTPUTNB); openpicirqs[i][OPENPICOUTPUTINT] = ((qemuirq *)env->irqinputs)[PPC970INPUTINT]; openpicirqs[i][OPENPICOUTPUTCINT] = ((qemuirq *)env->irqinputs)[PPC970INPUTINT]; openpicirqs[i][OPENPICOUTPUTMCK] = ((qemuirq *)env->irqinputs)[PPC970INPUTMCP]; /* Not connected ? */ openpicirqs[i][OPENPICOUTPUTDEBUG] = NULL; /* Check this */ openpicirqs[i][OPENPICOUTPUTRESET] = ((qemuirq *)env->irqinputs)[PPC970INPUTHRESET]; break; #endif /* defined(TARGETPPC64) */ default: hwerror(\"Bus model not supported on mac99 machine\\n\"); exit(1); } } pic = openpicinit(NULL, &picmemindex, smpcpus, openpicirqs, NULL); if (PPCINPUT(env) == PPCFLAGSINPUT970) { /* 970 gets a U3 bus */ pcibus = pcipmacu3init(pic); machinearch = ARCHMAC99U3; } else { pcibus = pcipmacinit(pic); machinearch = ARCHMAC99; } /* init basic PC hardware */ pcivgainit(pcibus, vgabiosoffset, vgabiossize); esccmemindex = esccinit(0x80013000, pic[0x25], pic[0x24], serialhds[0], serialhds[1], ESCCCLOCK, 4); for(i = 0; i < nbnics; i++) pcinicinitnofail(&ndtable[i], \"ne2kpci\", NULL); if (drivegetmaxbus(IFIDE) >= MAXIDEBUS) { fprintf(stderr, \"qemu: too many IDE bus\\n\"); exit(1); } dbdma = DBDMAinit(&dbdmamemindex); /* We only emulate 2 out of 3 IDE controllers for now */ idememindex[0] = -1; hd[0] = driveget(IFIDE, 0, 0); hd[1] = driveget(IFIDE, 0, 1); idememindex[1] = pmacideinit(hd, pic[0x0d], dbdma, 0x16, pic[0x02]); hd[0] = driveget(IFIDE, 1, 0); hd[1] = driveget(IFIDE, 1, 1); idememindex[2] = pmacideinit(hd, pic[0x0e], dbdma, 0x1a, pic[0x02]); /* cuda also initialize ADB */ if (machinearch == ARCHMAC99U3) { usbenabled = 1; } cudainit(&cudamemindex, pic[0x19]); adbkbdinit(&adbbus); adbmouseinit(&adbbus); macioinit(pcibus, PCIDEVICEIDAPPLEUNINKEYL, 0, picmemindex, dbdmamemindex, cudamemindex, NULL, 3, idememindex, esccmemindex); if (usbenabled) { usbohciinitpci(pcibus, -1); } /* U3 needs to use USB for input because Linux doesn't support via-cuda on PPC64 */ if (machinearch == ARCHMAC99U3) { usbdevicecreate(\"keyboard\"); usbdevicecreate(\"mouse\"); } if (graphicdepth != 15 && graphicdepth != 32 && graphicdepth != 8) graphicdepth = 15; /* The NewWorld NVRAM is not located in the MacIO device */ nvr = macionvraminit(&nvrammemindex, 0x2000, 1); pmacformatnvrampartition(nvr, 0x2000); macionvrammap(nvr, 0xFFF04000); /* No PCI init: the BIOS will do it */ fwcfg = fwcfginit(0, 0, CFGADDR, CFGADDR + 2); fwcfgaddi32(fwcfg, FWCFGID, 1); fwcfgaddi64(fwcfg, FWCFGRAMSIZE, (uint64t)ramsize); fwcfgaddi16(fwcfg, FWCFGMACHINEID, machinearch); fwcfgaddi32(fwcfg, FWCFGKERNELADDR, kernelbase); fwcfgaddi32(fwcfg, FWCFGKERNELSIZE, kernelsize); if (kernelcmdline) { fwcfgaddi32(fwcfg, FWCFGKERNELCMDLINE, CMDLINEADDR); pstrcpytargphys(\"cmdline\", CMDLINEADDR, TARGETPAGESIZE, kernelcmdline); } else { fwcfgaddi32(fwcfg, FWCFGKERNELCMDLINE, 0); } fwcfgaddi32(fwcfg, FWCFGINITRDADDR, initrdbase); fwcfgaddi32(fwcfg, FWCFGINITRDSIZE, initrdsize); fwcfgaddi16(fwcfg, FWCFGBOOTDEVICE, ppcbootdevice); fwcfgaddi16(fwcfg, FWCFGPPCWIDTH, graphicwidth); fwcfgaddi16(fwcfg, FWCFGPPCHEIGHT, graphicheight); fwcfgaddi16(fwcfg, FWCFGPPCDEPTH, graphicdepth); fwcfgaddi32(fwcfg, FWCFGPPCISKVM, kvmenabled()); if (kvmenabled()) { #ifdef CONFIGKVM uint8t *hypercall; fwcfgaddi32(fwcfg, FWCFGPPCTBFREQ, kvmppcgettbfreq()); hypercall = qemumalloc(16); kvmppcgethypercall(env, hypercall, 16); fwcfgaddbytes(fwcfg, FWCFGPPCKVMHC, hypercall, 16); fwcfgaddi32(fwcfg, FWCFGPPCKVMPID, getpid()); #endif } else { fwcfgaddi32(fwcfg, FWCFGPPCTBFREQ, gettickspersec()); } qemuregisterbootset(fwcfgbootset, fwcfg); } ", "target": 0}
{"func": "void DMArun(void) { /* XXXXX */ } ", "target": 0}
{"func": "INLINE int16 extractFloat64Exp( float64 a ) { return ( a>>52 ) & 0x7FF; } ", "target": 0}
{"func": "uint32t helperfcmpun(uint32t a, uint32t b) { CPUFloatU fa, fb; uint32t r = 0; fa.l = a; fb.l = b; if (float32issignalingnan(fa.f) || float32issignalingnan(fb.f)) { updatefpuflags(floatflaginvalid); r = 1; } if (float32isnan(fa.f) || float32isnan(fb.f)) { r = 1; } return r; } ", "target": 0}
{"func": "static int vhostuserstart(VhostUserState *s) { VhostNetOptions options; if (vhostuserrunning(s)) { return 0; } options.backendtype = VHOSTBACKENDTYPEUSER; options.netbackend = &s->nc; options.opaque = s->chr; s->vhostnet = vhostnetinit(&options); return vhostuserrunning(s) ? 0 : -1; } ", "target": 0}
{"func": "static int alacsetinfo(ALACContext *alac) { GetByteContext gb; bytestream2init(&gb, alac->avctx->extradata, alac->avctx->extradatasize); bytestream2skipu(&gb, 12); // size:4, alac:4, version:4 alac->maxsamplesperframe = bytestream2getbe32u(&gb); if (alac->maxsamplesperframe >= UINTMAX/4){ avlog(alac->avctx, AVLOGERROR, \"maxsamplesperframe too large\\n\"); return AVERRORINVALIDDATA; } bytestream2skipu(&gb, 1); // compatible version alac->samplesize = bytestream2getbyteu(&gb); alac->ricehistorymult = bytestream2getbyteu(&gb); alac->riceinitialhistory = bytestream2getbyteu(&gb); alac->ricelimit = bytestream2getbyteu(&gb); alac->channels = bytestream2getbyteu(&gb); bytestream2getbe16u(&gb); // maxRun bytestream2getbe32u(&gb); // max coded frame size bytestream2getbe32u(&gb); // average bitrate bytestream2getbe32u(&gb); // samplerate return 0; } ", "target": 0}
{"func": "static void sdhcisendcommand(SDHCIState *s) { SDRequest request; uint8t response[16]; int rlen; s->errintsts = 0; s->acmd12errsts = 0; request.cmd = s->cmdreg >> 8; request.arg = s->argument; DPRINTL1(\"sending CMD%u ARG[0x%08x]\\n\", request.cmd, request.arg); rlen = sdbusdocommand(&s->sdbus, &request, response); if (s->cmdreg & SDHCCMDRESPONSE) { if (rlen == 4) { s->rspreg[0] = (response[0] << 24) | (response[1] << 16) | (response[2] << 8) | response[3]; s->rspreg[1] = s->rspreg[2] = s->rspreg[3] = 0; DPRINTL1(\"Response: RSPREG[31..0]=0x%08x\\n\", s->rspreg[0]); } else if (rlen == 16) { s->rspreg[0] = (response[11] << 24) | (response[12] << 16) | (response[13] << 8) | response[14]; s->rspreg[1] = (response[7] << 24) | (response[8] << 16) | (response[9] << 8) | response[10]; s->rspreg[2] = (response[3] << 24) | (response[4] << 16) | (response[5] << 8) | response[6]; s->rspreg[3] = (response[0] << 16) | (response[1] << 8) | response[2]; DPRINTL1(\"Response received:\\n RSPREG[127..96]=0x%08x, RSPREG[95..\" \"64]=0x%08x,\\n RSPREG[63..32]=0x%08x, RSPREG[31..0]=0x%08x\\n\", s->rspreg[3], s->rspreg[2], s->rspreg[1], s->rspreg[0]); } else { ERRPRINT(\"Timeout waiting for command response\\n\"); if (s->errintstsen & SDHCEISENCMDTIMEOUT) { s->errintsts |= SDHCEISCMDTIMEOUT; s->norintsts |= SDHCNISERR; } } if ((s->norintstsen & SDHCNISENTRSCMP) && (s->cmdreg & SDHCCMDRESPONSE) == SDHCCMDRSPWITHBUSY) { s->norintsts |= SDHCNISTRSCMP; } } if (s->norintstsen & SDHCNISENCMDCMP) { s->norintsts |= SDHCNISCMDCMP; } sdhciupdateirq(s); if (s->blksize && (s->cmdreg & SDHCCMDDATAPRESENT)) { s->datacount = 0; sdhcidatatransfer(s); } } ", "target": 1}
{"func": "static void testdealloctypes(void) { UserDefOne *ud1test, *ud1a, *ud1b; UserDefOneList *ud1list; ud1test = gmalloc0(sizeof(UserDefOne)); ud1test->base = gnew0(UserDefZero, 1); ud1test->base->integer = 42; ud1test->string = gstrdup(\"hi there 42\"); qapifreeUserDefOne(ud1test); ud1a = gmalloc0(sizeof(UserDefOne)); ud1a->base = gnew0(UserDefZero, 1); ud1a->base->integer = 43; ud1a->string = gstrdup(\"hi there 43\"); ud1b = gmalloc0(sizeof(UserDefOne)); ud1b->base = gnew0(UserDefZero, 1); ud1b->base->integer = 44; ud1b->string = gstrdup(\"hi there 44\"); ud1list = gmalloc0(sizeof(UserDefOneList)); ud1list->value = ud1a; ud1list->next = gmalloc0(sizeof(UserDefOneList)); ud1list->next->value = ud1b; qapifreeUserDefOneList(ud1list); } ", "target": 0}
{"func": "void netchecksumcalculate(uint8t *data, int length) { int hlen, plen, proto, csumoffset; uint16t csum; if ((data[14] & 0xf0) != 0x40) \treturn; /* not IPv4 */ hlen = (data[14] & 0x0f) * 4; plen = (data[16] << 8 | data[17]) - hlen; proto = data[23]; switch (proto) { case PROTOTCP: \tcsumoffset = 16; \tbreak; case PROTOUDP: \tcsumoffset = 6; \tbreak; default: \treturn; } if (plen < csumoffset+2) \treturn; data[14+hlen+csumoffset] = 0; data[14+hlen+csumoffset+1] = 0; csum = netchecksumtcpudp(plen, proto, data+14+12, data+14+hlen); data[14+hlen+csumoffset] = csum >> 8; data[14+hlen+csumoffset+1] = csum & 0xff; } ", "target": 0}
{"func": "static void x86cpuparsefeaturestr(const char *typename, char *features, Error **errp) { char *featurestr; /* Single 'key=value\" string being parsed */ static bool cpuglobalsinitialized; bool ambiguous = false; if (cpuglobalsinitialized) { return; } cpuglobalsinitialized = true; if (!features) { return; } for (featurestr = strtok(features, \",\"); featurestr; featurestr = strtok(NULL, \",\")) { const char *name; const char *val = NULL; char *eq = NULL; char num[32]; GlobalProperty *prop; /* Compatibility syntax: */ if (featurestr[0] == '+') { plusfeatures = glistappend(plusfeatures, gstrdup(featurestr + 1)); continue; } else if (featurestr[0] == '-') { minusfeatures = glistappend(minusfeatures, gstrdup(featurestr + 1)); continue; } eq = strchr(featurestr, '='); if (eq) { *eq++ = 0; val = eq; } else { val = \"on\"; } feat2prop(featurestr); name = featurestr; if (glistfindcustom(plusfeatures, name, comparestring)) { errorreport(\"warning: Ambiguous CPU model string. \" \"Don't mix both \\\"+%s\\\" and \\\"%s=%s\\\"\", name, name, val); ambiguous = true; } if (glistfindcustom(minusfeatures, name, comparestring)) { errorreport(\"warning: Ambiguous CPU model string. \" \"Don't mix both \\\"-%s\\\" and \\\"%s=%s\\\"\", name, name, val); ambiguous = true; } /* Special case: */ if (!strcmp(name, \"tsc-freq\")) { int64t tscfreq; tscfreq = qemustrtoszmetric(val, NULL); if (tscfreq < 0) { errorsetg(errp, \"bad numerical value %s\", val); return; } snprintf(num, sizeof(num), \"%\" PRId64, tscfreq); val = num; name = \"tsc-frequency\"; } prop = gnew0(typeof(*prop), 1); prop->driver = typename; prop->property = gstrdup(name); prop->value = gstrdup(val); prop->errp = &errorfatal; qdevpropregisterglobal(prop); } if (ambiguous) { errorreport(\"warning: Compatibility of ambiguous CPU model \" \"strings won't be kept on future QEMU versions\"); } } ", "target": 0}
{"func": "static VirtIOSCSIVring *virtioscsivringinit(VirtIOSCSI *s, VirtQueue *vq, EventNotifierHandler *handler, int n) { BusState *qbus = BUS(qdevgetparentbus(DEVICE(s))); VirtioBusClass *k = VIRTIOBUSGETCLASS(qbus); VirtIOSCSIVring *r = gslicenew(VirtIOSCSIVring); int rc; /* Set up virtqueue notify */ rc = k->sethostnotifier(qbus->parent, n, true); if (rc != 0) { fprintf(stderr, \"virtio-scsi: Failed to set host notifier (%d)\\n\", rc); exit(1); } r->hostnotifier = *virtioqueuegethostnotifier(vq); r->guestnotifier = *virtioqueuegetguestnotifier(vq); aioseteventnotifier(s->ctx, &r->hostnotifier, handler); r->parent = s; if (!vringsetup(&r->vring, VIRTIODEVICE(s), n)) { fprintf(stderr, \"virtio-scsi: VRing setup failed\\n\"); exit(1); } return r; } ", "target": 1}
{"func": "void qemunetqueuepurge(NetQueue *queue, NetClientState *from) { NetPacket *packet, *next; QTAILQFOREACHSAFE(packet, &queue->packets, entry, next) { if (packet->sender == from) { QTAILQREMOVE(&queue->packets, packet, entry); gfree(packet); } } }", "target": 1}
{"func": "static ssizet vncclientreadtls(gnutlssessiont *session, uint8t *data, sizet datalen) { ssizet ret = gnutlsread(*session, data, datalen); if (ret < 0) { if (ret == GNUTLSEAGAIN) { errno = EAGAIN; } else { errno = EIO; } ret = -1; } return ret; } ", "target": 1}
{"func": "static int sliceend(AVCodecContext *avctx, AVFrame *pict) { Mpeg1Context *s1 = avctx->privdata; MpegEncContext *s = &s1->mpegencctx; if (!s1->mpegencctxallocated || !s->currentpictureptr) return 0; if (s->avctx->hwaccel) { if (s->avctx->hwaccel->endframe(s->avctx) < 0) avlog(avctx, AVLOGERROR, \"hardware accelerator failed to decode picture\\n\"); } #if FFAPIXVMC FFDISABLEDEPRECATIONWARNINGS if (CONFIGMPEGXVMCDECODER && s->avctx->xvmcacceleration) ffxvmcfieldend(s); FFENABLEDEPRECATIONWARNINGS #endif /* FFAPIXVMC */ /* end of slice reached */ if (/* s->mby << fieldpic == s->mbheight && */ !s->firstfield) { /* end of image */ fferframeend(&s->er); ffMPVframeend(s); if (s->picttype == AVPICTURETYPEB || s->lowdelay) { int ret = avframeref(pict, &s->currentpictureptr->f); if (ret < 0) return ret; ffprintdebuginfo(s, s->currentpictureptr); } else { if (avctx->activethreadtype & FFTHREADFRAME) s->picturenumber++; /* latency of 1 frame for I- and P-frames */ /* XXX: use another variable than picturenumber */ if (s->lastpictureptr != NULL) { int ret = avframeref(pict, &s->lastpictureptr->f); if (ret < 0) return ret; ffprintdebuginfo(s, s->lastpictureptr); } } return 1; } else { return 0; } } ", "target": 1}
{"func": "static inline int mpeg2fastdecodeblocknonintra(MpegEncContext *s, int16t *block, int n) { int level, i, j, run; RLTable *rl = &ffrlmpeg1; uint8t * const scantable = s->intrascantable.permutated; const int qscale = s->qscale; OPENREADER(re, &s->gb); i = -1; // special case for first coefficient, no need to add second VLC table UPDATECACHE(re, &s->gb); if (((int32t)GETCACHE(re, &s->gb)) < 0) { level = (3 * qscale) >> 1; if (GETCACHE(re, &s->gb) & 0x40000000) level = -level; block[0] = level; i++; SKIPBITS(re, &s->gb, 2); if (((int32t)GETCACHE(re, &s->gb)) <= (int32t)0xBFFFFFFF) goto end; } /* now quantify & encode AC coefficients */ for (;;) { GETRLVLC(level, run, re, &s->gb, rl->rlvlc[0], TEXVLCBITS, 2, 0); if (level != 0) { i += run; j = scantable[i]; level = ((level * 2 + 1) * qscale) >> 1; level = (level ^ SHOWSBITS(re, &s->gb, 1)) - SHOWSBITS(re, &s->gb, 1); SKIPBITS(re, &s->gb, 1); } else { /* escape */ run = SHOWUBITS(re, &s->gb, 6) + 1; LASTSKIPBITS(re, &s->gb, 6); UPDATECACHE(re, &s->gb); level = SHOWSBITS(re, &s->gb, 12); SKIPBITS(re, &s->gb, 12); i += run; j = scantable[i]; if (level < 0) { level = ((-level * 2 + 1) * qscale) >> 1; level = -level; } else { level = ((level * 2 + 1) * qscale) >> 1; } } block[j] = level; if (((int32t)GETCACHE(re, &s->gb)) <= (int32t)0xBFFFFFFF) break; UPDATECACHE(re, &s->gb); } end: LASTSKIPBITS(re, &s->gb, 2); CLOSEREADER(re, &s->gb); s->blocklastindex[n] = i; return 0; } ", "target": 1}
{"func": "static void streamclose(VideoState *is) { VideoPicture *vp; int i; /* XXX: use a special urlshutdown call to abort parse cleanly */ is->abortrequest = 1; SDLWaitThread(is->readtid, NULL); SDLWaitThread(is->refreshtid, NULL); packetqueuedestroy(&is->videoq); packetqueuedestroy(&is->audioq); packetqueuedestroy(&is->subtitleq); /* free all pictures */ for (i = 0; i < VIDEOPICTUREQUEUESIZE; i++) { vp = &is->pictq[i]; #if CONFIGAVFILTER avfilterunrefbufferp(&vp->picref); #endif if (vp->bmp) { SDLFreeYUVOverlay(vp->bmp); vp->bmp = NULL; } } SDLDestroyMutex(is->pictqmutex); SDLDestroyCond(is->pictqcond); SDLDestroyMutex(is->subpqmutex); SDLDestroyCond(is->subpqcond); SDLDestroyCond(is->continuereadthread); #if !CONFIGAVFILTER swsfreeContext(is->imgconvertctx); #endif avfree(is); } ", "target": 0}
{"func": "static void initgaintable(COOKContext *q) { int i; q->gainsizefactor = q->samplesperchannel/8; for (i=0 ; i<23 ; i++) { q->gaintable[i] = pow((double)q->pow2tab[i+52] , (1.0/(double)q->gainsizefactor)); } memset(&q->gaincopy, 0, sizeof(COOKgain)); memset(&q->gaincurrent, 0, sizeof(COOKgain)); memset(&q->gainnow, 0, sizeof(COOKgain)); memset(&q->gainprevious, 0, sizeof(COOKgain)); } ", "target": 1}
{"func": "static void qpafiniout (HWVoiceOut *hw) { void *ret; PAVoiceOut *pa = (PAVoiceOut *) hw; audioptlock (&pa->pt, AUDIOFUNC); pa->done = 1; audioptunlockandsignal (&pa->pt, AUDIOFUNC); audioptjoin (&pa->pt, &ret, AUDIOFUNC); if (pa->s) { pasimplefree (pa->s); pa->s = NULL; } audioptfini (&pa->pt, AUDIOFUNC); gfree (pa->pcmbuf); pa->pcmbuf = NULL; } ", "target": 1}
{"func": "static int scsideviceinit(SCSIDevice *s) { SCSIDeviceClass *sc = SCSIDEVICEGETCLASS(s); if (sc->init) { return sc->init(s); } return 0; } ", "target": 0}
{"func": "static void setdirtybitmap(BlockDriverState *bs, int64t sectornum, int nbsectors, int dirty) { int64t start, end; unsigned long val, idx, bit; start = sectornum / BDRVSECTORSPERDIRTYCHUNK; end = (sectornum + nbsectors - 1) / BDRVSECTORSPERDIRTYCHUNK; for (; start <= end; start++) { idx = start / (sizeof(unsigned long) * 8); bit = start % (sizeof(unsigned long) * 8); val = bs->dirtybitmap[idx]; if (dirty) { val |= 1 << bit; } else { val &= ~(1 << bit); } bs->dirtybitmap[idx] = val; } } ", "target": 0}
{"func": "static sizet nettxpktfetchfragment(struct NetTxPkt *pkt, int *srcidx, sizet *srcoffset, struct iovec *dst, int *dstidx) { sizet fetched = 0; struct iovec *src = pkt->vec; *dstidx = NETTXPKTFRAGMENTHEADERNUM; while (fetched < pkt->virthdr.gsosize) { /* no more place in fragment iov */ if (*dstidx == NETMAXFRAGSGLIST) { break; } /* no more data in iovec */ if (*srcidx == (pkt->payloadfrags + NETTXPKTPLSTARTFRAG)) { break; } dst[*dstidx].iovbase = src[*srcidx].iovbase + *srcoffset; dst[*dstidx].iovlen = MIN(src[*srcidx].iovlen - *srcoffset, pkt->virthdr.gsosize - fetched); *srcoffset += dst[*dstidx].iovlen; fetched += dst[*dstidx].iovlen; if (*srcoffset == src[*srcidx].iovlen) { *srcoffset = 0; (*srcidx)++; } (*dstidx)++; } return fetched; } ", "target": 0}
{"func": "static void lsiramwrite(void *opaque, targetphysaddrt addr, uint64t val, unsigned size) { LSIState *s = opaque; uint32t newval; uint32t mask; int shift; newval = s->scriptram[addr >> 2]; shift = (addr & 3) * 8; mask = ((uint64t)1 << (size * 8)) - 1; newval &= ~(mask << shift); newval |= val << shift; s->scriptram[addr >> 2] = newval; } ", "target": 0}
{"func": "static int getbuffersao(HEVCContext *s, AVFrame *frame, const HEVCSPS *sps) { int ret, i; frame->width = s->avctx->width + 2; frame->height = s->avctx->height + 2; if ((ret = ffgetbuffer(s->avctx, frame, AVGETBUFFERFLAGREF)) < 0) return ret; for (i = 0; frame->data[i]; i++) { int offset = frame->linesize[i] + (1 << sps->pixelshift); frame->data[i] += offset; } frame->width = s->avctx->width; frame->height = s->avctx->height; return 0; } ", "target": 1}
{"func": "static void avclumavt16wmsa(const uint8t *src, int32t srcstride, uint8t *dst, int32t dststride, int32t height) { int32t loopcnt; int16t filtconst0 = 0xfb01; int16t filtconst1 = 0x1414; int16t filtconst2 = 0x1fb; v16i8 src0, src1, src2, src3, src4, src5, src6, src7, src8; v16i8 src10r, src32r, src54r, src76r, src21r, src43r, src65r; v16i8 src87r, src10l, src32l, src54l, src76l, src21l, src43l; v16i8 src65l, src87l; v8i16 out0r, out1r, out2r, out3r, out0l, out1l, out2l, out3l; v16u8 res0, res1, res2, res3; v16i8 filt0, filt1, filt2; filt0 = (v16i8) msafillh(filtconst0); filt1 = (v16i8) msafillh(filtconst1); filt2 = (v16i8) msafillh(filtconst2); LDSB5(src, srcstride, src0, src1, src2, src3, src4); src += (5 * srcstride); XORIB5128SB(src0, src1, src2, src3, src4); ILVRB4SB(src1, src0, src2, src1, src3, src2, src4, src3, src10r, src21r, src32r, src43r); ILVLB4SB(src1, src0, src2, src1, src3, src2, src4, src3, src10l, src21l, src32l, src43l); for (loopcnt = (height >> 2); loopcnt--;) { LDSB4(src, srcstride, src5, src6, src7, src8); src += (4 * srcstride); XORIB4128SB(src5, src6, src7, src8); ILVRB4SB(src5, src4, src6, src5, src7, src6, src8, src7, src54r, src65r, src76r, src87r); ILVLB4SB(src5, src4, src6, src5, src7, src6, src8, src7, src54l, src65l, src76l, src87l); out0r = DPADDSH3SH(src10r, src32r, src54r, filt0, filt1, filt2); out1r = DPADDSH3SH(src21r, src43r, src65r, filt0, filt1, filt2); out2r = DPADDSH3SH(src32r, src54r, src76r, filt0, filt1, filt2); out3r = DPADDSH3SH(src43r, src65r, src87r, filt0, filt1, filt2); out0l = DPADDSH3SH(src10l, src32l, src54l, filt0, filt1, filt2); out1l = DPADDSH3SH(src21l, src43l, src65l, filt0, filt1, filt2); out2l = DPADDSH3SH(src32l, src54l, src76l, filt0, filt1, filt2); out3l = DPADDSH3SH(src43l, src65l, src87l, filt0, filt1, filt2); SRARIH4SH(out0r, out1r, out2r, out3r, 5); SATSH4SH(out0r, out1r, out2r, out3r, 7); SRARIH4SH(out0l, out1l, out2l, out3l, 5); SATSH4SH(out0l, out1l, out2l, out3l, 7); PCKEVB4UB(out0l, out0r, out1l, out1r, out2l, out2r, out3l, out3r, res0, res1, res2, res3); XORIB4128UB(res0, res1, res2, res3); STUB4(res0, res1, res2, res3, dst, dststride); dst += (4 * dststride); src10r = src54r; src32r = src76r; src21r = src65r; src43r = src87r; src10l = src54l; src32l = src76l; src21l = src65l; src43l = src87l; src4 = src8; } } ", "target": 0}
{"func": "static int imgcommit(int argc, char **argv) { int c, ret, flags; const char *filename, *fmt, *cache, *base; BlockBackend *blk; BlockDriverState *bs, *basebs; bool progress = false, quiet = false, drop = false; bool writethrough; Error *localerr = NULL; CommonBlockJobCBInfo cbi; bool imageopts = false; AioContext *aiocontext; fmt = NULL; cache = BDRVDEFAULTCACHE; base = NULL; for(;;) { static const struct option longoptions[] = { {\"help\", noargument, 0, 'h'}, {\"object\", requiredargument, 0, OPTIONOBJECT}, {\"image-opts\", noargument, 0, OPTIONIMAGEOPTS}, {0, 0, 0, 0} }; c = getoptlong(argc, argv, \"f:ht:b:dpq\", longoptions, NULL); if (c == -1) { break; } switch(c) { case '?': case 'h': help(); break; case 'f': fmt = optarg; break; case 't': cache = optarg; break; case 'b': base = optarg; /* -b implies -d */ drop = true; break; case 'd': drop = true; break; case 'p': progress = true; break; case 'q': quiet = true; break; case OPTIONOBJECT: { QemuOpts *opts; opts = qemuoptsparsenoisily(&qemuobjectopts, optarg, true); if (!opts) { return 1; } } break; case OPTIONIMAGEOPTS: imageopts = true; break; } } /* Progress is not shown in Quiet mode */ if (quiet) { progress = false; } if (optind != argc - 1) { errorexit(\"Expecting one image file name\"); } filename = argv[optind++]; if (qemuoptsforeach(&qemuobjectopts, usercreatableaddoptsforeach, NULL, NULL)) { return 1; } flags = BDRVORDWR | BDRVOUNMAP; ret = bdrvparsecachemode(cache, &flags, &writethrough); if (ret < 0) { errorreport(\"Invalid cache option: %s\", cache); return 1; } blk = imgopen(imageopts, filename, fmt, flags, writethrough, quiet); if (!blk) { return 1; } bs = blkbs(blk); qemuprogressinit(progress, 1.f); qemuprogressprint(0.f, 100); if (base) { basebs = bdrvfindbackingimage(bs, base); if (!basebs) { errorsetg(&localerr, QERRBASENOTFOUND, base); goto done; } } else { /* This is different from QMP, which by default uses the deepest file in * the backing chain (i.e., the very base); however, the traditional * behavior of qemu-img commit is using the immediate backing file. */ basebs = backingbs(bs); if (!basebs) { errorsetg(&localerr, \"Image does not have a backing file\"); goto done; } } cbi = (CommonBlockJobCBInfo){ .errp = &localerr, .bs = bs, }; aiocontext = bdrvgetaiocontext(bs); aiocontextacquire(aiocontext); commitactivestart(\"commit\", bs, basebs, BLOCKJOBDEFAULT, 0, BLOCKDEVONERRORREPORT, commonblockjobcb, &cbi, &localerr, false); aiocontextrelease(aiocontext); if (localerr) { goto done; } /* When the block job completes, the BlockBackend reference will point to * the old backing file. In order to avoid that the top image is already * deleted, so we can still empty it afterwards, increment the reference * counter here preemptively. */ if (!drop) { bdrvref(bs); } runblockjob(bs->job, &localerr); if (localerr) { goto unrefbacking; } if (!drop && bs->drv->bdrvmakeempty) { ret = bs->drv->bdrvmakeempty(bs); if (ret) { errorsetgerrno(&localerr, -ret, \"Could not empty %s\", filename); goto unrefbacking; } } unrefbacking: if (!drop) { bdrvunref(bs); } done: qemuprogressend(); blkunref(blk); if (localerr) { errorreporterr(localerr); return 1; } qprintf(quiet, \"Image committed.\\n\"); return 0; } ", "target": 0}
{"func": "unsigned long setupargpages(void * mh, char ** argv, char ** env) { unsigned long stackbase, error, size; int i; int * stack; int argc, envc; /* Create enough stack to hold everything. If we don't use * it for args, we'll use it for something else... */ size = stacksize; error = targetmmap(0, size + qemuhostpagesize, PROTREAD | PROTWRITE, MAPPRIVATE | MAPANONYMOUS, -1, 0); if (error == -1) qerror(\"stk mmap\"); /* we reserve one extra page at the top of the stack as guard */ targetmprotect(error + size, qemuhostpagesize, PROTNONE); stackbase = error + size; stack = (void*)stackbase; /* * | STRING AREA | * +-------------+ * | 0 | * +-------------+ * | apple[n] | * +-------------+ * : * +-------------+ * | apple[0] | * +-------------+ * | 0 | * +-------------+ * | env[n] | * +-------------+ * : * : * +-------------+ * | env[0] | * +-------------+ * | 0 | * +-------------+ * | arg[argc-1] | * +-------------+ * : * : * +-------------+ * | arg[0] | * +-------------+ * | argc | * +-------------+ * sp-> | mh | address of where the a.out's file offset 0 is in memory * +-------------+ */ /* Construct the stack Stack grows down */ stack--; /* XXX: string should go up there */ *stack = 0; stack--; /* Push the absolute path of our executable */ DPRINTF(\"pushing apple %s (0x%x)\\n\", (char*)argv[0], (int)argv[0]); stl(stack, (int) argv[0]); stack--; stl(stack, 0); stack--; /* Get envc */ for(envc = 0; env[envc]; envc++); for(i = envc-1; i >= 0; i--) { DPRINTF(\"pushing env %s (0x%x)\\n\", (char*)env[i], (int)env[i]); stl(stack, (int)env[i]); stack--; /* XXX: remove that when string will be on top of the stack */ pagesetflags((int)env[i], (int)(env[i]+strlen(env[i])), PROTREAD | PAGEVALID); } /* Add on the stack the interpprefix choosen if so */ if(interpprefix[0]) { char *dyldroot; asprintf(&dyldroot, \"DYLDROOTPATH=%s\", interpprefix); pagesetflags((int)dyldroot, (int)(dyldroot+strlen(interpprefix)+1), PROTREAD | PAGEVALID); stl(stack, (int)dyldroot); stack--; } #ifdef DONTUSEDYLDSHAREDMAP { char *sharedmapmode; asprintf(&sharedmapmode, \"DYLDSHAREDREGION=avoid\"); pagesetflags((int)sharedmapmode, (int)(sharedmapmode+strlen(sharedmapmode)+1), PROTREAD | PAGEVALID); stl(stack, (int)sharedmapmode); stack--; } #endif #ifdef ACTIVATEDYLDTRACE char * extraenvstatic[] = {\"DYLDDEBUGTRACE=yes\", \"DYLDPREBINDDEBUG=3\", \"DYLDUNKNOWTRACE=yes\", \"DYLDPRINTINITIALIZERS=yes\", \"DYLDPRINTSEGMENTS=yes\", \"DYLDPRINTREBASINGS=yes\", \"DYLDPRINTBINDINGS=yes\", \"DYLDPRINTINITIALIZERS=yes\", \"DYLDPRINTWARNINGS=yes\" }; char ** extraenv = malloc(sizeof(extraenvstatic)); bcopy(extraenvstatic, extraenv, sizeof(extraenvstatic)); pagesetflags((int)extraenv, (int)((void*)extraenv+sizeof(extraenvstatic)), PROTREAD | PAGEVALID); for(i = 0; i<9; i++) { DPRINTF(\"pushing (extra) env %s (0x%x)\\n\", (char*)extraenv[i], (int)extraenv[i]); stl(stack, (int) extraenv[i]); stack--; } #endif stl(stack, 0); stack--; /* Get argc */ for(argc = 0; argv[argc]; argc++); for(i = argc-1; i >= 0; i--) { DPRINTF(\"pushing arg %s (0x%x)\\n\", (char*)argv[i], (int)argv[i]); stl(stack, (int) argv[i]); stack--; /* XXX: remove that when string will be on top of the stack */ pagesetflags((int)argv[i], (int)(argv[i]+strlen(argv[i])), PROTREAD | PAGEVALID); } DPRINTF(\"pushing argc %d \\n\", argc); stl(stack, argc); stack--; DPRINTF(\"pushing mh 0x%x \\n\", (int)mh); stl(stack, (int) mh); /* Stack points on the mh */ return (unsigned long)stack; } ", "target": 0}
{"func": "int sddocommand(SDState *sd, SDRequest *req, uint8t *response) { uint32t laststatus = sd->cardstatus; sdrsptypet rtype; int rsplen; if (!sd->bdrv || !bdrvisinserted(sd->bdrv) || !sd->enable) { return 0; } if (sdreqcrcvalidate(req)) { sd->cardstatus |= COMCRCERROR; rtype = sdillegal; goto sendresponse; } sd->cardstatus &= ~CARDSTATUSB; sdsetstatus(sd); if (laststatus & CARDISLOCKED) { if (!cmdvalidwhilelocked(sd, req)) { sd->cardstatus |= ILLEGALCOMMAND; fprintf(stderr, \"SD: Card is locked\\n\"); rtype = sdillegal; goto sendresponse; } } if (laststatus & APPCMD) { rtype = sdappcommand(sd, *req); sd->cardstatus &= ~APPCMD; } else rtype = sdnormalcommand(sd, *req); if (rtype == sdillegal) { sd->cardstatus |= ILLEGALCOMMAND; } sd->currentcmd = req->cmd; sendresponse: switch (rtype) { case sdr1: case sdr1b: sdresponser1make(sd, response, laststatus); rsplen = 4; break; case sdr2i: memcpy(response, sd->cid, sizeof(sd->cid)); rsplen = 16; break; case sdr2s: memcpy(response, sd->csd, sizeof(sd->csd)); rsplen = 16; break; case sdr3: sdresponser3make(sd, response); rsplen = 4; break; case sdr6: sdresponser6make(sd, response); rsplen = 4; break; case sdr7: sdresponser7make(sd, response); rsplen = 4; break; case sdr0: case sdillegal: default: rsplen = 0; break; } #ifdef DEBUGSD if (rsplen) { int i; DPRINTF(\"Response:\"); for (i = 0; i < rsplen; i++) printf(\" %02x\", response[i]); printf(\" state %d\\n\", sd->state); } else { DPRINTF(\"No response %d\\n\", sd->state); } #endif return rsplen; } ", "target": 0}
{"func": "void cpux86cpuid(CPUX86State *env, uint32t index, uint32t count, uint32t *eax, uint32t *ebx, uint32t *ecx, uint32t *edx) { X86CPU *cpu = x86envgetcpu(env); CPUState *cs = CPU(cpu); uint32t pkgoffset; /* test if maximum index reached */ if (index & 0x80000000) { if (index > env->cpuidxlevel) { if (env->cpuidxlevel2 > 0) { /* Handle the Centaur's CPUID instruction. */ if (index > env->cpuidxlevel2) { index = env->cpuidxlevel2; } else if (index < 0xC0000000) { index = env->cpuidxlevel; } } else { /* Intel documentation states that invalid EAX input will * return the same information as EAX=cpuidlevel * (Intel SDM Vol. 2A - Instruction Set Reference - CPUID) */ index = env->cpuidlevel; } } } else { if (index > env->cpuidlevel) index = env->cpuidlevel; } switch(index) { case 0: *eax = env->cpuidlevel; *ebx = env->cpuidvendor1; *edx = env->cpuidvendor2; *ecx = env->cpuidvendor3; break; case 1: *eax = env->cpuidversion; *ebx = (cpu->apicid << 24) | 8 << 8; /* CLFLUSH size in quad words, Linux wants it. */ *ecx = env->features[FEAT1ECX]; if ((*ecx & CPUIDEXTXSAVE) && (env->cr[4] & CR4OSXSAVEMASK)) { *ecx |= CPUIDEXTOSXSAVE; } *edx = env->features[FEAT1EDX]; if (cs->nrcores * cs->nrthreads > 1) { *ebx |= (cs->nrcores * cs->nrthreads) << 16; *edx |= CPUIDHT; } break; case 2: /* cache info: needed for Pentium Pro compatibility */ if (cpu->cacheinfopassthrough) { hostcpuid(index, 0, eax, ebx, ecx, edx); break; } *eax = 1; /* Number of CPUID[EAX=2] calls required */ *ebx = 0; if (!cpu->enablel3cache) { *ecx = 0; } else { *ecx = L3NDESCRIPTOR; } *edx = (L1DDESCRIPTOR << 16) | \\ (L1IDESCRIPTOR << 8) | \\ (L2DESCRIPTOR); break; case 4: /* cache info: needed for Core compatibility */ if (cpu->cacheinfopassthrough) { hostcpuid(index, count, eax, ebx, ecx, edx); *eax &= ~0xFC000000; } else { *eax = 0; switch (count) { case 0: /* L1 dcache info */ *eax |= CPUID4TYPEDCACHE | \\ CPUID4LEVEL(1) | \\ CPUID4SELFINITLEVEL; *ebx = (L1DLINESIZE - 1) | \\ ((L1DPARTITIONS - 1) << 12) | \\ ((L1DASSOCIATIVITY - 1) << 22); *ecx = L1DSETS - 1; *edx = CPUID4NOINVDSHARING; break; case 1: /* L1 icache info */ *eax |= CPUID4TYPEICACHE | \\ CPUID4LEVEL(1) | \\ CPUID4SELFINITLEVEL; *ebx = (L1ILINESIZE - 1) | \\ ((L1IPARTITIONS - 1) << 12) | \\ ((L1IASSOCIATIVITY - 1) << 22); *ecx = L1ISETS - 1; *edx = CPUID4NOINVDSHARING; break; case 2: /* L2 cache info */ *eax |= CPUID4TYPEUNIFIED | \\ CPUID4LEVEL(2) | \\ CPUID4SELFINITLEVEL; if (cs->nrthreads > 1) { *eax |= (cs->nrthreads - 1) << 14; } *ebx = (L2LINESIZE - 1) | \\ ((L2PARTITIONS - 1) << 12) | \\ ((L2ASSOCIATIVITY - 1) << 22); *ecx = L2SETS - 1; *edx = CPUID4NOINVDSHARING; break; case 3: /* L3 cache info */ if (!cpu->enablel3cache) { *eax = 0; *ebx = 0; *ecx = 0; *edx = 0; break; } *eax |= CPUID4TYPEUNIFIED | \\ CPUID4LEVEL(3) | \\ CPUID4SELFINITLEVEL; pkgoffset = apicidpkgoffset(cs->nrcores, cs->nrthreads); *eax |= ((1 << pkgoffset) - 1) << 14; *ebx = (L3NLINESIZE - 1) | \\ ((L3NPARTITIONS - 1) << 12) | \\ ((L3NASSOCIATIVITY - 1) << 22); *ecx = L3NSETS - 1; *edx = CPUID4INCLUSIVE | CPUID4COMPLEXIDX; break; default: /* end of info */ *eax = 0; *ebx = 0; *ecx = 0; *edx = 0; break; } } /* QEMU gives out its own APIC IDs, never pass down bits 31..26. */ if ((*eax & 31) && cs->nrcores > 1) { *eax |= (cs->nrcores - 1) << 26; } break; case 5: /* mwait info: needed for Core compatibility */ *eax = 0; /* Smallest monitor-line size in bytes */ *ebx = 0; /* Largest monitor-line size in bytes */ *ecx = CPUIDMWAITEMX | CPUIDMWAITIBE; *edx = 0; break; case 6: /* Thermal and Power Leaf */ *eax = env->features[FEAT6EAX]; *ebx = 0; *ecx = 0; *edx = 0; break; case 7: /* Structured Extended Feature Flags Enumeration Leaf */ if (count == 0) { *eax = 0; /* Maximum ECX value for sub-leaves */ *ebx = env->features[FEAT70EBX]; /* Feature flags */ *ecx = env->features[FEAT70ECX]; /* Feature flags */ if ((*ecx & CPUID70ECXPKU) && env->cr[4] & CR4PKEMASK) { *ecx |= CPUID70ECXOSPKE; } *edx = 0; /* Reserved */ } else { *eax = 0; *ebx = 0; *ecx = 0; *edx = 0; } break; case 9: /* Direct Cache Access Information Leaf */ *eax = 0; /* Bits 0-31 in DCACAP MSR */ *ebx = 0; *ecx = 0; *edx = 0; break; case 0xA: /* Architectural Performance Monitoring Leaf */ if (kvmenabled() && cpu->enablepmu) { KVMState *s = cs->kvmstate; *eax = kvmarchgetsupportedcpuid(s, 0xA, count, REAX); *ebx = kvmarchgetsupportedcpuid(s, 0xA, count, REBX); *ecx = kvmarchgetsupportedcpuid(s, 0xA, count, RECX); *edx = kvmarchgetsupportedcpuid(s, 0xA, count, REDX); } else { *eax = 0; *ebx = 0; *ecx = 0; *edx = 0; } break; case 0xB: /* Extended Topology Enumeration Leaf */ if (!cpu->enablecpuid0xb) { *eax = *ebx = *ecx = *edx = 0; break; } *ecx = count & 0xff; *edx = cpu->apicid; switch (count) { case 0: *eax = apicidcoreoffset(cs->nrcores, cs->nrthreads); *ebx = cs->nrthreads; *ecx |= CPUIDTOPOLOGYLEVELSMT; break; case 1: *eax = apicidpkgoffset(cs->nrcores, cs->nrthreads); *ebx = cs->nrcores * cs->nrthreads; *ecx |= CPUIDTOPOLOGYLEVELCORE; break; default: *eax = 0; *ebx = 0; *ecx |= CPUIDTOPOLOGYLEVELINVALID; } assert(!(*eax & ~0x1f)); *ebx &= 0xffff; /* The count doesn't need to be reliable. */ break; case 0xD: { KVMState *s = cs->kvmstate; uint64t enamask; int i; /* Processor Extended State */ *eax = 0; *ebx = 0; *ecx = 0; *edx = 0; if (!(env->features[FEAT1ECX] & CPUIDEXTXSAVE)) { break; } if (kvmenabled()) { enamask = kvmarchgetsupportedcpuid(s, 0xd, 0, REDX); enamask <<= 32; enamask |= kvmarchgetsupportedcpuid(s, 0xd, 0, REAX); } else { enamask = -1; } if (count == 0) { *ecx = 0x240; for (i = 2; i < ARRAYSIZE(x86extsaveareas); i++) { const ExtSaveArea *esa = &x86extsaveareas[i]; if ((env->features[esa->feature] & esa->bits) == esa->bits && ((enamask >> i) & 1) != 0) { if (i < 32) { *eax |= 1u << i; } else { *edx |= 1u << (i - 32); } *ecx = MAX(*ecx, esa->offset + esa->size); } } *eax |= enamask & (XSTATEFPMASK | XSTATESSEMASK); *ebx = *ecx; } else if (count == 1) { *eax = env->features[FEATXSAVE]; } else if (count < ARRAYSIZE(x86extsaveareas)) { const ExtSaveArea *esa = &x86extsaveareas[count]; if ((env->features[esa->feature] & esa->bits) == esa->bits && ((enamask >> count) & 1) != 0) { *eax = esa->size; *ebx = esa->offset; } } break; } case 0x80000000: *eax = env->cpuidxlevel; *ebx = env->cpuidvendor1; *edx = env->cpuidvendor2; *ecx = env->cpuidvendor3; break; case 0x80000001: *eax = env->cpuidversion; *ebx = 0; *ecx = env->features[FEAT80000001ECX]; *edx = env->features[FEAT80000001EDX]; /* The Linux kernel checks for the CMPLegacy bit and * discards multiple thread information if it is set. * So don't set it here for Intel to make Linux guests happy. */ if (cs->nrcores * cs->nrthreads > 1) { if (env->cpuidvendor1 != CPUIDVENDORINTEL1 || env->cpuidvendor2 != CPUIDVENDORINTEL2 || env->cpuidvendor3 != CPUIDVENDORINTEL3) { *ecx |= 1 << 1; /* CmpLegacy bit */ } } break; case 0x80000002: case 0x80000003: case 0x80000004: *eax = env->cpuidmodel[(index - 0x80000002) * 4 + 0]; *ebx = env->cpuidmodel[(index - 0x80000002) * 4 + 1]; *ecx = env->cpuidmodel[(index - 0x80000002) * 4 + 2]; *edx = env->cpuidmodel[(index - 0x80000002) * 4 + 3]; break; case 0x80000005: /* cache info (L1 cache) */ if (cpu->cacheinfopassthrough) { hostcpuid(index, 0, eax, ebx, ecx, edx); break; } *eax = (L1DTLB2MASSOC << 24) | (L1DTLB2MENTRIES << 16) | \\ (L1ITLB2MASSOC << 8) | (L1ITLB2MENTRIES); *ebx = (L1DTLB4KASSOC << 24) | (L1DTLB4KENTRIES << 16) | \\ (L1ITLB4KASSOC << 8) | (L1ITLB4KENTRIES); *ecx = (L1DSIZEKBAMD << 24) | (L1DASSOCIATIVITYAMD << 16) | \\ (L1DLINESPERTAG << 8) | (L1DLINESIZE); *edx = (L1ISIZEKBAMD << 24) | (L1IASSOCIATIVITYAMD << 16) | \\ (L1ILINESPERTAG << 8) | (L1ILINESIZE); break; case 0x80000006: /* cache info (L2 cache) */ if (cpu->cacheinfopassthrough) { hostcpuid(index, 0, eax, ebx, ecx, edx); break; } *eax = (AMDENCASSOC(L2DTLB2MASSOC) << 28) | \\ (L2DTLB2MENTRIES << 16) | \\ (AMDENCASSOC(L2ITLB2MASSOC) << 12) | \\ (L2ITLB2MENTRIES); *ebx = (AMDENCASSOC(L2DTLB4KASSOC) << 28) | \\ (L2DTLB4KENTRIES << 16) | \\ (AMDENCASSOC(L2ITLB4KASSOC) << 12) | \\ (L2ITLB4KENTRIES); *ecx = (L2SIZEKBAMD << 16) | \\ (AMDENCASSOC(L2ASSOCIATIVITY) << 12) | \\ (L2LINESPERTAG << 8) | (L2LINESIZE); if (!cpu->enablel3cache) { *edx = ((L3SIZEKB / 512) << 18) | \\ (AMDENCASSOC(L3ASSOCIATIVITY) << 12) | \\ (L3LINESPERTAG << 8) | (L3LINESIZE); } else { *edx = ((L3NSIZEKBAMD / 512) << 18) | \\ (AMDENCASSOC(L3NASSOCIATIVITY) << 12) | \\ (L3NLINESPERTAG << 8) | (L3NLINESIZE); } break; case 0x80000007: *eax = 0; *ebx = 0; *ecx = 0; *edx = env->features[FEAT80000007EDX]; break; case 0x80000008: /* virtual & phys address size in low 2 bytes. */ if (env->features[FEAT80000001EDX] & CPUIDEXT2LM) { /* 64 bit processor, 48 bits virtual, configurable * physical bits. */ *eax = 0x00003000 + cpu->physbits; } else { *eax = cpu->physbits; } *ebx = 0; *ecx = 0; *edx = 0; if (cs->nrcores * cs->nrthreads > 1) { *ecx |= (cs->nrcores * cs->nrthreads) - 1; } break; case 0x8000000A: if (env->features[FEAT80000001ECX] & CPUIDEXT3SVM) { *eax = 0x00000001; /* SVM Revision */ *ebx = 0x00000010; /* nr of ASIDs */ *ecx = 0; *edx = env->features[FEATSVM]; /* optional features */ } else { *eax = 0; *ebx = 0; *ecx = 0; *edx = 0; } break; case 0xC0000000: *eax = env->cpuidxlevel2; *ebx = 0; *ecx = 0; *edx = 0; break; case 0xC0000001: /* Support for VIA CPU's CPUID instruction */ *eax = env->cpuidversion; *ebx = 0; *ecx = 0; *edx = env->features[FEATC0000001EDX]; break; case 0xC0000002: case 0xC0000003: case 0xC0000004: /* Reserved for the future, and now filled with zero */ *eax = 0; *ebx = 0; *ecx = 0; *edx = 0; break; default: /* reserved values: zero */ *eax = 0; *ebx = 0; *ecx = 0; *edx = 0; break; } } ", "target": 0}
{"func": "static void prepareapparguments(int *argcptr, char ***argvptr) { char *argstrflat; wchart **argvw; int i, buffsize = 0, offset = 0; if (win32argvutf8) { *argcptr = win32argc; *argvptr = win32argvutf8; return; } win32argc = 0; argvw = CommandLineToArgvW(GetCommandLineW(), &win32argc); if (win32argc <= 0 || !argvw) return; /* determine the UTF-8 buffer size (including NULL-termination symbols) */ for (i = 0; i < win32argc; i++) buffsize += WideCharToMultiByte(CPUTF8, 0, argvw[i], -1, NULL, 0, NULL, NULL); win32argvutf8 = avmallocz(sizeof(char *) * (win32argc + 1) + buffsize); argstrflat = (char *)win32argvutf8 + sizeof(char *) * (win32argc + 1); if (win32argvutf8 == NULL) { LocalFree(argvw); return; } for (i = 0; i < win32argc; i++) { win32argvutf8[i] = &argstrflat[offset]; offset += WideCharToMultiByte(CPUTF8, 0, argvw[i], -1, &argstrflat[offset], buffsize - offset, NULL, NULL); } win32argvutf8[i] = NULL; LocalFree(argvw); *argcptr = win32argc; *argvptr = win32argvutf8; } ", "target": 0}
{"func": "static inline void genneonaddlsaturate(TCGv op0, TCGv op1, int size) { switch (size) { case 1: genhelperneonaddlsaturates32(op0, cpuenv, op0, op1); break; case 2: genhelperneonaddlsaturates64(op0, cpuenv, op0, op1); break; default: abort(); } } ", "target": 0}
{"func": "int MP3lameencodeframe(AVCodecContext *avctx, unsigned char *frame, int bufsize, void *data) { \tMp3AudioContext *s = avctx->privdata; \tint num, i; //avlog(avctx, AVLOGDEBUG, \"%X %d %X\\n\", (int)frame, bufsize, (int)data); // if(data==NULL) // return lameencodeflush(s->gfp, frame, bufsize); \t/* lame 3.91 dies on '1-channel interleaved' data */ \tif (s->stereo) { \t\tnum = lameencodebufferinterleaved(s->gfp, data, \t\t\tMPAFRAMESIZE, frame, bufsize); \t} else { \t\tnum = lameencodebuffer(s->gfp, data, data, MPAFRAMESIZE, \t\t\tframe, bufsize); /*avlog(avctx, AVLOGDEBUG, \"in:%d out:%d\\n\", MPAFRAMESIZE, num); for(i=0; i<num; i++){ avlog(avctx, AVLOGDEBUG, \"%2X \", frame[i]); }*/ \t} \treturn num; } ", "target": 0}
{"func": "int qemuchrfereadall(CharDriverState *s, uint8t *buf, int len) { int offset = 0, counter = 10; int res; if (!s->chrsyncread) { return 0; } if (s->replay && replaymode == REPLAYMODEPLAY) { return replaycharreadallload(buf); } while (offset < len) { do { res = s->chrsyncread(s, buf + offset, len - offset); if (res == -1 && errno == EAGAIN) { gusleep(100); } } while (res == -1 && errno == EAGAIN); if (res == 0) { break; } if (res < 0) { if (s->replay && replaymode == REPLAYMODERECORD) { replaycharreadallsaveerror(res); } return res; } offset += res; if (!counter--) { break; } } if (s->replay && replaymode == REPLAYMODERECORD) { replaycharreadallsavebuf(buf, offset); } return offset; } ", "target": 1}
{"func": "static int decodebpicturesecondaryheader(VC9Context *v) { GetBitContext *gb = &v->s.gb; int status; bitplanedecoding(&v->skipmbplane, v); if (status < 0) return -1; #if TRACE if (v->mvmode == MVPMODEMIXEDMV) { status = bitplanedecoding(&v->mvtypembplane, v); if (status < 0) return -1; #if TRACE avlog(v->s.avctx, AVLOGDEBUG, \"MB MV Type plane encoding: \" \"Imode: %i, Invert: %i\\n\", status>>1, status&1); #endif } //bitplane status = bitplanedecoding(&v->directmbplane, v); if (status < 0) return -1; #if TRACE avlog(v->s.avctx, AVLOGDEBUG, \"MB Direct plane encoding: \" \"Imode: %i, Invert: %i\\n\", status>>1, status&1); #endif avlog(v->s.avctx, AVLOGDEBUG, \"Skip MB plane encoding: \" \"Imode: %i, Invert: %i\\n\", status>>1, status&1); #endif /* FIXME: what is actually chosen for B frames ? */ v->s.mvtableindex = getbits(gb, 2); //but using vc9 tables v->cbpcyvlc = &vc9cbpcypvlc[getbits(gb, 2)]; if (v->dquant) { vopdquantdecoding(v); } if (v->vstransform) { v->ttmbf = getbits(gb, 1); if (v->ttmbf) { v->ttfrm = getbits(gb, 2); avlog(v->s.avctx, AVLOGINFO, \"Transform used: %ix%i\\n\", (v->ttfrm & 2) ? 4 : 8, (v->ttfrm & 1) ? 4 : 8); } } /* Epilog (AC/DC syntax) should be done in caller */ return 0; } ", "target": 1}
{"func": "static int mxfgetstreamindex(AVFormatContext *s, KLVPacket *klv) { int i; for (i = 0; i < s->nbstreams; i++) { MXFTrack *track = s->streams[i]->privdata; /* SMPTE 379M 7.3 */ if (!memcmp(klv->key + sizeof(mxfessenceelementkey), track->tracknumber, sizeof(track->tracknumber))) return i; } /* return 0 if only one stream, for OP Atom files with 0 as track number */ return s->nbstreams == 1 ? 0 : -1; } ", "target": 1}
{"func": "static void vc1mc1mv(VC1Context *v, int dir) { MpegEncContext *s = &v->s; H264ChromaContext *h264chroma = &v->h264chroma; uint8t *srcY, *srcU, *srcV; int dxy, mx, my, uvmx, uvmy, srcx, srcy, uvsrcx, uvsrcy; int vedgepos = s->vedgepos >> v->fieldmode; int i; uint8t (*luty)[256], (*lutuv)[256]; int useic; if ((!v->fieldmode || (v->reffieldtype[dir] == 1 && v->curfieldtype == 1)) && !v->s.lastpicture.f.data[0]) return; mx = s->mv[dir][0][0]; my = s->mv[dir][0][1]; // store motion vectors for further use in B frames if (s->picttype == AVPICTURETYPEP) { for (i = 0; i < 4; i++) { s->currentpicture.motionval[1][s->blockindex[i] + v->blocksoff][0] = mx; s->currentpicture.motionval[1][s->blockindex[i] + v->blocksoff][1] = my; } } uvmx = (mx + ((mx & 3) == 3)) >> 1; uvmy = (my + ((my & 3) == 3)) >> 1; v->lumamv[s->mbx][0] = uvmx; v->lumamv[s->mbx][1] = uvmy; if (v->fieldmode && v->curfieldtype != v->reffieldtype[dir]) { my = my - 2 + 4 * v->curfieldtype; uvmy = uvmy - 2 + 4 * v->curfieldtype; } // fastuvmc shall be ignored for interlaced frame picture if (v->fastuvmc && (v->fcm != ILACEFRAME)) { uvmx = uvmx + ((uvmx < 0) ? (uvmx & 1) : -(uvmx & 1)); uvmy = uvmy + ((uvmy < 0) ? (uvmy & 1) : -(uvmy & 1)); } if (!dir) { if (v->fieldmode && (v->curfieldtype != v->reffieldtype[dir]) && v->secondfield) { srcY = s->currentpicture.f.data[0]; srcU = s->currentpicture.f.data[1]; srcV = s->currentpicture.f.data[2]; luty = v->currluty; lutuv = v->currlutuv; useic = v->curruseic; } else { srcY = s->lastpicture.f.data[0]; srcU = s->lastpicture.f.data[1]; srcV = s->lastpicture.f.data[2]; luty = v->lastluty; lutuv = v->lastlutuv; useic = v->lastuseic; } } else { srcY = s->nextpicture.f.data[0]; srcU = s->nextpicture.f.data[1]; srcV = s->nextpicture.f.data[2]; luty = v->nextluty; lutuv = v->nextlutuv; useic = v->nextuseic; } if (!srcY || !srcU) { avlog(v->s.avctx, AVLOGERROR, \"Referenced frame missing.\\n\"); return; } srcx = s->mbx * 16 + (mx >> 2); srcy = s->mby * 16 + (my >> 2); uvsrcx = s->mbx * 8 + (uvmx >> 2); uvsrcy = s->mby * 8 + (uvmy >> 2); if (v->profile != PROFILEADVANCED) { srcx = avclip( srcx, -16, s->mbwidth * 16); srcy = avclip( srcy, -16, s->mbheight * 16); uvsrcx = avclip(uvsrcx, -8, s->mbwidth * 8); uvsrcy = avclip(uvsrcy, -8, s->mbheight * 8); } else { srcx = avclip( srcx, -17, s->avctx->codedwidth); srcy = avclip( srcy, -18, s->avctx->codedheight + 1); uvsrcx = avclip(uvsrcx, -8, s->avctx->codedwidth >> 1); uvsrcy = avclip(uvsrcy, -8, s->avctx->codedheight >> 1); } srcY += srcy * s->linesize + srcx; srcU += uvsrcy * s->uvlinesize + uvsrcx; srcV += uvsrcy * s->uvlinesize + uvsrcx; if (v->fieldmode && v->reffieldtype[dir]) { srcY += s->currentpictureptr->f.linesize[0]; srcU += s->currentpictureptr->f.linesize[1]; srcV += s->currentpictureptr->f.linesize[2]; } /* for grayscale we should not try to read from unknown area */ if (s->flags & CODECFLAGGRAY) { srcU = s->edgeemubuffer + 18 * s->linesize; srcV = s->edgeemubuffer + 18 * s->linesize; } if (v->rangeredfrm || useic || s->hedgepos < 22 || vedgepos < 22 || (unsigned)(srcx - s->mspel) > s->hedgepos - (mx&3) - 16 - s->mspel * 3 || (unsigned)(srcy - 1) > vedgepos - (my&3) - 16 - 3) { uint8t *uvbuf = s->edgeemubuffer + 19 * s->linesize; srcY -= s->mspel * (1 + s->linesize); s->vdsp.emulatededgemc(s->edgeemubuffer, srcY, s->linesize, s->linesize, 17 + s->mspel * 2, 17 + s->mspel * 2, srcx - s->mspel, srcy - s->mspel, s->hedgepos, vedgepos); srcY = s->edgeemubuffer; s->vdsp.emulatededgemc(uvbuf, srcU, s->uvlinesize, s->uvlinesize, 8 + 1, 8 + 1, uvsrcx, uvsrcy, s->hedgepos >> 1, vedgepos >> 1); s->vdsp.emulatededgemc(uvbuf + 16, srcV, s->uvlinesize, s->uvlinesize, 8 + 1, 8 + 1, uvsrcx, uvsrcy, s->hedgepos >> 1, vedgepos >> 1); srcU = uvbuf; srcV = uvbuf + 16; /* if we deal with range reduction we need to scale source blocks */ if (v->rangeredfrm) { int i, j; uint8t *src, *src2; src = srcY; for (j = 0; j < 17 + s->mspel * 2; j++) { for (i = 0; i < 17 + s->mspel * 2; i++) src[i] = ((src[i] - 128) >> 1) + 128; src += s->linesize; } src = srcU; src2 = srcV; for (j = 0; j < 9; j++) { for (i = 0; i < 9; i++) { src[i] = ((src[i] - 128) >> 1) + 128; src2[i] = ((src2[i] - 128) >> 1) + 128; } src += s->uvlinesize; src2 += s->uvlinesize; } } /* if we deal with intensity compensation we need to scale source blocks */ if (useic) { int i, j; uint8t *src, *src2; src = srcY; for (j = 0; j < 17 + s->mspel * 2; j++) { int f = v->fieldmode ? v->reffieldtype[dir] : ((j + srcy - s->mspel) & 1) ; for (i = 0; i < 17 + s->mspel * 2; i++) src[i] = luty[f][src[i]]; src += s->linesize; } src = srcU; src2 = srcV; for (j = 0; j < 9; j++) { int f = v->fieldmode ? v->reffieldtype[dir] : ((j + uvsrcy) & 1); for (i = 0; i < 9; i++) { src[i] = lutuv[f][src[i]]; src2[i] = lutuv[f][src2[i]]; } src += s->uvlinesize; src2 += s->uvlinesize; } } srcY += s->mspel * (1 + s->linesize); } if (s->mspel) { dxy = ((my & 3) << 2) | (mx & 3); v->vc1dsp.putvc1mspelpixelstab[dxy](s->dest[0] , srcY , s->linesize, v->rnd); v->vc1dsp.putvc1mspelpixelstab[dxy](s->dest[0] + 8, srcY + 8, s->linesize, v->rnd); srcY += s->linesize * 8; v->vc1dsp.putvc1mspelpixelstab[dxy](s->dest[0] + 8 * s->linesize , srcY , s->linesize, v->rnd); v->vc1dsp.putvc1mspelpixelstab[dxy](s->dest[0] + 8 * s->linesize + 8, srcY + 8, s->linesize, v->rnd); } else { // hpel mc - always used for luma dxy = (my & 2) | ((mx & 2) >> 1); if (!v->rnd) s->hdsp.putpixelstab[0][dxy](s->dest[0], srcY, s->linesize, 16); else s->hdsp.putnorndpixelstab[0][dxy](s->dest[0], srcY, s->linesize, 16); } if (s->flags & CODECFLAGGRAY) return; /* Chroma MC always uses qpel bilinear */ uvmx = (uvmx & 3) << 1; uvmy = (uvmy & 3) << 1; if (!v->rnd) { h264chroma->puth264chromapixelstab[0](s->dest[1], srcU, s->uvlinesize, 8, uvmx, uvmy); h264chroma->puth264chromapixelstab[0](s->dest[2], srcV, s->uvlinesize, 8, uvmx, uvmy); } else { v->vc1dsp.putnorndvc1chromapixelstab[0](s->dest[1], srcU, s->uvlinesize, 8, uvmx, uvmy); v->vc1dsp.putnorndvc1chromapixelstab[0](s->dest[2], srcV, s->uvlinesize, 8, uvmx, uvmy); } } ", "target": 1}
{"func": "static inline void RENAME(yuy2ToUV)(uint8t *dstU, uint8t *dstV, uint8t *src1, uint8t *src2, int width) { #if defined (HAVEMMX2) || defined (HAVE3DNOW) \tasm volatile( \t\t\"movq \"MANGLE(bm01010101)\", %%mm4\\n\\t\" \t\t\"mov %0, %%\"REGa\"\t\t\\n\\t\" \t\t\"1:\t\t\t\t\\n\\t\" \t\t\"movq (%1, %%\"REGa\",4), %%mm0\t\\n\\t\" \t\t\"movq 8(%1, %%\"REGa\",4), %%mm1\t\\n\\t\" \t\t\"movq (%2, %%\"REGa\",4), %%mm2\t\\n\\t\" \t\t\"movq 8(%2, %%\"REGa\",4), %%mm3\t\\n\\t\" \t\tPAVGB(%%mm2, %%mm0) \t\tPAVGB(%%mm3, %%mm1) \t\t\"psrlw $8, %%mm0\t\t\\n\\t\" \t\t\"psrlw $8, %%mm1\t\t\\n\\t\" \t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\" \t\t\"movq %%mm0, %%mm1\t\t\\n\\t\" \t\t\"psrlw $8, %%mm0\t\t\\n\\t\" \t\t\"pand %%mm4, %%mm1\t\t\\n\\t\" \t\t\"packuswb %%mm0, %%mm0\t\t\\n\\t\" \t\t\"packuswb %%mm1, %%mm1\t\t\\n\\t\" \t\t\"movd %%mm0, (%4, %%\"REGa\")\t\\n\\t\" \t\t\"movd %%mm1, (%3, %%\"REGa\")\t\\n\\t\" \t\t\"add $4, %%\"REGa\"\t\t\\n\\t\" \t\t\" js 1b\t\t\t\t\\n\\t\" \t\t: : \"g\" ((long)-width), \"r\" (src1+width*4), \"r\" (src2+width*4), \"r\" (dstU+width), \"r\" (dstV+width) \t\t: \"%\"REGa \t); #else \tint i; \tfor(i=0; i<width; i++) \t{ \t\tdstU[i]= (src1[4*i + 1] + src2[4*i + 1])>>1; \t\tdstV[i]= (src1[4*i + 3] + src2[4*i + 3])>>1; \t} #endif } ", "target": 1}
{"func": "static int mtvreadheader(AVFormatContext *s) { MTVDemuxContext *mtv = s->privdata; AVIOContext *pb = s->pb; AVStream *st; unsigned int audiosubsegments; avioskip(pb, 3); mtv->filesize = aviorl32(pb); mtv->segments = aviorl32(pb); avioskip(pb, 32); mtv->audioidentifier = aviorl24(pb); mtv->audiobr = aviorl16(pb); mtv->imgcolorfmt = aviorl24(pb); mtv->imgbpp = avior8(pb); mtv->imgwidth = aviorl16(pb); mtv->imgheight = aviorl16(pb); mtv->imgsegmentsize = aviorl16(pb); /* Calculate width and height if missing from header */ if(mtv->imgbpp>>3){ if(!mtv->imgwidth && mtv->imgheight) mtv->imgwidth=mtv->imgsegmentsize / (mtv->imgbpp>>3) / mtv->imgheight; if(!mtv->imgheight && mtv->imgwidth) mtv->imgheight=mtv->imgsegmentsize / (mtv->imgbpp>>3) / mtv->imgwidth; } if(!mtv->imgheight || !mtv->imgwidth || !mtv->imgsegmentsize){ avlog(s, AVLOGERROR, \"width or height or segmentsize is invalid and I cannot calculate them from other information\\n\"); return AVERROR(EINVAL); } avioskip(pb, 4); audiosubsegments = aviorl16(pb); if (audiosubsegments == 0) { avprivrequestsample(s, \"MTV files without audio\"); return AVERRORPATCHWELCOME; } mtv->fullsegmentsize = audiosubsegments * (MTVAUDIOPADDINGSIZE + MTVASUBCHUNKDATASIZE) + mtv->imgsegmentsize; mtv->videofps = (mtv->audiobr / 4) / audiosubsegments; // FIXME Add sanity check here // all systems go! init decoders // video - raw rgb565 st = avformatnewstream(s, NULL); if(!st) return AVERROR(ENOMEM); avprivsetptsinfo(st, 64, 1, mtv->videofps); st->codec->codectype = AVMEDIATYPEVIDEO; st->codec->codecid = AVCODECIDRAWVIDEO; st->codec->pixfmt = AVPIXFMTRGB565BE; st->codec->width = mtv->imgwidth; st->codec->height = mtv->imgheight; st->codec->samplerate = mtv->videofps; st->codec->extradata = avstrdup(\"BottomUp\"); st->codec->extradatasize = 9; // audio - mp3 st = avformatnewstream(s, NULL); if(!st) return AVERROR(ENOMEM); avprivsetptsinfo(st, 64, 1, AUDIOSAMPLINGRATE); st->codec->codectype = AVMEDIATYPEAUDIO; st->codec->codecid = AVCODECIDMP3; st->codec->bitrate = mtv->audiobr; st->needparsing = AVSTREAMPARSEFULL; // Jump over header if(avioseek(pb, MTVHEADERSIZE, SEEKSET) != MTVHEADERSIZE) return AVERROR(EIO); return 0; } ", "target": 0}
{"func": "static bool qhtinsertlocked(struct qht *ht, struct qhtmap *map, struct qhtbucket *head, void *p, uint32t hash, bool *needsresize) { struct qhtbucket *b = head; struct qhtbucket *prev = NULL; struct qhtbucket *new = NULL; int i; do { for (i = 0; i < QHTBUCKETENTRIES; i++) { if (b->pointers[i]) { if (unlikely(b->pointers[i] == p)) { return false; } } else { goto found; } } prev = b; b = b->next; } while (b); b = qemumemalign(QHTBUCKETALIGN, sizeof(*b)); memset(b, 0, sizeof(*b)); new = b; i = 0; atomicinc(&map->naddedbuckets); if (unlikely(qhtmapneedsresize(map)) && needsresize) { *needsresize = true; } found: /* found an empty key: acquire the seqlock and write */ seqlockwritebegin(&head->sequence); if (new) { atomicrcuset(&prev->next, b); } b->hashes[i] = hash; /* smpwmb() implicit in seqlockwritebegin. */ atomicset(&b->pointers[i], p); seqlockwriteend(&head->sequence); return true; } ", "target": 1}
{"func": "static int copypacketdata(AVPacket *pkt, AVPacket *src, int dup) { pkt->data = NULL; pkt->sidedata = NULL; if (pkt->buf) { AVBufferRef *ref = avbufferref(src->buf); if (!ref) return AVERROR(ENOMEM); pkt->buf = ref; pkt->data = ref->data; } else { DUPDATA(pkt->data, src->data, pkt->size, 1, ALLOCBUF); } #if FFAPIDESTRUCTPACKET FFDISABLEDEPRECATIONWARNINGS pkt->destruct = dummydestructpacket; FFENABLEDEPRECATIONWARNINGS #endif if (pkt->sidedataelems && dup) pkt->sidedata = src->sidedata; if (pkt->sidedataelems && !dup) { return avcopypacketsidedata(pkt, src); } return 0; failedalloc: avdestructpacket(pkt); return AVERROR(ENOMEM); } ", "target": 1}
{"func": "static void virtiocryptoinstanceinit(Object *obj) { VirtIOCrypto *vcrypto = VIRTIOCRYPTO(obj); /* * The default configsize is sizeof(struct virtiocryptoconfig). * Can be overriden with virtiocryptosetconfigsize. */ vcrypto->configsize = sizeof(struct virtiocryptoconfig); objectpropertyaddlink(obj, \"cryptodev\", TYPECRYPTODEVBACKEND, (Object **)&vcrypto->conf.cryptodev, virtiocryptocheckcryptodevisused, OBJPROPLINKUNREFONRELEASE, NULL); } ", "target": 0}
{"func": "int cpush4handlemmufault(CPUState * env, targetulong address, int rw, \t\t\t int mmuidx, int issoftmmu) { targetulong physical; int prot, ret, accesstype; accesstype = ACCESSINT; ret = \tgetphysicaladdress(env, &physical, &prot, address, rw, \t\t\t accesstype); if (ret != MMUOK) { \tenv->tea = address; \tswitch (ret) { \tcase MMUITLBMISS: \tcase MMUDTLBMISSREAD: \t env->exceptionindex = 0x040; \t break; \tcase MMUDTLBMULTIPLE: \tcase MMUITLBMULTIPLE: \t env->exceptionindex = 0x140; \t break; \tcase MMUITLBVIOLATION: \t env->exceptionindex = 0x0a0; \t break; \tcase MMUDTLBMISSWRITE: \t env->exceptionindex = 0x060; \t break; \tcase MMUDTLBINITIALWRITE: \t env->exceptionindex = 0x080; \t break; \tcase MMUDTLBVIOLATIONREAD: \t env->exceptionindex = 0x0a0; \t break; \tcase MMUDTLBVIOLATIONWRITE: \t env->exceptionindex = 0x0c0; \t break; \tcase MMUIADDRERROR: \tcase MMUDADDRERRORREAD: \t env->exceptionindex = 0x0c0; \t break; \tcase MMUDADDRERRORWRITE: \t env->exceptionindex = 0x100; \t break; \tdefault: \t assert(0); \t} \treturn 1; } address &= TARGETPAGEMASK; physical &= TARGETPAGEMASK; return tlbsetpage(env, address, physical, prot, mmuidx, issoftmmu); } ", "target": 0}
{"func": "static int virtioblkdeviceexit(DeviceState *dev) { VirtIODevice *vdev = VIRTIODEVICE(dev); VirtIOBlock *s = VIRTIOBLK(dev); #ifdef CONFIGVIRTIOBLKDATAPLANE removemigrationstatechangenotifier(&s->migrationstatenotifier); virtioblkdataplanedestroy(s->dataplane); s->dataplane = NULL; #endif qemudelvmchangestatehandler(s->change); unregistersavevm(dev, \"virtio-blk\", s); blockdevmarkautodel(s->bs); virtiocleanup(vdev); return 0; } ", "target": 1}
{"func": "static void pcdimmgetsize(Object *obj, Visitor *v, const char *name, void *opaque, Error **errp) { uint64t value; MemoryRegion *mr; PCDIMMDevice *dimm = PCDIMM(obj); PCDIMMDeviceClass *ddc = PCDIMMGETCLASS(obj); mr = ddc->getmemoryregion(dimm); value = memoryregionsize(mr); visittypeuint64(v, name, &value, errp); } ", "target": 1}
{"func": "targetulong spaprrtascall(sPAPREnvironment *spapr, uint32t token, uint32t nargs, targetulong args, uint32t nret, targetulong rets) { if ((token >= TOKENBASE) && ((token - TOKENBASE) < TOKENMAX)) { struct rtascall *call = rtastable + (token - TOKENBASE); if (call->fn) { call->fn(spapr, token, nargs, args, nret, rets); hcalldprintf(\"Unknown RTAS token 0x%x\\n\", token); rtasst(rets, 0, -3); return HPARAMETER;", "target": 1}
{"func": "static int32t scsisendcommand(SCSIRequest *req, uint8t *cmd) { SCSIGenericState *s = DOUPCAST(SCSIGenericState, qdev, req->dev); SCSIGenericReq *r = DOUPCAST(SCSIGenericReq, req, req); int ret; if (cmd[0] != REQUESTSENSE && req->lun != s->qdev.lun) { DPRINTF(\"Unimplemented LUN %d\\n\", req->lun); scsireqbuildsense(&r->req, SENSECODE(LUNNOTSUPPORTED)); scsireqcomplete(&r->req, CHECKCONDITION); return 0; } if (-1 == scsireqparse(&r->req, cmd)) { BADF(\"Unsupported command length, command %x\\n\", cmd[0]); scsicommandcomplete(r, -EINVAL); return 0; } scsireqfixup(&r->req); DPRINTF(\"Command: lun=%d tag=0x%x len %zd data=0x%02x\", lun, tag, r->req.cmd.xfer, cmd[0]); #ifdef DEBUGSCSI { int i; for (i = 1; i < r->req.cmd.len; i++) { printf(\" 0x%02x\", cmd[i]); } printf(\"\\n\"); } #endif if (r->req.cmd.xfer == 0) { if (r->buf != NULL) qemufree(r->buf); r->buflen = 0; r->buf = NULL; ret = executecommand(s->bs, r, SGDXFERNONE, scsicommandcomplete); if (ret < 0) { scsicommandcomplete(r, ret); return 0; } return 0; } if (r->buflen != r->req.cmd.xfer) { if (r->buf != NULL) qemufree(r->buf); r->buf = qemumalloc(r->req.cmd.xfer); r->buflen = r->req.cmd.xfer; } memset(r->buf, 0, r->buflen); r->len = r->req.cmd.xfer; if (r->req.cmd.mode == SCSIXFERTODEV) { r->len = 0; return -r->req.cmd.xfer; } else { return r->req.cmd.xfer; } } ", "target": 0}
{"func": "void ip6input(struct mbuf *m) { struct ip6 *ip6; DEBUGCALL(\"ip6input\"); DEBUGARG(\"m = %lx\", (long)m); DEBUGARG(\"mlen = %d\", m->mlen); if (m->mlen < sizeof(struct ip6)) { goto bad; } ip6 = mtod(m, struct ip6 *); if (ip6->ipv != IP6VERSION) { goto bad; } /* check ipttl for a correct ICMP reply */ if (ip6->iphl == 0) { /*icmpsenderror(m, ICMPTIMXCEED,ICMPTIMXCEEDINTRANS, 0,\"ttl\");*/ goto bad; } /* * Switch out to protocol's input routine. */ switch (ip6->ipnh) { case IPPROTOTCP: /*tcpinput(m, hlen, (struct socket *)NULL);*/ break; case IPPROTOUDP: /*udpinput(m, hlen);*/ break; case IPPROTOICMPV6: icmp6input(m); break; default: mfree(m); } return; bad: mfree(m); } ", "target": 0}
{"func": "void forkstart(void) { pthreadmutexlock(&tcgctx.tbctx.tblock); pthreadmutexlock(&exclusivelock); mmapforkstart(); } ", "target": 0}
{"func": "static int writedumppages(DumpState *s) { int ret = 0; DataCache pagedesc, pagedata; sizet lenbufout, sizeout; #ifdef CONFIGLZO lzobytep wrkmem = NULL; #endif uint8t *bufout = NULL; offt offsetdesc, offsetdata; PageDescriptor pd, pdzero; uint8t *buf; int endian = s->dumpinfo.dendian; GuestPhysBlock *blockiter = NULL; uint64t pfniter; /* get offset of pagedesc and pagedata in dump file */ offsetdesc = s->offsetpage; offsetdata = offsetdesc + sizeof(PageDescriptor) * s->numdumpable; preparedatacache(&pagedesc, s, offsetdesc); preparedatacache(&pagedata, s, offsetdata); /* prepare buffer to store compressed data */ lenbufout = getlenbufout(s->pagesize, s->flagcompress); if (lenbufout == 0) { dumperror(s, \"dump: failed to get length of output buffer.\\n\"); goto out; } #ifdef CONFIGLZO wrkmem = gmalloc(LZO1X1MEMCOMPRESS); #endif bufout = gmalloc(lenbufout); /* * init zero page's pagedesc and pagedata, because every zero page * uses the same pagedata */ pdzero.size = cpuconverttotarget32(s->pagesize, endian); pdzero.flags = cpuconverttotarget32(0, endian); pdzero.offset = cpuconverttotarget64(offsetdata, endian); pdzero.pageflags = cpuconverttotarget64(0, endian); buf = gmalloc0(s->pagesize); ret = writecache(&pagedata, buf, s->pagesize, false); gfree(buf); if (ret < 0) { dumperror(s, \"dump: failed to write page data(zero page).\\n\"); goto out; } offsetdata += s->pagesize; /* * dump memory to vmcore page by page. zero page will all be resided in the * first page of page section */ while (getnextpage(&blockiter, &pfniter, &buf, s)) { /* check zero page */ if (iszeropage(buf, s->pagesize)) { ret = writecache(&pagedesc, &pdzero, sizeof(PageDescriptor), false); if (ret < 0) { dumperror(s, \"dump: failed to write page desc.\\n\"); goto out; } } else { /* * not zero page, then: * 1. compress the page * 2. write the compressed page into the cache of pagedata * 3. get page desc of the compressed page and write it into the * cache of pagedesc * * only one compression format will be used here, for * s->flagcompress is set. But when compression fails to work, * we fall back to save in plaintext. */ sizeout = lenbufout; if ((s->flagcompress & DUMPDHCOMPRESSEDZLIB) && (compress2(bufout, (uLongf *)&sizeout, buf, s->pagesize, ZBESTSPEED) == ZOK) && (sizeout < s->pagesize)) { pd.flags = cpuconverttotarget32(DUMPDHCOMPRESSEDZLIB, endian); pd.size = cpuconverttotarget32(sizeout, endian); ret = writecache(&pagedata, bufout, sizeout, false); if (ret < 0) { dumperror(s, \"dump: failed to write page data.\\n\"); goto out; } #ifdef CONFIGLZO } else if ((s->flagcompress & DUMPDHCOMPRESSEDLZO) && (lzo1x1compress(buf, s->pagesize, bufout, (lzouint *)&sizeout, wrkmem) == LZOEOK) && (sizeout < s->pagesize)) { pd.flags = cpuconverttotarget32(DUMPDHCOMPRESSEDLZO, endian); pd.size = cpuconverttotarget32(sizeout, endian); ret = writecache(&pagedata, bufout, sizeout, false); if (ret < 0) { dumperror(s, \"dump: failed to write page data.\\n\"); goto out; } #endif #ifdef CONFIGSNAPPY } else if ((s->flagcompress & DUMPDHCOMPRESSEDSNAPPY) && (snappycompress((char *)buf, s->pagesize, (char *)bufout, &sizeout) == SNAPPYOK) && (sizeout < s->pagesize)) { pd.flags = cpuconverttotarget32( DUMPDHCOMPRESSEDSNAPPY, endian); pd.size = cpuconverttotarget32(sizeout, endian); ret = writecache(&pagedata, bufout, sizeout, false); if (ret < 0) { dumperror(s, \"dump: failed to write page data.\\n\"); goto out; } #endif } else { /* * fall back to save in plaintext, sizeout should be * assigned to s->pagesize */ pd.flags = cpuconverttotarget32(0, endian); sizeout = s->pagesize; pd.size = cpuconverttotarget32(sizeout, endian); ret = writecache(&pagedata, buf, s->pagesize, false); if (ret < 0) { dumperror(s, \"dump: failed to write page data.\\n\"); goto out; } } /* get and write page desc here */ pd.pageflags = cpuconverttotarget64(0, endian); pd.offset = cpuconverttotarget64(offsetdata, endian); offsetdata += sizeout; ret = writecache(&pagedesc, &pd, sizeof(PageDescriptor), false); if (ret < 0) { dumperror(s, \"dump: failed to write page desc.\\n\"); goto out; } } } ret = writecache(&pagedesc, NULL, 0, true); if (ret < 0) { dumperror(s, \"dump: failed to sync cache for pagedesc.\\n\"); goto out; } ret = writecache(&pagedata, NULL, 0, true); if (ret < 0) { dumperror(s, \"dump: failed to sync cache for pagedata.\\n\"); goto out; } out: freedatacache(&pagedesc); freedatacache(&pagedata); #ifdef CONFIGLZO gfree(wrkmem); #endif gfree(bufout); return ret; } ", "target": 0}
{"func": "static void doextinterrupt(CPUS390XState *env) { S390CPU *cpu = s390envgetcpu(env); uint64t mask, addr; LowCore *lowcore; ExtQueue *q; if (!(env->psw.mask & PSWMASKEXT)) { cpuabort(CPU(cpu), \"Ext int w/o ext mask\\n\"); } lowcore = cpumaplowcore(env); if (env->pendingint & INTERRUPTEXTCLOCKCOMPARATOR) { lowcore->extintcode = cputobe16(EXTCLOCKCOMP); lowcore->cpuaddr = 0; env->pendingint &= ~INTERRUPTEXTCLOCKCOMPARATOR; } else if (env->pendingint & INTERRUPTEXTCPUTIMER) { lowcore->extintcode = cputobe16(EXTCPUTIMER); lowcore->cpuaddr = 0; env->pendingint &= ~INTERRUPTEXTCPUTIMER; } else if (env->pendingint & INTERRUPTEXTSERVICE) { gassert(env->extindex >= 0); /* * FIXME: floating IRQs should be considered by all CPUs and * shuld not get cleared by CPU reset. */ q = &env->extqueue[env->extindex]; lowcore->extintcode = cputobe16(q->code); lowcore->extparams = cputobe32(q->param); lowcore->extparams2 = cputobe64(q->param64); lowcore->cpuaddr = cputobe16(env->coreid | VIRTIOSUBCODE64); env->extindex--; if (env->extindex == -1) { env->pendingint &= ~INTERRUPTEXTSERVICE; } } else { gassertnotreached(); } mask = be64tocpu(lowcore->externalnewpsw.mask); addr = be64tocpu(lowcore->externalnewpsw.addr); lowcore->externaloldpsw.mask = cputobe64(getpswmask(env)); lowcore->externaloldpsw.addr = cputobe64(env->psw.addr); cpuunmaplowcore(lowcore); DPRINTF(\"%s: %\" PRIx64 \" %\" PRIx64 \"\\n\", func, env->psw.mask, env->psw.addr); loadpsw(env, mask, addr); } ", "target": 0}
{"func": "static void verdexinit(MachineState *machine) { const char *cpumodel = machine->cpumodel; PXA2xxState *cpu; DriveInfo *dinfo; int be; MemoryRegion *addressspacemem = getsystemmemory(); uint32t verdexrom = 0x02000000; uint32t verdexram = 0x10000000; cpu = pxa270init(addressspacemem, verdexram, cpumodel ?: \"pxa270-c0\"); dinfo = driveget(IFPFLASH, 0, 0); if (!dinfo && !qtestenabled()) { fprintf(stderr, \"A flash image must be given with the \" \"'pflash' parameter\\n\"); exit(1); } #ifdef TARGETWORDSBIGENDIAN be = 1; #else be = 0; #endif if (!pflashcfi01register(0x00000000, NULL, \"verdex.rom\", verdexrom, dinfo ? blkbs(blkbylegacydinfo(dinfo)) : NULL, sectorlen, verdexrom / sectorlen, 2, 0, 0, 0, 0, be)) { fprintf(stderr, \"qemu: Error registering flash memory.\\n\"); exit(1); } /* Interrupt line of NIC is connected to GPIO line 99 */ smc91c111init(&ndtable[0], 0x04000300, qdevgetgpioin(cpu->gpio, 99)); } ", "target": 0}
{"func": "static int bochsopen(BlockDriverState *bs, QDict *options, int flags, Error **errp) { BDRVBochsState *s = bs->opaque; uint32t i; struct bochsheader bochs; int ret; bs->readonly = 1; // no write support yet ret = bdrvpread(bs->file, 0, &bochs, sizeof(bochs)); if (ret < 0) { return ret; if (strcmp(bochs.magic, HEADERMAGIC) || strcmp(bochs.type, REDOLOGTYPE) || strcmp(bochs.subtype, GROWINGTYPE) || \t((le32tocpu(bochs.version) != HEADERVERSION) && \t(le32tocpu(bochs.version) != HEADERV1))) { errorsetg(errp, \"Image not in Bochs format\"); return -EINVAL; if (le32tocpu(bochs.version) == HEADERV1) { bs->totalsectors = le64tocpu(bochs.extra.redologv1.disk) / 512; } else { bs->totalsectors = le64tocpu(bochs.extra.redolog.disk) / 512; s->catalogsize = le32tocpu(bochs.catalog); s->catalogbitmap = gmalloc(s->catalogsize * 4); ret = bdrvpread(bs->file, le32tocpu(bochs.header), s->catalogbitmap, s->catalogsize * 4); if (ret < 0) { goto fail; for (i = 0; i < s->catalogsize; i++) \tle32tocpus(&s->catalogbitmap[i]); s->dataoffset = le32tocpu(bochs.header) + (s->catalogsize * 4); s->bitmapblocks = 1 + (le32tocpu(bochs.bitmap) - 1) / 512; s->extentblocks = 1 + (le32tocpu(bochs.extent) - 1) / 512; s->extentsize = le32tocpu(bochs.extent); if (s->catalogsize < bs->totalsectors / s->extentsize) { errorsetg(errp, \"Catalog size is too small for this disk size\"); ret = -EINVAL; goto fail; qemucomutexinit(&s->lock); return 0; fail: gfree(s->catalogbitmap); return ret;", "target": 1}
{"func": "offsett urlfseek(ByteIOContext *s, offsett offset, int whence) { offsett offset1; offsett pos= s->pos - (s->writeflag ? 0 : (s->bufend - s->buffer)); if (whence != SEEKCUR && whence != SEEKSET) return -EINVAL; if (whence == SEEKCUR) { offset1 = pos + (s->bufptr - s->buffer); if (offset == 0) return offset1; offset += offset1; } offset1 = offset - pos; if (!s->mustflush && offset1 >= 0 && offset1 < (s->bufend - s->buffer)) { /* can do the seek inside the buffer */ s->bufptr = s->buffer + offset1; } else { if (!s->seek) return -EPIPE; #ifdef CONFIGMUXERS if (s->writeflag) { flushbuffer(s); s->mustflush = 1; } else #endif //CONFIGMUXERS { s->bufend = s->buffer; } s->bufptr = s->buffer; if (s->seek(s->opaque, offset, SEEKSET) == (offsett)-EPIPE) return -EPIPE; s->pos = offset; } s->eofreached = 0; return offset; } ", "target": 1}
{"func": "void ppctranslateinit(void) { int i; char* p; sizet cpuregnamessize; static int doneinit = 0; if (doneinit) return; cpuenv = tcgglobalregnewptr(TCGAREG0, \"env\"); p = cpuregnames; cpuregnamessize = sizeof(cpuregnames); for (i = 0; i < 8; i++) { snprintf(p, cpuregnamessize, \"crf%d\", i); cpucrf[i] = tcgglobalmemnewi32(TCGAREG0, offsetof(CPUState, crf[i]), p); p += 5; cpuregnamessize -= 5; } for (i = 0; i < 32; i++) { snprintf(p, cpuregnamessize, \"r%d\", i); cpugpr[i] = tcgglobalmemnew(TCGAREG0, offsetof(CPUState, gpr[i]), p); p += (i < 10) ? 3 : 4; cpuregnamessize -= (i < 10) ? 3 : 4; #if !defined(TARGETPPC64) snprintf(p, cpuregnamessize, \"r%dH\", i); cpugprh[i] = tcgglobalmemnewi32(TCGAREG0, offsetof(CPUState, gprh[i]), p); p += (i < 10) ? 4 : 5; cpuregnamessize -= (i < 10) ? 4 : 5; #endif snprintf(p, cpuregnamessize, \"fp%d\", i); cpufpr[i] = tcgglobalmemnewi64(TCGAREG0, offsetof(CPUState, fpr[i]), p); p += (i < 10) ? 4 : 5; cpuregnamessize -= (i < 10) ? 4 : 5; snprintf(p, cpuregnamessize, \"avr%dH\", i); #ifdef HOSTWORDSBIGENDIAN cpuavrh[i] = tcgglobalmemnewi64(TCGAREG0, offsetof(CPUState, avr[i].u64[0]), p); #else cpuavrh[i] = tcgglobalmemnewi64(TCGAREG0, offsetof(CPUState, avr[i].u64[1]), p); #endif p += (i < 10) ? 6 : 7; cpuregnamessize -= (i < 10) ? 6 : 7; snprintf(p, cpuregnamessize, \"avr%dL\", i); #ifdef HOSTWORDSBIGENDIAN cpuavrl[i] = tcgglobalmemnewi64(TCGAREG0, offsetof(CPUState, avr[i].u64[1]), p); #else cpuavrl[i] = tcgglobalmemnewi64(TCGAREG0, offsetof(CPUState, avr[i].u64[0]), p); #endif p += (i < 10) ? 6 : 7; cpuregnamessize -= (i < 10) ? 6 : 7; } cpunip = tcgglobalmemnew(TCGAREG0, offsetof(CPUState, nip), \"nip\"); cpumsr = tcgglobalmemnew(TCGAREG0, offsetof(CPUState, msr), \"msr\"); cpuctr = tcgglobalmemnew(TCGAREG0, offsetof(CPUState, ctr), \"ctr\"); cpulr = tcgglobalmemnew(TCGAREG0, offsetof(CPUState, lr), \"lr\"); cpuxer = tcgglobalmemnew(TCGAREG0, offsetof(CPUState, xer), \"xer\"); cpureserve = tcgglobalmemnew(TCGAREG0, offsetof(CPUState, reserve), \"reserve\"); cpufpscr = tcgglobalmemnewi32(TCGAREG0, offsetof(CPUState, fpscr), \"fpscr\"); cpuaccesstype = tcgglobalmemnewi32(TCGAREG0, offsetof(CPUState, accesstype), \"accesstype\"); /* register helpers */ #define GENHELPER 2 #include \"helper.h\" doneinit = 1; } ", "target": 0}
{"func": "static void genmtfsfi(DisasContext *ctx) { int bf, sh; TCGvi64 t0; TCGvi32 t1; if (unlikely(!ctx->fpuenabled)) { genexception(ctx, POWERPCEXCPFPU); return; } bf = crbD(ctx->opcode) >> 2; sh = 7 - bf; /* NIP cannot be restored if the memory exception comes from an helper */ genupdatenip(ctx, ctx->nip - 4); genresetfpstatus(); t0 = tcgconsti64(FPIMM(ctx->opcode) << (4 * sh)); t1 = tcgconsti32(1 << sh); genhelperstorefpscr(cpuenv, t0, t1); tcgtempfreei64(t0); tcgtempfreei32(t1); if (unlikely(Rc(ctx->opcode) != 0)) { tcggentrunctli32(cpucrf[1], cpufpscr); tcggenshrii32(cpucrf[1], cpucrf[1], FPSCROX); } /* We can raise a differed exception */ genhelperfloatcheckstatus(cpuenv); } ", "target": 0}
{"func": "void osmemprealloc(int fd, char *area, sizet memory, Error **errp) { int i; sizet pagesize = getpagesize(); memory = (memory + pagesize - 1) & -pagesize; for (i = 0; i < memory / pagesize; i++) { memset(area + pagesize * i, 0, 1); } } ", "target": 1}
{"func": "static int cuviddecodeframe(AVCodecContext *avctx, void *data, int *gotframe, AVPacket *avpkt) { CuvidContext *ctx = avctx->privdata; AVHWDeviceContext *devicectx = (AVHWDeviceContext*)ctx->hwdevice->data; AVCUDADeviceContext *devicehwctx = devicectx->hwctx; CUcontext dummy, cudactx = devicehwctx->cudactx; AVFrame *frame = data; CUVIDSOURCEDATAPACKET cupkt; AVPacket filterpacket = { 0 }; AVPacket filteredpacket = { 0 }; CUdeviceptr mappedframe = 0; int ret = 0, eret = 0; if (ctx->bsf && avpkt->size) { if ((ret = avpacketref(&filterpacket, avpkt)) < 0) { avlog(avctx, AVLOGERROR, \"avpacketref failed\\n\"); return ret; } if ((ret = avbsfsendpacket(ctx->bsf, &filterpacket)) < 0) { avlog(avctx, AVLOGERROR, \"avbsfsendpacket failed\\n\"); avpacketunref(&filterpacket); return ret; } if ((ret = avbsfreceivepacket(ctx->bsf, &filteredpacket)) < 0) { avlog(avctx, AVLOGERROR, \"avbsfreceivepacket failed\\n\"); return ret; } avpkt = &filteredpacket; } ret = CHECKCU(cuCtxPushCurrent(cudactx)); if (ret < 0) { avpacketunref(&filteredpacket); return ret; } memset(&cupkt, 0, sizeof(cupkt)); if (avpkt->size) { cupkt.payloadsize = avpkt->size; cupkt.payload = avpkt->data; if (avpkt->pts != AVNOPTSVALUE) { cupkt.flags = CUVIDPKTTIMESTAMP; if (avctx->pkttimebase.num && avctx->pkttimebase.den) cupkt.timestamp = avrescaleq(avpkt->pts, avctx->pkttimebase, (AVRational){1, 10000000}); else cupkt.timestamp = avpkt->pts; } } else { cupkt.flags = CUVIDPKTENDOFSTREAM; } ret = CHECKCU(cuvidParseVideoData(ctx->cuparser, &cupkt)); avpacketunref(&filteredpacket); if (ret < 0) { if (ctx->internalerror) ret = ctx->internalerror; goto error; } if (avfifosize(ctx->framequeue)) { CUVIDPARSERDISPINFO dispinfo; CUVIDPROCPARAMS params; unsigned int pitch = 0; int offset = 0; int i; avfifogenericread(ctx->framequeue, &dispinfo, sizeof(CUVIDPARSERDISPINFO), NULL); memset(&params, 0, sizeof(params)); params.progressiveframe = dispinfo.progressiveframe; params.secondfield = 0; params.topfieldfirst = dispinfo.topfieldfirst; ret = CHECKCU(cuvidMapVideoFrame(ctx->cudecoder, dispinfo.pictureindex, &mappedframe, &pitch, &params)); if (ret < 0) goto error; if (avctx->pixfmt == AVPIXFMTCUDA) { ret = avhwframegetbuffer(ctx->hwframe, frame, 0); if (ret < 0) { avlog(avctx, AVLOGERROR, \"avhwframegetbuffer failed\\n\"); goto error; } ret = ffdecodeframeprops(avctx, frame); if (ret < 0) { avlog(avctx, AVLOGERROR, \"ffdecodeframeprops failed\\n\"); goto error; } for (i = 0; i < 2; i++) { CUDAMEMCPY2D cpy = { .srcMemoryType = CUMEMORYTYPEDEVICE, .dstMemoryType = CUMEMORYTYPEDEVICE, .srcDevice = mappedframe, .dstDevice = (CUdeviceptr)frame->data[i], .srcPitch = pitch, .dstPitch = frame->linesize[i], .srcY = offset, .WidthInBytes = FFMIN(pitch, frame->linesize[i]), .Height = avctx->codedheight >> (i ? 1 : 0), }; ret = CHECKCU(cuMemcpy2D(&cpy)); if (ret < 0) goto error; offset += avctx->codedheight; } } else if (avctx->pixfmt == AVPIXFMTNV12) { AVFrame *tmpframe = avframealloc(); if (!tmpframe) { avlog(avctx, AVLOGERROR, \"avframealloc failed\\n\"); ret = AVERROR(ENOMEM); goto error; } tmpframe->format = AVPIXFMTCUDA; tmpframe->hwframesctx = avbufferref(ctx->hwframe); tmpframe->data[0] = (uint8t*)mappedframe; tmpframe->linesize[0] = pitch; tmpframe->data[1] = (uint8t*)(mappedframe + avctx->codedheight * pitch); tmpframe->linesize[1] = pitch; tmpframe->width = avctx->width; tmpframe->height = avctx->height; ret = ffgetbuffer(avctx, frame, 0); if (ret < 0) { avlog(avctx, AVLOGERROR, \"ffgetbuffer failed\\n\"); avframefree(&tmpframe); goto error; } ret = avhwframetransferdata(frame, tmpframe, 0); if (ret) { avlog(avctx, AVLOGERROR, \"avhwframetransferdata failed\\n\"); avframefree(&tmpframe); goto error; } avframefree(&tmpframe); } else { ret = AVERRORBUG; goto error; } frame->width = avctx->width; frame->height = avctx->height; if (avctx->pkttimebase.num && avctx->pkttimebase.den) frame->pts = avrescaleq(dispinfo.timestamp, (AVRational){1, 10000000}, avctx->pkttimebase); else frame->pts = dispinfo.timestamp; /* CUVIDs opaque reordering breaks the internal pkt logic. * So set pktpts and clear all the other pkt fields. */ frame->pktpts = frame->pts; avframesetpktpos(frame, -1); avframesetpktduration(frame, 0); avframesetpktsize(frame, -1); frame->interlacedframe = !dispinfo.progressiveframe; if (!dispinfo.progressiveframe) frame->topfieldfirst = dispinfo.topfieldfirst; *gotframe = 1; } else { *gotframe = 0; } error: if (mappedframe) eret = CHECKCU(cuvidUnmapVideoFrame(ctx->cudecoder, mappedframe)); eret = CHECKCU(cuCtxPopCurrent(&dummy)); if (eret < 0) return eret; else return ret; } ", "target": 1}
{"func": "static void hotplug(void) { qteststart(\"-device virtio-net-pci\"); qpciplugdevicetest(\"virtio-net-pci\", \"net1\", PCISLOTHP, NULL); qpciunplugacpidevicetest(\"net1\", PCISLOTHP); testend(); } ", "target": 0}
{"func": "static void ffh264idct8addsse2(uint8t *dst, int16t *block, int stride) { asm volatile( \"movdqa 0x10(%1), %%xmm1 \\n\" \"movdqa 0x20(%1), %%xmm2 \\n\" \"movdqa 0x30(%1), %%xmm3 \\n\" \"movdqa 0x50(%1), %%xmm5 \\n\" \"movdqa 0x60(%1), %%xmm6 \\n\" \"movdqa 0x70(%1), %%xmm7 \\n\" H264IDCT81DSSE2(%%xmm0, %%xmm1, %%xmm2, %%xmm3, %%xmm4, %%xmm5, %%xmm6, %%xmm7) TRANSPOSE8(%%xmm4, %%xmm1, %%xmm7, %%xmm3, %%xmm5, %%xmm0, %%xmm2, %%xmm6, (%1)) \"paddw %4, %%xmm4 \\n\" \"movdqa %%xmm4, 0x00(%1) \\n\" \"movdqa %%xmm2, 0x40(%1) \\n\" H264IDCT81DSSE2(%%xmm4, %%xmm0, %%xmm6, %%xmm3, %%xmm2, %%xmm5, %%xmm7, %%xmm1) \"movdqa %%xmm6, 0x60(%1) \\n\" \"movdqa %%xmm7, 0x70(%1) \\n\" \"pxor %%xmm7, %%xmm7 \\n\" STOREDIFF8P(%%xmm2, (%0), %%xmm6, %%xmm7) STOREDIFF8P(%%xmm0, (%0,%2), %%xmm6, %%xmm7) STOREDIFF8P(%%xmm1, (%0,%2,2), %%xmm6, %%xmm7) STOREDIFF8P(%%xmm3, (%0,%3), %%xmm6, %%xmm7) \"lea (%0,%2,4), %0 \\n\" STOREDIFF8P(%%xmm5, (%0), %%xmm6, %%xmm7) STOREDIFF8P(%%xmm4, (%0,%2), %%xmm6, %%xmm7) \"movdqa 0x60(%1), %%xmm0 \\n\" \"movdqa 0x70(%1), %%xmm1 \\n\" STOREDIFF8P(%%xmm0, (%0,%2,2), %%xmm6, %%xmm7) STOREDIFF8P(%%xmm1, (%0,%3), %%xmm6, %%xmm7) :\"+r\"(dst) :\"r\"(block), \"r\"((x86reg)stride), \"r\"((x86reg)3L*stride), \"m\"(ffpw32) ); } ", "target": 0}
{"func": "static void ideidentify(IDEState *s) { uint16t *p; unsigned int oldsize; memset(s->iobuffer, 0, 512); p = (uint16t *)s->iobuffer; stw(p + 0, 0x0040); stw(p + 1, s->cylinders); stw(p + 3, s->heads); stw(p + 4, 512 * s->sectors); /* sectors */ stw(p + 5, 512); /* sector size */ stw(p + 6, s->sectors); stw(p + 20, 3); /* buffer type */ stw(p + 21, 512); /* cache size in sectors */ stw(p + 22, 4); /* ecc bytes */ padstr((uint8t *)(p + 27), \"QEMU HARDDISK\", 40); #if MAXMULTSECTORS > 1 stw(p + 47, MAXMULTSECTORS); #endif stw(p + 48, 1); /* dword I/O */ stw(p + 49, 1 << 9); /* LBA supported, no DMA */ stw(p + 51, 0x200); /* PIO transfer cycle */ stw(p + 52, 0x200); /* DMA transfer cycle */ stw(p + 54, s->cylinders); stw(p + 55, s->heads); stw(p + 56, s->sectors); oldsize = s->cylinders * s->heads * s->sectors; stw(p + 57, oldsize); stw(p + 58, oldsize >> 16); if (s->multsectors) stw(p + 59, 0x100 | s->multsectors); stw(p + 60, s->nbsectors); stw(p + 61, s->nbsectors >> 16); stw(p + 80, (1 << 1) | (1 << 2)); stw(p + 82, (1 << 14)); stw(p + 83, (1 << 14)); stw(p + 84, (1 << 14)); stw(p + 85, (1 << 14)); stw(p + 86, 0); stw(p + 87, (1 << 14)); } ", "target": 0}
{"func": "static int encodeapng(AVCodecContext *avctx, AVPacket *pkt, const AVFrame *pict, int *gotpacket) { PNGEncContext *s = avctx->privdata; int ret; int encrowsize; sizet maxpacketsize; APNGFctlChunk fctlchunk = {0}; if (pict && avctx->codecid == AVCODECIDAPNG && s->colortype == PNGCOLORTYPEPALETTE) { uint32t checksum = ~avcrc(avcrcgettable(AVCRC32IEEELE), ~0U, pict->data[1], 256 * sizeof(uint32t)); if (avctx->framenumber == 0) { s->palettechecksum = checksum; } else if (checksum != s->palettechecksum) { avlog(avctx, AVLOGERROR, \"Input contains more than one unique palette. APNG does not support multiple palettes.\\n\"); return -1; } } encrowsize = deflateBound(&s->zstream, (avctx->width * s->bitsperpixel + 7) >> 3); maxpacketsize = AVINPUTBUFFERMINSIZE + // headers avctx->height * ( encrowsize + (4 + 12) * (((int64t)encrowsize + IOBUFSIZE - 1) / IOBUFSIZE) // fdAT * ceil(encrowsize / IOBUFSIZE) ); if (maxpacketsize > INTMAX) return AVERROR(ENOMEM); if (avctx->framenumber == 0) { if (!pict) return AVERROR(EINVAL); s->bytestream = avctx->extradata = avmalloc(FFMINBUFFERSIZE); if (!avctx->extradata) return AVERROR(ENOMEM); ret = encodeheaders(avctx, pict); if (ret < 0) return ret; avctx->extradatasize = s->bytestream - avctx->extradata; s->lastframepacket = avmalloc(maxpacketsize); if (!s->lastframepacket) return AVERROR(ENOMEM); } else if (s->lastframe) { ret = ffallocpacket2(avctx, pkt, maxpacketsize, 0); if (ret < 0) return ret; memcpy(pkt->data, s->lastframepacket, s->lastframepacketsize); pkt->size = s->lastframepacketsize; pkt->pts = pkt->dts = s->lastframe->pts; } if (pict) { s->bytestreamstart = s->bytestream = s->lastframepacket; s->bytestreamend = s->bytestream + maxpacketsize; // We're encoding the frame first, so we have to do a bit of shuffling around // to have the image data write to the correct place in the buffer fctlchunk.sequencenumber = s->sequencenumber; ++s->sequencenumber; s->bytestream += 26 + 12; ret = apngencodeframe(avctx, pict, &fctlchunk, &s->lastframefctl); if (ret < 0) return ret; fctlchunk.delaynum = 0; // delay filled in during muxing fctlchunk.delayden = 0; } else { s->lastframefctl.disposeop = APNGDISPOSEOPNONE; } if (s->lastframe) { uint8t* lastfctlchunkstart = pkt->data; uint8t buf[26]; AVWB32(buf + 0, s->lastframefctl.sequencenumber); AVWB32(buf + 4, s->lastframefctl.width); AVWB32(buf + 8, s->lastframefctl.height); AVWB32(buf + 12, s->lastframefctl.xoffset); AVWB32(buf + 16, s->lastframefctl.yoffset); AVWB16(buf + 20, s->lastframefctl.delaynum); AVWB16(buf + 22, s->lastframefctl.delayden); buf[24] = s->lastframefctl.disposeop; buf[25] = s->lastframefctl.blendop; pngwritechunk(&lastfctlchunkstart, MKTAG('f', 'c', 'T', 'L'), buf, 26); *gotpacket = 1; } if (pict) { if (!s->lastframe) { s->lastframe = avframealloc(); if (!s->lastframe) return AVERROR(ENOMEM); } else if (s->lastframefctl.disposeop != APNGDISPOSEOPPREVIOUS) { if (!s->prevframe) { s->prevframe = avframealloc(); if (!s->prevframe) return AVERROR(ENOMEM); s->prevframe->format = pict->format; s->prevframe->width = pict->width; s->prevframe->height = pict->height; if ((ret = avframegetbuffer(s->prevframe, 32)) < 0) return ret; } // Do disposal, but not blending memcpy(s->prevframe->data[0], s->lastframe->data[0], s->lastframe->linesize[0] * s->lastframe->height); if (s->lastframefctl.disposeop == APNGDISPOSEOPBACKGROUND) { uint32t y; uint8t bpp = (s->bitsperpixel + 7) >> 3; for (y = s->lastframefctl.yoffset; y < s->lastframefctl.yoffset + s->lastframefctl.height; ++y) { sizet rowstart = s->lastframe->linesize[0] * y + bpp * s->lastframefctl.xoffset; memset(s->prevframe->data[0] + rowstart, 0, bpp * s->lastframefctl.width); } } } avframeunref(s->lastframe); ret = avframeref(s->lastframe, (AVFrame*)pict); if (ret < 0) return ret; s->lastframefctl = fctlchunk; s->lastframepacketsize = s->bytestream - s->bytestreamstart; } else { avframefree(&s->lastframe); } return 0; } ", "target": 0}
{"func": "BlockDriverAIOCB *bdrvaioreadv(BlockDriverState *bs, int64t sectornum, QEMUIOVector *qiov, int nbsectors, BlockDriverCompletionFunc *cb, void *opaque) { BlockDriver *drv = bs->drv; BlockDriverAIOCB *ret; tracebdrvaioreadv(bs, sectornum, nbsectors, opaque); if (!drv) return NULL; if (bdrvcheckrequest(bs, sectornum, nbsectors)) return NULL; ret = drv->bdrvaioreadv(bs, sectornum, qiov, nbsectors, cb, opaque); if (ret) { \t/* Update stats even though technically transfer has not happened. */ \tbs->rdbytes += (unsigned) nbsectors * BDRVSECTORSIZE; \tbs->rdops ++; } return ret; } ", "target": 0}
{"func": "static void migratesetdowntime(QTestState *who, const char *value) { QDict *rsp; gchar *cmd; cmd = gstrdupprintf(\"{ 'execute': 'migratesetdowntime',\" \"'arguments': { 'value': %s } }\", value); rsp = qtestqmp(who, cmd); gfree(cmd); gassert(qdicthaskey(rsp, \"return\")); QDECREF(rsp); } ", "target": 0}
{"func": "targetulong doarmsemihosting(CPUARMState *env) { ARMCPU *cpu = armenvgetcpu(env); CPUState *cs = CPU(cpu); targetulong args; targetulong arg0, arg1, arg2, arg3; char * s; int nr; uint32t ret; uint32t len; #ifdef CONFIGUSERONLY TaskState *ts = cs->opaque; #else CPUARMState *ts = env; #endif if (isa64(env)) { /* Note that the syscall number is in W0, not X0 */ nr = env->xregs[0] & 0xffffffffU; args = env->xregs[1]; } else { nr = env->regs[0]; args = env->regs[1]; } switch (nr) { case TARGETSYSOPEN: GETARG(0); GETARG(1); GETARG(2); s = lockuserstring(arg0); if (!s) { /* FIXME - should this error code be -TARGETEFAULT ? */ return (uint32t)-1; } if (arg1 >= 12) { unlockuser(s, arg0, 0); return (uint32t)-1; } if (strcmp(s, \":tt\") == 0) { int resultfileno = arg1 < 4 ? STDINFILENO : STDOUTFILENO; unlockuser(s, arg0, 0); return resultfileno; } if (usegdbsyscalls()) { ret = armgdbsyscall(cpu, armsemicb, \"open,%s,%x,1a4\", arg0, (int)arg2+1, gdbopenmodeflags[arg1]); } else { ret = setswierrno(ts, open(s, openmodeflags[arg1], 0644)); } unlockuser(s, arg0, 0); return ret; case TARGETSYSCLOSE: GETARG(0); if (usegdbsyscalls()) { return armgdbsyscall(cpu, armsemicb, \"close,%x\", arg0); } else { return setswierrno(ts, close(arg0)); } case TARGETSYSWRITEC: { char c; if (getuseru8(c, args)) /* FIXME - should this error code be -TARGETEFAULT ? */ return (uint32t)-1; /* Write to debug console. stderr is near enough. */ if (usegdbsyscalls()) { return armgdbsyscall(cpu, armsemicb, \"write,2,%x,1\", args); } else { return write(STDERRFILENO, &c, 1); } } case TARGETSYSWRITE0: if (!(s = lockuserstring(args))) /* FIXME - should this error code be -TARGETEFAULT ? */ return (uint32t)-1; len = strlen(s); if (usegdbsyscalls()) { return armgdbsyscall(cpu, armsemicb, \"write,2,%x,%x\", args, len); } else { ret = write(STDERRFILENO, s, len); } unlockuser(s, args, 0); return ret; case TARGETSYSWRITE: GETARG(0); GETARG(1); GETARG(2); len = arg2; if (usegdbsyscalls()) { armsemisyscalllen = len; return armgdbsyscall(cpu, armsemicb, \"write,%x,%x,%x\", arg0, arg1, len); } else { s = lockuser(VERIFYREAD, arg1, len, 1); if (!s) { /* FIXME - should this error code be -TARGETEFAULT ? */ return (uint32t)-1; } ret = setswierrno(ts, write(arg0, s, len)); unlockuser(s, arg1, 0); if (ret == (uint32t)-1) return -1; return len - ret; } case TARGETSYSREAD: GETARG(0); GETARG(1); GETARG(2); len = arg2; if (usegdbsyscalls()) { armsemisyscalllen = len; return armgdbsyscall(cpu, armsemicb, \"read,%x,%x,%x\", arg0, arg1, len); } else { s = lockuser(VERIFYWRITE, arg1, len, 0); if (!s) { /* FIXME - should this error code be -TARGETEFAULT ? */ return (uint32t)-1; } do { ret = setswierrno(ts, read(arg0, s, len)); } while (ret == -1 && errno == EINTR); unlockuser(s, arg1, len); if (ret == (uint32t)-1) return -1; return len - ret; } case TARGETSYSREADC: /* XXX: Read from debug console. Not implemented. */ return 0; case TARGETSYSISTTY: GETARG(0); if (usegdbsyscalls()) { return armgdbsyscall(cpu, armsemicb, \"isatty,%x\", arg0); } else { return isatty(arg0); } case TARGETSYSSEEK: GETARG(0); GETARG(1); if (usegdbsyscalls()) { return armgdbsyscall(cpu, armsemicb, \"lseek,%x,%x,0\", arg0, arg1); } else { ret = setswierrno(ts, lseek(arg0, arg1, SEEKSET)); if (ret == (uint32t)-1) return -1; return 0; } case TARGETSYSFLEN: GETARG(0); if (usegdbsyscalls()) { return armgdbsyscall(cpu, armsemiflencb, \"fstat,%x,%x\", arg0, armflenbuf(cpu)); } else { struct stat buf; ret = setswierrno(ts, fstat(arg0, &buf)); if (ret == (uint32t)-1) return -1; return buf.stsize; } case TARGETSYSTMPNAM: /* XXX: Not implemented. */ return -1; case TARGETSYSREMOVE: GETARG(0); GETARG(1); if (usegdbsyscalls()) { ret = armgdbsyscall(cpu, armsemicb, \"unlink,%s\", arg0, (int)arg1+1); } else { s = lockuserstring(arg0); if (!s) { /* FIXME - should this error code be -TARGETEFAULT ? */ return (uint32t)-1; } ret = setswierrno(ts, remove(s)); unlockuser(s, arg0, 0); } return ret; case TARGETSYSRENAME: GETARG(0); GETARG(1); GETARG(2); GETARG(3); if (usegdbsyscalls()) { return armgdbsyscall(cpu, armsemicb, \"rename,%s,%s\", arg0, (int)arg1+1, arg2, (int)arg3+1); } else { char *s2; s = lockuserstring(arg0); s2 = lockuserstring(arg2); if (!s || !s2) /* FIXME - should this error code be -TARGETEFAULT ? */ ret = (uint32t)-1; else ret = setswierrno(ts, rename(s, s2)); if (s2) unlockuser(s2, arg2, 0); if (s) unlockuser(s, arg0, 0); return ret; } case TARGETSYSCLOCK: return clock() / (CLOCKSPERSEC / 100); case TARGETSYSTIME: return setswierrno(ts, time(NULL)); case TARGETSYSSYSTEM: GETARG(0); GETARG(1); if (usegdbsyscalls()) { return armgdbsyscall(cpu, armsemicb, \"system,%s\", arg0, (int)arg1+1); } else { s = lockuserstring(arg0); if (!s) { /* FIXME - should this error code be -TARGETEFAULT ? */ return (uint32t)-1; } ret = setswierrno(ts, system(s)); unlockuser(s, arg0, 0); return ret; } case TARGETSYSERRNO: #ifdef CONFIGUSERONLY return ts->swierrno; #else return syscallerr; #endif case TARGETSYSGETCMDLINE: { /* Build a command-line from the original argv. * * The inputs are: * * arg0, pointer to a buffer of at least the size * specified in arg1. * * arg1, size of the buffer pointed to by arg0 in * bytes. * * The outputs are: * * arg0, pointer to null-terminated string of the * command line. * * arg1, length of the string pointed to by arg0. */ char *outputbuffer; sizet inputsize; sizet outputsize; int status = 0; #if !defined(CONFIGUSERONLY) const char *cmdline; #endif GETARG(0); GETARG(1); inputsize = arg1; /* Compute the size of the output string. */ #if !defined(CONFIGUSERONLY) cmdline = semihostinggetcmdline(); if (cmdline == NULL) { cmdline = \"\"; /* Default to an empty line. */ } outputsize = strlen(cmdline) + 1; /* Count terminating 0. */ #else unsigned int i; outputsize = ts->info->argend - ts->info->argstart; if (!outputsize) { /* We special-case the \"empty command line\" case (argc==0). Just provide the terminating 0. */ outputsize = 1; } #endif if (outputsize > inputsize) { /* Not enough space to store command-line arguments. */ return -1; } /* Adjust the command-line length. */ if (SETARG(1, outputsize - 1)) { /* Couldn't write back to argument block */ return -1; } /* Lock the buffer on the ARM side. */ outputbuffer = lockuser(VERIFYWRITE, arg0, outputsize, 0); if (!outputbuffer) { return -1; } /* Copy the command-line arguments. */ #if !defined(CONFIGUSERONLY) pstrcpy(outputbuffer, outputsize, cmdline); #else if (outputsize == 1) { /* Empty command-line. */ outputbuffer[0] = '\\0'; goto out; } if (copyfromuser(outputbuffer, ts->info->argstart, outputsize)) { status = -1; goto out; } /* Separate arguments by white spaces. */ for (i = 0; i < outputsize - 1; i++) { if (outputbuffer[i] == 0) { outputbuffer[i] = ' '; } } out: #endif /* Unlock the buffer on the ARM side. */ unlockuser(outputbuffer, arg0, outputsize); return status; } case TARGETSYSHEAPINFO: { targetulong retvals[4]; uint32t limit; int i; GETARG(0); #ifdef CONFIGUSERONLY /* Some C libraries assume the heap immediately follows .bss, so allocate it using sbrk. */ if (!ts->heaplimit) { abiulong ret; ts->heapbase = dobrk(0); limit = ts->heapbase + ARMANGELHEAPSIZE; /* Try a big heap, and reduce the size if that fails. */ for (;;) { ret = dobrk(limit); if (ret >= limit) { break; } limit = (ts->heapbase >> 1) + (limit >> 1); } ts->heaplimit = limit; } retvals[0] = ts->heapbase; retvals[1] = ts->heaplimit; retvals[2] = ts->stackbase; retvals[3] = 0; /* Stack limit. */ #else limit = ramsize; /* TODO: Make this use the limit of the loaded application. */ retvals[0] = limit / 2; retvals[1] = limit; retvals[2] = limit; /* Stack base */ retvals[3] = 0; /* Stack limit. */ #endif for (i = 0; i < ARRAYSIZE(retvals); i++) { bool fail; if (isa64(env)) { fail = putuseru64(retvals[i], arg0 + i * 8); } else { fail = putuseru32(retvals[i], arg0 + i * 4); } if (fail) { /* Couldn't write back to argument block */ return -1; } } return 0; } case TARGETSYSEXIT: if (isa64(env)) { /* The A64 version of this call takes a parameter block, * so the application-exit type can return a subcode which * is the exit status code from the application. */ GETARG(0); GETARG(1); if (arg0 == ADPStoppedApplicationExit) { ret = arg1; } else { ret = 1; } } else { /* ARM specifies only StoppedApplicationExit as normal * exit, everything else is considered an error */ ret = (args == ADPStoppedApplicationExit) ? 0 : 1; } gdbexit(env, ret); exit(ret); case TARGETSYSSYNCCACHE: /* Clean the D-cache and invalidate the I-cache for the specified * virtual address range. This is a nop for us since we don't * implement caches. This is only present on A64. */ if (isa64(env)) { return 0; } /* fall through -- invalid for A32/T32 */ default: fprintf(stderr, \"qemu: Unsupported SemiHosting SWI 0x%02x\\n\", nr); cpudumpstate(cs, stderr, fprintf, 0); abort(); } } ", "target": 0}
{"func": "static int decodeunregistereduserdata(H264SEIUnregistered *h, GetBitContext *gb, void *logctx, int size) { uint8t *userdata; int e, build, i; if (size < 16 || size >= INTMAX - 16) return AVERRORINVALIDDATA; userdata = avmalloc(16 + size + 1); if (!userdata) return AVERROR(ENOMEM); for (i = 0; i < size + 16; i++) userdata[i] = getbits(gb, 8); userdata[i] = 0; e = sscanf(userdata + 16, \"x264 - core %d\", &build); if (e == 1 && build > 0) h->x264build = build; if (e == 1 && build == 1 && !strncmp(userdata+16, \"x264 - core 0000\", 16)) h->x264build = 67; if (strlen(userdata + 16) > 0) avlog(logctx, AVLOGDEBUG, \"user data:\\\"%s\\\"\\n\", userdata + 16); avfree(userdata); return 0; } ", "target": 0}
{"func": "void avfilterfiltersamples(AVFilterLink *link, AVFilterBufferRef *samplesref) { void (*filtersamples)(AVFilterLink *, AVFilterBufferRef *); AVFilterPad *dst = link->dstpad; int i; FFDPRINTFSTART(NULL, filtersamples); ffdloglink(NULL, link, 1); if (!(filtersamples = dst->filtersamples)) filtersamples = avfilterdefaultfiltersamples; /* prepare to copy the samples if the buffer has insufficient permissions */ if ((dst->minperms & samplesref->perms) != dst->minperms || dst->rejperms & samplesref->perms) { avlog(link->dst, AVLOGDEBUG, \"Copying audio data in avfilter (have perms %x, need %x, reject %x)\\n\", samplesref->perms, link->dstpad->minperms, link->dstpad->rejperms); link->curbuf = avfilterdefaultgetaudiobuffer(link, dst->minperms, samplesref->audio->nbsamples); link->curbuf->pts = samplesref->pts; link->curbuf->audio->samplerate = samplesref->audio->samplerate; /* Copy actual data into new samples buffer */ for (i = 0; samplesref->data[i]; i++) memcpy(link->curbuf->data[i], samplesref->data[i], samplesref->linesize[0]); avfilterunrefbuffer(samplesref); } else link->curbuf = samplesref; filtersamples(link, link->curbuf); } ", "target": 0}
{"func": "static qemuirq *ppce500initmpic(PPCE500Params *params, MemoryRegion *ccsr, qemuirq **irqs) { qemuirq *mpic; DeviceState *dev; SysBusDevice *s; int i, j, k; mpic = gnew(qemuirq, 256); dev = qdevcreate(NULL, \"openpic\"); qdevpropsetuint32(dev, \"nbcpus\", smpcpus); qdevpropsetuint32(dev, \"model\", params->mpicversion); qdevinitnofail(dev); s = SYSBUSDEVICE(dev); k = 0; for (i = 0; i < smpcpus; i++) { for (j = 0; j < OPENPICOUTPUTNB; j++) { sysbusconnectirq(s, k++, irqs[i][j]); } } for (i = 0; i < 256; i++) { mpic[i] = qdevgetgpioin(dev, i); } memoryregionaddsubregion(ccsr, MPC8544MPICREGSOFFSET, s->mmio[0].memory); return mpic; } ", "target": 0}
{"func": "CharDriverState *qemuchrnew(const char *label, const char *filename, void (*init)(struct CharDriverState *s)) { const char *p; CharDriverState *chr; QemuOpts *opts; Error *err = NULL; if (strstart(filename, \"chardev:\", &p)) { return qemuchrfind(p); } opts = qemuchrparsecompat(label, filename); if (!opts) return NULL; chr = qemuchrnewfromopts(opts, init, &err); if (err) { errorreporterr(err); } if (chr && qemuoptgetbool(opts, \"mux\", 0)) { qemuchrfeclaimnofail(chr); monitorinit(chr, MONITORUSEREADLINE); } return chr; } ", "target": 0}
{"func": "static int netinittapone(const NetdevTapOptions *tap, NetClientState *peer, const char *model, const char *name, const char *ifname, const char *script, const char *downscript, const char *vhostfdname, int vnethdr, int fd) { TAPState *s; s = nettapfdinit(peer, model, name, fd, vnethdr); if (!s) { close(fd); return -1; } if (tapsetsndbuf(s->fd, tap) < 0) { return -1; } if (tap->hasfd || tap->hasfds) { snprintf(s->nc.infostr, sizeof(s->nc.infostr), \"fd=%d\", fd); } else if (tap->hashelper) { snprintf(s->nc.infostr, sizeof(s->nc.infostr), \"helper=%s\", tap->helper); } else { snprintf(s->nc.infostr, sizeof(s->nc.infostr), \"ifname=%s,script=%s,downscript=%s\", ifname, script, downscript); if (strcmp(downscript, \"no\") != 0) { snprintf(s->downscript, sizeof(s->downscript), \"%s\", downscript); snprintf(s->downscriptarg, sizeof(s->downscriptarg), \"%s\", ifname); } } if (tap->hasvhost ? tap->vhost : vhostfdname || (tap->hasvhostforce && tap->vhostforce)) { int vhostfd; if (tap->hasvhostfd) { vhostfd = monitorhandlefdparam(curmon, vhostfdname); if (vhostfd == -1) { return -1; } } else { vhostfd = -1; } s->vhostnet = vhostnetinit(&s->nc, vhostfd, tap->hasvhostforce && tap->vhostforce); if (!s->vhostnet) { errorreport(\"vhost-net requested but could not be initialized\"); return -1; } } else if (tap->hasvhostfd || tap->hasvhostfds) { errorreport(\"vhostfd= is not valid without vhost\"); return -1; } return 0; } ", "target": 0}
{"func": "int qdevpropcheckglobals(void) { GList *l; int ret = 0; for (l = globalprops; l; l = l->next) { GlobalProperty *prop = l->data; ObjectClass *oc; DeviceClass *dc; if (prop->used) { continue; } if (!prop->userprovided) { continue; } oc = objectclassbyname(prop->driver); oc = objectclassdynamiccast(oc, TYPEDEVICE); if (!oc) { errorreport(\"Warning: global %s.%s has invalid class name\", prop->driver, prop->property); ret = 1; continue; } dc = DEVICECLASS(oc); if (!dc->hotpluggable && !prop->used) { errorreport(\"Warning: global %s.%s=%s not used\", prop->driver, prop->property, prop->value); ret = 1; continue; } } return ret; } ", "target": 0}
{"func": "static int qesdinitout (HWVoiceOut *hw, audsettingst *as) { ESDVoiceOut *esd = (ESDVoiceOut *) hw; audsettingst obtas = *as; int esdfmt = ESDSTREAM | ESDPLAY; int err; sigsett set, oldset; sigfillset (&set); esdfmt |= (as->nchannels == 2) ? ESDSTEREO : ESDMONO; switch (as->fmt) { case AUDFMTS8: case AUDFMTU8: esdfmt |= ESDBITS8; obtas.fmt = AUDFMTU8; break; case AUDFMTS32: case AUDFMTU32: dolog (\"Will use 16 instead of 32 bit samples\\n\"); case AUDFMTS16: case AUDFMTU16: deffmt: esdfmt |= ESDBITS16; obtas.fmt = AUDFMTS16; break; default: dolog (\"Internal logic error: Bad audio format %d\\n\", as->fmt); goto deffmt; } obtas.endianness = AUDIOHOSTENDIANNESS; audiopcminitinfo (&hw->info, &obtas); hw->samples = conf.samples; esd->pcmbuf = audiocalloc (AUDIOFUNC, hw->samples, 1 << hw->info.shift); if (!esd->pcmbuf) { dolog (\"Could not allocate buffer (%d bytes)\\n\", hw->samples << hw->info.shift); return -1; } esd->fd = -1; err = pthreadsigmask (SIGBLOCK, &set, &oldset); if (err) { qesdlogerr (err, \"pthreadsigmask failed\\n\"); goto fail1; } esd->fd = esdplaystream (esdfmt, as->freq, conf.dachost, NULL); if (esd->fd < 0) { qesdlogerr (errno, \"esdplaystream failed\\n\"); goto fail2; } if (audioptinit (&esd->pt, qesdthreadout, esd, AUDIOCAP, AUDIOFUNC)) { goto fail3; } err = pthreadsigmask (SIGSETMASK, &oldset, NULL); if (err) { qesdlogerr (err, \"pthreadsigmask(restore) failed\\n\"); } return 0; fail3: if (close (esd->fd)) { qesdlogerr (errno, \"%s: close on esd socket(%d) failed\\n\", AUDIOFUNC, esd->fd); } esd->fd = -1; fail2: err = pthreadsigmask (SIGSETMASK, &oldset, NULL); if (err) { qesdlogerr (err, \"pthreadsigmask(restore) failed\\n\"); } fail1: qemufree (esd->pcmbuf); esd->pcmbuf = NULL; return -1; } ", "target": 0}
{"func": "static void monitorfindcompletion(const char *cmdline) { const char *cmdname; char *args[MAXARGS]; int nbargs, i, len; const char *ptype, *str; const moncmdt *cmd; const KeyDef *key; parsecmdline(cmdline, &nbargs, args); #ifdef DEBUGCOMPLETION for(i = 0; i < nbargs; i++) { monitorprintf(curmon, \"arg%d = '%s'\\n\", i, (char *)args[i]); } #endif /* if the line ends with a space, it means we want to complete the next arg */ len = strlen(cmdline); if (len > 0 && qemuisspace(cmdline[len - 1])) { if (nbargs >= MAXARGS) return; args[nbargs++] = qemustrdup(\"\"); } if (nbargs <= 1) { /* command completion */ if (nbargs == 0) cmdname = \"\"; else cmdname = args[0]; readlinesetcompletionindex(curmon->rs, strlen(cmdname)); for(cmd = moncmds; cmd->name != NULL; cmd++) { cmdcompletion(cmdname, cmd->name); } } else { /* find the command */ for(cmd = moncmds; cmd->name != NULL; cmd++) { if (comparecmd(args[0], cmd->name)) goto found; } return; found: ptype = nextargtype(cmd->argstype); for(i = 0; i < nbargs - 2; i++) { if (*ptype != '\\0') { ptype = nextargtype(ptype); while (*ptype == '?') ptype = nextargtype(ptype); } } str = args[nbargs - 1]; if (*ptype == '-' && ptype[1] != '\\0') { ptype += 2; } switch(*ptype) { case 'F': /* file completion */ readlinesetcompletionindex(curmon->rs, strlen(str)); filecompletion(str); break; case 'B': /* block device name completion */ readlinesetcompletionindex(curmon->rs, strlen(str)); bdrviterate(blockcompletionit, (void *)str); break; case 's': /* XXX: more generic ? */ if (!strcmp(cmd->name, \"info\")) { readlinesetcompletionindex(curmon->rs, strlen(str)); for(cmd = infocmds; cmd->name != NULL; cmd++) { cmdcompletion(str, cmd->name); } } else if (!strcmp(cmd->name, \"sendkey\")) { char *sep = strrchr(str, '-'); if (sep) str = sep + 1; readlinesetcompletionindex(curmon->rs, strlen(str)); for(key = keydefs; key->name != NULL; key++) { cmdcompletion(str, key->name); } } else if (!strcmp(cmd->name, \"help|?\")) { readlinesetcompletionindex(curmon->rs, strlen(str)); for (cmd = moncmds; cmd->name != NULL; cmd++) { cmdcompletion(str, cmd->name); } } break; default: break; } } for(i = 0; i < nbargs; i++) qemufree(args[i]); } ", "target": 1}
{"func": "static void sdresponser1make(SDState *sd, uint8t *response, uint32t laststatus) { uint32t mask = CARDSTATUSB ^ ILLEGALCOMMAND; uint32t status; status = (sd->cardstatus & ~mask) | (laststatus & mask); sd->cardstatus &= ~CARDSTATUSC | APPCMD; response[0] = (status >> 24) & 0xff; response[1] = (status >> 16) & 0xff; response[2] = (status >> 8) & 0xff; response[3] = (status >> 0) & 0xff; } ", "target": 0}
{"func": "static int mpc8decodeframe(AVCodecContext * avctx, void *data, int *datasize, AVPacket *avpkt) { const uint8t *buf = avpkt->data; int bufsize = avpkt->size; MPCContext *c = avctx->privdata; GetBitContext gb2, *gb = &gb2; int i, j, k, ch, cnt, res, t; Band *bands = c->bands; int off; int maxband, keyframe; int last[2]; keyframe = c->curframe == 0; if(keyframe){ memset(c->Q, 0, sizeof(c->Q)); c->lastbitsused = 0; } initgetbits(gb, buf, bufsize * 8); skipbits(gb, c->lastbitsused & 7); if(keyframe) maxband = mpc8getmodgolomb(gb, c->maxbands + 1); else{ maxband = c->lastmaxband + getvlc2(gb, bandvlc.table, MPC8BANDSBITS, 2); if(maxband > 32) maxband -= 33; } c->lastmaxband = maxband; /* read subband indexes */ if(maxband){ last[0] = last[1] = 0; for(i = maxband - 1; i >= 0; i--){ for(ch = 0; ch < 2; ch++){ last[ch] = getvlc2(gb, resvlc[last[ch] > 2].table, MPC8RESBITS, 2) + last[ch]; if(last[ch] > 15) last[ch] -= 17; bands[i].res[ch] = last[ch]; } } if(c->MSS){ int mask; cnt = 0; for(i = 0; i < maxband; i++) if(bands[i].res[0] || bands[i].res[1]) cnt++; t = mpc8getmodgolomb(gb, cnt); mask = mpc8getmask(gb, cnt, t); for(i = maxband - 1; i >= 0; i--) if(bands[i].res[0] || bands[i].res[1]){ bands[i].msf = mask & 1; mask >>= 1; } } } for(i = maxband; i < c->maxbands; i++) bands[i].res[0] = bands[i].res[1] = 0; if(keyframe){ for(i = 0; i < 32; i++) c->oldDSCF[0][i] = c->oldDSCF[1][i] = 1; } for(i = 0; i < maxband; i++){ if(bands[i].res[0] || bands[i].res[1]){ cnt = !!bands[i].res[0] + !!bands[i].res[1] - 1; if(cnt >= 0){ t = getvlc2(gb, scfivlc[cnt].table, scfivlc[cnt].bits, 1); if(bands[i].res[0]) bands[i].scfi[0] = t >> (2 * cnt); if(bands[i].res[1]) bands[i].scfi[1] = t & 3; } } } for(i = 0; i < maxband; i++){ for(ch = 0; ch < 2; ch++){ if(!bands[i].res[ch]) continue; if(c->oldDSCF[ch][i]){ bands[i].scfidx[ch][0] = getbits(gb, 7) - 6; c->oldDSCF[ch][i] = 0; }else{ t = getvlc2(gb, dscfvlc[1].table, MPC8DSCF1BITS, 2); if(t == 64) t += getbits(gb, 6); bands[i].scfidx[ch][0] = ((bands[i].scfidx[ch][2] + t - 25) & 0x7F) - 6; } for(j = 0; j < 2; j++){ if((bands[i].scfi[ch] << j) & 2) bands[i].scfidx[ch][j + 1] = bands[i].scfidx[ch][j]; else{ t = getvlc2(gb, dscfvlc[0].table, MPC8DSCF0BITS, 2); if(t == 31) t = 64 + getbits(gb, 6); bands[i].scfidx[ch][j + 1] = ((bands[i].scfidx[ch][j] + t - 25) & 0x7F) - 6; } } } } for(i = 0, off = 0; i < maxband; i++, off += SAMPLESPERBAND){ for(ch = 0; ch < 2; ch++){ res = bands[i].res[ch]; switch(res){ case -1: for(j = 0; j < SAMPLESPERBAND; j++) c->Q[ch][off + j] = (avlfgget(&c->rnd) & 0x3FC) - 510; break; case 0: break; case 1: for(j = 0; j < SAMPLESPERBAND; j += SAMPLESPERBAND / 2){ cnt = getvlc2(gb, q1vlc.table, MPC8Q1BITS, 2); t = mpc8getmask(gb, 18, cnt); for(k = 0; k < SAMPLESPERBAND / 2; k++, t <<= 1) c->Q[ch][off + j + k] = (t & 0x20000) ? (getbits1(gb) << 1) - 1 : 0; } break; case 2: cnt = 6;//2*mpc8thres[res] for(j = 0; j < SAMPLESPERBAND; j += 3){ t = getvlc2(gb, q2vlc[cnt > 3].table, MPC8Q2BITS, 2); c->Q[ch][off + j + 0] = mpc8idx50[t]; c->Q[ch][off + j + 1] = mpc8idx51[t]; c->Q[ch][off + j + 2] = mpc8idx52[t]; cnt = (cnt >> 1) + mpc8huffq2[t]; } break; case 3: case 4: for(j = 0; j < SAMPLESPERBAND; j += 2){ t = getvlc2(gb, q3vlc[res - 3].table, MPC8Q3BITS, 2) + q3offsets[res - 3]; c->Q[ch][off + j + 1] = t >> 4; c->Q[ch][off + j + 0] = (t & 8) ? (t & 0xF) - 16 : (t & 0xF); } break; case 5: case 6: case 7: case 8: cnt = 2 * mpc8thres[res]; for(j = 0; j < SAMPLESPERBAND; j++){ t = getvlc2(gb, quantvlc[res - 5][cnt > mpc8thres[res]].table, quantvlc[res - 5][cnt > mpc8thres[res]].bits, 2) + quantoffsets[res - 5]; c->Q[ch][off + j] = t; cnt = (cnt >> 1) + FFABS(c->Q[ch][off + j]); } break; default: for(j = 0; j < SAMPLESPERBAND; j++){ c->Q[ch][off + j] = getvlc2(gb, q9upvlc.table, MPC8Q9UPBITS, 2); if(res != 9){ c->Q[ch][off + j] <<= res - 9; c->Q[ch][off + j] |= getbits(gb, res - 9); } c->Q[ch][off + j] -= (1 << (res - 2)) - 1; } } } } ffmpcdequantizeandsynth(c, maxband, data, avctx->channels); c->curframe++; c->lastbitsused = getbitscount(gb); if(c->curframe >= c->frames) c->curframe = 0; *datasize = MPCFRAMESIZE * 2 * avctx->channels; return c->curframe ? c->lastbitsused >> 3 : bufsize; } ", "target": 0}
{"func": "DeviceState *qdevtrycreate(BusState *bus, const char *name) { DeviceState *dev; if (objectclassbyname(name) == NULL) { return NULL; } dev = DEVICE(objectnew(name)); if (!dev) { return NULL; } if (!bus) { bus = sysbusgetdefault(); } qdevsetparentbus(dev, bus); qdevpropsetglobals(dev); return dev; } ", "target": 0}
{"func": "Visitor *qobjectinputvisitornewkeyval(QObject *obj) { QObjectInputVisitor *v = qobjectinputvisitorbasenew(obj); v->visitor.typeint64 = qobjectinputtypeint64keyval; v->visitor.typeuint64 = qobjectinputtypeuint64keyval; v->visitor.typebool = qobjectinputtypeboolkeyval; v->visitor.typestr = qobjectinputtypestr; v->visitor.typenumber = qobjectinputtypenumberkeyval; v->visitor.typeany = qobjectinputtypeany; v->visitor.typenull = qobjectinputtypenull; v->visitor.typesize = qobjectinputtypesizekeyval; return &v->visitor; } ", "target": 1}
{"func": "void *pl080init(uint32t base, qemuirq irq, int nchannels) { int iomemtype; pl080state *s; s = (pl080state *)qemumallocz(sizeof(pl080state)); iomemtype = cpuregisteriomemory(0, pl080readfn, pl080writefn, s); cpuregisterphysicalmemory(base, 0x00000fff, iomemtype); s->base = base; s->irq = irq; s->nchannels = nchannels; /* ??? Save/restore. */ return s; } ", "target": 1}
{"func": "static avcold void initcoefvlc(VLC *vlc, uint16t **pruntable, float **pleveltable, uint16t **pinttable, const CoefVLCTable *vlctable) { int n = vlctable->n; const uint8t *tablebits = vlctable->huffbits; const uint32t *tablecodes = vlctable->huffcodes; const uint16t *levelstable = vlctable->levels; uint16t *runtable, *leveltable, *inttable; float *fleveltable; int i, l, j, k, level; initvlc(vlc, VLCBITS, n, tablebits, 1, 1, tablecodes, 4, 4, 0); runtable = avmalloc(n * sizeof(uint16t)); leveltable = avmalloc(n * sizeof(uint16t)); fleveltable = avmalloc(n * sizeof(*fleveltable)); inttable = avmalloc(n * sizeof(uint16t)); i = 2; level = 1; k = 0; while (i < n) { inttable[k] = i; l = levelstable[k++]; for (j = 0; j < l; j++) { runtable[i] = j; leveltable[i] = level; fleveltable[i] = level; i++; } level++; } *pruntable = runtable; *pleveltable = fleveltable; *pinttable = inttable; avfree(leveltable); } ", "target": 0}
{"func": "static inline int parsenalunits(AVCodecParserContext *s, AVCodecContext *avctx, const uint8t *buf, int bufsize) { H264ParseContext *p = s->privdata; const uint8t *bufend = buf + bufsize; H2645NAL nal = { NULL }; unsigned int ppsid; unsigned int slicetype; int state = -1, gotreset = 0; int fieldpoc[2]; int ret; /* set some sane default values */ s->picttype = AVPICTURETYPEI; s->keyframe = 0; s->picturestructure = AVPICTURESTRUCTUREUNKNOWN; ffh264seiuninit(&p->sei); if (!bufsize) return 0; for (;;) { const SPS *sps; int srclength, consumed; buf = avprivfindstartcode(buf, bufend, &state); if (buf >= bufend) break; --buf; srclength = bufend - buf; switch (state & 0x1f) { case H264NALSLICE: case H264NALIDRSLICE: // Do not walk the whole buffer just to decode slice header if ((state & 0x1f) == H264NALIDRSLICE || ((state >> 5) & 0x3) == 0) { /* IDR or disposable slice * No need to decode many bytes because MMCOs shall not be present. */ if (srclength > 60) srclength = 60; } else { /* To decode up to MMCOs */ if (srclength > 1000) srclength = 1000; } break; } consumed = ffh2645extractrbsp(buf, srclength, &nal); if (consumed < 0) break; ret = initgetbits(&nal.gb, nal.data, nal.size * 8); if (ret < 0) goto fail; getbits1(&nal.gb); nal.refidc = getbits(&nal.gb, 2); nal.type = getbits(&nal.gb, 5); switch (nal.type) { case H264NALSPS: ffh264decodeseqparameterset(&nal.gb, avctx, &p->ps); break; case H264NALPPS: ffh264decodepictureparameterset(&nal.gb, avctx, &p->ps, nal.sizebits); break; case H264NALSEI: ffh264seidecode(&p->sei, &nal.gb, &p->ps, avctx); break; case H264NALIDRSLICE: s->keyframe = 1; p->poc.prevframenum = 0; p->poc.prevframenumoffset = 0; p->poc.prevpocmsb = p->poc.prevpoclsb = 0; /* fall through */ case H264NALSLICE: getuegolomb(&nal.gb); // skip firstmbinslice slicetype = getuegolomb31(&nal.gb); s->picttype = ffh264golombtopicttype[slicetype % 5]; if (p->sei.recoverypoint.recoveryframecnt >= 0) { /* key frame, since recoveryframecnt is set */ s->keyframe = 1; } ppsid = getuegolomb(&nal.gb); if (ppsid >= MAXPPSCOUNT) { avlog(avctx, AVLOGERROR, \"ppsid %u out of range\\n\", ppsid); goto fail; } if (!p->ps.ppslist[ppsid]) { avlog(avctx, AVLOGERROR, \"non-existing PPS %u referenced\\n\", ppsid); goto fail; } p->ps.pps = (const PPS*)p->ps.ppslist[ppsid]->data; if (!p->ps.spslist[p->ps.pps->spsid]) { avlog(avctx, AVLOGERROR, \"non-existing SPS %u referenced\\n\", p->ps.pps->spsid); goto fail; } p->ps.sps = (SPS*)p->ps.spslist[p->ps.pps->spsid]->data; sps = p->ps.sps; p->poc.framenum = getbits(&nal.gb, sps->log2maxframenum); s->codedwidth = 16 * sps->mbwidth; s->codedheight = 16 * sps->mbheight; s->width = s->codedwidth - (sps->cropright + sps->cropleft); s->height = s->codedheight - (sps->croptop + sps->cropbottom); if (s->width <= 0 || s->height <= 0) { s->width = s->codedwidth; s->height = s->codedheight; } switch (sps->bitdepthluma) { case 9: if (sps->chromaformatidc == 3) s->format = AVPIXFMTYUV444P9; else if (sps->chromaformatidc == 2) s->format = AVPIXFMTYUV422P9; else s->format = AVPIXFMTYUV420P9; break; case 10: if (sps->chromaformatidc == 3) s->format = AVPIXFMTYUV444P10; else if (sps->chromaformatidc == 2) s->format = AVPIXFMTYUV422P10; else s->format = AVPIXFMTYUV420P10; break; case 8: if (sps->chromaformatidc == 3) s->format = AVPIXFMTYUV444P; else if (sps->chromaformatidc == 2) s->format = AVPIXFMTYUV422P; else s->format = AVPIXFMTYUV420P; break; default: s->format = AVPIXFMTNONE; } avctx->profile = ffh264getprofile(sps); avctx->level = sps->levelidc; if (sps->framembsonlyflag) { p->picturestructure = PICTFRAME; } else { if (getbits1(&nal.gb)) { // fieldpicflag p->picturestructure = PICTTOPFIELD + getbits1(&nal.gb); // bottomfieldflag } else { p->picturestructure = PICTFRAME; } } if (nal.type == H264NALIDRSLICE) getuegolomb(&nal.gb); /* idrpicid */ if (sps->poctype == 0) { p->poc.poclsb = getbits(&nal.gb, sps->log2maxpoclsb); if (p->ps.pps->picorderpresent == 1 && p->picturestructure == PICTFRAME) p->poc.deltapocbottom = getsegolomb(&nal.gb); } if (sps->poctype == 1 && !sps->deltapicorderalwayszeroflag) { p->poc.deltapoc[0] = getsegolomb(&nal.gb); if (p->ps.pps->picorderpresent == 1 && p->picturestructure == PICTFRAME) p->poc.deltapoc[1] = getsegolomb(&nal.gb); } /* Decode POC of this picture. * The prev values needed for decoding POC of the next picture are not set here. */ fieldpoc[0] = fieldpoc[1] = INTMAX; ffh264initpoc(fieldpoc, &s->outputpicturenumber, sps, &p->poc, p->picturestructure, nal.refidc); /* Continue parsing to check if MMCORESET is present. * FIXME: MMCORESET could appear in non-first slice. * Maybe, we should parse all undisposable non-IDR slice of this * picture until encountering MMCORESET in a slice of it. */ if (nal.refidc && nal.type != H264NALIDRSLICE) { gotreset = scanmmcoreset(s, &nal.gb, avctx); if (gotreset < 0) goto fail; } /* Set up the prev values for decoding POC of the next picture. */ p->poc.prevframenum = gotreset ? 0 : p->poc.framenum; p->poc.prevframenumoffset = gotreset ? 0 : p->poc.framenumoffset; if (nal.refidc != 0) { if (!gotreset) { p->poc.prevpocmsb = p->poc.pocmsb; p->poc.prevpoclsb = p->poc.poclsb; } else { p->poc.prevpocmsb = 0; p->poc.prevpoclsb = p->picturestructure == PICTBOTTOMFIELD ? 0 : fieldpoc[0]; } } if (sps->picstructpresentflag) { switch (p->sei.picturetiming.picstruct) { case SEIPICSTRUCTTOPFIELD: case SEIPICSTRUCTBOTTOMFIELD: s->repeatpict = 0; break; case SEIPICSTRUCTFRAME: case SEIPICSTRUCTTOPBOTTOM: case SEIPICSTRUCTBOTTOMTOP: s->repeatpict = 1; break; case SEIPICSTRUCTTOPBOTTOMTOP: case SEIPICSTRUCTBOTTOMTOPBOTTOM: s->repeatpict = 2; break; case SEIPICSTRUCTFRAMEDOUBLING: s->repeatpict = 3; break; case SEIPICSTRUCTFRAMETRIPLING: s->repeatpict = 5; break; default: s->repeatpict = p->picturestructure == PICTFRAME ? 1 : 0; break; } } else { s->repeatpict = p->picturestructure == PICTFRAME ? 1 : 0; } if (p->picturestructure == PICTFRAME) { s->picturestructure = AVPICTURESTRUCTUREFRAME; if (sps->picstructpresentflag) { switch (p->sei.picturetiming.picstruct) { case SEIPICSTRUCTTOPBOTTOM: case SEIPICSTRUCTTOPBOTTOMTOP: s->fieldorder = AVFIELDTT; break; case SEIPICSTRUCTBOTTOMTOP: case SEIPICSTRUCTBOTTOMTOPBOTTOM: s->fieldorder = AVFIELDBB; break; default: s->fieldorder = AVFIELDPROGRESSIVE; break; } } else { if (fieldpoc[0] < fieldpoc[1]) s->fieldorder = AVFIELDTT; else if (fieldpoc[0] > fieldpoc[1]) s->fieldorder = AVFIELDBB; else s->fieldorder = AVFIELDPROGRESSIVE; } } else { if (p->picturestructure == PICTTOPFIELD) s->picturestructure = AVPICTURESTRUCTURETOPFIELD; else s->picturestructure = AVPICTURESTRUCTUREBOTTOMFIELD; s->fieldorder = AVFIELDUNKNOWN; } avfreep(&nal.rbspbuffer); return 0; /* no need to evaluate the rest */ } buf += consumed; } /* didn't find a picture! */ avlog(avctx, AVLOGERROR, \"missing picture in access unit\\n\"); fail: avfreep(&nal.rbspbuffer); return -1; } ", "target": 0}
{"func": "static avalwaysinline void FUNC(intrapred)(HEVCContext *s, int x0, int y0, int log2size, int cidx) { #define PU(x) \\ ((x) >> s->ps.sps->log2minpusize) #define MVF(x, y) \\ (s->ref->tabmvf[(x) + (y) * minpuwidth]) #define MVFPU(x, y) \\ MVF(PU(x0 + ((x) << hshift)), PU(y0 + ((y) << vshift))) #define ISINTRA(x, y) \\ (MVFPU(x, y).predflag == PFINTRA) #define MINTBADDRZS(x, y) \\ s->ps.pps->mintbaddrzs[(y) * (s->ps.sps->tbmask+2) + (x)] #define EXTEND(ptr, val, len) \\ do { \\ pixel4 pix = PIXELSPLATX4(val); \\ for (i = 0; i < (len); i += 4) \\ AVWN4P(ptr + i, pix); \\ } while (0) #define EXTENDRIGHTCIP(ptr, start, length) \\ for (i = start; i < (start) + (length); i += 4) \\ if (!ISINTRA(i, -1)) \\ AVWN4P(&ptr[i], a); \\ else \\ a = PIXELSPLATX4(ptr[i+3]) #define EXTENDLEFTCIP(ptr, start, length) \\ for (i = start; i > (start) - (length); i--) \\ if (!ISINTRA(i - 1, -1)) \\ ptr[i - 1] = ptr[i] #define EXTENDUPCIP(ptr, start, length) \\ for (i = (start); i > (start) - (length); i -= 4) \\ if (!ISINTRA(-1, i - 3)) \\ AVWN4P(&ptr[i - 3], a); \\ else \\ a = PIXELSPLATX4(ptr[i - 3]) #define EXTENDDOWNCIP(ptr, start, length) \\ for (i = start; i < (start) + (length); i += 4) \\ if (!ISINTRA(-1, i)) \\ AVWN4P(&ptr[i], a); \\ else \\ a = PIXELSPLATX4(ptr[i + 3]) HEVCLocalContext *lc = s->HEVClc; int i; int hshift = s->ps.sps->hshift[cidx]; int vshift = s->ps.sps->vshift[cidx]; int size = (1 << log2size); int sizeinlumah = size << hshift; int sizeintbsh = sizeinlumah >> s->ps.sps->log2mintbsize; int sizeinlumav = size << vshift; int sizeintbsv = sizeinlumav >> s->ps.sps->log2mintbsize; int x = x0 >> hshift; int y = y0 >> vshift; int xtb = (x0 >> s->ps.sps->log2mintbsize) & s->ps.sps->tbmask; int ytb = (y0 >> s->ps.sps->log2mintbsize) & s->ps.sps->tbmask; int curtbaddr = MINTBADDRZS(xtb, ytb); ptrdifft stride = s->frame->linesize[cidx] / sizeof(pixel); pixel *src = (pixel*)s->frame->data[cidx] + x + y * stride; int minpuwidth = s->ps.sps->minpuwidth; enum IntraPredMode mode = cidx ? lc->tu.intrapredmodec : lc->tu.intrapredmode; pixel4 a; pixel leftarray[2 * MAXTBSIZE + 1]; pixel filteredleftarray[2 * MAXTBSIZE + 1]; pixel toparray[2 * MAXTBSIZE + 1]; pixel filteredtoparray[2 * MAXTBSIZE + 1]; pixel *left = leftarray + 1; pixel *top = toparray + 1; pixel *filteredleft = filteredleftarray + 1; pixel *filteredtop = filteredtoparray + 1; int candbottomleft = lc->na.candbottomleft && curtbaddr > MINTBADDRZS( xtb - 1, (ytb + sizeintbsv) & s->ps.sps->tbmask); int candleft = lc->na.candleft; int candupleft = lc->na.candupleft; int candup = lc->na.candup; int candupright = lc->na.candupright && curtbaddr > MINTBADDRZS((xtb + sizeintbsh) & s->ps.sps->tbmask, ytb - 1); int bottomleftsize = (FFMIN(y0 + 2 * sizeinlumav, s->ps.sps->height) - (y0 + sizeinlumav)) >> vshift; int toprightsize = (FFMIN(x0 + 2 * sizeinlumah, s->ps.sps->width) - (x0 + sizeinlumah)) >> hshift; if (s->ps.pps->constrainedintrapredflag == 1) { int sizeinlumapuv = PU(sizeinlumav); int sizeinlumapuh = PU(sizeinlumah); int onpuedgex = !avmoduintp2(x0, s->ps.sps->log2minpusize); int onpuedgey = !avmoduintp2(y0, s->ps.sps->log2minpusize); if (!sizeinlumapuh) sizeinlumapuh++; if (candbottomleft == 1 && onpuedgex) { int xleftpu = PU(x0 - 1); int ybottompu = PU(y0 + sizeinlumav); int max = FFMIN(sizeinlumapuv, s->ps.sps->minpuheight - ybottompu); candbottomleft = 0; for (i = 0; i < max; i += 2) candbottomleft |= (MVF(xleftpu, ybottompu + i).predflag == PFINTRA); } if (candleft == 1 && onpuedgex) { int xleftpu = PU(x0 - 1); int yleftpu = PU(y0); int max = FFMIN(sizeinlumapuv, s->ps.sps->minpuheight - yleftpu); candleft = 0; for (i = 0; i < max; i += 2) candleft |= (MVF(xleftpu, yleftpu + i).predflag == PFINTRA); } if (candupleft == 1) { int xleftpu = PU(x0 - 1); int ytoppu = PU(y0 - 1); candupleft = MVF(xleftpu, ytoppu).predflag == PFINTRA; } if (candup == 1 && onpuedgey) { int xtoppu = PU(x0); int ytoppu = PU(y0 - 1); int max = FFMIN(sizeinlumapuh, s->ps.sps->minpuwidth - xtoppu); candup = 0; for (i = 0; i < max; i += 2) candup |= (MVF(xtoppu + i, ytoppu).predflag == PFINTRA); } if (candupright == 1 && onpuedgey) { int ytoppu = PU(y0 - 1); int xrightpu = PU(x0 + sizeinlumah); int max = FFMIN(sizeinlumapuh, s->ps.sps->minpuwidth - xrightpu); candupright = 0; for (i = 0; i < max; i += 2) candupright |= (MVF(xrightpu + i, ytoppu).predflag == PFINTRA); } memset(left, 128, 2 * MAXTBSIZE*sizeof(pixel)); memset(top , 128, 2 * MAXTBSIZE*sizeof(pixel)); top[-1] = 128; } if (candupleft) { left[-1] = POS(-1, -1); top[-1] = left[-1]; } if (candup) memcpy(top, src - stride, size * sizeof(pixel)); if (candupright) { memcpy(top + size, src - stride + size, size * sizeof(pixel)); EXTEND(top + size + toprightsize, POS(size + toprightsize - 1, -1), size - toprightsize); } if (candleft) for (i = 0; i < size; i++) left[i] = POS(-1, i); if (candbottomleft) { for (i = size; i < size + bottomleftsize; i++) left[i] = POS(-1, i); EXTEND(left + size + bottomleftsize, POS(-1, size + bottomleftsize - 1), size - bottomleftsize); } if (s->ps.pps->constrainedintrapredflag == 1) { if (candbottomleft || candleft || candupleft || candup || candupright) { int sizemaxx = x0 + ((2 * size) << hshift) < s->ps.sps->width ? 2 * size : (s->ps.sps->width - x0) >> hshift; int sizemaxy = y0 + ((2 * size) << vshift) < s->ps.sps->height ? 2 * size : (s->ps.sps->height - y0) >> vshift; int j = size + (candbottomleft? bottomleftsize: 0) -1; if (!candupright) { sizemaxx = x0 + ((size) << hshift) < s->ps.sps->width ? size : (s->ps.sps->width - x0) >> hshift; } if (!candbottomleft) { sizemaxy = y0 + (( size) << vshift) < s->ps.sps->height ? size : (s->ps.sps->height - y0) >> vshift; } if (candbottomleft || candleft || candupleft) { while (j > -1 && !ISINTRA(-1, j)) j--; if (!ISINTRA(-1, j)) { j = 0; while (j < sizemaxx && !ISINTRA(j, -1)) j++; EXTENDLEFTCIP(top, j, j + 1); left[-1] = top[-1]; } } else { j = 0; while (j < sizemaxx && !ISINTRA(j, -1)) j++; if (j > 0) if (x0 > 0) { EXTENDLEFTCIP(top, j, j + 1); } else { EXTENDLEFTCIP(top, j, j); top[-1] = top[0]; } left[-1] = top[-1]; } left[-1] = top[-1]; if (candbottomleft || candleft) { a = PIXELSPLATX4(left[-1]); EXTENDDOWNCIP(left, 0, sizemaxy); } if (!candleft) EXTEND(left, left[-1], size); if (!candbottomleft) EXTEND(left + size, left[size - 1], size); if (x0 != 0 && y0 != 0) { a = PIXELSPLATX4(left[sizemaxy - 1]); EXTENDUPCIP(left, sizemaxy - 1, sizemaxy); if (!ISINTRA(-1, - 1)) left[-1] = left[0]; } else if (x0 == 0) { EXTEND(left, 0, sizemaxy); } else { a = PIXELSPLATX4(left[sizemaxy - 1]); EXTENDUPCIP(left, sizemaxy - 1, sizemaxy); } top[-1] = left[-1]; if (y0 != 0) { a = PIXELSPLATX4(left[-1]); EXTENDRIGHTCIP(top, 0, sizemaxx); } } } // Infer the unavailable samples if (!candbottomleft) { if (candleft) { EXTEND(left + size, left[size - 1], size); } else if (candupleft) { EXTEND(left, left[-1], 2 * size); candleft = 1; } else if (candup) { left[-1] = top[0]; EXTEND(left, left[-1], 2 * size); candupleft = 1; candleft = 1; } else if (candupright) { EXTEND(top, top[size], size); left[-1] = top[size]; EXTEND(left, left[-1], 2 * size); candup = 1; candupleft = 1; candleft = 1; } else { // No samples available left[-1] = (1 << (BITDEPTH - 1)); EXTEND(top, left[-1], 2 * size); EXTEND(left, left[-1], 2 * size); } } if (!candleft) EXTEND(left, left[size], size); if (!candupleft) { left[-1] = left[0]; } if (!candup) EXTEND(top, left[-1], size); if (!candupright) EXTEND(top + size, top[size - 1], size); top[-1] = left[-1]; // Filtering process if (!s->ps.sps->intrasmoothingdisabledflag && (cidx == 0 || s->ps.sps->chromaformatidc == 3)) { if (mode != INTRADC && size != 4){ int intrahorverdistthresh[] = { 7, 1, 0 }; int mindistverthor = FFMIN(FFABS((int)(mode - 26U)), FFABS((int)(mode - 10U))); if (mindistverthor > intrahorverdistthresh[log2size - 3]) { int threshold = 1 << (BITDEPTH - 5); if (s->ps.sps->spsstrongintrasmoothingenableflag && cidx == 0 && log2size == 5 && FFABS(top[-1] + top[63] - 2 * top[31]) < threshold && FFABS(left[-1] + left[63] - 2 * left[31]) < threshold) { // We can't just overwrite values in top because it could be // a pointer into src filteredtop[-1] = top[-1]; filteredtop[63] = top[63]; for (i = 0; i < 63; i++) filteredtop[i] = ((64 - (i + 1)) * top[-1] + (i + 1) * top[63] + 32) >> 6; for (i = 0; i < 63; i++) left[i] = ((64 - (i + 1)) * left[-1] + (i + 1) * left[63] + 32) >> 6; top = filteredtop; } else { filteredleft[2 * size - 1] = left[2 * size - 1]; filteredtop[2 * size - 1] = top[2 * size - 1]; for (i = 2 * size - 2; i >= 0; i--) filteredleft[i] = (left[i + 1] + 2 * left[i] + left[i - 1] + 2) >> 2; filteredtop[-1] = filteredleft[-1] = (left[0] + 2 * left[-1] + top[0] + 2) >> 2; for (i = 2 * size - 2; i >= 0; i--) filteredtop[i] = (top[i + 1] + 2 * top[i] + top[i - 1] + 2) >> 2; left = filteredleft; top = filteredtop; } } } } switch (mode) { case INTRAPLANAR: s->hpc.predplanar[log2size - 2]((uint8t *)src, (uint8t *)top, (uint8t *)left, stride); break; case INTRADC: s->hpc.preddc((uint8t *)src, (uint8t *)top, (uint8t *)left, stride, log2size, cidx); break; default: s->hpc.predangular[log2size - 2]((uint8t *)src, (uint8t *)top, (uint8t *)left, stride, cidx, mode); break; } } ", "target": 1}
{"func": "static void endlastframe(AVFilterContext *ctx) { TileContext *tile = ctx->priv; AVFilterLink *outlink = ctx->outputs[0]; AVFilterBufferRef *outbuf = outlink->outbuf; outlink->outbuf = NULL; ffstartframe(outlink, outbuf); while (tile->current < tile->nbframes) drawblankframe(ctx, outbuf); ffdrawslice(outlink, 0, outbuf->video->h, 1); ffendframe(outlink); tile->current = 0; } ", "target": 0}
{"func": "void avregisteroutputformat(AVOutputFormat *format) { AVOutputFormat **p = &firstoformat; while (*p != NULL) p = &(*p)->next; *p = format; format->next = NULL; } ", "target": 0}
{"func": "static void decode32Bitopc(CPUTriCoreState *env, DisasContext *ctx) { int op1; int32t r1, r2, r3; int32t address, const16; int8t b, const4; int32t bpos; TCGv temp, temp2, temp3; op1 = MASKOPMAJOR(ctx->opcode); /* handle JNZ.T opcode only being 7 bit long */ if (unlikely((op1 & 0x7f) == OPCM32BRNJTT)) { op1 = OPCM32BRNJTT; } switch (op1) { /* ABS-format */ case OPCM32ABSLDW: decodeabsldw(env, ctx); case OPCM32ABSLDB: decodeabsldb(env, ctx); case OPCM32ABSLDMSTSWAP: decodeabsldstswap(env, ctx); case OPCM32ABSLDSTCONTEXT: decodeabsldstcontext(env, ctx); case OPCM32ABSSTORE: decodeabsstore(env, ctx); case OPCM32ABSSTOREBH: decodeabsstorebh(env, ctx); case OPC132ABSSTOREQ: address = MASKOPABSOFF18(ctx->opcode); r1 = MASKOPABSS1D(ctx->opcode); temp = tcgconsti32(EAABSFORMAT(address)); temp2 = tcgtempnew(); tcggenshritl(temp2, cpugprd[r1], 16); tcggenqemusttl(temp2, temp, ctx->memidx, MOLEUW); tcgtempfree(temp2); tcgtempfree(temp); case OPC132ABSLDQ: address = MASKOPABSOFF18(ctx->opcode); r1 = MASKOPABSS1D(ctx->opcode); temp = tcgconsti32(EAABSFORMAT(address)); tcggenqemuldtl(cpugprd[r1], temp, ctx->memidx, MOLEUW); tcggenshlitl(cpugprd[r1], cpugprd[r1], 16); tcgtempfree(temp); case OPC132ABSLEA: address = MASKOPABSOFF18(ctx->opcode); r1 = MASKOPABSS1D(ctx->opcode); tcggenmovitl(cpugpra[r1], EAABSFORMAT(address)); /* ABSB-format */ case OPC132ABSBSTT: address = MASKOPABSOFF18(ctx->opcode); b = MASKOPABSBB(ctx->opcode); bpos = MASKOPABSBBPOS(ctx->opcode); temp = tcgconsti32(EAABSFORMAT(address)); temp2 = tcgtempnew(); tcggenqemuldtl(temp2, temp, ctx->memidx, MOUB); tcggenanditl(temp2, temp2, ~(0x1u << bpos)); tcggenoritl(temp2, temp2, (b << bpos)); tcggenqemusttl(temp2, temp, ctx->memidx, MOUB); tcgtempfree(temp); tcgtempfree(temp2); /* B-format */ case OPC132BCALL: case OPC132BCALLA: case OPC132BJ: case OPC132BJA: case OPC132BJL: case OPC132BJLA: address = MASKOPBDISP24(ctx->opcode); gencomputebranch(ctx, op1, 0, 0, 0, address); /* Bit-format */ case OPCM32BITANDACC: decodebitandacc(env, ctx); case OPCM32BITLOGICALT1: decodebitlogicalt(env, ctx); case OPCM32BITINSERT: decodebitinsert(env, ctx); case OPCM32BITLOGICALT2: decodebitlogicalt2(env, ctx); case OPCM32BITORAND: decodebitorand(env, ctx); case OPCM32BITSHLOGIC1: decodebitshlogic1(env, ctx); case OPCM32BITSHLOGIC2: decodebitshlogic2(env, ctx); /* BO Format */ case OPCM32BOADDRMODEPOSTPREBASE: decodeboaddrmodepostprebase(env, ctx); case OPCM32BOADDRMODEBITREVERSECIRCULAR: decodeboaddrmodebitreversecircular(env, ctx); case OPCM32BOADDRMODELDPOSTPREBASE: decodeboaddrmodeldpostprebase(env, ctx); case OPCM32BOADDRMODELDBITREVERSECIRCULAR: decodeboaddrmodeldbitreversecircular(env, ctx); case OPCM32BOADDRMODESTCTXPOSTPREBASE: decodeboaddrmodestctxpostprebase(env, ctx); case OPCM32BOADDRMODELDMSTBITREVERSECIRCULAR: decodeboaddrmodeldmstbitreversecircular(env, ctx); /* BOL-format */ case OPC132BOLLDALONGOFF: case OPC132BOLLDWLONGOFF: case OPC132BOLLEALONGOFF: case OPC132BOLSTWLONGOFF: case OPC132BOLSTALONGOFF: decodebolopc(env, ctx, op1); /* BRC Format */ case OPCM32BRCEQNEQ: case OPCM32BRCGE: case OPCM32BRCJLT: case OPCM32BRCJNE: const4 = MASKOPBRCCONST4SEXT(ctx->opcode); address = MASKOPBRCDISP15SEXT(ctx->opcode); r1 = MASKOPBRCS1(ctx->opcode); gencomputebranch(ctx, op1, r1, 0, const4, address); /* BRN Format */ case OPCM32BRNJTT: address = MASKOPBRNDISP15SEXT(ctx->opcode); r1 = MASKOPBRNS1(ctx->opcode); gencomputebranch(ctx, op1, r1, 0, 0, address); /* BRR Format */ case OPCM32BRREQNEQ: case OPCM32BRRADDREQNEQ: case OPCM32BRRGE: case OPCM32BRRJLT: case OPCM32BRRJNE: case OPCM32BRRJNZ: case OPCM32BRRLOOP: address = MASKOPBRRDISP15SEXT(ctx->opcode); r2 = MASKOPBRRS2(ctx->opcode); r1 = MASKOPBRRS1(ctx->opcode); gencomputebranch(ctx, op1, r1, r2, 0, address); /* RC Format */ case OPCM32RCLOGICALSHIFT: decoderclogicalshift(env, ctx); case OPCM32RCACCUMULATOR: decodercaccumulator(env, ctx); case OPCM32RCSERVICEROUTINE: decodercserviceroutine(env, ctx); case OPCM32RCMUL: decodercmul(env, ctx); /* RCPW Format */ case OPCM32RCPWMASKINSERT: decodercpwinsert(env, ctx); /* RCRR Format */ case OPC132RCRRINSERT: r1 = MASKOPRCRRS1(ctx->opcode); r2 = MASKOPRCRRS3(ctx->opcode); r3 = MASKOPRCRRD(ctx->opcode); const16 = MASKOPRCRRCONST4(ctx->opcode); temp = tcgconsti32(const16); temp2 = tcgtempnew(); /* width*/ temp3 = tcgtempnew(); /* pos */ tcggenanditl(temp2, cpugprd[r3+1], 0x1f); tcggenanditl(temp3, cpugprd[r3], 0x1f); geninsert(cpugprd[r2], cpugprd[r1], temp, temp2, temp3); tcgtempfree(temp); tcgtempfree(temp2); tcgtempfree(temp3); /* RCRW Format */ case OPCM32RCRWMASKINSERT: decodercrwinsert(env, ctx); /* RCR Format */ case OPCM32RCRCONDSELECT: decodercrcondselect(env, ctx); case OPCM32RCRMADD: decodercrmadd(env, ctx); case OPCM32RCRMSUB: decodercrmsub(env, ctx); /* RLC Format */ case OPC132RLCADDI: case OPC132RLCADDIH: case OPC132RLCADDIHA: case OPC132RLCMFCR: case OPC132RLCMOV: case OPC132RLCMOV64: case OPC132RLCMOVU: case OPC132RLCMOVH: case OPC132RLCMOVHA: case OPC132RLCMTCR: decoderlcopc(env, ctx, op1); } }", "target": 1}
{"func": "AVFilterBufferRef *avfiltergetvideobufferreffromframe(const AVFrame *frame, int perms) { AVFilterBufferRef *picref = avfiltergetvideobufferreffromarrays(frame->data, frame->linesize, perms, frame->width, frame->height, frame->format); if (!picref) return NULL; avfiltercopyframeprops(picref, frame); return picref; } ", "target": 0}
{"func": "void *grealloc(void *ptr, sizet size) { sizet oldsize, copy; void *newptr; if (!ptr) return gmalloc(size); oldsize = *(sizet *)((char *)ptr - 16); copy = oldsize < size ? oldsize : size; newptr = gmalloc(size); memcpy(newptr, ptr, copy); gfree(ptr); return newptr; } ", "target": 1}
{"func": "static OutputStream *newaudiostream(OptionsContext *o, AVFormatContext *oc) { AVStream *st; OutputStream *ost; AVCodecContext *audioenc; ost = newoutputstream(o, oc, AVMEDIATYPEAUDIO); st = ost->st; audioenc = st->codec; audioenc->codectype = AVMEDIATYPEAUDIO; if (!ost->streamcopy) { char *samplefmt = NULL; MATCHPERSTREAMOPT(audiochannels, i, audioenc->channels, oc, st); MATCHPERSTREAMOPT(samplefmts, str, samplefmt, oc, st); if (samplefmt && (audioenc->samplefmt = avgetsamplefmt(samplefmt)) == AVSAMPLEFMTNONE) { avlog(NULL, AVLOGFATAL, \"Invalid sample format '%s'\\n\", samplefmt); exitprogram(1); } MATCHPERSTREAMOPT(audiosamplerate, i, audioenc->samplerate, oc, st); } return ost; } ", "target": 1}
{"func": "static int pcxdecodeframe(AVCodecContext *avctx, void *data, int *gotframe, AVPacket *avpkt) { const uint8t *buf = avpkt->data; int bufsize = avpkt->size; AVFrame *const p = data; int compressed, xmin, ymin, xmax, ymax; unsigned int w, h, bitsperpixel, bytesperline, nplanes, stride, y, x, bytesperscanline; uint8t *ptr; const uint8t *bufend = buf + bufsize; const uint8t *bufstart = buf; uint8t *scanline; int ret = -1; if (buf[0] != 0x0a || buf[1] > 5) { avlog(avctx, AVLOGERROR, \"this is not PCX encoded data\\n\"); compressed = buf[2]; xmin = AVRL16(buf + 4); ymin = AVRL16(buf + 6); xmax = AVRL16(buf + 8); ymax = AVRL16(buf + 10); if (xmax < xmin || ymax < ymin) { avlog(avctx, AVLOGERROR, \"invalid image dimensions\\n\"); w = xmax - xmin + 1; h = ymax - ymin + 1; bitsperpixel = buf[3]; bytesperline = AVRL16(buf + 66); nplanes = buf[65]; bytesperscanline = nplanes * bytesperline; if (bytesperscanline < (w * bitsperpixel * nplanes + 7) / 8 || (!compressed && bytesperscanline > bufsize / h)) { avlog(avctx, AVLOGERROR, \"PCX data is corrupted\\n\"); switch ((nplanes << 8) + bitsperpixel) { case 0x0308: avctx->pixfmt = AVPIXFMTRGB24; break; case 0x0108: case 0x0104: case 0x0102: case 0x0101: case 0x0401: case 0x0301: case 0x0201: avctx->pixfmt = AVPIXFMTPAL8; break; default: avlog(avctx, AVLOGERROR, \"invalid PCX file\\n\"); buf += 128; if ((ret = ffsetdimensions(avctx, w, h)) < 0) return ret; if ((ret = ffgetbuffer(avctx, p, 0)) < 0) { avlog(avctx, AVLOGERROR, \"getbuffer() failed\\n\"); return ret; p->picttype = AVPICTURETYPEI; ptr = p->data[0]; stride = p->linesize[0]; scanline = avmalloc(bytesperscanline + AVINPUTBUFFERPADDINGSIZE); if (!scanline) return AVERROR(ENOMEM); if (nplanes == 3 && bitsperpixel == 8) { for (y = 0; y < h; y++) { buf = pcxrledecode(buf, bufend, scanline, bytesperscanline, compressed); for (x = 0; x < w; x++) { ptr[3 * x] = scanline[x]; ptr[3 * x + 1] = scanline[x + bytesperline]; ptr[3 * x + 2] = scanline[x + (bytesperline << 1)]; ptr += stride; } else if (nplanes == 1 && bitsperpixel == 8) { const uint8t *palstart = bufstart + bufsize - 769; if (bufsize < 769) { avlog(avctx, AVLOGERROR, \"File is too short\\n\"); ret = avctx->errrecognition & AVEFEXPLODE ? AVERRORINVALIDDATA : bufsize; goto end; for (y = 0; y < h; y++, ptr += stride) { buf = pcxrledecode(buf, bufend, scanline, bytesperscanline, compressed); memcpy(ptr, scanline, w); if (buf != palstart) { avlog(avctx, AVLOGWARNING, \"image data possibly corrupted\\n\"); buf = palstart; if (*buf++ != 12) { avlog(avctx, AVLOGERROR, \"expected palette after image data\\n\"); ret = avctx->errrecognition & AVEFEXPLODE ? AVERRORINVALIDDATA : bufsize; goto end; } else if (nplanes == 1) { /* all packed formats, max. 16 colors */ GetBitContext s; for (y = 0; y < h; y++) { initgetbits(&s, scanline, bytesperscanline << 3); buf = pcxrledecode(buf, bufend, scanline, bytesperscanline, compressed); for (x = 0; x < w; x++) ptr[x] = getbits(&s, bitsperpixel); ptr += stride; } else { /* planar, 4, 8 or 16 colors */ int i; for (y = 0; y < h; y++) { buf = pcxrledecode(buf, bufend, scanline, bytesperscanline, compressed); for (x = 0; x < w; x++) { int m = 0x80 >> (x & 7), v = 0; for (i = nplanes - 1; i >= 0; i--) { v <<= 1; v += !!(scanline[i * bytesperline + (x >> 3)] & m); ptr[x] = v; ptr += stride; if (nplanes == 1 && bitsperpixel == 8) { pcxpalette(&buf, (uint32t *)p->data[1], 256); } else if (bitsperpixel < 8) { const uint8t *palette = bufstart + 16; pcxpalette(&palette, (uint32t *)p->data[1], 16); *gotframe = 1; ret = buf - bufstart; end: avfree(scanline); return ret;", "target": 1}
{"func": "static void ioportwrite(void *opaque, uint32t addr, uint32t val) { PCIQXLDevice *d = opaque; uint32t ioport = addr - d->iobase; switch (ioport) { case QXLIORESET: case QXLIOSETMODE: case QXLIOMEMSLOTADD: case QXLIOMEMSLOTDEL: case QXLIOCREATEPRIMARY: break; default: if (d->mode == QXLMODENATIVE || d->mode == QXLMODECOMPAT) break; dprint(d, 1, \"%s: unexpected port 0x%x in vga mode\\n\", FUNCTION, ioport); return; } switch (ioport) { case QXLIOUPDATEAREA: { QXLRect update = d->ram->updatearea; qemumutexunlockiothread(); d->ssd.worker->updatearea(d->ssd.worker, d->ram->updatesurface, &update, NULL, 0, 0); qemumutexlockiothread(); break; } case QXLIONOTIFYCMD: d->ssd.worker->wakeup(d->ssd.worker); break; case QXLIONOTIFYCURSOR: d->ssd.worker->wakeup(d->ssd.worker); break; case QXLIOUPDATEIRQ: qxlsetirq(d); break; case QXLIONOTIFYOOM: if (!SPICERINGISEMPTY(&d->ram->releasering)) { break; } pthreadyield(); if (!SPICERINGISEMPTY(&d->ram->releasering)) { break; } d->oomrunning = 1; d->ssd.worker->oom(d->ssd.worker); d->oomrunning = 0; break; case QXLIOSETMODE: dprint(d, 1, \"QXLSETMODE %d\\n\", val); qxlsetmode(d, val, 0); break; case QXLIOLOG: if (d->guestdebug) { fprintf(stderr, \"qxl/guest: %s\", d->ram->logbuf); } break; case QXLIORESET: dprint(d, 1, \"QXLIORESET\\n\"); qxlhardreset(d, 0); break; case QXLIOMEMSLOTADD: PANICON(val >= NUMMEMSLOTS); PANICON(d->guestslots[val].active); d->guestslots[val].slot = d->ram->memslot; qxladdmemslot(d, val, 0); break; case QXLIOMEMSLOTDEL: qxldelmemslot(d, val); break; case QXLIOCREATEPRIMARY: PANICON(val != 0); dprint(d, 1, \"QXLIOCREATEPRIMARY\\n\"); d->guestprimary.surface = d->ram->createsurface; qxlcreateguestprimary(d, 0); break; case QXLIODESTROYPRIMARY: PANICON(val != 0); dprint(d, 1, \"QXLIODESTROYPRIMARY\\n\"); qxldestroyprimary(d); break; case QXLIODESTROYSURFACEWAIT: d->ssd.worker->destroysurfacewait(d->ssd.worker, val); break; case QXLIODESTROYALLSURFACES: d->ssd.worker->destroysurfaces(d->ssd.worker); break; default: fprintf(stderr, \"%s: ioport=0x%x, abort()\\n\", FUNCTION, ioport); abort(); } } ", "target": 1}
{"func": "static int h264sliceheaderparse(H264Context *h, H264SliceContext *sl) { const SPS *sps; const PPS *pps; unsigned int firstmbinslice; unsigned int ppsid; int ret; unsigned int slicetype, tmp, i; int lastpicstructure, lastpicdroppable; int needsreinit = 0; int fieldpicflag, bottomfieldflag; int framenum, droppable, picturestructure; int mbaffframe = 0; firstmbinslice = getuegolomb(&sl->gb); if (firstmbinslice == 0) { // FIXME better field boundary detection if (h->currentslice && h->curpicptr && FIELDPICTURE(h)) { ffh264fieldend(h, sl, 1); } h->currentslice = 0; if (!h->firstfield) { if (h->curpicptr && !h->droppable) { ffthreadreportprogress(&h->curpicptr->tf, INTMAX, h->picturestructure == PICTBOTTOMFIELD); } h->curpicptr = NULL; } } slicetype = getuegolomb31(&sl->gb); if (slicetype > 9) { avlog(h->avctx, AVLOGERROR, \"slice type %d too large at %d\\n\", slicetype, firstmbinslice); return AVERRORINVALIDDATA; } if (slicetype > 4) { slicetype -= 5; sl->slicetypefixed = 1; } else sl->slicetypefixed = 0; slicetype = ffh264golombtopicttype[slicetype]; sl->slicetype = slicetype; sl->slicetypenos = slicetype & 3; if (h->nalunittype == NALIDRSLICE && sl->slicetypenos != AVPICTURETYPEI) { avlog(h->avctx, AVLOGERROR, \"A non-intra slice in an IDR NAL unit.\\n\"); return AVERRORINVALIDDATA; } ppsid = getuegolomb(&sl->gb); if (ppsid >= MAXPPSCOUNT) { avlog(h->avctx, AVLOGERROR, \"ppsid %u out of range\\n\", ppsid); return AVERRORINVALIDDATA; } if (!h->ps.ppslist[ppsid]) { avlog(h->avctx, AVLOGERROR, \"non-existing PPS %u referenced\\n\", ppsid); return AVERRORINVALIDDATA; } if (!h->setupfinished) { h->ps.pps = (const PPS*)h->ps.ppslist[ppsid]->data; } else if (h->ps.pps != (const PPS*)h->ps.ppslist[ppsid]->data) { avlog(h->avctx, AVLOGERROR, \"PPS changed between slices\\n\"); return AVERRORINVALIDDATA; } if (!h->ps.spslist[h->ps.pps->spsid]) { avlog(h->avctx, AVLOGERROR, \"non-existing SPS %u referenced\\n\", h->ps.pps->spsid); return AVERRORINVALIDDATA; } if (h->ps.sps != (const SPS*)h->ps.spslist[h->ps.pps->spsid]->data) { h->ps.sps = (SPS*)h->ps.spslist[h->ps.pps->spsid]->data; if (h->bitdepthluma != h->ps.sps->bitdepthluma || h->chromaformatidc != h->ps.sps->chromaformatidc) needsreinit = 1; } pps = h->ps.pps; sps = h->ps.sps; if (!h->setupfinished) { h->avctx->profile = ffh264getprofile(sps); h->avctx->level = sps->levelidc; h->avctx->refs = sps->refframecount; if (h->mbwidth != sps->mbwidth || h->mbheight != sps->mbheight * (2 - sps->framembsonlyflag)) needsreinit = 1; h->mbwidth = sps->mbwidth; h->mbheight = sps->mbheight * (2 - sps->framembsonlyflag); h->mbnum = h->mbwidth * h->mbheight; h->mbstride = h->mbwidth + 1; h->bstride = h->mbwidth * 4; h->chromayshift = sps->chromaformatidc <= 1; // 400 uses yuv420p h->width = 16 * h->mbwidth; h->height = 16 * h->mbheight; ret = initdimensions(h); if (ret < 0) return ret; if (sps->videosignaltypepresentflag) { h->avctx->colorrange = sps->fullrange ? AVCOLRANGEJPEG : AVCOLRANGEMPEG; if (sps->colourdescriptionpresentflag) { if (h->avctx->colorspace != sps->colorspace) needsreinit = 1; h->avctx->colorprimaries = sps->colorprimaries; h->avctx->colortrc = sps->colortrc; h->avctx->colorspace = sps->colorspace; } } } if (h->contextinitialized && needsreinit) { h->contextinitialized = 0; if (sl != h->slicectx) { avlog(h->avctx, AVLOGERROR, \"changing width %d -> %d / height %d -> %d on \" \"slice %d\\n\", h->width, h->avctx->codedwidth, h->height, h->avctx->codedheight, h->currentslice + 1); return AVERRORINVALIDDATA; } ffh264flushchange(h); if ((ret = getpixelformat(h)) < 0) return ret; h->avctx->pixfmt = ret; avlog(h->avctx, AVLOGINFO, \"Reinit context to %dx%d, \" \"pixfmt: %d\\n\", h->width, h->height, h->avctx->pixfmt); if ((ret = h264sliceheaderinit(h)) < 0) { avlog(h->avctx, AVLOGERROR, \"h264sliceheaderinit() failed\\n\"); return ret; } } if (!h->contextinitialized) { if (sl != h->slicectx) { avlog(h->avctx, AVLOGERROR, \"Cannot (re-)initialize context during parallel decoding.\\n\"); return AVERRORPATCHWELCOME; } if ((ret = getpixelformat(h)) < 0) return ret; h->avctx->pixfmt = ret; if ((ret = h264sliceheaderinit(h)) < 0) { avlog(h->avctx, AVLOGERROR, \"h264sliceheaderinit() failed\\n\"); return ret; } } framenum = getbits(&sl->gb, sps->log2maxframenum); if (!h->setupfinished) h->poc.framenum = framenum; sl->mbmbaff = 0; lastpicstructure = h->picturestructure; lastpicdroppable = h->droppable; droppable = h->nalrefidc == 0; if (sps->framembsonlyflag) { picturestructure = PICTFRAME; } else { fieldpicflag = getbits1(&sl->gb); if (fieldpicflag) { bottomfieldflag = getbits1(&sl->gb); picturestructure = PICTTOPFIELD + bottomfieldflag; } else { picturestructure = PICTFRAME; mbaffframe = sps->mbaff; } } if (!h->setupfinished) { h->droppable = droppable; h->picturestructure = picturestructure; h->mbaffframe = mbaffframe; } sl->mbfielddecodingflag = h->picturestructure != PICTFRAME; if (h->currentslice != 0) { if (lastpicstructure != picturestructure || lastpicdroppable != droppable) { avlog(h->avctx, AVLOGERROR, \"Changing field mode (%d -> %d) between slices is not allowed\\n\", lastpicstructure, h->picturestructure); return AVERRORINVALIDDATA; } else if (!h->curpicptr) { avlog(h->avctx, AVLOGERROR, \"unset curpicptr on slice %d\\n\", h->currentslice + 1); return AVERRORINVALIDDATA; } } else { /* Shorten frame num gaps so we don't have to allocate reference * frames just to throw them away */ if (h->poc.framenum != h->poc.prevframenum) { int unwrapprevframenum = h->poc.prevframenum; int maxframenum = 1 << sps->log2maxframenum; if (unwrapprevframenum > h->poc.framenum) unwrapprevframenum -= maxframenum; if ((h->poc.framenum - unwrapprevframenum) > sps->refframecount) { unwrapprevframenum = (h->poc.framenum - sps->refframecount) - 1; if (unwrapprevframenum < 0) unwrapprevframenum += maxframenum; h->poc.prevframenum = unwrapprevframenum; } } /* See if we have a decoded first field looking for a pair... * Here, we're using that to see if we should mark previously * decode frames as \"finished\". * We have to do that before the \"dummy\" in-between frame allocation, * since that can modify s->currentpictureptr. */ if (h->firstfield) { assert(h->curpicptr); assert(h->curpicptr->f->buf[0]); assert(h->curpicptr->reference != DELAYEDPICREF); /* figure out if we have a complementary field pair */ if (!FIELDPICTURE(h) || h->picturestructure == lastpicstructure) { /* Previous field is unmatched. Don't display it, but let it * remain for reference if marked as such. */ if (!lastpicdroppable && lastpicstructure != PICTFRAME) { ffthreadreportprogress(&h->curpicptr->tf, INTMAX, lastpicstructure == PICTTOPFIELD); } } else { if (h->curpicptr->framenum != h->poc.framenum) { /* This and previous field were reference, but had * different framenums. Consider this field first in * pair. Throw away previous field except for reference * purposes. */ if (!lastpicdroppable && lastpicstructure != PICTFRAME) { ffthreadreportprogress(&h->curpicptr->tf, INTMAX, lastpicstructure == PICTTOPFIELD); } } else { /* Second field in complementary pair */ if (!((lastpicstructure == PICTTOPFIELD && h->picturestructure == PICTBOTTOMFIELD) || (lastpicstructure == PICTBOTTOMFIELD && h->picturestructure == PICTTOPFIELD))) { avlog(h->avctx, AVLOGERROR, \"Invalid field mode combination %d/%d\\n\", lastpicstructure, h->picturestructure); h->picturestructure = lastpicstructure; h->droppable = lastpicdroppable; return AVERRORINVALIDDATA; } else if (lastpicdroppable != h->droppable) { avprivrequestsample(h->avctx, \"Found reference and non-reference fields in the same frame, which\"); h->picturestructure = lastpicstructure; h->droppable = lastpicdroppable; return AVERRORPATCHWELCOME; } } } } while (h->poc.framenum != h->poc.prevframenum && h->poc.framenum != (h->poc.prevframenum + 1) % (1 << sps->log2maxframenum)) { H264Picture *prev = h->shortrefcount ? h->shortref[0] : NULL; avlog(h->avctx, AVLOGDEBUG, \"Frame num gap %d %d\\n\", h->poc.framenum, h->poc.prevframenum); ret = initializecurframe(h); if (ret < 0) { h->firstfield = 0; return ret; } h->poc.prevframenum++; h->poc.prevframenum %= 1 << sps->log2maxframenum; h->curpicptr->framenum = h->poc.prevframenum; ffthreadreportprogress(&h->curpicptr->tf, INTMAX, 0); ffthreadreportprogress(&h->curpicptr->tf, INTMAX, 1); ret = ffgenerateslidingwindowmmcos(h, 1); if (ret < 0 && (h->avctx->errrecognition & AVEFEXPLODE)) return ret; ret = ffh264executerefpicmarking(h, h->mmco, h->mmcoindex); if (ret < 0 && (h->avctx->errrecognition & AVEFEXPLODE)) return ret; /* Error concealment: If a ref is missing, copy the previous ref * in its place. * FIXME: Avoiding a memcpy would be nice, but ref handling makes * many assumptions about there being no actual duplicates. * FIXME: This does not copy padding for out-of-frame motion * vectors. Given we are concealing a lost frame, this probably * is not noticeable by comparison, but it should be fixed. */ if (h->shortrefcount) { if (prev && h->shortref[0]->f->width == prev->f->width && h->shortref[0]->f->height == prev->f->height && h->shortref[0]->f->format == prev->f->format) { avimagecopy(h->shortref[0]->f->data, h->shortref[0]->f->linesize, (const uint8t **)prev->f->data, prev->f->linesize, prev->f->format, h->mbwidth * 16, h->mbheight * 16); h->shortref[0]->poc = prev->poc + 2; } h->shortref[0]->framenum = h->poc.prevframenum; } } /* See if we have a decoded first field looking for a pair... * We're using that to see whether to continue decoding in that * frame, or to allocate a new one. */ if (h->firstfield) { assert(h->curpicptr); assert(h->curpicptr->f->buf[0]); assert(h->curpicptr->reference != DELAYEDPICREF); /* figure out if we have a complementary field pair */ if (!FIELDPICTURE(h) || h->picturestructure == lastpicstructure) { /* Previous field is unmatched. Don't display it, but let it * remain for reference if marked as such. */ h->curpicptr = NULL; h->firstfield = FIELDPICTURE(h); } else { if (h->curpicptr->framenum != h->poc.framenum) { /* This and the previous field had different framenums. * Consider this field first in pair. Throw away previous * one except for reference purposes. */ h->firstfield = 1; h->curpicptr = NULL; } else { /* Second field in complementary pair */ h->firstfield = 0; } } } else { /* Frame or first field in a potentially complementary pair */ h->firstfield = FIELDPICTURE(h); } if (!FIELDPICTURE(h) || h->firstfield) { if (h264framestart(h) < 0) { h->firstfield = 0; return AVERRORINVALIDDATA; } } else { releaseunusedpictures(h, 0); } } assert(h->mbnum == h->mbwidth * h->mbheight); if (firstmbinslice << FIELDORMBAFFPICTURE(h) >= h->mbnum || firstmbinslice >= h->mbnum) { avlog(h->avctx, AVLOGERROR, \"firstmbinslice overflow\\n\"); return AVERRORINVALIDDATA; } sl->resyncmbx = sl->mbx = firstmbinslice % h->mbwidth; sl->resyncmby = sl->mby = (firstmbinslice / h->mbwidth) << FIELDORMBAFFPICTURE(h); if (h->picturestructure == PICTBOTTOMFIELD) sl->resyncmby = sl->mby = sl->mby + 1; assert(sl->mby < h->mbheight); if (h->picturestructure == PICTFRAME) { h->currpicnum = h->poc.framenum; h->maxpicnum = 1 << sps->log2maxframenum; } else { h->currpicnum = 2 * h->poc.framenum + 1; h->maxpicnum = 1 << (sps->log2maxframenum + 1); } if (h->nalunittype == NALIDRSLICE) getuegolomb(&sl->gb); /* idrpicid */ if (sps->poctype == 0) { int poclsb = getbits(&sl->gb, sps->log2maxpoclsb); if (!h->setupfinished) h->poc.poclsb = poclsb; if (pps->picorderpresent == 1 && h->picturestructure == PICTFRAME) { int deltapocbottom = getsegolomb(&sl->gb); if (!h->setupfinished) h->poc.deltapocbottom = deltapocbottom; } } if (sps->poctype == 1 && !sps->deltapicorderalwayszeroflag) { int deltapoc = getsegolomb(&sl->gb); if (!h->setupfinished) h->poc.deltapoc[0] = deltapoc; if (pps->picorderpresent == 1 && h->picturestructure == PICTFRAME) { deltapoc = getsegolomb(&sl->gb); if (!h->setupfinished) h->poc.deltapoc[1] = deltapoc; } } if (!h->setupfinished) ffh264initpoc(h->curpicptr->fieldpoc, &h->curpicptr->poc, sps, &h->poc, h->picturestructure, h->nalrefidc); if (pps->redundantpiccntpresent) sl->redundantpiccount = getuegolomb(&sl->gb); if (sl->slicetypenos == AVPICTURETYPEB) sl->directspatialmvpred = getbits1(&sl->gb); ret = ffh264parserefcount(&sl->listcount, sl->refcount, &sl->gb, pps, sl->slicetypenos, h->picturestructure); if (ret < 0) return ret; if (sl->slicetypenos != AVPICTURETYPEI) { ret = ffh264decoderefpiclistreordering(h, sl); if (ret < 0) { sl->refcount[1] = sl->refcount[0] = 0; return ret; } } sl->pwt.useweight = 0; for (i = 0; i < 2; i++) { sl->pwt.lumaweightflag[i] = 0; sl->pwt.chromaweightflag[i] = 0; } if ((pps->weightedpred && sl->slicetypenos == AVPICTURETYPEP) || (pps->weightedbipredidc == 1 && sl->slicetypenos == AVPICTURETYPEB)) ffh264predweighttable(&sl->gb, sps, sl->refcount, sl->slicetypenos, &sl->pwt); // If frame-mt is enabled, only update mmco tables for the first slice // in a field. Subsequent slices can temporarily clobber h->mmcoindex // or h->mmco, which will cause ref list mix-ups and decoding errors // further down the line. This may break decoding if the first slice is // corrupt, thus we only do this if frame-mt is enabled. if (h->nalrefidc) { ret = ffh264decoderefpicmarking(h, &sl->gb, !(h->avctx->activethreadtype & FFTHREADFRAME) || h->currentslice == 0); if (ret < 0 && (h->avctx->errrecognition & AVEFEXPLODE)) return AVERRORINVALIDDATA; } if (sl->slicetypenos != AVPICTURETYPEI && pps->cabac) { tmp = getuegolomb31(&sl->gb); if (tmp > 2) { avlog(h->avctx, AVLOGERROR, \"cabacinitidc %u overflow\\n\", tmp); return AVERRORINVALIDDATA; } sl->cabacinitidc = tmp; } sl->lastqscalediff = 0; tmp = pps->initqp + getsegolomb(&sl->gb); if (tmp > 51 + 6 * (sps->bitdepthluma - 8)) { avlog(h->avctx, AVLOGERROR, \"QP %u out of range\\n\", tmp); return AVERRORINVALIDDATA; } sl->qscale = tmp; sl->chromaqp[0] = getchromaqp(h, 0, sl->qscale); sl->chromaqp[1] = getchromaqp(h, 1, sl->qscale); // FIXME qscale / qp ... stuff if (sl->slicetype == AVPICTURETYPESP) getbits1(&sl->gb); /* spforswitchflag */ if (sl->slicetype == AVPICTURETYPESP || sl->slicetype == AVPICTURETYPESI) getsegolomb(&sl->gb); /* sliceqsdelta */ sl->deblockingfilter = 1; sl->slicealphac0offset = 0; sl->slicebetaoffset = 0; if (pps->deblockingfilterparameterspresent) { tmp = getuegolomb31(&sl->gb); if (tmp > 2) { avlog(h->avctx, AVLOGERROR, \"deblockingfilteridc %u out of range\\n\", tmp); return AVERRORINVALIDDATA; } sl->deblockingfilter = tmp; if (sl->deblockingfilter < 2) sl->deblockingfilter ^= 1; // 1<->0 if (sl->deblockingfilter) { sl->slicealphac0offset = getsegolomb(&sl->gb) * 2; sl->slicebetaoffset = getsegolomb(&sl->gb) * 2; if (sl->slicealphac0offset > 12 || sl->slicealphac0offset < -12 || sl->slicebetaoffset > 12 || sl->slicebetaoffset < -12) { avlog(h->avctx, AVLOGERROR, \"deblocking filter parameters %d %d out of range\\n\", sl->slicealphac0offset, sl->slicebetaoffset); return AVERRORINVALIDDATA; } } } return 0; } ", "target": 0}
{"func": "int ffurlshutdown(URLContext *h, int flags) { if (!h->prot->urlshutdown) return AVERROR(EINVAL); return h->prot->urlshutdown(h, flags); } ", "target": 0}
{"func": "static void i82378init(DeviceState *dev, I82378State *s) { ISABus *isabus = DOUPCAST(ISABus, qbus, qdevgetchildbus(dev, \"isa.0\")); ISADevice *pit; qemuirq *out0irq; /* This device has: 2 82C59 (irq) 1 82C54 (pit) 2 82C37 (dma) NMI Utility Bus Support Registers All devices accept byte access only, except timer */ qdevinitgpioout(dev, s->out, 2); qdevinitgpioin(dev, i82378requestpicirq, 16); /* Workaround the fact that i8259 is not qdev'ified... */ out0irq = qemuallocateirqs(i82378requestout0irq, s, 1); /* 2 82C59 (irq) */ s->i8259 = i8259init(isabus, *out0irq); isabusirqs(isabus, s->i8259); /* 1 82C54 (pit) */ pit = pitinit(isabus, 0x40, 0, NULL); /* speaker */ pcspkinit(isabus, pit); /* 2 82C37 (dma) */ DMAinit(1, &s->out[1]); isacreatesimple(isabus, \"i82374\"); /* timer */ isacreatesimple(isabus, \"mc146818rtc\"); } ", "target": 1}
{"func": "static void realviewinit(ramaddrt ramsize, int vgaramsize, const char *bootdevice, DisplayState *ds, const char *kernelfilename, const char *kernelcmdline, const char *initrdfilename, const char *cpumodel) { CPUState *env; qemuirq *pic; void *scsihba; PCIBus *pcibus; NICInfo *nd; int n; int donesmc = 0; qemuirq cpuirq[4]; int ncpu; int index; if (!cpumodel) cpumodel = \"arm926\"; /* FIXME: obey smpcpus. */ if (strcmp(cpumodel, \"arm11mpcore\") == 0) { ncpu = 4; } else { ncpu = 1; } for (n = 0; n < ncpu; n++) { env = cpuinit(cpumodel); if (!env) { fprintf(stderr, \"Unable to find CPU definition\\n\"); exit(1); } pic = armpicinitcpu(env); cpuirq[n] = pic[ARMPICCPUIRQ]; if (n > 0) { /* Set entry point for secondary CPUs. This assumes we're using the init code from armboot.c. Real hardware resets all CPUs the same. */ env->regs[15] = 0x80000000; } } /* ??? RAM should repeat to fill physical memory space. */ /* SDRAM at address zero. */ cpuregisterphysicalmemory(0, ramsize, IOMEMRAM); armsysctlinit(0x10000000, 0xc1400400); if (ncpu == 1) { /* ??? The documentation says GIC1 is nFIQ and either GIC2 or GIC3 is nIRQ (there are inconsistencies). However Linux 2.6.17 expects GIC1 to be nIRQ and ignores all the others, so do that for now. */ pic = realviewgicinit(0x10040000, cpuirq[0]); } else { pic = mpcoreirqinit(cpuirq); } pl050init(0x10006000, pic[20], 0); pl050init(0x10007000, pic[21], 1); pl011init(0x10009000, pic[12], serialhds[0], PL011ARM); pl011init(0x1000a000, pic[13], serialhds[1], PL011ARM); pl011init(0x1000b000, pic[14], serialhds[2], PL011ARM); pl011init(0x1000c000, pic[15], serialhds[3], PL011ARM); /* DMA controller is optional, apparently. */ pl080init(0x10030000, pic[24], 2); sp804init(0x10011000, pic[4]); sp804init(0x10012000, pic[5]); pl110init(ds, 0x10020000, pic[23], 1); index = drivegetindex(IFSD, 0, 0); if (index == -1) { fprintf(stderr, \"qemu: missing SecureDigital card\\n\"); exit(1); } pl181init(0x10005000, drivestable[index].bdrv, pic[17], pic[18]); pl031init(0x10017000, pic[10]); pcibus = pcivpbinit(pic, 48, 1); if (usbenabled) { usbohciinitpci(pcibus, 3, -1); } if (drivegetmaxbus(IFSCSI) > 0) { fprintf(stderr, \"qemu: too many SCSI bus\\n\"); exit(1); } scsihba = lsiscsiinit(pcibus, -1); for (n = 0; n < LSIMAXDEVS; n++) { index = drivegetindex(IFSCSI, 0, n); if (index == -1) continue; lsiscsiattach(scsihba, drivestable[index].bdrv, n); } for(n = 0; n < nbnics; n++) { nd = &ndtable[n]; if (!nd->model) nd->model = donesmc ? \"rtl8139\" : \"smc91c111\"; if (strcmp(nd->model, \"smc91c111\") == 0) { smc91c111init(nd, 0x4e000000, pic[28]); } else { pcinicinit(pcibus, nd, -1); } } /* Memory map for RealView Emulation Baseboard: */ /* 0x10000000 System registers. */ /* 0x10001000 System controller. */ /* 0x10002000 Two-Wire Serial Bus. */ /* 0x10003000 Reserved. */ /* 0x10004000 AACI. */ /* 0x10005000 MCI. */ /* 0x10006000 KMI0. */ /* 0x10007000 KMI1. */ /* 0x10008000 Character LCD. */ /* 0x10009000 UART0. */ /* 0x1000a000 UART1. */ /* 0x1000b000 UART2. */ /* 0x1000c000 UART3. */ /* 0x1000d000 SSPI. */ /* 0x1000e000 SCI. */ /* 0x1000f000 Reserved. */ /* 0x10010000 Watchdog. */ /* 0x10011000 Timer 0+1. */ /* 0x10012000 Timer 2+3. */ /* 0x10013000 GPIO 0. */ /* 0x10014000 GPIO 1. */ /* 0x10015000 GPIO 2. */ /* 0x10016000 Reserved. */ /* 0x10017000 RTC. */ /* 0x10018000 DMC. */ /* 0x10019000 PCI controller config. */ /* 0x10020000 CLCD. */ /* 0x10030000 DMA Controller. */ /* 0x10040000 GIC1. */ /* 0x10050000 GIC2. */ /* 0x10060000 GIC3. */ /* 0x10070000 GIC4. */ /* 0x10080000 SMC. */ /* 0x40000000 NOR flash. */ /* 0x44000000 DoC flash. */ /* 0x48000000 SRAM. */ /* 0x4c000000 Configuration flash. */ /* 0x4e000000 Ethernet. */ /* 0x4f000000 USB. */ /* 0x50000000 PISMO. */ /* 0x54000000 PISMO. */ /* 0x58000000 PISMO. */ /* 0x5c000000 PISMO. */ /* 0x60000000 PCI. */ /* 0x61000000 PCI Self Config. */ /* 0x62000000 PCI Config. */ /* 0x63000000 PCI IO. */ /* 0x64000000 PCI mem 0. */ /* 0x68000000 PCI mem 1. */ /* 0x6c000000 PCI mem 2. */ realviewbinfo.ramsize = ramsize; realviewbinfo.kernelfilename = kernelfilename; realviewbinfo.kernelcmdline = kernelcmdline; realviewbinfo.initrdfilename = initrdfilename; realviewbinfo.nbcpus = ncpu; armloadkernel(firstcpu, &realviewbinfo); /* ??? Hack to map an additional page of ram for the secondary CPU startup code. I guess this works on real hardware because the BootROM happens to be in ROM/flash or in memory that isn't clobbered until after Linux boots the secondary CPUs. */ cpuregisterphysicalmemory(0x80000000, 0x1000, IOMEMRAM + ramsize); } ", "target": 0}
{"func": "QString *qstringfromsubstr(const char *str, int start, int end) { QString *qstring; qstring = gmalloc(sizeof(*qstring)); qstring->length = end - start + 1; qstring->capacity = qstring->length; qstring->string = gmalloc(qstring->capacity + 1); memcpy(qstring->string, str + start, qstring->length); qstring->string[qstring->length] = 0; QOBJECTINIT(qstring, &qstringtype); return qstring; } ", "target": 0}
{"func": "static void testsourcewaiteventnotifier(void) { EventNotifierTestData data = { .n = 0, .active = 1 }; eventnotifierinit(&data.e, false); aioseteventnotifier(ctx, &data.e, eventreadycb); gassert(gmaincontextiteration(NULL, false)); gassertcmpint(data.n, ==, 0); gassertcmpint(data.active, ==, 1); eventnotifierset(&data.e); gassert(gmaincontextiteration(NULL, false)); gassertcmpint(data.n, ==, 1); gassertcmpint(data.active, ==, 0); while (gmaincontextiteration(NULL, false)); gassertcmpint(data.n, ==, 1); gassertcmpint(data.active, ==, 0); aioseteventnotifier(ctx, &data.e, NULL); while (gmaincontextiteration(NULL, false)); gassertcmpint(data.n, ==, 1); eventnotifiercleanup(&data.e); } ", "target": 0}
{"func": "static int coroutinefn isallocatedbase(BlockDriverState *top, BlockDriverState *base, int64t sectornum, int nbsectors, int *pnum) { BlockDriverState *intermediate; int ret, n; ret = bdrvcoisallocated(top, sectornum, nbsectors, &n); if (ret) { *pnum = n; return ret; } /* * Is the unallocated chunk [sectornum, n] also * unallocated between base and top? */ intermediate = top->backinghd; while (intermediate != base) { int pnuminter; ret = bdrvcoisallocated(intermediate, sectornum, nbsectors, &pnuminter); if (ret < 0) { return ret; } else if (ret) { *pnum = pnuminter; return 0; } /* * [sectornum, nbsectors] is unallocated on top but intermediate * might have * * [sectornum+x, nrsectors] allocated. */ if (n > pnuminter) { n = pnuminter; } intermediate = intermediate->backinghd; } *pnum = n; return 1; } ", "target": 0}
{"func": "static DisplayType selectdisplay(const char *p) { Error *err = NULL; const char *opts; DisplayType display = DTDEFAULT; if (strstart(p, \"sdl\", &opts)) { #ifdef CONFIGSDL display = DTSDL; while (*opts) { const char *nextopt; if (strstart(opts, \",frame=\", &nextopt)) { opts = nextopt; if (strstart(opts, \"on\", &nextopt)) { noframe = 0; } else if (strstart(opts, \"off\", &nextopt)) { noframe = 1; } else { goto invalidsdlargs; } } else if (strstart(opts, \",altgrab=\", &nextopt)) { opts = nextopt; if (strstart(opts, \"on\", &nextopt)) { altgrab = 1; } else if (strstart(opts, \"off\", &nextopt)) { altgrab = 0; } else { goto invalidsdlargs; } } else if (strstart(opts, \",ctrlgrab=\", &nextopt)) { opts = nextopt; if (strstart(opts, \"on\", &nextopt)) { ctrlgrab = 1; } else if (strstart(opts, \"off\", &nextopt)) { ctrlgrab = 0; } else { goto invalidsdlargs; } } else if (strstart(opts, \",windowclose=\", &nextopt)) { opts = nextopt; if (strstart(opts, \"on\", &nextopt)) { noquit = 0; } else if (strstart(opts, \"off\", &nextopt)) { noquit = 1; } else { goto invalidsdlargs; } } else if (strstart(opts, \",gl=\", &nextopt)) { opts = nextopt; if (strstart(opts, \"on\", &nextopt)) { requestopengl = 1; } else if (strstart(opts, \"off\", &nextopt)) { requestopengl = 0; } else { goto invalidsdlargs; } } else { invalidsdlargs: fprintf(stderr, \"Invalid SDL option string: %s\\n\", p); exit(1); } opts = nextopt; } #else fprintf(stderr, \"SDL support is disabled\\n\"); exit(1); #endif } else if (strstart(p, \"vnc\", &opts)) { #ifdef CONFIGVNC if (*opts == '=') { if (vncparse(opts + 1, &err) == NULL) { errorreporterr(err); exit(1); } } else { fprintf(stderr, \"VNC requires a display argument vnc=<display>\\n\"); exit(1); } #else fprintf(stderr, \"VNC support is disabled\\n\"); exit(1); #endif } else if (strstart(p, \"curses\", &opts)) { #ifdef CONFIGCURSES display = DTCURSES; #else fprintf(stderr, \"Curses support is disabled\\n\"); exit(1); #endif } else if (strstart(p, \"gtk\", &opts)) { #ifdef CONFIGGTK display = DTGTK; while (*opts) { const char *nextopt; if (strstart(opts, \",grabonhover=\", &nextopt)) { opts = nextopt; if (strstart(opts, \"on\", &nextopt)) { grabonhover = true; } else if (strstart(opts, \"off\", &nextopt)) { grabonhover = false; } else { goto invalidgtkargs; } } else if (strstart(opts, \",gl=\", &nextopt)) { opts = nextopt; if (strstart(opts, \"on\", &nextopt)) { requestopengl = 1; } else if (strstart(opts, \"off\", &nextopt)) { requestopengl = 0; } else { goto invalidgtkargs; } } else { invalidgtkargs: fprintf(stderr, \"Invalid GTK option string: %s\\n\", p); exit(1); } opts = nextopt; } #else fprintf(stderr, \"GTK support is disabled\\n\"); exit(1); #endif } else if (strstart(p, \"none\", &opts)) { display = DTNONE; } else { fprintf(stderr, \"Unknown display type: %s\\n\", p); exit(1); } return display; } ", "target": 0}
{"func": "static int getpacketheader(NUTContext *nut, ByteIOContext *bc, int prefixlength, int calculatechecksum) { int64t start, size, lastsize; start= urlftell(bc) - prefixlength; if(start != nut->packetstart + nut->writtenpacketsize){ avlog(nut->avf, AVLOGERROR, \"getpacketheader called at weird position\\n\"); return -1; } if(calculatechecksum) initchecksum(bc, updateadler32, 0); size= getv(bc); lastsize= getv(bc); if(nut->writtenpacketsize != lastsize){ avlog(nut->avf, AVLOGERROR, \"packet size missmatch %d != %lld at %lld\\n\", nut->writtenpacketsize, lastsize, start); return -1; } nut->lastpacketstart = nut->packetstart; nut->packetstart = start; nut->writtenpacketsize= size; return size; } ", "target": 0}
{"func": "static void megasasunmapframe(MegasasState *s, MegasasCmd *cmd) { PCIDevice *p = PCIDEVICE(s); pcidmaunmap(p, cmd->frame, cmd->pasize, 0, 0); cmd->frame = NULL; cmd->pa = 0; clearbit(cmd->index, s->framemap); } ", "target": 0}
{"func": "int v9fscoopen2(V9fsState *s, V9fsFidState *fidp, char *fullname, gidt gid, int flags, int mode) { int err; FsCred cred; credinit(&cred); cred.fcmode = mode & 07777; cred.fcuid = fidp->uid; cred.fcgid = gid; v9fscoruninworker( { fidp->fs.fd = s->ops->open2(&s->ctx, fullname, flags, &cred); err = 0; if (fidp->fs.fd == -1) { err = -errno; } }); if (!err) { totalopenfd++; if (totalopenfd > openfdhw) { v9fsreclaimfd(s); } } return err; } ", "target": 0}
{"func": "static int receivefilter(VirtIONet *n, const uint8t *buf, int size) { static const uint8t bcast[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff}; static const uint8t vlan[] = {0x81, 0x00}; uint8t *ptr = (uint8t *)buf; int i; if (n->promisc) return 1; if (!memcmp(&ptr[12], vlan, sizeof(vlan))) { int vid = be16tocpup((uint16t *)(ptr + 14)) & 0xfff; if (!(n->vlans[vid >> 5] & (1U << (vid & 0x1f)))) return 0; } if ((ptr[0] & 1) && n->allmulti) return 1; if (!memcmp(ptr, bcast, sizeof(bcast))) return 1; if (!memcmp(ptr, n->mac, ETHALEN)) return 1; for (i = 0; i < n->mactable.inuse; i++) { if (!memcmp(ptr, &n->mactable.macs[i * ETHALEN], ETHALEN)) return 1; } return 0; } ", "target": 0}
{"func": "static int outputpacket(InputStream *ist, int istindex, OutputStream *osttable, int nbostreams, const AVPacket *pkt) { AVFormatContext *os; OutputStream *ost; int ret, i; int gotoutput; void *buffertofree = NULL; static unsigned int samplessize= 0; AVSubtitle subtitle, *subtitletofree; int64t pktpts = AVNOPTSVALUE; #if CONFIGAVFILTER int frameavailable; #endif float quality; AVPacket avpkt; int bps = avgetbytespersample(ist->st->codec->samplefmt); if(ist->nextpts == AVNOPTSVALUE) ist->nextpts= ist->pts; if (pkt == NULL) { /* EOF handling */ avinitpacket(&avpkt); avpkt.data = NULL; avpkt.size = 0; goto handleeof; } else { avpkt = *pkt; } if(pkt->dts != AVNOPTSVALUE) ist->nextpts = ist->pts = avrescaleq(pkt->dts, ist->st->timebase, AVTIMEBASEQ); if(pkt->pts != AVNOPTSVALUE) pktpts = avrescaleq(pkt->pts, ist->st->timebase, AVTIMEBASEQ); //while we have more to decode or while the decoder did output something on EOF while (avpkt.size > 0 || (!pkt && gotoutput)) { uint8t *databuf, *decodeddatabuf; int datasize, decodeddatasize; AVFrame *decodedframe, *filteredframe; handleeof: ist->pts= ist->nextpts; if(avpkt.size && avpkt.size != pkt->size) avlog(NULL, ist->showedmultipacketwarning ? AVLOGVERBOSE : AVLOGWARNING, \"Multiple frames in a packet from stream %d\\n\", pkt->streamindex); ist->showedmultipacketwarning=1; /* decode the packet if needed */ decodedframe = filteredframe = NULL; decodeddatabuf = NULL; /* fail safe */ decodeddatasize= 0; databuf = avpkt.data; datasize = avpkt.size; subtitletofree = NULL; if (ist->decodingneeded) { switch(ist->st->codec->codectype) { case AVMEDIATYPEAUDIO:{ if(pkt && samplessize < FFMAX(pkt->size * bps, AVCODECMAXAUDIOFRAMESIZE)) { samplessize = FFMAX(pkt->size * bps, AVCODECMAXAUDIOFRAMESIZE); avfree(samples); samples= avmalloc(samplessize); } decodeddatasize= samplessize; /* XXX: could avoid copy if PCM 16 bits with same endianness as CPU */ ret = avcodecdecodeaudio3(ist->st->codec, samples, &decodeddatasize, &avpkt); if (ret < 0) return ret; avpkt.data += ret; avpkt.size -= ret; datasize = ret; gotoutput = decodeddatasize > 0; /* Some bug in mpeg audio decoder gives */ /* decodeddatasize < 0, it seems they are overflows */ if (!gotoutput) { /* no audio frame */ continue; } decodeddatabuf = (uint8t *)samples; ist->nextpts += ((int64t)AVTIMEBASE/bps * decodeddatasize) / (ist->st->codec->samplerate * ist->st->codec->channels); break;} case AVMEDIATYPEVIDEO: decodeddatasize = (ist->st->codec->width * ist->st->codec->height * 3) / 2; if (!(decodedframe = avcodecallocframe())) return AVERROR(ENOMEM); avpkt.pts = pktpts; avpkt.dts = ist->pts; pktpts = AVNOPTSVALUE; ret = avcodecdecodevideo2(ist->st->codec, decodedframe, &gotoutput, &avpkt); quality = samequant ? decodedframe->quality : 0; if (ret < 0) goto fail; if (!gotoutput) { /* no picture yet */ avfreep(&decodedframe); goto discardpacket; } ist->nextpts = ist->pts = guesscorrectpts(&ist->ptsctx, decodedframe->pktpts, decodedframe->pktdts); if (ist->st->codec->timebase.num != 0) { int ticks= ist->st->parser ? ist->st->parser->repeatpict+1 : ist->st->codec->ticksperframe; ist->nextpts += ((int64t)AVTIMEBASE * ist->st->codec->timebase.num * ticks) / ist->st->codec->timebase.den; } avpkt.size = 0; buffertofree = NULL; preprocessvideoframe(ist, (AVPicture *)decodedframe, &buffertofree); break; case AVMEDIATYPESUBTITLE: ret = avcodecdecodesubtitle2(ist->st->codec, &subtitle, &gotoutput, &avpkt); if (ret < 0) return ret; if (!gotoutput) { goto discardpacket; } subtitletofree = &subtitle; avpkt.size = 0; break; default: return -1; } } else { switch(ist->st->codec->codectype) { case AVMEDIATYPEAUDIO: ist->nextpts += ((int64t)AVTIMEBASE * ist->st->codec->framesize) / ist->st->codec->samplerate; break; case AVMEDIATYPEVIDEO: if (ist->st->codec->timebase.num != 0) { int ticks= ist->st->parser ? ist->st->parser->repeatpict+1 : ist->st->codec->ticksperframe; ist->nextpts += ((int64t)AVTIMEBASE * ist->st->codec->timebase.num * ticks) / ist->st->codec->timebase.den; } break; } avpkt.size = 0; } // preprocess audio (volume) if (ist->st->codec->codectype == AVMEDIATYPEAUDIO) { if (audiovolume != 256) { switch (ist->st->codec->samplefmt) { case AVSAMPLEFMTU8: { uint8t *volp = samples; for (i = 0; i < (decodeddatasize / sizeof(*volp)); i++) { int v = (((*volp - 128) * audiovolume + 128) >> 8) + 128; *volp++ = avclipuint8(v); } break; } case AVSAMPLEFMTS16: { short *volp; volp = samples; for(i=0;i<(decodeddatasize / sizeof(short));i++) { int v = ((*volp) * audiovolume + 128) >> 8; *volp++ = avclipint16(v); } break; } case AVSAMPLEFMTS32: { int32t *volp = samples; for (i = 0; i < (decodeddatasize / sizeof(*volp)); i++) { int64t v = (((int64t)*volp * audiovolume + 128) >> 8); *volp++ = avcliplint32(v); } break; } case AVSAMPLEFMTFLT: { float *volp = samples; float scale = audiovolume / 256.f; for (i = 0; i < (decodeddatasize / sizeof(*volp)); i++) { *volp++ *= scale; } break; } case AVSAMPLEFMTDBL: { double *volp = samples; double scale = audiovolume / 256.; for (i = 0; i < (decodeddatasize / sizeof(*volp)); i++) { *volp++ *= scale; } break; } default: avlog(NULL, AVLOGFATAL, \"Audio volume adjustment on sample format %s is not supported.\\n\", avgetsamplefmtname(ist->st->codec->samplefmt)); exitprogram(1); } } } /* frame rate emulation */ if (inputfiles[ist->fileindex].rateemu) { int64t pts = avrescale(ist->pts, 1000000, AVTIMEBASE); int64t now = avgettime() - ist->start; if (pts > now) usleep(pts - now); } /* if output time reached then transcode raw format, encode packets and output them */ for (i = 0; i < nbostreams; i++) { OutputFile *of = &outputfiles[osttable[i].fileindex]; int framesize; ost = &osttable[i]; if (ost->sourceindex != istindex) continue; if (of->starttime && ist->pts < of->starttime) continue; if (of->recordingtime != INT64MAX && avcomparets(ist->pts, AVTIMEBASEQ, of->recordingtime + of->starttime, (AVRational){1, 1000000}) >= 0) { ost->ispastrecordingtime = 1; continue; } #if CONFIGAVFILTER if (ist->st->codec->codectype == AVMEDIATYPEVIDEO && ost->inputvideofilter) { AVRational sar; if (ist->st->sampleaspectratio.num) sar = ist->st->sampleaspectratio; else sar = ist->st->codec->sampleaspectratio; avvsrcbufferaddframe(ost->inputvideofilter, decodedframe, ist->pts, sar); if (!(filteredframe = avcodecallocframe())) { ret = AVERROR(ENOMEM); goto fail; } } frameavailable = ist->st->codec->codectype != AVMEDIATYPEVIDEO || !ost->outputvideofilter || avfilterpollframe(ost->outputvideofilter->inputs[0]); while (frameavailable) { AVRational istptstb; if (ist->st->codec->codectype == AVMEDIATYPEVIDEO && ost->outputvideofilter) getfilteredvideoframe(ost->outputvideofilter, filteredframe, &ost->picref, &istptstb); if (ost->picref) ist->pts = avrescaleq(ost->picref->pts, istptstb, AVTIMEBASEQ); #else filteredframe = decodedframe; #endif os = outputfiles[ost->fileindex].ctx; /* set the input output pts pairs */ //ost->syncipts = (double)(ist->pts + inputfiles[ist->fileindex].tsoffset - starttime)/ AVTIMEBASE; if (ost->encodingneeded) { avassert0(ist->decodingneeded); switch(ost->st->codec->codectype) { case AVMEDIATYPEAUDIO: doaudioout(os, ost, ist, decodeddatabuf, decodeddatasize); break; case AVMEDIATYPEVIDEO: #if CONFIGAVFILTER if (ost->picref->video && !ost->frameaspectratio) ost->st->codec->sampleaspectratio = ost->picref->video->pixelaspect; #endif dovideoout(os, ost, ist, filteredframe, &framesize, samequant ? quality : ost->st->codec->globalquality); if (vstatsfilename && framesize) dovideostats(os, ost, framesize); break; case AVMEDIATYPESUBTITLE: dosubtitleout(os, ost, ist, &subtitle, pkt->pts); break; default: abort(); } } else { AVPacket opkt; int64t osttbstarttime= avrescaleq(of->starttime, AVTIMEBASEQ, ost->st->timebase); avinitpacket(&opkt); if ((!ost->framenumber && !(pkt->flags & AVPKTFLAGKEY)) && !copyinitialnonkeyframes) #if !CONFIGAVFILTER continue; #else goto cont; #endif /* no reencoding needed : output the packet directly */ /* force the input stream PTS */ if(ost->st->codec->codectype == AVMEDIATYPEAUDIO) audiosize += datasize; else if (ost->st->codec->codectype == AVMEDIATYPEVIDEO) { videosize += datasize; ost->syncopts++; } opkt.streamindex= ost->index; if(pkt->pts != AVNOPTSVALUE) opkt.pts= avrescaleq(pkt->pts, ist->st->timebase, ost->st->timebase) - osttbstarttime; else opkt.pts= AVNOPTSVALUE; if (pkt->dts == AVNOPTSVALUE) opkt.dts = avrescaleq(ist->pts, AVTIMEBASEQ, ost->st->timebase); else opkt.dts = avrescaleq(pkt->dts, ist->st->timebase, ost->st->timebase); opkt.dts -= osttbstarttime; opkt.duration = avrescaleq(pkt->duration, ist->st->timebase, ost->st->timebase); opkt.flags= pkt->flags; //FIXME remove the following 2 lines they shall be replaced by the bitstream filters if( ost->st->codec->codecid != CODECIDH264 && ost->st->codec->codecid != CODECIDMPEG1VIDEO && ost->st->codec->codecid != CODECIDMPEG2VIDEO ) { if(avparserchange(ist->st->parser, ost->st->codec, &opkt.data, &opkt.size, databuf, datasize, pkt->flags & AVPKTFLAGKEY)) opkt.destruct= avdestructpacket; } else { opkt.data = databuf; opkt.size = datasize; } writeframe(os, &opkt, ost->st->codec, ost->bitstreamfilters); ost->st->codec->framenumber++; ost->framenumber++; avfreepacket(&opkt); } #if CONFIGAVFILTER cont: frameavailable = (ist->st->codec->codectype == AVMEDIATYPEVIDEO) && ost->outputvideofilter && avfilterpollframe(ost->outputvideofilter->inputs[0]); if (ost->picref) avfilterunrefbuffer(ost->picref); } avfreep(&filteredframe); #endif } fail: avfree(buffertofree); /* XXX: allocate the subtitles in the codec ? */ if (subtitletofree) { avsubtitlefree(subtitletofree); subtitletofree = NULL; } avfreep(&decodedframe); if (ret < 0) return ret; } discardpacket: return 0; } ", "target": 0}
{"func": "static void gentlbsx440(DisasContext *ctx) { #if defined(CONFIGUSERONLY) geninvalexception(ctx, POWERPCEXCPPRIVOPC); #else TCGv t0; if (unlikely(ctx->pr)) { geninvalexception(ctx, POWERPCEXCPPRIVOPC); return; } t0 = tcgtempnew(); genaddrregindex(ctx, t0); genhelper440tlbsx(cpugpr[rD(ctx->opcode)], cpuenv, t0); tcgtempfree(t0); if (Rc(ctx->opcode)) { int l1 = gennewlabel(); tcggentrunctli32(cpucrf[0], cpuso); tcggenbrconditl(TCGCONDEQ, cpugpr[rD(ctx->opcode)], -1, l1); tcggenorii32(cpucrf[0], cpucrf[0], 0x02); gensetlabel(l1); } #endif } ", "target": 0}
{"func": "GSource *iohandlergetgsource(void) { iohandlerinit(); return aiogetgsource(iohandlerctx); } ", "target": 0}
{"func": "int ffmpeg1findframeend(ParseContext *pc, const uint8t *buf, int bufsize) { int i; uint32t state= pc->state; /* EOF considered as end of frame */ if (bufsize == 0) return 0; /* 0 frame start -> 1/4 1 firstSEQEXT -> 0/2 2 first field start -> 3/0 3 secondSEQEXT -> 2/0 4 searching end */ for(i=0; i<bufsize; i++){ assert(pc->framestartfound>=0 && pc->framestartfound<=4); if(pc->framestartfound&1){ if(state == EXTSTARTCODE && (buf[i]&0xF0) != 0x80) pc->framestartfound--; else if(state == EXTSTARTCODE+2){ if((buf[i]&3) == 3) pc->framestartfound= 0; else pc->framestartfound= (pc->framestartfound+1)&3; } state++; }else{ i= fffindstartcode(buf+i, buf+bufsize, &state) - buf - 1; if(pc->framestartfound==0 && state >= SLICEMINSTARTCODE && state <= SLICEMAXSTARTCODE){ i++; pc->framestartfound=4; } if(state == SEQENDCODE){ pc->state=-1; return i+1; } if(pc->framestartfound==2 && state == SEQSTARTCODE) pc->framestartfound= 0; if(pc->framestartfound<4 && state == EXTSTARTCODE) pc->framestartfound++; if(pc->framestartfound == 4 && (state&0xFFFFFF00) == 0x100){ if(state < SLICEMINSTARTCODE || state > SLICEMAXSTARTCODE){ pc->framestartfound=0; pc->state=-1; return i-3; } } } } pc->state= state; return ENDNOTFOUND; } ", "target": 0}
{"func": "static avcold int encodeinit(AVCodecContext *avctx) { FFV1Context *s = avctx->privdata; const AVPixFmtDescriptor *desc = avpixfmtdescget(avctx->pixfmt); int i, j, k, m, ret; if ((ret = ffffv1commoninit(avctx)) < 0) return ret; s->version = 0; if ((avctx->flags & (AVCODECFLAGPASS1 | AVCODECFLAGPASS2)) || avctx->slices > 1) s->version = FFMAX(s->version, 2); // Unspecified level & slices, we choose version 1.2+ to ensure multithreaded decodability if (avctx->slices == 0 && avctx->level < 0 && avctx->width * avctx->height > 720*576) s->version = FFMAX(s->version, 2); if (avctx->level <= 0 && s->version == 2) { s->version = 3; } if (avctx->level >= 0 && avctx->level <= 4) { if (avctx->level < s->version) { avlog(avctx, AVLOGERROR, \"Version %d needed for requested features but %d requested\\n\", s->version, avctx->level); return AVERROR(EINVAL); } s->version = avctx->level; } if (s->ec < 0) { s->ec = (s->version >= 3); } if ((s->version == 2 || s->version>3) && avctx->strictstdcompliance > FFCOMPLIANCEEXPERIMENTAL) { avlog(avctx, AVLOGERROR, \"Version 2 needed for requested features but version 2 is experimental and not enabled\\n\"); return AVERRORINVALIDDATA; } #if FFAPICODERTYPE FFDISABLEDEPRECATIONWARNINGS if (avctx->codertype != -1) s->ac = avctx->codertype > 0 ? ACRANGECUSTOMTAB : ACGOLOMBRICE; else FFENABLEDEPRECATIONWARNINGS #endif if (s->ac == 1) // Compatbility with common command line usage s->ac = ACRANGECUSTOMTAB; else if (s->ac == ACRANGEDEFAULTTABFORCE) s->ac = ACRANGEDEFAULTTAB; s->planecount = 3; switch(avctx->pixfmt) { case AVPIXFMTYUV444P9: case AVPIXFMTYUV422P9: case AVPIXFMTYUV420P9: case AVPIXFMTYUVA444P9: case AVPIXFMTYUVA422P9: case AVPIXFMTYUVA420P9: if (!avctx->bitsperrawsample) s->bitsperrawsample = 9; case AVPIXFMTGRAY10: case AVPIXFMTYUV444P10: case AVPIXFMTYUV420P10: case AVPIXFMTYUV422P10: case AVPIXFMTYUVA444P10: case AVPIXFMTYUVA422P10: case AVPIXFMTYUVA420P10: if (!avctx->bitsperrawsample && !s->bitsperrawsample) s->bitsperrawsample = 10; case AVPIXFMTGRAY12: case AVPIXFMTYUV444P12: case AVPIXFMTYUV420P12: case AVPIXFMTYUV422P12: s->packedatlsb = 1; if (!avctx->bitsperrawsample && !s->bitsperrawsample) s->bitsperrawsample = 12; case AVPIXFMTGRAY16: case AVPIXFMTYUV444P16: case AVPIXFMTYUV422P16: case AVPIXFMTYUV420P16: case AVPIXFMTYUVA444P16: case AVPIXFMTYUVA422P16: case AVPIXFMTYUVA420P16: if (!avctx->bitsperrawsample && !s->bitsperrawsample) { s->bitsperrawsample = 16; } else if (!s->bitsperrawsample) { s->bitsperrawsample = avctx->bitsperrawsample; } if (s->bitsperrawsample <= 8) { avlog(avctx, AVLOGERROR, \"bitsperrawsample invalid\\n\"); return AVERRORINVALIDDATA; } s->version = FFMAX(s->version, 1); case AVPIXFMTGRAY8: case AVPIXFMTYA8: case AVPIXFMTYUV444P: case AVPIXFMTYUV440P: case AVPIXFMTYUV422P: case AVPIXFMTYUV420P: case AVPIXFMTYUV411P: case AVPIXFMTYUV410P: case AVPIXFMTYUVA444P: case AVPIXFMTYUVA422P: case AVPIXFMTYUVA420P: s->chromaplanes = desc->nbcomponents < 3 ? 0 : 1; s->colorspace = 0; s->transparency = desc->nbcomponents == 4 || desc->nbcomponents == 2; if (!avctx->bitsperrawsample && !s->bitsperrawsample) s->bitsperrawsample = 8; else if (!s->bitsperrawsample) s->bitsperrawsample = 8; break; case AVPIXFMTRGB32: s->colorspace = 1; s->transparency = 1; s->chromaplanes = 1; s->bitsperrawsample = 8; break; case AVPIXFMTRGB48: s->colorspace = 1; s->chromaplanes = 1; s->bitsperrawsample = 16; s->use32bit = 1; s->version = FFMAX(s->version, 1); if (avctx->strictstdcompliance > FFCOMPLIANCEEXPERIMENTAL) { avlog(avctx, AVLOGERROR, \"16bit RGB is experimental and under development, only use it for experiments\\n\"); return AVERRORINVALIDDATA; } break; case AVPIXFMT0RGB32: s->colorspace = 1; s->chromaplanes = 1; s->bitsperrawsample = 8; break; case AVPIXFMTGBRP9: if (!avctx->bitsperrawsample) s->bitsperrawsample = 9; case AVPIXFMTGBRP10: if (!avctx->bitsperrawsample && !s->bitsperrawsample) s->bitsperrawsample = 10; case AVPIXFMTGBRP12: if (!avctx->bitsperrawsample && !s->bitsperrawsample) s->bitsperrawsample = 12; case AVPIXFMTGBRP14: if (!avctx->bitsperrawsample && !s->bitsperrawsample) s->bitsperrawsample = 14; case AVPIXFMTGBRP16: if (!avctx->bitsperrawsample && !s->bitsperrawsample) s->bitsperrawsample = 16; else if (!s->bitsperrawsample) s->bitsperrawsample = avctx->bitsperrawsample; s->colorspace = 1; s->chromaplanes = 1; if (s->bitsperrawsample >= 16) { s->use32bit = 1; if (avctx->strictstdcompliance > FFCOMPLIANCEEXPERIMENTAL) { avlog(avctx, AVLOGERROR, \"16bit RGB is experimental and under development, only use it for experiments\\n\"); return AVERRORINVALIDDATA; } } s->version = FFMAX(s->version, 1); break; default: avlog(avctx, AVLOGERROR, \"format not supported\\n\"); return AVERROR(ENOSYS); } avassert0(s->bitsperrawsample >= 8); if (s->bitsperrawsample > 8) { if (s->ac == ACGOLOMBRICE) { avlog(avctx, AVLOGINFO, \"bitsperrawsample > 8, forcing range coder\\n\"); s->ac = ACRANGECUSTOMTAB; } } if (s->transparency) { avlog(avctx, AVLOGWARNING, \"Storing alpha plane, this will require a recent FFV1 decoder to playback!\\n\"); } #if FFAPIPRIVATEOPT FFDISABLEDEPRECATIONWARNINGS if (avctx->contextmodel) s->contextmodel = avctx->contextmodel; if (avctx->contextmodel > 1U) { avlog(avctx, AVLOGERROR, \"Invalid context model %d, valid values are 0 and 1\\n\", avctx->contextmodel); return AVERROR(EINVAL); } FFENABLEDEPRECATIONWARNINGS #endif if (s->ac == ACRANGECUSTOMTAB) { for (i = 1; i < 256; i++) s->statetransition[i] = ver2state[i]; } else { RangeCoder c; ffbuildracstates(&c, 0.05 * (1LL << 32), 256 - 8); for (i = 1; i < 256; i++) s->statetransition[i] = c.onestate[i]; } for (i = 0; i < 256; i++) { s->quanttablecount = 2; if (s->bitsperrawsample <= 8) { s->quanttables[0][0][i]= quant11[i]; s->quanttables[0][1][i]= 11*quant11[i]; s->quanttables[0][2][i]= 11*11*quant11[i]; s->quanttables[1][0][i]= quant11[i]; s->quanttables[1][1][i]= 11*quant11[i]; s->quanttables[1][2][i]= 11*11*quant5 [i]; s->quanttables[1][3][i]= 5*11*11*quant5 [i]; s->quanttables[1][4][i]= 5*5*11*11*quant5 [i]; } else { s->quanttables[0][0][i]= quant910bit[i]; s->quanttables[0][1][i]= 11*quant910bit[i]; s->quanttables[0][2][i]= 11*11*quant910bit[i]; s->quanttables[1][0][i]= quant910bit[i]; s->quanttables[1][1][i]= 11*quant910bit[i]; s->quanttables[1][2][i]= 11*11*quant510bit[i]; s->quanttables[1][3][i]= 5*11*11*quant510bit[i]; s->quanttables[1][4][i]= 5*5*11*11*quant510bit[i]; } } s->contextcount[0] = (11 * 11 * 11 + 1) / 2; s->contextcount[1] = (11 * 11 * 5 * 5 * 5 + 1) / 2; memcpy(s->quanttable, s->quanttables[s->contextmodel], sizeof(s->quanttable)); for (i = 0; i < s->planecount; i++) { PlaneContext *const p = &s->plane[i]; memcpy(p->quanttable, s->quanttable, sizeof(p->quanttable)); p->quanttableindex = s->contextmodel; p->contextcount = s->contextcount[p->quanttableindex]; } if ((ret = ffffv1allocateinitialstates(s)) < 0) return ret; #if FFAPICODEDFRAME FFDISABLEDEPRECATIONWARNINGS avctx->codedframe->picttype = AVPICTURETYPEI; FFENABLEDEPRECATIONWARNINGS #endif if (!s->transparency) s->planecount = 2; if (!s->chromaplanes && s->version > 3) s->planecount--; avcodecgetchromasubsample(avctx->pixfmt, &s->chromahshift, &s->chromavshift); s->picturenumber = 0; if (avctx->flags & (AVCODECFLAGPASS1 | AVCODECFLAGPASS2)) { for (i = 0; i < s->quanttablecount; i++) { s->rcstat2[i] = avmallocz(s->contextcount[i] * sizeof(*s->rcstat2[i])); if (!s->rcstat2[i]) return AVERROR(ENOMEM); } } if (avctx->statsin) { char *p = avctx->statsin; uint8t (*beststate)[256] = avmallocarray(256, 256); int gobcount = 0; char *next; if (!beststate) return AVERROR(ENOMEM); avassert0(s->version >= 2); for (;;) { for (j = 0; j < 256; j++) for (i = 0; i < 2; i++) { s->rcstat[j][i] = strtol(p, &next, 0); if (next == p) { avlog(avctx, AVLOGERROR, \"2Pass file invalid at %d %d [%s]\\n\", j, i, p); avfreep(&beststate); return AVERRORINVALIDDATA; } p = next; } for (i = 0; i < s->quanttablecount; i++) for (j = 0; j < s->contextcount[i]; j++) { for (k = 0; k < 32; k++) for (m = 0; m < 2; m++) { s->rcstat2[i][j][k][m] = strtol(p, &next, 0); if (next == p) { avlog(avctx, AVLOGERROR, \"2Pass file invalid at %d %d %d %d [%s]\\n\", i, j, k, m, p); avfreep(&beststate); return AVERRORINVALIDDATA; } p = next; } } gobcount = strtol(p, &next, 0); if (next == p || gobcount <= 0) { avlog(avctx, AVLOGERROR, \"2Pass file invalid\\n\"); avfreep(&beststate); return AVERRORINVALIDDATA; } p = next; while (*p == '\\n' || *p == ' ') p++; if (p[0] == 0) break; } if (s->ac == ACRANGECUSTOMTAB) sortstt(s, s->statetransition); findbeststate(beststate, s->statetransition); for (i = 0; i < s->quanttablecount; i++) { for (k = 0; k < 32; k++) { double a=0, b=0; int jp = 0; for (j = 0; j < s->contextcount[i]; j++) { double p = 128; if (s->rcstat2[i][j][k][0] + s->rcstat2[i][j][k][1] > 200 && j || a+b > 200) { if (a+b) p = 256.0 * b / (a + b); s->initialstates[i][jp][k] = beststate[avclip(round(p), 1, 255)][avclipuint8((a + b) / gobcount)]; for(jp++; jp<j; jp++) s->initialstates[i][jp][k] = s->initialstates[i][jp-1][k]; a=b=0; } a += s->rcstat2[i][j][k][0]; b += s->rcstat2[i][j][k][1]; if (a+b) { p = 256.0 * b / (a + b); } s->initialstates[i][j][k] = beststate[avclip(round(p), 1, 255)][avclipuint8((a + b) / gobcount)]; } } } avfreep(&beststate); } if (s->version > 1) { int planecount = 1 + 2*s->chromaplanes + s->transparency; s->numvslices = (avctx->width > 352 || avctx->height > 288 || !avctx->slices) ? 2 : 1; if (avctx->height < 5) s->numvslices = 1; for (; s->numvslices < 32; s->numvslices++) { for (s->numhslices = s->numvslices; s->numhslices < 2*s->numvslices; s->numhslices++) { int maxw = (avctx->width + s->numhslices - 1) / s->numhslices; int maxh = (avctx->height + s->numvslices - 1) / s->numvslices; if (s->numhslices > avctx->width || s->numvslices > avctx->height) continue; if (maxw * maxh * (int64t)(s->bitsperrawsample+1) * planecount > 8<<24) continue; if (avctx->slices == s->numhslices * s->numvslices && avctx->slices <= MAXSLICES || !avctx->slices) goto slicesok; } } avlog(avctx, AVLOGERROR, \"Unsupported number %d of slices requested, please specify a \" \"supported number with -slices (ex:4,6,9,12,16, ...)\\n\", avctx->slices); return AVERROR(ENOSYS); slicesok: if ((ret = writeextradata(s)) < 0) return ret; } if ((ret = ffffv1initslicecontexts(s)) < 0) return ret; s->slicecount = s->maxslicecount; if ((ret = ffffv1initslicesstate(s)) < 0) return ret; #define STATSOUTSIZE 1024 * 1024 * 6 if (avctx->flags & AVCODECFLAGPASS1) { avctx->statsout = avmallocz(STATSOUTSIZE); if (!avctx->statsout) return AVERROR(ENOMEM); for (i = 0; i < s->quanttablecount; i++) for (j = 0; j < s->maxslicecount; j++) { FFV1Context *sf = s->slicecontext[j]; avassert0(!sf->rcstat2[i]); sf->rcstat2[i] = avmallocz(s->contextcount[i] * sizeof(*sf->rcstat2[i])); if (!sf->rcstat2[i]) return AVERROR(ENOMEM); } } return 0; } ", "target": 0}
{"func": "static int hlsslicedatawpp(HEVCContext *s, const HEVCNAL *nal) { const uint8t *data = nal->data; int length = nal->size; HEVCLocalContext *lc = s->HEVClc; int *ret = avmallocarray(s->sh.numentrypointoffsets + 1, sizeof(int)); int *arg = avmallocarray(s->sh.numentrypointoffsets + 1, sizeof(int)); int64t offset; int startheader, cmpt = 0; int i, j, res = 0; if (!ret || !arg) { avfree(ret); avfree(arg); return AVERROR(ENOMEM); } if (!s->sList[1]) { ffallocentries(s->avctx, s->sh.numentrypointoffsets + 1); for (i = 1; i < s->threadsnumber; i++) { s->sList[i] = avmalloc(sizeof(HEVCContext)); memcpy(s->sList[i], s, sizeof(HEVCContext)); s->HEVClcList[i] = avmallocz(sizeof(HEVCLocalContext)); s->sList[i]->HEVClc = s->HEVClcList[i]; } } offset = (lc->gb.index >> 3); for (j = 0, cmpt = 0, startheader = offset + s->sh.entrypointoffset[0]; j < nal->skippedbytes; j++) { if (nal->skippedbytespos[j] >= offset && nal->skippedbytespos[j] < startheader) { startheader--; cmpt++; } } for (i = 1; i < s->sh.numentrypointoffsets; i++) { offset += (s->sh.entrypointoffset[i - 1] - cmpt); for (j = 0, cmpt = 0, startheader = offset + s->sh.entrypointoffset[i]; j < nal->skippedbytes; j++) { if (nal->skippedbytespos[j] >= offset && nal->skippedbytespos[j] < startheader) { startheader--; cmpt++; } } s->sh.size[i - 1] = s->sh.entrypointoffset[i] - cmpt; s->sh.offset[i - 1] = offset; } if (s->sh.numentrypointoffsets != 0) { offset += s->sh.entrypointoffset[s->sh.numentrypointoffsets - 1] - cmpt; if (length < offset) { avlog(s->avctx, AVLOGERROR, \"entrypointoffset table is corrupted\\n\"); res = AVERRORINVALIDDATA; goto error; } s->sh.size[s->sh.numentrypointoffsets - 1] = length - offset; s->sh.offset[s->sh.numentrypointoffsets - 1] = offset; } s->data = data; for (i = 1; i < s->threadsnumber; i++) { s->sList[i]->HEVClc->firstqpgroup = 1; s->sList[i]->HEVClc->qpy = s->sList[0]->HEVClc->qpy; memcpy(s->sList[i], s, sizeof(HEVCContext)); s->sList[i]->HEVClc = s->HEVClcList[i]; } avprivatomicintset(&s->wpperr, 0); ffresetentries(s->avctx); for (i = 0; i <= s->sh.numentrypointoffsets; i++) { arg[i] = i; ret[i] = 0; } if (s->ps.pps->entropycodingsyncenabledflag) s->avctx->execute2(s->avctx, hlsdecodeentrywpp, arg, ret, s->sh.numentrypointoffsets + 1); for (i = 0; i <= s->sh.numentrypointoffsets; i++) res += ret[i]; error: avfree(ret); avfree(arg); return res; } ", "target": 0}
{"func": "static void pxa2xxlcdcdma0redrawrot0(PXA2xxLCDState *s, hwaddr addr, int *miny, int *maxy) { DisplaySurface *surface = qemuconsolesurface(s->con); int srcwidth, destwidth; drawfn fn = NULL; if (s->destwidth) fn = s->linefn[s->transp][s->bpp]; if (!fn) return; srcwidth = (s->xres + 3) & ~3; /* Pad to a 4 pixels multiple */ if (s->bpp == pxalcdc19pbpp || s->bpp == pxalcdc18pbpp) srcwidth *= 3; else if (s->bpp > pxalcdc16bpp) srcwidth *= 4; else if (s->bpp > pxalcdc8bpp) srcwidth *= 2; destwidth = s->xres * s->destwidth; *miny = 0; framebufferupdatedisplay(surface, s->sysmem, addr, s->xres, s->yres, srcwidth, destwidth, s->destwidth, s->invalidated, fn, s->dmach[0].palette, miny, maxy); } ", "target": 0}
{"func": "builddmarq35(GArray *tabledata, GArray *linker) { int dmarstart = tabledata->len; AcpiTableDmar *dmar; AcpiDmarHardwareUnit *drhd; dmar = acpidatapush(tabledata, sizeof(*dmar)); dmar->hostaddresswidth = VTDHOSTADDRESSWIDTH - 1; dmar->flags = 0; /* No intrremap for now */ /* DMAR Remapping Hardware Unit Definition structure */ drhd = acpidatapush(tabledata, sizeof(*drhd)); drhd->type = cputole16(ACPIDMARTYPEHARDWAREUNIT); drhd->length = cputole16(sizeof(*drhd)); /* No device scope now */ drhd->flags = ACPIDMARINCLUDEPCIALL; drhd->pcisegment = cputole16(0); drhd->address = cputole64(Q35HOSTBRIDGEIOMMUADDR); buildheader(linker, tabledata, (void *)(tabledata->data + dmarstart), \"DMAR\", tabledata->len - dmarstart, 1, NULL); } ", "target": 0}
{"func": "static GtkWidget *gdcreatemenumachine(GtkDisplayState *s, GtkAccelGroup *accelgroup) { GtkWidget *machinemenu; GtkWidget *separator; machinemenu = gtkmenunew(); gtkmenusetaccelgroup(GTKMENU(machinemenu), accelgroup); s->pauseitem = gtkcheckmenuitemnewwithmnemonic((\"Pause\")); gtkmenushellappend(GTKMENUSHELL(machinemenu), s->pauseitem); separator = gtkseparatormenuitemnew(); gtkmenushellappend(GTKMENUSHELL(machinemenu), separator); s->resetitem = gtkmenuitemnewwithmnemonic((\"Reset\")); gtkmenushellappend(GTKMENUSHELL(machinemenu), s->resetitem); s->powerdownitem = gtkmenuitemnewwithmnemonic((\"Power Down\")); gtkmenushellappend(GTKMENUSHELL(machinemenu), s->powerdownitem); separator = gtkseparatormenuitemnew(); gtkmenushellappend(GTKMENUSHELL(machinemenu), separator); s->quititem = gtkmenuitemnewwithmnemonic((\"Quit\")); gtkmenuitemsetaccelpath(GTKMENUITEM(s->quititem), \"<QEMU>/Machine/Quit\"); gtkaccelmapaddentry(\"<QEMU>/Machine/Quit\", GDKKEYq, GDKCONTROLMASK); gtkmenushellappend(GTKMENUSHELL(machinemenu), s->quititem); return machinemenu; } ", "target": 0}
{"func": "static void mv88w8618flashcfgwrite(void *opaque, targetphysaddrt offset, uint64t value, unsigned size) { mv88w8618flashcfgstate *s = opaque; switch (offset) { case MPFLASHCFGCFGR0: s->cfgr0 = value; break; } } ", "target": 0}
{"func": "static int qemurdmagetfd(void *opaque) { QEMUFileRDMA *rfile = opaque; RDMAContext *rdma = rfile->rdma; return rdma->compchannel->fd; } ", "target": 1}
{"func": "static void dumpppcinsns (CPUPPCState *env) { opchandlert **table, *handler; const char *p, *q; uint8t opc1, opc2, opc3; printf(\"Instructions set:\\n\"); /* opc1 is 6 bits long */ for (opc1 = 0x00; opc1 < PPCCPUOPCODESLEN; opc1++) { table = env->opcodes; handler = table[opc1]; if (isindirectopcode(handler)) { /* opc2 is 5 bits long */ for (opc2 = 0; opc2 < PPCCPUINDIRECTOPCODESLEN; opc2++) { table = env->opcodes; handler = env->opcodes[opc1]; table = indtable(handler); handler = table[opc2]; if (isindirectopcode(handler)) { table = indtable(handler); /* opc3 is 5 bits long */ for (opc3 = 0; opc3 < PPCCPUINDIRECTOPCODESLEN; opc3++) { handler = table[opc3]; if (handler->handler != &geninvalid) { /* Special hack to properly dump SPE insns */ p = strchr(handler->oname, ''); if (p == NULL) { printf(\"INSN: %02x %02x %02x (%02d %04d) : \" \"%s\\n\", opc1, opc2, opc3, opc1, (opc3 << 5) | opc2, handler->oname); } else { q = \"speundef\"; if ((p - handler->oname) != strlen(q) || memcmp(handler->oname, q, strlen(q)) != 0) { /* First instruction */ printf(\"INSN: %02x %02x %02x (%02d %04d) : \" \"%.*s\\n\", opc1, opc2 << 1, opc3, opc1, (opc3 << 6) | (opc2 << 1), (int)(p - handler->oname), handler->oname); } if (strcmp(p + 1, q) != 0) { /* Second instruction */ printf(\"INSN: %02x %02x %02x (%02d %04d) : \" \"%s\\n\", opc1, (opc2 << 1) | 1, opc3, opc1, (opc3 << 6) | (opc2 << 1) | 1, p + 1); } } } } } else { if (handler->handler != &geninvalid) { printf(\"INSN: %02x %02x -- (%02d %04d) : %s\\n\", opc1, opc2, opc1, opc2, handler->oname); } } } } else { if (handler->handler != &geninvalid) { printf(\"INSN: %02x -- -- (%02d ----) : %s\\n\", opc1, opc1, handler->oname); } } } } ", "target": 1}
{"func": "yuv2rgb2ctemplate(SwsContext *c, const int16t *buf[2], const int16t *ubuf[2], const int16t *vbuf[2], const int16t *abuf[2], uint8t *dest, int dstW, int yalpha, int uvalpha, int y, enum PixelFormat target, int hasAlpha) { const int16t *buf0 = buf[0], *buf1 = buf[1], *ubuf0 = ubuf[0], *ubuf1 = ubuf[1], *vbuf0 = vbuf[0], *vbuf1 = vbuf[1], *abuf0 = abuf[0], *abuf1 = abuf[1]; int yalpha1 = 4095 - yalpha; int uvalpha1 = 4095 - uvalpha; int i; for (i = 0; i < (dstW >> 1); i++) { int Y1 = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19; int Y2 = (buf0[i * 2 + 1] * yalpha1 + buf1[i * 2 + 1] * yalpha) >> 19; int U = (ubuf0[i] * uvalpha1 + ubuf1[i] * uvalpha) >> 19; int V = (vbuf0[i] * uvalpha1 + vbuf1[i] * uvalpha) >> 19; int A1, A2; const void *r = c->tablerV[V], *g = (c->tablegU[U] + c->tablegV[V]), *b = c->tablebU[U]; if (hasAlpha) { A1 = (abuf0[i * 2 ] * yalpha1 + abuf1[i * 2 ] * yalpha) >> 19; A2 = (abuf0[i * 2 + 1] * yalpha1 + abuf1[i * 2 + 1] * yalpha) >> 19; } yuv2rgbwrite(dest, i, Y1, Y2, U, V, hasAlpha ? A1 : 0, hasAlpha ? A2 : 0, r, g, b, y, target, hasAlpha); } } ", "target": 1}
{"func": "static int minimumframebits(VC2EncContext *s) { int slicex, slicey, bits = 0; s->sizescaler = 64; for (slicey = 0; slicey < s->numy; slicey++) { for (slicex = 0; slicex < s->numx; slicex++) { bits += counthqslice(s, NULL, slicex, slicey, s->qceil); } } return bits; } ", "target": 1}
{"func": "static void fdcoroutineenter(void *opaque) { FDYieldUntilData *data = opaque; qemusetfdhandler(data->fd, NULL, NULL, NULL); qemucoroutineenter(data->co, NULL); } ", "target": 1}
{"func": "static void qcowaiowritecb(void *opaque, int ret) { QCowAIOCB *acb = opaque; BlockDriverState *bs = acb->common.bs; BDRVQcowState *s = bs->opaque; int indexincluster; uint64t clusteroffset; const uint8t *srcbuf; int nend; acb->hdaiocb = NULL; if (ret < 0) { fail: acb->common.cb(acb->common.opaque, ret); qemuaiorelease(acb); return; } acb->nbsectors -= acb->n; acb->sectornum += acb->n; acb->buf += acb->n * 512; if (acb->nbsectors == 0) { /* request completed */ acb->common.cb(acb->common.opaque, 0); qemuaiorelease(acb); return; } indexincluster = acb->sectornum & (s->clustersectors - 1); nend = indexincluster + acb->nbsectors; if (s->cryptmethod && nend > QCOWMAXCRYPTCLUSTERS * s->clustersectors) nend = QCOWMAXCRYPTCLUSTERS * s->clustersectors; clusteroffset = allocclusteroffset(bs, acb->sectornum << 9, indexincluster, nend, &acb->n); if (!clusteroffset || (clusteroffset & 511) != 0) { ret = -EIO; goto fail; } if (s->cryptmethod) { if (!acb->clusterdata) { acb->clusterdata = qemumallocz(QCOWMAXCRYPTCLUSTERS * s->clustersize); if (!acb->clusterdata) { ret = -ENOMEM; goto fail; } } encryptsectors(s, acb->sectornum, acb->clusterdata, acb->buf, acb->n, 1, &s->aesencryptkey); srcbuf = acb->clusterdata; } else { srcbuf = acb->buf; } acb->hdaiocb = bdrvaiowrite(s->hd, (clusteroffset >> 9) + indexincluster, srcbuf, acb->n, qcowaiowritecb, acb); if (acb->hdaiocb == NULL) goto fail; } ", "target": 1}
{"func": "static int optinputfile(const char *opt, const char *filename) { AVFormatContext *ic; AVInputFormat *fileiformat = NULL; int err, i, ret, rfps, rfpsbase; int64t timestamp; uint8t buf[128]; AVDictionary **opts; int orignbstreams; // number of streams before avformatfindstreaminfo if (lastaskedformat) { if (!(fileiformat = avfindinputformat(lastaskedformat))) { fprintf(stderr, \"Unknown input format: '%s'\\n\", lastaskedformat); ffmpegexit(1); } lastaskedformat = NULL; } if (!strcmp(filename, \"-\")) filename = \"pipe:\"; usingstdin |= !strncmp(filename, \"pipe:\", 5) || !strcmp(filename, \"/dev/stdin\"); /* get default parameters from command line */ ic = avformatalloccontext(); if (!ic) { printerror(filename, AVERROR(ENOMEM)); ffmpegexit(1); } if (audiosamplerate) { snprintf(buf, sizeof(buf), \"%d\", audiosamplerate); avdictset(&formatopts, \"samplerate\", buf, 0); } if (audiochannels) { snprintf(buf, sizeof(buf), \"%d\", audiochannels); avdictset(&formatopts, \"channels\", buf, 0); } if (framerate.num) { snprintf(buf, sizeof(buf), \"%d/%d\", framerate.num, framerate.den); avdictset(&formatopts, \"framerate\", buf, 0); } if (framewidth && frameheight) { snprintf(buf, sizeof(buf), \"%dx%d\", framewidth, frameheight); avdictset(&formatopts, \"videosize\", buf, 0); } if (framepixfmt != PIXFMTNONE) avdictset(&formatopts, \"pixelformat\", avgetpixfmtname(framepixfmt), 0); ic->videocodecid = findcodecordie(videocodecname , AVMEDIATYPEVIDEO , 0); ic->audiocodecid = findcodecordie(audiocodecname , AVMEDIATYPEAUDIO , 0); ic->subtitlecodecid= findcodecordie(subtitlecodecname, AVMEDIATYPESUBTITLE, 0); ic->flags |= AVFMTFLAGNONBLOCK; /* open the input file with generic libav function */ err = avformatopeninput(&ic, filename, fileiformat, &formatopts); if (err < 0) { printerror(filename, err); ffmpegexit(1); } assertavoptions(formatopts); if(optprogramid) { int i, j; int found=0; for(i=0; i<ic->nbstreams; i++){ ic->streams[i]->discard= AVDISCARDALL; } for(i=0; i<ic->nbprograms; i++){ AVProgram *p= ic->programs[i]; if(p->id != optprogramid){ p->discard = AVDISCARDALL; }else{ found=1; for(j=0; j<p->nbstreamindexes; j++){ ic->streams[p->streamindex[j]]->discard= AVDISCARDDEFAULT; } } } if(!found){ fprintf(stderr, \"Specified program id not found\\n\"); ffmpegexit(1); } optprogramid=0; } if (loopinput) { avlog(NULL, AVLOGWARNING, \"-loopinput is deprecated, use -loop 1\\n\"); ic->loopinput = loopinput; } /* Set AVCodecContext options for avformatfindstreaminfo */ opts = setupfindstreaminfoopts(ic, codecopts); orignbstreams = ic->nbstreams; /* If not enough info to get the stream parameters, we decode the first frames to get it. (used in mpeg case for example) */ ret = avformatfindstreaminfo(ic, opts); if (ret < 0 && verbose >= 0) { fprintf(stderr, \"%s: could not find codec parameters\\n\", filename); avcloseinputfile(ic); ffmpegexit(1); } timestamp = starttime; /* add the stream start time */ if (ic->starttime != AVNOPTSVALUE) timestamp += ic->starttime; /* if seeking requested, we execute it */ if (starttime != 0) { ret = avseekframe(ic, -1, timestamp, AVSEEKFLAGBACKWARD); if (ret < 0) { fprintf(stderr, \"%s: could not seek to position %0.3f\\n\", filename, (double)timestamp / AVTIMEBASE); } /* reset seek info */ starttime = 0; } /* update the current parameters so that they match the one of the input stream */ for(i=0;i<ic->nbstreams;i++) { AVStream *st = ic->streams[i]; AVCodecContext *dec = st->codec; InputStream *ist; dec->threadcount = threadcount; inputstreams = growarray(inputstreams, sizeof(*inputstreams), &nbinputstreams, nbinputstreams + 1); ist = &inputstreams[nbinputstreams - 1]; ist->st = st; ist->fileindex = nbinputfiles; ist->discard = 1; ist->opts = filtercodecopts(codecopts, ist->st->codec->codecid, 0); if (i < nbtsscale) ist->tsscale = tsscale[i]; switch (dec->codectype) { case AVMEDIATYPEAUDIO: ist->dec = avcodecfinddecoderbyname(audiocodecname); if(!ist->dec) ist->dec = avcodecfinddecoder(dec->codecid); if(audiodisable) st->discard= AVDISCARDALL; break; case AVMEDIATYPEVIDEO: ist->dec= avcodecfinddecoderbyname(videocodecname); if(!ist->dec) ist->dec = avcodecfinddecoder(dec->codecid); rfps = ic->streams[i]->rframerate.num; rfpsbase = ic->streams[i]->rframerate.den; if (dec->lowres) { dec->flags |= CODECFLAGEMUEDGE; } if(methreshold) dec->debug |= FFDEBUGMV; if (dec->timebase.den != rfps*dec->ticksperframe || dec->timebase.num != rfpsbase) { if (verbose >= 0) fprintf(stderr,\"\\nSeems stream %d codec frame rate differs from container frame rate: %2.2f (%d/%d) -> %2.2f (%d/%d)\\n\", i, (float)dec->timebase.den / dec->timebase.num, dec->timebase.den, dec->timebase.num, (float)rfps / rfpsbase, rfps, rfpsbase); } if(videodisable) st->discard= AVDISCARDALL; else if(videodiscard) st->discard= videodiscard; break; case AVMEDIATYPEDATA: break; case AVMEDIATYPESUBTITLE: ist->dec = avcodecfinddecoderbyname(subtitlecodecname); if(!ist->dec) ist->dec = avcodecfinddecoder(dec->codecid); if(subtitledisable) st->discard = AVDISCARDALL; break; case AVMEDIATYPEATTACHMENT: case AVMEDIATYPEUNKNOWN: break; default: abort(); } } /* dump the file content */ if (verbose >= 0) avdumpformat(ic, nbinputfiles, filename, 0); inputfiles = growarray(inputfiles, sizeof(*inputfiles), &nbinputfiles, nbinputfiles + 1); inputfiles[nbinputfiles - 1].ctx = ic; inputfiles[nbinputfiles - 1].istindex = nbinputstreams - ic->nbstreams; inputfiles[nbinputfiles - 1].tsoffset = inputtsoffset - (copyts ? 0 : timestamp); topfieldfirst = -1; framerate = (AVRational){0, 0}; framepixfmt = PIXFMTNONE; frameheight = 0; framewidth = 0; audiosamplerate = 0; audiochannels = 0; audiosamplefmt = AVSAMPLEFMTNONE; avfreep(&tsscale); nbtsscale = 0; for (i = 0; i < orignbstreams; i++) avdictfree(&opts[i]); avfreep(&opts); avfreep(&videocodecname); avfreep(&audiocodecname); avfreep(&subtitlecodecname); uninitopts(); initopts(); return 0; } ", "target": 0}
{"func": "static int usbhubhandlecontrol(USBDevice *dev, USBPacket *p, int request, int value, int index, int length, uint8t *data) { USBHubState *s = (USBHubState *)dev; int ret; ret = usbdeschandlecontrol(dev, p, request, value, index, length, data); if (ret >= 0) { return ret; } switch(request) { case EndpointOutRequest | USBREQCLEARFEATURE: if (value == 0 && index != 0x81) { /* clear ep halt */ goto fail; } ret = 0; break; case DeviceRequest | USBREQGETINTERFACE: data[0] = 0; ret = 1; break; case DeviceOutRequest | USBREQSETINTERFACE: ret = 0; break; /* usb specific requests */ case GetHubStatus: data[0] = 0; data[1] = 0; data[2] = 0; data[3] = 0; ret = 4; break; case GetPortStatus: { unsigned int n = index - 1; USBHubPort *port; if (n >= NUMPORTS) { goto fail; } port = &s->ports[n]; data[0] = port->wPortStatus; data[1] = port->wPortStatus >> 8; data[2] = port->wPortChange; data[3] = port->wPortChange >> 8; ret = 4; } break; case SetHubFeature: case ClearHubFeature: if (value == 0 || value == 1) { } else { goto fail; } ret = 0; break; case SetPortFeature: { unsigned int n = index - 1; USBHubPort *port; USBDevice *dev; if (n >= NUMPORTS) { goto fail; } port = &s->ports[n]; dev = port->port.dev; switch(value) { case PORTSUSPEND: port->wPortStatus |= PORTSTATSUSPEND; break; case PORTRESET: if (dev) { usbsendmsg(dev, USBMSGRESET); port->wPortChange |= PORTSTATCRESET; /* set enable bit */ port->wPortStatus |= PORTSTATENABLE; } break; case PORTPOWER: break; default: goto fail; } ret = 0; } break; case ClearPortFeature: { unsigned int n = index - 1; USBHubPort *port; if (n >= NUMPORTS) { goto fail; } port = &s->ports[n]; switch(value) { case PORTENABLE: port->wPortStatus &= ~PORTSTATENABLE; break; case PORTCENABLE: port->wPortChange &= ~PORTSTATCENABLE; break; case PORTSUSPEND: port->wPortStatus &= ~PORTSTATSUSPEND; break; case PORTCSUSPEND: port->wPortChange &= ~PORTSTATCSUSPEND; break; case PORTCCONNECTION: port->wPortChange &= ~PORTSTATCCONNECTION; break; case PORTCOVERCURRENT: port->wPortChange &= ~PORTSTATCOVERCURRENT; break; case PORTCRESET: port->wPortChange &= ~PORTSTATCRESET; break; default: goto fail; } ret = 0; } break; case GetHubDescriptor: { unsigned int n, limit, varhubsize = 0; memcpy(data, qemuhubhubdescriptor, sizeof(qemuhubhubdescriptor)); data[2] = NUMPORTS; /* fill DeviceRemovable bits */ limit = ((NUMPORTS + 1 + 7) / 8) + 7; for (n = 7; n < limit; n++) { data[n] = 0x00; varhubsize++; } /* fill PortPwrCtrlMask bits */ limit = limit + ((NUMPORTS + 7) / 8); for (;n < limit; n++) { data[n] = 0xff; varhubsize++; } ret = sizeof(qemuhubhubdescriptor) + varhubsize; data[0] = ret; break; } default: fail: ret = USBRETSTALL; break; } return ret; } ", "target": 0}
{"func": "static int mxfwritepacket(AVFormatContext *s, AVPacket *pkt) { MXFContext *mxf = s->privdata; AVIOContext *pb = s->pb; AVStream *st = s->streams[pkt->streamindex]; MXFStreamContext *sc = st->privdata; MXFIndexEntry ie = {0}; if (!mxf->editunitbytecount && !(mxf->editunitscount % EDITUNITSPERBODY)) { mxf->indexentries = avrealloc(mxf->indexentries, (mxf->editunitscount + EDITUNITSPERBODY)*sizeof(*mxf->indexentries)); if (!mxf->indexentries) { avlog(s, AVLOGERROR, \"could not allocate index entries\\n\"); return -1; } } if (st->codec->codecid == AVCODECIDMPEG2VIDEO) { if (!mxfparsempeg2frame(s, st, pkt, &ie)) { avlog(s, AVLOGERROR, \"could not get mpeg2 profile and level\\n\"); return -1; } } if (!mxf->headerwritten) { if (mxf->editunitbytecount) { mxfwritepartition(s, 1, 2, headeropenpartitionkey, 1); mxfwriteklvfill(s); mxfwriteindextablesegment(s); } else { mxfwritepartition(s, 0, 0, headeropenpartitionkey, 1); } mxf->headerwritten = 1; } if (st->index == 0) { if (!mxf->editunitbytecount && (!mxf->editunitscount || mxf->editunitscount > EDITUNITSPERBODY) && !(ie.flags & 0x33)) { // I frame, Gop start mxfwriteklvfill(s); mxfwritepartition(s, 1, 2, bodypartitionkey, 0); mxfwriteklvfill(s); mxfwriteindextablesegment(s); } mxfwriteklvfill(s); mxfwritesystemitem(s); if (!mxf->editunitbytecount) { mxf->indexentries[mxf->editunitscount].offset = mxf->bodyoffset; mxf->indexentries[mxf->editunitscount].flags = ie.flags; mxf->indexentries[mxf->editunitscount].temporalref = ie.temporalref; mxf->bodyoffset += KAGSIZE; // size of system element } mxf->editunitscount++; } else if (!mxf->editunitbytecount && st->index == 1) { mxf->indexentries[mxf->editunitscount-1].sliceoffset = mxf->bodyoffset - mxf->indexentries[mxf->editunitscount-1].offset; } mxfwriteklvfill(s); aviowrite(pb, sc->trackessenceelementkey, 16); // write key if (s->oformat == &ffmxfd10muxer) { if (st->codec->codectype == AVMEDIATYPEVIDEO) mxfwrited10videopacket(s, st, pkt); else mxfwrited10audiopacket(s, st, pkt); } else { klvencodeber4length(pb, pkt->size); // write length aviowrite(pb, pkt->data, pkt->size); mxf->bodyoffset += 16+4+pkt->size + klvfillsize(16+4+pkt->size); } avioflush(pb); return 0; } ", "target": 0}
{"func": "int cpuarmhandlemmufault (CPUState *env, targetulong address, int accesstype, int mmuidx, int issoftmmu) { uint32t physaddr; targetulong pagesize; int prot; int ret, isuser; isuser = mmuidx == MMUUSERIDX; ret = getphysaddr(env, address, accesstype, isuser, &physaddr, &prot, &pagesize); if (ret == 0) { /* Map a single [sub]page. */ physaddr &= ~(uint32t)0x3ff; address &= ~(uint32t)0x3ff; tlbsetpage (env, address, physaddr, prot | PAGEEXEC, mmuidx, pagesize); return 0; } if (accesstype == 2) { env->cp15.c5insn = ret; env->cp15.c6insn = address; env->exceptionindex = EXCPPREFETCHABORT; } else { env->cp15.c5data = ret; if (accesstype == 1 && armfeature(env, ARMFEATUREV6)) env->cp15.c5data |= (1 << 11); env->cp15.c6data = address; env->exceptionindex = EXCPDATAABORT; } return 1; } ", "target": 0}
{"func": "static inline int getchromaqp(H264Context *h, int t, int qscale){ return h->pps.chromaqptable[t][qscale]; } ", "target": 0}
{"func": "static int binkbdecodeplane(BinkContext *c, AVFrame *frame, BitstreamContext *bc, int planeidx, int iskey, int ischroma) { int blk, ret; int i, j, bx, by; uint8t *dst, *ref, *refstart, *refend; int v, col[2]; const uint8t *scan; int xoff, yoff; LOCALALIGNED16(int16t, block, [64]); LOCALALIGNED16(int32t, dctblock, [64]); int coordmap[64]; int ybias = iskey ? -15 : 0; int qp; const int stride = frame->linesize[planeidx]; int bw = ischroma ? (c->avctx->width + 15) >> 4 : (c->avctx->width + 7) >> 3; int bh = ischroma ? (c->avctx->height + 15) >> 4 : (c->avctx->height + 7) >> 3; binkbinitbundles(c); refstart = frame->data[planeidx]; refend = frame->data[planeidx] + (bh * frame->linesize[planeidx] + bw) * 8; for (i = 0; i < 64; i++) coordmap[i] = (i & 7) + (i >> 3) * stride; for (by = 0; by < bh; by++) { for (i = 0; i < BINKBNBSRC; i++) { if ((ret = binkbreadbundle(c, bc, i)) < 0) return ret; } dst = frame->data[planeidx] + 8*by*stride; for (bx = 0; bx < bw; bx++, dst += 8) { blk = binkbgetvalue(c, BINKBSRCBLOCKTYPES); switch (blk) { case 0: break; case 1: scan = binkpatterns[bitstreamread(bc, 4)]; i = 0; do { int mode = bitstreamreadbit(bc); int run = bitstreamread(bc, binkbrunbits[i]) + 1; i += run; if (i > 64) { avlog(c->avctx, AVLOGERROR, \"Run went out of bounds\\n\"); return AVERRORINVALIDDATA; } if (mode) { v = binkbgetvalue(c, BINKBSRCCOLORS); for (j = 0; j < run; j++) dst[coordmap[*scan++]] = v; } else { for (j = 0; j < run; j++) dst[coordmap[*scan++]] = binkbgetvalue(c, BINKBSRCCOLORS); } } while (i < 63); if (i == 63) dst[coordmap[*scan++]] = binkbgetvalue(c, BINKBSRCCOLORS); break; case 2: memset(dctblock, 0, sizeof(*dctblock) * 64); dctblock[0] = binkbgetvalue(c, BINKBSRCINTRADC); qp = binkbgetvalue(c, BINKBSRCINTRAQ); readdctcoeffs(bc, dctblock, binkscan, binkbintraquant, qp); c->binkdsp.idctput(dst, stride, dctblock); break; case 3: xoff = binkbgetvalue(c, BINKBSRCXOFF); yoff = binkbgetvalue(c, BINKBSRCYOFF) + ybias; ref = dst + xoff + yoff * stride; if (ref < refstart || ref + 8*stride > refend) { avlog(c->avctx, AVLOGWARNING, \"Reference block is out of bounds\\n\"); } else if (ref + 8*stride < dst || ref >= dst + 8*stride) { c->hdsp.putpixelstab[1][0](dst, ref, stride, 8); } else { putpixels8x8overlapped(dst, ref, stride); } c->bdsp.clearblock(block); v = binkbgetvalue(c, BINKBSRCINTERCOEFS); readresidue(bc, block, v); c->binkdsp.addpixels8(dst, block, stride); break; case 4: xoff = binkbgetvalue(c, BINKBSRCXOFF); yoff = binkbgetvalue(c, BINKBSRCYOFF) + ybias; ref = dst + xoff + yoff * stride; if (ref < refstart || ref + 8 * stride > refend) { avlog(c->avctx, AVLOGWARNING, \"Reference block is out of bounds\\n\"); } else if (ref + 8*stride < dst || ref >= dst + 8*stride) { c->hdsp.putpixelstab[1][0](dst, ref, stride, 8); } else { putpixels8x8overlapped(dst, ref, stride); } memset(dctblock, 0, sizeof(*dctblock) * 64); dctblock[0] = binkbgetvalue(c, BINKBSRCINTERDC); qp = binkbgetvalue(c, BINKBSRCINTERQ); readdctcoeffs(bc, dctblock, binkscan, binkbinterquant, qp); c->binkdsp.idctadd(dst, stride, dctblock); break; case 5: v = binkbgetvalue(c, BINKBSRCCOLORS); c->bdsp.fillblocktab[1](dst, v, stride, 8); break; case 6: for (i = 0; i < 2; i++) col[i] = binkbgetvalue(c, BINKBSRCCOLORS); for (i = 0; i < 8; i++) { v = binkbgetvalue(c, BINKBSRCPATTERN); for (j = 0; j < 8; j++, v >>= 1) dst[i*stride + j] = col[v & 1]; } break; case 7: xoff = binkbgetvalue(c, BINKBSRCXOFF); yoff = binkbgetvalue(c, BINKBSRCYOFF) + ybias; ref = dst + xoff + yoff * stride; if (ref < refstart || ref + 8 * stride > refend) { avlog(c->avctx, AVLOGWARNING, \"Reference block is out of bounds\\n\"); } else if (ref + 8*stride < dst || ref >= dst + 8*stride) { c->hdsp.putpixelstab[1][0](dst, ref, stride, 8); } else { putpixels8x8overlapped(dst, ref, stride); } break; case 8: for (i = 0; i < 8; i++) memcpy(dst + i*stride, c->bundle[BINKBSRCCOLORS].curptr + i*8, 8); c->bundle[BINKBSRCCOLORS].curptr += 64; break; default: avlog(c->avctx, AVLOGERROR, \"Unknown block type %d\\n\", blk); return AVERRORINVALIDDATA; } } } if (bitstreamtell(bc) & 0x1F) // next plane data starts at 32-bit boundary bitstreamskip(bc, 32 - (bitstreamtell(bc) & 0x1F)); return 0; } ", "target": 0}
{"func": "static int getcpsr(QEMUFile *f, void *opaque, sizet size) { ARMCPU *cpu = opaque; CPUARMState *env = &cpu->env; uint32t val = qemugetbe32(f); env->aarch64 = ((val & PSTATEnRW) == 0); if (isa64(env)) { pstatewrite(env, val); return 0; } /* Avoid mode switch when restoring CPSR */ env->uncachedcpsr = val & CPSRM; cpsrwrite(env, val, 0xffffffff, CPSRWriteRaw); return 0; } ", "target": 1}
{"func": "static void termhandlebyte(int ch) { switch(termescstate) { case ISNORM: switch(ch) { case 1: termbol(); break; case 4: termdeletechar(); break; case 5: termeol(); break; case 9: termcompletion(); break; case 10: case 13: termcmdbuf[termcmdbufsize] = '\\0'; \t termhistadd(termcmdbuf); termprintf(\"\\n\"); termhandlecommand(termcmdbuf); termshowprompt(); break; case 27: termescstate = ISESC; break; case 127: case 8: termbackspace(); break; \tcase 155: termescstate = ISCSI; \t break; default: if (ch >= 32) { terminsertchar(ch); } break; } break; case ISESC: if (ch == '[') { termescstate = ISCSI; termescparam = 0; } else { termescstate = ISNORM; } break; case ISCSI: switch(ch) { \tcase 'A': \tcase 'F': \t termupchar(); \t break; \tcase 'B': \tcase 'E': \t termdownchar(); \t break; case 'D': termbackwardchar(); break; case 'C': termforwardchar(); break; case '0' ... '9': termescparam = termescparam * 10 + (ch - '0'); goto theend; case '~': switch(termescparam) { case 1: termbol(); break; case 3: termdeletechar(); break; case 4: termeol(); break; } break; default: break; } termescstate = ISNORM; theend: break; } termupdate(); } ", "target": 0}
{"func": "struct omapl4s *omapl4init(targetphysaddrt base, int tanum) { struct omapl4s *bus = gmalloc0( sizeof(*bus) + tanum * sizeof(*bus->ta)); bus->tanum = tanum; bus->base = base; #ifdef L4MUXHACK omapl4ioentries = 1; omapl4ioentry = gmalloc0(125 * sizeof(*omapl4ioentry)); omapcpuioentry = cpuregisteriomemory(omapl4ioreadfn, omapl4iowritefn, bus, DEVICENATIVEENDIAN); # define L4PAGES\t(0xb4000 / TARGETPAGESIZE) omapl4ioreadbfn = gmalloc0(sizeof(void *) * L4PAGES); omapl4ioreadhfn = gmalloc0(sizeof(void *) * L4PAGES); omapl4ioreadwfn = gmalloc0(sizeof(void *) * L4PAGES); omapl4iowritebfn = gmalloc0(sizeof(void *) * L4PAGES); omapl4iowritehfn = gmalloc0(sizeof(void *) * L4PAGES); omapl4iowritewfn = gmalloc0(sizeof(void *) * L4PAGES); omapl4ioopaque = gmalloc0(sizeof(void *) * L4PAGES); #endif return bus; } ", "target": 0}
{"func": "static void qbuslistbus(DeviceState *dev, char *dest, int len) { BusState *child; const char *sep = \" \"; int pos = 0; pos += snprintf(dest+pos, len-pos,\"child busses at \\\"%s\\\":\", dev->id ? dev->id : dev->info->name); LISTFOREACH(child, &dev->childbus, sibling) { pos += snprintf(dest+pos, len-pos, \"%s\\\"%s\\\"\", sep, child->name); sep = \", \"; } } ", "target": 0}
{"func": "static int readdirectory(BDRVVVFATState* s, int mappingindex) { mappingt* mapping = arrayget(&(s->mapping), mappingindex); direntryt* direntry; const char* dirname = mapping->path; int firstcluster = mapping->begin; int parentindex = mapping->info.dir.parentmappingindex; mappingt* parentmapping = (mappingt*) (parentindex >= 0 ? arrayget(&(s->mapping), parentindex) : NULL); int firstclusterofparent = parentmapping ? parentmapping->begin : -1; DIR* dir=opendir(dirname); struct dirent* entry; int i; assert(mapping->mode & MODEDIRECTORY); if(!dir) { mapping->end = mapping->begin; return -1; } i = mapping->info.dir.firstdirindex = firstcluster == 0 ? 0 : s->directory.next; if (firstcluster != 0) { /* create the top entries of a subdirectory */ (void)createshortandlongname(s, i, \".\", 1); (void)createshortandlongname(s, i, \"..\", 1); } /* actually read the directory, and allocate the mappings */ while((entry=readdir(dir))) { unsigned int length=strlen(dirname)+2+strlen(entry->dname); char* buffer; direntryt* direntry; struct stat st; int isdot=!strcmp(entry->dname,\".\"); int isdotdot=!strcmp(entry->dname,\"..\"); if(firstcluster == 0 && (isdotdot || isdot)) continue; buffer = gmalloc(length); snprintf(buffer,length,\"%s/%s\",dirname,entry->dname); if(stat(buffer,&st)<0) { gfree(buffer); continue; } /* create directory entry for this file */ if (!isdot && !isdotdot) { direntry = createshortandlongname(s, i, entry->dname, 0); } else { direntry = arrayget(&(s->directory), isdot ? i : i + 1); } direntry->attributes=(SISDIR(st.stmode)?0x10:0x20); direntry->reserved[0]=direntry->reserved[1]=0; direntry->ctime=fatdatetime(st.stctime,1); direntry->cdate=fatdatetime(st.stctime,0); direntry->adate=fatdatetime(st.statime,0); direntry->beginhi=0; direntry->mtime=fatdatetime(st.stmtime,1); direntry->mdate=fatdatetime(st.stmtime,0); if(isdotdot) setbeginofdirentry(direntry, firstclusterofparent); else if(isdot) setbeginofdirentry(direntry, firstcluster); else direntry->begin=0; /* do that later */ if (st.stsize > 0x7fffffff) { fprintf(stderr, \"File %s is larger than 2GB\\n\", buffer); gfree(buffer); closedir(dir); return -2; } direntry->size=cputole32(SISDIR(st.stmode)?0:st.stsize); /* create mapping for this file */ if(!isdot && !isdotdot && (SISDIR(st.stmode) || st.stsize)) { s->currentmapping = arraygetnext(&(s->mapping)); s->currentmapping->begin=0; s->currentmapping->end=st.stsize; /* * we get the direntry of the most recent direntry, which * contains the short name and all the relevant information. */ s->currentmapping->dirindex=s->directory.next-1; s->currentmapping->firstmappingindex = -1; if (SISDIR(st.stmode)) { s->currentmapping->mode = MODEDIRECTORY; s->currentmapping->info.dir.parentmappingindex = mappingindex; } else { s->currentmapping->mode = MODEUNDEFINED; s->currentmapping->info.file.offset = 0; } s->currentmapping->path=buffer; s->currentmapping->readonly = (st.stmode & (SIWUSR | SIWGRP | SIWOTH)) == 0; } else { gfree(buffer); } } closedir(dir); /* fill with zeroes up to the end of the cluster */ while(s->directory.next%(0x10*s->sectorspercluster)) { direntryt* direntry=arraygetnext(&(s->directory)); memset(direntry,0,sizeof(direntryt)); } /* TODO: if there are more entries, bootsector has to be adjusted! */ #define ROOTENTRIES (0x02 * 0x10 * s->sectorspercluster) if (mappingindex == 0 && s->directory.next < ROOTENTRIES) { /* root directory */ int cur = s->directory.next; arrayensureallocated(&(s->directory), ROOTENTRIES - 1); s->directory.next = ROOTENTRIES; memset(arrayget(&(s->directory), cur), 0, (ROOTENTRIES - cur) * sizeof(direntryt)); } /* re-get the mapping, since s->mapping was possibly realloc()ed */ mapping = arrayget(&(s->mapping), mappingindex); firstcluster += (s->directory.next - mapping->info.dir.firstdirindex) * 0x20 / s->clustersize; mapping->end = firstcluster; direntry = arrayget(&(s->directory), mapping->dirindex); setbeginofdirentry(direntry, mapping->begin); return 0; } ", "target": 1}
{"func": "static int replaceintdatainfilename(char *buf, int bufsize, const char *filename, char placeholder, int64t number) { const char *p; char *q, buf1[20], c; int nd, len, addcharcount; int foundcount = 0; q = buf; p = filename; for (;;) { c = *p; if (c == '\\0') break; if (c == '%' && *(p+1) == '%') // %% addcharcount = 2; else if (c == '%' && (avisdigit(*(p+1)) || *(p+1) == placeholder)) { nd = 0; addcharcount = 1; while (avisdigit(*(p + addcharcount))) { nd = nd * 10 + *(p + addcharcount) - '0'; addcharcount++; } if (*(p + addcharcount) == placeholder) { len = snprintf(buf1, sizeof(buf1), \"%0*\"PRId64, (number < 0) ? nd : nd++, number); if (len < 1) // returned error or empty buf1 goto fail; if ((q - buf + len) > bufsize - 1) goto fail; memcpy(q, buf1, len); q += len; p += (addcharcount + 1); addcharcount = 0; foundcount++; } } else addcharcount = 1; while (addcharcount--) if ((q - buf) < bufsize - 1) *q++ = *p++; else goto fail; } *q = '\\0'; return foundcount; fail: *q = '\\0'; return -1; } ", "target": 0}
{"func": "static void cubieboardinit(QEMUMachineInitArgs *args) { CubieBoardState *s = gnew(CubieBoardState, 1); Error *err = NULL; s->a10 = AWA10(objectnew(TYPEAWA10)); objectpropertysetbool(OBJECT(s->a10), true, \"realized\", &err); if (err != NULL) { errorreport(\"Couldn't realize Allwinner A10: %s\\n\", errorgetpretty(err)); exit(1); } memoryregioninitram(&s->sdram, NULL, \"cubieboard.ram\", args->ramsize); vmstateregisterramglobal(&s->sdram); memoryregionaddsubregion(getsystemmemory(), AWA10SDRAMBASE, &s->sdram); cubieboardbinfo.ramsize = args->ramsize; cubieboardbinfo.kernelfilename = args->kernelfilename; cubieboardbinfo.kernelcmdline = args->kernelcmdline; armloadkernel(&s->a10->cpu, &cubieboardbinfo); } ", "target": 0}
{"func": "void espinit(targetphysaddrt espaddr, int itshift, ESPDMAMemoryReadWriteFunc dmamemoryread, ESPDMAMemoryReadWriteFunc dmamemorywrite, void *dmaopaque, qemuirq irq, qemuirq *reset, qemuirq *dmaenable) { DeviceState *dev; SysBusDevice *s; SysBusESPState *sysbus; ESPState *esp; dev = qdevcreate(NULL, \"esp\"); sysbus = DOUPCAST(SysBusESPState, busdev.qdev, dev); esp = &sysbus->esp; esp->dmamemoryread = dmamemoryread; esp->dmamemorywrite = dmamemorywrite; esp->dmaopaque = dmaopaque; sysbus->itshift = itshift; /* XXX for now until rc4030 has been changed to use DMA enable signal */ esp->dmaenabled = 1; qdevinitnofail(dev); s = sysbusfromqdev(dev); sysbusconnectirq(s, 0, irq); sysbusmmiomap(s, 0, espaddr); *reset = qdevgetgpioin(dev, 0); *dmaenable = qdevgetgpioin(dev, 1); } ", "target": 0}
{"func": "static void applywindowandmdct(AVCodecContext *avctx, const AVFrame *frame) { WMACodecContext *s = avctx->privdata; float **audio = (float **) frame->extendeddata; int len = frame->nbsamples; int windowindex = s->framelenbits - s->blocklenbits; FFTContext *mdct = &s->mdctctx[windowindex]; int ch; const float *win = s->windows[windowindex]; int windowlen = 1 << s->blocklenbits; float n = 2.0 * 32768.0 / windowlen; for (ch = 0; ch < avctx->channels; ch++) { memcpy(s->output, s->frameout[ch], windowlen * sizeof(*s->output)); s->fdsp->vectorfmulscalar(s->frameout[ch], audio[ch], n, len); s->fdsp->vectorfmulreverse(&s->output[windowlen], s->frameout[ch], win, len); s->fdsp->vectorfmul(s->frameout[ch], s->frameout[ch], win, len); mdct->mdctcalc(mdct, s->coefs[ch], s->output); } } ", "target": 0}
{"func": "static void diffpixelsaltivec(int16t *restrict block, const uint8t *s1, const uint8t *s2, int stride) { int i; vecu8 perm1 = veclvsl(0, s1); vecu8 perm2 = veclvsl(0, s2); const vecu8 zero = (const vecu8)vecsplatu8(0); vecs16 shorts1, shorts2; for (i = 0; i < 4; i++) { /* Read potentially unaligned pixels. * We're reading 16 pixels, and actually only want 8, * but we simply ignore the extras. */ vecu8 pixl = vecld(0, s1); vecu8 pixr = vecld(15, s1); vecu8 bytes = vecperm(pixl, pixr, perm1); // Convert the bytes into shorts. shorts1 = (vecs16)vecmergeh(zero, bytes); // Do the same for the second block of pixels. pixl = vecld(0, s2); pixr = vecld(15, s2); bytes = vecperm(pixl, pixr, perm2); // Convert the bytes into shorts. shorts2 = (vecs16)vecmergeh(zero, bytes); // Do the subtraction. shorts1 = vecsub(shorts1, shorts2); // Save the data to the block, we assume the block is 16-byte aligned. vecst(shorts1, 0, (vecs16 *)block); s1 += stride; s2 += stride; block += 8; /* The code below is a copy of the code above... * This is a manual unroll. */ /* Read potentially unaligned pixels. * We're reading 16 pixels, and actually only want 8, * but we simply ignore the extras. */ pixl = vecld(0, s1); pixr = vecld(15, s1); bytes = vecperm(pixl, pixr, perm1); // Convert the bytes into shorts. shorts1 = (vecs16)vecmergeh(zero, bytes); // Do the same for the second block of pixels. pixl = vecld(0, s2); pixr = vecld(15, s2); bytes = vecperm(pixl, pixr, perm2); // Convert the bytes into shorts. shorts2 = (vecs16)vecmergeh(zero, bytes); // Do the subtraction. shorts1 = vecsub(shorts1, shorts2); // Save the data to the block, we assume the block is 16-byte aligned. vecst(shorts1, 0, (vecs16 *)block); s1 += stride; s2 += stride; block += 8; } } ", "target": 1}
{"func": "int ffthreadgetbuffer(AVCodecContext *avctx, AVFrame *f) { PerThreadContext *p = avctx->threadopaque; int *progress, err; f->owner = avctx; ffinitbufferinfo(avctx, f); if (!(avctx->activethreadtype&FFTHREADFRAME)) { f->threadopaque = NULL; return avctx->getbuffer(avctx, f); } if (p->state != STATESETTINGUP && (avctx->codec->updatethreadcontext || (!avctx->threadsafecallbacks && avctx->getbuffer != avcodecdefaultgetbuffer))) { avlog(avctx, AVLOGERROR, \"getbuffer() cannot be called after ffthreadfinishsetup()\\n\"); return -1; } pthreadmutexlock(&p->parent->buffermutex); f->threadopaque = progress = allocateprogress(p); if (!progress) { pthreadmutexunlock(&p->parent->buffermutex); return -1; } progress[0] = progress[1] = -1; if (avctx->threadsafecallbacks || avctx->getbuffer == avcodecdefaultgetbuffer) { err = avctx->getbuffer(avctx, f); } else { p->requestedframe = f; p->state = STATEGETBUFFER; pthreadmutexlock(&p->progressmutex); pthreadcondsignal(&p->progresscond); while (p->state != STATESETTINGUP) pthreadcondwait(&p->progresscond, &p->progressmutex); err = p->result; pthreadmutexunlock(&p->progressmutex); if (!avctx->codec->updatethreadcontext) ffthreadfinishsetup(avctx); } pthreadmutexunlock(&p->parent->buffermutex); return err; } ", "target": 1}
{"func": "bool qiotaskpropagateerror(QIOTask *task, Error **errp) { if (task->err) { errorpropagate(errp, task->err); return true; } return false; }", "target": 1}
{"func": "static void hdsfree(AVFormatContext *s) { HDSContext *c = s->privdata; int i, j; if (!c->streams) return; for (i = 0; i < s->nbstreams; i++) { OutputStream *os = &c->streams[i]; if (os->out) avioclose(os->out); os->out = NULL; if (os->ctx && os->ctxinited) avwritetrailer(os->ctx); if (os->ctx && os->ctx->pb) avfree(os->ctx->pb); if (os->ctx) avformatfreecontext(os->ctx); avfree(os->metadata); for (j = 0; j < os->nbextrapackets; j++) avfree(os->extrapackets[j]); for (j = 0; j < os->nbfragments; j++) avfree(os->fragments[j]); avfree(os->fragments); } avfreep(&c->streams); } ", "target": 0}
{"func": "yuv2ya82c(SwsContext *c, const int16t *buf[2], const int16t *ubuf[2], const int16t *vbuf[2], const int16t *abuf[2], uint8t *dest, int dstW, int yalpha, int uvalpha, int y) { int hasAlpha = abuf[0] && abuf[1]; const int16t *buf0 = buf[0], *buf1 = buf[1], *abuf0 = hasAlpha ? abuf[0] : NULL, *abuf1 = hasAlpha ? abuf[1] : NULL; int yalpha1 = 4096 - yalpha; int i; for (i = 0; i < dstW; i++) { int Y = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19; int A; Y = avclipuint8(Y); if (hasAlpha) { A = (abuf0[i * 2] * yalpha1 + abuf1[i * 2] * yalpha) >> 19; A = avclipuint8(A); } dest[i * 2 ] = Y; dest[i * 2 + 1] = hasAlpha ? A : 255; } } ", "target": 1}
{"func": "static void deviceunparent(Object *obj) { DeviceState *dev = DEVICE(obj); BusState *bus; if (dev->realized) { objectpropertysetbool(obj, false, \"realized\", NULL); } while (dev->numchildbus) { bus = QLISTFIRST(&dev->childbus); objectunparent(OBJECT(bus)); } if (dev->parentbus) { busremovechild(dev->parentbus, dev); objectunref(OBJECT(dev->parentbus)); dev->parentbus = NULL; } /* Only send event if the device had been completely realized */ if (dev->pendingdeletedevent) { gassert(dev->canonicalpath); qapieventsenddevicedeleted(!!dev->id, dev->id, dev->canonicalpath, &errorabort); gfree(dev->canonicalpath); dev->canonicalpath = NULL; } } ", "target": 1}
{"func": "QBool *qboolfrombool(bool value) { QBool *qb; qb = gmalloc(sizeof(*qb)); qb->value = value; QOBJECTINIT(qb, &qbooltype); return qb; } ", "target": 0}
{"func": "static void setuprtframe(int usig, struct emulatedsigaction *ka, targetsiginfot *info, \t\t\t targetsigsett *set, CPUState *env) { \tstruct rtsigframe *frame = getsigframe(ka, env, sizeof(*frame)); \tint err = 0; #if 0 \tif (!accessok(VERIFYWRITE, frame, sizeof (*frame))) return 1; #endif \tputusererror(&frame->info, (targetulong *)&frame->pinfo, err); \tputusererror(&frame->uc, (targetulong *)&frame->puc, err); \terr |= copysiginfotouser(&frame->info, info); \t/* Clear all the bits of the ucontext we don't use. */ \terr |= clearuser(&frame->uc, offsetof(struct ucontext, ucmcontext)); \terr |= setupsigcontext(&frame->uc.ucmcontext, /*&frame->fpstate,*/ \t\t\t\tenv, set->sig[0]); \terr |= copytouser(&frame->uc.ucsigmask, set, sizeof(*set)); \tif (err == 0) \t\terr = setupreturn(env, ka, &frame->retcode, frame, usig); \tif (err == 0) { \t\t/* \t\t * For realtime signals we must also set the second and third \t\t * arguments for the signal handler. \t\t * -- Peter Maydell <pmaydell@chiark.greenend.org.uk> 2000-12-06 \t\t */ env->regs[1] = (targetulong)frame->pinfo; env->regs[2] = (targetulong)frame->puc; \t} //\treturn err; } ", "target": 0}
{"func": "static void spaprphbplacement(sPAPRMachineState *spapr, uint32t index, uint64t *buid, hwaddr *pio, hwaddr *mmio32, hwaddr *mmio64, unsigned ndma, uint32t *liobns, Error **errp) { /* * New-style PHB window placement. * * Goals: Gives large (1TiB), naturally aligned 64-bit MMIO window * for each PHB, in addition to 2GiB 32-bit MMIO and 64kiB PIO * windows. * * Some guest kernels can't work with MMIO windows above 1<<46 * (64TiB), so we place up to 31 PHBs in the area 32TiB..64TiB * * 32TiB..(33TiB+1984kiB) contains the 64kiB PIO windows for each * PHB stacked together. (32TiB+2GiB)..(32TiB+64GiB) contains the * 2GiB 32-bit MMIO windows for each PHB. Then 33..64TiB has the * 1TiB 64-bit MMIO windows for each PHB. */ const uint64t basebuid = 0x800000020000000ULL; const int maxphbs = (SPAPRPCILIMIT - SPAPRPCIBASE) / SPAPRPCIMEM64WINSIZE - 1; int i; /* Sanity check natural alignments */ QEMUBUILDBUGON((SPAPRPCIBASE % SPAPRPCIMEM64WINSIZE) != 0); QEMUBUILDBUGON((SPAPRPCILIMIT % SPAPRPCIMEM64WINSIZE) != 0); QEMUBUILDBUGON((SPAPRPCIMEM64WINSIZE % SPAPRPCIMEM32WINSIZE) != 0); QEMUBUILDBUGON((SPAPRPCIMEM32WINSIZE % SPAPRPCIIOWINSIZE) != 0); /* Sanity check bounds */ QEMUBUILDBUGON((maxphbs * SPAPRPCIIOWINSIZE) > SPAPRPCIMEM32WINSIZE); QEMUBUILDBUGON((maxphbs * SPAPRPCIMEM32WINSIZE) > SPAPRPCIMEM64WINSIZE); if (index >= maxphbs) { errorsetg(errp, \"\\\"index\\\" for PAPR PHB is too large (max %u)\", maxphbs - 1); return; } *buid = basebuid + index; for (i = 0; i < ndma; ++i) { liobns[i] = SPAPRPCILIOBN(index, i); } *pio = SPAPRPCIBASE + index * SPAPRPCIIOWINSIZE; *mmio32 = SPAPRPCIBASE + (index + 1) * SPAPRPCIMEM32WINSIZE; *mmio64 = SPAPRPCIBASE + (index + 1) * SPAPRPCIMEM64WINSIZE; } ", "target": 1}
{"func": "static void ppc405epcomputeclocks (ppc405epcpct *cpc) { uint32t CPUclk, PLBclk, OPBclk, EBCclk, MALclk, PCIclk; uint32t UART0clk, UART1clk; uint64t VCOout, PLLout; int M, D; VCOout = 0; if ((cpc->pllmr[1] & 0x80000000) && !(cpc->pllmr[1] & 0x40000000)) { M = (((cpc->pllmr[1] >> 20) - 1) & 0xF) + 1; /* FBMUL */ #ifdef DEBUGCLOCKSLL printf(\"FBMUL %01\" PRIx32 \" %d\\n\", (cpc->pllmr[1] >> 20) & 0xF, M); #endif D = 8 - ((cpc->pllmr[1] >> 16) & 0x7); /* FWDA */ #ifdef DEBUGCLOCKSLL printf(\"FWDA %01\" PRIx32 \" %d\\n\", (cpc->pllmr[1] >> 16) & 0x7, D); #endif VCOout = cpc->sysclk * M * D; if (VCOout < 500000000UL || VCOout > 1000000000UL) { /* Error - unlock the PLL */ printf(\"VCO out of range %\" PRIu64 \"\\n\", VCOout); #if 0 cpc->pllmr[1] &= ~0x80000000; goto pllbypass; #endif } PLLout = VCOout / D; /* Pretend the PLL is locked */ cpc->boot |= 0x00000001; } else { #if 0 pllbypass: #endif PLLout = cpc->sysclk; if (cpc->pllmr[1] & 0x40000000) { /* Pretend the PLL is not locked */ cpc->boot &= ~0x00000001; } } /* Now, compute all other clocks */ D = ((cpc->pllmr[0] >> 20) & 0x3) + 1; /* CCDV */ #ifdef DEBUGCLOCKSLL printf(\"CCDV %01\" PRIx32 \" %d\\n\", (cpc->pllmr[0] >> 20) & 0x3, D); #endif CPUclk = PLLout / D; D = ((cpc->pllmr[0] >> 16) & 0x3) + 1; /* CBDV */ #ifdef DEBUGCLOCKSLL printf(\"CBDV %01\" PRIx32 \" %d\\n\", (cpc->pllmr[0] >> 16) & 0x3, D); #endif PLBclk = CPUclk / D; D = ((cpc->pllmr[0] >> 12) & 0x3) + 1; /* OPDV */ #ifdef DEBUGCLOCKSLL printf(\"OPDV %01\" PRIx32 \" %d\\n\", (cpc->pllmr[0] >> 12) & 0x3, D); #endif OPBclk = PLBclk / D; D = ((cpc->pllmr[0] >> 8) & 0x3) + 2; /* EPDV */ #ifdef DEBUGCLOCKSLL printf(\"EPDV %01\" PRIx32 \" %d\\n\", (cpc->pllmr[0] >> 8) & 0x3, D); #endif EBCclk = PLBclk / D; D = ((cpc->pllmr[0] >> 4) & 0x3) + 1; /* MPDV */ #ifdef DEBUGCLOCKSLL printf(\"MPDV %01\" PRIx32 \" %d\\n\", (cpc->pllmr[0] >> 4) & 0x3, D); #endif MALclk = PLBclk / D; D = (cpc->pllmr[0] & 0x3) + 1; /* PPDV */ #ifdef DEBUGCLOCKSLL printf(\"PPDV %01\" PRIx32 \" %d\\n\", cpc->pllmr[0] & 0x3, D); #endif PCIclk = PLBclk / D; D = ((cpc->ucr - 1) & 0x7F) + 1; /* U0DIV */ #ifdef DEBUGCLOCKSLL printf(\"U0DIV %01\" PRIx32 \" %d\\n\", cpc->ucr & 0x7F, D); #endif UART0clk = PLLout / D; D = (((cpc->ucr >> 8) - 1) & 0x7F) + 1; /* U1DIV */ #ifdef DEBUGCLOCKSLL printf(\"U1DIV %01\" PRIx32 \" %d\\n\", (cpc->ucr >> 8) & 0x7F, D); #endif UART1clk = PLLout / D; #ifdef DEBUGCLOCKS printf(\"Setup PPC405EP clocks - sysclk %\" PRIu32 \" VCO %\" PRIu64 \" PLL out %\" PRIu64 \" Hz\\n\", cpc->sysclk, VCOout, PLLout); printf(\"CPU %\" PRIu32 \" PLB %\" PRIu32 \" OPB %\" PRIu32 \" EBC %\" PRIu32 \" MAL %\" PRIu32 \" PCI %\" PRIu32 \" UART0 %\" PRIu32 \" UART1 %\" PRIu32 \"\\n\", CPUclk, PLBclk, OPBclk, EBCclk, MALclk, PCIclk, UART0clk, UART1clk); #endif /* Setup CPU clocks */ clksetup(&cpc->clksetup[PPC405EPCPUCLK], CPUclk); /* Setup PLB clock */ clksetup(&cpc->clksetup[PPC405EPPLBCLK], PLBclk); /* Setup OPB clock */ clksetup(&cpc->clksetup[PPC405EPOPBCLK], OPBclk); /* Setup external clock */ clksetup(&cpc->clksetup[PPC405EPEBCCLK], EBCclk); /* Setup MAL clock */ clksetup(&cpc->clksetup[PPC405EPMALCLK], MALclk); /* Setup PCI clock */ clksetup(&cpc->clksetup[PPC405EPPCICLK], PCIclk); /* Setup UART0 clock */ clksetup(&cpc->clksetup[PPC405EPUART0CLK], UART0clk); /* Setup UART1 clock */ clksetup(&cpc->clksetup[PPC405EPUART1CLK], UART1clk); } ", "target": 1}
{"func": "avcold void ffwmv2commoninit(Wmv2Context * w){ MpegEncContext * const s= &w->s; ffinitscantable(s->dsp.idctpermutation, &w->abtscantable[0], ffwmv2scantableA); ffinitscantable(s->dsp.idctpermutation, &w->abtscantable[1], ffwmv2scantableB); } ", "target": 1}
{"func": "void tapfdsetoffload(int fd, int csum, int tso4, int tso6, int ecn, int ufo) { unsigned int offload = 0; if (csum) { offload |= TUNFCSUM; if (tso4) offload |= TUNFTSO4; if (tso6) offload |= TUNFTSO6; if ((tso4 || tso6) && ecn) offload |= TUNFTSOECN; if (ufo) offload |= TUNFUFO; if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) { offload &= ~TUNFUFO; if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) { fprintf(stderr, \"TUNSETOFFLOAD ioctl() failed: %s\\n\", strerror(errno));", "target": 1}
{"func": "void ffmpeg1encodeinit(MpegEncContext *s) { static int done=0; commoninit(s); if(!done){ int fcode; int mv; \tint i; done=1; initrl(&rlmpeg1); \tfor(i=0; i<64; i++) \t{ \t\tmpeg1maxlevel[0][i]= rlmpeg1.maxlevel[0][i]; \t\tmpeg1indexrun[0][i]= rlmpeg1.indexrun[0][i]; \t} inituniacvlc(&rlmpeg1, unimpeg1acvlcbits, unimpeg1acvlclen); \t/* build unified dc encoding tables */ \tfor(i=-255; i<256; i++) \t{ \t\tint adiff, index; \t\tint bits, code; \t\tint diff=i; \t\tadiff = ABS(diff); \t\tif(diff<0) diff--; \t\tindex = avlog2(2*adiff); \t\tbits= vlcdclumbits[index] + index; \t\tcode= (vlcdclumcode[index]<<index) + (diff & ((1 << index) - 1)); \t\tmpeg1lumdcuni[i+255]= bits + (code<<8); \t\t \t\tbits= vlcdcchromabits[index] + index; \t\tcode= (vlcdcchromacode[index]<<index) + (diff & ((1 << index) - 1)); \t\tmpeg1chrdcuni[i+255]= bits + (code<<8); \t} mvpenalty= avmallocz( sizeof(uint8t)*(MAXFCODE+1)*(2*MAXMV+1) ); for(fcode=1; fcode<=MAXFCODE; fcode++){ for(mv=-MAXMV; mv<=MAXMV; mv++){ int len; if(mv==0) len= mbMotionVectorTable[0][1]; else{ int val, bitsize, range, code; bitsize = fcode - 1; range = 1 << bitsize; val=mv; if (val < 0) val = -val; val--; code = (val >> bitsize) + 1; if(code<17){ len= mbMotionVectorTable[code][1] + 1 + bitsize; }else{ len= mbMotionVectorTable[16][1] + 2 + bitsize; } } mvpenalty[fcode][mv+MAXMV]= len; } } for(fcode=MAXFCODE; fcode>0; fcode--){ for(mv=-(8<<fcode); mv<(8<<fcode); mv++){ fcodetab[mv+MAXMV]= fcode; } } } s->me.mvpenalty= mvpenalty; s->fcodetab= fcodetab; if(s->codecid == CODECIDMPEG1VIDEO){ s->minqcoeff=-255; s->maxqcoeff= 255; }else{ s->minqcoeff=-2047; s->maxqcoeff= 2047; } s->intraacvlclength= s->interacvlclength= s->intraacvlclastlength= s->interacvlclastlength= unimpeg1acvlclen; } ", "target": 1}
{"func": "static avcold int ac3decodeinit(AVCodecContext *avctx) { AC3DecodeContext *s = avctx->privdata; s->avctx = avctx; ffac3commoninit(); ac3tablesinit(); ffmdctinit(&s->imdct256, 8, 1, 1.0); ffmdctinit(&s->imdct512, 9, 1, 1.0); ffkbdwindowinit(s->window, 5.0, 256); dsputilinit(&s->dsp, avctx); fffmtconvertinit(&s->fmtconv, avctx); avlfginit(&s->dithstate, 0); /* set scale value for float to int16 conversion */ s->mulbias = 32767.0f; /* allow downmixing to stereo or mono */ if (avctx->channels > 0 && avctx->requestchannels > 0 && avctx->requestchannels < avctx->channels && avctx->requestchannels <= 2) { avctx->channels = avctx->requestchannels; } s->downmixed = 1; /* allocate context input buffer */ if (avctx->errorrecognition >= FFERCAREFUL) { s->inputbuffer = avmallocz(AC3FRAMEBUFFERSIZE + FFINPUTBUFFERPADDINGSIZE); if (!s->inputbuffer) return AVERROR(ENOMEM); } avctx->samplefmt = AVSAMPLEFMTS16; return 0; } ", "target": 1}
{"func": "static void countframebitsfixed(AC3EncodeContext *s) { static const int framebitsinc[8] = { 0, 0, 2, 2, 2, 4, 2, 4 }; int blk; int framebits; /* assumptions: * no dynamic range codes * bit allocation parameters do not change between blocks * no delta bit allocation * no skipped data * no auxilliary data * no E-AC-3 metadata */ /* header */ framebits = 16; /* sync info */ if (s->eac3) { /* bitstream info header */ framebits += 35; framebits += 1 + 1 + 1; /* audio frame header */ framebits += 2; framebits += 10; /* exponent strategy */ for (blk = 0; blk < AC3MAXBLOCKS; blk++) framebits += 2 * s->fbwchannels + s->lfeon; /* converter exponent strategy */ framebits += s->fbwchannels * 5; /* snr offsets */ framebits += 10; /* block start info */ framebits++; } else { framebits += 49; framebits += framebitsinc[s->channelmode]; } /* audio blocks */ for (blk = 0; blk < AC3MAXBLOCKS; blk++) { if (!s->eac3) { /* block switch flags */ framebits += s->fbwchannels; /* dither flags */ framebits += s->fbwchannels; } /* dynamic range */ framebits++; /* spectral extension */ if (s->eac3) framebits++; if (!s->eac3) { /* exponent strategy */ framebits += 2 * s->fbwchannels; if (s->lfeon) framebits++; /* bit allocation params */ framebits++; if (!blk) framebits += 2 + 2 + 2 + 2 + 3; } /* converter snr offset */ if (s->eac3) framebits++; if (!s->eac3) { /* delta bit allocation */ framebits++; /* skipped data */ framebits++; } } /* auxiliary data */ framebits++; /* CRC */ framebits += 1 + 16; s->framebitsfixed = framebits; } ", "target": 0}
{"func": "static void avnoinline filtermbedgev( uint8t *pix, int stride, int16t bS[4], unsigned int qp, H264Context *h) { const unsigned int indexa = 52 + qp + h->slicealphac0offset; const int alpha = alphatable[indexa]; const int beta = (betatable+52)[qp + h->slicebetaoffset]; if (alpha ==0 || beta == 0) return; if( bS[0] < 4 ) { int8t tc[4]; tc[0] = tc0table[indexa][bS[0]]; tc[1] = tc0table[indexa][bS[1]]; tc[2] = tc0table[indexa][bS[2]]; tc[3] = tc0table[indexa][bS[3]]; h->s.dsp.h264hloopfilterluma(pix, stride, alpha, beta, tc); } else { h->s.dsp.h264hloopfilterlumaintra(pix, stride, alpha, beta); } } ", "target": 0}
{"func": "int avcodecdecodeaudio(AVCodecContext *avctx, int16t *samples, int *framesizeptr, uint8t *buf, int bufsize) { int ret; *framesizeptr= 0; if((avctx->codec->capabilities & CODECCAPDELAY) || bufsize){ ret = avctx->codec->decode(avctx, samples, framesizeptr, buf, bufsize); avctx->framenumber++; }else ret= 0; return ret; } ", "target": 0}
{"func": "void vp8decodemvs(VP8Context *s, VP8Macroblock *mb, int mbx, int mby, int layout) { VP8Macroblock *mbedge[3] = { 0 /* top */, mb - 1 /* left */, 0 /* top-left */ }; enum { CNTZERO, CNTNEAREST, CNTNEAR, CNTSPLITMV }; enum { VP8EDGETOP, VP8EDGELEFT, VP8EDGETOPLEFT }; int idx = CNTZERO; int cursignbias = s->signbias[mb->refframe]; int8t *signbias = s->signbias; VP56mv nearmv[4]; uint8t cnt[4] = { 0 }; VP56RangeCoder *c = &s->c; if (!layout) { // layout is inlined (s->mblayout is not) mbedge[0] = mb + 2; mbedge[2] = mb + 1; } else { mbedge[0] = mb - s->mbwidth - 1; mbedge[2] = mb - s->mbwidth - 2; } AVZERO32(&nearmv[0]); AVZERO32(&nearmv[1]); AVZERO32(&nearmv[2]); /* Process MB on top, left and top-left */ #define MVEDGECHECK(n) \\ { \\ VP8Macroblock *edge = mbedge[n]; \\ int edgeref = edge->refframe; \\ if (edgeref != VP56FRAMECURRENT) { \\ uint32t mv = AVRN32A(&edge->mv); \\ if (mv) { \\ if (cursignbias != signbias[edgeref]) { \\ /* SWAR negate of the values in mv. */ \\ mv = ~mv; \\ mv = ((mv & 0x7fff7fff) + \\ 0x00010001) ^ (mv & 0x80008000); \\ } \\ if (!n || mv != AVRN32A(&nearmv[idx])) \\ AVWN32A(&nearmv[++idx], mv); \\ cnt[idx] += 1 + (n != 2); \\ } else \\ cnt[CNTZERO] += 1 + (n != 2); \\ } \\ } MVEDGECHECK(0) MVEDGECHECK(1) MVEDGECHECK(2) mb->partitioning = VP8SPLITMVMODENONE; if (vp56racgetprobbranchy(c, vp8modecontexts[cnt[CNTZERO]][0])) { mb->mode = VP8MVMODEMV; /* If we have three distinct MVs, merge first and last if they're the same */ if (cnt[CNTSPLITMV] && AVRN32A(&nearmv[1 + VP8EDGETOP]) == AVRN32A(&nearmv[1 + VP8EDGETOPLEFT])) cnt[CNTNEAREST] += 1; /* Swap near and nearest if necessary */ if (cnt[CNTNEAR] > cnt[CNTNEAREST]) { FFSWAP(uint8t, cnt[CNTNEAREST], cnt[CNTNEAR]); FFSWAP( VP56mv, nearmv[CNTNEAREST], nearmv[CNTNEAR]); } if (vp56racgetprobbranchy(c, vp8modecontexts[cnt[CNTNEAREST]][1])) { if (vp56racgetprobbranchy(c, vp8modecontexts[cnt[CNTNEAR]][2])) { /* Choose the best mv out of 0,0 and the nearest mv */ clampmv(s, &mb->mv, &nearmv[CNTZERO + (cnt[CNTNEAREST] >= cnt[CNTZERO])]); cnt[CNTSPLITMV] = ((mbedge[VP8EDGELEFT]->mode == VP8MVMODESPLIT) + (mbedge[VP8EDGETOP]->mode == VP8MVMODESPLIT)) * 2 + (mbedge[VP8EDGETOPLEFT]->mode == VP8MVMODESPLIT); if (vp56racgetprobbranchy(c, vp8modecontexts[cnt[CNTSPLITMV]][3])) { mb->mode = VP8MVMODESPLIT; mb->mv = mb->bmv[decodesplitmvs(s, c, mb, layout, ISVP8) - 1]; } else { mb->mv.y += vp8readmvcomponent(c, s->prob->mvc[0]); mb->mv.x += vp8readmvcomponent(c, s->prob->mvc[1]); mb->bmv[0] = mb->mv; } } else { clampmv(s, &mb->mv, &nearmv[CNTNEAR]); mb->bmv[0] = mb->mv; } } else { clampmv(s, &mb->mv, &nearmv[CNTNEAREST]); mb->bmv[0] = mb->mv; } } else { mb->mode = VP8MVMODEZERO; AVZERO32(&mb->mv); mb->bmv[0] = mb->mv; } } ", "target": 1}
{"func": "int main() { int rd, rt, dsp; int result, resultdsp; rt = 0x12345678; result = 0xA000C000; resultdsp = 1; asm (\"shll.ph %0, %2, 0x0B\\n\\t\" \"rddsp %1\\n\\t\" : \"=r\"(rd), \"=r\"(dsp) : \"r\"(rt) ); dsp = (dsp >> 22) & 0x01; assert(dsp == resultdsp); assert(rd == result); return 0; } ", "target": 1}
{"func": "int ffrleencode(uint8t *outbuf, int outsize, const uint8t *ptr , int bpp, int w, int8t add, uint8t xor) { int count, x; uint8t *out; out = outbuf; for(x = 0; x < w; x += count) { /* see if we can encode the next set of pixels with RLE */ if((count = countpixels(ptr, w-x, bpp, 1)) > 1) { if(out + bpp + 1 > outbuf + outsize) return -1; *out++ = (count ^ xor) + add; memcpy(out, ptr, bpp); out += bpp; } else { /* fall back on uncompressed */ count = countpixels(ptr, w-x, bpp, 0); *out++ = count - 1; if(out + bpp*count > outbuf + outsize) return -1; memcpy(out, ptr, bpp * count); out += bpp * count; } ptr += count * bpp; } return out - outbuf; } ", "target": 0}
{"func": "static int vdpauframesinit(AVHWFramesContext *ctx) { VDPAUDeviceContext *devicepriv = ctx->devicectx->internal->priv; VDPAUFramesContext *priv = ctx->internal->priv; int i; switch (ctx->swformat) { case AVPIXFMTYUV420P: priv->chromatype = VDPCHROMATYPE420; break; case AVPIXFMTYUV422P: priv->chromatype = VDPCHROMATYPE422; break; case AVPIXFMTYUV444P: priv->chromatype = VDPCHROMATYPE444; break; default: avlog(ctx, AVLOGERROR, \"Unsupported data layout: %s\\n\", avgetpixfmtname(ctx->swformat)); return AVERROR(ENOSYS); } for (i = 0; i < FFARRAYELEMS(vdpaupixfmts); i++) { if (vdpaupixfmts[i].chromatype == priv->chromatype) { priv->chromaidx = i; priv->pixfmts = devicepriv->pixfmts[i]; priv->nbpixfmts = devicepriv->nbpixfmts[i]; break; } } if (!priv->pixfmts) { avlog(ctx, AVLOGERROR, \"Unsupported chroma type: %d\\n\", priv->chromatype); return AVERROR(ENOSYS); } if (!ctx->pool) { ctx->internal->poolinternal = avbufferpoolinit2(sizeof(VdpVideoSurface), ctx, vdpaupoolalloc, NULL); if (!ctx->internal->poolinternal) return AVERROR(ENOMEM); } priv->getdata = devicepriv->getdata; priv->putdata = devicepriv->putdata; return 0; } ", "target": 1}
{"func": "int vmstop(RunState state) { if (qemuinvcputhread()) { qemusystemvmstoprequest(state); /* * FIXME: should not return to device code in case * vmstop() has been requested. */ cpustopcurrent(); return 0; } return dovmstop(state); }", "target": 1}
{"func": "static int dcadecodeframe(AVCodecContext *avctx, void *data, int *gotframeptr, AVPacket *avpkt) { AVFrame *frame = data; const uint8t *buf = avpkt->data; int bufsize = avpkt->size; int lfesamples; int numcorechannels = 0; int i, ret; float **samplesflt; DCAContext *s = avctx->privdata; int channels, fullchannels; int coressend; s->xchpresent = 0; s->dcabuffersize = ffdcaconvertbitstream(buf, bufsize, s->dcabuffer, DCAMAXFRAMESIZE + DCAMAXEXSSHEADERSIZE); if (s->dcabuffersize == AVERRORINVALIDDATA) { avlog(avctx, AVLOGERROR, \"Not a valid DCA frame\\n\"); return AVERRORINVALIDDATA; } initgetbits(&s->gb, s->dcabuffer, s->dcabuffersize * 8); if ((ret = dcaparseframeheader(s)) < 0) { //seems like the frame is corrupt, try with the next one return ret; } //set AVCodec values with parsed data avctx->samplerate = s->samplerate; avctx->bitrate = s->bitrate; s->profile = FFPROFILEDTS; for (i = 0; i < (s->sampleblocks / 8); i++) { if ((ret = dcadecodeblock(s, 0, i))) { avlog(avctx, AVLOGERROR, \"error decoding block\\n\"); return ret; } } /* record number of core channels incase less than max channels are requested */ numcorechannels = s->primchannels; if (s->extcoding) s->coreextmask = dcaextaudiodescrmask[s->extdescr]; else s->coreextmask = 0; coressend = FFMIN(s->framesize, s->dcabuffersize) * 8; /* only scan for extensions if extdescr was unknown or indicated a * supported XCh extension */ if (s->coreextmask < 0 || s->coreextmask & DCAEXTXCH) { /* if extdescr was unknown, clear s->coreextmask so that the * extensions scan can fill it up */ s->coreextmask = FFMAX(s->coreextmask, 0); /* extensions start at 32-bit boundaries into bitstream */ skipbitslong(&s->gb, (-getbitscount(&s->gb)) & 31); while (coressend - getbitscount(&s->gb) >= 32) { uint32t bits = getbitslong(&s->gb, 32); switch (bits) { case 0x5a5a5a5a: { int extamode, xchfsize; s->xchbasechannel = s->primchannels; /* validate sync word using XCHFSIZE field */ xchfsize = showbits(&s->gb, 10); if ((s->framesize != (getbitscount(&s->gb) >> 3) - 4 + xchfsize) && (s->framesize != (getbitscount(&s->gb) >> 3) - 4 + xchfsize + 1)) continue; /* skip length-to-end-of-frame field for the moment */ skipbits(&s->gb, 10); s->coreextmask |= DCAEXTXCH; /* extension amode(number of channels in extension) should be 1 */ /* AFAIK XCh is not used for more channels */ if ((extamode = getbits(&s->gb, 4)) != 1) { avlog(avctx, AVLOGERROR, \"XCh extension amode %d not\" \" supported!\\n\", extamode); continue; } /* much like core primary audio coding header */ dcaparseaudiocodingheader(s, s->xchbasechannel); for (i = 0; i < (s->sampleblocks / 8); i++) if ((ret = dcadecodeblock(s, s->xchbasechannel, i))) { avlog(avctx, AVLOGERROR, \"error decoding XCh extension\\n\"); continue; } s->xchpresent = 1; break; } case 0x47004a03: /* XXCh: extended channels */ /* usually found either in core or HD part in DTS-HD HRA streams, * but not in DTS-ES which contains XCh extensions instead */ s->coreextmask |= DCAEXTXXCH; break; case 0x1d95f262: { int fsize96 = showbits(&s->gb, 12) + 1; if (s->framesize != (getbitscount(&s->gb) >> 3) - 4 + fsize96) continue; avlog(avctx, AVLOGDEBUG, \"X96 extension found at %d bits\\n\", getbitscount(&s->gb)); skipbits(&s->gb, 12); avlog(avctx, AVLOGDEBUG, \"FSIZE96 = %d bytes\\n\", fsize96); avlog(avctx, AVLOGDEBUG, \"REVNO = %d\\n\", getbits(&s->gb, 4)); s->coreextmask |= DCAEXTX96; break; } } skipbitslong(&s->gb, (-getbitscount(&s->gb)) & 31); } } else { /* no supported extensions, skip the rest of the core substream */ skipbitslong(&s->gb, coressend - getbitscount(&s->gb)); } if (s->coreextmask & DCAEXTX96) s->profile = FFPROFILEDTS9624; else if (s->coreextmask & (DCAEXTXCH | DCAEXTXXCH)) s->profile = FFPROFILEDTSES; /* check for ExSS (HD part) */ if (s->dcabuffersize - s->framesize > 32 && getbitslong(&s->gb, 32) == DCAHDMARKER) dcaexssparseheader(s); avctx->profile = s->profile; fullchannels = channels = s->primchannels + !!s->lfe; if (s->amode < 16) { avctx->channellayout = dcacorechannellayout[s->amode]; if (s->primchannels + !!s->lfe > 2 && avctx->requestchannellayout == AVCHLAYOUTSTEREO) { /* * Neither the core's auxiliary data nor our default tables contain * downmix coefficients for the additional channel coded in the XCh * extension, so when we're doing a Stereo downmix, don't decode it. */ s->xchdisable = 1; } #if FFAPIREQUESTCHANNELS FFDISABLEDEPRECATIONWARNINGS if (s->xchpresent && !s->xchdisable && (!avctx->requestchannels || avctx->requestchannels > numcorechannels + !!s->lfe)) { FFENABLEDEPRECATIONWARNINGS #else if (s->xchpresent && !s->xchdisable) { #endif avctx->channellayout |= AVCHBACKCENTER; if (s->lfe) { avctx->channellayout |= AVCHLOWFREQUENCY; s->channelordertab = dcachannelreorderlfexch[s->amode]; } else { s->channelordertab = dcachannelreordernolfexch[s->amode]; } } else { channels = numcorechannels + !!s->lfe; s->xchpresent = 0; /* disable further xch processing */ if (s->lfe) { avctx->channellayout |= AVCHLOWFREQUENCY; s->channelordertab = dcachannelreorderlfe[s->amode]; } else s->channelordertab = dcachannelreordernolfe[s->amode]; } if (channels > !!s->lfe && s->channelordertab[channels - 1 - !!s->lfe] < 0) return AVERRORINVALIDDATA; if (s->primchannels + !!s->lfe > 2 && avctx->requestchannellayout == AVCHLAYOUTSTEREO) { channels = 2; s->output = s->primchannels == 2 ? s->amode : DCASTEREO; avctx->channellayout = AVCHLAYOUTSTEREO; /* Stereo downmix coefficients * * The decoder can only downmix to 2-channel, so we need to ensure * embedded downmix coefficients are actually targeting 2-channel. */ if (s->coredownmix && (s->coredownmixamode == DCASTEREO || s->coredownmixamode == DCASTEREOTOTAL)) { int sign, code; for (i = 0; i < s->primchannels + !!s->lfe; i++) { sign = s->coredownmixcodes[i][0] & 0x100 ? 1 : -1; code = s->coredownmixcodes[i][0] & 0x0FF; s->downmixcoef[i][0] = (!code ? 0.0f : sign * dcadmixtable[code - 1]); sign = s->coredownmixcodes[i][1] & 0x100 ? 1 : -1; code = s->coredownmixcodes[i][1] & 0x0FF; s->downmixcoef[i][1] = (!code ? 0.0f : sign * dcadmixtable[code - 1]); } s->output = s->coredownmixamode; } else { int am = s->amode & DCACHANNELMASK; if (am >= FFARRAYELEMS(dcadefaultcoeffs)) { avlog(s->avctx, AVLOGERROR, \"Invalid channel mode %d\\n\", am); return AVERRORINVALIDDATA; } if (s->primchannels + !!s->lfe > FFARRAYELEMS(dcadefaultcoeffs[0])) { avprivrequestsample(s->avctx, \"Downmixing %d channels\", s->primchannels + !!s->lfe); return AVERRORPATCHWELCOME; } for (i = 0; i < s->primchannels + !!s->lfe; i++) { s->downmixcoef[i][0] = dcadefaultcoeffs[am][i][0]; s->downmixcoef[i][1] = dcadefaultcoeffs[am][i][1]; } } avdlog(s->avctx, \"Stereo downmix coeffs:\\n\"); for (i = 0; i < s->primchannels + !!s->lfe; i++) { avdlog(s->avctx, \"L, input channel %d = %f\\n\", i, s->downmixcoef[i][0]); avdlog(s->avctx, \"R, input channel %d = %f\\n\", i, s->downmixcoef[i][1]); } avdlog(s->avctx, \"\\n\"); } } else { avlog(avctx, AVLOGERROR, \"Non standard configuration %d !\\n\", s->amode); return AVERRORINVALIDDATA; } avctx->channels = channels; /* get output buffer */ frame->nbsamples = 256 * (s->sampleblocks / 8); if ((ret = ffgetbuffer(avctx, frame, 0)) < 0) { avlog(avctx, AVLOGERROR, \"getbuffer() failed\\n\"); return ret; } samplesflt = (float **)frame->extendeddata; /* allocate buffer for extra channels if downmixing */ if (avctx->channels < fullchannels) { ret = avsamplesgetbuffersize(NULL, fullchannels - channels, frame->nbsamples, avctx->samplefmt, 0); if (ret < 0) return ret; avfastmalloc(&s->extrachannelsbuffer, &s->extrachannelsbuffersize, ret); if (!s->extrachannelsbuffer) return AVERROR(ENOMEM); ret = avsamplesfillarrays((uint8t **)s->extrachannels, NULL, s->extrachannelsbuffer, fullchannels - channels, frame->nbsamples, avctx->samplefmt, 0); if (ret < 0) return ret; } /* filter to get final output */ for (i = 0; i < (s->sampleblocks / 8); i++) { int ch; for (ch = 0; ch < channels; ch++) s->sampleschanptr[ch] = samplesflt[ch] + i * 256; for (; ch < fullchannels; ch++) s->sampleschanptr[ch] = s->extrachannels[ch - channels] + i * 256; dcafilterchannels(s, i); /* If this was marked as a DTS-ES stream we need to subtract back- */ /* channel from SL & SR to remove matrixed back-channel signal */ if ((s->sourcepcmres & 1) && s->xchpresent) { float *backchan = s->sampleschanptr[s->channelordertab[s->xchbasechannel]]; float *ltchan = s->sampleschanptr[s->channelordertab[s->xchbasechannel - 2]]; float *rtchan = s->sampleschanptr[s->channelordertab[s->xchbasechannel - 1]]; s->fdsp.vectorfmacscalar(ltchan, backchan, -MSQRT12, 256); s->fdsp.vectorfmacscalar(rtchan, backchan, -MSQRT12, 256); } } /* update lfe history */ lfesamples = 2 * s->lfe * (s->sampleblocks / 8); for (i = 0; i < 2 * s->lfe * 4; i++) s->lfedata[i] = s->lfedata[i + lfesamples]; /* AVMatrixEncoding * * DCASTEREOTOTAL (Lt/Rt) is equivalent to Dolby Surround */ ret = ffsidedataupdatematrixencoding(frame, (s->output & ~DCALFE) == DCASTEREOTOTAL ? AVMATRIXENCODINGDOLBY : AVMATRIXENCODINGNONE); if (ret < 0) return ret; *gotframeptr = 1; return bufsize; } ", "target": 0}
{"func": "static unsigned dostfle(CPUS390XState *env, uint64t words[MAXSTFLWORDS]) { S390CPU *cpu = s390envgetcpu(env); const unsigned long *features = cpu->model->features; unsigned maxbit = 0; S390Feat feat; memset(words, 0, sizeof(uint64t) * MAXSTFLWORDS); if (testbit(S390FEATZARCH, features)) { /* z/Architecture is always active if around */ words[0] = 1ull << (63 - 2); } for (feat = findfirstbit(features, S390FEATMAX); feat < S390FEATMAX; feat = findnextbit(features, S390FEATMAX, feat + 1)) { const S390FeatDef *def = s390featdef(feat); if (def->type == S390FEATTYPESTFL) { unsigned bit = def->bit; if (bit > maxbit) { maxbit = bit; } assert(bit / 64 < MAXSTFLWORDS); words[bit / 64] |= 1ULL << (63 - bit % 64); } } return maxbit / 64; } ", "target": 0}
{"func": "static int nbdestablishconnection(BlockDriverState *bs) { BDRVNBDState *s = bs->opaque; int sock; int ret; offt size; sizet blocksize; if (s->hostspec[0] == '/') { sock = unixsocketoutgoing(s->hostspec); } else { sock = tcpsocketoutgoingspec(s->hostspec); } /* Failed to establish connection */ if (sock < 0) { logout(\"Failed to establish connection to NBD server\\n\"); return -errno; } /* NBD handshake */ ret = nbdreceivenegotiate(sock, s->exportname, &s->nbdflags, &size, &blocksize); if (ret < 0) { logout(\"Failed to negotiate with the NBD server\\n\"); closesocket(sock); return -errno; } /* Now that we're connected, set the socket to be non-blocking and * kick the reply mechanism. */ socketsetnonblock(sock); qemuaiosetfdhandler(s->sock, nbdreplyready, NULL, nbdhaverequest, NULL, s); s->sock = sock; s->size = size; s->blocksize = blocksize; logout(\"Established connection with NBD server\\n\"); return 0; } ", "target": 0}
{"func": "static avcold int vc2encodeinit(AVCodecContext *avctx) { Plane *p; SubBand *b; int i, j, level, o, shift; const AVPixFmtDescriptor *fmt = avpixfmtdescget(avctx->pixfmt); const int depth = fmt->comp[0].depth; VC2EncContext *s = avctx->privdata; s->picturenumber = 0; /* Total allowed quantization range */ s->qceil = DIRACMAXQUANTINDEX; s->ver.major = 2; s->ver.minor = 0; s->profile = 3; s->level = 3; s->basevf = -1; s->strictcompliance = 1; s->qavg = 0; s->slicemaxbytes = 0; s->sliceminbytes = 0; /* Mark unknown as progressive */ s->interlaced = !((avctx->fieldorder == AVFIELDUNKNOWN) || (avctx->fieldorder == AVFIELDPROGRESSIVE)); for (i = 0; i < basevideofmtslen; i++) { const VC2BaseVideoFormat *fmt = &basevideofmts[i]; if (avctx->pixfmt != fmt->pixfmt) continue; if (avctx->timebase.num != fmt->timebase.num) continue; if (avctx->timebase.den != fmt->timebase.den) continue; if (avctx->width != fmt->width) continue; if (avctx->height != fmt->height) continue; if (s->interlaced != fmt->interlaced) continue; s->basevf = i; s->level = basevideofmts[i].level; break; } if (s->interlaced) avlog(avctx, AVLOGWARNING, \"Interlacing enabled!\\n\"); if ((s->slicewidth & (s->slicewidth - 1)) || (s->sliceheight & (s->sliceheight - 1))) { avlog(avctx, AVLOGERROR, \"Slice size is not a power of two!\\n\"); return AVERRORUNKNOWN; } if ((s->slicewidth > avctx->width) || (s->sliceheight > avctx->height)) { avlog(avctx, AVLOGERROR, \"Slice size is bigger than the image!\\n\"); return AVERRORUNKNOWN; } if (s->basevf <= 0) { if (avctx->strictstdcompliance <= FFCOMPLIANCEUNOFFICIAL) { s->strictcompliance = s->basevf = 0; avlog(avctx, AVLOGWARNING, \"Disabling strict compliance\\n\"); } else { avlog(avctx, AVLOGWARNING, \"Given format does not strictly comply with \" \"the specifications, please add a -strict -1 flag to use it\\n\"); return AVERRORUNKNOWN; } } else { avlog(avctx, AVLOGINFO, \"Selected base video format = %i (%s)\\n\", s->basevf, basevideofmts[s->basevf].name); } /* Chroma subsampling */ avcodecgetchromasubsample(avctx->pixfmt, &s->chromaxshift, &s->chromayshift); /* Bit depth and color range index */ if (depth == 8 && avctx->colorrange == AVCOLRANGEJPEG) { s->bpp = 1; s->bppidx = 1; s->diffoffset = 128; } else if (depth == 8 && (avctx->colorrange == AVCOLRANGEMPEG || avctx->colorrange == AVCOLRANGEUNSPECIFIED)) { s->bpp = 1; s->bppidx = 2; s->diffoffset = 128; } else if (depth == 10) { s->bpp = 2; s->bppidx = 3; s->diffoffset = 512; } else { s->bpp = 2; s->bppidx = 4; s->diffoffset = 2048; } /* Planes initialization */ for (i = 0; i < 3; i++) { int w, h; p = &s->plane[i]; p->width = avctx->width >> (i ? s->chromaxshift : 0); p->height = avctx->height >> (i ? s->chromayshift : 0); if (s->interlaced) p->height >>= 1; p->dwtwidth = w = FFALIGN(p->width, (1 << s->waveletdepth)); p->dwtheight = h = FFALIGN(p->height, (1 << s->waveletdepth)); p->coefstride = FFALIGN(p->dwtwidth, 32); p->coefbuf = avmalloc(p->coefstride*p->dwtheight*sizeof(dwtcoef)); if (!p->coefbuf) goto allocfail; for (level = s->waveletdepth-1; level >= 0; level--) { w = w >> 1; h = h >> 1; for (o = 0; o < 4; o++) { b = &p->band[level][o]; b->width = w; b->height = h; b->stride = p->coefstride; shift = (o > 1)*b->height*b->stride + (o & 1)*b->width; b->buf = p->coefbuf + shift; } } /* DWT init */ if (ffvc2encinittransforms(&s->transformargs[i].t, s->plane[i].coefstride, s->plane[i].dwtheight)) goto allocfail; } /* Slices */ s->numx = s->plane[0].dwtwidth/s->slicewidth; s->numy = s->plane[0].dwtheight/s->sliceheight; s->sliceargs = avcalloc(s->numx*s->numy, sizeof(SliceArgs)); if (!s->sliceargs) goto allocfail; /* Lookup tables */ s->coeflutlen = avmalloc(COEFLUTTAB*(s->qceil+1)*sizeof(*s->coeflutlen)); if (!s->coeflutlen) goto allocfail; s->coeflutval = avmalloc(COEFLUTTAB*(s->qceil+1)*sizeof(*s->coeflutval)); if (!s->coeflutval) goto allocfail; for (i = 0; i < s->qceil; i++) { uint8t *lenlut = &s->coeflutlen[i*COEFLUTTAB]; uint32t *vallut = &s->coeflutval[i*COEFLUTTAB]; for (j = 0; j < COEFLUTTAB; j++) { getvc2ueuint(QUANT(j, ffdiracqscaletab[i]), &lenlut[j], &vallut[j]); if (lenlut[j] != 1) { lenlut[j] += 1; vallut[j] <<= 1; } else { vallut[j] = 1; } } } return 0; allocfail: vc2encodeend(avctx); avlog(avctx, AVLOGERROR, \"Unable to allocate memory!\\n\"); return AVERROR(ENOMEM); } ", "target": 0}
{"func": "void fffixlongbmvs(MpegEncContext * s, int16t (*mvtable)[2], int fcode, int type) { int y; uint8t * fcodetab= s->fcodetab; // RAL: 8 in MPEG-1, 16 in MPEG-4 int range = (((s->codecid == CODECIDMPEG1VIDEO) ? 8 : 16) << fcode); /* clip / convert to intra 16x16 type MVs */ for(y=0; y<s->mbheight; y++){ int x; int xy= (y+1)* (s->mbwidth+2)+1; int i= y*s->mbwidth; for(x=0; x<s->mbwidth; x++) { if (s->mbtype[i] & type) // RAL: \"type\" test added... { if (fcodetab[mvtable[xy][0] + MAXMV] > fcode || fcodetab[mvtable[xy][0] + MAXMV] == 0) { if(mvtable[xy][0]>0) mvtable[xy][0]= range-1; else mvtable[xy][0]= -range; } if (fcodetab[mvtable[xy][1] + MAXMV] > fcode || fcodetab[mvtable[xy][1] + MAXMV] == 0) { if(mvtable[xy][1]>0) mvtable[xy][1]= range-1; else mvtable[xy][1]= -range; } } xy++; i++; } } } ", "target": 0}
{"func": "S390CPU *s390xnewcpu(const char *cpumodel, uint32t coreid, Error **errp) { S390CPU *cpu; Error *err = NULL; cpu = cpus390xcreate(cpumodel, &err); if (err != NULL) { goto out; } objectpropertysetint(OBJECT(cpu), coreid, \"core-id\", &err); if (err != NULL) { goto out; } objectpropertysetbool(OBJECT(cpu), true, \"realized\", &err); out: if (err) { errorpropagate(errp, err); objectunref(OBJECT(cpu)); cpu = NULL; } return cpu; } ", "target": 0}
{"func": "aiocomputetimeout(AioContext *ctx) { int64t deadline; int timeout = -1; QEMUBH *bh; for (bh = atomicrcuread(&ctx->firstbh); bh; bh = atomicrcuread(&bh->next)) { if (bh->scheduled) { if (bh->idle) { /* idle bottom halves will be polled at least * every 10ms */ timeout = 10000000; } else { /* non-idle bottom halves will be executed * immediately */ return 0; } } } deadline = timerlistgroupdeadlinens(&ctx->tlg); if (deadline == 0) { return 0; } else { return qemusoonesttimeout(timeout, deadline); } } ", "target": 0}
{"func": "static void createcelevals(RoqContext *enc, RoqTempdata *tempData) { int n=0, x, y, i; tempData->celevals = avmalloc(enc->width*enc->height/64 * sizeof(CelEvaluation)); /* Map to the ROQ quadtree order */ for (y=0; y<enc->height; y+=16) for (x=0; x<enc->width; x+=16) for(i=0; i<4; i++) { tempData->celevals[n ].sourceX = x + (i&1)*8; tempData->celevals[n++].sourceY = y + (i&2)*4; } } ", "target": 0}
{"func": "static int eareadpacket(AVFormatContext *s, AVPacket *pkt) { EaDemuxContext *ea = s->privdata; AVIOContext *pb = s->pb; int ret = 0; int packetread = 0; unsigned int chunktype, chunksize; int key = 0; int avuninit(numsamples); while (!packetread) { chunktype = aviorl32(pb); chunksize = (ea->bigendian ? aviorb32(pb) : aviorl32(pb)) - 8; switch (chunktype) { /* audio data */ case ISNhTAG: /* header chunk also contains data; skip over the header portion*/ avioskip(pb, 32); chunksize -= 32; case ISNdTAG: case SCDlTAG: case SNDCTAG: case SDENTAG: if (!ea->audiocodec) { avioskip(pb, chunksize); break; } else if (ea->audiocodec == CODECIDPCMS16LEPLANAR || ea->audiocodec == CODECIDMP3) { numsamples = aviorl32(pb); avioskip(pb, 8); chunksize -= 12; } ret = avgetpacket(pb, pkt, chunksize); if (ret < 0) return ret; pkt->streamindex = ea->audiostreamindex; switch (ea->audiocodec) { case CODECIDADPCMEA: case CODECIDADPCMEAR1: case CODECIDADPCMEAR2: case CODECIDADPCMIMAEAEACS: pkt->duration = AVRL32(pkt->data); break; case CODECIDADPCMEAR3: pkt->duration = AVRB32(pkt->data); break; case CODECIDADPCMIMAEASEAD: pkt->duration = ret * 2 / ea->numchannels; break; case CODECIDPCMS16LEPLANAR: case CODECIDMP3: pkt->duration = numsamples; break; default: pkt->duration = chunksize / (ea->bytes * ea->numchannels); } packetread = 1; break; /* ending tag */ case 0: case ISNeTAG: case SCElTAG: case SENDTAG: case SEENTAG: ret = AVERROR(EIO); packetread = 1; break; case MVIhTAG: case kVGTTAG: case pQGTTAG: case TGQsTAG: case MADkTAG: key = AVPKTFLAGKEY; case MVIfTAG: case fVGTTAG: case MADmTAG: case MADeTAG: avioseek(pb, -8, SEEKCUR); // include chunk preamble chunksize += 8; goto getvideopacket; case mTCDTAG: avioskip(pb, 8); // skip ea dct header chunksize -= 8; goto getvideopacket; case MV0KTAG: case MPChTAG: case pIQTTAG: key = AVPKTFLAGKEY; case MV0FTAG: getvideopacket: ret = avgetpacket(pb, pkt, chunksize); if (ret < 0) return ret; pkt->streamindex = ea->videostreamindex; pkt->flags |= key; packetread = 1; break; default: avioskip(pb, chunksize); break; } } return ret; } ", "target": 0}
{"func": "static void typeinitializeinterface(TypeImpl *ti, const char *parent) { InterfaceClass *newiface; TypeInfo info = { }; TypeImpl *ifaceimpl; info.parent = parent; info.name = gstrdupprintf(\"%s::%s\", ti->name, info.parent); info.abstract = true; ifaceimpl = typeregister(&info); typeinitialize(ifaceimpl); gfree((char *)info.name); newiface = (InterfaceClass *)ifaceimpl->class; newiface->concreteclass = ti->class; ti->class->interfaces = gslistappend(ti->class->interfaces, ifaceimpl->class); } ", "target": 1}
{"func": "static int videoopen(VideoState *is){ int flags = SDLHWSURFACE|SDLASYNCBLIT|SDLHWACCEL; int w,h; if(isfullscreen) flags |= SDLFULLSCREEN; else flags |= SDLRESIZABLE; if (isfullscreen && fsscreenwidth) { w = fsscreenwidth; h = fsscreenheight; } else if(!isfullscreen && screenwidth){ w = screenwidth; h = screenheight; }else if (is->videost && is->videost->codec->width){ w = is->videost->codec->width; h = is->videost->codec->height; } else { w = 640; h = 480; } #ifndef SYSDARWIN screen = SDLSetVideoMode(w, h, 0, flags); #else /* setting bitsperpixel = 0 or 32 causes blank video on OS X */ screen = SDLSetVideoMode(w, h, 24, flags); #endif if (!screen) { fprintf(stderr, \"SDL: could not set video mode - exiting\\n\"); return -1; } SDLWMSetCaption(\"FFplay\", \"FFplay\"); is->width = screen->w; is->height = screen->h; return 0; } ", "target": 0}
{"func": "static uint64t nandread(void *opaque, targetphysaddrt addr, unsigned size) { struct nandstatet *s = opaque; uint32t r; int rdy; r = nandgetio(s->nand); nandgetpins(s->nand, &rdy); s->rdy = rdy; DNAND(printf(\"%s addr=%x r=%x\\n\", func, addr, r)); return r; } ", "target": 0}
{"func": "void qmpmigratesetspeed(int64t value, Error **errp) { MigrationState *s; if (value < 0) { value = 0; } s = migrategetcurrent(); s->bandwidthlimit = value; qemufilesetratelimit(s->file, s->bandwidthlimit); } ", "target": 0}
{"func": "void blockjobresumeall(void) { BlockJob *job = NULL; while ((job = blockjobnext(job))) { AioContext *aiocontext = blkgetaiocontext(job->blk); aiocontextacquire(aiocontext); blockjobresume(job); aiocontextrelease(aiocontext); } } ", "target": 1}
{"func": "static int writeoption(void *optctx, const OptionDef *po, const char *opt, const char *arg) { /* new-style options contain an offset into optctx, old-style address of * a global var*/ void *dst = po->flags & (OPTOFFSET | OPTSPEC) ? (uint8t *)optctx + po->u.off : po->u.dstptr; int *dstcount; if (po->flags & OPTSPEC) { SpecifierOpt **so = dst; char *p = strchr(opt, ':'); dstcount = (int *)(so + 1); *so = growarray(*so, sizeof(**so), dstcount, *dstcount + 1); (*so)[*dstcount - 1].specifier = avstrdup(p ? p + 1 : \"\"); dst = &(*so)[*dstcount - 1].u; } if (po->flags & OPTSTRING) { char *str; str = avstrdup(arg); avfreep(dst); *(char **)dst = str; } else if (po->flags & OPTBOOL || po->flags & OPTINT) { *(int *)dst = parsenumberordie(opt, arg, OPTINT64, INTMIN, INTMAX); } else if (po->flags & OPTINT64) { *(int64t *)dst = parsenumberordie(opt, arg, OPTINT64, INT64MIN, INT64MAX); } else if (po->flags & OPTTIME) { *(int64t *)dst = parsetimeordie(opt, arg, 1); } else if (po->flags & OPTFLOAT) { *(float *)dst = parsenumberordie(opt, arg, OPTFLOAT, -INFINITY, INFINITY); } else if (po->flags & OPTDOUBLE) { *(double *)dst = parsenumberordie(opt, arg, OPTDOUBLE, -INFINITY, INFINITY); } else if (po->u.funcarg) { int ret = po->u.funcarg(optctx, opt, arg); if (ret < 0) { avlog(NULL, AVLOGERROR, \"Failed to set value '%s' for option '%s'\\n\", arg, opt); return ret; } } if (po->flags & OPTEXIT) exitprogram(0); return 0; } ", "target": 0}
{"func": "static void putuint8(QEMUFile *f, void *pv, sizet size) { uint8t *v = pv; qemuput8s(f, v); } ", "target": 1}
{"func": "static RemoveResult removehpte(PowerPCCPU *cpu, targetulong ptex, targetulong avpn, targetulong flags, targetulong *vp, targetulong *rp) { CPUPPCState *env = &cpu->env; uint64t token; targetulong v, r, rb; if (!validpteindex(env, ptex)) { return REMOVEPARM; } token = ppchash64startaccess(cpu, ptex); v = ppchash64loadhpte0(cpu, token, 0); r = ppchash64loadhpte1(cpu, token, 0); ppchash64stopaccess(token); if ((v & HPTE64VVALID) == 0 || ((flags & HAVPN) && (v & ~0x7fULL) != avpn) || ((flags & HANDCOND) && (v & avpn) != 0)) { return REMOVENOTFOUND; } *vp = v; *rp = r; ppchash64storehpte(cpu, ptex, HPTE64VHPTEDIRTY, 0); rb = computetlbierb(v, r, ptex); ppctlbinvalidateone(env, rb); return REMOVESUCCESS; } ", "target": 1}
{"func": "int pcieaerinit(PCIDevice *dev, uint16t offset, uint16t size) { PCIExpressDevice *exp; pcieaddcapability(dev, PCIEXTCAPIDERR, PCIERRVER, offset, size); exp = &dev->exp; exp->aercap = offset; /* logmax is property */ if (dev->exp.aerlog.logmax == PCIEAERLOGMAXUNSET) { dev->exp.aerlog.logmax = PCIEAERLOGMAXDEFAULT; } /* clip down the value to avoid unreasobale memory usage */ if (dev->exp.aerlog.logmax > PCIEAERLOGMAXLIMIT) { return -EINVAL; } dev->exp.aerlog.log = gmalloc0(sizeof dev->exp.aerlog.log[0] * dev->exp.aerlog.logmax); pcisetlong(dev->w1cmask + offset + PCIERRUNCORSTATUS, PCIERRUNCSUPPORTED); pcisetlong(dev->config + offset + PCIERRUNCORSEVER, PCIERRUNCSEVERITYDEFAULT); pcisetlong(dev->wmask + offset + PCIERRUNCORSEVER, PCIERRUNCSUPPORTED); pcilongtestandsetmask(dev->w1cmask + offset + PCIERRCORSTATUS, PCIERRCORSUPPORTED); pcisetlong(dev->config + offset + PCIERRCORMASK, PCIERRCORMASKDEFAULT); pcisetlong(dev->wmask + offset + PCIERRCORMASK, PCIERRCORSUPPORTED); /* capabilities and control. multiple header logging is supported */ if (dev->exp.aerlog.logmax > 0) { pcisetlong(dev->config + offset + PCIERRCAP, PCIERRCAPECRCGENC | PCIERRCAPECRCCHKC | PCIERRCAPMHRC); pcisetlong(dev->wmask + offset + PCIERRCAP, PCIERRCAPECRCGENE | PCIERRCAPECRCCHKE | PCIERRCAPMHRE); } else { pcisetlong(dev->config + offset + PCIERRCAP, PCIERRCAPECRCGENC | PCIERRCAPECRCCHKC); pcisetlong(dev->wmask + offset + PCIERRCAP, PCIERRCAPECRCGENE | PCIERRCAPECRCCHKE); } switch (pciecapgettype(dev)) { case PCIEXPTYPEROOTPORT: /* this case will be set by pcieaerrootinit() */ /* fallthrough */ case PCIEXPTYPEDOWNSTREAM: case PCIEXPTYPEUPSTREAM: pciwordtestandsetmask(dev->wmask + PCIBRIDGECONTROL, PCIBRIDGECTLSERR); pcilongtestandsetmask(dev->w1cmask + PCISTATUS, PCISECSTATUSRCVSYSTEMERROR); break; default: /* nothing */ break; } return 0; } ", "target": 1}
{"func": "static void qemutcginitvcpu(CPUState *cpu) { char threadname[VCPUTHREADNAMESIZE]; static QemuCond *tcghaltcond; static QemuThread *tcgcputhread; /* share a single thread for all cpus with TCG */ if (!tcgcputhread) { cpu->thread = gmalloc0(sizeof(QemuThread)); cpu->haltcond = gmalloc0(sizeof(QemuCond)); qemucondinit(cpu->haltcond); tcghaltcond = cpu->haltcond; snprintf(threadname, VCPUTHREADNAMESIZE, \"CPU %d/TCG\", cpu->cpuindex); qemuthreadcreate(cpu->thread, threadname, qemutcgcputhreadfn, cpu, QEMUTHREADJOINABLE); #ifdef WIN32 cpu->hThread = qemuthreadgethandle(cpu->thread); #endif while (!cpu->created) { qemucondwait(&qemucpucond, &qemuglobalmutex); } tcgcputhread = cpu->thread; } else { cpu->thread = tcgcputhread; cpu->haltcond = tcghaltcond; } } ", "target": 1}
{"func": "ssizet vncclientwritebuf(VncState *vs, const uint8t *data, sizet datalen) { ssizet ret; #ifdef CONFIGVNCTLS if (vs->tls.session) { ret = vncclientwritetls(&vs->tls.session, data, datalen); } else { #endif /* CONFIGVNCTLS */ ret = send(vs->csock, (const void *)data, datalen, 0); #ifdef CONFIGVNCTLS } #endif /* CONFIGVNCTLS */ VNCDEBUG(\"Wrote wire %p %zd -> %ld\\n\", data, datalen, ret); return vncclientioerror(vs, ret, socketerror()); } ", "target": 1}
{"func": "static avcold int decodeinit(AVCodecContext * avctx) { MPADecodeContext *s = avctx->privdata; static int init=0; int i, j, k; s->avctx = avctx; ffmpadspinit(&s->mpadsp); avctx->samplefmt= OUTFMT; s->errorrecognition= avctx->errorrecognition; if (!init && !avctx->parseonly) { int offset; /* scale factors table for layer 1/2 */ for(i=0;i<64;i++) { int shift, mod; /* 1.0 (i = 3) is normalized to 2 ^ FRACBITS */ shift = (i / 3); mod = i % 3; scalefactormodshift[i] = mod | (shift << 2); } /* scale factor multiply for layer 1 */ for(i=0;i<15;i++) { int n, norm; n = i + 2; norm = ((INT64C(1) << n) * FRACONE) / ((1 << n) - 1); scalefactormult[i][0] = MULLx(norm, FIXR(1.0 * 2.0), FRACBITS); scalefactormult[i][1] = MULLx(norm, FIXR(0.7937005259 * 2.0), FRACBITS); scalefactormult[i][2] = MULLx(norm, FIXR(0.6299605249 * 2.0), FRACBITS); avdlog(avctx, \"%d: norm=%x s=%x %x %x\\n\", i, norm, scalefactormult[i][0], scalefactormult[i][1], scalefactormult[i][2]); } RENAME(ffmpasynthinit)(RENAME(ffmpasynthwindow)); /* huffman decode tables */ offset = 0; for(i=1;i<16;i++) { const HuffTable *h = &mpahufftables[i]; int xsize, x, y; uint8t tmpbits [512]; uint16t tmpcodes[512]; memset(tmpbits , 0, sizeof(tmpbits )); memset(tmpcodes, 0, sizeof(tmpcodes)); xsize = h->xsize; j = 0; for(x=0;x<xsize;x++) { for(y=0;y<xsize;y++){ tmpbits [(x << 5) | y | ((x&&y)<<4)]= h->bits [j ]; tmpcodes[(x << 5) | y | ((x&&y)<<4)]= h->codes[j++]; } } /* XXX: fail test */ huffvlc[i].table = huffvlctables+offset; huffvlc[i].tableallocated = huffvlctablessizes[i]; initvlc(&huffvlc[i], 7, 512, tmpbits, 1, 1, tmpcodes, 2, 2, INITVLCUSENEWSTATIC); offset += huffvlctablessizes[i]; } assert(offset == FFARRAYELEMS(huffvlctables)); offset = 0; for(i=0;i<2;i++) { huffquadvlc[i].table = huffquadvlctables+offset; huffquadvlc[i].tableallocated = huffquadvlctablessizes[i]; initvlc(&huffquadvlc[i], i == 0 ? 7 : 4, 16, mpaquadbits[i], 1, 1, mpaquadcodes[i], 1, 1, INITVLCUSENEWSTATIC); offset += huffquadvlctablessizes[i]; } assert(offset == FFARRAYELEMS(huffquadvlctables)); for(i=0;i<9;i++) { k = 0; for(j=0;j<22;j++) { bandindexlong[i][j] = k; k += bandsizelong[i][j]; } bandindexlong[i][22] = k; } /* compute n ^ (4/3) and store it in mantissa/exp format */ intpowinit(); mpegaudiotableinit(); for (i = 0; i < 4; i++) if (ffmpaquantbits[i] < 0) for (j = 0; j < (1<<(-ffmpaquantbits[i]+1)); j++) { int val1, val2, val3, steps; int val = j; steps = ffmpaquantsteps[i]; val1 = val % steps; val /= steps; val2 = val % steps; val3 = val / steps; divisiontabs[i][j] = val1 + (val2 << 4) + (val3 << 8); } for(i=0;i<7;i++) { float f; INTFLOAT v; if (i != 6) { f = tan((double)i * MPI / 12.0); v = FIXR(f / (1.0 + f)); } else { v = FIXR(1.0); } istable[0][i] = v; istable[1][6 - i] = v; } /* invalid values */ for(i=7;i<16;i++) istable[0][i] = istable[1][i] = 0.0; for(i=0;i<16;i++) { double f; int e, k; for(j=0;j<2;j++) { e = -(j + 1) * ((i + 1) >> 1); f = pow(2.0, e / 4.0); k = i & 1; istablelsf[j][k ^ 1][i] = FIXR(f); istablelsf[j][k][i] = FIXR(1.0); avdlog(avctx, \"istablelsf %d %d: %x %x\\n\", i, j, istablelsf[j][0][i], istablelsf[j][1][i]); } } for(i=0;i<8;i++) { float ci, cs, ca; ci = citable[i]; cs = 1.0 / sqrt(1.0 + ci * ci); ca = cs * ci; csatable[i][0] = FIXHR(cs/4); csatable[i][1] = FIXHR(ca/4); csatable[i][2] = FIXHR(ca/4) + FIXHR(cs/4); csatable[i][3] = FIXHR(ca/4) - FIXHR(cs/4); csatablefloat[i][0] = cs; csatablefloat[i][1] = ca; csatablefloat[i][2] = ca + cs; csatablefloat[i][3] = ca - cs; } /* compute mdct windows */ for(i=0;i<36;i++) { for(j=0; j<4; j++){ double d; if(j==2 && i%3 != 1) continue; d= sin(MPI * (i + 0.5) / 36.0); if(j==1){ if (i>=30) d= 0; else if(i>=24) d= sin(MPI * (i - 18 + 0.5) / 12.0); else if(i>=18) d= 1; }else if(j==3){ if (i< 6) d= 0; else if(i< 12) d= sin(MPI * (i - 6 + 0.5) / 12.0); else if(i< 18) d= 1; } //merge last stage of imdct into the window coefficients d*= 0.5 / cos(MPI*(2*i + 19)/72); if(j==2) mdctwin[j][i/3] = FIXHR((d / (1<<5))); else mdctwin[j][i ] = FIXHR((d / (1<<5))); } } /* NOTE: we do frequency inversion adter the MDCT by changing the sign of the right window coefs */ for(j=0;j<4;j++) { for(i=0;i<36;i+=2) { mdctwin[j + 4][i] = mdctwin[j][i]; mdctwin[j + 4][i + 1] = -mdctwin[j][i + 1]; } } init = 1; } if (avctx->codecid == CODECIDMP3ADU) s->adumode = 1; return 0; } ", "target": 0}
{"func": "static int libgsmdecodeframe(AVCodecContext *avctx, void *data, int *datasize, AVPacket *avpkt) { uint8t *buf = avpkt->data; int bufsize = avpkt->size; int outsize = avctx->framesize * avgetbytespersample(avctx->samplefmt); if (*datasize < outsize) { avlog(avctx, AVLOGERROR, \"Output buffer is too small\\n\"); return AVERROR(EINVAL); } if (bufsize < avctx->blockalign) { avlog(avctx, AVLOGERROR, \"Packet is too small\\n\"); return AVERRORINVALIDDATA; } switch(avctx->codecid) { case CODECIDGSM: if(gsmdecode(avctx->privdata,buf,data)) return -1; break; case CODECIDGSMMS: if(gsmdecode(avctx->privdata,buf,data) || gsmdecode(avctx->privdata,buf+33,((int16t*)data)+GSMFRAMESIZE)) return -1; } *datasize = outsize; return avctx->blockalign; } ", "target": 0}
{"func": "static int memoryaccesssize(MemoryRegion *mr, unsigned l, hwaddr addr) { unsigned accesssizemin = mr->ops->impl.minaccesssize; unsigned accesssizemax = mr->ops->impl.maxaccesssize; /* Regions are assumed to support 1-4 byte accesses unless otherwise specified. */ if (accesssizemin == 0) { accesssizemin = 1; } if (accesssizemax == 0) { accesssizemax = 4; } /* Bound the maximum access by the alignment of the address. */ if (!mr->ops->impl.unaligned) { unsigned alignsizemax = addr & -addr; if (alignsizemax != 0 && alignsizemax < accesssizemax) { accesssizemax = alignsizemax; } } /* Don't attempt accesses larger than the maximum. */ if (l > accesssizemax) { l = accesssizemax; } /* ??? The users of this function are wrong, not supporting minimums larger than the remaining length. C.f. memory.c:accesswithadjustedsize. */ assert(l >= accesssizemin); return l; } ", "target": 1}
{"func": "void fwcfgaddfilecallback(FWCfgState *s, const char *filename, FWCfgCallback selectcb, FWCfgWriteCallback writecb, void *callbackopaque, void *data, sizet len, bool readonly) { int i, index, count; sizet dsize; MachineClass *mc = MACHINEGETCLASS(qdevgetmachine()); int order = 0; if (!s->files) { dsize = sizeof(uint32t) + sizeof(FWCfgFile) * fwcfgfileslots(s); s->files = gmalloc0(dsize); fwcfgaddbytes(s, FWCFGFILEDIR, s->files, dsize); } count = be32tocpu(s->files->count); assert(count < fwcfgfileslots(s)); /* Find the insertion point. */ if (mc->legacyfwcfgorder) { /* * Sort by order. For files with the same order, we keep them * in the sequence in which they were added. */ order = getfwcfgorder(s, filename); for (index = count; index > 0 && order < s->entryorder[index - 1]; index--); } else { /* Sort by file name. */ for (index = count; index > 0 && strcmp(filename, s->files->f[index - 1].name) < 0; index--); } /* * Move all the entries from the index point and after down one * to create a slot for the new entry. Because calculations are * being done with the index, make it so that \"i\" is the current * index and \"i - 1\" is the one being copied from, thus the * unusual start and end in the for statement. */ for (i = count + 1; i > index; i--) { s->files->f[i] = s->files->f[i - 1]; s->files->f[i].select = cputobe16(FWCFGFILEFIRST + i); s->entries[0][FWCFGFILEFIRST + i] = s->entries[0][FWCFGFILEFIRST + i - 1]; s->entryorder[i] = s->entryorder[i - 1]; } memset(&s->files->f[index], 0, sizeof(FWCfgFile)); memset(&s->entries[0][FWCFGFILEFIRST + index], 0, sizeof(FWCfgEntry)); pstrcpy(s->files->f[index].name, sizeof(s->files->f[index].name), filename); for (i = 0; i <= count; i++) { if (i != index && strcmp(s->files->f[index].name, s->files->f[i].name) == 0) { errorreport(\"duplicate fwcfg file name: %s\", s->files->f[index].name); exit(1); } } fwcfgaddbytescallback(s, FWCFGFILEFIRST + index, selectcb, writecb, callbackopaque, data, len, readonly); s->files->f[index].size = cputobe32(len); s->files->f[index].select = cputobe16(FWCFGFILEFIRST + index); s->entryorder[index] = order; tracefwcfgaddfile(s, index, s->files->f[index].name, len); s->files->count = cputobe32(count+1); } ", "target": 1}
{"func": "static void stellarisenetsave(QEMUFile *f, void *opaque) { stellarisenetstate *s = (stellarisenetstate *)opaque; int i; qemuputbe32(f, s->ris); qemuputbe32(f, s->im); qemuputbe32(f, s->rctl); qemuputbe32(f, s->tctl); qemuputbe32(f, s->thr); qemuputbe32(f, s->mctl); qemuputbe32(f, s->mdv); qemuputbe32(f, s->mtxd); qemuputbe32(f, s->mrxd); qemuputbe32(f, s->np); qemuputbe32(f, s->txfifolen); qemuputbuffer(f, s->txfifo, sizeof(s->txfifo)); for (i = 0; i < 31; i++) { qemuputbe32(f, s->rx[i].len); qemuputbuffer(f, s->rx[i].data, sizeof(s->rx[i].data)); } qemuputbe32(f, s->nextpacket); qemuputbe32(f, s->rxfifooffset); } ", "target": 1}
{"func": "static void exitprogram(void) { int i, j; for (i = 0; i < nbfiltergraphs; i++) { avfiltergraphfree(&filtergraphs[i]->graph); for (j = 0; j < filtergraphs[i]->nbinputs; j++) { avfreep(&filtergraphs[i]->inputs[j]->name); avfreep(&filtergraphs[i]->inputs[j]); } avfreep(&filtergraphs[i]->inputs); for (j = 0; j < filtergraphs[i]->nboutputs; j++) { avfreep(&filtergraphs[i]->outputs[j]->name); avfreep(&filtergraphs[i]->outputs[j]); } avfreep(&filtergraphs[i]->outputs); avfreep(&filtergraphs[i]->graphdesc); avfreep(&filtergraphs[i]); } avfreep(&filtergraphs); /* close files */ for (i = 0; i < nboutputfiles; i++) { AVFormatContext *s = outputfiles[i]->ctx; if (!(s->oformat->flags & AVFMTNOFILE) && s->pb) avioclose(s->pb); avformatfreecontext(s); avdictfree(&outputfiles[i]->opts); avfreep(&outputfiles[i]); } for (i = 0; i < nboutputstreams; i++) { AVBitStreamFilterContext *bsfc = outputstreams[i]->bitstreamfilters; while (bsfc) { AVBitStreamFilterContext *next = bsfc->next; avbitstreamfilterclose(bsfc); bsfc = next; } outputstreams[i]->bitstreamfilters = NULL; avcodecfreeframe(&outputstreams[i]->filteredframe); avfreep(&outputstreams[i]->forcedkeyframes); avfreep(&outputstreams[i]->avfilter); avfreep(&outputstreams[i]->logfileprefix); avfreep(&outputstreams[i]); } for (i = 0; i < nbinputfiles; i++) { avformatcloseinput(&inputfiles[i]->ctx); avfreep(&inputfiles[i]); } for (i = 0; i < nbinputstreams; i++) { avframefree(&inputstreams[i]->decodedframe); avframefree(&inputstreams[i]->filterframe); avdictfree(&inputstreams[i]->opts); avfreep(&inputstreams[i]->filters); avfreep(&inputstreams[i]); } if (vstatsfile) fclose(vstatsfile); avfree(vstatsfilename); avfreep(&inputstreams); avfreep(&inputfiles); avfreep(&outputstreams); avfreep(&outputfiles); uninitopts(); avfilteruninit(); avformatnetworkdeinit(); if (receivedsigterm) { avlog(NULL, AVLOGINFO, \"Received signal %d: terminating.\\n\", (int) receivedsigterm); exit (255); } } ", "target": 0}
{"func": "static int coroutinefn cowcoisallocated(BlockDriverState *bs, int64t sectornum, int nbsectors, int *numsame) { int64t bitnum = sectornum + sizeof(struct cowheaderv2) * 8; uint64t offset = (bitnum / 8) & -BDRVSECTORSIZE; uint8t bitmap[BDRVSECTORSIZE]; int ret; int changed; ret = bdrvpread(bs->file, offset, &bitmap, sizeof(bitmap)); if (ret < 0) { return ret; } bitnum &= BITSPERBITMAPSECTOR - 1; changed = cowtestbit(bitnum, bitmap); *numsame = cowfindstreak(bitmap, changed, bitnum, nbsectors); return changed; } ", "target": 1}
{"func": "bool timerlistexpired(QEMUTimerList *timerlist) { int64t expiretime; if (!atomicread(&timerlist->activetimers)) { return false; } qemumutexlock(&timerlist->activetimerslock); if (!timerlist->activetimers) { qemumutexunlock(&timerlist->activetimerslock); return false; } expiretime = timerlist->activetimers->expiretime; qemumutexunlock(&timerlist->activetimerslock); return expiretime < qemuclockgetns(timerlist->clock->type); } ", "target": 0}
{"func": "static void checkrefcounts(BlockDriverState *bs) { BDRVQcowState *s = bs->opaque; int64t size; int nbclusters, refcount1, refcount2, i; QCowSnapshot *sn; uint16t *refcounttable; size = bdrvgetlength(s->hd); nbclusters = sizetoclusters(s, size); refcounttable = qemumallocz(nbclusters * sizeof(uint16t)); /* header */ increfcounts(bs, refcounttable, nbclusters, 0, s->clustersize); checkrefcountsl1(bs, refcounttable, nbclusters, s->l1tableoffset, s->l1size, 1); /* snapshots */ for(i = 0; i < s->nbsnapshots; i++) { sn = s->snapshots + i; checkrefcountsl1(bs, refcounttable, nbclusters, sn->l1tableoffset, sn->l1size, 0); } increfcounts(bs, refcounttable, nbclusters, s->snapshotsoffset, s->snapshotssize); /* refcount data */ increfcounts(bs, refcounttable, nbclusters, s->refcounttableoffset, s->refcounttablesize * sizeof(uint64t)); for(i = 0; i < s->refcounttablesize; i++) { int64t offset; offset = s->refcounttable[i]; if (offset != 0) { increfcounts(bs, refcounttable, nbclusters, offset, s->clustersize); } } /* compare ref counts */ for(i = 0; i < nbclusters; i++) { refcount1 = getrefcount(bs, i); refcount2 = refcounttable[i]; if (refcount1 != refcount2) fprintf(stderr, \"ERROR cluster %d refcount=%d reference=%d\\n\", i, refcount1, refcount2); } qemufree(refcounttable); } ", "target": 0}
{"func": "static int ipoctalinit(IPackDevice *ip) { IPOctalState *s = IPOCTAL(ip); unsigned i; for (i = 0; i < NCHANNELS; i++) { SCC2698Channel *ch = &s->ch[i]; ch->ipoctal = s; /* Redirect IP-Octal channels to host character devices */ if (ch->devpath) { const char chrname[] = \"ipoctal\"; char label[ARRAYSIZE(chrname) + 2]; static int index; snprintf(label, sizeof(label), \"%s%d\", chrname, index); ch->dev = qemuchrnew(label, ch->devpath, NULL); if (ch->dev) { index++; qemuchraddhandlers(ch->dev, hostdevcanreceive, hostdevreceive, hostdevevent, ch); DPRINTF(\"Redirecting channel %u to %s (%s)\\n\", i, ch->devpath, label); } else { DPRINTF(\"Could not redirect channel %u to %s\\n\", i, ch->devpath); } } } return 0; }", "target": 1}
{"func": "static AddrRange addrrangeintersection(AddrRange r1, AddrRange r2) { uint64t start = MAX(r1.start, r2.start); /* off-by-one arithmetic to prevent overflow */ uint64t end = MIN(addrrangeend(r1) - 1, addrrangeend(r2) - 1); return addrrangemake(start, end - start + 1); } ", "target": 1}
{"func": "static int wc3readheader(AVFormatContext *s, AVFormatParameters *ap) { Wc3DemuxContext *wc3 = s->privdata; ByteIOContext *pb = s->pb; unsigned int fourcctag; unsigned int size; AVStream *st; unsigned char preamble[WC3PREAMBLESIZE]; int ret = 0; int currentpalette = 0; int bytestoread; int i; unsigned char rotate; /* default context members */ wc3->width = WC3DEFAULTWIDTH; wc3->height = WC3DEFAULTHEIGHT; wc3->palettes = NULL; wc3->palettecount = 0; wc3->pts = 0; wc3->videostreamindex = wc3->audiostreamindex = 0; /* skip the first 3 32-bit numbers */ urlfseek(pb, 12, SEEKCUR); /* traverse through the chunks and load the header information before * the first BRCH tag */ if ((ret = getbuffer(pb, preamble, WC3PREAMBLESIZE)) != WC3PREAMBLESIZE) return AVERROR(EIO); fourcctag = AVRL32(&preamble[0]); size = (AVRB32(&preamble[4]) + 1) & (~1); do { switch (fourcctag) { case SONDTAG: case INDXTAG: /* SOND unknown, INDX unnecessary; ignore both */ urlfseek(pb, size, SEEKCUR); break; case PCTAG: /* need the number of palettes */ urlfseek(pb, 8, SEEKCUR); if ((ret = getbuffer(pb, preamble, 4)) != 4) return AVERROR(EIO); wc3->palettecount = AVRL32(&preamble[0]); if((unsigned)wc3->palettecount >= UINTMAX / PALETTESIZE){ wc3->palettecount= 0; return -1; } wc3->palettes = avmalloc(wc3->palettecount * PALETTESIZE); break; case BNAMTAG: /* load up the name */ if ((unsigned)size < 512) bytestoread = size; else bytestoread = 512; if ((ret = getbuffer(pb, s->title, bytestoread)) != bytestoread) return AVERROR(EIO); break; case SIZETAG: /* video resolution override */ if ((ret = getbuffer(pb, preamble, WC3PREAMBLESIZE)) != WC3PREAMBLESIZE) return AVERROR(EIO); wc3->width = AVRL32(&preamble[0]); wc3->height = AVRL32(&preamble[4]); break; case PALTTAG: /* one of several palettes */ if ((unsigned)currentpalette >= wc3->palettecount) return AVERRORINVALIDDATA; if ((ret = getbuffer(pb, &wc3->palettes[currentpalette * PALETTESIZE], PALETTESIZE)) != PALETTESIZE) return AVERROR(EIO); /* transform the current palette in place */ for (i = currentpalette * PALETTESIZE; i < (currentpalette + 1) * PALETTESIZE; i++) { /* rotate each palette component left by 2 and use the result * as an index into the color component table */ rotate = ((wc3->palettes[i] << 2) & 0xFF) | ((wc3->palettes[i] >> 6) & 0xFF); wc3->palettes[i] = wc3pallookup[rotate]; } currentpalette++; break; default: avlog(s, AVLOGERROR, \" unrecognized WC3 chunk: %c%c%c%c (0x%02X%02X%02X%02X)\\n\", preamble[0], preamble[1], preamble[2], preamble[3], preamble[0], preamble[1], preamble[2], preamble[3]); return AVERRORINVALIDDATA; break; } if ((ret = getbuffer(pb, preamble, WC3PREAMBLESIZE)) != WC3PREAMBLESIZE) return AVERROR(EIO); fourcctag = AVRL32(&preamble[0]); /* chunk sizes are 16-bit aligned */ size = (AVRB32(&preamble[4]) + 1) & (~1); } while (fourcctag != BRCHTAG); /* initialize the decoder streams */ st = avnewstream(s, 0); if (!st) return AVERROR(ENOMEM); avsetptsinfo(st, 33, 1, 90000); wc3->videostreamindex = st->index; st->codec->codectype = CODECTYPEVIDEO; st->codec->codecid = CODECIDXANWC3; st->codec->codectag = 0; /* no fourcc */ st->codec->width = wc3->width; st->codec->height = wc3->height; /* palette considerations */ st->codec->palctrl = &wc3->palettecontrol; st = avnewstream(s, 0); if (!st) return AVERROR(ENOMEM); avsetptsinfo(st, 33, 1, 90000); wc3->audiostreamindex = st->index; st->codec->codectype = CODECTYPEAUDIO; st->codec->codecid = CODECIDPCMS16LE; st->codec->codectag = 1; st->codec->channels = WC3AUDIOCHANNELS; st->codec->bitspersample = WC3AUDIOBITS; st->codec->samplerate = WC3SAMPLERATE; st->codec->bitrate = st->codec->channels * st->codec->samplerate * st->codec->bitspersample; st->codec->blockalign = WC3AUDIOBITS * WC3AUDIOCHANNELS; return 0; } ", "target": 0}
{"func": "static int64t dostrtosz(const char *nptr, char **end, const char defaultsuffix, int64t unit) { int64t retval; char *endptr; unsigned char c; int mulrequired = 0; double val, mul, integral, fraction; errno = 0; val = strtod(nptr, &endptr); if (isnan(val) || endptr == nptr || errno != 0) { retval = -EINVAL; goto out; } fraction = modf(val, &integral); if (fraction != 0) { mulrequired = 1; } c = *endptr; mul = suffixmul(c, unit); if (mul >= 0) { endptr++; } else { mul = suffixmul(defaultsuffix, unit); assert(mul >= 0); } if (mul == 1 && mulrequired) { retval = -EINVAL; goto out; } if ((val * mul >= INT64MAX) || val < 0) { retval = -ERANGE; goto out; } retval = val * mul; out: if (end) { *end = endptr; } else if (*endptr) { retval = -EINVAL; } return retval; } ", "target": 0}
{"func": "static int checkrefcountsl1(BlockDriverState *bs, BdrvCheckResult *res, uint16t **refcounttable, int64t *refcounttablesize, int64t l1tableoffset, int l1size, int flags) { BDRVQcowState *s = bs->opaque; uint64t *l1table = NULL, l2offset, l1size2; int i, ret; l1size2 = l1size * sizeof(uint64t); /* Mark L1 table as used */ ret = increfcounts(bs, res, refcounttable, refcounttablesize, l1tableoffset, l1size2); if (ret < 0) { goto fail; } /* Read L1 table entries from disk */ if (l1size2 > 0) { l1table = gtrymalloc(l1size2); if (l1table == NULL) { ret = -ENOMEM; res->checkerrors++; goto fail; } ret = bdrvpread(bs->file, l1tableoffset, l1table, l1size2); if (ret < 0) { fprintf(stderr, \"ERROR: I/O error in checkrefcountsl1\\n\"); res->checkerrors++; goto fail; } for(i = 0;i < l1size; i++) be64tocpus(&l1table[i]); } /* Do the actual checks */ for(i = 0; i < l1size; i++) { l2offset = l1table[i]; if (l2offset) { /* Mark L2 table as used */ l2offset &= L1EOFFSETMASK; ret = increfcounts(bs, res, refcounttable, refcounttablesize, l2offset, s->clustersize); if (ret < 0) { goto fail; } /* L2 tables are cluster aligned */ if (offsetintocluster(s, l2offset)) { fprintf(stderr, \"ERROR l2offset=%\" PRIx64 \": Table is not \" \"cluster aligned; L1 entry corrupted\\n\", l2offset); res->corruptions++; } /* Process and check L2 entries */ ret = checkrefcountsl2(bs, res, refcounttable, refcounttablesize, l2offset, flags); if (ret < 0) { goto fail; } } } gfree(l1table); return 0; fail: gfree(l1table); return ret; } ", "target": 1}
{"func": "static uint32t dcrreadpob (void *opaque, int dcrn) { ppc4xxpobt *pob; uint32t ret; pob = opaque; switch (dcrn) { case POB0BEAR: ret = pob->bear; break; case POB0BESR0: case POB0BESR1: ret = pob->besr[dcrn - POB0BESR0]; break; default: /* Avoid gcc warning */ ret = 0; break; } return ret; } ", "target": 1}
{"func": "static inline int onenanderase(OneNANDState *s, int sec, int num) { uint8t *blankbuf, *tmpbuf; blankbuf = gmalloc(512); if (!blankbuf) { return 1; } tmpbuf = gmalloc(512); if (!tmpbuf) { gfree(blankbuf); return 1; } memset(blankbuf, 0xff, 512); for (; num > 0; num--, sec++) { if (s->bdrvcur) { int erasesec = s->secscur + (sec >> 5); if (bdrvwrite(s->bdrvcur, sec, blankbuf, 1) < 0) { goto fail; } if (bdrvread(s->bdrvcur, erasesec, tmpbuf, 1) < 0) { goto fail; } memcpy(tmpbuf + ((sec & 31) << 4), blankbuf, 1 << 4); if (bdrvwrite(s->bdrvcur, erasesec, tmpbuf, 1) < 0) { goto fail; } } else { if (sec + 1 > s->secscur) { goto fail; } memcpy(s->current + (sec << 9), blankbuf, 512); memcpy(s->current + (s->secscur << 9) + (sec << 4), blankbuf, 1 << 4); } } gfree(tmpbuf); gfree(blankbuf); return 0; fail: gfree(tmpbuf); gfree(blankbuf); return 1; } ", "target": 0}
{"func": "static int vmdkparseextents(const char *desc, BlockDriverState *bs, const char *descfilepath, Error **errp) { int ret; char access[11]; char type[11]; char fname[512]; const char *p = desc; int64t sectors = 0; int64t flatoffset; char extentpath[PATHMAX]; BlockDriverState *extentfile; BDRVVmdkState *s = bs->opaque; VmdkExtent *extent; while (*p) { /* parse extent line: * RW [size in sectors] FLAT \"file-name.vmdk\" OFFSET * or * RW [size in sectors] SPARSE \"file-name.vmdk\" */ flatoffset = -1; ret = sscanf(p, \"%10s %\" SCNd64 \" %10s \\\"%511[^\\n\\r\\\"]\\\" %\" SCNd64, access, &sectors, type, fname, &flatoffset); if (ret < 4 || strcmp(access, \"RW\")) { goto nextline; } else if (!strcmp(type, \"FLAT\")) { if (ret != 5 || flatoffset < 0) { errorsetg(errp, \"Invalid extent lines: \\n%s\", p); return -EINVAL; } } else if (!strcmp(type, \"VMFS\")) { if (ret == 4) { flatoffset = 0; } else { errorsetg(errp, \"Invalid extent lines:\\n%s\", p); return -EINVAL; } } else if (ret != 4) { errorsetg(errp, \"Invalid extent lines:\\n%s\", p); return -EINVAL; } if (sectors <= 0 || (strcmp(type, \"FLAT\") && strcmp(type, \"SPARSE\") && strcmp(type, \"VMFS\") && strcmp(type, \"VMFSSPARSE\")) || (strcmp(access, \"RW\"))) { goto nextline; } pathcombine(extentpath, sizeof(extentpath), descfilepath, fname); extentfile = NULL; ret = bdrvopen(&extentfile, extentpath, NULL, NULL, bs->openflags | BDRVOPROTOCOL, NULL, errp); if (ret) { return ret; } /* save to extents array */ if (!strcmp(type, \"FLAT\") || !strcmp(type, \"VMFS\")) { /* FLAT extent */ ret = vmdkaddextent(bs, extentfile, true, sectors, 0, 0, 0, 0, 0, &extent, errp); if (ret < 0) { return ret; } extent->flatstartoffset = flatoffset << 9; } else if (!strcmp(type, \"SPARSE\") || !strcmp(type, \"VMFSSPARSE\")) { /* SPARSE extent and VMFSSPARSE extent are both \"COWD\" sparse file*/ char *buf = vmdkreaddesc(extentfile, 0, errp); if (!buf) { ret = -EINVAL; } else { ret = vmdkopensparse(bs, extentfile, bs->openflags, buf, errp); } if (ret) { gfree(buf); return ret; } extent = &s->extents[s->numextents - 1]; } else { errorsetg(errp, \"Unsupported extent type '%s'\", type); return -ENOTSUP; } extent->type = gstrdup(type); nextline: /* move to next line */ while (*p) { if (*p == '\\n') { p++; break; } p++; } } return 0; }", "target": 1}
{"func": "static int defaultlockmgrcb(void **arg, enum AVLockOp op) { void * volatile * mutex = arg; int err; switch (op) { case AVLOCKCREATE: return 0; case AVLOCKOBTAIN: if (!*mutex) { pthreadmutext *tmp = avmalloc(sizeof(pthreadmutext)); if (!tmp) return AVERROR(ENOMEM); if ((err = pthreadmutexinit(tmp, NULL))) { avfree(tmp); return AVERROR(err); } if (avprivatomicptrcas(mutex, NULL, tmp)) { pthreadmutexdestroy(tmp); avfree(tmp); } } if ((err = pthreadmutexlock(*mutex))) return AVERROR(err); return 0; case AVLOCKRELEASE: if ((err = pthreadmutexunlock(*mutex))) return AVERROR(err); return 0; case AVLOCKDESTROY: if (*mutex) pthreadmutexdestroy(*mutex); avfree(*mutex); avprivatomicptrcas(mutex, *mutex, NULL); return 0; } return 1; } ", "target": 1}
{"func": "static inline int checkinputmotion(MpegEncContext * s, int mbx, int mby, int ptype){ MotionEstContext * const c= &s->me; Picture *p= s->currentpictureptr; int mbxy= mbx + mby*s->mbstride; int xy= 2*mbx + 2*mby*s->b8stride; int mbtype= s->currentpicture.mbtype[mbxy]; int flags= c->flags; int shift= (flags&FLAGQPEL) + 1; int mask= (1<<shift)-1; int x, y, i; int d=0; mecmpfunc cmpf= s->dsp.sse[0]; mecmpfunc chromacmpf= s->dsp.sse[1]; assert(ptype==0 || !USESLIST(mbtype, 1)); assert(ISINTRA(mbtype) || USESLIST(mbtype,0) || USESLIST(mbtype,1)); if(ISINTERLACED(mbtype)){ int xy2= xy + s->b8stride; s->mbtype[mbxy]=CANDIDATEMBTYPEINTRA; c->stride<<=1; c->uvstride<<=1; initinterlacedref(s, 2); assert(s->flags & CODECFLAGINTERLACEDME); if(USESLIST(mbtype, 0)){ int fieldselect0= p->refindex[0][xy ]; int fieldselect1= p->refindex[0][xy2]; assert(fieldselect0==0 ||fieldselect0==1); assert(fieldselect1==0 ||fieldselect1==1); if(ptype){ s->pfieldselecttable[0][mbxy]= fieldselect0; s->pfieldselecttable[1][mbxy]= fieldselect1; *(uint32t*)s->pfieldmvtable[0][fieldselect0][mbxy]= *(uint32t*)p->motionval[0][xy ]; *(uint32t*)s->pfieldmvtable[1][fieldselect1][mbxy]= *(uint32t*)p->motionval[0][xy2]; s->mbtype[mbxy]=CANDIDATEMBTYPEINTERI; }else{ s->bfieldselecttable[0][0][mbxy]= fieldselect0; s->bfieldselecttable[0][1][mbxy]= fieldselect1; *(uint32t*)s->bfieldmvtable[0][0][fieldselect0][mbxy]= *(uint32t*)p->motionval[0][xy ]; *(uint32t*)s->bfieldmvtable[0][1][fieldselect1][mbxy]= *(uint32t*)p->motionval[0][xy2]; s->mbtype[mbxy]= CANDIDATEMBTYPEFORWARDI; } x= p->motionval[0][xy ][0]; y= p->motionval[0][xy ][1]; d = cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 8, fieldselect0, 0, cmpf, chromacmpf, flags); x= p->motionval[0][xy2][0]; y= p->motionval[0][xy2][1]; d+= cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 8, fieldselect1, 1, cmpf, chromacmpf, flags); } if(USESLIST(mbtype, 1)){ int fieldselect0= p->refindex[1][xy ]; int fieldselect1= p->refindex[1][xy2]; assert(fieldselect0==0 ||fieldselect0==1); assert(fieldselect1==0 ||fieldselect1==1); s->bfieldselecttable[1][0][mbxy]= fieldselect0; s->bfieldselecttable[1][1][mbxy]= fieldselect1; *(uint32t*)s->bfieldmvtable[1][0][fieldselect0][mbxy]= *(uint32t*)p->motionval[1][xy ]; *(uint32t*)s->bfieldmvtable[1][1][fieldselect1][mbxy]= *(uint32t*)p->motionval[1][xy2]; if(USESLIST(mbtype, 0)){ s->mbtype[mbxy]= CANDIDATEMBTYPEBIDIRI; }else{ s->mbtype[mbxy]= CANDIDATEMBTYPEBACKWARDI; } x= p->motionval[1][xy ][0]; y= p->motionval[1][xy ][1]; d = cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 8, fieldselect0+2, 0, cmpf, chromacmpf, flags); x= p->motionval[1][xy2][0]; y= p->motionval[1][xy2][1]; d+= cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 8, fieldselect1+2, 1, cmpf, chromacmpf, flags); //FIXME bidir scores } c->stride>>=1; c->uvstride>>=1; }else if(IS8X8(mbtype)){ cmpf= s->dsp.sse[1]; chromacmpf= s->dsp.sse[1]; initmv4ref(s); for(i=0; i<4; i++){ xy= s->blockindex[i]; x= p->motionval[0][xy][0]; y= p->motionval[0][xy][1]; d+= cmp(s, x>>shift, y>>shift, x&mask, y&mask, 1, 8, i, i, cmpf, chromacmpf, flags); } s->mbtype[mbxy]=CANDIDATEMBTYPEINTER4V; }else{ if(USESLIST(mbtype, 0)){ if(ptype){ *(uint32t*)s->pmvtable[mbxy]= *(uint32t*)p->motionval[0][xy]; s->mbtype[mbxy]=CANDIDATEMBTYPEINTER; }else if(USESLIST(mbtype, 1)){ *(uint32t*)s->bbidirforwmvtable[mbxy]= *(uint32t*)p->motionval[0][xy]; *(uint32t*)s->bbidirbackmvtable[mbxy]= *(uint32t*)p->motionval[1][xy]; s->mbtype[mbxy]=CANDIDATEMBTYPEBIDIR; }else{ *(uint32t*)s->bforwmvtable[mbxy]= *(uint32t*)p->motionval[0][xy]; s->mbtype[mbxy]=CANDIDATEMBTYPEFORWARD; } x= p->motionval[0][xy][0]; y= p->motionval[0][xy][1]; d = cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 16, 0, 0, cmpf, chromacmpf, flags); }else if(USESLIST(mbtype, 1)){ *(uint32t*)s->bbackmvtable[mbxy]= *(uint32t*)p->motionval[1][xy]; s->mbtype[mbxy]=CANDIDATEMBTYPEBACKWARD; x= p->motionval[1][xy][0]; y= p->motionval[1][xy][1]; d = cmp(s, x>>shift, y>>shift, x&mask, y&mask, 0, 16, 2, 0, cmpf, chromacmpf, flags); }else s->mbtype[mbxy]=CANDIDATEMBTYPEINTRA; } return d; }", "target": 1}
{"func": "void ffestimatepframemotion(MpegEncContext * s, int mbx, int mby) { UINT8 *pix, *ppix; int sum, varc, vard, mx, my, range, dmin, xx, yy; int xmin, ymin, xmax, ymax; int relxmin, relymin, relxmax, relymax; int predx=0, predy=0; int P[6][2]; const int shift= 1+s->quartersample; int mbtype=0; uint8t *refpicture= s->lastpicture[0]; getlimits(s, &range, &xmin, &ymin, &xmax, &ymax, s->fcode); switch(s->memethod) { case MEZERO: default: \tnomotionsearch(s, &mx, &my); dmin = 0; break; case MEFULL: \tdmin = fullmotionsearch(s, &mx, &my, range, xmin, ymin, xmax, ymax, refpicture); break; case MELOG: \tdmin = logmotionsearch(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, refpicture); break; case MEPHODS: \tdmin = phodsmotionsearch(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, refpicture); break; case MEX1: case MEEPZS: { const int motstride = s->blockwrap[0]; const int motxy = s->blockindex[0]; relxmin= xmin - mbx*16; relxmax= xmax - mbx*16; relymin= ymin - mby*16; relymax= ymax - mby*16; P[0][0] = s->motionval[motxy ][0]; P[0][1] = s->motionval[motxy ][1]; P[1][0] = s->motionval[motxy - 1][0]; P[1][1] = s->motionval[motxy - 1][1]; if(P[1][0] > (relxmax<<shift)) P[1][0]= (relxmax<<shift); /* special case for first line */ if ((mby == 0 || s->firstsliceline || s->firstgobline)) { P[4][0] = P[1][0]; P[4][1] = P[1][1]; } else { P[2][0] = s->motionval[motxy - motstride ][0]; P[2][1] = s->motionval[motxy - motstride ][1]; P[3][0] = s->motionval[motxy - motstride + 2 ][0]; P[3][1] = s->motionval[motxy - motstride + 2 ][1]; if(P[2][1] > (relymax<<shift)) P[2][1]= (relymax<<shift); if(P[3][0] < (relxmin<<shift)) P[3][0]= (relxmin<<shift); if(P[3][1] > (relymax<<shift)) P[3][1]= (relymax<<shift); P[4][0]= midpred(P[1][0], P[2][0], P[3][0]); P[4][1]= midpred(P[1][1], P[2][1], P[3][1]); } if(s->outformat == FMTH263){ predx = P[4][0]; predy = P[4][1]; }else { /* mpeg1 at least */ predx= P[1][0]; predy= P[1][1]; } } dmin = epzsmotionsearch(s, &mx, &my, P, predx, predy, relxmin, relymin, relxmax, relymax, refpicture); mx+= mbx*16; my+= mby*16; break; } if(s->flags&CODECFLAG4MV){ int block; mbtype|= MBTYPEINTER4V; for(block=0; block<4; block++){ int mx4, my4; int predx4, predy4; int dmin4; static const int off[4]= {2, 1, 1, -1}; const int motstride = s->blockwrap[0]; const int motxy = s->blockindex[block]; const int blockx= mbx*2 + (block&1); const int blocky= mby*2 + (block>>1); const int relxmin4= xmin - blockx*8; const int relxmax4= xmax - blockx*8 + 8; const int relymin4= ymin - blocky*8; const int relymax4= ymax - blocky*8 + 8; P[0][0] = s->motionval[motxy ][0]; P[0][1] = s->motionval[motxy ][1]; P[1][0] = s->motionval[motxy - 1][0]; P[1][1] = s->motionval[motxy - 1][1]; if(P[1][0] > (relxmax4<<shift)) P[1][0]= (relxmax4<<shift); /* special case for first line */ if ((mby == 0 || s->firstsliceline || s->firstgobline) && block<2) { P[4][0] = P[1][0]; P[4][1] = P[1][1]; } else { P[2][0] = s->motionval[motxy - motstride ][0]; P[2][1] = s->motionval[motxy - motstride ][1]; P[3][0] = s->motionval[motxy - motstride + off[block]][0]; P[3][1] = s->motionval[motxy - motstride + off[block]][1]; if(P[2][1] > (relymax4<<shift)) P[2][1]= (relymax4<<shift); if(P[3][0] < (relxmin4<<shift)) P[3][0]= (relxmin4<<shift); if(P[3][0] > (relxmax4<<shift)) P[3][0]= (relxmax4<<shift); if(P[3][1] > (relymax4<<shift)) P[3][1]= (relymax4<<shift); P[4][0]= midpred(P[1][0], P[2][0], P[3][0]); P[4][1]= midpred(P[1][1], P[2][1], P[3][1]); } if(s->outformat == FMTH263){ predx4 = P[4][0]; predy4 = P[4][1]; }else { /* mpeg1 at least */ predx4= P[1][0]; predy4= P[1][1]; } P[5][0]= mx - mbx*16; P[5][1]= my - mby*16; dmin4 = epzsmotionsearch4(s, block, &mx4, &my4, P, predx4, predy4, relxmin4, relymin4, relxmax4, relymax4, refpicture); halfpelmotionsearch4(s, &mx4, &my4, dmin4, relxmin4, relymin4, relxmax4, relymax4, predx4, predy4, blockx, blocky, refpicture); s->motionval[ s->blockindex[block] ][0]= mx4; s->motionval[ s->blockindex[block] ][1]= my4; } } /* intra / predictive decision */ xx = mbx * 16; yy = mby * 16; pix = s->newpicture[0] + (yy * s->linesize) + xx; /* At this point (mx,my) are full-pell and the absolute displacement */ ppix = refpicture + (my * s->linesize) + mx; sum = pixsum(pix, s->linesize); #if 0 varc = pixdev(pix, s->linesize, (sum+128)>>8) + INTERBIAS; vard = pixabs16x16(pix, ppix, s->linesize); #else sum= (sum+8)>>4; varc = ((pixnorm1(pix, s->linesize) - sum*sum + 128 + 500)>>8); vard = (pixnorm(pix, ppix, s->linesize)+128)>>8; #endif s->mbvar[s->mbwidth * mby + mbx] = varc; s->avgmbvar+= varc; s->mcmbvar += vard; #if 0 printf(\"varc=%4d avgvar=%4d (sum=%4d) vard=%4d mx=%2d my=%2d\\n\", \t varc, s->avgmbvar, sum, vard, mx - xx, my - yy); #endif if(s->flags&CODECFLAGHQ){ if (vard*2 + 200 > varc) mbtype|= MBTYPEINTRA; if (varc*2 + 200 > vard){ mbtype|= MBTYPEINTER; halfpelmotionsearch(s, &mx, &my, dmin, xmin, ymin, xmax, ymax, predx, predy, refpicture); }else{ mx = mx*2 - mbx*32; my = my*2 - mby*32; } }else{ if (vard <= 64 || vard < varc) { mbtype|= MBTYPEINTER; if (s->memethod != MEZERO) { halfpelmotionsearch(s, &mx, &my, dmin, xmin, ymin, xmax, ymax, predx, predy, refpicture); } else { mx -= 16 * mbx; my -= 16 * mby; } #if 0 if (vard < 10) { skip++; fprintf(stderr,\"\\nEarly skip: %d vard: %2d varc: %5d dmin: %d\", skip, vard, varc, dmin); } #endif }else{ mbtype|= MBTYPEINTRA; mx = 0;//mx*2 - 32 * mbx; my = 0;//my*2 - 32 * mby; } } s->mbtype[mby*s->mbwidth + mbx]= mbtype; setpmvtables(s, mx, my); } ", "target": 0}
{"func": "avcold int ffvaapiencodeclose(AVCodecContext *avctx) { VAAPIEncodeContext *ctx = avctx->privdata; VAAPIEncodePicture *pic, *next; for (pic = ctx->picstart; pic; pic = next) { next = pic->next; vaapiencodefree(avctx, pic); } if (ctx->vacontext != VAINVALIDID) { vaDestroyContext(ctx->hwctx->display, ctx->vacontext); ctx->vacontext = VAINVALIDID; } if (ctx->vaconfig != VAINVALIDID) { vaDestroyConfig(ctx->hwctx->display, ctx->vaconfig); ctx->vaconfig = VAINVALIDID; } if (ctx->codec->close) ctx->codec->close(avctx); avbufferpooluninit(&ctx->outputbufferpool); avfreep(&ctx->codecsequenceparams); avfreep(&ctx->codecpictureparams); avbufferunref(&ctx->reconframesref); avbufferunref(&ctx->inputframesref); avbufferunref(&ctx->deviceref); avfreep(&ctx->privdata); return 0; } ", "target": 0}
{"func": "static ssizet socketread(int sockfd, void *buff, sizet size) { ssizet retval, total = 0; while (size) { retval = read(sockfd, buff, size); if (retval == 0) { return -EIO; } if (retval < 0) { if (errno == EINTR) { continue; } return -errno; } size -= retval; buff += retval; total += retval; } return total; } ", "target": 0}
{"func": "AioContext *blkgetaiocontext(BlockBackend *blk) { return bdrvgetaiocontext(blk->bs); } ", "target": 0}
{"func": "static int vfioloadrom(VFIODevice *vdev) { uint64t size = vdev->romsize; char name[32]; offt off = 0, voff = vdev->romoffset; ssizet bytes; void *ptr; /* If loading ROM from file, pci handles it */ if (vdev->pdev.romfile || !vdev->pdev.rombar || !size) { return 0; } DPRINTF(\"%s(%04x:%02x:%02x.%x)\\n\", func, vdev->host.domain, vdev->host.bus, vdev->host.slot, vdev->host.function); snprintf(name, sizeof(name), \"vfio[%04x:%02x:%02x.%x].rom\", vdev->host.domain, vdev->host.bus, vdev->host.slot, vdev->host.function); memoryregioninitram(&vdev->pdev.rom, OBJECT(vdev), name, size); ptr = memoryregiongetramptr(&vdev->pdev.rom); memset(ptr, 0xff, size); while (size) { bytes = pread(vdev->fd, ptr + off, size, voff + off); if (bytes == 0) { break; /* expect that we could get back less than the ROM BAR */ } else if (bytes > 0) { off += bytes; size -= bytes; } else { if (errno == EINTR || errno == EAGAIN) { continue; } errorreport(\"vfio: Error reading device ROM: %m\"); memoryregiondestroy(&vdev->pdev.rom); return -errno; } } pciregisterbar(&vdev->pdev, PCIROMSLOT, 0, &vdev->pdev.rom); vdev->pdev.hasrom = true; return 0; } ", "target": 0}
{"func": "UuidInfo *qmpqueryuuid(Error **errp) { UuidInfo *info = gmalloc0(sizeof(*info)); char uuid[64]; snprintf(uuid, sizeof(uuid), UUIDFMT, qemuuuid[0], qemuuuid[1], qemuuuid[2], qemuuuid[3], qemuuuid[4], qemuuuid[5], qemuuuid[6], qemuuuid[7], qemuuuid[8], qemuuuid[9], qemuuuid[10], qemuuuid[11], qemuuuid[12], qemuuuid[13], qemuuuid[14], qemuuuid[15]); info->UUID = gstrdup(uuid); return info; } ", "target": 0}
{"func": "static int mpc7decodeframe(AVCodecContext * avctx, void *data, int *gotframeptr, AVPacket *avpkt) { const uint8t *buf = avpkt->data; int bufsize; MPCContext *c = avctx->privdata; GetBitContext gb; int i, ch; int mb = -1; Band *bands = c->bands; int off, ret, lastframe, skip; int bitsused, bitsavail; memset(bands, 0, sizeof(*bands) * (c->maxbands + 1)); bufsize = avpkt->size & ~3; if (bufsize <= 0) { avlog(avctx, AVLOGERROR, \"packet size is too small (%i bytes)\\n\", avpkt->size); return AVERRORINVALIDDATA; } if (bufsize != avpkt->size) { avlog(avctx, AVLOGWARNING, \"packet size is not a multiple of 4. \" \"extra bytes at the end will be skipped.\\n\"); } skip = buf[0]; lastframe = buf[1]; buf += 4; bufsize -= 4; /* get output buffer */ c->frame.nbsamples = lastframe ? c->lastframelen : MPCFRAMESIZE; if ((ret = avctx->getbuffer(avctx, &c->frame)) < 0) { avlog(avctx, AVLOGERROR, \"getbuffer() failed\\n\"); return ret; } avfastpaddedmalloc(&c->bits, &c->bufsize, bufsize); if (!c->bits) return AVERROR(ENOMEM); c->dsp.bswapbuf((uint32t *)c->bits, (const uint32t *)buf, bufsize >> 2); initgetbits(&gb, c->bits, bufsize * 8); skipbitslong(&gb, skip); /* read subband indexes */ for(i = 0; i <= c->maxbands; i++){ for(ch = 0; ch < 2; ch++){ int t = 4; if(i) t = getvlc2(&gb, hdrvlc.table, MPC7HDRBITS, 1) - 5; if(t == 4) bands[i].res[ch] = getbits(&gb, 4); else bands[i].res[ch] = bands[i-1].res[ch] + t; } if(bands[i].res[0] || bands[i].res[1]){ mb = i; if(c->MSS) bands[i].msf = getbits1(&gb); } } /* get scale indexes coding method */ for(i = 0; i <= mb; i++) for(ch = 0; ch < 2; ch++) if(bands[i].res[ch]) bands[i].scfi[ch] = getvlc2(&gb, scfivlc.table, MPC7SCFIBITS, 1); /* get scale indexes */ for(i = 0; i <= mb; i++){ for(ch = 0; ch < 2; ch++){ if(bands[i].res[ch]){ bands[i].scfidx[ch][2] = c->oldDSCF[ch][i]; bands[i].scfidx[ch][0] = getscaleidx(&gb, bands[i].scfidx[ch][2]); switch(bands[i].scfi[ch]){ case 0: bands[i].scfidx[ch][1] = getscaleidx(&gb, bands[i].scfidx[ch][0]); bands[i].scfidx[ch][2] = getscaleidx(&gb, bands[i].scfidx[ch][1]); break; case 1: bands[i].scfidx[ch][1] = getscaleidx(&gb, bands[i].scfidx[ch][0]); bands[i].scfidx[ch][2] = bands[i].scfidx[ch][1]; break; case 2: bands[i].scfidx[ch][1] = bands[i].scfidx[ch][0]; bands[i].scfidx[ch][2] = getscaleidx(&gb, bands[i].scfidx[ch][1]); break; case 3: bands[i].scfidx[ch][2] = bands[i].scfidx[ch][1] = bands[i].scfidx[ch][0]; break; } c->oldDSCF[ch][i] = bands[i].scfidx[ch][2]; } } } /* get quantizers */ memset(c->Q, 0, sizeof(c->Q)); off = 0; for(i = 0; i < BANDS; i++, off += SAMPLESPERBAND) for(ch = 0; ch < 2; ch++) idxtoquant(c, &gb, bands[i].res[ch], c->Q[ch] + off); ffmpcdequantizeandsynth(c, mb, c->frame.data[0], 2); bitsused = getbitscount(&gb); bitsavail = bufsize * 8; if (!lastframe && ((bitsavail < bitsused) || (bitsused + 32 <= bitsavail))) { avlog(avctx, AVLOGERROR, \"Error decoding frame: used %i of %i bits\\n\", bitsused, bitsavail); return -1; } if(c->framestoskip){ c->framestoskip--; *gotframeptr = 0; return avpkt->size; } *gotframeptr = 1; *(AVFrame *)data = c->frame; return avpkt->size; } ", "target": 0}
{"func": "static int rleunpack(const unsigned char *src, int srclen, int srccount, unsigned char *dest, int destlen) { const unsigned char *ps; const unsigned char *psend; unsigned char *pd; int i, l; unsigned char *destend = dest + destlen; ps = src; psend = src + srclen; pd = dest; if (srccount & 1) { if (psend - ps < 1) return 0; *pd++ = *ps++; } srccount >>= 1; i = 0; do { if (psend - ps < 1) break; l = *ps++; if (l & 0x80) { l = (l & 0x7F) * 2; if (pd + l > destend || psend - ps < l) return ps - src; memcpy(pd, ps, l); ps += l; pd += l; } else { if (pd + i > destend || psend - ps < 2) return ps - src; for (i = 0; i < l; i++) { *pd++ = ps[0]; *pd++ = ps[1]; } ps += 2; } i += l; } while (i < srccount); return ps - src; } ", "target": 1}
{"func": "int vc1decodesequenceheader(AVCodecContext *avctx, VC1Context *v, GetBitContext *gb) { avlog(avctx, AVLOGDEBUG, \"Header: %0X\\n\", showbits(gb, 32)); v->profile = getbits(gb, 2); if (v->profile == PROFILECOMPLEX) { avlog(avctx, AVLOGWARNING, \"WMV3 Complex Profile is not fully supported\\n\"); } if (v->profile == PROFILEADVANCED) { v->zz8x4 = ffvc1advprogressive8x4zz; v->zz4x8 = ffvc1advprogressive4x8zz; return decodesequenceheaderadv(v, gb); } else { v->zz8x4 = wmv2scantableA; v->zz4x8 = wmv2scantableB; v->resy411 = getbits1(gb); v->ressprite = getbits1(gb); if (v->resy411) { avlog(avctx, AVLOGERROR, \"Old interlaced mode is not supported\\n\"); return -1; } if (v->ressprite) { avlog(avctx, AVLOGERROR, \"WMVP is not fully supported\\n\"); } } // (fps-2)/4 (->30) v->frmrtqpostproc = getbits(gb, 3); //common // (bitrate-32kbps)/64kbps v->bitrtqpostproc = getbits(gb, 5); //common v->s.loopfilter = getbits1(gb); //common if(v->s.loopfilter == 1 && v->profile == PROFILESIMPLE) { avlog(avctx, AVLOGERROR, \"LOOPFILTER shall not be enabled in Simple Profile\\n\"); } if(v->s.avctx->skiploopfilter >= AVDISCARDALL) v->s.loopfilter = 0; v->resx8 = getbits1(gb); //reserved v->multires = getbits1(gb); v->resfasttx = getbits1(gb); if (!v->resfasttx) { v->vc1dsp.vc1invtrans8x8 = ffsimpleidct8; v->vc1dsp.vc1invtrans8x4 = ffsimpleidct84add; v->vc1dsp.vc1invtrans4x8 = ffsimpleidct48add; v->vc1dsp.vc1invtrans4x4 = ffsimpleidct44add; v->vc1dsp.vc1invtrans8x8dc = ffsimpleidctadd8; v->vc1dsp.vc1invtrans8x4dc = ffsimpleidct84add; v->vc1dsp.vc1invtrans4x8dc = ffsimpleidct48add; v->vc1dsp.vc1invtrans4x4dc = ffsimpleidct44add; } v->fastuvmc = getbits1(gb); //common if (!v->profile && !v->fastuvmc) { avlog(avctx, AVLOGERROR, \"FASTUVMC unavailable in Simple Profile\\n\"); return -1; } v->extendedmv = getbits1(gb); //common if (!v->profile && v->extendedmv) { avlog(avctx, AVLOGERROR, \"Extended MVs unavailable in Simple Profile\\n\"); return -1; } v->dquant = getbits(gb, 2); //common v->vstransform = getbits1(gb); //common v->restranstab = getbits1(gb); if (v->restranstab) { avlog(avctx, AVLOGERROR, \"1 for reserved RESTRANSTAB is forbidden\\n\"); return -1; } v->overlap = getbits1(gb); //common v->s.resyncmarker = getbits1(gb); v->rangered = getbits1(gb); if (v->rangered && v->profile == PROFILESIMPLE) { avlog(avctx, AVLOGINFO, \"RANGERED should be set to 0 in Simple Profile\\n\"); } v->s.maxbframes = avctx->maxbframes = getbits(gb, 3); //common v->quantizermode = getbits(gb, 2); //common v->finterpflag = getbits1(gb); //common if (v->ressprite) { v->s.avctx->width = v->s.avctx->codedwidth = getbits(gb, 11); v->s.avctx->height = v->s.avctx->codedheight = getbits(gb, 11); skipbits(gb, 5); //frame rate v->resx8 = getbits1(gb); if (getbits1(gb)) { // something to do with DC VLC selection avlog(avctx, AVLOGERROR, \"Unsupported sprite feature\\n\"); return -1; } skipbits(gb, 3); //slice code v->resrtmflag = 0; } else { v->resrtmflag = getbits1(gb); //reserved } if (!v->resrtmflag) { // avlog(avctx, AVLOGERROR, // \"0 for reserved RESRTMFLAG is forbidden\\n\"); avlog(avctx, AVLOGERROR, \"Old WMV3 version detected, some frames may be decoded incorrectly\\n\"); //return -1; } //TODO: figure out what they mean (always 0x402F) if(!v->resfasttx) skipbits(gb, 16); avlog(avctx, AVLOGDEBUG, \"Profile %i:\\nfrmrtqpostproc=%i, bitrtqpostproc=%i\\n\" \"LoopFilter=%i, MultiRes=%i, FastUVMC=%i, Extended MV=%i\\n\" \"Rangered=%i, VSTransform=%i, Overlap=%i, SyncMarker=%i\\n\" \"DQuant=%i, Quantizer mode=%i, Max B frames=%i\\n\", v->profile, v->frmrtqpostproc, v->bitrtqpostproc, v->s.loopfilter, v->multires, v->fastuvmc, v->extendedmv, v->rangered, v->vstransform, v->overlap, v->s.resyncmarker, v->dquant, v->quantizermode, avctx->maxbframes ); return 0; } ", "target": 1}
{"func": "static int s390virtiornginit(VirtIOS390Device *s390dev) { VirtIORNGS390 *dev = VIRTIORNGS390(s390dev); DeviceState *vdev = DEVICE(&dev->vdev); qdevsetparentbus(vdev, BUS(&s390dev->bus)); if (qdevinit(vdev) < 0) { return -1; } objectpropertysetlink(OBJECT(dev), OBJECT(dev->vdev.conf.defaultbackend), \"rng\", NULL); return s390virtiodeviceinit(s390dev, VIRTIODEVICE(vdev)); } ", "target": 1}
{"func": "static void apicupdateirq(APICState *s) { int irrv, ppr; if (!(s->spuriousvec & APICSVENABLE)) return; irrv = gethighestpriorityint(s->irr); if (irrv < 0) return; ppr = apicgetppr(s); if (ppr && (irrv & 0xf0) <= (ppr & 0xf0)) return; cpuinterrupt(s->cpuenv, CPUINTERRUPTHARD); } ", "target": 0}
{"func": "setupsigcontext(struct targetsigcontext *sc, struct targetfpstate *fpstate, \t\t CPUX86State *env, abiulong mask, abiulong fpstateaddr) { CPUState *cs = CPU(x86envgetcpu(env)); int err = 0; uint16t magic; \t/* already locked in setupframe() */ putuser(env->segs[RGS].selector, (unsigned int *)&sc->gs); putuser(env->segs[RFS].selector, (unsigned int *)&sc->fs); putuser(env->segs[RES].selector, (unsigned int *)&sc->es); putuser(env->segs[RDS].selector, (unsigned int *)&sc->ds); putuser(env->regs[REDI], &sc->edi); putuser(env->regs[RESI], &sc->esi); putuser(env->regs[REBP], &sc->ebp); putuser(env->regs[RESP], &sc->esp); putuser(env->regs[REBX], &sc->ebx); putuser(env->regs[REDX], &sc->edx); putuser(env->regs[RECX], &sc->ecx); putuser(env->regs[REAX], &sc->eax); putuser(cs->exceptionindex, &sc->trapno); putuser(env->errorcode, &sc->err); putuser(env->eip, &sc->eip); putuser(env->segs[RCS].selector, (unsigned int *)&sc->cs); putuser(env->eflags, &sc->eflags); putuser(env->regs[RESP], &sc->espatsignal); putuser(env->segs[RSS].selector, (unsigned int *)&sc->ss); cpux86fsave(env, fpstateaddr, 1); fpstate->status = fpstate->sw; magic = 0xffff; putuser(magic, &fpstate->magic); putuser(fpstateaddr, &sc->fpstate); \t/* non-iBCS2 extensions.. */ putuser(mask, &sc->oldmask); putuser(env->cr[2], &sc->cr2); \treturn err; } ", "target": 0}
{"func": "static void coroutinefn qedaiocomplete(QEDAIOCB *acb) { BDRVQEDState *s = acbtos(acb); /* Free resources */ qemuiovecdestroy(&acb->curqiov); qedunrefl2cacheentry(acb->request.l2table); /* Free the buffer we may have allocated for zero writes */ if (acb->flags & QEDAIOCBZERO) { qemuvfree(acb->qiov->iov[0].iovbase); acb->qiov->iov[0].iovbase = NULL; } /* Start next allocating write request waiting behind this one. Note that * requests enqueue themselves when they first hit an unallocated cluster * but they wait until the entire request is finished before waking up the * next request in the queue. This ensures that we don't cycle through * requests multiple times but rather finish one at a time completely. */ if (acb == s->allocatingacb) { s->allocatingacb = NULL; if (!qemucoqueueempty(&s->allocatingwritereqs)) { qemucoenternext(&s->allocatingwritereqs); } else if (s->header.features & QEDFNEEDCHECK) { qedstartneedchecktimer(s); } } } ", "target": 0}
{"func": "static bool vtddoiommutranslate(VTDAddressSpace *vtdas, PCIBus *bus, uint8t devfn, hwaddr addr, bool iswrite, IOMMUTLBEntry *entry) { IntelIOMMUState *s = vtdas->iommustate; VTDContextEntry ce; uint8t busnum = pcibusnum(bus); VTDContextCacheEntry *ccentry = &vtdas->contextcacheentry; uint64t slpte, pagemask; uint32t level; uint16t sourceid = vtdmakesourceid(busnum, devfn); int retfr; bool isfpdset = false; bool reads = true; bool writes = true; uint8t accessflags; VTDIOTLBEntry *iotlbentry; /* * We have standalone memory region for interrupt addresses, we * should never receive translation requests in this region. */ assert(!vtdisinterruptaddr(addr)); /* Try to fetch slpte form IOTLB */ iotlbentry = vtdlookupiotlb(s, sourceid, addr); if (iotlbentry) { tracevtdiotlbpagehit(sourceid, addr, iotlbentry->slpte, iotlbentry->domainid); slpte = iotlbentry->slpte; accessflags = iotlbentry->accessflags; pagemask = iotlbentry->mask; goto out; } /* Try to fetch context-entry from cache first */ if (ccentry->contextcachegen == s->contextcachegen) { tracevtdiotlbcchit(busnum, devfn, ccentry->contextentry.hi, ccentry->contextentry.lo, ccentry->contextcachegen); ce = ccentry->contextentry; isfpdset = ce.lo & VTDCONTEXTENTRYFPD; } else { retfr = vtddevtocontextentry(s, busnum, devfn, &ce); isfpdset = ce.lo & VTDCONTEXTENTRYFPD; if (retfr) { retfr = -retfr; if (isfpdset && vtdisqualifiedfault(retfr)) { tracevtdfaultdisabled(); } else { vtdreportdmarfault(s, sourceid, addr, retfr, iswrite); } goto error; } /* Update context-cache */ tracevtdiotlbccupdate(busnum, devfn, ce.hi, ce.lo, ccentry->contextcachegen, s->contextcachegen); ccentry->contextentry = ce; ccentry->contextcachegen = s->contextcachegen; } /* * We don't need to translate for pass-through context entries. * Also, let's ignore IOTLB caching as well for PT devices. */ if (vtdcegettype(&ce) == VTDCONTEXTTTPASSTHROUGH) { entry->iova = addr & VTDPAGEMASK4K; entry->translatedaddr = entry->iova; entry->addrmask = ~VTDPAGEMASK4K; entry->perm = IOMMURW; tracevtdtranslatept(sourceid, entry->iova); /* * When this happens, it means firstly caching-mode is not * enabled, and this is the first passthrough translation for * the device. Let's enable the fast path for passthrough. * * When passthrough is disabled again for the device, we can * capture it via the context entry invalidation, then the * IOMMU region can be swapped back. */ vtdptenablefastpath(s, sourceid); return true; } retfr = vtdiovatoslpte(&ce, addr, iswrite, &slpte, &level, &reads, &writes); if (retfr) { retfr = -retfr; if (isfpdset && vtdisqualifiedfault(retfr)) { tracevtdfaultdisabled(); } else { vtdreportdmarfault(s, sourceid, addr, retfr, iswrite); } goto error; } pagemask = vtdslptlevelpagemask(level); accessflags = IOMMUACCESSFLAG(reads, writes); vtdupdateiotlb(s, sourceid, VTDCONTEXTENTRYDID(ce.hi), addr, slpte, accessflags, level); out: entry->iova = addr & pagemask; entry->translatedaddr = vtdgetslpteaddr(slpte) & pagemask; entry->addrmask = ~pagemask; entry->perm = accessflags; return true; error: entry->iova = 0; entry->translatedaddr = 0; entry->addrmask = 0; entry->perm = IOMMUNONE; return false; } ", "target": 0}
{"func": "int loadmultiboot(void *fwcfg, FILE *f, const char *kernelfilename, const char *initrdfilename, const char *kernelcmdline, int kernelfilesize, uint8t *header) { int i, ismultiboot = 0; uint32t flags = 0; uint32t mhentryaddr; uint32t mhloadaddr; uint32t mbkernelsize; MultibootState mbs; uint8t bootinfo[MBISIZE]; uint8t *mbbootinfodata; /* Ok, let's see if it is a multiboot image. The header is 12x32bit long, so the latest entry may be 8192 - 48. */ for (i = 0; i < (8192 - 48); i += 4) { if (ldlp(header+i) == 0x1BADB002) { uint32t checksum = ldlp(header+i+8); flags = ldlp(header+i+4); checksum += flags; checksum += (uint32t)0x1BADB002; if (!checksum) { ismultiboot = 1; break; } } } if (!ismultiboot) return 0; /* no multiboot */ mbdebug(\"qemu: I believe we found a multiboot image!\\n\"); memset(bootinfo, 0, sizeof(bootinfo)); memset(&mbs, 0, sizeof(mbs)); if (flags & 0x00000004) { /* MULTIBOOTHEADERHASVBE */ fprintf(stderr, \"qemu: multiboot knows VBE. we don't.\\n\"); } if (!(flags & 0x00010000)) { /* MULTIBOOTHEADERHASADDR */ uint64t elfentry; uint64t elflow, elfhigh; int kernelsize; fclose(f); if (((struct elf64hdr*)header)->emachine == EMX8664) { fprintf(stderr, \"Cannot load x86-64 image, give a 32bit one.\\n\"); exit(1); } kernelsize = loadelf(kernelfilename, NULL, NULL, &elfentry, &elflow, &elfhigh, 0, ELFMACHINE, 0); if (kernelsize < 0) { fprintf(stderr, \"Error while loading elf kernel\\n\"); exit(1); } mhloadaddr = elflow; mbkernelsize = elfhigh - elflow; mhentryaddr = elfentry; mbs.mbbuf = gmalloc(mbkernelsize); if (romcopy(mbs.mbbuf, mhloadaddr, mbkernelsize) != mbkernelsize) { fprintf(stderr, \"Error while fetching elf kernel from rom\\n\"); exit(1); } mbdebug(\"qemu: loading multiboot-elf kernel (%#x bytes) with entry %#zx\\n\", mbkernelsize, (sizet)mhentryaddr); } else { /* Valid if mhflags sets MULTIBOOTHEADERHASADDR. */ uint32t mhheaderaddr = ldlp(header+i+12); uint32t mhloadendaddr = ldlp(header+i+20); uint32t mhbssendaddr = ldlp(header+i+24); mhloadaddr = ldlp(header+i+16); uint32t mbkerneltextoffset = i - (mhheaderaddr - mhloadaddr); uint32t mbloadsize = 0; mhentryaddr = ldlp(header+i+28); if (mhloadendaddr) { mbkernelsize = mhbssendaddr - mhloadaddr; mbloadsize = mhloadendaddr - mhloadaddr; } else { mbkernelsize = kernelfilesize - mbkerneltextoffset; mbloadsize = mbkernelsize; } /* Valid if mhflags sets MULTIBOOTHEADERHASVBE. uint32t mhmodetype = ldlp(header+i+32); uint32t mhwidth = ldlp(header+i+36); uint32t mhheight = ldlp(header+i+40); uint32t mhdepth = ldlp(header+i+44); */ mbdebug(\"multiboot: mhheaderaddr = %#x\\n\", mhheaderaddr); mbdebug(\"multiboot: mhloadaddr = %#x\\n\", mhloadaddr); mbdebug(\"multiboot: mhloadendaddr = %#x\\n\", mhloadendaddr); mbdebug(\"multiboot: mhbssendaddr = %#x\\n\", mhbssendaddr); mbdebug(\"qemu: loading multiboot kernel (%#x bytes) at %#x\\n\", mbloadsize, mhloadaddr); mbs.mbbuf = gmalloc(mbkernelsize); fseek(f, mbkerneltextoffset, SEEKSET); if (fread(mbs.mbbuf, 1, mbloadsize, f) != mbloadsize) { fprintf(stderr, \"fread() failed\\n\"); exit(1); } memset(mbs.mbbuf + mbloadsize, 0, mbkernelsize - mbloadsize); fclose(f); } mbs.mbbufphys = mhloadaddr; mbs.mbbufsize = TARGETPAGEALIGN(mbkernelsize); mbs.offsetmbinfo = mbs.mbbufsize; /* Calculate space for cmdlines and mbmods */ mbs.mbbufsize += strlen(kernelfilename) + 1; mbs.mbbufsize += strlen(kernelcmdline) + 1; if (initrdfilename) { const char *r = initrdfilename; mbs.mbbufsize += strlen(r) + 1; mbs.mbmodsavail = 1; while (*(r = getoptvalue(NULL, 0, r))) { mbs.mbmodsavail++; r++; } mbs.mbbufsize += MBMODSIZE * mbs.mbmodsavail; } mbs.mbbufsize = TARGETPAGEALIGN(mbs.mbbufsize); /* enlarge mbbuf to hold cmdlines and mb-info structs */ mbs.mbbuf = grealloc(mbs.mbbuf, mbs.mbbufsize); mbs.offsetcmdlines = mbs.offsetmbinfo + mbs.mbmodsavail * MBMODSIZE; if (initrdfilename) { char *nextinitrd, notlast; mbs.offsetmods = mbs.mbbufsize; do { char *nextspace; int mbmodlength; uint32t offs = mbs.mbbufsize; nextinitrd = (char *)getoptvalue(NULL, 0, initrdfilename); notlast = *nextinitrd; *nextinitrd = '\\0'; /* if a space comes after the module filename, treat everything after that as parameters */ targetphysaddrt c = mbaddcmdline(&mbs, initrdfilename); if ((nextspace = strchr(initrdfilename, ' '))) *nextspace = '\\0'; mbdebug(\"multiboot loading module: %s\\n\", initrdfilename); mbmodlength = getimagesize(initrdfilename); if (mbmodlength < 0) { fprintf(stderr, \"Failed to open file '%s'\\n\", initrdfilename); exit(1); } mbs.mbbufsize = TARGETPAGEALIGN(mbmodlength + mbs.mbbufsize); mbs.mbbuf = grealloc(mbs.mbbuf, mbs.mbbufsize); loadimage(initrdfilename, (unsigned char *)mbs.mbbuf + offs); mbaddmod(&mbs, mbs.mbbufphys + offs, mbs.mbbufphys + offs + mbmodlength, c); mbdebug(\"modstart: %p\\nmodend: %p\\n cmdline: \"TARGETFMTplx\"\\n\", (char *)mbs.mbbuf + offs, (char *)mbs.mbbuf + offs + mbmodlength, c); initrdfilename = nextinitrd+1; } while (notlast); } /* Commandline support */ char kcmdline[strlen(kernelfilename) + strlen(kernelcmdline) + 2]; snprintf(kcmdline, sizeof(kcmdline), \"%s %s\", kernelfilename, kernelcmdline); stlp(bootinfo + MBICMDLINE, mbaddcmdline(&mbs, kcmdline)); stlp(bootinfo + MBIMODSADDR, mbs.mbbufphys + mbs.offsetmbinfo); stlp(bootinfo + MBIMODSCOUNT, mbs.mbmodscount); /* modscount */ /* the kernel is where we want it to be now */ stlp(bootinfo + MBIFLAGS, MULTIBOOTFLAGSMEMORY | MULTIBOOTFLAGSBOOTDEVICE | MULTIBOOTFLAGSCMDLINE | MULTIBOOTFLAGSMODULES | MULTIBOOTFLAGSMMAP); stlp(bootinfo + MBIMEMLOWER, 640); stlp(bootinfo + MBIMEMUPPER, (ramsize / 1024) - 1024); stlp(bootinfo + MBIBOOTDEVICE, 0x8000ffff); /* XXX: use the -boot switch? */ stlp(bootinfo + MBIMMAPADDR, ADDRE820MAP); mbdebug(\"multiboot: mhentryaddr = %#x\\n\", mhentryaddr); mbdebug(\" mbbufphys = \"TARGETFMTplx\"\\n\", mbs.mbbufphys); mbdebug(\" modstart = \"TARGETFMTplx\"\\n\", mbs.mbbufphys + mbs.offsetmods); mbdebug(\" mbmodscount = %d\\n\", mbs.mbmodscount); /* save bootinfo off the stack */ mbbootinfodata = gmalloc(sizeof(bootinfo)); memcpy(mbbootinfodata, bootinfo, sizeof(bootinfo)); /* Pass variables to option rom */ fwcfgaddi32(fwcfg, FWCFGKERNELENTRY, mhentryaddr); fwcfgaddi32(fwcfg, FWCFGKERNELADDR, mhloadaddr); fwcfgaddi32(fwcfg, FWCFGKERNELSIZE, mbs.mbbufsize); fwcfgaddbytes(fwcfg, FWCFGKERNELDATA, mbs.mbbuf, mbs.mbbufsize); fwcfgaddi32(fwcfg, FWCFGINITRDADDR, ADDRMBI); fwcfgaddi32(fwcfg, FWCFGINITRDSIZE, sizeof(bootinfo)); fwcfgaddbytes(fwcfg, FWCFGINITRDDATA, mbbootinfodata, sizeof(bootinfo)); optionrom[nboptionroms].name = \"multiboot.bin\"; optionrom[nboptionroms].bootindex = 0; nboptionroms++; return 1; /* yes, we are multiboot */ } ", "target": 0}
{"func": "static void FUNC(hevchloopfilterluma)(uint8t *pix, ptrdifft stride, int *beta, int *tc, uint8t *nop, uint8t *noq) { FUNC(hevcloopfilterluma)(pix, stride, sizeof(pixel), beta, tc, nop, noq); } ", "target": 0}
{"func": "static void tcgoutbrcond(TCGContext *s, TCGMemOp ext, TCGCond c, TCGArg a, TCGArg b, bool bconst, TCGLabel *l) { intptrt offset; bool needcmp; if (bconst && b == 0 && (c == TCGCONDEQ || c == TCGCONDNE)) { needcmp = false; } else { needcmp = true; tcgoutcmp(s, ext, a, b, bconst); } if (!l->hasvalue) { tcgoutreloc(s, s->codeptr, RAARCH64CONDBR19, l, 0); offset = tcgin32(s) >> 5; } else { offset = l->u.valueptr - s->codeptr; assert(offset == sextract64(offset, 0, 19)); } if (needcmp) { tcgoutinsn(s, 3202, BC, c, offset); } else if (c == TCGCONDEQ) { tcgoutinsn(s, 3201, CBZ, ext, a, offset); } else { tcgoutinsn(s, 3201, CBNZ, ext, a, offset); } } ", "target": 0}
{"func": "static int nbdnegotiateoptions(NBDClient *client, Error **errp) { uint32t flags; bool fixedNewstyle = false; /* Client sends: [ 0 .. 3] client flags [ 0 .. 7] NBDOPTSMAGIC [ 8 .. 11] NBD option [12 .. 15] Data length ... Rest of request [ 0 .. 7] NBDOPTSMAGIC [ 8 .. 11] Second NBD option [12 .. 15] Data length ... Rest of request */ if (nbdread(client->ioc, &flags, sizeof(flags), errp) < 0) { errorprepend(errp, \"read failed: \"); return -EIO; } tracenbdnegotiateoptionsflags(); be32tocpus(&flags); if (flags & NBDFLAGCFIXEDNEWSTYLE) { tracenbdnegotiateoptionsnewstyle(); fixedNewstyle = true; flags &= ~NBDFLAGCFIXEDNEWSTYLE; } if (flags & NBDFLAGCNOZEROES) { tracenbdnegotiateoptionsnozeroes(); client->nozeroes = true; flags &= ~NBDFLAGCNOZEROES; } if (flags != 0) { errorsetg(errp, \"Unknown client flags 0x%\" PRIx32 \" received\", flags); return -EIO; } while (1) { int ret; uint32t option, length; uint64t magic; if (nbdread(client->ioc, &magic, sizeof(magic), errp) < 0) { errorprepend(errp, \"read failed: \"); return -EINVAL; } magic = be64tocpu(magic); tracenbdnegotiateoptionscheckmagic(magic); if (magic != NBDOPTSMAGIC) { errorsetg(errp, \"Bad magic received\"); return -EINVAL; } if (nbdread(client->ioc, &option, sizeof(option), errp) < 0) { errorprepend(errp, \"read failed: \"); return -EINVAL; } option = be32tocpu(option); if (nbdread(client->ioc, &length, sizeof(length), errp) < 0) { errorprepend(errp, \"read failed: \"); return -EINVAL; } length = be32tocpu(length); tracenbdnegotiateoptionscheckoption(option); if (client->tlscreds && client->ioc == (QIOChannel *)client->sioc) { QIOChannel *tioc; if (!fixedNewstyle) { errorsetg(errp, \"Unsupported option 0x%\" PRIx32, option); return -EINVAL; } switch (option) { case NBDOPTSTARTTLS: tioc = nbdnegotiatehandlestarttls(client, length, errp); if (!tioc) { return -EIO; } objectunref(OBJECT(client->ioc)); client->ioc = QIOCHANNEL(tioc); break; case NBDOPTEXPORTNAME: /* No way to return an error to client, so drop connection */ errorsetg(errp, \"Option 0x%x not permitted before TLS\", option); return -EINVAL; default: if (nbddrop(client->ioc, length, errp) < 0) { return -EIO; } ret = nbdnegotiatesendreperr(client->ioc, NBDREPERRTLSREQD, option, errp, \"Option 0x%\" PRIx32 \"not permitted before TLS\", option); if (ret < 0) { return ret; } /* Let the client keep trying, unless they asked to * quit. In this mode, we've already sent an error, so * we can't ack the abort. */ if (option == NBDOPTABORT) { return 1; } break; } } else if (fixedNewstyle) { switch (option) { case NBDOPTLIST: ret = nbdnegotiatehandlelist(client, length, errp); if (ret < 0) { return ret; } break; case NBDOPTABORT: /* NBD spec says we must try to reply before * disconnecting, but that we must also tolerate * guests that don't wait for our reply. */ nbdnegotiatesendrep(client->ioc, NBDREPACK, option, NULL); return 1; case NBDOPTEXPORTNAME: return nbdnegotiatehandleexportname(client, length, errp); case NBDOPTSTARTTLS: if (nbddrop(client->ioc, length, errp) < 0) { return -EIO; } if (client->tlscreds) { ret = nbdnegotiatesendreperr(client->ioc, NBDREPERRINVALID, option, errp, \"TLS already enabled\"); } else { ret = nbdnegotiatesendreperr(client->ioc, NBDREPERRPOLICY, option, errp, \"TLS not configured\"); } if (ret < 0) { return ret; } break; default: if (nbddrop(client->ioc, length, errp) < 0) { return -EIO; } ret = nbdnegotiatesendreperr(client->ioc, NBDREPERRUNSUP, option, errp, \"Unsupported option 0x%\" PRIx32, option); if (ret < 0) { return ret; } break; } } else { /* * If broken new-style we should drop the connection * for anything except NBDOPTEXPORTNAME */ switch (option) { case NBDOPTEXPORTNAME: return nbdnegotiatehandleexportname(client, length, errp); default: errorsetg(errp, \"Unsupported option 0x%\" PRIx32, option); return -EINVAL; } } } } ", "target": 0}
{"func": "static void pl181fiforun(pl181state *s) { uint32t bits; uint32t value; int n; int isread; isread = (s->datactrl & PL181DATADIRECTION) != 0; if (s->datacnt != 0 && (!isread || sddataready(s->card)) && !s->linuxhack) { if (isread) { n = 0; value = 0; while (s->datacnt && s->fifolen < PL181FIFOLEN) { value |= (uint32t)sdreaddata(s->card) << (n * 8); s->datacnt--; n++; if (n == 4) { pl181fifopush(s, value); n = 0; value = 0; } } if (n != 0) { pl181fifopush(s, value); } } else { /* write */ n = 0; while (s->datacnt > 0 && (s->fifolen > 0 || n > 0)) { if (n == 0) { value = pl181fifopop(s); n = 4; } n--; s->datacnt--; sdwritedata(s->card, value & 0xff); value >>= 8; } } } s->status &= ~(PL181STATUSRXFIFO | PL181STATUSTXFIFO); if (s->datacnt == 0) { s->status |= PL181STATUSDATAEND; /* HACK: */ s->status |= PL181STATUSDATABLOCKEND; DPRINTF(\"Transfer Complete\\n\"); } if (s->datacnt == 0 && s->fifolen == 0) { s->datactrl &= ~PL181DATAENABLE; DPRINTF(\"Data engine idle\\n\"); } else { /* Update FIFO bits. */ bits = PL181STATUSTXACTIVE | PL181STATUSRXACTIVE; if (s->fifolen == 0) { bits |= PL181STATUSTXFIFOEMPTY; bits |= PL181STATUSRXFIFOEMPTY; } else { bits |= PL181STATUSTXDATAAVLBL; bits |= PL181STATUSRXDATAAVLBL; } if (s->fifolen == 16) { bits |= PL181STATUSTXFIFOFULL; bits |= PL181STATUSRXFIFOFULL; } if (s->fifolen <= 8) { bits |= PL181STATUSTXFIFOHALFEMPTY; } if (s->fifolen >= 8) { bits |= PL181STATUSRXFIFOHALFFULL; } if (s->datactrl & PL181DATADIRECTION) { bits &= PL181STATUSRXFIFO; } else { bits &= PL181STATUSTXFIFO; } s->status |= bits; } } ", "target": 1}
{"func": "static int flvreadmetabody(AVFormatContext *s, int64t nextpos) { AMFDataType type; AVStream *stream, *astream, *vstream; AVIOContext *ioc; int i; // only needs to hold the string \"onMetaData\". // Anything longer is something we don't want. char buffer[11]; astream = NULL; vstream = NULL; ioc = s->pb; // first object needs to be \"onMetaData\" string type = avior8(ioc); if (type != AMFDATATYPESTRING || amfgetstring(ioc, buffer, sizeof(buffer)) < 0) return -1; if (!strcmp(buffer, \"onTextData\")) return 1; if (strcmp(buffer, \"onMetaData\")) return -1; // find the streams now so that amfparseobject doesn't need to do // the lookup every time it is called. for (i = 0; i < s->nbstreams; i++) { stream = s->streams[i]; if (stream->codec->codectype == AVMEDIATYPEAUDIO) astream = stream; else if (stream->codec->codectype == AVMEDIATYPEVIDEO) vstream = stream; } // parse the second object (we want a mixed array) if (amfparseobject(s, astream, vstream, buffer, nextpos, 0) < 0) return -1; return 0; } ", "target": 0}
{"func": "static void mptsasscsiinit(PCIDevice *dev, Error **errp) { DeviceState *d = DEVICE(dev); MPTSASState *s = MPTSAS(dev); Error *err = NULL; int ret; dev->config[PCILATENCYTIMER] = 0; dev->config[PCIINTERRUPTPIN] = 0x01; if (s->msi != ONOFFAUTOOFF) { ret = msiinit(dev, 0, 1, true, false, &err); /* Any error other than -ENOTSUP(board's MSI support is broken) * is a programming error */ assert(!ret || ret == -ENOTSUP); if (ret && s->msi == ONOFFAUTOON) { /* Can't satisfy user's explicit msi=on request, fail */ errorappendhint(&err, \"You have to use msi=auto (default) or \" \"msi=off with this machine type.\\n\"); errorpropagate(errp, err); s->msiinuse = false; return; } else if (ret) { /* With msi=auto, we fall back to MSI off silently */ errorfree(err); s->msiinuse = false; } else { s->msiinuse = true; } } memoryregioninitio(&s->mmioio, OBJECT(s), &mptsasmmioops, s, \"mptsas-mmio\", 0x4000); memoryregioninitio(&s->portio, OBJECT(s), &mptsasportops, s, \"mptsas-io\", 256); memoryregioninitio(&s->diagio, OBJECT(s), &mptsasdiagops, s, \"mptsas-diag\", 0x10000); pciregisterbar(dev, 0, PCIBASEADDRESSSPACEIO, &s->portio); pciregisterbar(dev, 1, PCIBASEADDRESSSPACEMEMORY | PCIBASEADDRESSMEMTYPE32, &s->mmioio); pciregisterbar(dev, 2, PCIBASEADDRESSSPACEMEMORY | PCIBASEADDRESSMEMTYPE32, &s->diagio); if (!s->sasaddr) { s->sasaddr = ((NAALOCALLYASSIGNEDID << 24) | IEEECOMPANYLOCALLYASSIGNED) << 36; s->sasaddr |= (pcibusnum(dev->bus) << 16); s->sasaddr |= (PCISLOT(dev->devfn) << 8); s->sasaddr |= PCIFUNC(dev->devfn); } s->maxdevices = MPTSASNUMPORTS; s->requestbh = qemubhnew(mptsasfetchrequests, s); QTAILQINIT(&s->pending); scsibusnew(&s->bus, sizeof(s->bus), &dev->qdev, &mptsasscsiinfo, NULL); if (!d->hotplugged) { scsibuslegacyhandlecmdline(&s->bus, errp); } } ", "target": 0}
{"func": "static void kvmarmgicrealize(DeviceState *dev, Error **errp) { int i; GICState *s = KVMARMGIC(dev); SysBusDevice *sbd = SYSBUSDEVICE(dev); KVMARMGICClass *kgc = KVMARMGICGETCLASS(s); kgc->parentrealize(dev, errp); if (errorisset(errp)) { return; } i = s->numirq - GICINTERNAL; /* For the GIC, also expose incoming GPIO lines for PPIs for each CPU. * GPIO array layout is thus: * [0..N-1] SPIs * [N..N+31] PPIs for CPU 0 * [N+32..N+63] PPIs for CPU 1 * ... */ i += (GICINTERNAL * s->numcpu); qdevinitgpioin(dev, kvmarmgicsetirq, i); /* We never use our outbound IRQ lines but provide them so that * we maintain the same interface as the non-KVM GIC. */ for (i = 0; i < s->numcpu; i++) { sysbusinitirq(sbd, &s->parentirq[i]); } /* Distributor */ memoryregioninitreservation(&s->iomem, OBJECT(s), \"kvm-gicdist\", 0x1000); sysbusinitmmio(sbd, &s->iomem); kvmarmregisterdevice(&s->iomem, (KVMARMDEVICEVGICV2 << KVMARMDEVICEIDSHIFT) | KVMVGICV2ADDRTYPEDIST); /* CPU interface for current core. Unlike armgic, we don't * provide the \"interface for core #N\" memory regions, because * cores with a VGIC don't have those. */ memoryregioninitreservation(&s->cpuiomem[0], OBJECT(s), \"kvm-giccpu\", 0x1000); sysbusinitmmio(sbd, &s->cpuiomem[0]); kvmarmregisterdevice(&s->cpuiomem[0], (KVMARMDEVICEVGICV2 << KVMARMDEVICEIDSHIFT) | KVMVGICV2ADDRTYPECPU); } ", "target": 0}
{"func": "static int writefragments(struct Tracks *tracks, int startindex, AVIOContext *in) { char dirname[100], filename[500]; int i, j; for (i = startindex; i < tracks->nbtracks; i++) { struct Track *track = tracks->tracks[i]; const char *type = track->isvideo ? \"video\" : \"audio\"; snprintf(dirname, sizeof(dirname), \"QualityLevels(%d)\", track->bitrate); mkdir(dirname, 0777); for (j = 0; j < track->chunks; j++) { snprintf(filename, sizeof(filename), \"%s/Fragments(%s=%\"PRId64\")\", dirname, type, track->offsets[j].time); avioseek(in, track->offsets[j].offset, SEEKSET); writefragment(filename, in); } } return 0; } ", "target": 0}
{"func": "char *qemufindfile(int type, const char *name) { int len; const char *subdir; char *buf; /* If name contains path separators then try it as a straight path. */ if ((strchr(name, '/') || strchr(name, '\\\\')) && access(name, ROK) == 0) { return gstrdup(name); } switch (type) { case QEMUFILETYPEBIOS: subdir = \"\"; break; case QEMUFILETYPEKEYMAP: subdir = \"keymaps/\"; break; default: abort(); } len = strlen(datadir) + strlen(name) + strlen(subdir) + 2; buf = gmalloc0(len); snprintf(buf, len, \"%s/%s%s\", datadir, subdir, name); if (access(buf, ROK)) { gfree(buf); return NULL; } return buf; } ", "target": 0}
{"func": "void termflush(void) { } ", "target": 0}
{"func": "static uint64t elcrioportread(void *opaque, targetphysaddrt addr, unsigned size) { PICCommonState *s = opaque; return s->elcr; } ", "target": 0}
{"func": "static int increfcounts(BlockDriverState *bs, BdrvCheckResult *res, uint16t *refcounttable, int64t refcounttablesize, int64t offset, int64t size) { BDRVQcowState *s = bs->opaque; uint64t start, last, clusteroffset, k; if (size <= 0) { return 0; } start = startofcluster(s, offset); last = startofcluster(s, offset + size - 1); for(clusteroffset = start; clusteroffset <= last; clusteroffset += s->clustersize) { k = clusteroffset >> s->clusterbits; if (k >= refcounttablesize) { fprintf(stderr, \"Warning: cluster offset=0x%\" PRIx64 \" is after \" \"the end of the image file, can't properly check refcounts.\\n\", clusteroffset); res->checkerrors++; } else { if (++refcounttable[k] == 0) { fprintf(stderr, \"ERROR: overflow cluster offset=0x%\" PRIx64 \"\\n\", clusteroffset); res->corruptions++; } } } return 0; } ", "target": 0}
{"func": "static int nbdcorequest(BlockDriverState *bs, NBDRequest *request, QEMUIOVector *qiov) { NBDClientSession *client = nbdgetclientsession(bs); int ret; if (qiov) { assert(request->type == NBDCMDWRITE || request->type == NBDCMDREAD); assert(request->len == iovsize(qiov->iov, qiov->niov)); } else { assert(request->type != NBDCMDWRITE && request->type != NBDCMDREAD); } ret = nbdcosendrequest(bs, request, request->type == NBDCMDWRITE ? qiov : NULL); if (ret < 0) { return ret; } return nbdcoreceivereply(client, request->handle, request->type == NBDCMDREAD ? qiov : NULL); } ", "target": 1}
{"func": "static ExitStatus translog(DisasContext *ctx, uint32t insn, const DisasInsn *di) { unsigned r2 = extract32(insn, 21, 5); unsigned r1 = extract32(insn, 16, 5); unsigned cf = extract32(insn, 12, 4); unsigned rt = extract32(insn, 0, 5); TCGv tcgr1, tcgr2; ExitStatus ret; if (cf) { nullifyover(ctx); } tcgr1 = loadgpr(ctx, r1); tcgr2 = loadgpr(ctx, r2); ret = dolog(ctx, rt, tcgr1, tcgr2, cf, di->fttt); return nullifyend(ctx, ret); } ", "target": 1}
{"func": "static avalwaysinline void xchgmbborder(H264Context *h, uint8t *srcy, uint8t *srccb, uint8t *srccr, int linesize, int uvlinesize, int xchg, int chroma444, int simple, int pixelshift) { int deblocktopleft; int deblocktop; int topidx = 1; uint8t *topborderm1; uint8t *topborder; if (!simple && FRAMEMBAFF(h)) { if (h->mby & 1) { if (!MBMBAFF(h)) return; } else { topidx = MBMBAFF(h) ? 0 : 1; } } if (h->deblockingfilter == 2) { deblocktopleft = h->slicetable[h->mbxy - 1 - h->mbstride] == h->slicenum; deblocktop = h->toptype; } else { deblocktopleft = (h->mbx > 0); deblocktop = (h->mby > !!MBFIELD(h)); } srcy -= linesize + 1 + pixelshift; srccb -= uvlinesize + 1 + pixelshift; srccr -= uvlinesize + 1 + pixelshift; topborderm1 = h->topborders[topidx][h->mbx - 1]; topborder = h->topborders[topidx][h->mbx]; #define XCHG(a, b, xchg) \\ if (pixelshift) { \\ if (xchg) { \\ AVSWAP64(b + 0, a + 0); \\ AVSWAP64(b + 8, a + 8); \\ } else { \\ AVCOPY128(b, a); \\ } \\ } else if (xchg) \\ AVSWAP64(b, a); \\ else \\ AVCOPY64(b, a); if (deblocktop) { if (deblocktopleft) { XCHG(topborderm1 + (8 << pixelshift), srcy - (7 << pixelshift), 1); } XCHG(topborder + (0 << pixelshift), srcy + (1 << pixelshift), xchg); XCHG(topborder + (8 << pixelshift), srcy + (9 << pixelshift), 1); if (h->mbx + 1 < h->mbwidth) { XCHG(h->topborders[topidx][h->mbx + 1], srcy + (17 << pixelshift), 1); } } if (simple || !CONFIGGRAY || !(h->flags & CODECFLAGGRAY)) { if (chroma444) { if (deblocktopleft) { XCHG(topborderm1 + (24 << pixelshift), srccb - (7 << pixelshift), 1); XCHG(topborderm1 + (40 << pixelshift), srccr - (7 << pixelshift), 1); } XCHG(topborder + (16 << pixelshift), srccb + (1 << pixelshift), xchg); XCHG(topborder + (24 << pixelshift), srccb + (9 << pixelshift), 1); XCHG(topborder + (32 << pixelshift), srccr + (1 << pixelshift), xchg); XCHG(topborder + (40 << pixelshift), srccr + (9 << pixelshift), 1); if (h->mbx + 1 < h->mbwidth) { XCHG(h->topborders[topidx][h->mbx + 1] + (16 << pixelshift), srccb + (17 << pixelshift), 1); XCHG(h->topborders[topidx][h->mbx + 1] + (32 << pixelshift), srccr + (17 << pixelshift), 1); } } else { if (deblocktop) { if (deblocktopleft) { XCHG(topborderm1 + (16 << pixelshift), srccb - (7 << pixelshift), 1); XCHG(topborderm1 + (24 << pixelshift), srccr - (7 << pixelshift), 1); } XCHG(topborder + (16 << pixelshift), srccb + 1 + pixelshift, 1); XCHG(topborder + (24 << pixelshift), srccr + 1 + pixelshift, 1); } } } } ", "target": 0}
{"func": "static int gifimagewriteimage(AVCodecContext *avctx, uint8t **bytestream, uint8t *end, const uint8t *buf, int linesize) { GIFContext *s = avctx->privdata; int len, height; const uint8t *ptr; /* image block */ bytestreamputbyte(bytestream, 0x2c); bytestreamputle16(bytestream, 0); bytestreamputle16(bytestream, 0); bytestreamputle16(bytestream, avctx->width); bytestreamputle16(bytestream, avctx->height); bytestreamputbyte(bytestream, 0x00); /* flags */ /* no local clut */ bytestreamputbyte(bytestream, 0x08); fflzwencodeinit(s->lzw, s->buf, avctx->width*avctx->height, 12, FFLZWGIF, putbits); ptr = buf; for (height = avctx->height; height--;) { len += fflzwencode(s->lzw, ptr, avctx->width); ptr += linesize; } len += fflzwencodeflush(s->lzw, flushputbits); ptr = s->buf; while (len > 0) { int size = FFMIN(255, len); bytestreamputbyte(bytestream, size); if (end - *bytestream < size) return -1; bytestreamputbuffer(bytestream, ptr, size); ptr += size; len -= size; } bytestreamputbyte(bytestream, 0x00); /* end of image block */ bytestreamputbyte(bytestream, 0x3b); return 0; } ", "target": 1}
{"func": "static int movwritestbltag(AVIOContext *pb, MOVTrack *track) { int64t pos = aviotell(pb); aviowb32(pb, 0); /* size */ ffiowfourcc(pb, \"stbl\"); movwritestsdtag(pb, track); movwritesttstag(pb, track); if ((track->enc->codectype == AVMEDIATYPEVIDEO || track->enc->codectag == MKTAG('r','t','p',' ')) && track->haskeyframes && track->haskeyframes < track->entry) movwritestsstag(pb, track, MOVSYNCSAMPLE); if (track->mode == MODEMOV && track->flags & MOVTRACKSTPS) movwritestsstag(pb, track, MOVPARTIALSYNCSAMPLE); if (track->enc->codectype == AVMEDIATYPEVIDEO && track->flags & MOVTRACKCTTS && track->entry) movwritecttstag(pb, track); movwritestsctag(pb, track); movwritestsztag(pb, track); movwritestcotag(pb, track); return updatesize(pb, pos); } ", "target": 1}
{"func": "uint64t qcow2getclusteroffset(BlockDriverState *bs, uint64t offset, int *num) { BDRVQcowState *s = bs->opaque; int l1index, l2index; uint64t l2offset, *l2table, clusteroffset; int l1bits, c; int indexincluster, nbavailable, nbneeded, nbclusters; indexincluster = (offset >> 9) & (s->clustersectors - 1); nbneeded = *num + indexincluster; l1bits = s->l2bits + s->clusterbits; /* compute how many bytes there are between the offset and * the end of the l1 entry */ nbavailable = (1 << l1bits) - (offset & ((1 << l1bits) - 1)); /* compute the number of available sectors */ nbavailable = (nbavailable >> 9) + indexincluster; if (nbneeded > nbavailable) { nbneeded = nbavailable; } clusteroffset = 0; /* seek the the l2 offset in the l1 table */ l1index = offset >> l1bits; if (l1index >= s->l1size) goto out; l2offset = s->l1table[l1index]; /* seek the l2 table of the given l2 offset */ if (!l2offset) goto out; /* load the l2 table in memory */ l2offset &= ~QCOWOFLAGCOPIED; l2table = l2load(bs, l2offset); if (l2table == NULL) return 0; /* find the cluster offset for the given disk offset */ l2index = (offset >> s->clusterbits) & (s->l2size - 1); clusteroffset = be64tocpu(l2table[l2index]); nbclusters = sizetoclusters(s, nbneeded << 9); if (!clusteroffset) { /* how many empty clusters ? */ c = countcontiguousfreeclusters(nbclusters, &l2table[l2index]); } else { /* how many allocated clusters ? */ c = countcontiguousclusters(nbclusters, s->clustersize, &l2table[l2index], 0, QCOWOFLAGCOPIED); } nbavailable = (c * s->clustersectors); out: if (nbavailable > nbneeded) nbavailable = nbneeded; *num = nbavailable - indexincluster; return clusteroffset & ~QCOWOFLAGCOPIED; } ", "target": 1}
{"func": "static inline int RENAME(yuv420rgb16)(SwsContext *c, uint8t* src[], int srcStride[], int srcSliceY, int srcSliceH, uint8t* dst[], int dstStride[]){ int y, hsize; if(c->srcFormat == PIXFMTYUV422P){ \tsrcStride[1] *= 2; \tsrcStride[2] *= 2; } hsize= (c->dstW+7)&~7; if(hsize*2 > FFABS(dstStride[0])) hsize-=8; asm volatile (\"pxor %mm4, %mm4;\" /* zero mm4 */ ); //printf(\"%X %X %X %X %X %X %X %X %X %X\\n\", (int)&c->redDither, (int)&b5Dither, (int)src[0], (int)src[1], (int)src[2], (int)dst[0], //srcStride[0],srcStride[1],srcStride[2],dstStride[0]); for (y= 0; y<srcSliceH; y++ ) { \tuint8t *image = dst[0] + (y+srcSliceY)*dstStride[0]; \tuint8t *py = src[0] + y*srcStride[0]; \tuint8t *pu = src[1] + (y>>1)*srcStride[1]; \tuint8t *pv = src[2] + (y>>1)*srcStride[2]; \tlong index= -hsize/2; \tb5Dither= dither8[y&1]; \tg6Dither= dither4[y&1]; \tg5Dither= dither8[y&1]; \tr5Dither= dither8[(y+1)&1]; \t /* this mmx assembly code deals with SINGLE scan line at a time, it convert 8 \t pixels in each iteration */ \t asm volatile ( \t/* load data for start of next scan line */ \t\t \"movd (%2, %0), %%mm0;\" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */ \t\t \"movd (%3, %0), %%mm1;\" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */ \t\t \"movq (%5, %0, 2), %%mm6;\" /* Load 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */ //\t\t \".balign 16\t\t\t\\n\\t\" \t\t \"1:\t\t\t\t\\n\\t\" /* no speed diference on my p3@500 with prefetch, * if it is faster for anyone with -benchmark then tell me \t\t\tPREFETCH\" 64(%0) \\n\\t\" \t\t\tPREFETCH\" 64(%1) \\n\\t\" \t\t\tPREFETCH\" 64(%2) \\n\\t\" */ YUV2RGB #ifdef DITHER1XBPP \t\t\t\"paddusb \"MANGLE(b5Dither)\", %%mm0;\" \t\t\t\"paddusb \"MANGLE(g6Dither)\", %%mm2;\" \t\t\t\"paddusb \"MANGLE(r5Dither)\", %%mm1;\" #endif \t\t /* mask unneeded bits off */ \t\t \"pand \"MANGLE(mmxredmask)\", %%mm0;\" /* b7b6b5b4 b3000 b7b6b5b4 b3000 */ \t\t \"pand \"MANGLE(mmxgrnmask)\", %%mm2;\" /* g7g6g5g4 g3g200 g7g6g5g4 g3g200 */ \t\t \"pand \"MANGLE(mmxredmask)\", %%mm1;\" /* r7r6r5r4 r3000 r7r6r5r4 r3000 */ \t\t \"psrlw $3,%%mm0;\" /* 000b7 b6b5b4b3 000b7 b6b5b4b3 */ \t\t \"pxor %%mm4, %%mm4;\" /* zero mm4 */ \t\t \"movq %%mm0, %%mm5;\" /* Copy B7-B0 */ \t\t \"movq %%mm2, %%mm7;\" /* Copy G7-G0 */ \t\t /* convert rgb24 plane to rgb16 pack for pixel 0-3 */ \t\t \"punpcklbw %%mm4, %%mm2;\" /* 0000 0000 g7g6g5g4 g3g200 */ \t\t \"punpcklbw %%mm1, %%mm0;\" /* r7r6r5r4 r3000 000b7 b6b5b4b3 */ \t\t \"psllw $3, %%mm2;\" /* 0000 0g7g6g5 g4g3g20 0000 */ \t\t \"por %%mm2, %%mm0;\" /* r7r6r5r4 r3g7g6g5 g4g3g2b7 b6b5b4b3 */ \t\t \"movq 8 (%5, %0, 2), %%mm6;\" /* Load 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */ \t\t MOVNTQ \" %%mm0, (%1);\" /* store pixel 0-3 */ \t\t /* convert rgb24 plane to rgb16 pack for pixel 0-3 */ \t\t \"punpckhbw %%mm4, %%mm7;\" /* 0000 0000 g7g6g5g4 g3g200 */ \t\t \"punpckhbw %%mm1, %%mm5;\" /* r7r6r5r4 r3000 000b7 b6b5b4b3 */ \t\t \"psllw $3, %%mm7;\" /* 0000 0g7g6g5 g4g3g20 0000 */ \t\t \"movd 4 (%2, %0), %%mm0;\" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */ \t\t \"por %%mm7, %%mm5;\" /* r7r6r5r4 r3g7g6g5 g4g3g2b7 b6b5b4b3 */ \t\t \"movd 4 (%3, %0), %%mm1;\" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */ \t\t MOVNTQ \" %%mm5, 8 (%1);\" /* store pixel 4-7 */ \t\t \"add $16, %1\t\t\t\\n\\t\" \t\t \"add $4, %0\t\t\t\\n\\t\" \t\t \" js 1b\t\t\t\t\\n\\t\" \t\t : \"+r\" (index), \"+r\" (image) \t\t : \"r\" (pu - index), \"r\" (pv - index), \"r\"(&c->redDither), \"r\" (py - 2*index) \t\t ); } asm volatile (EMMS); return srcSliceH; } ", "target": 1}
{"func": "void memoryregionaddeventfd(MemoryRegion *mr, hwaddr addr, unsigned size, bool matchdata, uint64t data, EventNotifier *e) { MemoryRegionIoeventfd mrfd = { .addr.start = int128make64(addr), .addr.size = int128make64(size), .matchdata = matchdata, .data = data, .e = e, }; unsigned i; adjustendianness(mr, &mrfd.data, size); memoryregiontransactionbegin(); for (i = 0; i < mr->ioeventfdnb; ++i) { if (memoryregionioeventfdbefore(mrfd, mr->ioeventfds[i])) { break; } } ++mr->ioeventfdnb; mr->ioeventfds = grealloc(mr->ioeventfds, sizeof(*mr->ioeventfds) * mr->ioeventfdnb); memmove(&mr->ioeventfds[i+1], &mr->ioeventfds[i], sizeof(*mr->ioeventfds) * (mr->ioeventfdnb-1 - i)); mr->ioeventfds[i] = mrfd; ioeventfdupdatepending |= mr->enabled; memoryregiontransactioncommit(); } ", "target": 1}
{"func": "enum AVPixelFormat choosepixelfmt(AVStream *st, AVCodec *codec, enum AVPixelFormat target) { if (codec && codec->pixfmts) { const enum AVPixelFormat *p = codec->pixfmts; int hasalpha= avpixfmtdescget(target)->nbcomponents % 2 == 0; enum AVPixelFormat best= AVPIXFMTNONE; if (st->codec->strictstdcompliance <= FFCOMPLIANCEUNOFFICIAL) { if (st->codec->codecid == AVCODECIDMJPEG) { p = (const enum AVPixelFormat[]) { AVPIXFMTYUVJ420P, AVPIXFMTYUVJ422P, AVPIXFMTYUV420P, AVPIXFMTYUV422P, AVPIXFMTNONE }; } else if (st->codec->codecid == AVCODECIDLJPEG) { p = (const enum AVPixelFormat[]) { AVPIXFMTYUVJ420P, AVPIXFMTYUVJ422P, AVPIXFMTYUVJ444P, AVPIXFMTYUV420P, AVPIXFMTYUV422P, AVPIXFMTYUV444P, AVPIXFMTBGRA, AVPIXFMTNONE }; } } for (; *p != AVPIXFMTNONE; p++) { best= avcodecfindbestpixfmtof2(best, *p, target, hasalpha, NULL); if (*p == target) break; } if (*p == AVPIXFMTNONE) { if (target != AVPIXFMTNONE) avlog(NULL, AVLOGWARNING, \"Incompatible pixel format '%s' for codec '%s', auto-selecting format '%s'\\n\", avgetpixfmtname(target), codec->name, avgetpixfmtname(best)); return best; } } return target; } ", "target": 0}
{"func": "static void gicsetirq(void *opaque, int irq, int level) { /* Meaning of the 'irq' parameter: * [0..N-1] : external interrupts * [N..N+31] : PPI (internal) interrupts for CPU 0 * [N+32..N+63] : PPI (internal interrupts for CPU 1 * ... */ GICState *s = (GICState *)opaque; int cm, target; if (irq < (s->numirq - GICINTERNAL)) { /* The first external input line is internal interrupt 32. */ cm = ALLCPUMASK; irq += GICINTERNAL; target = GICTARGET(irq); } else { int cpu; irq -= (s->numirq - GICINTERNAL); cpu = irq / GICINTERNAL; irq %= GICINTERNAL; cm = 1 << cpu; target = cm; } assert(irq >= GICNRSGIS); if (level == GICTESTLEVEL(irq, cm)) { return; } if (s->revision == REV11MPCORE || s->revision == REVNVIC) { gicsetirq11mpcore(s, irq, level, cm, target); } else { gicsetirqgeneric(s, irq, level, cm, target); } gicupdate(s); }", "target": 1}
{"func": "static int decodembinfo(IVI5DecContext *ctx, IVIBandDesc *band, IVITile *tile, AVCodecContext *avctx) { int x, y, mvx, mvy, mvdelta, offs, mboffset, mvscale, blkspermb; IVIMbInfo *mb, *refmb; int rowoffset = band->mbsize * band->pitch; mb = tile->mbs; refmb = tile->refmbs; offs = tile->ypos * band->pitch + tile->xpos; /* scale factor for motion vectors */ mvscale = (ctx->planes[0].bands[0].mbsize >> 3) - (band->mbsize >> 3); mvx = mvy = 0; for (y = tile->ypos; y < (tile->ypos + tile->height); y += band->mbsize) { mboffset = offs; for (x = tile->xpos; x < (tile->xpos + tile->width); x += band->mbsize) { mb->xpos = x; mb->ypos = y; mb->bufoffs = mboffset; if (getbits1(&ctx->gb)) { if (ctx->frametype == FRAMETYPEINTRA) { avlog(avctx, AVLOGERROR, \"Empty macroblock in an INTRA picture!\\n\"); return -1; } mb->type = 1; /* empty macroblocks are always INTER */ mb->cbp = 0; /* all blocks are empty */ mb->qdelta = 0; if (!band->plane && !band->bandnum && (ctx->frameflags & 8)) { mb->qdelta = getvlc2(&ctx->gb, ctx->mbvlc.tab->table, IVIVLCBITS, 1); mb->qdelta = IVITOSIGNED(mb->qdelta); } mb->mvx = mb->mvy = 0; /* no motion vector coded */ if (band->inheritmv){ /* motion vector inheritance */ if (mvscale) { mb->mvx = iviscalemv(refmb->mvx, mvscale); mb->mvy = iviscalemv(refmb->mvy, mvscale); } else { mb->mvx = refmb->mvx; mb->mvy = refmb->mvy; } } } else { if (band->inheritmv) { mb->type = refmb->type; /* copy mbtype from corresponding reference mb */ } else if (ctx->frametype == FRAMETYPEINTRA) { mb->type = 0; /* mbtype is always INTRA for intra-frames */ } else { mb->type = getbits1(&ctx->gb); } blkspermb = band->mbsize != band->blksize ? 4 : 1; mb->cbp = getbits(&ctx->gb, blkspermb); mb->qdelta = 0; if (band->qdeltapresent) { if (band->inheritqdelta) { if (refmb) mb->qdelta = refmb->qdelta; } else if (mb->cbp || (!band->plane && !band->bandnum && (ctx->frameflags & 8))) { mb->qdelta = getvlc2(&ctx->gb, ctx->mbvlc.tab->table, IVIVLCBITS, 1); mb->qdelta = IVITOSIGNED(mb->qdelta); } } if (!mb->type) { mb->mvx = mb->mvy = 0; /* there is no motion vector in intra-macroblocks */ } else { if (band->inheritmv){ /* motion vector inheritance */ if (mvscale) { mb->mvx = iviscalemv(refmb->mvx, mvscale); mb->mvy = iviscalemv(refmb->mvy, mvscale); } else { mb->mvx = refmb->mvx; mb->mvy = refmb->mvy; } } else { /* decode motion vector deltas */ mvdelta = getvlc2(&ctx->gb, ctx->mbvlc.tab->table, IVIVLCBITS, 1); mvy += IVITOSIGNED(mvdelta); mvdelta = getvlc2(&ctx->gb, ctx->mbvlc.tab->table, IVIVLCBITS, 1); mvx += IVITOSIGNED(mvdelta); mb->mvx = mvx; mb->mvy = mvy; } } } mb++; if (refmb) refmb++; mboffset += band->mbsize; } offs += rowoffset; } aligngetbits(&ctx->gb); return 0; }", "target": 1}
{"func": "VIOsPAPRDevice *vtylookup(sPAPRMachineState *spapr, targetulong reg) { VIOsPAPRDevice *sdev; sdev = spaprviofindbyreg(spapr->viobus, reg); if (!sdev && reg == 0) { /* Hack for kernel early debug, which always specifies reg==0. * We search all VIO devices, and grab the vty with the lowest * reg. This attempts to mimic existing PowerVM behaviour * (early debug does work there, despite having no vty with * reg==0. */ return spaprvtygetdefault(spapr->viobus); return sdev;", "target": 1}
{"func": "void coroutinefn blockjobpausepoint(BlockJob *job) { assert(job && blockjobstarted(job)); if (!blockjobshouldpause(job)) { return; } if (blockjobiscancelled(job)) { return; } if (job->driver->pause) { job->driver->pause(job); } if (blockjobshouldpause(job) && !blockjobiscancelled(job)) { job->paused = true; job->busy = false; qemucoroutineyield(); /* wait for blockjobresume() */ job->busy = true; job->paused = false; } if (job->driver->resume) { job->driver->resume(job); } } ", "target": 1}
{"func": "int bdrvpread(BlockDriverState *bs, int64t offset, void *buf1, int count1) { BlockDriver *drv = bs->drv; if (!drv) return -ENOMEDIUM; if (!drv->bdrvpread) return bdrvpreadem(bs, offset, buf1, count1); return drv->bdrvpread(bs, offset, buf1, count1); }", "target": 1}
{"func": "int avprivdcaconvertbitstream(const uint8t *src, int srcsize, uint8t *dst, int maxsize) { uint32t mrk; int i, tmp; const uint16t *ssrc = (const uint16t *) src; uint16t *sdst = (uint16t *) dst; PutBitContext pb; if ((unsigned) srcsize > (unsigned) maxsize) srcsize = maxsize; mrk = AVRB32(src); switch (mrk) { case DCASYNCWORDCOREBE: memcpy(dst, src, srcsize); return srcsize; case DCASYNCWORDCORELE: for (i = 0; i < (srcsize + 1) >> 1; i++) *sdst++ = avbswap16(*ssrc++); return srcsize; case DCASYNCWORDCORE14BBE: case DCASYNCWORDCORE14BLE: initputbits(&pb, dst, maxsize); for (i = 0; i < (srcsize + 1) >> 1; i++, src += 2) { tmp = ((mrk == DCASYNCWORDCORE14BBE) ? AVRB16(src) : AVRL16(src)) & 0x3FFF; putbits(&pb, 14, tmp); } flushputbits(&pb); return (putbitscount(&pb) + 7) >> 3; default: return AVERRORINVALIDDATA; } } ", "target": 1}
{"func": "static TRBCCode xhcidisableep(XHCIState *xhci, unsigned int slotid, unsigned int epid) { XHCISlot *slot; XHCIEPContext *epctx; int i; traceusbxhciepdisable(slotid, epid); assert(slotid >= 1 && slotid <= xhci->numslots); assert(epid >= 1 && epid <= 31); slot = &xhci->slots[slotid-1]; if (!slot->eps[epid-1]) { DPRINTF(\"xhci: slot %d ep %d already disabled\\n\", slotid, epid); return CCSUCCESS; xhciepnukexfers(xhci, slotid, epid); epctx = slot->eps[epid-1]; if (epctx->nrpstreams) { xhcifreestreams(epctx); xhcisetepstate(xhci, epctx, NULL, EPDISABLED); timerfree(epctx->kicktimer); gfree(epctx); slot->eps[epid-1] = NULL; return CCSUCCESS;", "target": 1}
{"func": "int pvpanicinit(ISABus *bus) { isacreatesimple(bus, TYPEISAPVPANICDEVICE); return 0; } ", "target": 1}
{"func": "static uint32t gicdistreadb(void *opaque, hwaddr offset, MemTxAttrs attrs) { GICState *s = (GICState *)opaque; uint32t res; int irq; int i; int cpu; int cm; int mask; cpu = gicgetcurrentcpu(s); cm = 1 << cpu; if (offset < 0x100) { if (offset == 0) return s->enabled; if (offset == 4) /* Interrupt Controller Type Register */ return ((s->numirq / 32) - 1) | ((NUMCPU(s) - 1) << 5) | (s->securityextn << 10); if (offset < 0x08) return 0; if (offset >= 0x80) { /* Interrupt Group Registers: these RAZ/WI if this is an NS * access to a GIC with the security extensions, or if the GIC * doesn't have groups at all. */ res = 0; if (!(s->securityextn && !attrs.secure) && gichasgroups(s)) { /* Every byte offset holds 8 group status bits */ irq = (offset - 0x080) * 8 + GICBASEIRQ; if (irq >= s->numirq) { goto badreg; } for (i = 0; i < 8; i++) { if (GICTESTGROUP(irq + i, cm)) { res |= (1 << i); } } } return res; } goto badreg; } else if (offset < 0x200) { /* Interrupt Set/Clear Enable. */ if (offset < 0x180) irq = (offset - 0x100) * 8; else irq = (offset - 0x180) * 8; irq += GICBASEIRQ; if (irq >= s->numirq) goto badreg; res = 0; for (i = 0; i < 8; i++) { if (GICTESTENABLED(irq + i, cm)) { res |= (1 << i); } } } else if (offset < 0x300) { /* Interrupt Set/Clear Pending. */ if (offset < 0x280) irq = (offset - 0x200) * 8; else irq = (offset - 0x280) * 8; irq += GICBASEIRQ; if (irq >= s->numirq) goto badreg; res = 0; mask = (irq < GICINTERNAL) ? cm : ALLCPUMASK; for (i = 0; i < 8; i++) { if (gictestpending(s, irq + i, mask)) { res |= (1 << i); } } } else if (offset < 0x400) { /* Interrupt Active. */ irq = (offset - 0x300) * 8 + GICBASEIRQ; if (irq >= s->numirq) goto badreg; res = 0; mask = (irq < GICINTERNAL) ? cm : ALLCPUMASK; for (i = 0; i < 8; i++) { if (GICTESTACTIVE(irq + i, mask)) { res |= (1 << i); } } } else if (offset < 0x800) { /* Interrupt Priority. */ irq = (offset - 0x400) + GICBASEIRQ; if (irq >= s->numirq) goto badreg; res = GICGETPRIORITY(irq, cpu); } else if (offset < 0xc00) { /* Interrupt CPU Target. */ if (s->numcpu == 1 && s->revision != REV11MPCORE) { /* For uniprocessor GICs these RAZ/WI */ res = 0; } else { irq = (offset - 0x800) + GICBASEIRQ; if (irq >= s->numirq) { goto badreg; } if (irq >= 29 && irq <= 31) { res = cm; } else { res = GICTARGET(irq); } } } else if (offset < 0xf00) { /* Interrupt Configuration. */ irq = (offset - 0xc00) * 4 + GICBASEIRQ; if (irq >= s->numirq) goto badreg; res = 0; for (i = 0; i < 4; i++) { if (GICTESTMODEL(irq + i)) res |= (1 << (i * 2)); if (GICTESTEDGETRIGGER(irq + i)) res |= (2 << (i * 2)); } } else if (offset < 0xf10) { goto badreg; } else if (offset < 0xf30) { if (s->revision == REV11MPCORE || s->revision == REVNVIC) { goto badreg; } if (offset < 0xf20) { /* GICDCPENDSGIRn */ irq = (offset - 0xf10); } else { irq = (offset - 0xf20); /* GICDSPENDSGIRn */ } res = s->sgipending[irq][cpu]; } else if (offset < 0xfe0) { goto badreg; } else /* offset >= 0xfe0 */ { if (offset & 3) { res = 0; } else { res = gicid[(offset - 0xfe0) >> 2]; } } return res; badreg: qemulogmask(LOGGUESTERROR, \"gicdistreadb: Bad offset %x\\n\", (int)offset); return 0; } ", "target": 0}
{"func": "static inline int getsegment6xxtlb(CPUPPCState *env, mmuctxt *ctx, targetulong eaddr, int rw, int type) { hwaddr hash; targetulong vsid; int ds, pr, targetpagebits; int ret; targetulong sr, pgidx; pr = msrpr; ctx->eaddr = eaddr; sr = env->sr[eaddr >> 28]; ctx->key = (((sr & 0x20000000) && (pr != 0)) || ((sr & 0x40000000) && (pr == 0))) ? 1 : 0; ds = sr & 0x80000000 ? 1 : 0; ctx->nx = sr & 0x10000000 ? 1 : 0; vsid = sr & 0x00FFFFFF; targetpagebits = TARGETPAGEBITS; qemulogmask(CPULOGMMU, \"Check segment v=\" TARGETFMTlx \" %d \" TARGETFMTlx \" nip=\" TARGETFMTlx \" lr=\" TARGETFMTlx \" ir=%d dr=%d pr=%d %d t=%d\\n\", eaddr, (int)(eaddr >> 28), sr, env->nip, env->lr, (int)msrir, (int)msrdr, pr != 0 ? 1 : 0, rw, type); pgidx = (eaddr & ~SEGMENTMASK256M) >> targetpagebits; hash = vsid ^ pgidx; ctx->ptem = (vsid << 7) | (pgidx >> 10); qemulogmask(CPULOGMMU, \"pte segment: key=%d ds %d nx %d vsid \" TARGETFMTlx \"\\n\", ctx->key, ds, ctx->nx, vsid); ret = -1; if (!ds) { /* Check if instruction fetch is allowed, if needed */ if (type != ACCESSCODE || ctx->nx == 0) { /* Page address translation */ qemulogmask(CPULOGMMU, \"htabbase \" TARGETFMTplx \" htabmask \" TARGETFMTplx \" hash \" TARGETFMTplx \"\\n\", env->htabbase, env->htabmask, hash); ctx->hash[0] = hash; ctx->hash[1] = ~hash; /* Initialize real address with an invalid value */ ctx->raddr = (hwaddr)-1ULL; /* Software TLB search */ ret = ppc6xxtlbcheck(env, ctx, eaddr, rw, type); #if defined(DUMPPAGETABLES) if (qemuloglevelmask(CPULOGMMU)) { CPUState *cs = ENVGETCPU(env); hwaddr curaddr; uint32t a0, a1, a2, a3; qemulog(\"Page table: \" TARGETFMTplx \" len \" TARGETFMTplx \"\\n\", env->htabbase, env->htabmask + 0x80); for (curaddr = env->htabbase; curaddr < (env->htabbase + env->htabmask + 0x80); curaddr += 16) { a0 = ldlphys(cs->as, curaddr); a1 = ldlphys(cs->as, curaddr + 4); a2 = ldlphys(cs->as, curaddr + 8); a3 = ldlphys(cs->as, curaddr + 12); if (a0 != 0 || a1 != 0 || a2 != 0 || a3 != 0) { qemulog(TARGETFMTplx \": %08x %08x %08x %08x\\n\", curaddr, a0, a1, a2, a3); } } } #endif } else { qemulogmask(CPULOGMMU, \"No access allowed\\n\"); ret = -3; } } else { targetulong sr; qemulogmask(CPULOGMMU, \"direct store...\\n\"); /* Direct-store segment : absolutely *BUGGY* for now */ /* Direct-store implies a 32-bit MMU. * Check the Segment Register's bus unit ID (BUID). */ sr = env->sr[eaddr >> 28]; if ((sr & 0x1FF00000) >> 20 == 0x07f) { /* Memory-forced I/O controller interface access */ /* If T=1 and BUID=x'07F', the 601 performs a memory access * to SR[28-31] LA[4-31], bypassing all protection mechanisms. */ ctx->raddr = ((sr & 0xF) << 28) | (eaddr & 0x0FFFFFFF); ctx->prot = PAGEREAD | PAGEWRITE | PAGEEXEC; return 0; } switch (type) { case ACCESSINT: /* Integer load/store : only access allowed */ break; case ACCESSCODE: /* No code fetch is allowed in direct-store areas */ return -4; case ACCESSFLOAT: /* Floating point load/store */ return -4; case ACCESSRES: /* lwarx, ldarx or srwcx. */ return -4; case ACCESSCACHE: /* dcba, dcbt, dcbtst, dcbf, dcbi, dcbst, dcbz, or icbi */ /* Should make the instruction do no-op. * As it already do no-op, it's quite easy :-) */ ctx->raddr = eaddr; return 0; case ACCESSEXT: /* eciwx or ecowx */ return -4; default: qemulogmask(CPULOGMMU, \"ERROR: instruction should not need \" \"address translation\\n\"); return -4; } if ((rw == 1 || ctx->key != 1) && (rw == 0 || ctx->key != 0)) { ctx->raddr = eaddr; ret = 2; } else { ret = -2; } } return ret; } ", "target": 0}
{"func": "static void slirpsocketsave(QEMUFile *f, struct socket *so) { qemuputbe32(f, so->sourgc); qemuputbe16(f, so->soffamily); switch (so->soffamily) { case AFINET: qemuputbe32(f, so->sofaddr.saddr); qemuputbe16(f, so->sofport); break; default: errorreport( \"soffamily unknown, unable to save sofaddr and sofport\\n\"); } qemuputbe16(f, so->solfamily); switch (so->solfamily) { case AFINET: qemuputbe32(f, so->soladdr.saddr); qemuputbe16(f, so->solport); break; default: errorreport( \"soffamily unknown, unable to save soladdr and solport\\n\"); } qemuputbyte(f, so->soiptos); qemuputbyte(f, so->soemu); qemuputbyte(f, so->sotype); qemuputbe32(f, so->sostate); slirpsbufsave(f, &so->sorcv); slirpsbufsave(f, &so->sosnd); slirptcpsave(f, so->sotcpcb); } ", "target": 0}
{"func": "void objectpropertyallowsetlink(Object *obj, const char *name, Object *val, Error **errp) { /* Allow the link to be set, always */ } ", "target": 1}
{"func": "static inline void mix3f1rtomono(AC3DecodeContext *ctx) { int i; float (*output)[256] = ctx->audioblock.blockoutput; for (i = 0; i < 256; i++) output[1][i] = (output[2][i] + output[3][i] + output[4][i]); memset(output[2], 0, sizeof(output[2])); memset(output[3], 0, sizeof(output[3])); memset(output[4], 0, sizeof(output[4])); } ", "target": 0}
{"func": "static inline void RENAME(nv21ToUV)(uint8t *dstU, uint8t *dstV, const uint8t *src1, const uint8t *src2, long width, uint32t *unused) { RENAME(nvXXtoUV)(dstV, dstU, src1, width); } ", "target": 0}
{"func": "static uint64t lan9118readl(void *opaque, targetphysaddrt offset, unsigned size) { lan9118state *s = (lan9118state *)opaque; //DPRINTF(\"Read reg 0x%02x\\n\", (int)offset); if (offset < 0x20) { /* RX FIFO */ return rxfifopop(s); } switch (offset) { case 0x40: return rxstatusfifopop(s); case 0x44: return s->rxstatusfifo[s->txstatusfifohead]; case 0x48: return txstatusfifopop(s); case 0x4c: return s->txstatusfifo[s->txstatusfifohead]; case CSRIDREV: return 0x01180001; case CSRIRQCFG: return s->irqcfg; case CSRINTSTS: return s->intsts; case CSRINTEN: return s->inten; case CSRBYTETEST: return 0x87654321; case CSRFIFOINT: return s->fifoint; case CSRRXCFG: return s->rxcfg; case CSRTXCFG: return s->txcfg; case CSRHWCFG: return s->hwcfg; case CSRRXDPCTRL: return 0; case CSRRXFIFOINF: return (s->rxstatusfifoused << 16) | (s->rxfifoused << 2); case CSRTXFIFOINF: return (s->txstatusfifoused << 16) | (s->txfifosize - s->txp->fifoused); case CSRPMTCTRL: return s->pmtctrl; case CSRGPIOCFG: return s->gpiocfg; case CSRGPTCFG: return s->gptcfg; case CSRGPTCNT: return ptimergetcount(s->timer); case CSRWORDSWAP: return s->wordswap; case CSRFREERUN: return (qemugetclockns(vmclock) / 40) - s->freetimerstart; case CSRRXDROP: /* TODO: Implement dropped frames counter. */ return 0; case CSRMACCSRCMD: return s->maccmd; case CSRMACCSRDATA: return s->macdata; case CSRAFCCFG: return s->afccfg; case CSRE2PCMD: return s->e2pcmd; case CSRE2PDATA: return s->e2pdata; } hwerror(\"lan9118read: Bad reg 0x%x\\n\", (int)offset); return 0; } ", "target": 0}
{"func": "static int readlowcoeffs(AVCodecContext *avctx, int16t *dst, int size, int width, ptrdifft stride) { PixletContext *ctx = avctx->privdata; GetBitContext *b = &ctx->gbit; unsigned cnt1, nbits, k, j = 0, i = 0; int64t value, state = 3; int rlen, escape, flag = 0; while (i < size) { nbits = FFMIN(ffclz((state >> 8) + 3) ^ 0x1F, 14); cnt1 = getunary(b, 0, 8); if (cnt1 < 8) { value = showbits(b, nbits); if (value <= 1) { skipbits(b, nbits - 1); escape = ((1 << nbits) - 1) * cnt1; } else { skipbits(b, nbits); escape = value + ((1 << nbits) - 1) * cnt1 - 1; } } else { escape = getbits(b, 16); } value = -((escape + flag) & 1) | 1; dst[j++] = value * ((escape + flag + 1) >> 1); i++; if (j == width) { j = 0; dst += stride; } state = 120 * (escape + flag) + state - (120 * state >> 8); flag = 0; if (state * 4 > 0xFF || i >= size) continue; nbits = ((state + 8) >> 5) + (state ? ffclz(state) : 32) - 24; escape = avmoduintp2(16383, nbits); cnt1 = getunary(b, 0, 8); if (cnt1 > 7) { rlen = getbits(b, 16); } else { value = showbits(b, nbits); if (value > 1) { skipbits(b, nbits); rlen = value + escape * cnt1 - 1; } else { skipbits(b, nbits - 1); rlen = escape * cnt1; } } if (i + rlen > size) return AVERRORINVALIDDATA; i += rlen; for (k = 0; k < rlen; k++) { dst[j++] = 0; if (j == width) { j = 0; dst += stride; } } state = 0; flag = rlen < 0xFFFF ? 1 : 0; } aligngetbits(b); return getbitscount(b) >> 3; } ", "target": 0}
{"func": "static int nbdcoreadv1(BlockDriverState *bs, int64t sectornum, int nbsectors, QEMUIOVector *qiov, int offset) { BDRVNBDState *s = bs->opaque; struct nbdrequest request; struct nbdreply reply; request.type = NBDCMDREAD; request.from = sectornum * 512; request.len = nbsectors * 512; nbdcoroutinestart(s, &request); if (nbdcosendrequest(s, &request, NULL, 0) == -1) { reply.error = errno; } else { nbdcoreceivereply(s, &request, &reply, qiov->iov, offset); } nbdcoroutineend(s, &request); return -reply.error; } ", "target": 0}
{"func": "static int requestframe(AVFilterLink *link) { AVFilterContext *ctx = link->src; IDETContext *idet = ctx->priv; do { int ret; if (idet->eof) return AVERROREOF; ret = ffrequestframe(link->src->inputs[0]); if (ret == AVERROREOF && idet->cur) { AVFrame *next = avframeclone(idet->next); if (!next) return AVERROR(ENOMEM); filterframe(link->src->inputs[0], next); idet->eof = 1; } else if (ret < 0) { return ret; } } while (!idet->cur); return 0; } ", "target": 0}
{"func": "static int dpcmdecodeframe(AVCodecContext *avctx, void *data, int *datasize, uint8t *buf, int bufsize) { DPCMContext *s = avctx->privdata; int in, out = 0; int predictor[2]; int channelnumber = 0; short *outputsamples = data; int shift[2]; unsigned char byte; short diff; if (!bufsize) return 0; switch(avctx->codec->id) { case CODECIDROQDPCM: if (s->channels == 1) predictor[0] = AVRL16(&buf[6]); else { predictor[0] = buf[7] << 8; predictor[1] = buf[6] << 8; } SE16BIT(predictor[0]); SE16BIT(predictor[1]); /* decode the samples */ for (in = 8, out = 0; in < bufsize; in++, out++) { predictor[channelnumber] += s->roqsquarearray[buf[in]]; predictor[channelnumber] = avclipint16(predictor[channelnumber]); outputsamples[out] = predictor[channelnumber]; /* toggle channel */ channelnumber ^= s->channels - 1; } break; case CODECIDINTERPLAYDPCM: in = 6; /* skip over the stream mask and stream length */ predictor[0] = AVRL16(&buf[in]); in += 2; SE16BIT(predictor[0]) outputsamples[out++] = predictor[0]; if (s->channels == 2) { predictor[1] = AVRL16(&buf[in]); in += 2; SE16BIT(predictor[1]) outputsamples[out++] = predictor[1]; } while (in < bufsize) { predictor[channelnumber] += interplaydeltatable[buf[in++]]; predictor[channelnumber] = avclipint16(predictor[channelnumber]); outputsamples[out++] = predictor[channelnumber]; /* toggle channel */ channelnumber ^= s->channels - 1; } break; case CODECIDXANDPCM: in = 0; shift[0] = shift[1] = 4; predictor[0] = AVRL16(&buf[in]); in += 2; SE16BIT(predictor[0]); if (s->channels == 2) { predictor[1] = AVRL16(&buf[in]); in += 2; SE16BIT(predictor[1]); } while (in < bufsize) { byte = buf[in++]; diff = (byte & 0xFC) << 8; if ((byte & 0x03) == 3) shift[channelnumber]++; else shift[channelnumber] -= (2 * (byte & 3)); /* saturate the shifter to a lower limit of 0 */ if (shift[channelnumber] < 0) shift[channelnumber] = 0; diff >>= shift[channelnumber]; predictor[channelnumber] += diff; predictor[channelnumber] = avclipint16(predictor[channelnumber]); outputsamples[out++] = predictor[channelnumber]; /* toggle channel */ channelnumber ^= s->channels - 1; } break; case CODECIDSOLDPCM: in = 0; if (avctx->codectag != 3) { if(*datasize/4 < bufsize) while (in < bufsize) { int n1, n2; n1 = (buf[in] >> 4) & 0xF; n2 = buf[in++] & 0xF; s->sample[0] += s->soltable[n1]; if (s->sample[0] < 0) s->sample[0] = 0; if (s->sample[0] > 255) s->sample[0] = 255; outputsamples[out++] = (s->sample[0] - 128) << 8; s->sample[s->channels - 1] += s->soltable[n2]; if (s->sample[s->channels - 1] < 0) s->sample[s->channels - 1] = 0; if (s->sample[s->channels - 1] > 255) s->sample[s->channels - 1] = 255; outputsamples[out++] = (s->sample[s->channels - 1] - 128) << 8; } } else { while (in < bufsize) { int n; n = buf[in++]; if (n & 0x80) s->sample[channelnumber] -= s->soltable[n & 0x7F]; else s->sample[channelnumber] += s->soltable[n & 0x7F]; s->sample[channelnumber] = avclipint16(s->sample[channelnumber]); outputsamples[out++] = s->sample[channelnumber]; /* toggle channel */ channelnumber ^= s->channels - 1; } } break; } *datasize = out * sizeof(short); return bufsize; }", "target": 1}
{"func": "int ffrmreadmdprcodecdata(AVFormatContext *s, AVIOContext *pb, AVStream *st, RMStream *rst, unsigned int codecdatasize, const uint8t *mime) { unsigned int v; int size; int64t codecpos; int ret; if (codecdatasize > INTMAX) return AVERRORINVALIDDATA; avprivsetptsinfo(st, 64, 1, 1000); codecpos = aviotell(pb); v = aviorb32(pb); if (v == MKBETAG('M', 'L', 'T', 'I')) { int numberofstreams = aviorb16(pb); int numberofmdpr; int i; for (i = 0; i<numberofstreams; i++) aviorb16(pb); numberofmdpr = aviorb16(pb); if (numberofmdpr != 1) { avprivrequestsample(s, \"MLTI with multiple MDPR\"); } aviorb32(pb); v = aviorb32(pb); } if (v == MKTAG(0xfd, 'a', 'r', '.')) { /* ra type header */ if (rmreadaudiostreaminfo(s, pb, st, rst, 0)) return -1; } else if (v == MKBETAG('L', 'S', 'D', ':')) { avioseek(pb, -4, SEEKCUR); if ((ret = rmreadextradata(pb, st->codec, codecdatasize)) < 0) return ret; st->codec->codectype = AVMEDIATYPEAUDIO; st->codec->codectag = AVRL32(st->codec->extradata); st->codec->codecid = ffcodecgetid(ffrmcodectags, st->codec->codectag); } else if(mime && !strcmp(mime, \"logical-fileinfo\")){ int streamcount, rulecount, propertycount, i; fffreestream(s, st); if (aviorb16(pb) != 0) { avlog(s, AVLOGWARNING, \"Unsupported version\\n\"); goto skip; } streamcount = aviorb16(pb); avioskip(pb, 6*streamcount); rulecount = aviorb16(pb); avioskip(pb, 2*rulecount); propertycount = aviorb16(pb); for(i=0; i<propertycount; i++){ uint8t name[128], val[128]; aviorb32(pb); if (aviorb16(pb) != 0) { avlog(s, AVLOGWARNING, \"Unsupported Name value property version\\n\"); goto skip; //FIXME skip just this one } getstr8(pb, name, sizeof(name)); switch(aviorb32(pb)) { case 2: getstrl(pb, val, sizeof(val), aviorb16(pb)); avdictset(&s->metadata, name, val, 0); break; default: avioskip(pb, aviorb16(pb)); } } } else { int fps; if (aviorl32(pb) != MKTAG('V', 'I', 'D', 'O')) { fail1: avlog(s, AVLOGWARNING, \"Unsupported stream type %08x\\n\", v); goto skip; } st->codec->codectag = aviorl32(pb); st->codec->codecid = ffcodecgetid(ffrmcodectags, st->codec->codectag); avdlog(s, \"%X %X\\n\", st->codec->codectag, MKTAG('R', 'V', '2', '0')); if (st->codec->codecid == AVCODECIDNONE) goto fail1; st->codec->width = aviorb16(pb); st->codec->height = aviorb16(pb); avioskip(pb, 2); // looks like bits per sample avioskip(pb, 4); // always zero? st->codec->codectype = AVMEDIATYPEVIDEO; st->needparsing = AVSTREAMPARSETIMESTAMPS; fps = aviorb32(pb); if ((ret = rmreadextradata(pb, st->codec, codecdatasize - (aviotell(pb) - codecpos))) < 0) return ret; if (fps > 0) { avreduce(&st->avgframerate.den, &st->avgframerate.num, 0x10000, fps, (1 << 30) - 1); #if FFAPIRFRAMERATE st->rframerate = st->avgframerate; #endif } else if (s->errorrecognition & AVEFEXPLODE) { avlog(s, AVLOGERROR, \"Invalid framerate\\n\"); return AVERRORINVALIDDATA; } } skip: /* skip codec info */ size = aviotell(pb) - codecpos; avioskip(pb, codecdatasize - size); return 0; } ", "target": 1}
{"func": "int sddocommand(SDState *sd, SDRequest *req, uint8t *response) { uint32t laststatus = sd->cardstatus; sdrsptypet rtype; int rsplen; if (!sd->bdrv || !bdrvisinserted(sd->bdrv) || !sd->enable) { return 0; } if (sdreqcrcvalidate(req)) { sd->cardstatus &= ~COMCRCERROR; return 0; } sd->cardstatus &= ~CARDSTATUSB; sdsetstatus(sd); if (laststatus & CARDISLOCKED) { if (!cmdvalidwhilelocked(sd, req)) { sd->cardstatus |= ILLEGALCOMMAND; fprintf(stderr, \"SD: Card is locked\\n\"); return 0; } } if (laststatus & APPCMD) { rtype = sdappcommand(sd, *req); sd->cardstatus &= ~APPCMD; } else rtype = sdnormalcommand(sd, *req); sd->currentcmd = req->cmd; switch (rtype) { case sdr1: case sdr1b: sdresponser1make(sd, response, laststatus); rsplen = 4; break; case sdr2i: memcpy(response, sd->cid, sizeof(sd->cid)); rsplen = 16; break; case sdr2s: memcpy(response, sd->csd, sizeof(sd->csd)); rsplen = 16; break; case sdr3: sdresponser3make(sd, response); rsplen = 4; break; case sdr6: sdresponser6make(sd, response); rsplen = 4; break; case sdr7: sdresponser7make(sd, response); rsplen = 4; break; case sdr0: default: rsplen = 0; break; } if (sd->cardstatus & ILLEGALCOMMAND) rsplen = 0; #ifdef DEBUGSD if (rsplen) { int i; DPRINTF(\"Response:\"); for (i = 0; i < rsplen; i++) printf(\" %02x\", response[i]); printf(\" state %d\\n\", sd->state); } else { DPRINTF(\"No response %d\\n\", sd->state); } #endif return rsplen; } ", "target": 1}
{"func": "static int dpcmdecodeframe(AVCodecContext *avctx, void *data, int *datasize, AVPacket *avpkt) { const uint8t *buf = avpkt->data; int bufsize = avpkt->size; DPCMContext *s = avctx->privdata; int in, out = 0; int predictor[2]; int ch = 0; int stereo = s->channels - 1; short *outputsamples = data; int shift[2]; unsigned char byte; short diff; if (!bufsize) return 0; // almost every DPCM variant expands one byte of data into two if(*datasize/2 < bufsize) return -1; switch(avctx->codec->id) { case CODECIDROQDPCM: if (stereo) { predictor[0] = buf[7] << 8; predictor[1] = buf[6] << 8; } else { predictor[0] = AVRL16(&buf[6]); } SE16BIT(predictor[0]); SE16BIT(predictor[1]); /* decode the samples */ for (in = 8, out = 0; in < bufsize; in++, out++) { predictor[ch] += s->roqsquarearray[buf[in]]; predictor[ch] = avclipint16(predictor[ch]); outputsamples[out] = predictor[ch]; /* toggle channel */ ch ^= stereo; } break; case CODECIDINTERPLAYDPCM: in = 6; /* skip over the stream mask and stream length */ predictor[0] = AVRL16(&buf[in]); in += 2; SE16BIT(predictor[0]) outputsamples[out++] = predictor[0]; if (stereo) { predictor[1] = AVRL16(&buf[in]); in += 2; SE16BIT(predictor[1]) outputsamples[out++] = predictor[1]; } while (in < bufsize) { predictor[ch] += interplaydeltatable[buf[in++]]; predictor[ch] = avclipint16(predictor[ch]); outputsamples[out++] = predictor[ch]; /* toggle channel */ ch ^= stereo; } break; case CODECIDXANDPCM: in = 0; shift[0] = shift[1] = 4; predictor[0] = AVRL16(&buf[in]); in += 2; SE16BIT(predictor[0]); if (stereo) { predictor[1] = AVRL16(&buf[in]); in += 2; SE16BIT(predictor[1]); } while (in < bufsize) { byte = buf[in++]; diff = (byte & 0xFC) << 8; if ((byte & 0x03) == 3) shift[ch]++; else shift[ch] -= (2 * (byte & 3)); /* saturate the shifter to a lower limit of 0 */ if (shift[ch] < 0) shift[ch] = 0; diff >>= shift[ch]; predictor[ch] += diff; predictor[ch] = avclipint16(predictor[ch]); outputsamples[out++] = predictor[ch]; /* toggle channel */ ch ^= stereo; } break; case CODECIDSOLDPCM: in = 0; if (avctx->codectag != 3) { if(*datasize/4 < bufsize) return -1; while (in < bufsize) { int n1, n2; n1 = (buf[in] >> 4) & 0xF; n2 = buf[in++] & 0xF; s->sample[0] += s->soltable[n1]; if (s->sample[0] < 0) s->sample[0] = 0; if (s->sample[0] > 255) s->sample[0] = 255; outputsamples[out++] = (s->sample[0] - 128) << 8; s->sample[stereo] += s->soltable[n2]; if (s->sample[stereo] < 0) s->sample[stereo] = 0; if (s->sample[stereo] > 255) s->sample[stereo] = 255; outputsamples[out++] = (s->sample[stereo] - 128) << 8; } } else { while (in < bufsize) { int n; n = buf[in++]; if (n & 0x80) s->sample[ch] -= s->soltable[n & 0x7F]; else s->sample[ch] += s->soltable[n & 0x7F]; s->sample[ch] = avclipint16(s->sample[ch]); outputsamples[out++] = s->sample[ch]; /* toggle channel */ ch ^= stereo; } } break; } *datasize = out * sizeof(short); return bufsize; } ", "target": 0}
{"func": "static void picmemset(PicContext *s, AVFrame *frame, unsigned value, int run, int *x, int *y, int *plane, int bitsperplane) { uint8t *d; int shift = *plane * bitsperplane; unsigned mask = ((1 << bitsperplane) - 1) << shift; value <<= shift; while (run > 0) { int j; for (j = 8-bitsperplane; j >= 0; j -= bitsperplane) { d = frame->data[0] + *y * frame->linesize[0]; d[*x] |= (value >> j) & mask; *x += 1; if (*x == s->width) { *y -= 1; *x = 0; if (*y < 0) { *y = s->height - 1; *plane += 1; if (*plane >= s->nbplanes) return; value <<= bitsperplane; mask <<= bitsperplane; } } } run--; } } ", "target": 1}
{"func": "mpimaget* vfgetimage(vfinstancet* vf, unsigned int outfmt, int mpimgtype, int mpimgflag, int w, int h){ MPContext *m= (MPContext*)(((uint8t*)vf) - offsetof(MPContext, nextvf)); mpimaget* mpi=NULL; int w2; int number = mpimgtype >> 16; avassert0(vf->next == NULL); // all existing filters call this just on next //vfdint needs these as it calls vfgetimage() before configuring the output if(vf->w==0 && w>0) vf->w=w; if(vf->h==0 && h>0) vf->h=h; avassert0(w == -1 || w >= vf->w); avassert0(h == -1 || h >= vf->h); avassert0(vf->w > 0); avassert0(vf->h > 0); avlog(m->avfctx, AVLOGDEBUG, \"getimage: %d:%d, vf: %d:%d\\n\", w,h,vf->w,vf->h); if (w == -1) w = vf->w; if (h == -1) h = vf->h; w2=(mpimgflag&MPIMGFLAGACCEPTALIGNEDSTRIDE)?((w+15)&(~15)):w; // Note: we should call libvo first to check if it supports direct rendering // and if not, then fallback to software buffers: switch(mpimgtype & 0xff){ case MPIMGTYPEEXPORT: if(!vf->imgctx.exportimages[0]) vf->imgctx.exportimages[0]=newmpimage(w2,h); mpi=vf->imgctx.exportimages[0]; break; case MPIMGTYPESTATIC: if(!vf->imgctx.staticimages[0]) vf->imgctx.staticimages[0]=newmpimage(w2,h); mpi=vf->imgctx.staticimages[0]; break; case MPIMGTYPETEMP: if(!vf->imgctx.tempimages[0]) vf->imgctx.tempimages[0]=newmpimage(w2,h); mpi=vf->imgctx.tempimages[0]; break; case MPIMGTYPEIPB: if(!(mpimgflag&MPIMGFLAGREADABLE)){ // B frame: if(!vf->imgctx.tempimages[0]) vf->imgctx.tempimages[0]=newmpimage(w2,h); mpi=vf->imgctx.tempimages[0]; break; } case MPIMGTYPEIP: if(!vf->imgctx.staticimages[vf->imgctx.staticidx]) vf->imgctx.staticimages[vf->imgctx.staticidx]=newmpimage(w2,h); mpi=vf->imgctx.staticimages[vf->imgctx.staticidx]; vf->imgctx.staticidx^=1; break; case MPIMGTYPENUMBERED: if (number == -1) { int i; for (i = 0; i < NUMNUMBEREDMPI; i++) if (!vf->imgctx.numberedimages[i] || !vf->imgctx.numberedimages[i]->usagecount) break; number = i; } if (number < 0 || number >= NUMNUMBEREDMPI) return NULL; if (!vf->imgctx.numberedimages[number]) vf->imgctx.numberedimages[number] = newmpimage(w2,h); mpi = vf->imgctx.numberedimages[number]; mpi->number = number; break; } if(mpi){ mpi->type=mpimgtype; mpi->w=vf->w; mpi->h=vf->h; // keep buffer allocation status & color flags only: // mpi->flags&=~(MPIMGFLAGPRESERVE|MPIMGFLAGREADABLE|MPIMGFLAGDIRECT); mpi->flags&=MPIMGFLAGALLOCATED|MPIMGFLAGTYPEDISPLAYED|MPIMGFLAGMASKCOLORS; // accept restrictions, drawslice and palette flags only: mpi->flags|=mpimgflag&(MPIMGFLAGMASKRESTRICTIONS|MPIMGFLAGDRAWCALLBACK|MPIMGFLAGRGBPALETTE); if(!vf->drawslice) mpi->flags&=~MPIMGFLAGDRAWCALLBACK; if(mpi->width!=w2 || mpi->height!=h){ // printf(\"vf.c: MPI parameters changed! %dx%d -> %dx%d \\n\", mpi->width,mpi->height,w2,h); if(mpi->flags&MPIMGFLAGALLOCATED){ if(mpi->width<w2 || mpi->height<h){ // need to re-allocate buffer memory: avfree(mpi->planes[0]); mpi->flags&=~MPIMGFLAGALLOCATED; mpmsg(MSGTVFILTER,MSGLV,\"vf.c: have to REALLOCATE buffer memory :(\\n\"); } // } else { } { mpi->width=w2; mpi->chromawidth=(w2 + (1<<mpi->chromaxshift) - 1)>>mpi->chromaxshift; mpi->height=h; mpi->chromaheight=(h + (1<<mpi->chromayshift) - 1)>>mpi->chromayshift; } } if(!mpi->bpp) mpimagesetfmt(mpi,outfmt); if(!(mpi->flags&MPIMGFLAGALLOCATED) && mpi->type>MPIMGTYPEEXPORT){ avassert0(!vf->getimage); // check libvo first! if(vf->getimage) vf->getimage(vf,mpi); if(!(mpi->flags&MPIMGFLAGDIRECT)){ // non-direct and not yet allocated image. allocate it! if (!mpi->bpp) { // no way we can allocate this mpmsg(MSGTDECVIDEO, MSGLFATAL, \"vfgetimage: Tried to allocate a format that can not be allocated!\\n\"); return NULL; } // check if codec prefer aligned stride: if(mpimgflag&MPIMGFLAGPREFERALIGNEDSTRIDE){ int align=(mpi->flags&MPIMGFLAGPLANAR && mpi->flags&MPIMGFLAGYUV) ? (8<<mpi->chromaxshift)-1 : 15; // -- maybe FIXME w2=((w+align)&(~align)); if(mpi->width!=w2){ #if 0 // we have to change width... check if we CAN co it: int flags=vf->queryformat(vf,outfmt); // should not fail if(!(flags&3)) mpmsg(MSGTDECVIDEO,MSGLWARN,\"??? vfgetimage{vf->queryformat(outfmt)} failed!\\n\"); // printf(\"query -> 0x%X \\n\",flags); if(flags&VFCAPACCEPTSTRIDE){ #endif mpi->width=w2; mpi->chromawidth=(w2 + (1<<mpi->chromaxshift) - 1)>>mpi->chromaxshift; // } } } mpimageallocplanes(mpi); // printf(\"clearing img!\\n\"); vfmpiclear(mpi,0,0,mpi->width,mpi->height); } } avassert0(!vf->startslice); if(mpi->flags&MPIMGFLAGDRAWCALLBACK) if(vf->startslice) vf->startslice(vf,mpi); if(!(mpi->flags&MPIMGFLAGTYPEDISPLAYED)){ mpmsg(MSGTDECVIDEO,MSGLV,\"*** [%s] %s%s mpimaget, %dx%dx%dbpp %s %s, %d bytes\\n\", \"NULL\"/*vf->info->name*/, (mpi->type==MPIMGTYPEEXPORT)?\"Exporting\": ((mpi->flags&MPIMGFLAGDIRECT)?\"Direct Rendering\":\"Allocating\"), (mpi->flags&MPIMGFLAGDRAWCALLBACK)?\" (slices)\":\"\", mpi->width,mpi->height,mpi->bpp, (mpi->flags&MPIMGFLAGYUV)?\"YUV\":((mpi->flags&MPIMGFLAGSWAPPED)?\"BGR\":\"RGB\"), (mpi->flags&MPIMGFLAGPLANAR)?\"planar\":\"packed\", mpi->bpp*mpi->width*mpi->height/8); mpmsg(MSGTDECVIDEO,MSGLDBG2,\"(imgfmt: %x, planes: %p,%p,%p strides: %d,%d,%d, chroma: %dx%d, shift: h:%d,v:%d)\\n\", mpi->imgfmt, mpi->planes[0], mpi->planes[1], mpi->planes[2], mpi->stride[0], mpi->stride[1], mpi->stride[2], mpi->chromawidth, mpi->chromaheight, mpi->chromaxshift, mpi->chromayshift); mpi->flags|=MPIMGFLAGTYPEDISPLAYED; } mpi->qscale = NULL; } mpi->usagecount++; // printf(\"\\rVFMPI: %p %p %p %d %d %d \\n\", // mpi->planes[0],mpi->planes[1],mpi->planes[2], // mpi->stride[0],mpi->stride[1],mpi->stride[2]); return mpi; } ", "target": 1}
{"func": "static int parseMP4SLDescrTag(MP4DescrParseContext *d, int64t off, int len) { Mp4Descr *descr = d->activedescr; int predefined; if (!descr) return -1; predefined = avior8(&d->pb); if (!predefined) { int lengths; int flags = avior8(&d->pb); descr->sl.useaustart = !!(flags & 0x80); descr->sl.useauend = !!(flags & 0x40); descr->sl.userandaccpt = !!(flags & 0x20); descr->sl.usepadding = !!(flags & 0x08); descr->sl.usetimestamps = !!(flags & 0x04); descr->sl.useidle = !!(flags & 0x02); descr->sl.timestampres = aviorb32(&d->pb); aviorb32(&d->pb); descr->sl.timestamplen = avior8(&d->pb); descr->sl.ocrlen = avior8(&d->pb); descr->sl.aulen = avior8(&d->pb); descr->sl.instbitratelen = avior8(&d->pb); lengths = aviorb16(&d->pb); descr->sl.degrpriorlen = lengths >> 12; descr->sl.auseqnumlen = (lengths >> 7) & 0x1f; descr->sl.packetseqnumlen = (lengths >> 2) & 0x1f; } else { avprivreportmissingfeature(d->s, \"Predefined SLConfigDescriptor\"); return 0; ", "target": 1}
{"func": "targetulong helpermulsuov(CPUTriCoreState *env, targetulong r1, targetulong r2) { int64t t1 = extract64(r1, 0, 32); int64t t2 = extract64(r2, 0, 32); int64t result = t1 * t2; return suov32(env, result); } ", "target": 1}
{"func": "static int parsechunks(AVFormatContext *s, int mode, int64t seekts, int *lenptr) { WtvContext *wtv = s->privdata; AVIOContext *pb = wtv->pb; while (!urlfeof(pb)) { ffasfguid g; int len, sid, consumed; ffgetguid(pb, &g); len = aviorl32(pb); if (len < 32) break; sid = aviorl32(pb) & 0x7FFF; avioskip(pb, 8); consumed = 32; if (!ffguidcmp(g, ffSBE2STREAMDESCEVENT)) { if (fffindstreamindex(s, sid) < 0) { ffasfguid mediatype, subtype, formattype; int size; avioskip(pb, 28); ffgetguid(pb, &mediatype); ffgetguid(pb, &subtype); avioskip(pb, 12); ffgetguid(pb, &formattype); size = aviorl32(pb); parsemediatype(s, 0, sid, mediatype, subtype, formattype, size); consumed += 92 + size; } } else if (!ffguidcmp(g, ffstream2guid)) { int streamindex = fffindstreamindex(s, sid); if (streamindex >= 0 && !((WtvStream*)s->streams[streamindex]->privdata)->seendata) { ffasfguid mediatype, subtype, formattype; int size; avioskip(pb, 12); ffgetguid(pb, &mediatype); ffgetguid(pb, &subtype); avioskip(pb, 12); ffgetguid(pb, &formattype); size = aviorl32(pb); parsemediatype(s, s->streams[streamindex], sid, mediatype, subtype, formattype, size); consumed += 76 + size; } } else if (!ffguidcmp(g, EVENTIDAudioDescriptorSpanningEvent) || !ffguidcmp(g, EVENTIDCtxADescriptorSpanningEvent) || !ffguidcmp(g, EVENTIDCSDescriptorSpanningEvent) || !ffguidcmp(g, EVENTIDStreamIDSpanningEvent) || !ffguidcmp(g, EVENTIDSubtitleSpanningEvent) || !ffguidcmp(g, EVENTIDTeletextSpanningEvent)) { int streamindex = fffindstreamindex(s, sid); if (streamindex >= 0) { AVStream *st = s->streams[streamindex]; uint8t buf[258]; const uint8t *pbuf = buf; int bufsize; avioskip(pb, 8); consumed += 8; if (!ffguidcmp(g, EVENTIDCtxADescriptorSpanningEvent) || !ffguidcmp(g, EVENTIDCSDescriptorSpanningEvent)) { avioskip(pb, 6); consumed += 6; } bufsize = FFMIN(len - consumed, sizeof(buf)); avioread(pb, buf, bufsize); consumed += bufsize; ffparsempeg2descriptor(s, st, 0, &pbuf, buf + bufsize, NULL, 0, 0, NULL); } } else if (!ffguidcmp(g, EVENTIDAudioTypeSpanningEvent)) { int streamindex = fffindstreamindex(s, sid); if (streamindex >= 0) { AVStream *st = s->streams[streamindex]; int audiotype; avioskip(pb, 8); audiotype = avior8(pb); if (audiotype == 2) st->disposition |= AVDISPOSITIONHEARINGIMPAIRED; else if (audiotype == 3) st->disposition |= AVDISPOSITIONVISUALIMPAIRED; consumed += 9; } } else if (!ffguidcmp(g, EVENTIDDVBScramblingControlSpanningEvent)) { int streamindex = fffindstreamindex(s, sid); if (streamindex >= 0) { avioskip(pb, 12); if (aviorl32(pb)) avlog(s, AVLOGWARNING, \"DVB scrambled stream detected (st:%d), decoding will likely fail\\n\", streamindex); consumed += 16; } } else if (!ffguidcmp(g, EVENTIDLanguageSpanningEvent)) { int streamindex = fffindstreamindex(s, sid); if (streamindex >= 0) { AVStream *st = s->streams[streamindex]; uint8t language[4]; avioskip(pb, 12); avioread(pb, language, 3); if (language[0]) { language[3] = 0; avdictset(&st->metadata, \"language\", language, 0); if (!strcmp(language, \"nar\") || !strcmp(language, \"NAR\")) st->disposition |= AVDISPOSITIONVISUALIMPAIRED; } consumed += 15; } } else if (!ffguidcmp(g, fftimestampguid)) { int streamindex = fffindstreamindex(s, sid); if (streamindex >= 0) { avioskip(pb, 8); wtv->pts = aviorl64(pb); consumed += 16; if (wtv->pts == -1) wtv->pts = AVNOPTSVALUE; else { wtv->lastvalidpts = wtv->pts; if (wtv->epoch == AVNOPTSVALUE || wtv->pts < wtv->epoch) wtv->epoch = wtv->pts; if (mode == SEEKTOPTS && wtv->pts >= seekts) { avioskip(pb, WTVPAD8(len) - consumed); return 0; } } } } else if (!ffguidcmp(g, ffdataguid)) { int streamindex = fffindstreamindex(s, sid); if (mode == SEEKTODATA && streamindex >= 0 && len > 32 && s->streams[streamindex]->privdata) { WtvStream *wst = s->streams[streamindex]->privdata; wst->seendata = 1; if (lenptr) { *lenptr = len; } return streamindex; } } else if (!ffguidcmp(g, /* DSATTRIBWMDRMProtectionInfo */ (const ffasfguid){0x83,0x95,0x74,0x40,0x9D,0x6B,0xEC,0x4E,0xB4,0x3C,0x67,0xA1,0x80,0x1E,0x1A,0x9B})) { int streamindex = fffindstreamindex(s, sid); if (streamindex >= 0) avlog(s, AVLOGWARNING, \"encrypted stream detected (st:%d), decoding will likely fail\\n\", streamindex); } else if ( !ffguidcmp(g, /* DSATTRIBCAPTURESTREAMTIME */ (const ffasfguid){0x14,0x56,0x1A,0x0C,0xCD,0x30,0x40,0x4F,0xBC,0xBF,0xD0,0x3E,0x52,0x30,0x62,0x07}) || !ffguidcmp(g, /* DSATTRIBPBDATAGATTRIBUTE */ (const ffasfguid){0x79,0x66,0xB5,0xE0,0xB9,0x12,0xCC,0x43,0xB7,0xDF,0x57,0x8C,0xAA,0x5A,0x7B,0x63}) || !ffguidcmp(g, /* DSATTRIBPicSampleSeq */ (const ffasfguid){0x02,0xAE,0x5B,0x2F,0x8F,0x7B,0x60,0x4F,0x82,0xD6,0xE4,0xEA,0x2F,0x1F,0x4C,0x99}) || !ffguidcmp(g, /* DSATTRIBTRANSPORTPROPERTIES */ ffDSATTRIBTRANSPORTPROPERTIES) || !ffguidcmp(g, /* dvrmsvidframerepdata */ (const ffasfguid){0xCC,0x32,0x64,0xDD,0x29,0xE2,0xDB,0x40,0x80,0xF6,0xD2,0x63,0x28,0xD2,0x76,0x1F}) || !ffguidcmp(g, /* EVENTIDChannelChangeSpanningEvent */ (const ffasfguid){0xE5,0xC5,0x67,0x90,0x5C,0x4C,0x05,0x42,0x86,0xC8,0x7A,0xFE,0x20,0xFE,0x1E,0xFA}) || !ffguidcmp(g, /* EVENTIDChannelInfoSpanningEvent */ (const ffasfguid){0x80,0x6D,0xF3,0x41,0x32,0x41,0xC2,0x4C,0xB1,0x21,0x01,0xA4,0x32,0x19,0xD8,0x1B}) || !ffguidcmp(g, /* EVENTIDChannelTypeSpanningEvent */ (const ffasfguid){0x51,0x1D,0xAB,0x72,0xD2,0x87,0x9B,0x48,0xBA,0x11,0x0E,0x08,0xDC,0x21,0x02,0x43}) || !ffguidcmp(g, /* EVENTIDPIDListSpanningEvent */ (const ffasfguid){0x65,0x8F,0xFC,0x47,0xBB,0xE2,0x34,0x46,0x9C,0xEF,0xFD,0xBF,0xE6,0x26,0x1D,0x5C}) || !ffguidcmp(g, /* EVENTIDSignalAndServiceStatusSpanningEvent */ (const ffasfguid){0xCB,0xC5,0x68,0x80,0x04,0x3C,0x2B,0x49,0xB4,0x7D,0x03,0x08,0x82,0x0D,0xCE,0x51}) || !ffguidcmp(g, /* EVENTIDStreamTypeSpanningEvent */ (const ffasfguid){0xBC,0x2E,0xAF,0x82,0xA6,0x30,0x64,0x42,0xA8,0x0B,0xAD,0x2E,0x13,0x72,0xAC,0x60}) || !ffguidcmp(g, (const ffasfguid){0x1E,0xBE,0xC3,0xC5,0x43,0x92,0xDC,0x11,0x85,0xE5,0x00,0x12,0x3F,0x6F,0x73,0xB9}) || !ffguidcmp(g, (const ffasfguid){0x3B,0x86,0xA2,0xB1,0xEB,0x1E,0xC3,0x44,0x8C,0x88,0x1C,0xA3,0xFF,0xE3,0xE7,0x6A}) || !ffguidcmp(g, (const ffasfguid){0x4E,0x7F,0x4C,0x5B,0xC4,0xD0,0x38,0x4B,0xA8,0x3E,0x21,0x7F,0x7B,0xBF,0x52,0xE7}) || !ffguidcmp(g, (const ffasfguid){0x63,0x36,0xEB,0xFE,0xA1,0x7E,0xD9,0x11,0x83,0x08,0x00,0x07,0xE9,0x5E,0xAD,0x8D}) || !ffguidcmp(g, (const ffasfguid){0x70,0xE9,0xF1,0xF8,0x89,0xA4,0x4C,0x4D,0x83,0x73,0xB8,0x12,0xE0,0xD5,0xF8,0x1E}) || !ffguidcmp(g, ffindexguid) || !ffguidcmp(g, ffsyncguid) || !ffguidcmp(g, ffstream1guid) || !ffguidcmp(g, (const ffasfguid){0xF7,0x10,0x02,0xB9,0xEE,0x7C,0xED,0x4E,0xBD,0x7F,0x05,0x40,0x35,0x86,0x18,0xA1})) { //ignore known guids } else avlog(s, AVLOGWARNING, \"unsupported chunk:\"FFPRIGUID\"\\n\", FFARGGUID(g)); avioskip(pb, WTVPAD8(len) - consumed); } return AVERROREOF; } ", "target": 1}
{"func": "static void virtiorngclassinit(ObjectClass *klass, void *data) { DeviceClass *dc = DEVICECLASS(klass); VirtioDeviceClass *vdc = VIRTIODEVICECLASS(klass); dc->props = virtiorngproperties; setbit(DEVICECATEGORYMISC, dc->categories); vdc->realize = virtiorngdevicerealize; vdc->unrealize = virtiorngdeviceunrealize; vdc->getfeatures = getfeatures; vdc->load = virtiorngloaddevice; } ", "target": 1}
{"func": "int kvminit(int smpcpus) { KVMState *s; int ret; int i; if (smpcpus > 1) return -EINVAL; s = qemumallocz(sizeof(KVMState)); if (s == NULL) return -ENOMEM; for (i = 0; i < ARRAYSIZE(s->slots); i++) s->slots[i].slot = i; s->vmfd = -1; s->fd = open(\"/dev/kvm\", ORDWR); if (s->fd == -1) { fprintf(stderr, \"Could not access KVM kernel module: %m\\n\"); ret = -errno; goto err; } ret = kvmioctl(s, KVMGETAPIVERSION, 0); if (ret < KVMAPIVERSION) { ret = -EINVAL; fprintf(stderr, \"kvm version too old\\n\"); goto err; } if (ret > KVMAPIVERSION) { ret = -EINVAL; fprintf(stderr, \"kvm version not supported\\n\"); goto err; } s->vmfd = kvmioctl(s, KVMCREATEVM, 0); if (s->vmfd < 0) goto err; /* initially, KVM allocated its own memory and we had to jump through * hooks to make physrambase point to this. Modern versions of KVM * just use a user allocated buffer so we can use physrambase * unmodified. Make sure we have a sufficiently modern version of KVM. */ ret = kvmioctl(s, KVMCHECKEXTENSION, KVMCAPUSERMEMORY); if (ret <= 0) { if (ret == 0) ret = -EINVAL; fprintf(stderr, \"kvm does not support KVMCAPUSERMEMORY\\n\"); goto err; } /* There was a nasty bug in < kvm-80 that prevents memory slots from being * destroyed properly. Since we rely on this capability, refuse to work * with any kernel without this capability. */ ret = kvmioctl(s, KVMCHECKEXTENSION, KVMCAPDESTROYMEMORYREGIONWORKS); if (ret <= 0) { if (ret == 0) ret = -EINVAL; fprintf(stderr, \"KVM kernel module broken (DESTROYMEMORYREGION)\\n\" \"Please upgrade to at least kvm-81.\\n\"); goto err; } ret = kvmarchinit(s, smpcpus); if (ret < 0) goto err; kvmstate = s; return 0; err: if (s) { if (s->vmfd != -1) close(s->vmfd); if (s->fd != -1) close(s->fd); } qemufree(s); return ret; }", "target": 1}
{"func": "static int64t nfsclientopen(NFSClient *client, const char *filename, int flags, Error **errp) { int ret = -EINVAL, i; struct stat st; URI *uri; QueryParams *qp = NULL; char *file = NULL, *strp = NULL; uri = uriparse(filename); if (!uri) { errorsetg(errp, \"Invalid URL specified\"); goto fail; } if (!uri->server) { errorsetg(errp, \"Invalid URL specified\"); goto fail; } strp = strrchr(uri->path, '/'); if (strp == NULL) { errorsetg(errp, \"Invalid URL specified\"); goto fail; } file = gstrdup(strp); *strp = 0; client->context = nfsinitcontext(); if (client->context == NULL) { errorsetg(errp, \"Failed to init NFS context\"); goto fail; } qp = queryparamsparse(uri->query); for (i = 0; i < qp->n; i++) { if (!qp->p[i].value) { errorsetg(errp, \"Value for NFS parameter expected: %s\", qp->p[i].name); goto fail; } if (!strncmp(qp->p[i].name, \"uid\", 3)) { nfssetuid(client->context, atoi(qp->p[i].value)); } else if (!strncmp(qp->p[i].name, \"gid\", 3)) { nfssetgid(client->context, atoi(qp->p[i].value)); } else if (!strncmp(qp->p[i].name, \"tcp-syncnt\", 10)) { nfssettcpsyncnt(client->context, atoi(qp->p[i].value)); } else { errorsetg(errp, \"Unknown NFS parameter name: %s\", qp->p[i].name); goto fail; } } ret = nfsmount(client->context, uri->server, uri->path); if (ret < 0) { errorsetg(errp, \"Failed to mount nfs share: %s\", nfsgeterror(client->context)); goto fail; } if (flags & OCREAT) { ret = nfscreat(client->context, file, 0600, &client->fh); if (ret < 0) { errorsetg(errp, \"Failed to create file: %s\", nfsgeterror(client->context)); goto fail; } } else { ret = nfsopen(client->context, file, flags, &client->fh); if (ret < 0) { errorsetg(errp, \"Failed to open file : %s\", nfsgeterror(client->context)); goto fail; } } ret = nfsfstat(client->context, client->fh, &st); if (ret < 0) { errorsetg(errp, \"Failed to fstat file: %s\", nfsgeterror(client->context)); goto fail; } ret = DIVROUNDUP(st.stsize, BDRVSECTORSIZE); client->haszeroinit = SISREG(st.stmode); goto out; fail: nfsclientclose(client); out: if (qp) { queryparamsfree(qp); } urifree(uri); gfree(file); return ret; } ", "target": 1}
{"func": "static int nutreadheader(AVFormatContext * avf, AVFormatParameters * ap) { NUTContext * priv = avf->privdata; AVIOContext * bc = avf->pb; nutdemuxeroptstt dopts = { .input = { .priv = bc, .seek = avseek, .read = avread, .eof = NULL, .filepos = 0, }, .alloc = { avmalloc, avrealloc, avfree }, .readindex = 1, .cachesyncpoints = 1, }; nutcontexttt * nut = priv->nut = nutdemuxerinit(&dopts); nutstreamheadertt * s; int ret, i; if ((ret = nutreadheaders(nut, &s, NULL))) { avlog(avf, AVLOGERROR, \" NUT error: %s\\n\", nuterror(ret)); return -1; priv->s = s; for (i = 0; s[i].type != -1 && i < 2; i++) { AVStream * st = avformatnewstream(avf, NULL); int j; for (j = 0; j < s[i].fourcclen && j < 8; j++) st->codec->codectag |= s[i].fourcc[j]<<(j*8); st->codec->hasbframes = s[i].decodedelay; st->codec->extradatasize = s[i].codecspecificlen; if (st->codec->extradatasize) { st->codec->extradata = avmallocz(st->codec->extradatasize); memcpy(st->codec->extradata, s[i].codecspecific, st->codec->extradatasize); avprivsetptsinfo(avf->streams[i], 60, s[i].timebase.num, s[i].timebase.den); st->starttime = 0; st->duration = s[i].maxpts; st->codec->codecid = ffcodecgetid(nuttags, st->codec->codectag); switch(s[i].type) { case NUTAUDIOCLASS: st->codec->codectype = AVMEDIATYPEAUDIO; if (st->codec->codecid == CODECIDNONE) st->codec->codecid = ffcodecgetid(ffcodecwavtags, st->codec->codectag); st->codec->channels = s[i].channelcount; st->codec->samplerate = s[i].sampleratenum / s[i].sampleratedenom; break; case NUTVIDEOCLASS: st->codec->codectype = AVMEDIATYPEVIDEO; if (st->codec->codecid == CODECIDNONE) st->codec->codecid = ffcodecgetid(ffcodecbmptags, st->codec->codectag); st->codec->width = s[i].width; st->codec->height = s[i].height; st->sampleaspectratio.num = s[i].samplewidth; st->sampleaspectratio.den = s[i].sampleheight; break; if (st->codec->codecid == CODECIDNONE) avlog(avf, AVLOGERROR, \"Unknown codec?!\\n\"); return 0; ", "target": 1}
{"func": "static void ppccpurealizefn(DeviceState *dev, Error **errp) { CPUState *cs = CPU(dev); PowerPCCPU *cpu = POWERPCCPU(dev); PowerPCCPUClass *pcc = POWERPCCPUGETCLASS(cpu); Error *localerr = NULL; #if !defined(CONFIGUSERONLY) int maxsmt = kvmenabled() ? kvmppcsmtthreads() : 1; #endif #if !defined(CONFIGUSERONLY) if (smpthreads > maxsmt) { errorsetg(errp, \"Cannot support more than %d threads on PPC with %s\", maxsmt, kvmenabled() ? \"KVM\" : \"TCG\"); if (!ispowerof2(smpthreads)) { errorsetg(errp, \"Cannot support %d threads on PPC with %s, \" \"threads count must be a power of 2.\", smpthreads, kvmenabled() ? \"KVM\" : \"TCG\"); #endif cpuexecinit(cs, &localerr); if (localerr != NULL) { errorpropagate(errp, localerr); #if !defined(CONFIGUSERONLY) cpu->cpudtid = (cs->cpuindex / smpthreads) * maxsmt + (cs->cpuindex % smpthreads); #endif if (tcgenabled()) { if (ppcfixupcpu(cpu) != 0) { errorsetg(errp, \"Unable to emulate selected CPU with TCG\"); #if defined(TARGETPPCEMB) if (!ppccpuisvalid(pcc)) { errorsetg(errp, \"CPU does not possess a BookE or 4xx MMU. \" \"Please use qemu-system-ppc or qemu-system-ppc64 instead \" \"or choose another CPU model.\"); #endif createppcopcodes(cpu, &localerr); if (localerr != NULL) { errorpropagate(errp, localerr); initppcproc(cpu); if (pcc->insnsflags & PPCFLOAT) { gdbregistercoprocessor(cs, gdbgetfloatreg, gdbsetfloatreg, 33, \"power-fpu.xml\", 0); if (pcc->insnsflags & PPCALTIVEC) { gdbregistercoprocessor(cs, gdbgetavrreg, gdbsetavrreg, 34, \"power-altivec.xml\", 0); if (pcc->insnsflags & PPCSPE) { gdbregistercoprocessor(cs, gdbgetspereg, gdbsetspereg, 34, \"power-spe.xml\", 0); if (pcc->insnsflags2 & PPC2VSX) { gdbregistercoprocessor(cs, gdbgetvsxreg, gdbsetvsxreg, 32, \"power-vsx.xml\", 0); qemuinitvcpu(cs); pcc->parentrealize(dev, errp); #if defined(PPCDUMPCPU) { CPUPPCState *env = &cpu->env; const char *mmumodel, *excpmodel, *busmodel; switch (env->mmumodel) { case POWERPCMMU32B: mmumodel = \"PowerPC 32\"; break; case POWERPCMMUSOFT6xx: mmumodel = \"PowerPC 6xx/7xx with software driven TLBs\"; break; case POWERPCMMUSOFT74xx: mmumodel = \"PowerPC 74xx with software driven TLBs\"; break; case POWERPCMMUSOFT4xx: mmumodel = \"PowerPC 4xx with software driven TLBs\"; break; case POWERPCMMUSOFT4xxZ: mmumodel = \"PowerPC 4xx with software driven TLBs \" \"and zones protections\"; break; case POWERPCMMUREAL: mmumodel = \"PowerPC real mode only\"; break; case POWERPCMMUMPC8xx: mmumodel = \"PowerPC MPC8xx\"; break; case POWERPCMMUBOOKE: mmumodel = \"PowerPC BookE\"; break; case POWERPCMMUBOOKE206: mmumodel = \"PowerPC BookE 2.06\"; break; case POWERPCMMU601: mmumodel = \"PowerPC 601\"; break; #if defined (TARGETPPC64) case POWERPCMMU64B: mmumodel = \"PowerPC 64\"; break; #endif default: mmumodel = \"Unknown or invalid\"; break; switch (env->excpmodel) { case POWERPCEXCPSTD: excpmodel = \"PowerPC\"; break; case POWERPCEXCP40x: excpmodel = \"PowerPC 40x\"; break; case POWERPCEXCP601: excpmodel = \"PowerPC 601\"; break; case POWERPCEXCP602: excpmodel = \"PowerPC 602\"; break; case POWERPCEXCP603: excpmodel = \"PowerPC 603\"; break; case POWERPCEXCP603E: excpmodel = \"PowerPC 603e\"; break; case POWERPCEXCP604: excpmodel = \"PowerPC 604\"; break; case POWERPCEXCP7x0: excpmodel = \"PowerPC 740/750\"; break; case POWERPCEXCP7x5: excpmodel = \"PowerPC 745/755\"; break; case POWERPCEXCP74xx: excpmodel = \"PowerPC 74xx\"; break; case POWERPCEXCPBOOKE: excpmodel = \"PowerPC BookE\"; break; #if defined (TARGETPPC64) case POWERPCEXCP970: excpmodel = \"PowerPC 970\"; break; #endif default: excpmodel = \"Unknown or invalid\"; break; switch (env->busmodel) { case PPCFLAGSINPUT6xx: busmodel = \"PowerPC 6xx\"; break; case PPCFLAGSINPUTBookE: busmodel = \"PowerPC BookE\"; break; case PPCFLAGSINPUT405: busmodel = \"PowerPC 405\"; break; case PPCFLAGSINPUT401: busmodel = \"PowerPC 401/403\"; break; case PPCFLAGSINPUTRCPU: busmodel = \"RCPU / MPC8xx\"; break; #if defined (TARGETPPC64) case PPCFLAGSINPUT970: busmodel = \"PowerPC 970\"; break; #endif default: busmodel = \"Unknown or invalid\"; break; printf(\"PowerPC %-12s : PVR %08x MSR %016\" PRIx64 \"\\n\" \" MMU model : %s\\n\", objectclassgetname(OBJECTCLASS(pcc)), pcc->pvr, pcc->msrmask, mmumodel); #if !defined(CONFIGUSERONLY) if (env->tlb.tlb6) { printf(\" %d %s TLB in %d ways\\n\", env->nbtlb, env->idtlbs ? \"splitted\" : \"merged\", env->nbways); #endif printf(\" Exceptions model : %s\\n\" \" Bus model : %s\\n\", excpmodel, busmodel); printf(\" MSR features :\\n\"); if (env->flags & POWERPCFLAGSPE) printf(\" signal processing engine enable\" \"\\n\"); else if (env->flags & POWERPCFLAGVRE) printf(\" vector processor enable\\n\"); if (env->flags & POWERPCFLAGTGPR) printf(\" temporary GPRs\\n\"); else if (env->flags & POWERPCFLAGCE) printf(\" critical input enable\\n\"); if (env->flags & POWERPCFLAGSE) printf(\" single-step trace mode\\n\"); else if (env->flags & POWERPCFLAGDWE) printf(\" debug wait enable\\n\"); else if (env->flags & POWERPCFLAGUBLE) printf(\" user BTB lock enable\\n\"); if (env->flags & POWERPCFLAGBE) printf(\" branch-step trace mode\\n\"); else if (env->flags & POWERPCFLAGDE) printf(\" debug interrupt enable\\n\"); if (env->flags & POWERPCFLAGPX) printf(\" inclusive protection\\n\"); else if (env->flags & POWERPCFLAGPMM) printf(\" performance monitor mark\\n\"); if (env->flags == POWERPCFLAGNONE) printf(\" none\\n\"); printf(\" Time-base/decrementer clock source: %s\\n\", env->flags & POWERPCFLAGRTCCLK ? \"RTC clock\" : \"bus clock\"); dumpppcinsns(env); dumpppcsprs(env); fflush(stdout); #endif", "target": 1}
{"func": "static void raminit(targetphysaddrt addr, ramaddrt RAMsize) { DeviceState *dev; SysBusDevice *s; RamDevice *d; /* allocate RAM */ dev = qdevcreate(NULL, \"memory\"); s = sysbusfromqdev(dev); d = FROMSYSBUS(RamDevice, s); d->size = RAMsize; qdevinit(dev); sysbusmmiomap(s, 0, addr); } ", "target": 1}
{"func": "QemuOpts *qemuchrparsecompat(const char *label, const char *filename) { char host[65], port[33], width[8], height[8]; int pos; const char *p; QemuOpts *opts; Error *localerr = NULL; opts = qemuoptscreate(qemufindopts(\"chardev\"), label, 1, &localerr); if (errorisset(&localerr)) { qerrorreporterr(localerr); errorfree(localerr); return NULL; } if (strstart(filename, \"mon:\", &p)) { filename = p; qemuoptset(opts, \"mux\", \"on\"); if (strcmp(filename, \"stdio\") == 0) { /* Monitor is muxed to stdio: do not exit on Ctrl+C by default * but pass it to the guest. Handle this only for compat syntax, * for -chardev syntax we have special option for this. * This is what -nographic did, redirecting+muxing serial+monitor * to stdio causing Ctrl+C to be passed to guest. */ qemuoptset(opts, \"signal\", \"off\"); } } if (strcmp(filename, \"null\") == 0 || strcmp(filename, \"pty\") == 0 || strcmp(filename, \"msmouse\") == 0 || strcmp(filename, \"braille\") == 0 || strcmp(filename, \"stdio\") == 0) { qemuoptset(opts, \"backend\", filename); return opts; } if (strstart(filename, \"vc\", &p)) { qemuoptset(opts, \"backend\", \"vc\"); if (*p == ':') { if (sscanf(p+1, \"%8[0-9]x%8[0-9]\", width, height) == 2) { /* pixels */ qemuoptset(opts, \"width\", width); qemuoptset(opts, \"height\", height); } else if (sscanf(p+1, \"%8[0-9]Cx%8[0-9]C\", width, height) == 2) { /* chars */ qemuoptset(opts, \"cols\", width); qemuoptset(opts, \"rows\", height); } else { goto fail; } } return opts; } if (strcmp(filename, \"con:\") == 0) { qemuoptset(opts, \"backend\", \"console\"); return opts; } if (strstart(filename, \"COM\", NULL)) { qemuoptset(opts, \"backend\", \"serial\"); qemuoptset(opts, \"path\", filename); return opts; } if (strstart(filename, \"file:\", &p)) { qemuoptset(opts, \"backend\", \"file\"); qemuoptset(opts, \"path\", p); return opts; } if (strstart(filename, \"pipe:\", &p)) { qemuoptset(opts, \"backend\", \"pipe\"); qemuoptset(opts, \"path\", p); return opts; } if (strstart(filename, \"tcp:\", &p) || strstart(filename, \"telnet:\", &p)) { if (sscanf(p, \"%64[^:]:%32[^,]%n\", host, port, &pos) < 2) { host[0] = 0; if (sscanf(p, \":%32[^,]%n\", port, &pos) < 1) goto fail; } qemuoptset(opts, \"backend\", \"socket\"); qemuoptset(opts, \"host\", host); qemuoptset(opts, \"port\", port); if (p[pos] == ',') { if (qemuoptsdoparse(opts, p+pos+1, NULL) != 0) goto fail; } if (strstart(filename, \"telnet:\", &p)) qemuoptset(opts, \"telnet\", \"on\"); return opts; } if (strstart(filename, \"udp:\", &p)) { qemuoptset(opts, \"backend\", \"udp\"); if (sscanf(p, \"%64[^:]:%32[^@,]%n\", host, port, &pos) < 2) { host[0] = 0; if (sscanf(p, \":%32[^@,]%n\", port, &pos) < 1) { goto fail; } } qemuoptset(opts, \"host\", host); qemuoptset(opts, \"port\", port); if (p[pos] == '@') { p += pos + 1; if (sscanf(p, \"%64[^:]:%32[^,]%n\", host, port, &pos) < 2) { host[0] = 0; if (sscanf(p, \":%32[^,]%n\", port, &pos) < 1) { goto fail; } } qemuoptset(opts, \"localaddr\", host); qemuoptset(opts, \"localport\", port); } return opts; } if (strstart(filename, \"unix:\", &p)) { qemuoptset(opts, \"backend\", \"socket\"); if (qemuoptsdoparse(opts, p, \"path\") != 0) goto fail; return opts; } if (strstart(filename, \"/dev/parport\", NULL) || strstart(filename, \"/dev/ppi\", NULL)) { qemuoptset(opts, \"backend\", \"parport\"); qemuoptset(opts, \"path\", filename); return opts; } if (strstart(filename, \"/dev/\", NULL)) { qemuoptset(opts, \"backend\", \"tty\"); qemuoptset(opts, \"path\", filename); return opts; } fail: qemuoptsdel(opts); return NULL; } ", "target": 1}
{"func": "POWERPCFAMILY(POWER8)(ObjectClass *oc, void *data) { DeviceClass *dc = DEVICECLASS(oc); PowerPCCPUClass *pcc = POWERPCCPUCLASS(oc); dc->fwname = \"PowerPC,POWER8\"; dc->desc = \"POWER8\"; pcc->pvr = CPUPOWERPCPOWER8BASE; pcc->pvrmask = CPUPOWERPCPOWER8MASK; pcc->initproc = initprocPOWER7; pcc->checkpow = checkpownocheck; pcc->insnsflags = PPCINSNSBASE | PPCSTRING | PPCMFTB | PPCFLOAT | PPCFLOATFSEL | PPCFLOATFRES | PPCFLOATFSQRT | PPCFLOATFRSQRTE | PPCFLOATSTFIWX | PPCCACHE | PPCCACHEICBI | PPCCACHEDCBZ | PPCMEMSYNC | PPCMEMEIEIO | PPCMEMTLBIE | PPCMEMTLBSYNC | PPC64B | PPCALTIVEC | PPCSEGMENT64B | PPCSLBI | PPCPOPCNTB | PPCPOPCNTWD; pcc->insnsflags2 = PPC2VSX | PPC2VSX207 | PPC2DFP | PPC2DBRX | PPC2PERMISA206 | PPC2DIVEISA206 | PPC2ATOMICISA206 | PPC2FPCVTISA206; pcc->msrmask = 0x800000000284FF36ULL; pcc->mmumodel = POWERPCMMU206; #if defined(CONFIGSOFTMMU) pcc->handlemmufault = ppchash64handlemmufault; #endif pcc->excpmodel = POWERPCEXCPPOWER7; pcc->busmodel = PPCFLAGSINPUTPOWER7; pcc->bfdmach = bfdmachppc64; pcc->flags = POWERPCFLAGVRE | POWERPCFLAGSE | POWERPCFLAGBE | POWERPCFLAGPMM | POWERPCFLAGBUSCLK | POWERPCFLAGCFAR | POWERPCFLAGVSX; pcc->l1dcachesize = 0x8000; pcc->l1icachesize = 0x8000; }", "target": 1}
{"func": "static int parseobjectsegment(AVCodecContext *avctx, const uint8t *buf, int bufsize) { PGSSubContext *ctx = avctx->privdata; PGSSubObject *object; uint8t sequencedesc; unsigned int rlebitmaplen, width, height; int id; if (bufsize <= 4) return AVERRORINVALIDDATA; bufsize -= 4; id = bytestreamgetbe16(&buf); object = findobject(id, &ctx->objects); if (!object) { if (ctx->objects.count >= MAXEPOCHOBJECTS) { avlog(avctx, AVLOGERROR, \"Too many objects in epoch\\n\"); return AVERRORINVALIDDATA; } object = &ctx->objects.object[ctx->objects.count++]; object->id = id; } /* skip object version number */ buf += 1; /* Read the Sequence Description to determine if start of RLE data or appended to previous RLE */ sequencedesc = bytestreamgetbyte(&buf); if (!(sequencedesc & 0x80)) { /* Additional RLE data */ if (bufsize > object->rleremaininglen) return AVERRORINVALIDDATA; memcpy(object->rle + object->rledatalen, buf, bufsize); object->rledatalen += bufsize; object->rleremaininglen -= bufsize; return 0; } if (bufsize <= 7) return AVERRORINVALIDDATA; bufsize -= 7; /* Decode rle bitmap length, stored size includes width/height data */ rlebitmaplen = bytestreamgetbe24(&buf) - 2*2; if (bufsize > rlebitmaplen) { avlog(avctx, AVLOGERROR, \"Buffer dimension %d larger than the expected RLE data %d\\n\", bufsize, rlebitmaplen); return AVERRORINVALIDDATA; } /* Get bitmap dimensions from data */ width = bytestreamgetbe16(&buf); height = bytestreamgetbe16(&buf); /* Make sure the bitmap is not too large */ if (avctx->width < width || avctx->height < height || !width || !height) { avlog(avctx, AVLOGERROR, \"Bitmap dimensions (%dx%d) invalid.\\n\", width, height); return AVERRORINVALIDDATA; } object->w = width; object->h = height; avfastpaddedmalloc(&object->rle, &object->rlebuffersize, rlebitmaplen); if (!object->rle) return AVERROR(ENOMEM); memcpy(object->rle, buf, bufsize); object->rledatalen = bufsize; object->rleremaininglen = rlebitmaplen - bufsize; return 0; } ", "target": 0}
{"func": "static int qemurdmaregisterandgetkeys(RDMAContext *rdma, RDMALocalBlock *block, uintptrt hostaddr, uint32t *lkey, uint32t *rkey, int chunk, uint8t *chunkstart, uint8t *chunkend) { if (block->mr) { if (lkey) { *lkey = block->mr->lkey; } if (rkey) { *rkey = block->mr->rkey; } return 0; } /* allocate memory to store chunk MRs */ if (!block->pmr) { block->pmr = gmalloc0(block->nbchunks * sizeof(struct ibvmr *)); } /* * If 'rkey', then we're the destination, so grant access to the source. * * If 'lkey', then we're the source VM, so grant access only to ourselves. */ if (!block->pmr[chunk]) { uint64t len = chunkend - chunkstart; traceqemurdmaregisterandgetkeys(len, chunkstart); block->pmr[chunk] = ibvregmr(rdma->pd, chunkstart, len, (rkey ? (IBVACCESSLOCALWRITE | IBVACCESSREMOTEWRITE) : 0)); if (!block->pmr[chunk]) { perror(\"Failed to register chunk!\"); fprintf(stderr, \"Chunk details: block: %d chunk index %d\" \" start %\" PRIuPTR \" end %\" PRIuPTR \" host %\" PRIuPTR \" local %\" PRIuPTR \" registrations: %d\\n\", block->index, chunk, (uintptrt)chunkstart, (uintptrt)chunkend, hostaddr, (uintptrt)block->localhostaddr, rdma->totalregistrations); return -1; } rdma->totalregistrations++; } if (lkey) { *lkey = block->pmr[chunk]->lkey; } if (rkey) { *rkey = block->pmr[chunk]->rkey; } return 0; } ", "target": 1}
{"func": "static void vgadrawgraphic(VGAState *s, int fullupdate) { int y1, y, update, pagemin, pagemax, linesize, ystart, doublescan, mask, depth; int width, height, shiftcontrol, lineoffset, page0, page1, bwidth, bits; int dispwidth, multiscan, multirun; uint8t *d; uint32t v, addr1, addr; vgadrawlinefunc *vgadrawline; fullupdate |= updatebasicparams(s); if (!fullupdate) vgasyncdirtybitmap(s); s->getresolution(s, &width, &height); dispwidth = width; shiftcontrol = (s->gr[0x05] >> 5) & 3; doublescan = (s->cr[0x09] >> 7); if (shiftcontrol != 1) { multiscan = (((s->cr[0x09] & 0x1f) + 1) << doublescan) - 1; } else { /* in CGA modes, multiscan is ignored */ /* XXX: is it correct ? */ multiscan = doublescan; } multirun = multiscan; if (shiftcontrol != s->shiftcontrol || doublescan != s->doublescan) { fullupdate = 1; s->shiftcontrol = shiftcontrol; s->doublescan = doublescan; } if (shiftcontrol == 0) { fullupdate |= updatepalette16(s); if (s->sr[0x01] & 8) { v = VGADRAWLINE4D2; dispwidth <<= 1; } else { v = VGADRAWLINE4; } bits = 4; } else if (shiftcontrol == 1) { fullupdate |= updatepalette16(s); if (s->sr[0x01] & 8) { v = VGADRAWLINE2D2; dispwidth <<= 1; } else { v = VGADRAWLINE2; } bits = 4; } else { switch(s->getbpp(s)) { default: case 0: fullupdate |= updatepalette256(s); v = VGADRAWLINE8D2; bits = 4; break; case 8: fullupdate |= updatepalette256(s); v = VGADRAWLINE8; bits = 8; break; case 15: v = VGADRAWLINE15; bits = 16; break; case 16: v = VGADRAWLINE16; bits = 16; break; case 24: v = VGADRAWLINE24; bits = 24; break; case 32: v = VGADRAWLINE32; bits = 32; break; } } vgadrawline = vgadrawlinetable[v * NBDEPTHS + getdepthindex(s->ds)]; depth = s->getbpp(s); if (s->lineoffset != s->lastlineoffset || dispwidth != s->lastwidth || height != s->lastheight || s->lastdepth != depth) { if (depth == 16 || depth == 32) { if (isgraphicconsole()) { qemufreedisplaysurface(s->ds->surface); s->ds->surface = qemucreatedisplaysurfacefrom(dispwidth, height, depth, s->lineoffset, s->vramptr + (s->startaddr * 4)); dpyresize(s->ds); } else { qemuconsoleresize(s->ds, dispwidth, height); } } else { qemuconsoleresize(s->ds, dispwidth, height); } s->lastscrwidth = dispwidth; s->lastscrheight = height; s->lastwidth = dispwidth; s->lastheight = height; s->lastlineoffset = s->lineoffset; s->lastdepth = depth; fullupdate = 1; } else if (isgraphicconsole() && isbuffershared(s->ds->surface) && (fullupdate || s->ds->surface->data != s->vramptr + (s->startaddr * 4))) { s->ds->surface->data = s->vramptr + (s->startaddr * 4); dpysetdata(s->ds); } s->rgbtopixel = rgbtopixelduptable[getdepthindex(s->ds)]; if (!isbuffershared(s->ds->surface) && s->cursorinvalidate) s->cursorinvalidate(s); lineoffset = s->lineoffset; #if 0 printf(\"w=%d h=%d v=%d lineoffset=%d cr[0x09]=0x%02x cr[0x17]=0x%02x linecmp=%d sr[0x01]=0x%02x\\n\", width, height, v, lineoffset, s->cr[9], s->cr[0x17], s->linecompare, s->sr[0x01]); #endif addr1 = (s->startaddr * 4); bwidth = (width * bits + 7) / 8; ystart = -1; pagemin = 0x7fffffff; pagemax = -1; d = dsgetdata(s->ds); linesize = dsgetlinesize(s->ds); y1 = 0; for(y = 0; y < height; y++) { addr = addr1; if (!(s->cr[0x17] & 1)) { int shift; /* CGA compatibility handling */ shift = 14 + ((s->cr[0x17] >> 6) & 1); addr = (addr & ~(1 << shift)) | ((y1 & 1) << shift); } if (!(s->cr[0x17] & 2)) { addr = (addr & ~0x8000) | ((y1 & 2) << 14); } page0 = s->vramoffset + (addr & TARGETPAGEMASK); page1 = s->vramoffset + ((addr + bwidth - 1) & TARGETPAGEMASK); update = fullupdate | cpuphysicalmemorygetdirty(page0, VGADIRTYFLAG) | cpuphysicalmemorygetdirty(page1, VGADIRTYFLAG); if ((page1 - page0) > TARGETPAGESIZE) { /* if wide line, can use another page */ update |= cpuphysicalmemorygetdirty(page0 + TARGETPAGESIZE, VGADIRTYFLAG); } /* explicit invalidation for the hardware cursor */ update |= (s->invalidatedytable[y >> 5] >> (y & 0x1f)) & 1; if (update) { if (ystart < 0) ystart = y; if (page0 < pagemin) pagemin = page0; if (page1 > pagemax) pagemax = page1; if (!(isbuffershared(s->ds->surface))) { vgadrawline(s, d, s->vramptr + addr, width); if (s->cursordrawline) s->cursordrawline(s, d, y); } } else { if (ystart >= 0) { /* flush to display */ dpyupdate(s->ds, 0, ystart, dispwidth, y - ystart); ystart = -1; } } if (!multirun) { mask = (s->cr[0x17] & 3) ^ 3; if ((y1 & mask) == mask) addr1 += lineoffset; y1++; multirun = multiscan; } else { multirun--; } /* line compare acts on the displayed lines */ if (y == s->linecompare) addr1 = 0; d += linesize; } if (ystart >= 0) { /* flush to display */ dpyupdate(s->ds, 0, ystart, dispwidth, y - ystart); } /* reset modified pages */ if (pagemax != -1) { cpuphysicalmemoryresetdirty(pagemin, pagemax + TARGETPAGESIZE, VGADIRTYFLAG); } memset(s->invalidatedytable, 0, ((height + 31) >> 5) * 4); } ", "target": 1}
{"func": "static int qemusignalfdcompat(const sigsett *mask) { pthreadattrt attr; pthreadt tid; struct sigfdcompatinfo *info; int fds[2]; info = malloc(sizeof(*info)); if (info == NULL) { errno = ENOMEM; return -1; } if (pipe(fds) == -1) { free(info); return -1; } memcpy(&info->mask, mask, sizeof(*mask)); info->fd = fds[1]; pthreadattrinit(&attr); pthreadattrsetdetachstate(&attr, PTHREADCREATEDETACHED); pthreadcreate(&tid, &attr, sigwaitcompat, info); pthreadattrdestroy(&attr); return fds[0]; } ", "target": 1}
{"func": "static int protocolclientauthsaslstartlen(VncState *vs, uint8t *data, sizet len) { uint32t startlen = readu32(data, 0); VNCDEBUG(\"Got client start len %d\\n\", startlen); if (startlen > SASLDATAMAXLEN) { VNCDEBUG(\"Too much SASL data %d\\n\", startlen); vncclienterror(vs); return -1; } if (startlen == 0) return protocolclientauthsaslstart(vs, NULL, 0); vncreadwhen(vs, protocolclientauthsaslstart, startlen); return 0; } ", "target": 1}
{"func": "static inline void mvpreddirect(AVSContext *h, cavsvector *pmvfw, cavsvector *colmv) { cavsvector *pmvbw = pmvfw + MVBWDOFFS; int den = h->directden[colmv->ref]; int m = FFSIGNBIT(colmv->x); pmvfw->dist = h->dist[1]; pmvbw->dist = h->dist[0]; pmvfw->ref = 1; pmvbw->ref = 0; /* scale the co-located motion vector according to its temporal span */ pmvfw->x = (((den + (den * colmv->x * pmvfw->dist ^ m) - m - 1) >> 14) ^ m) - m; pmvbw->x = m - (((den + (den * colmv->x * pmvbw->dist ^ m) - m - 1) >> 14) ^ m); m = FFSIGNBIT(colmv->y); pmvfw->y = (((den + (den * colmv->y * pmvfw->dist ^ m) - m - 1) >> 14) ^ m) - m; pmvbw->y = m - (((den + (den * colmv->y * pmvbw->dist ^ m) - m - 1) >> 14) ^ m); } ", "target": 1}
{"func": "static inline void h264deblockq1(register vector unsigned char p0, register vector unsigned char p1, register vector unsigned char p2, register vector unsigned char q0, register vector unsigned char tc0) { register vector unsigned char average = vecavg(p0, q0); register vector unsigned char temp; register vector unsigned char uncliped; register vector unsigned char ones; register vector unsigned char max; register vector unsigned char min; temp = vecxor(average, p2); average = vecavg(average, p2); /*avg(p2, avg(p0, q0)) */ ones = vecsplatu8(1); temp = vecand(temp, ones); /*(p2^avg(p0, q0)) & 1 */ uncliped = vecsubs(average, temp); /*(p2+((p0+q0+1)>>1))>>1 */ max = vecadds(p1, tc0); min = vecsubs(p1, tc0); p1 = vecmax(min, uncliped); p1 = vecmin(max, p1); } ", "target": 0}
{"func": "static inline void genbrancha(DisasContext *dc, targetulong pc1, targetulong pc2, TCGv rcond) { int l1; l1 = gennewlabel(); tcggenbrconditl(TCGCONDEQ, rcond, 0, l1); gengototb(dc, 0, pc2, pc1); gensetlabel(l1); gengototb(dc, 1, pc2 + 4, pc2 + 8); } ", "target": 0}
{"func": "uint64t qcow2allocclusteroffset(BlockDriverState *bs, uint64t offset, int nstart, int nend, int *num, QCowL2Meta *m) { BDRVQcowState *s = bs->opaque; int l2index, ret; uint64t l2offset, *l2table, clusteroffset; int nbclusters, i = 0; QCowL2Meta *oldalloc; ret = getclustertable(bs, offset, &l2table, &l2offset, &l2index); if (ret == 0) return 0; nbclusters = sizetoclusters(s, nend << 9); nbclusters = MIN(nbclusters, s->l2size - l2index); clusteroffset = be64tocpu(l2table[l2index]); /* We keep all QCOWOFLAGCOPIED clusters */ if (clusteroffset & QCOWOFLAGCOPIED) { nbclusters = countcontiguousclusters(nbclusters, s->clustersize, &l2table[l2index], 0, 0); clusteroffset &= ~QCOWOFLAGCOPIED; m->nbclusters = 0; goto out; } /* for the moment, multiple compressed clusters are not managed */ if (clusteroffset & QCOWOFLAGCOMPRESSED) nbclusters = 1; /* how many available clusters ? */ while (i < nbclusters) { i += countcontiguousclusters(nbclusters - i, s->clustersize, &l2table[l2index], i, 0); if(be64tocpu(l2table[l2index + i])) break; i += countcontiguousfreeclusters(nbclusters - i, &l2table[l2index + i]); clusteroffset = be64tocpu(l2table[l2index + i]); if ((clusteroffset & QCOWOFLAGCOPIED) || (clusteroffset & QCOWOFLAGCOMPRESSED)) break; } nbclusters = i; /* * Check if there already is an AIO write request in flight which allocates * the same cluster. In this case we need to wait until the previous * request has completed and updated the L2 table accordingly. */ LISTFOREACH(oldalloc, &s->clusterallocs, nextinflight) { uint64t endoffset = offset + nbclusters * s->clustersize; uint64t oldoffset = oldalloc->offset; uint64t oldendoffset = oldalloc->offset + oldalloc->nbclusters * s->clustersize; if (endoffset < oldoffset || offset > oldendoffset) { /* No intersection */ } else { if (offset < oldoffset) { /* Stop at the start of a running allocation */ nbclusters = (oldoffset - offset) >> s->clusterbits; } else { nbclusters = 0; } if (nbclusters == 0) { /* Set dependency and wait for a callback */ m->dependson = oldalloc; m->nbclusters = 0; *num = 0; return 0; } } } if (!nbclusters) { abort(); } LISTINSERTHEAD(&s->clusterallocs, m, nextinflight); /* allocate a new cluster */ clusteroffset = qcow2allocclusters(bs, nbclusters * s->clustersize); /* save info needed for meta data update */ m->offset = offset; m->nstart = nstart; m->nbclusters = nbclusters; out: m->nbavailable = MIN(nbclusters << (s->clusterbits - 9), nend); *num = m->nbavailable - nstart; return clusteroffset; } ", "target": 0}
{"func": "static int txconsume(Rocker *r, DescInfo *info) { PCIDevice *dev = PCIDEVICE(r); char *buf = descgetbuf(info, true); RockerTlv *tlvfrag; RockerTlv *tlvs[ROCKERTLVTXMAX + 1]; struct iovec iov[ROCKERTXFRAGSMAX] = { { 0, }, }; uint32t pport; uint32t port; uint16t txoffload = ROCKERTXOFFLOADNONE; uint16t txl3csumoff = 0; uint16t txtsomss = 0; uint16t txtsohdrlen = 0; int iovcnt = 0; int err = ROCKEROK; int rem; int i; if (!buf) { return -ROCKERENXIO; } rockertlvparse(tlvs, ROCKERTLVTXMAX, buf, desctlvsize(info)); if (!tlvs[ROCKERTLVTXFRAGS]) { return -ROCKEREINVAL; } pport = rockergetpportbytxring(r, descgetring(info)); if (!fpportfrompport(pport, &port)) { return -ROCKEREINVAL; } if (tlvs[ROCKERTLVTXOFFLOAD]) { txoffload = rockertlvgetu8(tlvs[ROCKERTLVTXOFFLOAD]); } switch (txoffload) { case ROCKERTXOFFLOADL3CSUM: if (!tlvs[ROCKERTLVTXL3CSUMOFF]) { return -ROCKEREINVAL; } break; case ROCKERTXOFFLOADTSO: if (!tlvs[ROCKERTLVTXTSOMSS] || !tlvs[ROCKERTLVTXTSOHDRLEN]) { return -ROCKEREINVAL; } break; } if (tlvs[ROCKERTLVTXL3CSUMOFF]) { txl3csumoff = rockertlvgetle16(tlvs[ROCKERTLVTXL3CSUMOFF]); } if (tlvs[ROCKERTLVTXTSOMSS]) { txtsomss = rockertlvgetle16(tlvs[ROCKERTLVTXTSOMSS]); } if (tlvs[ROCKERTLVTXTSOHDRLEN]) { txtsohdrlen = rockertlvgetle16(tlvs[ROCKERTLVTXTSOHDRLEN]); } rockertlvforeachnested(tlvfrag, tlvs[ROCKERTLVTXFRAGS], rem) { hwaddr fragaddr; uint16t fraglen; if (rockertlvtype(tlvfrag) != ROCKERTLVTXFRAG) { err = -ROCKEREINVAL; goto errbadattr; } rockertlvparsenested(tlvs, ROCKERTLVTXFRAGATTRMAX, tlvfrag); if (!tlvs[ROCKERTLVTXFRAGATTRADDR] || !tlvs[ROCKERTLVTXFRAGATTRLEN]) { err = -ROCKEREINVAL; goto errbadattr; } fragaddr = rockertlvgetle64(tlvs[ROCKERTLVTXFRAGATTRADDR]); fraglen = rockertlvgetle16(tlvs[ROCKERTLVTXFRAGATTRLEN]); iov[iovcnt].iovlen = fraglen; iov[iovcnt].iovbase = gmalloc(fraglen); if (!iov[iovcnt].iovbase) { err = -ROCKERENOMEM; goto errnomem; } if (pcidmaread(dev, fragaddr, iov[iovcnt].iovbase, iov[iovcnt].iovlen)) { err = -ROCKERENXIO; goto errbadio; } if (++iovcnt > ROCKERTXFRAGSMAX) { goto errtoomanyfrags; } } if (iovcnt) { /* XXX perform Tx offloads */ /* XXX silence compiler for now */ txl3csumoff += txtsomss = txtsohdrlen = 0; } err = fpporteg(r->fpport[port], iov, iovcnt); errtoomanyfrags: errbadio: errnomem: errbadattr: for (i = 0; i < ROCKERTXFRAGSMAX; i++) { if (iov[i].iovbase) { gfree(iov[i].iovbase); } } return err; } ", "target": 0}
{"func": "AVFilterFormats *avfilterallcolorspaces(void) { return avfiltermakeformatlist(35, PIXFMTYUV444P, PIXFMTYUV422P, PIXFMTYUV420P, PIXFMTYUV411P, PIXFMTYUV410P, PIXFMTYUYV422, PIXFMTUYVY422, PIXFMTUYYVYY411, PIXFMTYUVJ444P, PIXFMTYUVJ422P, PIXFMTYUVJ420P, PIXFMTYUV440P, PIXFMTYUVJ440P, PIXFMTRGB32, PIXFMTBGR32, PIXFMTRGB321, PIXFMTBGR321, PIXFMTRGB24, PIXFMTBGR24, PIXFMTRGB565, PIXFMTBGR565, PIXFMTRGB555, PIXFMTBGR555, PIXFMTRGB8, PIXFMTBGR8, PIXFMTRGB4BYTE,PIXFMTBGR4BYTE, PIXFMTGRAY16BE, PIXFMTGRAY16LE, PIXFMTGRAY8, PIXFMTPAL8, PIXFMTMONOWHITE,PIXFMTMONOBLACK PIXFMTNV12, PIXFMTNV21); } ", "target": 0}
{"func": "MemoryRegion *esccinit(targetphysaddrt base, qemuirq irqA, qemuirq irqB, CharDriverState *chrA, CharDriverState *chrB, int clock, int itshift) { DeviceState *dev; SysBusDevice *s; SerialState *d; dev = qdevcreate(NULL, \"escc\"); qdevpropsetuint32(dev, \"disabled\", 0); qdevpropsetuint32(dev, \"frequency\", clock); qdevpropsetuint32(dev, \"itshift\", itshift); qdevpropsetchr(dev, \"chrB\", chrB); qdevpropsetchr(dev, \"chrA\", chrA); qdevpropsetuint32(dev, \"chnBtype\", ser); qdevpropsetuint32(dev, \"chnAtype\", ser); qdevinitnofail(dev); s = sysbusfromqdev(dev); sysbusconnectirq(s, 0, irqB); sysbusconnectirq(s, 1, irqA); if (base) { sysbusmmiomap(s, 0, base); } d = FROMSYSBUS(SerialState, s); return &d->mmio; } ", "target": 0}
{"func": "static void freegeotags(TiffContext *const s) { int i; for (i = 0; i < s->geotagcount; i++) { if (s->geotags[i].val) avfreep(&s->geotags[i].val); } avfreep(&s->geotags); }", "target": 1}
{"func": "void ffbinkidctc(DCTELEM *block) { int i; DCTELEM temp[64]; for (i = 0; i < 8; i++) binkidctcol(&temp[i], &block[i]); for (i = 0; i < 8; i++) { IDCTROW( (&block[8*i]), (&temp[8*i]) ); } } ", "target": 1}
{"func": "PCIBus *pcipmacinit(qemuirq *pic) { DeviceState *dev; SysBusDevice *s; UNINState *d; /* Use values found on a real PowerMac */ /* Uninorth main bus */ dev = qdevcreate(NULL, \"Uni-north main\"); qdevinitnofail(dev); s = sysbusfromqdev(dev); d = FROMSYSBUS(UNINState, s); d->hoststate.bus = pciregisterbus(&d->busdev.qdev, \"pci\", pciuninsetirq, pciuninmapirq, pic, 11 << 3, 4); pcicreatesimple(d->hoststate.bus, 11 << 3, \"Uni-north main\"); sysbusmmiomap(s, 0, 0xf2800000); sysbusmmiomap(s, 1, 0xf2c00000); /* DEC 21154 bridge */ #if 0 /* XXX: not activated as PPC BIOS doesn't handle multiple buses properly */ pcicreatesimple(d->hoststate.bus, 12 << 3, \"DEC 21154\"); #endif /* Uninorth AGP bus */ pcicreatesimple(d->hoststate.bus, 13 << 3, \"Uni-north AGP\"); /* Uninorth internal bus */ #if 0 /* XXX: not needed for now */ pcicreatesimple(d->hoststate.bus, 14 << 3, \"Uni-north internal\"); #endif return d->hoststate.bus; } ", "target": 1}
{"func": "static void jsonmessageprocesstoken(JSONLexer *lexer, GString *input, JSONTokenType type, int x, int y) { JSONMessageParser *parser = containerof(lexer, JSONMessageParser, lexer); QDict *dict; switch (type) { case JSONLCURLY: parser->bracecount++; break; case JSONRCURLY: parser->bracecount--; break; case JSONLSQUARE: parser->bracketcount++; break; case JSONRSQUARE: parser->bracketcount--; break; default: break; } dict = qdictnew(); qdictput(dict, \"type\", qintfromint(type)); qdictput(dict, \"token\", qstringfromstr(input->str)); qdictput(dict, \"x\", qintfromint(x)); qdictput(dict, \"y\", qintfromint(y)); parser->tokensize += input->len; gqueuepushtail(parser->tokens, dict); if (type == JSONERROR) { goto outemitbad; } else if (parser->bracecount < 0 || parser->bracketcount < 0 || (parser->bracecount == 0 && parser->bracketcount == 0)) { goto outemit; } else if (parser->tokensize > MAXTOKENSIZE || parser->bracketcount + parser->bracecount > MAXNESTING) { /* Security consideration, we limit total memory allocated per object * and the maximum recursion depth that a message can force. */ goto outemitbad; } return; outemitbad: /* * Clear out token list and tell the parser to emit an error * indication by passing it a NULL list */ jsonmessagefreetokens(parser); outemit: /* send current list of tokens to parser and reset tokenizer */ parser->bracecount = 0; parser->bracketcount = 0; /* parser->emit takes ownership of parser->tokens. */ parser->emit(parser, parser->tokens); parser->tokens = gqueuenew(); parser->tokensize = 0; } ", "target": 0}
{"func": "static inline void ppc4xxtlbinvalidatevirt(CPUPPCState *env, targetulong eaddr, uint32t pid) { #if !defined(FLUSHALLTLBS) CPUState *cs = CPU(ppcenvgetcpu(env)); ppcembtlbt *tlb; hwaddr raddr; targetulong page, end; int i; for (i = 0; i < env->nbtlb; i++) { tlb = &env->tlb.tlbe[i]; if (ppcembtlbcheck(env, tlb, &raddr, eaddr, pid, 0, i) == 0) { end = tlb->EPN + tlb->size; for (page = tlb->EPN; page < end; page += TARGETPAGESIZE) { tlbflushpage(cs, page); } tlb->prot &= ~PAGEVALID; break; } } #else ppc4xxtlbinvalidateall(env); #endif } ", "target": 0}
{"func": "void pcibridgeinitfn(PCIDevice *dev, const char *typename) { PCIBus *parent = dev->bus; PCIBridge *br = PCIBRIDGE(dev); PCIBus *secbus = &br->secbus; pciwordtestandsetmask(dev->config + PCISTATUS, PCISTATUS66MHZ | PCISTATUSFASTBACK); /* * TODO: We implement VGA Enable in the Bridge Control Register * therefore per the PCI to PCI bridge spec we must also implement * VGA Palette Snooping. When done, set this bit writable: * * pciwordtestandsetmask(dev->wmask + PCICOMMAND, * PCICOMMANDVGAPALETTE); */ pciconfigsetclass(dev->config, PCICLASSBRIDGEPCI); dev->config[PCIHEADERTYPE] = (dev->config[PCIHEADERTYPE] & PCIHEADERTYPEMULTIFUNCTION) | PCIHEADERTYPEBRIDGE; pcisetword(dev->config + PCISECSTATUS, PCISTATUS66MHZ | PCISTATUSFASTBACK); /* * If we don't specify the name, the bus will be addressed as <id>.0, where * id is the device id. * Since PCI Bridge devices have a single bus each, we don't need the index: * let users address the bus using the device name. */ if (!br->busname && dev->qdev.id && *dev->qdev.id) { \t br->busname = dev->qdev.id; } qbuscreateinplace(secbus, sizeof(br->secbus), typename, DEVICE(dev), br->busname); secbus->parentdev = dev; secbus->mapirq = br->mapirq ? br->mapirq : pciswizzlemapirqfn; secbus->addressspacemem = &br->addressspacemem; memoryregioninit(&br->addressspacemem, OBJECT(br), \"pcibridgepci\", UINT64MAX); secbus->addressspaceio = &br->addressspaceio; memoryregioninit(&br->addressspaceio, OBJECT(br), \"pcibridgeio\", 65536); br->windows = pcibridgeregioninit(br); QLISTINIT(&secbus->child); QLISTINSERTHEAD(&parent->child, secbus, sibling); } ", "target": 0}
{"func": "void qemupixmanlinebuffill(pixmanimaget *linebuf, pixmanimaget *fb, int width, int y) { pixmanimagecomposite(PIXMANOPSRC, fb, NULL, linebuf, 0, y, 0, 0, 0, 0, width, 1); } ", "target": 0}
{"func": "static inline abilong targettohostcmsg(struct msghdr *msgh, struct targetmsghdr *targetmsgh) { struct cmsghdr *cmsg = CMSGFIRSTHDR(msgh); abilong msgcontrollen; abiulong targetcmsgaddr; struct targetcmsghdr *targetcmsg; socklent space = 0; msgcontrollen = tswapal(targetmsgh->msgcontrollen); if (msgcontrollen < sizeof (struct targetcmsghdr)) goto theend; targetcmsgaddr = tswapal(targetmsgh->msgcontrol); targetcmsg = lockuser(VERIFYREAD, targetcmsgaddr, msgcontrollen, 1); if (!targetcmsg) return -TARGETEFAULT; while (cmsg && targetcmsg) { void *data = CMSGDATA(cmsg); void *targetdata = TARGETCMSGDATA(targetcmsg); int len = tswapal(targetcmsg->cmsglen) - TARGETCMSGALIGN(sizeof (struct targetcmsghdr)); space += CMSGSPACE(len); if (space > msgh->msgcontrollen) { space -= CMSGSPACE(len); gemulog(\"Host cmsg overflow\\n\"); break; } if (tswap32(targetcmsg->cmsglevel) == TARGETSOLSOCKET) { cmsg->cmsglevel = SOLSOCKET; } else { cmsg->cmsglevel = tswap32(targetcmsg->cmsglevel); } cmsg->cmsgtype = tswap32(targetcmsg->cmsgtype); cmsg->cmsglen = CMSGLEN(len); if (cmsg->cmsglevel != SOLSOCKET || cmsg->cmsgtype != SCMRIGHTS) { gemulog(\"Unsupported ancillary data: %d/%d\\n\", cmsg->cmsglevel, cmsg->cmsgtype); memcpy(data, targetdata, len); } else { int *fd = (int *)data; int *targetfd = (int *)targetdata; int i, numfds = len / sizeof(int); for (i = 0; i < numfds; i++) fd[i] = tswap32(targetfd[i]); } cmsg = CMSGNXTHDR(msgh, cmsg); targetcmsg = TARGETCMSGNXTHDR(targetmsgh, targetcmsg); } unlockuser(targetcmsg, targetcmsgaddr, 0); theend: msgh->msgcontrollen = space; return 0; } ", "target": 0}
{"func": "static bool gaopenpidfile(const char *pidfile) { int pidfd; char pidstr[32]; pidfd = open(pidfile, OCREAT|OWRONLY, SIRUSR|SIWUSR); if (pidfd == -1 || lockf(pidfd, FTLOCK, 0)) { gcritical(\"Cannot lock pid file, %s\", strerror(errno)); if (pidfd != -1) { close(pidfd); } return false; } if (ftruncate(pidfd, 0) || lseek(pidfd, 0, SEEKSET)) { gcritical(\"Failed to truncate pid file\"); goto fail; } sprintf(pidstr, \"%d\", getpid()); if (write(pidfd, pidstr, strlen(pidstr)) != strlen(pidstr)) { gcritical(\"Failed to write pid file\"); goto fail; } return true; fail: unlink(pidfile); return false; } ", "target": 0}
{"func": "static void handlependingsignal(CPUArchState *cpuenv, int sig) { CPUState *cpu = ENVGETCPU(cpuenv); abiulong handler; sigsett set, oldset; targetsigsett targetoldset; struct targetsigaction *sa; struct sigqueue *q; TaskState *ts = cpu->opaque; struct emulatedsigtable *k = &ts->sigtab[sig - 1]; traceuserhandlesignal(cpuenv, sig); /* dequeue signal */ q = k->first; k->first = q->next; if (!k->first) k->pending = 0; sig = gdbhandlesig(cpu, sig); if (!sig) { sa = NULL; handler = TARGETSIGIGN; } else { sa = &sigacttable[sig - 1]; handler = sa->sahandler; } if (ts->sigsegvblocked && sig == TARGETSIGSEGV) { /* Guest has blocked SIGSEGV but we got one anyway. Assume this * is a forced SIGSEGV (ie one the kernel handles via forcesiginfo * because it got a real MMU fault), and treat as if default handler. */ handler = TARGETSIGDFL; } if (handler == TARGETSIGDFL) { /* default handler : ignore some signal. The other are job control or fatal */ if (sig == TARGETSIGTSTP || sig == TARGETSIGTTIN || sig == TARGETSIGTTOU) { kill(getpid(),SIGSTOP); } else if (sig != TARGETSIGCHLD && sig != TARGETSIGURG && sig != TARGETSIGWINCH && sig != TARGETSIGCONT) { forcesig(sig); } } else if (handler == TARGETSIGIGN) { /* ignore sig */ } else if (handler == TARGETSIGERR) { forcesig(sig); } else { /* compute the blocked signals during the handler execution */ targettohostsigset(&set, &sa->samask); /* SANODEFER indicates that the current signal should not be blocked during the handler */ if (!(sa->saflags & TARGETSANODEFER)) sigaddset(&set, targettohostsignal(sig)); /* block signals in the handler using Linux */ dosigprocmask(SIGBLOCK, &set, &oldset); /* save the previous blocked signal state to restore it at the end of the signal execution (see dosigreturn) */ hosttotargetsigsetinternal(&targetoldset, &oldset); /* if the CPU is in VM86 mode, we restore the 32 bit values */ #if defined(TARGETI386) && !defined(TARGETX8664) { CPUX86State *env = cpuenv; if (env->eflags & VMMASK) savev86state(env); } #endif /* prepare the stack frame of the virtual CPU */ #if defined(TARGETABIMIPSN32) || defined(TARGETABIMIPSN64) \\ || defined(TARGETOPENRISC) || defined(TARGETTILEGX) /* These targets do not have traditional signals. */ setuprtframe(sig, sa, &q->info, &targetoldset, cpuenv); #else if (sa->saflags & TARGETSASIGINFO) setuprtframe(sig, sa, &q->info, &targetoldset, cpuenv); else setupframe(sig, sa, &targetoldset, cpuenv); #endif if (sa->saflags & TARGETSARESETHAND) { sa->sahandler = TARGETSIGDFL; } } if (q != &k->info) freesigqueue(cpuenv, q); } ", "target": 1}
{"func": "static void pciepcibridgewriteconfig(PCIDevice *d, uint32t address, uint32t val, int len) { pcibridgewriteconfig(d, address, val, len); msiwriteconfig(d, address, val, len); shpccapwriteconfig(d, address, val, len); } ", "target": 1}
{"func": "static ramaddrt findramoffset(ramaddrt size) { RAMBlock *block, *nextblock; ramaddrt offset = RAMADDRMAX, mingap = RAMADDRMAX; assert(size != 0); /* it would hand out same offset multiple times */ if (QTAILQEMPTY(&ramlist.blocks)) return 0; QTAILQFOREACH(block, &ramlist.blocks, next) { ramaddrt end, next = RAMADDRMAX; end = block->offset + block->length; QTAILQFOREACH(nextblock, &ramlist.blocks, next) { if (nextblock->offset >= end) { next = MIN(next, nextblock->offset); } } if (next - end >= size && next - end < mingap) { offset = end; mingap = next - end; } } if (offset == RAMADDRMAX) { fprintf(stderr, \"Failed to find gap of requested size: %\" PRIu64 \"\\n\", (uint64t)size); abort(); } return offset; } ", "target": 0}
{"func": "CharDriverState *qemuchralloc(void) { CharDriverState *chr = gmalloc0(sizeof(CharDriverState)); qemumutexinit(&chr->chrwritelock); return chr; } ", "target": 0}
{"func": "static int scsidiskemulatecommand(SCSIDiskReq *r, uint8t *outbuf) { SCSIRequest *req = &r->req; SCSIDiskState *s = DOUPCAST(SCSIDiskState, qdev, req->dev); uint64t nbsectors; int buflen = 0; int ret; switch (req->cmd.buf[0]) { case TESTUNITREADY: if (!bdrvisinserted(s->bs)) goto notready; break; case REQUESTSENSE: if (req->cmd.xfer < 4) goto illegalrequest; buflen = scsidevicegetsense(&s->qdev, outbuf, req->cmd.xfer, (req->cmd.buf[1] & 1) == 0); break; case INQUIRY: buflen = scsidiskemulateinquiry(req, outbuf); if (buflen < 0) goto illegalrequest; break; case MODESENSE: case MODESENSE10: buflen = scsidiskemulatemodesense(req, outbuf); if (buflen < 0) goto illegalrequest; break; case READTOC: buflen = scsidiskemulatereadtoc(req, outbuf); if (buflen < 0) goto illegalrequest; break; case RESERVE: if (req->cmd.buf[1] & 1) goto illegalrequest; break; case RESERVE10: if (req->cmd.buf[1] & 3) goto illegalrequest; break; case RELEASE: if (req->cmd.buf[1] & 1) goto illegalrequest; break; case RELEASE10: if (req->cmd.buf[1] & 3) goto illegalrequest; break; case STARTSTOP: if (s->qdev.type == TYPEROM && (req->cmd.buf[4] & 2)) { /* load/eject medium */ bdrveject(s->bs, !(req->cmd.buf[4] & 1)); } break; case ALLOWMEDIUMREMOVAL: bdrvsetlocked(s->bs, req->cmd.buf[4] & 1); break; case READCAPACITY10: /* The normal LEN field for this command is zero. */ memset(outbuf, 0, 8); bdrvgetgeometry(s->bs, &nbsectors); if (!nbsectors) goto notready; nbsectors /= s->clustersize; /* Returned value is the address of the last sector. */ nbsectors--; /* Remember the new size for read/write sanity checking. */ s->maxlba = nbsectors; /* Clip to 2TB, instead of returning capacity modulo 2TB. */ if (nbsectors > UINT32MAX) nbsectors = UINT32MAX; outbuf[0] = (nbsectors >> 24) & 0xff; outbuf[1] = (nbsectors >> 16) & 0xff; outbuf[2] = (nbsectors >> 8) & 0xff; outbuf[3] = nbsectors & 0xff; outbuf[4] = 0; outbuf[5] = 0; outbuf[6] = s->clustersize * 2; outbuf[7] = 0; buflen = 8; break; case SYNCHRONIZECACHE: ret = bdrvflush(s->bs); if (ret < 0) { if (scsihandlerwerror(r, -ret, SCSIREQSTATUSRETRYFLUSH)) { return -1; } } break; case GETCONFIGURATION: memset(outbuf, 0, 8); /* ??? This should probably return much more information. For now just return the basic header indicating the CD-ROM profile. */ outbuf[7] = 8; // CD-ROM buflen = 8; break; case SERVICEACTIONIN: /* Service Action In subcommands. */ if ((req->cmd.buf[1] & 31) == 0x10) { DPRINTF(\"SAI READ CAPACITY(16)\\n\"); memset(outbuf, 0, req->cmd.xfer); bdrvgetgeometry(s->bs, &nbsectors); if (!nbsectors) goto notready; nbsectors /= s->clustersize; /* Returned value is the address of the last sector. */ nbsectors--; /* Remember the new size for read/write sanity checking. */ s->maxlba = nbsectors; outbuf[0] = (nbsectors >> 56) & 0xff; outbuf[1] = (nbsectors >> 48) & 0xff; outbuf[2] = (nbsectors >> 40) & 0xff; outbuf[3] = (nbsectors >> 32) & 0xff; outbuf[4] = (nbsectors >> 24) & 0xff; outbuf[5] = (nbsectors >> 16) & 0xff; outbuf[6] = (nbsectors >> 8) & 0xff; outbuf[7] = nbsectors & 0xff; outbuf[8] = 0; outbuf[9] = 0; outbuf[10] = s->clustersize * 2; outbuf[11] = 0; outbuf[12] = 0; outbuf[13] = getphysicalblockexp(&s->qdev.conf); /* set TPE bit if the format supports discard */ if (s->qdev.conf.discardgranularity) { outbuf[14] = 0x80; } /* Protection, exponent and lowest lba field left blank. */ buflen = req->cmd.xfer; break; } DPRINTF(\"Unsupported Service Action In\\n\"); goto illegalrequest; case REPORTLUNS: if (req->cmd.xfer < 16) goto illegalrequest; memset(outbuf, 0, 16); outbuf[3] = 8; buflen = 16; break; case VERIFY10: break; default: scsicheckcondition(r, SENSECODE(INVALIDOPCODE)); return -1; } return buflen; notready: if (!bdrvisinserted(s->bs)) { scsicheckcondition(r, SENSECODE(NOMEDIUM)); } else { scsicheckcondition(r, SENSECODE(LUNNOTREADY)); } return -1; illegalrequest: scsicheckcondition(r, SENSECODE(INVALIDFIELD)); return -1; } ", "target": 0}
{"func": "static void flushqueuedwork(CPUState *cpu) { struct qemuworkitem *wi; if (cpu->queuedworkfirst == NULL) { return; } while ((wi = cpu->queuedworkfirst)) { cpu->queuedworkfirst = wi->next; wi->func(wi->data); wi->done = true; if (wi->free) { gfree(wi); } } cpu->queuedworklast = NULL; qemucondbroadcast(&qemuworkcond); } ", "target": 0}
{"func": "static int validateguestspace(unsigned long guestbase, unsigned long guestsize) { unsigned long realstart, testpageaddr; /* We need to check that we can force a fault on access to the * commpage at 0xffff0fxx */ testpageaddr = guestbase + (0xffff0f00 & qemuhostpagemask); /* If the commpage lies within the already allocated guest space, * then there is no way we can allocate it. */ if (testpageaddr >= guestbase && testpageaddr <= (guestbase + guestsize)) { return -1; } /* Note it needs to be writeable to let us initialise it */ realstart = (unsigned long) mmap((void *)testpageaddr, qemuhostpagesize, PROTREAD | PROTWRITE, MAPANONYMOUS | MAPPRIVATE | MAPANONYMOUS, -1, 0); /* If we can't map it then try another address */ if (realstart == -1ul) { return 0; } if (realstart != testpageaddr) { /* OS didn't put the page where we asked - unmap and reject */ munmap((void *)realstart, qemuhostpagesize); return 0; } /* Leave the page mapped * Populate it (mmap should have left it all 0'd) */ /* Kernel helper versions */ putuser(5, (uint32t *)g2h(0xffff0ffcul)); /* Now it's populated make it RO */ if (mprotect((void *)testpageaddr, qemuhostpagesize, PROTREAD)) { perror(\"Protecting guest commpage\"); exit(-1); } return 1; /* All good */ } ", "target": 0}
{"func": "long dosigreturn(CPUCRISState *env) { \tstruct targetsignalframe *frame; \tabiulong frameaddr; \ttargetsigsett targetset; \tsigsett set; \tint i; \tframeaddr = env->regs[RSP]; \t/* Make sure the guest isn't playing games. */ \tif (!lockuserstruct(VERIFYWRITE, frame, frameaddr, 1)) \t\tgoto badframe; \t/* Restore blocked signals */ \tif (getuser(targetset.sig[0], &frame->sc.oldmask)) \t\tgoto badframe; \tfor(i = 1; i < TARGETNSIGWORDS; i++) { \t\tif (getuser(targetset.sig[i], &frame->extramask[i - 1])) \t\t\tgoto badframe; \t} \ttargettohostsigsetinternal(&set, &targetset); dosigprocmask(SIGSETMASK, &set, NULL); \trestoresigcontext(&frame->sc, env); \tunlockuserstruct(frame, frameaddr, 0); \treturn env->regs[10]; badframe: \tunlockuserstruct(frame, frameaddr, 0); \tforcesig(TARGETSIGSEGV); } ", "target": 1}
{"func": "static void usbredirinterruptpacket(void *priv, uint32t id, struct usbredirinterruptpacketheader *interruptpacket, uint8t *data, int datalen) { USBRedirDevice *dev = priv; uint8t ep = interruptpacket->endpoint; DPRINTF(\"interrupt-in status %d ep %02X len %d id %u\\n\", interruptpacket->status, ep, datalen, id); if (dev->endpoint[EP2I(ep)].type != USBENDPOINTXFERINT) { ERROR(\"received int packet for non interrupt endpoint %02X\\n\", ep); free(data); return; } if (ep & USBDIRIN) { if (dev->endpoint[EP2I(ep)].interruptstarted == 0) { DPRINTF(\"received int packet while not started ep %02X\\n\", ep); free(data); return; } /* bufpalloc also adds the packet to the ep queue */ bufpalloc(dev, data, datalen, interruptpacket->status, ep); } else { int len = interruptpacket->length; AsyncURB *aurb = asyncfind(dev, id); if (!aurb) { return; } if (aurb->interruptpacket.endpoint != interruptpacket->endpoint) { ERROR(\"return int packet mismatch, please report this!\\n\"); len = USBRETNAK; } if (aurb->packet) { aurb->packet->len = usbredirhandlestatus(dev, interruptpacket->status, len); usbpacketcomplete(&dev->dev, aurb->packet); } asyncfree(dev, aurb); } } ", "target": 1}
{"func": "void mpeg1encodemb(MpegEncContext *s, DCTELEM block[6][64], int motionx, int motiony) { int i, cbp; const int mbx = s->mbx; const int mby = s->mby; const int firstmb= mbx == s->resyncmbx && mby == s->resyncmby; /* compute cbp */ cbp = 0; for(i=0;i<6;i++) { if (s->blocklastindex[i] >= 0) cbp |= 1 << (5 - i); } if (cbp == 0 && !firstmb && (mbx != s->mbwidth - 1 || (mby != s->mbheight - 1 && s->codecid == CODECIDMPEG1VIDEO)) && ((s->picttype == PTYPE && s->mvtype == MVTYPE16X16 && (motionx | motiony) == 0) || (s->picttype == BTYPE && s->mvdir == s->lastmvdir && (((s->mvdir & MVDIRFORWARD) ? ((s->mv[0][0][0] - s->lastmv[0][0][0])|(s->mv[0][0][1] - s->lastmv[0][0][1])) : 0) | ((s->mvdir & MVDIRBACKWARD) ? ((s->mv[1][0][0] - s->lastmv[1][0][0])|(s->mv[1][0][1] - s->lastmv[1][0][1])) : 0)) == 0))) { s->mbskiprun++; s->qscale -= s->dquant; s->skipcount++; s->miscbits++; s->lastbits++; if(s->picttype == PTYPE){ s->lastmv[0][1][0]= s->lastmv[0][0][0]= s->lastmv[0][1][1]= s->lastmv[0][0][1]= 0; } } else { if(firstmb){ assert(s->mbskiprun == 0); encodembskiprun(s, s->mbx); }else{ encodembskiprun(s, s->mbskiprun); } if (s->picttype == ITYPE) { if(s->dquant && cbp){ putmbmodes(s, 2, 1, 0, 0); /* macroblocktype : macroblockquant = 1 */ putbits(&s->pb, 5, s->qscale); }else{ putmbmodes(s, 1, 1, 0, 0); /* macroblocktype : macroblockquant = 0 */ s->qscale -= s->dquant; } s->miscbits+= getbitsdiff(s); s->icount++; } else if (s->mbintra) { if(s->dquant && cbp){ putmbmodes(s, 6, 0x01, 0, 0); putbits(&s->pb, 5, s->qscale); }else{ putmbmodes(s, 5, 0x03, 0, 0); s->qscale -= s->dquant; } s->miscbits+= getbitsdiff(s); s->icount++; memset(s->lastmv, 0, sizeof(s->lastmv)); } else if (s->picttype == PTYPE) { if(s->mvtype == MVTYPE16X16){ if (cbp != 0) { if ((motionx|motiony) == 0) { if(s->dquant){ putmbmodes(s, 5, 1, 0, 0); /* macroblockpattern & quant */ putbits(&s->pb, 5, s->qscale); }else{ putmbmodes(s, 2, 1, 0, 0); /* macroblockpattern only */ } s->miscbits+= getbitsdiff(s); } else { if(s->dquant){ putmbmodes(s, 5, 2, 1, 0); /* motion + cbp */ putbits(&s->pb, 5, s->qscale); }else{ putmbmodes(s, 1, 1, 1, 0); /* motion + cbp */ } s->miscbits+= getbitsdiff(s); mpeg1encodemotion(s, motionx - s->lastmv[0][0][0], s->fcode); // RAL: fcode parameter added mpeg1encodemotion(s, motiony - s->lastmv[0][0][1], s->fcode); // RAL: fcode parameter added s->mvbits+= getbitsdiff(s); } } else { putbits(&s->pb, 3, 1); /* motion only */ if (!s->framepredframedct) putbits(&s->pb, 2, 2); /* motiontype: frame */ s->miscbits+= getbitsdiff(s); mpeg1encodemotion(s, motionx - s->lastmv[0][0][0], s->fcode); // RAL: fcode parameter added mpeg1encodemotion(s, motiony - s->lastmv[0][0][1], s->fcode); // RAL: fcode parameter added s->qscale -= s->dquant; s->mvbits+= getbitsdiff(s); } s->lastmv[0][1][0]= s->lastmv[0][0][0]= motionx; s->lastmv[0][1][1]= s->lastmv[0][0][1]= motiony; }else{ assert(!s->framepredframedct && s->mvtype == MVTYPEFIELD); if (cbp) { if(s->dquant){ putmbmodes(s, 5, 2, 1, 1); /* motion + cbp */ putbits(&s->pb, 5, s->qscale); }else{ putmbmodes(s, 1, 1, 1, 1); /* motion + cbp */ } } else { putbits(&s->pb, 3, 1); /* motion only */ putbits(&s->pb, 2, 1); /* motiontype: field */ s->qscale -= s->dquant; } s->miscbits+= getbitsdiff(s); for(i=0; i<2; i++){ putbits(&s->pb, 1, s->fieldselect[0][i]); mpeg1encodemotion(s, s->mv[0][i][0] - s->lastmv[0][i][0] , s->fcode); mpeg1encodemotion(s, s->mv[0][i][1] - (s->lastmv[0][i][1]>>1), s->fcode); s->lastmv[0][i][0]= s->mv[0][i][0]; s->lastmv[0][i][1]= 2*s->mv[0][i][1]; } s->mvbits+= getbitsdiff(s); } if(cbp) putbits(&s->pb, mbPatTable[cbp - 1][1], mbPatTable[cbp - 1][0]); s->fcount++; } else{ static const int mbtypelen[4]={0,3,4,2}; //bak,for,bi if(s->mvtype == MVTYPE16X16){ if (cbp){ // With coded bloc pattern if (s->dquant) { if(s->mvdir == MVDIRFORWARD) putmbmodes(s, 6, 3, 1, 0); else putmbmodes(s, mbtypelen[s->mvdir]+3, 2, 1, 0); putbits(&s->pb, 5, s->qscale); } else { putmbmodes(s, mbtypelen[s->mvdir], 3, 1, 0); } }else{ // No coded bloc pattern putbits(&s->pb, mbtypelen[s->mvdir], 2); if (!s->framepredframedct) putbits(&s->pb, 2, 2); /* motiontype: frame */ s->qscale -= s->dquant; } s->miscbits += getbitsdiff(s); if (s->mvdir&MVDIRFORWARD){ mpeg1encodemotion(s, s->mv[0][0][0] - s->lastmv[0][0][0], s->fcode); mpeg1encodemotion(s, s->mv[0][0][1] - s->lastmv[0][0][1], s->fcode); s->lastmv[0][0][0]=s->lastmv[0][1][0]= s->mv[0][0][0]; s->lastmv[0][0][1]=s->lastmv[0][1][1]= s->mv[0][0][1]; s->fcount++; } if (s->mvdir&MVDIRBACKWARD){ mpeg1encodemotion(s, s->mv[1][0][0] - s->lastmv[1][0][0], s->bcode); mpeg1encodemotion(s, s->mv[1][0][1] - s->lastmv[1][0][1], s->bcode); s->lastmv[1][0][0]=s->lastmv[1][1][0]= s->mv[1][0][0]; s->lastmv[1][0][1]=s->lastmv[1][1][1]= s->mv[1][0][1]; s->bcount++; } }else{ assert(s->mvtype == MVTYPEFIELD); assert(!s->framepredframedct); if (cbp){ // With coded bloc pattern if (s->dquant) { if(s->mvdir == MVDIRFORWARD) putmbmodes(s, 6, 3, 1, 1); else putmbmodes(s, mbtypelen[s->mvdir]+3, 2, 1, 1); putbits(&s->pb, 5, s->qscale); } else { putmbmodes(s, mbtypelen[s->mvdir], 3, 1, 1); } }else{ // No coded bloc pattern putbits(&s->pb, mbtypelen[s->mvdir], 2); putbits(&s->pb, 2, 1); /* motiontype: field */ s->qscale -= s->dquant; } s->miscbits += getbitsdiff(s); if (s->mvdir&MVDIRFORWARD){ for(i=0; i<2; i++){ putbits(&s->pb, 1, s->fieldselect[0][i]); mpeg1encodemotion(s, s->mv[0][i][0] - s->lastmv[0][i][0] , s->fcode); mpeg1encodemotion(s, s->mv[0][i][1] - (s->lastmv[0][i][1]>>1), s->fcode); s->lastmv[0][i][0]= s->mv[0][i][0]; s->lastmv[0][i][1]= 2*s->mv[0][i][1]; } s->fcount++; } if (s->mvdir&MVDIRBACKWARD){ for(i=0; i<2; i++){ putbits(&s->pb, 1, s->fieldselect[1][i]); mpeg1encodemotion(s, s->mv[1][i][0] - s->lastmv[1][i][0] , s->bcode); mpeg1encodemotion(s, s->mv[1][i][1] - (s->lastmv[1][i][1]>>1), s->bcode); s->lastmv[1][i][0]= s->mv[1][i][0]; s->lastmv[1][i][1]= 2*s->mv[1][i][1]; } s->bcount++; } } s->mvbits += getbitsdiff(s); if(cbp) putbits(&s->pb, mbPatTable[cbp - 1][1], mbPatTable[cbp - 1][0]); } for(i=0;i<6;i++) { if (cbp & (1 << (5 - i))) { mpeg1encodeblock(s, block[i], i); } } s->mbskiprun = 0; if(s->mbintra) s->itexbits+= getbitsdiff(s); else s->ptexbits+= getbitsdiff(s); } } ", "target": 0}
{"func": "static void virtioccwdevicerealize(VirtioCcwDevice *dev, Error **errp) { unsigned int cssid = 0; unsigned int ssid = 0; unsigned int schid; unsigned int devno; bool havedevno = false; bool found = false; SubchDev *sch; int num; DeviceState *parent = DEVICE(dev); Error *err = NULL; VirtIOCCWDeviceClass *k = VIRTIOCCWDEVICEGETCLASS(dev); VirtIODevice *vdev; sch = gmalloc0(sizeof(SubchDev)); sch->driverdata = dev; dev->sch = sch; dev->indicators = NULL; /* Initialize subchannel structure. */ sch->channelprog = 0x0; sch->lastcmdvalid = false; sch->thinintactive = false; /* * Use a device number if provided. Otherwise, fall back to subchannel * number. */ if (dev->busid) { num = sscanf(dev->busid, \"%x.%x.%04x\", &cssid, &ssid, &devno); if (num == 3) { if ((cssid > MAXCSSID) || (ssid > MAXSSID)) { errorsetg(errp, \"Invalid cssid or ssid: cssid %x, ssid %x\", cssid, ssid); goto outerr; } /* Enforce use of virtual cssid. */ if (cssid != VIRTUALCSSID) { errorsetg(errp, \"cssid %x not valid for virtio devices\", cssid); goto outerr; } if (cssdevnoused(cssid, ssid, devno)) { errorsetg(errp, \"Device %x.%x.%04x already exists\", cssid, ssid, devno); goto outerr; } sch->cssid = cssid; sch->ssid = ssid; sch->devno = devno; havedevno = true; } else { errorsetg(errp, \"Malformed devno parameter '%s'\", dev->busid); goto outerr; } } /* Find the next free id. */ if (havedevno) { for (schid = 0; schid <= MAXSCHID; schid++) { if (!cssfindsubch(1, cssid, ssid, schid)) { sch->schid = schid; csssubchassign(cssid, ssid, schid, devno, sch); found = true; break; } } if (!found) { errorsetg(errp, \"No free subchannel found for %x.%x.%04x\", cssid, ssid, devno); goto outerr; } tracevirtioccwnewdevice(cssid, ssid, schid, devno, \"user-configured\"); } else { cssid = VIRTUALCSSID; for (ssid = 0; ssid <= MAXSSID; ssid++) { for (schid = 0; schid <= MAXSCHID; schid++) { if (!cssfindsubch(1, cssid, ssid, schid)) { sch->cssid = cssid; sch->ssid = ssid; sch->schid = schid; devno = schid; /* * If the devno is already taken, look further in this * subchannel set. */ while (cssdevnoused(cssid, ssid, devno)) { if (devno == MAXSCHID) { devno = 0; } else if (devno == schid - 1) { errorsetg(errp, \"No free devno found\"); goto outerr; } else { devno++; } } sch->devno = devno; csssubchassign(cssid, ssid, schid, devno, sch); found = true; break; } } if (found) { break; } } if (!found) { errorsetg(errp, \"Virtual channel subsystem is full!\"); goto outerr; } tracevirtioccwnewdevice(cssid, ssid, schid, devno, \"auto-configured\"); } /* Build initial schib. */ cssschbuildvirtualschib(sch, 0, VIRTIOCCWCHPIDTYPE); sch->ccwcb = virtioccwcb; /* Build senseid data. */ memset(&sch->id, 0, sizeof(SenseId)); sch->id.reserved = 0xff; sch->id.cutype = VIRTIOCCWCUTYPE; if (k->realize) { k->realize(dev, &err); } if (err) { errorpropagate(errp, err); csssubchassign(cssid, ssid, schid, devno, NULL); goto outerr; } /* deviceid is only set after vdev has been realized */ vdev = virtioccwgetvdev(sch); sch->id.cumodel = vdev->deviceid; /* Only the first 32 feature bits are used. */ dev->hostfeatures[0] = virtiobusgetvdevfeatures(&dev->bus, dev->hostfeatures[0]); virtioaddfeature(&dev->hostfeatures[0], VIRTIOFNOTIFYONEMPTY); virtioaddfeature(&dev->hostfeatures[0], VIRTIOFBADFEATURE); cssgenerateschcrws(sch->cssid, sch->ssid, sch->schid, parent->hotplugged, 1); return; outerr: dev->sch = NULL; gfree(sch); } ", "target": 0}
{"func": "void opcp1registers(void) { if (!(env->CP0Status & (1 << CP0StFR)) && (PARAM1 & 1)) { CALLFROMTB1(doraiseexception, EXCPRI); } RETURN(); } ", "target": 0}
{"func": "static inline void RENAME(rgb24tobgr24)(const uint8t *src, uint8t *dst, long srcsize) { \tunsigned i; #ifdef HAVEMMX \tlong mmxsize= 23 - srcsize; \tasm volatile ( \t\t\"test %%\"REGa\", %%\"REGa\"\t\\n\\t\" \t\t\"jns 2f\t\t\t\t\\n\\t\" \t\t\"movq \"MANGLE(mask24r)\", %%mm5\t\\n\\t\" \t\t\"movq \"MANGLE(mask24g)\", %%mm6\t\\n\\t\" \t\t\"movq \"MANGLE(mask24b)\", %%mm7\t\\n\\t\" \t\tASMALIGN(4) \t\t\"1:\t\t\t\t\\n\\t\" \t\tPREFETCH\" 32(%1, %%\"REGa\")\t\\n\\t\" \t\t\"movq (%1, %%\"REGa\"), %%mm0\t\\n\\t\" // BGR BGR BG \t\t\"movq (%1, %%\"REGa\"), %%mm1\t\\n\\t\" // BGR BGR BG \t\t\"movq 2(%1, %%\"REGa\"), %%mm2\t\\n\\t\" // R BGR BGR B \t\t\"psllq $16, %%mm0\t\t\\n\\t\" // 00 BGR BGR \t\t\"pand %%mm5, %%mm0\t\t\\n\\t\" \t\t\"pand %%mm6, %%mm1\t\t\\n\\t\" \t\t\"pand %%mm7, %%mm2\t\t\\n\\t\" \t\t\"por %%mm0, %%mm1\t\t\\n\\t\" \t\t\"por %%mm2, %%mm1\t\t\\n\\t\" \t\t\"movq 6(%1, %%\"REGa\"), %%mm0\t\\n\\t\" // BGR BGR BG \t\tMOVNTQ\" %%mm1, (%2, %%\"REGa\")\\n\\t\" // RGB RGB RG \t\t\"movq 8(%1, %%\"REGa\"), %%mm1\t\\n\\t\" // R BGR BGR B \t\t\"movq 10(%1, %%\"REGa\"), %%mm2\t\\n\\t\" // GR BGR BGR \t\t\"pand %%mm7, %%mm0\t\t\\n\\t\" \t\t\"pand %%mm5, %%mm1\t\t\\n\\t\" \t\t\"pand %%mm6, %%mm2\t\t\\n\\t\" \t\t\"por %%mm0, %%mm1\t\t\\n\\t\" \t\t\"por %%mm2, %%mm1\t\t\\n\\t\" \t\t\"movq 14(%1, %%\"REGa\"), %%mm0\t\\n\\t\" // R BGR BGR B \t\tMOVNTQ\" %%mm1, 8(%2, %%\"REGa\")\\n\\t\" // B RGB RGB R \t\t\"movq 16(%1, %%\"REGa\"), %%mm1\t\\n\\t\" // GR BGR BGR \t\t\"movq 18(%1, %%\"REGa\"), %%mm2\t\\n\\t\" // BGR BGR BG \t\t\"pand %%mm6, %%mm0\t\t\\n\\t\" \t\t\"pand %%mm7, %%mm1\t\t\\n\\t\" \t\t\"pand %%mm5, %%mm2\t\t\\n\\t\" \t\t\"por %%mm0, %%mm1\t\t\\n\\t\" \t\t\"por %%mm2, %%mm1\t\t\\n\\t\" \t\tMOVNTQ\" %%mm1, 16(%2, %%\"REGa\")\\n\\t\" \t\t\"add $24, %%\"REGa\"\t\t\\n\\t\" \t\t\" js 1b\t\t\t\t\\n\\t\" \t\t\"2:\t\t\t\t\\n\\t\" \t\t: \"+a\" (mmxsize) \t\t: \"r\" (src-mmxsize), \"r\"(dst-mmxsize) \t); \tasm volatile(SFENCE:::\"memory\"); \tasm volatile(EMMS:::\"memory\"); \tif(mmxsize==23) return; //finihsed, was multiple of 8 \tsrc+= srcsize; \tdst+= srcsize; \tsrcsize= 23-mmxsize; \tsrc-= srcsize; \tdst-= srcsize; #endif \tfor(i=0; i<srcsize; i+=3) \t{ \t\tregister uint8t x; \t\tx = src[i + 2]; \t\tdst[i + 1] = src[i + 1]; \t\tdst[i + 2] = src[i + 0]; \t\tdst[i + 0] = x; \t} } ", "target": 1}
{"func": "static int vdah264endframe(AVCodecContext *avctx) { H264Context *h = avctx->privdata; struct vdacontext *vdactx = avctx->hwaccelcontext; AVFrame *frame = &h->curpicptr->f; struct vdabuffer *context; AVBufferRef *buffer; int status; if (!vdactx->decoder || !vdactx->privbitstream) status = vdasyncdecode(vdactx); frame->data[3] = (void*)vdactx->cvbuffer; if (status) avlog(avctx, AVLOGERROR, \"Failed to decode frame (%d)\\n\", status);", "target": 1}
{"func": "static int decodeframe(AVCodecContext *avctx, void *data, int *gotframe, AVPacket *avpkt) { const uint8t *buf = avpkt->data; int bufsize = avpkt->size; H264Context *h = avctx->privdata; AVFrame *pict = data; int bufindex = 0; Picture *out; int i, outidx; int ret; h->flags = avctx->flags; /* end of stream, output what is still in the buffers */ if (bufsize == 0) { out: h->curpicptr = NULL; h->firstfield = 0; // FIXME factorize this with the output code below out = h->delayedpic[0]; outidx = 0; for (i = 1; h->delayedpic[i] && !h->delayedpic[i]->f.keyframe && !h->delayedpic[i]->mmcoreset; i++) if (h->delayedpic[i]->poc < out->poc) { out = h->delayedpic[i]; outidx = i; } for (i = outidx; h->delayedpic[i]; i++) h->delayedpic[i] = h->delayedpic[i + 1]; if (out) { out->reference &= ~DELAYEDPICREF; ret = outputframe(h, pict, &out->f); if (ret < 0) return ret; *gotframe = 1; } return bufindex; } if(h->isavc && bufsize >= 9 && buf[0]==1 && buf[2]==0 && (buf[4]&0xFC)==0xFC && (buf[5]&0x1F) && buf[8]==0x67){ int cnt= buf[5]&0x1f; const uint8t *p= buf+6; while(cnt--){ int nalsize= AVRB16(p) + 2; if(nalsize > bufsize - (p-buf) || p[2]!=0x67) goto notextra; p += nalsize; } cnt = *(p++); if(!cnt) goto notextra; while(cnt--){ int nalsize= AVRB16(p) + 2; if(nalsize > bufsize - (p-buf) || p[2]!=0x68) goto notextra; p += nalsize; } return ffh264decodeextradata(h, buf, bufsize); } notextra: bufindex = decodenalunits(h, buf, bufsize, 0); if (bufindex < 0) return -1; if (!h->curpicptr && h->nalunittype == NALENDSEQUENCE) { avassert0(bufindex <= bufsize); goto out; } if (!(avctx->flags2 & CODECFLAG2CHUNKS) && !h->curpicptr) { if (avctx->skipframe >= AVDISCARDNONREF || bufsize >= 4 && !memcmp(\"Q264\", buf, 4)) return bufsize; avlog(avctx, AVLOGERROR, \"no frame!\\n\"); return -1; } if (!(avctx->flags2 & CODECFLAG2CHUNKS) || (h->mby >= h->mbheight && h->mbheight)) { if (avctx->flags2 & CODECFLAG2CHUNKS) decodepostinit(h, 1); fieldend(h, 0); /* Wait for second field. */ *gotframe = 0; if (h->nextoutputpic && (h->nextoutputpic->sync || h->sync>1)) { ret = outputframe(h, pict, &h->nextoutputpic->f); if (ret < 0) return ret; *gotframe = 1; if (CONFIGMPEGVIDEO) { ffprintdebuginfo2(h->avctx, h->nextoutputpic, pict, h->er.mbskiptable, &h->lowdelay, h->mbwidth, h->mbheight, h->mbstride, 1); } } } assert(pict->data[0] || !*gotframe); return getconsumedbytes(bufindex, bufsize); } ", "target": 1}
{"func": "GIOStatus gachannelwriteall(GAChannel *c, const char *buf, sizet size) { GIOStatus status = GIOSTATUSNORMAL; sizet count; while (size) { status = gachannelwrite(c, buf, size, &count); if (status == GIOSTATUSNORMAL) { size -= count; buf += count; } else if (status != GIOSTATUSAGAIN) { break; } } return status; } ", "target": 1}
{"func": "static int channelmapqueryformats(AVFilterContext *ctx) { ChannelMapContext *s = ctx->priv; ffsetcommonformats(ctx, ffplanarsamplefmts()); ffsetcommonsamplerates(ctx, ffallsamplerates()); ffchannellayoutsref(ffallchannellayouts(), &ctx->inputs[0]->outchannellayouts); ffchannellayoutsref(s->channellayouts, &ctx->outputs[0]->inchannellayouts); return 0; } ", "target": 1}
{"func": "static void flushqueuedwork(CPUState *env) { struct qemuworkitem *wi; if (!env->queuedworkfirst) return; while ((wi = env->queuedworkfirst)) { env->queuedworkfirst = wi->next; wi->func(wi->data); wi->done = true; } env->queuedworklast = NULL; qemucondbroadcast(&qemuworkcond); } ", "target": 0}
{"func": "static int coroutinefn addaiorequest(BDRVSheepdogState *s, AIOReq *aioreq, struct iovec *iov, int niov, bool create, enum AIOCBState aiocbtype) { int nrcopies = s->inode.nrcopies; SheepdogObjReq hdr; unsigned int wlen; int ret; uint64t oid = aioreq->oid; unsigned int datalen = aioreq->datalen; uint64t offset = aioreq->offset; uint8t flags = aioreq->flags; uint64t oldoid = aioreq->baseoid; if (!nrcopies) { errorreport(\"bug\"); } memset(&hdr, 0, sizeof(hdr)); if (aiocbtype == AIOCBREADUDATA) { wlen = 0; hdr.opcode = SDOPREADOBJ; hdr.flags = flags; } else if (create) { wlen = datalen; hdr.opcode = SDOPCREATEANDWRITEOBJ; hdr.flags = SDFLAGCMDWRITE | flags; } else { wlen = datalen; hdr.opcode = SDOPWRITEOBJ; hdr.flags = SDFLAGCMDWRITE | flags; } if (s->cacheflags) { hdr.flags |= s->cacheflags; } hdr.oid = oid; hdr.cowoid = oldoid; hdr.copies = s->inode.nrcopies; hdr.datalength = datalen; hdr.offset = offset; hdr.id = aioreq->id; qemucomutexlock(&s->lock); s->cosend = qemucoroutineself(); qemuaiosetfdhandler(s->fd, coreadresponse, cowriterequest, aioflushrequest, s); socketsetcork(s->fd, 1); /* send a header */ ret = qemucosend(s->fd, &hdr, sizeof(hdr)); if (ret < 0) { qemucomutexunlock(&s->lock); errorreport(\"failed to send a req, %s\", strerror(errno)); return -errno; } if (wlen) { ret = qemucosendv(s->fd, iov, niov, aioreq->iovoffset, wlen); if (ret < 0) { qemucomutexunlock(&s->lock); errorreport(\"failed to send a data, %s\", strerror(errno)); return -errno; } } socketsetcork(s->fd, 0); qemuaiosetfdhandler(s->fd, coreadresponse, NULL, aioflushrequest, s); qemucomutexunlock(&s->lock); return 0; } ", "target": 0}
{"func": "static int imgwritepacket(AVFormatContext *s, int streamindex, UINT8 *buf, int size) { VideoData *img = s->privdata; AVStream *st = s->streams[streamindex]; ByteIOContext pb1, *pb; AVPicture picture; int width, height, ret, size1; char filename[1024]; width = st->codec.width; height = st->codec.height; switch(st->codec.pixfmt) { case PIXFMTYUV420P: size1 = (width * height * 3) / 2; if (size != size1) return -EIO; picture.data[0] = buf; picture.data[1] = picture.data[0] + width * height; picture.data[2] = picture.data[1] + (width * height) / 4; picture.linesize[0] = width; picture.linesize[1] = width >> 1; picture.linesize[2] = width >> 1; break; case PIXFMTRGB24: size1 = (width * height * 3); if (size != size1) return -EIO; picture.data[0] = buf; picture.linesize[0] = width * 3; break; default: return -EIO; } if (getframefilename(filename, sizeof(filename), img->path, img->imgnumber) < 0) return -EIO; if (!img->ispipe) { pb = &pb1; if (urlfopen(pb, filename, URLWRONLY) < 0) return -EIO; } else { pb = &s->pb; } switch(img->imgfmt) { case IMGFMTPGMYUV: ret = pgmsave(&picture, width, height, pb, 1); break; case IMGFMTPGM: ret = pgmsave(&picture, width, height, pb, 0); break; case IMGFMTYUV: ret = yuvsave(&picture, width, height, filename); break; case IMGFMTPPM: ret = ppmsave(&picture, width, height, pb); break; } if (!img->ispipe) { urlfclose(pb); } img->imgnumber++; return 0; } ", "target": 1}
{"func": "int pcidrivehotadd(Monitor *mon, const QDict *qdict, DriveInfo *dinfo) { /* On non-x86 we don't do PCI hotplug */ monitorprintf(mon, \"Can't hot-add drive to type %d\\n\", dinfo->type); return -1; } ", "target": 1}
{"func": "static inline int yv12toyuy2unscaledaltivec(SwsContext *c, uint8t* src[], int srcStride[], int srcSliceY, int srcSliceH, uint8t* dstParam[], int dstStridea[]) { uint8t *dst=dstParam[0] + dstStridea[0]*srcSliceY; // yv12toyuy2( src[0],src[1],src[2],dst,c->srcW,srcSliceH,srcStride[0],srcStride[1],dstStride[0] ); uint8t *ysrc = src[0]; uint8t *usrc = src[1]; uint8t *vsrc = src[2]; const int width = c->srcW; const int height = srcSliceH; const int lumStride = srcStride[0]; const int chromStride = srcStride[1]; const int dstStride = dstStridea[0]; const vector unsigned char yperm = veclvsl(0, ysrc); const int vertLumPerChroma = 2; register unsigned int y; if(width&15){ yv12toyuy2( ysrc, usrc, vsrc, dst,c->srcW,srcSliceH, lumStride, chromStride, dstStride); return srcSliceH; } /* this code assume: 1) dst is 16 bytes-aligned 2) dstStride is a multiple of 16 3) width is a multiple of 16 4) lum&chrom stride are multiple of 8 */ for(y=0; y<height; y++) { int i; for (i = 0; i < width - 31; i+= 32) { \tconst unsigned int j = i >> 1; \tvector unsigned char vyA = vecld(i, ysrc); \tvector unsigned char vyB = vecld(i + 16, ysrc); \tvector unsigned char vyC = vecld(i + 32, ysrc); \tvector unsigned char vy1 = vecperm(vyA, vyB, yperm); \tvector unsigned char vy2 = vecperm(vyB, vyC, yperm); \tvector unsigned char vuA = vecld(j, usrc); \tvector unsigned char vuB = vecld(j + 16, usrc); \tvector unsigned char vu = vecperm(vuA, vuB, veclvsl(j, usrc)); \tvector unsigned char vvA = vecld(j, vsrc); \tvector unsigned char vvB = vecld(j + 16, vsrc); \tvector unsigned char vv = vecperm(vvA, vvB, veclvsl(j, vsrc)); \tvector unsigned char vuva = vecmergeh(vu, vv); \tvector unsigned char vuvb = vecmergel(vu, vv); \tvector unsigned char vyuy20 = vecmergeh(vy1, vuva); \tvector unsigned char vyuy21 = vecmergel(vy1, vuva); \tvector unsigned char vyuy22 = vecmergeh(vy2, vuvb); \tvector unsigned char vyuy23 = vecmergel(vy2, vuvb); \tvecst(vyuy20, (i << 1), dst); \tvecst(vyuy21, (i << 1) + 16, dst); \tvecst(vyuy22, (i << 1) + 32, dst); \tvecst(vyuy23, (i << 1) + 48, dst); } if (i < width) { \tconst unsigned int j = i >> 1; \tvector unsigned char vy1 = vecld(i, ysrc); \tvector unsigned char vu = vecld(j, usrc); \tvector unsigned char vv = vecld(j, vsrc); \tvector unsigned char vuva = vecmergeh(vu, vv); \tvector unsigned char vyuy20 = vecmergeh(vy1, vuva); \tvector unsigned char vyuy21 = vecmergel(vy1, vuva); \tvecst(vyuy20, (i << 1), dst); \tvecst(vyuy21, (i << 1) + 16, dst); } if((y&(vertLumPerChroma-1))==(vertLumPerChroma-1) ) \t{ \t usrc += chromStride; \t vsrc += chromStride; \t} ysrc += lumStride; dst += dstStride; } return srcSliceH; } ", "target": 1}
{"func": "void cpuloop(CPUAlphaState *env) { CPUState *cs = CPU(alphaenvgetcpu(env)); int trapnr; targetsiginfot info; abilong sysret; while (1) { cpuexecstart(cs); trapnr = cpualphaexec(cs); cpuexecend(cs); /* All of the traps imply a transition through PALcode, which implies an REI instruction has been executed. Which means that the intrflag should be cleared. */ env->intrflag = 0; switch (trapnr) { case EXCPRESET: fprintf(stderr, \"Reset requested. Exit\\n\"); exit(EXITFAILURE); break; case EXCPMCHK: fprintf(stderr, \"Machine check exception. Exit\\n\"); exit(EXITFAILURE); break; case EXCPSMPINTERRUPT: case EXCPCLKINTERRUPT: case EXCPDEVINTERRUPT: fprintf(stderr, \"External interrupt. Exit\\n\"); exit(EXITFAILURE); break; case EXCPMMFAULT: env->lockaddr = -1; info.sisigno = TARGETSIGSEGV; info.sierrno = 0; info.sicode = (pagegetflags(env->traparg0) & PAGEVALID ? TARGETSEGVACCERR : TARGETSEGVMAPERR); info.sifields.sigfault.addr = env->traparg0; queuesignal(env, info.sisigno, &info); break; case EXCPUNALIGN: env->lockaddr = -1; info.sisigno = TARGETSIGBUS; info.sierrno = 0; info.sicode = TARGETBUSADRALN; info.sifields.sigfault.addr = env->traparg0; queuesignal(env, info.sisigno, &info); break; case EXCPOPCDEC: dosigill: env->lockaddr = -1; info.sisigno = TARGETSIGILL; info.sierrno = 0; info.sicode = TARGETILLILLOPC; info.sifields.sigfault.addr = env->pc; queuesignal(env, info.sisigno, &info); break; case EXCPARITH: env->lockaddr = -1; info.sisigno = TARGETSIGFPE; info.sierrno = 0; info.sicode = TARGETFPEFLTINV; info.sifields.sigfault.addr = env->pc; queuesignal(env, info.sisigno, &info); break; case EXCPFEN: /* No-op. Linux simply re-enables the FPU. */ break; case EXCPCALLPAL: env->lockaddr = -1; switch (env->errorcode) { case 0x80: /* BPT */ info.sisigno = TARGETSIGTRAP; info.sierrno = 0; info.sicode = TARGETTRAPBRKPT; info.sifields.sigfault.addr = env->pc; queuesignal(env, info.sisigno, &info); break; case 0x81: /* BUGCHK */ info.sisigno = TARGETSIGTRAP; info.sierrno = 0; info.sicode = 0; info.sifields.sigfault.addr = env->pc; queuesignal(env, info.sisigno, &info); break; case 0x83: /* CALLSYS */ trapnr = env->ir[IRV0]; sysret = dosyscall(env, trapnr, env->ir[IRA0], env->ir[IRA1], env->ir[IRA2], env->ir[IRA3], env->ir[IRA4], env->ir[IRA5], 0, 0); if (trapnr == TARGETNRsigreturn || trapnr == TARGETNRrtsigreturn) { break; } /* Syscall writes 0 to V0 to bypass error check, similar to how this is handled internal to Linux kernel. (Ab)use trapnr temporarily as boolean indicating error. */ trapnr = (env->ir[IRV0] != 0 && sysret < 0); env->ir[IRV0] = (trapnr ? -sysret : sysret); env->ir[IRA3] = trapnr; break; case 0x86: /* IMB */ /* ??? We can probably elide the code using pageunprotect that is checking for self-modifying code. Instead we could simply call tbflush here. Until we work out the changes required to turn off the extra write protection, this can be a no-op. */ break; case 0x9E: /* RDUNIQUE */ /* Handled in the translator for usermode. */ abort(); case 0x9F: /* WRUNIQUE */ /* Handled in the translator for usermode. */ abort(); case 0xAA: /* GENTRAP */ info.sisigno = TARGETSIGFPE; switch (env->ir[IRA0]) { case TARGETGENINTOVF: info.sicode = TARGETFPEINTOVF; break; case TARGETGENINTDIV: info.sicode = TARGETFPEINTDIV; break; case TARGETGENFLTOVF: info.sicode = TARGETFPEFLTOVF; break; case TARGETGENFLTUND: info.sicode = TARGETFPEFLTUND; break; case TARGETGENFLTINV: info.sicode = TARGETFPEFLTINV; break; case TARGETGENFLTINE: info.sicode = TARGETFPEFLTRES; break; case TARGETGENROPRAND: info.sicode = 0; break; default: info.sisigno = TARGETSIGTRAP; info.sicode = 0; break; } info.sierrno = 0; info.sifields.sigfault.addr = env->pc; queuesignal(env, info.sisigno, &info); break; default: goto dosigill; } break; case EXCPDEBUG: info.sisigno = gdbhandlesig(cs, TARGETSIGTRAP); if (info.sisigno) { env->lockaddr = -1; info.sierrno = 0; info.sicode = TARGETTRAPBRKPT; queuesignal(env, info.sisigno, &info); } break; case EXCPSTLC: case EXCPSTQC: dostoreexclusive(env, env->errorcode, trapnr - EXCPSTLC); break; case EXCPINTERRUPT: /* Just indicate that signals should be handled asap. */ break; default: printf (\"Unhandled trap: 0x%x\\n\", trapnr); cpudumpstate(cs, stderr, fprintf, 0); exit(EXITFAILURE); } processpendingsignals (env); } } ", "target": 0}
{"func": "static S390PCIBusDevice *s390pcifinddevbytarget(const char *target) { int i; S390PCIBusDevice *pbdev; S390pciState *s = s390getphb(); if (!target) { return NULL; } for (i = 0; i < PCISLOTMAX; i++) { pbdev = s->pbdev[i]; if (!pbdev) { continue; } if (!strcmp(pbdev->target, target)) { return pbdev; } } return NULL; } ", "target": 0}
{"func": "static void cindecodelzss(const unsigned char *src, int srcsize, unsigned char *dst, int dstsize) { uint16t cmd; int i, sz, offset, code; unsigned char *dstend = dst + dstsize; const unsigned char *srcend = src + srcsize; while (src < srcend && dst < dstend) { code = *src++; for (i = 0; i < 8 && src < srcend && dst < dstend; ++i) { if (code & (1 << i)) { *dst++ = *src++; } else { cmd = AVRL16(src); src += 2; offset = cmd >> 4; sz = (cmd & 0xF) + 2; /* don't use memcpy/memmove here as the decoding routine (ab)uses */ /* buffer overlappings to repeat bytes in the destination */ sz = FFMIN(sz, dstend - dst); while (sz--) { *dst = *(dst - offset - 1); ++dst; } } } } } ", "target": 0}
{"func": "ffrdtparseopen(AVFormatContext *ic, int firststreamofsetidx, void *privdata, RTPDynamicProtocolHandler *handler) { RDTDemuxContext *s = avmallocz(sizeof(RDTDemuxContext)); if (!s) return NULL; s->ic = ic; s->streams = &ic->streams[firststreamofsetidx]; do { s->nstreams++; } while (firststreamofsetidx + s->nstreams < ic->nbstreams && s->streams[s->nstreams]->privdata == s->streams[0]->privdata); s->prevsetid = -1; s->prevstreamid = -1; s->prevtimestamp = -1; s->parsepacket = handler->parsepacket; s->dynamicprotocolcontext = privdata; return s; } ", "target": 1}
{"func": "static int qcow2cowritev(BlockDriverState *bs, int64t sectornum, int remainingsectors, QEMUIOVector *qiov) { BDRVQcowState *s = bs->opaque; int indexincluster; int nend; int ret; int curnrsectors; /* number of sectors in current iteration */ QCowL2Meta l2meta; uint64t clusteroffset; QEMUIOVector hdqiov; uint64t bytesdone = 0; uint8t *clusterdata = NULL; l2meta.nbclusters = 0; qemucoqueueinit(&l2meta.dependentrequests); qemuiovecinit(&hdqiov, qiov->niov); s->clustercacheoffset = -1; /* disable compressed cache */ qemucomutexlock(&s->lock); while (remainingsectors != 0) { indexincluster = sectornum & (s->clustersectors - 1); nend = indexincluster + remainingsectors; if (s->cryptmethod && nend > QCOWMAXCRYPTCLUSTERS * s->clustersectors) { nend = QCOWMAXCRYPTCLUSTERS * s->clustersectors; } ret = qcow2allocclusteroffset(bs, sectornum << 9, indexincluster, nend, &curnrsectors, &l2meta); if (ret < 0) { goto fail; } clusteroffset = l2meta.clusteroffset; assert((clusteroffset & 511) == 0); qemuiovecreset(&hdqiov); qemuioveccopy(&hdqiov, qiov, bytesdone, curnrsectors * 512); if (s->cryptmethod) { if (!clusterdata) { clusterdata = gmalloc0(QCOWMAXCRYPTCLUSTERS * s->clustersize); } assert(hdqiov.size <= QCOWMAXCRYPTCLUSTERS * s->clustersize); qemuiovectobuffer(&hdqiov, clusterdata); qcow2encryptsectors(s, sectornum, clusterdata, clusterdata, curnrsectors, 1, &s->aesencryptkey); qemuiovecreset(&hdqiov); qemuiovecadd(&hdqiov, clusterdata, curnrsectors * 512); } BLKDBGEVENT(bs->file, BLKDBGWRITEAIO); qemucomutexunlock(&s->lock); ret = bdrvcowritev(bs->file, (clusteroffset >> 9) + indexincluster, curnrsectors, &hdqiov); qemucomutexlock(&s->lock); if (ret < 0) { goto fail; } ret = qcow2allocclusterlinkl2(bs, &l2meta); rundependentrequests(s, &l2meta); if (ret < 0) { goto fail; } remainingsectors -= curnrsectors; sectornum += curnrsectors; bytesdone += curnrsectors * 512; } ret = 0; fail: qemucomutexunlock(&s->lock); qemuiovecdestroy(&hdqiov); return ret; }", "target": 1}
{"func": "int vhostdevinit(struct vhostdev *hdev, void *opaque, VhostBackendType backendtype, bool force) { uint64t features; int i, r; if (vhostsetbackendtype(hdev, backendtype) < 0) { close((uintptrt)opaque); return -1; } if (hdev->vhostops->vhostbackendinit(hdev, opaque) < 0) { close((uintptrt)opaque); return -errno; } r = hdev->vhostops->vhostcall(hdev, VHOSTSETOWNER, NULL); if (r < 0) { goto fail; } r = hdev->vhostops->vhostcall(hdev, VHOSTGETFEATURES, &features); if (r < 0) { goto fail; } for (i = 0; i < hdev->nvqs; ++i) { r = vhostvirtqueueinit(hdev, hdev->vqs + i, i); if (r < 0) { goto failvq; } } hdev->features = features; hdev->memorylistener = (MemoryListener) { .begin = vhostbegin, .commit = vhostcommit, .regionadd = vhostregionadd, .regiondel = vhostregiondel, .regionnop = vhostregionnop, .logstart = vhostlogstart, .logstop = vhostlogstop, .logsync = vhostlogsync, .logglobalstart = vhostlogglobalstart, .logglobalstop = vhostlogglobalstop, .eventfdadd = vhosteventfdadd, .eventfddel = vhosteventfddel, .priority = 10 }; hdev->migrationblocker = NULL; if (!(hdev->features & (0x1ULL << VHOSTFLOGALL))) { errorsetg(&hdev->migrationblocker, \"Migration disabled: vhost lacks VHOSTFLOGALL feature.\"); migrateaddblocker(hdev->migrationblocker); } hdev->mem = gmalloc0(offsetof(struct vhostmemory, regions)); hdev->nmemsections = 0; hdev->memsections = NULL; hdev->log = NULL; hdev->logsize = 0; hdev->logenabled = false; hdev->started = false; hdev->memorychanged = false; memorylistenerregister(&hdev->memorylistener, &addressspacememory); hdev->force = force; return 0; failvq: while (--i >= 0) { vhostvirtqueuecleanup(hdev->vqs + i); } fail: r = -errno; hdev->vhostops->vhostbackendcleanup(hdev); return r; } ", "target": 1}
{"func": "int ffsetsystematicpal2(uint32t pal[256], enum AVPixelFormat pixfmt) { int i; for (i = 0; i < 256; i++) { int r, g, b; switch (pixfmt) { case AVPIXFMTRGB8: r = (i>>5 )*36; g = ((i>>2)&7)*36; b = (i&3 )*85; break; case AVPIXFMTBGR8: b = (i>>6 )*85; g = ((i>>3)&7)*36; r = (i&7 )*36; break; case AVPIXFMTRGB4BYTE: r = (i>>3 )*255; g = ((i>>1)&3)*85; b = (i&1 )*255; break; case AVPIXFMTBGR4BYTE: b = (i>>3 )*255; g = ((i>>1)&3)*85; r = (i&1 )*255; break; case AVPIXFMTGRAY8: r = b = g = i; break; default: return AVERROR(EINVAL); } pal[i] = b + (g<<8) + (r<<16) + (0xFF<<24); } return 0; } ", "target": 1}
{"func": "void qmptransaction(TransactionActionList *devlist, Error **errp) { TransactionActionList *deventry = devlist; BlkTransactionState *state, *next; Error *localerr = NULL; QSIMPLEQHEAD(snapbdrvstates, BlkTransactionState) snapbdrvstates; QSIMPLEQINIT(&snapbdrvstates); /* drain all i/o before any operations */ bdrvdrainall(); /* We don't do anything in this loop that commits us to the operations */ while (NULL != deventry) { TransactionAction *devinfo = NULL; const BdrvActionOps *ops; devinfo = deventry->value; deventry = deventry->next; assert(devinfo->kind < ARRAYSIZE(actions)); ops = &actions[devinfo->kind]; assert(ops->instancesize > 0); state = gmalloc0(ops->instancesize); state->ops = ops; state->action = devinfo; QSIMPLEQINSERTTAIL(&snapbdrvstates, state, entry); state->ops->prepare(state, &localerr); if (localerr) { errorpropagate(errp, localerr); goto deleteandfail; } } QSIMPLEQFOREACH(state, &snapbdrvstates, entry) { if (state->ops->commit) { state->ops->commit(state); } } /* success */ goto exit; deleteandfail: /* failure, and it is all-or-none; roll back all operations */ QSIMPLEQFOREACH(state, &snapbdrvstates, entry) { if (state->ops->abort) { state->ops->abort(state); } } exit: QSIMPLEQFOREACHSAFE(state, &snapbdrvstates, entry, next) { if (state->ops->clean) { state->ops->clean(state); } gfree(state); } } ", "target": 0}
{"func": "static int intelhdainit(PCIDevice *pci) { IntelHDAState *d = DOUPCAST(IntelHDAState, pci, pci); uint8t *conf = d->pci.config; d->name = d->pci.qdev.info->name; pciconfigsetvendorid(conf, PCIVENDORIDINTEL); pciconfigsetdeviceid(conf, 0x2668); pciconfigsetrevision(conf, 1); pciconfigsetclass(conf, PCICLASSMULTIMEDIAHDAUDIO); pciconfigsetinterruptpin(conf, 1); /* HDCTL off 0x40 bit 0 selects signaling mode (1-HDA, 0 - Ac97) 18.1.19 */ conf[0x40] = 0x01; d->mmioaddr = cpuregisteriomemory(intelhdammioread, intelhdammiowrite, d, DEVICENATIVEENDIAN); pciregisterbarsimple(&d->pci, 0, 0x4000, 0, d->mmioaddr); if (d->msi) { msiinit(&d->pci, 0x50, 1, true, false); } hdacodecbusinit(&d->pci.qdev, &d->codecs, intelhdaresponse, intelhdaxfer); return 0; } ", "target": 0}
{"func": "static BlockDriverAIOCB *rawaiowritev(BlockDriverState *bs, int64t sectornum, QEMUIOVector *qiov, int nbsectors, BlockDriverCompletionFunc *cb, void *opaque) { RawAIOCB *acb; acb = rawaiosetup(bs, sectornum, qiov, nbsectors, cb, opaque); if (!acb) return NULL; if (qemupaiowrite(&acb->aiocb) < 0) { rawaioremove(acb); return NULL; } return &acb->common; } ", "target": 0}
{"func": "static inline void preddirectmotion(H264Context * const h, int *mbtype){ MpegEncContext * const s = &h->s; const int mbxy = s->mbx + s->mby*s->mbstride; const int b8xy = 2*s->mbx + 2*s->mby*h->b8stride; const int b4xy = 4*s->mbx + 4*s->mby*h->bstride; const int mbtypecol = h->reflist[1][0].mbtype[mbxy]; const int16t (*l1mv0)[2] = (const int16t (*)[2]) &h->reflist[1][0].motionval[0][b4xy]; const int8t *l1ref0 = &h->reflist[1][0].refindex[0][b8xy]; const int isb8x8 = IS8X8(*mbtype); int submbtype; int i8, i4; if(IS8X8(mbtypecol) && !h->sps.direct8x8inferenceflag){ /* FIXME save sub mb types from previous frames (or derive from MVs) * so we know exactly what block size to use */ submbtype = MBTYPE8x8|MBTYPEP0L0|MBTYPEP0L1|MBTYPEDIRECT2; /* BSUB4x4 */ *mbtype = MBTYPE8x8; }else if(!isb8x8 && (IS16X16(mbtypecol) || ISINTRA(mbtypecol))){ submbtype = MBTYPE16x16|MBTYPEP0L0|MBTYPEP0L1|MBTYPEDIRECT2; /* BSUB8x8 */ *mbtype = MBTYPE16x16|MBTYPEP0L0|MBTYPEP0L1|MBTYPEDIRECT2; /* B16x16 */ }else{ submbtype = MBTYPE16x16|MBTYPEP0L0|MBTYPEP0L1|MBTYPEDIRECT2; /* BSUB8x8 */ *mbtype = MBTYPE8x8; } if(!isb8x8) *mbtype |= MBTYPEDIRECT2; tprintf(\"mbtype = %08x, submbtype = %08x, isb8x8 = %d, mbtypecol = %08x\\n\", *mbtype, submbtype, isb8x8, mbtypecol); if(h->directspatialmvpred){ int ref[2]; int mv[2][2]; int list; /* ref = min(neighbors) */ for(list=0; list<2; list++){ int refa = h->refcache[list][scan8[0] - 1]; int refb = h->refcache[list][scan8[0] - 8]; int refc = h->refcache[list][scan8[0] - 8 + 4]; if(refc == -2) refc = h->refcache[list][scan8[0] - 8 - 1]; ref[list] = refa; if(ref[list] < 0 || (refb < ref[list] && refb >= 0)) ref[list] = refb; if(ref[list] < 0 || (refc < ref[list] && refc >= 0)) ref[list] = refc; if(ref[list] < 0) ref[list] = -1; } if(ref[0] < 0 && ref[1] < 0){ ref[0] = ref[1] = 0; mv[0][0] = mv[0][1] = mv[1][0] = mv[1][1] = 0; }else{ for(list=0; list<2; list++){ if(ref[list] >= 0) predmotion(h, 0, 4, list, ref[list], &mv[list][0], &mv[list][1]); else mv[list][0] = mv[list][1] = 0; } } if(ref[1] < 0){ *mbtype &= ~MBTYPEP0L1; submbtype &= ~MBTYPEP0L1; }else if(ref[0] < 0){ *mbtype &= ~MBTYPEP0L0; submbtype &= ~MBTYPEP0L0; } if(IS16X16(*mbtype)){ fillrectangle(&h->refcache[0][scan8[0]], 4, 4, 8, ref[0], 1); fillrectangle(&h->refcache[1][scan8[0]], 4, 4, 8, ref[1], 1); if(!ISINTRA(mbtypecol) && l1ref0[0] == 0 && ABS(l1mv0[0][0]) <= 1 && ABS(l1mv0[0][1]) <= 1){ if(ref[0] > 0) fillrectangle(&h->mvcache[0][scan8[0]], 4, 4, 8, pack16to32(mv[0][0],mv[0][1]), 4); else fillrectangle(&h->mvcache[0][scan8[0]], 4, 4, 8, 0, 4); if(ref[1] > 0) fillrectangle(&h->mvcache[1][scan8[0]], 4, 4, 8, pack16to32(mv[1][0],mv[1][1]), 4); else fillrectangle(&h->mvcache[1][scan8[0]], 4, 4, 8, 0, 4); }else{ fillrectangle(&h->mvcache[0][scan8[0]], 4, 4, 8, pack16to32(mv[0][0],mv[0][1]), 4); fillrectangle(&h->mvcache[1][scan8[0]], 4, 4, 8, pack16to32(mv[1][0],mv[1][1]), 4); } }else{ for(i8=0; i8<4; i8++){ const int x8 = i8&1; const int y8 = i8>>1; if(isb8x8 && !ISDIRECT(h->submbtype[i8])) continue; h->submbtype[i8] = submbtype; fillrectangle(&h->mvcache[0][scan8[i8*4]], 2, 2, 8, pack16to32(mv[0][0],mv[0][1]), 4); fillrectangle(&h->mvcache[1][scan8[i8*4]], 2, 2, 8, pack16to32(mv[1][0],mv[1][1]), 4); fillrectangle(&h->refcache[0][scan8[i8*4]], 2, 2, 8, ref[0], 1); fillrectangle(&h->refcache[1][scan8[i8*4]], 2, 2, 8, ref[1], 1); /* colzeroflag */ if(!ISINTRA(mbtypecol) && l1ref0[x8 + y8*h->b8stride] == 0){ for(i4=0; i4<4; i4++){ const int16t *mvcol = l1mv0[x8*2 + (i4&1) + (y8*2 + (i4>>1))*h->bstride]; if(ABS(mvcol[0]) <= 1 && ABS(mvcol[1]) <= 1){ if(ref[0] == 0) *(uint32t*)h->mvcache[0][scan8[i8*4+i4]] = 0; if(ref[1] == 0) *(uint32t*)h->mvcache[1][scan8[i8*4+i4]] = 0; } } } } } }else{ /* direct temporal mv pred */ /* FIXME assumes that L1ref0 used the same ref lists as current frame */ if(IS16X16(*mbtype)){ fillrectangle(&h->refcache[1][scan8[0]], 4, 4, 8, 0, 1); if(ISINTRA(mbtypecol)){ fillrectangle(&h->refcache[0][scan8[0]], 4, 4, 8, 0, 1); fillrectangle(&h-> mvcache[0][scan8[0]], 4, 4, 8, 0, 4); fillrectangle(&h-> mvcache[1][scan8[0]], 4, 4, 8, 0, 4); }else{ const int ref0 = l1ref0[0]; const int distscalefactor = h->distscalefactor[ref0]; const int16t *mvcol = l1mv0[0]; int mvl0[2]; mvl0[0] = (distscalefactor * mvcol[0] + 128) >> 8; mvl0[1] = (distscalefactor * mvcol[1] + 128) >> 8; fillrectangle(&h->refcache[0][scan8[0]], 4, 4, 8, ref0, 1); fillrectangle(&h-> mvcache[0][scan8[0]], 4, 4, 8, pack16to32(mvl0[0],mvl0[1]), 4); fillrectangle(&h-> mvcache[1][scan8[0]], 4, 4, 8, pack16to32(mvl0[0]-mvcol[0],mvl0[1]-mvcol[1]), 4); } }else{ for(i8=0; i8<4; i8++){ const int x8 = i8&1; const int y8 = i8>>1; int ref0, distscalefactor; if(isb8x8 && !ISDIRECT(h->submbtype[i8])) continue; h->submbtype[i8] = submbtype; if(ISINTRA(mbtypecol)){ fillrectangle(&h->refcache[0][scan8[i8*4]], 2, 2, 8, 0, 1); fillrectangle(&h->refcache[1][scan8[i8*4]], 2, 2, 8, 0, 1); fillrectangle(&h-> mvcache[0][scan8[i8*4]], 2, 2, 8, 0, 4); fillrectangle(&h-> mvcache[1][scan8[i8*4]], 2, 2, 8, 0, 4); continue; } ref0 = l1ref0[x8 + y8*h->b8stride]; distscalefactor = h->distscalefactor[ref0]; fillrectangle(&h->refcache[0][scan8[i8*4]], 2, 2, 8, ref0, 1); fillrectangle(&h->refcache[1][scan8[i8*4]], 2, 2, 8, 0, 1); for(i4=0; i4<4; i4++){ const int16t *mvcol = l1mv0[x8*2 + (i4&1) + (y8*2 + (i4>>1))*h->bstride]; int16t *mvl0 = h->mvcache[0][scan8[i8*4+i4]]; mvl0[0] = (distscalefactor * mvcol[0] + 128) >> 8; mvl0[1] = (distscalefactor * mvcol[1] + 128) >> 8; *(uint32t*)h->mvcache[1][scan8[i8*4+i4]] = pack16to32(mvl0[0]-mvcol[0],mvl0[1]-mvcol[1]); } } } } } ", "target": 0}
{"func": "static inline uint32t insnget(CPUX86State *env, DisasContext *s, TCGMemOp ot) { uint32t ret; switch (ot) { case MO8: ret = cpuldubcode(env, s->pc); s->pc++; break; case MO16: ret = cpulduwcode(env, s->pc); s->pc += 2; break; case MO32: #ifdef TARGETX8664 case MO64: #endif ret = cpuldlcode(env, s->pc); s->pc += 4; break; default: tcgabort(); } return ret; } ", "target": 0}
{"func": "static void bdrvthrottlewritetimercb(void *opaque) { BlockDriverState *bs = opaque; qemucoenternext(&bs->throttledreqs[1]); } ", "target": 0}
{"func": "static int findpte32(CPUPPCState *env, mmuctxt *ctx, int h, int rw, int type, int targetpagebits) { hwaddr ptegoff; targetulong pte0, pte1; int i, good = -1; int ret, r; ret = -1; /* No entry found */ ptegoff = getptegoffset(env, ctx->hash[h], HASHPTESIZE32); for (i = 0; i < 8; i++) { if (env->externalhtab) { pte0 = ldlp(env->externalhtab + ptegoff + (i * 8)); pte1 = ldlp(env->externalhtab + ptegoff + (i * 8) + 4); } else { pte0 = ldlphys(env->htabbase + ptegoff + (i * 8)); pte1 = ldlphys(env->htabbase + ptegoff + (i * 8) + 4); } r = ptecheckhash32(ctx, pte0, pte1, h, rw, type); LOGMMU(\"Load pte from %08\" HWADDRPRIx \" => \" TARGETFMTlx \" \" TARGETFMTlx \" %d %d %d \" TARGETFMTlx \"\\n\", ptegoff + (i * 8), pte0, pte1, (int)(pte0 >> 31), h, (int)((pte0 >> 6) & 1), ctx->ptem); switch (r) { case -3: /* PTE inconsistency */ return -1; case -2: /* Access violation */ ret = -2; good = i; break; case -1: default: /* No PTE match */ break; case 0: /* access granted */ /* XXX: we should go on looping to check all PTEs consistency * but if we can speed-up the whole thing as the * result would be undefined if PTEs are not consistent. */ ret = 0; good = i; goto done; } } if (good != -1) { done: LOGMMU(\"found PTE at addr %08\" HWADDRPRIx \" prot=%01x ret=%d\\n\", ctx->raddr, ctx->prot, ret); /* Update page flags */ pte1 = ctx->raddr; if (pteupdateflags(ctx, &pte1, ret, rw) == 1) { if (env->externalhtab) { stlp(env->externalhtab + ptegoff + (good * 8) + 4, pte1); } else { stlphysnotdirty(env->htabbase + ptegoff + (good * 8) + 4, pte1); } } } /* We have a TLB that saves 4K pages, so let's * split a huge page to 4k chunks */ if (targetpagebits != TARGETPAGEBITS) { ctx->raddr |= (ctx->eaddr & ((1 << targetpagebits) - 1)) & TARGETPAGEMASK; } return ret; } ", "target": 0}
{"func": "static int kvmputxcrs(CPUState *env) { #ifdef KVMCAPXCRS struct kvmxcrs xcrs; if (!kvmhasxcrs()) return 0; xcrs.nrxcrs = 1; xcrs.flags = 0; xcrs.xcrs[0].xcr = 0; xcrs.xcrs[0].value = env->xcr0; return kvmvcpuioctl(env, KVMSETXCRS, &xcrs); #else return 0; #endif } ", "target": 0}
{"func": "static ExitStatus genbcondinternal(DisasContext *ctx, TCGCond cond, TCGv cmp, int32t disp) { uint64t dest = ctx->pc + (disp << 2); int labtrue = gennewlabel(); if (usegototb(ctx, dest)) { tcggenbrcondii64(cond, cmp, 0, labtrue); tcggengototb(0); tcggenmovii64(cpupc, ctx->pc); tcggenexittb((uintptrt)ctx->tb); gensetlabel(labtrue); tcggengototb(1); tcggenmovii64(cpupc, dest); tcggenexittb((uintptrt)ctx->tb + 1); return EXITGOTOTB; } else { TCGvi64 z = tcgconsti64(0); TCGvi64 d = tcgconsti64(dest); TCGvi64 p = tcgconsti64(ctx->pc); tcggenmovcondi64(cond, cpupc, cmp, z, d, p); tcgtempfreei64(z); tcgtempfreei64(d); tcgtempfreei64(p); return EXITPCUPDATED; } } ", "target": 0}
{"func": "static uint32t gt64120readconfig(PCIDevice *d, uint32t address, int len) { uint32t val = pcidefaultreadconfig(d, address, len); #ifdef TARGETWORDSBIGENDIAN val = bswap32(val); #endif return val; } ", "target": 0}
{"func": "static void rtasgettimeofday(PowerPCCPU *cpu, sPAPREnvironment *spapr, uint32t token, uint32t nargs, targetulong args, uint32t nret, targetulong rets) { struct tm tm; if (nret != 8) { rtasst(rets, 0, RTASOUTPARAMERROR); return; } qemugettimedate(&tm, spapr->rtcoffset); rtasst(rets, 0, RTASOUTSUCCESS); rtasst(rets, 1, tm.tmyear + 1900); rtasst(rets, 2, tm.tmmon + 1); rtasst(rets, 3, tm.tmmday); rtasst(rets, 4, tm.tmhour); rtasst(rets, 5, tm.tmmin); rtasst(rets, 6, tm.tmsec); rtasst(rets, 7, 0); /* we don't do nanoseconds */ } ", "target": 1}
{"func": "void qmpblockjobsetspeed(const char *device, int64t speed, Error **errp) { BlockJob *job = findblockjob(device); if (!job) { errorset(errp, QERRBLOCKJOBNOTACTIVE, device); return; } blockjobsetspeed(job, speed, errp); } ", "target": 0}
{"func": "static int createstream(AVFormatContext *s) { XCBGrabContext *c = s->privdata; AVStream *st = avformatnewstream(s, NULL); xcbgetgeometrycookiet gc; xcbgetgeometryreplyt *geo; int ret; if (!st) return AVERROR(ENOMEM); ret = avparsevideosize(&c->width, &c->height, c->videosize); if (ret < 0) return ret; ret = avparsevideorate(&st->avgframerate, c->framerate); if (ret < 0) return ret; avprivsetptsinfo(st, 64, 1, 1000000); gc = xcbgetgeometry(c->conn, c->screen->root); geo = xcbgetgeometryreply(c->conn, gc, NULL); c->width = FFMIN(geo->width, c->width); c->height = FFMIN(geo->height, c->height); c->timebase = (AVRational){ st->avgframerate.den, st->avgframerate.num }; c->timeframe = avgettime(); st->codec->codectype = AVMEDIATYPEVIDEO; st->codec->codecid = AVCODECIDRAWVIDEO; st->codec->width = c->width; st->codec->height = c->height; st->codec->timebase = c->timebase; ret = pixfmtfrompixmapformat(s, geo->depth, &st->codec->pixfmt); free(geo); return ret; } ", "target": 0}
{"func": "static int vorbisparsesetuphdrcodebooks(vorbiscontext *vc) { unsigned cb; uint8t *tmpvlcbits; uint32t *tmpvlccodes; GetBitContext *gb = &vc->gb; uint16t *codebookmultiplicands; int ret = 0; vc->codebookcount = getbits(gb, 8) + 1; avdlog(NULL, \" Codebooks: %d \\n\", vc->codebookcount); vc->codebooks = avmallocz(vc->codebookcount * sizeof(*vc->codebooks)); tmpvlcbits = avmallocz(VMAXVLCS * sizeof(*tmpvlcbits)); tmpvlccodes = avmallocz(VMAXVLCS * sizeof(*tmpvlccodes)); codebookmultiplicands = avmalloc(VMAXVLCS * sizeof(*codebookmultiplicands)); for (cb = 0; cb < vc->codebookcount; ++cb) { vorbiscodebook *codebooksetup = &vc->codebooks[cb]; unsigned ordered, t, entries, usedentries = 0; avdlog(NULL, \" %u. Codebook\\n\", cb); if (getbits(gb, 24) != 0x564342) { avlog(vc->avctx, AVLOGERROR, \" %u. Codebook setup data corrupt.\\n\", cb); ret = AVERRORINVALIDDATA; goto error; } codebooksetup->dimensions=getbits(gb, 16); if (codebooksetup->dimensions > 16 || codebooksetup->dimensions == 0) { avlog(vc->avctx, AVLOGERROR, \" %u. Codebook's dimension is invalid (%d).\\n\", cb, codebooksetup->dimensions); ret = AVERRORINVALIDDATA; goto error; } entries = getbits(gb, 24); if (entries > VMAXVLCS) { avlog(vc->avctx, AVLOGERROR, \" %u. Codebook has too many entries (%u).\\n\", cb, entries); ret = AVERRORINVALIDDATA; goto error; } ordered = getbits1(gb); avdlog(NULL, \" codebookdimensions %d, codebookentries %u\\n\", codebooksetup->dimensions, entries); if (!ordered) { unsigned ce, flag; unsigned sparse = getbits1(gb); avdlog(NULL, \" not ordered \\n\"); if (sparse) { avdlog(NULL, \" sparse \\n\"); usedentries = 0; for (ce = 0; ce < entries; ++ce) { flag = getbits1(gb); if (flag) { tmpvlcbits[ce] = getbits(gb, 5) + 1; ++usedentries; } else tmpvlcbits[ce] = 0; } } else { avdlog(NULL, \" not sparse \\n\"); usedentries = entries; for (ce = 0; ce < entries; ++ce) tmpvlcbits[ce] = getbits(gb, 5) + 1; } } else { unsigned currententry = 0; unsigned currentlength = getbits(gb, 5) + 1; avdlog(NULL, \" ordered, current length: %u\\n\", currentlength); //FIXME usedentries = entries; for (; currententry < usedentries && currentlength <= 32; ++currentlength) { unsigned i, number; avdlog(NULL, \" number bits: %u \", ilog(entries - currententry)); number = getbits(gb, ilog(entries - currententry)); avdlog(NULL, \" number: %u\\n\", number); for (i = currententry; i < number+currententry; ++i) if (i < usedentries) tmpvlcbits[i] = currentlength; currententry+=number; } if (currententry>usedentries) { avlog(vc->avctx, AVLOGERROR, \" More codelengths than codes in codebook. \\n\"); ret = AVERRORINVALIDDATA; goto error; } } codebooksetup->lookuptype = getbits(gb, 4); avdlog(NULL, \" lookup type: %d : %s \\n\", codebooksetup->lookuptype, codebooksetup->lookuptype ? \"vq\" : \"no lookup\"); // If the codebook is used for (inverse) VQ, calculate codevectors. if (codebooksetup->lookuptype == 1) { unsigned i, j, k; unsigned codebooklookupvalues = ffvorbisnthroot(entries, codebooksetup->dimensions); float codebookminimumvalue = vorbisfloat2float(getbitslong(gb, 32)); float codebookdeltavalue = vorbisfloat2float(getbitslong(gb, 32)); unsigned codebookvaluebits = getbits(gb, 4) + 1; unsigned codebooksequencep = getbits1(gb); avdlog(NULL, \" We expect %d numbers for building the codevectors. \\n\", codebooklookupvalues); avdlog(NULL, \" delta %f minmum %f \\n\", codebookdeltavalue, codebookminimumvalue); for (i = 0; i < codebooklookupvalues; ++i) { codebookmultiplicands[i] = getbits(gb, codebookvaluebits); avdlog(NULL, \" multiplicands*delta+minmum : %e \\n\", (float)codebookmultiplicands[i] * codebookdeltavalue + codebookminimumvalue); avdlog(NULL, \" multiplicand %u\\n\", codebookmultiplicands[i]); } // Weed out unused vlcs and build codevector vector codebooksetup->codevectors = usedentries ? avmallocz(usedentries * codebooksetup->dimensions * sizeof(*codebooksetup->codevectors)) : NULL; for (j = 0, i = 0; i < entries; ++i) { unsigned dim = codebooksetup->dimensions; if (tmpvlcbits[i]) { float last = 0.0; unsigned lookupoffset = i; avdlog(vc->avctx, \"Lookup offset %u ,\", i); for (k = 0; k < dim; ++k) { unsigned multiplicandoffset = lookupoffset % codebooklookupvalues; codebooksetup->codevectors[j * dim + k] = codebookmultiplicands[multiplicandoffset] * codebookdeltavalue + codebookminimumvalue + last; if (codebooksequencep) last = codebooksetup->codevectors[j * dim + k]; lookupoffset/=codebooklookupvalues; } tmpvlcbits[j] = tmpvlcbits[i]; avdlog(vc->avctx, \"real lookup offset %u, vector: \", j); for (k = 0; k < dim; ++k) avdlog(vc->avctx, \" %f \", codebooksetup->codevectors[j * dim + k]); avdlog(vc->avctx, \"\\n\"); ++j; } } if (j != usedentries) { avlog(vc->avctx, AVLOGERROR, \"Bug in codevector vector building code. \\n\"); ret = AVERRORINVALIDDATA; goto error; } entries = usedentries; } else if (codebooksetup->lookuptype >= 2) { avlog(vc->avctx, AVLOGERROR, \"Codebook lookup type not supported. \\n\"); ret = AVERRORINVALIDDATA; goto error; } // Initialize VLC table if (ffvorbislen2vlc(tmpvlcbits, tmpvlccodes, entries)) { avlog(vc->avctx, AVLOGERROR, \" Invalid code lengths while generating vlcs. \\n\"); ret = AVERRORINVALIDDATA; goto error; } codebooksetup->maxdepth = 0; for (t = 0; t < entries; ++t) if (tmpvlcbits[t] >= codebooksetup->maxdepth) codebooksetup->maxdepth = tmpvlcbits[t]; if (codebooksetup->maxdepth > 3 * VNBBITS) codebooksetup->nbbits = VNBBITS2; else codebooksetup->nbbits = VNBBITS; codebooksetup->maxdepth = (codebooksetup->maxdepth+codebooksetup->nbbits - 1) / codebooksetup->nbbits; if ((ret = initvlc(&codebooksetup->vlc, codebooksetup->nbbits, entries, tmpvlcbits, sizeof(*tmpvlcbits), sizeof(*tmpvlcbits), tmpvlccodes, sizeof(*tmpvlccodes), sizeof(*tmpvlccodes), INITVLCLE))) { avlog(vc->avctx, AVLOGERROR, \" Error generating vlc tables. \\n\"); goto error; } } avfree(tmpvlcbits); avfree(tmpvlccodes); avfree(codebookmultiplicands); return 0; // Error: error: avfree(tmpvlcbits); avfree(tmpvlccodes); avfree(codebookmultiplicands); return ret; } ", "target": 0}
{"func": "static int htabsavelaterpass(QEMUFile *f, sPAPREnvironment *spapr, int64t maxns) { bool final = maxns < 0; int htabslots = HTABSIZE(spapr) / HASHPTESIZE64; int examined = 0, sent = 0; int index = spapr->htabsaveindex; int64t starttime = qemuclockgetns(QEMUCLOCKREALTIME); assert(!spapr->htabfirstpass); do { int chunkstart, invalidstart; /* Consume non-dirty HPTEs */ while ((index < htabslots) && !HPTEDIRTY(HPTE(spapr->htab, index))) { index++; examined++; } chunkstart = index; /* Consume valid dirty HPTEs */ while ((index < htabslots) && HPTEDIRTY(HPTE(spapr->htab, index)) && HPTEVALID(HPTE(spapr->htab, index))) { CLEANHPTE(HPTE(spapr->htab, index)); index++; examined++; } invalidstart = index; /* Consume invalid dirty HPTEs */ while ((index < htabslots) && HPTEDIRTY(HPTE(spapr->htab, index)) && !HPTEVALID(HPTE(spapr->htab, index))) { CLEANHPTE(HPTE(spapr->htab, index)); index++; examined++; } if (index > chunkstart) { int nvalid = invalidstart - chunkstart; int ninvalid = index - invalidstart; qemuputbe32(f, chunkstart); qemuputbe16(f, nvalid); qemuputbe16(f, ninvalid); qemuputbuffer(f, HPTE(spapr->htab, chunkstart), HASHPTESIZE64 * nvalid); sent += index - chunkstart; if (!final && (qemuclockgetns(QEMUCLOCKREALTIME) - starttime) > maxns) { break; } } if (examined >= htabslots) { break; } if (index >= htabslots) { assert(index == htabslots); index = 0; } } while ((examined < htabslots) && (!qemufileratelimit(f) || final)); if (index >= htabslots) { assert(index == htabslots); index = 0; } spapr->htabsaveindex = index; return (examined >= htabslots) && (sent == 0) ? 1 : 0; } ", "target": 1}
{"func": "static abilong dosocket(int domain, int type, int protocol) { int targettype = type; int ret; ret = targettohostsocktype(&type); if (ret) { return ret; } if (domain == PFNETLINK) return -TARGETEAFNOSUPPORT; if (domain == AFPACKET || (domain == AFINET && type == SOCKPACKET)) { protocol = tswap16(protocol); } ret = geterrno(socket(domain, type, protocol)); if (ret >= 0) { ret = sockflagsfixup(ret, targettype); if (type == SOCKPACKET) { /* Manage an obsolete case : * if socket type is SOCKPACKET, bind by name */ fdtransregister(ret, &targetpackettrans); } } return ret; } ", "target": 0}
{"func": "int kvmppcgethypercall(CPUPPCState *env, uint8t *buf, int buflen) { PowerPCCPU *cpu = ppcenvgetcpu(env); CPUState *cs = CPU(cpu); uint32t *hc = (uint32t*)buf; struct kvmppcpvinfo pvinfo; if (kvmcheckextension(cs->kvmstate, KVMCAPPPCGETPVINFO) && !kvmvmioctl(cs->kvmstate, KVMPPCGETPVINFO, &pvinfo)) { memcpy(buf, pvinfo.hcall, buflen); return 0; } /* * Fallback to always fail hypercalls: * * li r3, -1 * nop * nop * nop */ hc[0] = 0x3860ffff; hc[1] = 0x60000000; hc[2] = 0x60000000; hc[3] = 0x60000000; return 0; } ", "target": 0}
{"func": "void processincomingmigration(QEMUFile *f) { if (qemuloadvmstate(f) < 0) { fprintf(stderr, \"load of migration failed\\n\"); exit(0); } qemuannounceself(); DPRINTF(\"successfully loaded vm state\\n\"); incomingexpected = false; if (autostart) { vmstart(); } else { runstateset(RSTATEPRELAUNCH); } } ", "target": 0}
{"func": "static int rv40decodembinfo(RV34DecContext *r) { MpegEncContext *s = &r->s; GetBitContext *gb = &s->gb; int q, i; int prevtype = 0; int mbpos = s->mbx + s->mby * s->mbstride; int blocks[RV34MBTYPES] = {0}; int count = 0; if(!r->s.mbskiprun) r->s.mbskiprun = svq3getuegolomb(gb) + 1; if(--r->s.mbskiprun) return RV34MBSKIP; if(r->availcache[6-1]) blocks[r->mbtype[mbpos - 1]]++; if(r->availcache[6-4]){ blocks[r->mbtype[mbpos - s->mbstride]]++; if(r->availcache[6-2]) blocks[r->mbtype[mbpos - s->mbstride + 1]]++; if(r->availcache[6-5]) blocks[r->mbtype[mbpos - s->mbstride - 1]]++; } for(i = 0; i < RV34MBTYPES; i++){ if(blocks[i] > count){ count = blocks[i]; prevtype = i; } } if(s->picttype == AVPICTURETYPEP){ prevtype = blocknumtoptypevlcnum[prevtype]; q = getvlc2(gb, ptypevlc[prevtype].table, PTYPEVLCBITS, 1); if(q < PBTYPEESCAPE) return q; q = getvlc2(gb, ptypevlc[prevtype].table, PTYPEVLCBITS, 1); avlog(s->avctx, AVLOGERROR, \"Dquant for P-frame\\n\"); }else{ prevtype = blocknumtobtypevlcnum[prevtype]; q = getvlc2(gb, btypevlc[prevtype].table, BTYPEVLCBITS, 1); if(q < PBTYPEESCAPE) return q; q = getvlc2(gb, btypevlc[prevtype].table, BTYPEVLCBITS, 1); avlog(s->avctx, AVLOGERROR, \"Dquant for B-frame\\n\"); } return 0; } ", "target": 0}
{"func": "static inline void RENAME(yvu9toyuy2)(const uint8t *src1, const uint8t *src2, const uint8t *src3, uint8t *dst, long width, long height, long srcStride1, long srcStride2, long srcStride3, long dstStride) { x86reg x; long y,w,h; w=width/2; h=height; for (y=0;y<h;y++) { const uint8t* yp=src1+srcStride1*y; const uint8t* up=src2+srcStride2*(y>>2); const uint8t* vp=src3+srcStride3*(y>>2); uint8t* d=dst+dstStride*y; x=0; #if COMPILETEMPLATEMMX for (;x<w-7;x+=8) { asm volatile( PREFETCH\" 32(%1, %0) \\n\\t\" PREFETCH\" 32(%2, %0) \\n\\t\" PREFETCH\" 32(%3, %0) \\n\\t\" \"movq (%1, %0, 4), %%mm0 \\n\\t\" /* Y0Y1Y2Y3Y4Y5Y6Y7 */ \"movq (%2, %0), %%mm1 \\n\\t\" /* U0U1U2U3U4U5U6U7 */ \"movq (%3, %0), %%mm2 \\n\\t\" /* V0V1V2V3V4V5V6V7 */ \"movq %%mm0, %%mm3 \\n\\t\" /* Y0Y1Y2Y3Y4Y5Y6Y7 */ \"movq %%mm1, %%mm4 \\n\\t\" /* U0U1U2U3U4U5U6U7 */ \"movq %%mm2, %%mm5 \\n\\t\" /* V0V1V2V3V4V5V6V7 */ \"punpcklbw %%mm1, %%mm1 \\n\\t\" /* U0U0 U1U1 U2U2 U3U3 */ \"punpcklbw %%mm2, %%mm2 \\n\\t\" /* V0V0 V1V1 V2V2 V3V3 */ \"punpckhbw %%mm4, %%mm4 \\n\\t\" /* U4U4 U5U5 U6U6 U7U7 */ \"punpckhbw %%mm5, %%mm5 \\n\\t\" /* V4V4 V5V5 V6V6 V7V7 */ \"movq %%mm1, %%mm6 \\n\\t\" \"punpcklbw %%mm2, %%mm1 \\n\\t\" /* U0V0 U0V0 U1V1 U1V1*/ \"punpcklbw %%mm1, %%mm0 \\n\\t\" /* Y0U0 Y1V0 Y2U0 Y3V0*/ \"punpckhbw %%mm1, %%mm3 \\n\\t\" /* Y4U1 Y5V1 Y6U1 Y7V1*/ MOVNTQ\" %%mm0, (%4, %0, 8) \\n\\t\" MOVNTQ\" %%mm3, 8(%4, %0, 8) \\n\\t\" \"punpckhbw %%mm2, %%mm6 \\n\\t\" /* U2V2 U2V2 U3V3 U3V3*/ \"movq 8(%1, %0, 4), %%mm0 \\n\\t\" \"movq %%mm0, %%mm3 \\n\\t\" \"punpcklbw %%mm6, %%mm0 \\n\\t\" /* Y U2 Y V2 Y U2 Y V2*/ \"punpckhbw %%mm6, %%mm3 \\n\\t\" /* Y U3 Y V3 Y U3 Y V3*/ MOVNTQ\" %%mm0, 16(%4, %0, 8) \\n\\t\" MOVNTQ\" %%mm3, 24(%4, %0, 8) \\n\\t\" \"movq %%mm4, %%mm6 \\n\\t\" \"movq 16(%1, %0, 4), %%mm0 \\n\\t\" \"movq %%mm0, %%mm3 \\n\\t\" \"punpcklbw %%mm5, %%mm4 \\n\\t\" \"punpcklbw %%mm4, %%mm0 \\n\\t\" /* Y U4 Y V4 Y U4 Y V4*/ \"punpckhbw %%mm4, %%mm3 \\n\\t\" /* Y U5 Y V5 Y U5 Y V5*/ MOVNTQ\" %%mm0, 32(%4, %0, 8) \\n\\t\" MOVNTQ\" %%mm3, 40(%4, %0, 8) \\n\\t\" \"punpckhbw %%mm5, %%mm6 \\n\\t\" \"movq 24(%1, %0, 4), %%mm0 \\n\\t\" \"movq %%mm0, %%mm3 \\n\\t\" \"punpcklbw %%mm6, %%mm0 \\n\\t\" /* Y U6 Y V6 Y U6 Y V6*/ \"punpckhbw %%mm6, %%mm3 \\n\\t\" /* Y U7 Y V7 Y U7 Y V7*/ MOVNTQ\" %%mm0, 48(%4, %0, 8) \\n\\t\" MOVNTQ\" %%mm3, 56(%4, %0, 8) \\n\\t\" : \"+r\" (x) : \"r\"(yp), \"r\" (up), \"r\"(vp), \"r\"(d) :\"memory\"); } #endif for (; x<w; x++) { const long x2 = x<<2; d[8*x+0] = yp[x2]; d[8*x+1] = up[x]; d[8*x+2] = yp[x2+1]; d[8*x+3] = vp[x]; d[8*x+4] = yp[x2+2]; d[8*x+5] = up[x]; d[8*x+6] = yp[x2+3]; d[8*x+7] = vp[x]; } } #if COMPILETEMPLATEMMX asm( EMMS\" \\n\\t\" SFENCE\" \\n\\t\" ::: \"memory\" ); #endif } ", "target": 0}
{"func": "static int pcmdecodeframe(AVCodecContext *avctx, void *data, int *datasize, AVPacket *avpkt) { const uint8t *buf = avpkt->data; int bufsize = avpkt->size; PCMDecode *s = avctx->privdata; int samplesize, c, n, i; uint8t *samples; const uint8t *src, *src8, *src2[MAXCHANNELS]; int32t *dstint32t; samples = data; src = buf; if (avctx->samplefmt!=avctx->codec->samplefmts[0]) { avlog(avctx, AVLOGERROR, \"invalid samplefmt\\n\"); return -1; } if(avctx->channels <= 0 || avctx->channels > MAXCHANNELS){ avlog(avctx, AVLOGERROR, \"PCM channels out of bounds\\n\"); return -1; } samplesize = avgetbitspersample(avctx->codecid)/8; /* avgetbitspersample returns 0 for CODECIDPCMDVD */ if (CODECIDPCMDVD == avctx->codecid) /* 2 samples are interleaved per block in PCMDVD */ samplesize = avctx->bitspercodedsample * 2 / 8; else if (avctx->codecid == CODECIDPCMLXF) /* we process 40-bit blocks per channel for LXF */ samplesize = 5; if (samplesize == 0) { avlog(avctx, AVLOGERROR, \"Invalid samplesize\\n\"); return AVERROR(EINVAL); } n = avctx->channels * samplesize; if(n && bufsize % n){ if (bufsize < n) { avlog(avctx, AVLOGERROR, \"invalid PCM packet\\n\"); return -1; }else bufsize -= bufsize % n; } bufsize= FFMIN(bufsize, *datasize/2); n = bufsize/samplesize; switch(avctx->codec->id) { case CODECIDPCMU32LE: DECODE(32, le32, src, samples, n, 0, 0x80000000) break; case CODECIDPCMU32BE: DECODE(32, be32, src, samples, n, 0, 0x80000000) break; case CODECIDPCMS24LE: DECODE(32, le24, src, samples, n, 8, 0) break; case CODECIDPCMS24BE: DECODE(32, be24, src, samples, n, 8, 0) break; case CODECIDPCMU24LE: DECODE(32, le24, src, samples, n, 8, 0x800000) break; case CODECIDPCMU24BE: DECODE(32, be24, src, samples, n, 8, 0x800000) break; case CODECIDPCMS24DAUD: for(;n>0;n--) { uint32t v = bytestreamgetbe24(&src); v >>= 4; // sync flags are here AVWN16A(samples, avreverse[(v >> 8) & 0xff] + (avreverse[v & 0xff] << 8)); samples += 2; } break; case CODECIDPCMS16LEPLANAR: n /= avctx->channels; for(c=0;c<avctx->channels;c++) src2[c] = &src[c*n*2]; for(;n>0;n--) for(c=0;c<avctx->channels;c++) { AVWN16A(samples, bytestreamgetle16(&src2[c])); samples += 2; } src = src2[avctx->channels-1]; break; case CODECIDPCMU16LE: DECODE(16, le16, src, samples, n, 0, 0x8000) break; case CODECIDPCMU16BE: DECODE(16, be16, src, samples, n, 0, 0x8000) break; case CODECIDPCMS8: for(;n>0;n--) { *samples++ = *src++ + 128; } break; #if HAVEBIGENDIAN case CODECIDPCMF64LE: DECODE(64, le64, src, samples, n, 0, 0) break; case CODECIDPCMS32LE: case CODECIDPCMF32LE: DECODE(32, le32, src, samples, n, 0, 0) break; case CODECIDPCMS16LE: DECODE(16, le16, src, samples, n, 0, 0) break; case CODECIDPCMF64BE: case CODECIDPCMF32BE: case CODECIDPCMS32BE: case CODECIDPCMS16BE: #else case CODECIDPCMF64BE: DECODE(64, be64, src, samples, n, 0, 0) break; case CODECIDPCMF32BE: case CODECIDPCMS32BE: DECODE(32, be32, src, samples, n, 0, 0) break; case CODECIDPCMS16BE: DECODE(16, be16, src, samples, n, 0, 0) break; case CODECIDPCMF64LE: case CODECIDPCMF32LE: case CODECIDPCMS32LE: case CODECIDPCMS16LE: #endif /* HAVEBIGENDIAN */ case CODECIDPCMU8: memcpy(samples, src, n*samplesize); src += n*samplesize; samples += n * samplesize; break; case CODECIDPCMZORK: for(;n>0;n--) { int x= *src++; if(x&128) x-= 128; else x = -x; AVWN16A(samples, x << 8); samples += 2; } break; case CODECIDPCMALAW: case CODECIDPCMMULAW: for(;n>0;n--) { AVWN16A(samples, s->table[*src++]); samples += 2; } break; case CODECIDPCMDVD: dstint32t = data; n /= avctx->channels; switch (avctx->bitspercodedsample) { case 20: while (n--) { c = avctx->channels; src8 = src + 4*c; while (c--) { *dstint32t++ = (bytestreamgetbe16(&src) << 16) + ((*src8 &0xf0) << 8); *dstint32t++ = (bytestreamgetbe16(&src) << 16) + ((*src8++ &0x0f) << 12); } src = src8; } break; case 24: while (n--) { c = avctx->channels; src8 = src + 4*c; while (c--) { *dstint32t++ = (bytestreamgetbe16(&src) << 16) + ((*src8++) << 8); *dstint32t++ = (bytestreamgetbe16(&src) << 16) + ((*src8++) << 8); } src = src8; } break; default: avlog(avctx, AVLOGERROR, \"PCM DVD unsupported sample depth\\n\"); return -1; } samples = (uint8t *) dstint32t; break; case CODECIDPCMLXF: dstint32t = data; n /= avctx->channels; //unpack and de-planerize for (i = 0; i < n; i++) { for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) { //extract low 20 bits and expand to 32 bits *dstint32t++ = (src8[2] << 28) | (src8[1] << 20) | (src8[0] << 12) | ((src8[2] & 0xF) << 8) | src8[1]; } for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) { //extract high 20 bits and expand to 32 bits *dstint32t++ = (src8[4] << 24) | (src8[3] << 16) | ((src8[2] & 0xF0) << 8) | (src8[4] << 4) | (src8[3] >> 4); } } src += n * avctx->channels * 5; samples = (uint8t *) dstint32t; break; default: return -1; } *datasize = samples - (uint8t *)data; return src - buf; } ", "target": 0}
{"func": "static int parsepresentationsegment(AVCodecContext *avctx, const uint8t *buf, int bufsize, int64t pts) { PGSSubContext *ctx = avctx->privdata; int x, y, ret; int w = bytestreamgetbe16(&buf); int h = bytestreamgetbe16(&buf); ctx->presentation.pts = pts; avdlog(avctx, \"Video Dimensions %dx%d\\n\", w, h); ret = ffsetdimensions(avctx, w, h); if (ret < 0) return ret; /* Skip 1 bytes of unknown, frame rate? */ buf++; ctx->presentation.idnumber = bytestreamgetbe16(&buf); /* * Skip 3 bytes of unknown: * state * paletteupdateflag (0x80), * paletteidtouse, */ buf += 3; ctx->presentation.objectnumber = bytestreamgetbyte(&buf); ctx->presentation.compositionflag = 0; if (!ctx->presentation.objectnumber) return 0; /* * Skip 3 bytes of unknown: * objectidref (2 bytes), * windowidref, */ buf += 3; ctx->presentation.compositionflag = bytestreamgetbyte(&buf); x = bytestreamgetbe16(&buf); y = bytestreamgetbe16(&buf); /* TODO If cropping, croppingx, croppingy, croppingwidth, croppingheight (all 2 bytes).*/ avdlog(avctx, \"Subtitle Placement x=%d, y=%d\\n\", x, y); if (x > avctx->width || y > avctx->height) { avlog(avctx, AVLOGERROR, \"Subtitle out of video bounds. x = %d, y = %d, video width = %d, video height = %d.\\n\", x, y, avctx->width, avctx->height); x = 0; y = 0; } /* Fill in dimensions */ ctx->presentation.x = x; ctx->presentation.y = y; return 0; } ", "target": 0}
{"func": "void qemucoroutinedelete(Coroutine *co) { CoroutineThreadState *s = coroutinegetthreadstate(); CoroutineUContext *co = DOUPCAST(CoroutineUContext, base, co); if (s->poolsize < POOLMAXSIZE) { QLISTINSERTHEAD(&s->pool, &co->base, poolnext); co->base.caller = NULL; s->poolsize++; return; } gfree(co->stack); gfree(co); } ", "target": 0}
{"func": "int float64eqsignaling( float64 a, float64 b STATUSPARAM ) { if ( ( ( extractFloat64Exp( a ) == 0x7FF ) && extractFloat64Frac( a ) ) || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) ) ) { floatraise( floatflaginvalid STATUSVAR); return 0; } return ( a == b ) || ( (bits64) ( ( a | b )<<1 ) == 0 ); } ", "target": 0}
{"func": "static int tpmpassthroughunixtxbufs(int tpmfd, const uint8t *in, uint32t inlen, uint8t *out, uint32t outlen) { int ret; ret = tpmpassthroughunixwrite(tpmfd, in, inlen); if (ret != inlen) { errorreport(\"tpmpassthrough: error while transmitting data \" \"to TPM: %s (%i)\\n\", strerror(errno), errno); goto errexit; } ret = tpmpassthroughunixread(tpmfd, out, outlen); if (ret < 0) { errorreport(\"tpmpassthrough: error while reading data from \" \"TPM: %s (%i)\\n\", strerror(errno), errno); } else if (ret < sizeof(struct tpmresphdr) || tpmpassthroughgetsizefrombuffer(out) != ret) { ret = -1; errorreport(\"tpmpassthrough: received invalid response \" \"packet from TPM\\n\"); } errexit: if (ret < 0) { tpmwritefatalerrorresponse(out, outlen); } return ret; } ", "target": 0}
{"func": "int cpumemoryrwdebug(CPUArchState *env, targetulong addr, uint8t *buf, int len, int iswrite) { int l; targetphysaddrt physaddr; targetulong page; while (len > 0) { page = addr & TARGETPAGEMASK; physaddr = cpugetphyspagedebug(env, page); /* if no physical page mapped, return an error */ if (physaddr == -1) return -1; l = (page + TARGETPAGESIZE) - addr; if (l > len) l = len; physaddr += (addr & ~TARGETPAGEMASK); if (iswrite) cpuphysicalmemorywriterom(physaddr, buf, l); else cpuphysicalmemoryrw(physaddr, buf, l, iswrite); len -= l; buf += l; addr += l; } return 0; } ", "target": 0}
{"func": "struct omapuwires *omapuwireinit(MemoryRegion *systemmemory, targetphysaddrt base, qemuirq *irq, qemuirq dma, omapclk clk) { struct omapuwires *s = (struct omapuwires *) gmalloc0(sizeof(struct omapuwires)); s->txirq = irq[0]; s->rxirq = irq[1]; s->txdrq = dma; omapuwirereset(s); memoryregioninitio(&s->iomem, &omapuwireops, s, \"omap-uwire\", 0x800); memoryregionaddsubregion(systemmemory, base, &s->iomem); return s; } ", "target": 0}
{"func": "static int sendsubrect(VncState *vs, int x, int y, int w, int h) { VncPalette *palette = &colorcountpalette; uint32t bg = 0, fg = 0; int colors; int ret = 0; #ifdef CONFIGVNCJPEG bool forcejpeg = false; bool allowjpeg = true; #endif vncframebufferupdate(vs, x, y, w, h, vs->tight.type); vnctightstart(vs); vncrawsendframebufferupdate(vs, x, y, w, h); vnctightstop(vs); #ifdef CONFIGVNCJPEG if (!vs->vd->nonadaptive && vs->tight.quality != (uint8t)-1) { double freq = vncupdatefreq(vs, x, y, w, h); if (freq < tightjpegconf[vs->tight.quality].jpegfreqmin) { allowjpeg = false; } if (freq >= tightjpegconf[vs->tight.quality].jpegfreqthreshold) { forcejpeg = true; vncsentlossyrect(vs, x, y, w, h); } } #endif colors = tightfillpalette(vs, x, y, w * h, &bg, &fg, palette); #ifdef CONFIGVNCJPEG if (allowjpeg && vs->tight.quality != (uint8t)-1) { ret = sendsubrectjpeg(vs, x, y, w, h, bg, fg, colors, palette, forcejpeg); } else { ret = sendsubrectnojpeg(vs, x, y, w, h, bg, fg, colors, palette); } #else ret = sendsubrectnojpeg(vs, x, y, w, h, bg, fg, colors, palette); #endif return ret; } ", "target": 0}
{"func": "static ExitStatus translateone(DisasContext *ctx, uint32t insn) { uint32t palcode; int32t disp21, disp16; #ifndef CONFIGUSERONLY int32t disp12; #endif uint16t fn11; uint8t opc, ra, rb, rc, fpfn, fn7, islit, realislit; uint8t lit; ExitStatus ret; /* Decode all instruction fields */ opc = insn >> 26; ra = (insn >> 21) & 0x1F; rb = (insn >> 16) & 0x1F; rc = insn & 0x1F; realislit = islit = (insn >> 12) & 1; if (rb == 31 && !islit) { islit = 1; lit = 0; } else lit = (insn >> 13) & 0xFF; palcode = insn & 0x03FFFFFF; disp21 = ((int32t)((insn & 0x001FFFFF) << 11)) >> 11; disp16 = (int16t)(insn & 0x0000FFFF); #ifndef CONFIGUSERONLY disp12 = (int32t)((insn & 0x00000FFF) << 20) >> 20; #endif fn11 = (insn >> 5) & 0x000007FF; fpfn = fn11 & 0x3F; fn7 = (insn >> 5) & 0x0000007F; LOGDISAS(\"opc %02x ra %2d rb %2d rc %2d disp16 %6d\\n\", opc, ra, rb, rc, disp16); ret = NOEXIT; switch (opc) { case 0x00: /* CALLPAL */ ret = gencallpal(ctx, palcode); break; case 0x01: /* OPC01 */ goto invalidopc; case 0x02: /* OPC02 */ goto invalidopc; case 0x03: /* OPC03 */ goto invalidopc; case 0x04: /* OPC04 */ goto invalidopc; case 0x05: /* OPC05 */ goto invalidopc; case 0x06: /* OPC06 */ goto invalidopc; case 0x07: /* OPC07 */ goto invalidopc; case 0x08: /* LDA */ if (likely(ra != 31)) { if (rb != 31) { tcggenaddii64(cpuir[ra], cpuir[rb], disp16); } else { tcggenmovii64(cpuir[ra], disp16); } } break; case 0x09: /* LDAH */ if (likely(ra != 31)) { if (rb != 31) { tcggenaddii64(cpuir[ra], cpuir[rb], disp16 << 16); } else { tcggenmovii64(cpuir[ra], disp16 << 16); } } break; case 0x0A: /* LDBU */ if (ctx->tb->flags & TBFLAGSAMASKBWX) { genloadmem(ctx, &tcggenqemuld8u, ra, rb, disp16, 0, 0); break; } goto invalidopc; case 0x0B: /* LDQU */ genloadmem(ctx, &tcggenqemuld64, ra, rb, disp16, 0, 1); break; case 0x0C: /* LDWU */ if (ctx->tb->flags & TBFLAGSAMASKBWX) { genloadmem(ctx, &tcggenqemuld16u, ra, rb, disp16, 0, 0); break; } goto invalidopc; case 0x0D: /* STW */ genstoremem(ctx, &tcggenqemust16, ra, rb, disp16, 0, 0); break; case 0x0E: /* STB */ genstoremem(ctx, &tcggenqemust8, ra, rb, disp16, 0, 0); break; case 0x0F: /* STQU */ genstoremem(ctx, &tcggenqemust64, ra, rb, disp16, 0, 1); break; case 0x10: switch (fn7) { case 0x00: /* ADDL */ if (likely(rc != 31)) { if (ra != 31) { if (islit) { tcggenaddii64(cpuir[rc], cpuir[ra], lit); tcggenext32si64(cpuir[rc], cpuir[rc]); } else { tcggenaddi64(cpuir[rc], cpuir[ra], cpuir[rb]); tcggenext32si64(cpuir[rc], cpuir[rc]); } } else { if (islit) { tcggenmovii64(cpuir[rc], lit); } else { tcggenext32si64(cpuir[rc], cpuir[rb]); } } } break; case 0x02: /* S4ADDL */ if (likely(rc != 31)) { if (ra != 31) { TCGv tmp = tcgtempnew(); tcggenshlii64(tmp, cpuir[ra], 2); if (islit) { tcggenaddii64(tmp, tmp, lit); } else { tcggenaddi64(tmp, tmp, cpuir[rb]); } tcggenext32si64(cpuir[rc], tmp); tcgtempfree(tmp); } else { if (islit) { tcggenmovii64(cpuir[rc], lit); } else { tcggenext32si64(cpuir[rc], cpuir[rb]); } } } break; case 0x09: /* SUBL */ if (likely(rc != 31)) { if (ra != 31) { if (islit) { tcggensubii64(cpuir[rc], cpuir[ra], lit); } else { tcggensubi64(cpuir[rc], cpuir[ra], cpuir[rb]); } tcggenext32si64(cpuir[rc], cpuir[rc]); } else { if (islit) { tcggenmovii64(cpuir[rc], -lit); } else { tcggennegi64(cpuir[rc], cpuir[rb]); tcggenext32si64(cpuir[rc], cpuir[rc]); } } } break; case 0x0B: /* S4SUBL */ if (likely(rc != 31)) { if (ra != 31) { TCGv tmp = tcgtempnew(); tcggenshlii64(tmp, cpuir[ra], 2); if (islit) { tcggensubii64(tmp, tmp, lit); } else { tcggensubi64(tmp, tmp, cpuir[rb]); } tcggenext32si64(cpuir[rc], tmp); tcgtempfree(tmp); } else { if (islit) { tcggenmovii64(cpuir[rc], -lit); } else { tcggennegi64(cpuir[rc], cpuir[rb]); tcggenext32si64(cpuir[rc], cpuir[rc]); } } } break; case 0x0F: /* CMPBGE */ gencmpbge(ra, rb, rc, islit, lit); break; case 0x12: /* S8ADDL */ if (likely(rc != 31)) { if (ra != 31) { TCGv tmp = tcgtempnew(); tcggenshlii64(tmp, cpuir[ra], 3); if (islit) { tcggenaddii64(tmp, tmp, lit); } else { tcggenaddi64(tmp, tmp, cpuir[rb]); } tcggenext32si64(cpuir[rc], tmp); tcgtempfree(tmp); } else { if (islit) { tcggenmovii64(cpuir[rc], lit); } else { tcggenext32si64(cpuir[rc], cpuir[rb]); } } } break; case 0x1B: /* S8SUBL */ if (likely(rc != 31)) { if (ra != 31) { TCGv tmp = tcgtempnew(); tcggenshlii64(tmp, cpuir[ra], 3); if (islit) { tcggensubii64(tmp, tmp, lit); } else { tcggensubi64(tmp, tmp, cpuir[rb]); } tcggenext32si64(cpuir[rc], tmp); tcgtempfree(tmp); } else { if (islit) { tcggenmovii64(cpuir[rc], -lit); } else { tcggennegi64(cpuir[rc], cpuir[rb]); tcggenext32si64(cpuir[rc], cpuir[rc]); } } } break; case 0x1D: /* CMPULT */ gencmp(TCGCONDLTU, ra, rb, rc, islit, lit); break; case 0x20: /* ADDQ */ if (likely(rc != 31)) { if (ra != 31) { if (islit) { tcggenaddii64(cpuir[rc], cpuir[ra], lit); } else { tcggenaddi64(cpuir[rc], cpuir[ra], cpuir[rb]); } } else { if (islit) { tcggenmovii64(cpuir[rc], lit); } else { tcggenmovi64(cpuir[rc], cpuir[rb]); } } } break; case 0x22: /* S4ADDQ */ if (likely(rc != 31)) { if (ra != 31) { TCGv tmp = tcgtempnew(); tcggenshlii64(tmp, cpuir[ra], 2); if (islit) { tcggenaddii64(cpuir[rc], tmp, lit); } else { tcggenaddi64(cpuir[rc], tmp, cpuir[rb]); } tcgtempfree(tmp); } else { if (islit) { tcggenmovii64(cpuir[rc], lit); } else { tcggenmovi64(cpuir[rc], cpuir[rb]); } } } break; case 0x29: /* SUBQ */ if (likely(rc != 31)) { if (ra != 31) { if (islit) { tcggensubii64(cpuir[rc], cpuir[ra], lit); } else { tcggensubi64(cpuir[rc], cpuir[ra], cpuir[rb]); } } else { if (islit) { tcggenmovii64(cpuir[rc], -lit); } else { tcggennegi64(cpuir[rc], cpuir[rb]); } } } break; case 0x2B: /* S4SUBQ */ if (likely(rc != 31)) { if (ra != 31) { TCGv tmp = tcgtempnew(); tcggenshlii64(tmp, cpuir[ra], 2); if (islit) { tcggensubii64(cpuir[rc], tmp, lit); } else { tcggensubi64(cpuir[rc], tmp, cpuir[rb]); } tcgtempfree(tmp); } else { if (islit) { tcggenmovii64(cpuir[rc], -lit); } else { tcggennegi64(cpuir[rc], cpuir[rb]); } } } break; case 0x2D: /* CMPEQ */ gencmp(TCGCONDEQ, ra, rb, rc, islit, lit); break; case 0x32: /* S8ADDQ */ if (likely(rc != 31)) { if (ra != 31) { TCGv tmp = tcgtempnew(); tcggenshlii64(tmp, cpuir[ra], 3); if (islit) { tcggenaddii64(cpuir[rc], tmp, lit); } else { tcggenaddi64(cpuir[rc], tmp, cpuir[rb]); } tcgtempfree(tmp); } else { if (islit) { tcggenmovii64(cpuir[rc], lit); } else { tcggenmovi64(cpuir[rc], cpuir[rb]); } } } break; case 0x3B: /* S8SUBQ */ if (likely(rc != 31)) { if (ra != 31) { TCGv tmp = tcgtempnew(); tcggenshlii64(tmp, cpuir[ra], 3); if (islit) { tcggensubii64(cpuir[rc], tmp, lit); } else { tcggensubi64(cpuir[rc], tmp, cpuir[rb]); } tcgtempfree(tmp); } else { if (islit) { tcggenmovii64(cpuir[rc], -lit); } else { tcggennegi64(cpuir[rc], cpuir[rb]); } } } break; case 0x3D: /* CMPULE */ gencmp(TCGCONDLEU, ra, rb, rc, islit, lit); break; case 0x40: /* ADDL/V */ genaddlv(ra, rb, rc, islit, lit); break; case 0x49: /* SUBL/V */ gensublv(ra, rb, rc, islit, lit); break; case 0x4D: /* CMPLT */ gencmp(TCGCONDLT, ra, rb, rc, islit, lit); break; case 0x60: /* ADDQ/V */ genaddqv(ra, rb, rc, islit, lit); break; case 0x69: /* SUBQ/V */ gensubqv(ra, rb, rc, islit, lit); break; case 0x6D: /* CMPLE */ gencmp(TCGCONDLE, ra, rb, rc, islit, lit); break; default: goto invalidopc; } break; case 0x11: switch (fn7) { case 0x00: /* AND */ if (likely(rc != 31)) { if (ra == 31) { tcggenmovii64(cpuir[rc], 0); } else if (islit) { tcggenandii64(cpuir[rc], cpuir[ra], lit); } else { tcggenandi64(cpuir[rc], cpuir[ra], cpuir[rb]); } } break; case 0x08: /* BIC */ if (likely(rc != 31)) { if (ra != 31) { if (islit) { tcggenandii64(cpuir[rc], cpuir[ra], ~lit); } else { tcggenandci64(cpuir[rc], cpuir[ra], cpuir[rb]); } } else tcggenmovii64(cpuir[rc], 0); } break; case 0x14: /* CMOVLBS */ gencmov(TCGCONDNE, ra, rb, rc, islit, lit, 1); break; case 0x16: /* CMOVLBC */ gencmov(TCGCONDEQ, ra, rb, rc, islit, lit, 1); break; case 0x20: /* BIS */ if (likely(rc != 31)) { if (ra != 31) { if (islit) { tcggenorii64(cpuir[rc], cpuir[ra], lit); } else { tcggenori64(cpuir[rc], cpuir[ra], cpuir[rb]); } } else { if (islit) { tcggenmovii64(cpuir[rc], lit); } else { tcggenmovi64(cpuir[rc], cpuir[rb]); } } } break; case 0x24: /* CMOVEQ */ gencmov(TCGCONDEQ, ra, rb, rc, islit, lit, 0); break; case 0x26: /* CMOVNE */ gencmov(TCGCONDNE, ra, rb, rc, islit, lit, 0); break; case 0x28: /* ORNOT */ if (likely(rc != 31)) { if (ra != 31) { if (islit) { tcggenorii64(cpuir[rc], cpuir[ra], ~lit); } else { tcggenorci64(cpuir[rc], cpuir[ra], cpuir[rb]); } } else { if (islit) { tcggenmovii64(cpuir[rc], ~lit); } else { tcggennoti64(cpuir[rc], cpuir[rb]); } } } break; case 0x40: /* XOR */ if (likely(rc != 31)) { if (ra != 31) { if (islit) { tcggenxorii64(cpuir[rc], cpuir[ra], lit); } else { tcggenxori64(cpuir[rc], cpuir[ra], cpuir[rb]); } } else { if (islit) { tcggenmovii64(cpuir[rc], lit); } else { tcggenmovi64(cpuir[rc], cpuir[rb]); } } } break; case 0x44: /* CMOVLT */ gencmov(TCGCONDLT, ra, rb, rc, islit, lit, 0); break; case 0x46: /* CMOVGE */ gencmov(TCGCONDGE, ra, rb, rc, islit, lit, 0); break; case 0x48: /* EQV */ if (likely(rc != 31)) { if (ra != 31) { if (islit) { tcggenxorii64(cpuir[rc], cpuir[ra], ~lit); } else { tcggeneqvi64(cpuir[rc], cpuir[ra], cpuir[rb]); } } else { if (islit) { tcggenmovii64(cpuir[rc], ~lit); } else { tcggennoti64(cpuir[rc], cpuir[rb]); } } } break; case 0x61: /* AMASK */ if (likely(rc != 31)) { uint64t amask = ctx->tb->flags >> TBFLAGSAMASKSHIFT; if (islit) { tcggenmovii64(cpuir[rc], lit & ~amask); } else { tcggenandii64(cpuir[rc], cpuir[rb], ~amask); } } break; case 0x64: /* CMOVLE */ gencmov(TCGCONDLE, ra, rb, rc, islit, lit, 0); break; case 0x66: /* CMOVGT */ gencmov(TCGCONDGT, ra, rb, rc, islit, lit, 0); break; case 0x6C: /* IMPLVER */ if (rc != 31) { tcggenmovii64(cpuir[rc], ctx->implver); } break; default: goto invalidopc; } break; case 0x12: switch (fn7) { case 0x02: /* MSKBL */ genmskl(ra, rb, rc, islit, lit, 0x01); break; case 0x06: /* EXTBL */ genextl(ra, rb, rc, islit, lit, 0x01); break; case 0x0B: /* INSBL */ geninsl(ra, rb, rc, islit, lit, 0x01); break; case 0x12: /* MSKWL */ genmskl(ra, rb, rc, islit, lit, 0x03); break; case 0x16: /* EXTWL */ genextl(ra, rb, rc, islit, lit, 0x03); break; case 0x1B: /* INSWL */ geninsl(ra, rb, rc, islit, lit, 0x03); break; case 0x22: /* MSKLL */ genmskl(ra, rb, rc, islit, lit, 0x0f); break; case 0x26: /* EXTLL */ genextl(ra, rb, rc, islit, lit, 0x0f); break; case 0x2B: /* INSLL */ geninsl(ra, rb, rc, islit, lit, 0x0f); break; case 0x30: /* ZAP */ genzap(ra, rb, rc, islit, lit); break; case 0x31: /* ZAPNOT */ genzapnot(ra, rb, rc, islit, lit); break; case 0x32: /* MSKQL */ genmskl(ra, rb, rc, islit, lit, 0xff); break; case 0x34: /* SRL */ if (likely(rc != 31)) { if (ra != 31) { if (islit) { tcggenshrii64(cpuir[rc], cpuir[ra], lit & 0x3f); } else { TCGv shift = tcgtempnew(); tcggenandii64(shift, cpuir[rb], 0x3f); tcggenshri64(cpuir[rc], cpuir[ra], shift); tcgtempfree(shift); } } else tcggenmovii64(cpuir[rc], 0); } break; case 0x36: /* EXTQL */ genextl(ra, rb, rc, islit, lit, 0xff); break; case 0x39: /* SLL */ if (likely(rc != 31)) { if (ra != 31) { if (islit) { tcggenshlii64(cpuir[rc], cpuir[ra], lit & 0x3f); } else { TCGv shift = tcgtempnew(); tcggenandii64(shift, cpuir[rb], 0x3f); tcggenshli64(cpuir[rc], cpuir[ra], shift); tcgtempfree(shift); } } else tcggenmovii64(cpuir[rc], 0); } break; case 0x3B: /* INSQL */ geninsl(ra, rb, rc, islit, lit, 0xff); break; case 0x3C: /* SRA */ if (likely(rc != 31)) { if (ra != 31) { if (islit) { tcggensarii64(cpuir[rc], cpuir[ra], lit & 0x3f); } else { TCGv shift = tcgtempnew(); tcggenandii64(shift, cpuir[rb], 0x3f); tcggensari64(cpuir[rc], cpuir[ra], shift); tcgtempfree(shift); } } else tcggenmovii64(cpuir[rc], 0); } break; case 0x52: /* MSKWH */ genmskh(ra, rb, rc, islit, lit, 0x03); break; case 0x57: /* INSWH */ geninsh(ra, rb, rc, islit, lit, 0x03); break; case 0x5A: /* EXTWH */ genexth(ra, rb, rc, islit, lit, 0x03); break; case 0x62: /* MSKLH */ genmskh(ra, rb, rc, islit, lit, 0x0f); break; case 0x67: /* INSLH */ geninsh(ra, rb, rc, islit, lit, 0x0f); break; case 0x6A: /* EXTLH */ genexth(ra, rb, rc, islit, lit, 0x0f); break; case 0x72: /* MSKQH */ genmskh(ra, rb, rc, islit, lit, 0xff); break; case 0x77: /* INSQH */ geninsh(ra, rb, rc, islit, lit, 0xff); break; case 0x7A: /* EXTQH */ genexth(ra, rb, rc, islit, lit, 0xff); break; default: goto invalidopc; } break; case 0x13: switch (fn7) { case 0x00: /* MULL */ if (likely(rc != 31)) { if (ra == 31) { tcggenmovii64(cpuir[rc], 0); } else { if (islit) { tcggenmulii64(cpuir[rc], cpuir[ra], lit); } else { tcggenmuli64(cpuir[rc], cpuir[ra], cpuir[rb]); } tcggenext32si64(cpuir[rc], cpuir[rc]); } } break; case 0x20: /* MULQ */ if (likely(rc != 31)) { if (ra == 31) { tcggenmovii64(cpuir[rc], 0); } else if (islit) { tcggenmulii64(cpuir[rc], cpuir[ra], lit); } else { tcggenmuli64(cpuir[rc], cpuir[ra], cpuir[rb]); } } break; case 0x30: /* UMULH */ { TCGv low; if (unlikely(rc == 31)){ break; } if (ra == 31) { tcggenmovii64(cpuir[rc], 0); break; } low = tcgtempnew(); if (islit) { tcggenmovitl(low, lit); tcggenmulu2i64(low, cpuir[rc], cpuir[ra], low); } else { tcggenmulu2i64(low, cpuir[rc], cpuir[ra], cpuir[rb]); } tcgtempfree(low); } break; case 0x40: /* MULL/V */ genmullv(ra, rb, rc, islit, lit); break; case 0x60: /* MULQ/V */ genmulqv(ra, rb, rc, islit, lit); break; default: goto invalidopc; } break; case 0x14: switch (fpfn) { /* fn11 & 0x3F */ case 0x04: /* ITOFS */ if ((ctx->tb->flags & TBFLAGSAMASKFIX) == 0) { goto invalidopc; } if (likely(rc != 31)) { if (ra != 31) { TCGvi32 tmp = tcgtempnewi32(); tcggentrunci64i32(tmp, cpuir[ra]); genhelpermemorytos(cpufir[rc], tmp); tcgtempfreei32(tmp); } else tcggenmovii64(cpufir[rc], 0); } break; case 0x0A: /* SQRTF */ if (ctx->tb->flags & TBFLAGSAMASKFIX) { genfsqrtf(rb, rc); break; } goto invalidopc; case 0x0B: /* SQRTS */ if (ctx->tb->flags & TBFLAGSAMASKFIX) { genfsqrts(ctx, rb, rc, fn11); break; } goto invalidopc; case 0x14: /* ITOFF */ if ((ctx->tb->flags & TBFLAGSAMASKFIX) == 0) { goto invalidopc; } if (likely(rc != 31)) { if (ra != 31) { TCGvi32 tmp = tcgtempnewi32(); tcggentrunci64i32(tmp, cpuir[ra]); genhelpermemorytof(cpufir[rc], tmp); tcgtempfreei32(tmp); } else tcggenmovii64(cpufir[rc], 0); } break; case 0x24: /* ITOFT */ if ((ctx->tb->flags & TBFLAGSAMASKFIX) == 0) { goto invalidopc; } if (likely(rc != 31)) { if (ra != 31) { tcggenmovi64(cpufir[rc], cpuir[ra]); } else { tcggenmovii64(cpufir[rc], 0); } } break; case 0x2A: /* SQRTG */ if (ctx->tb->flags & TBFLAGSAMASKFIX) { genfsqrtg(rb, rc); break; } goto invalidopc; case 0x02B: /* SQRTT */ if (ctx->tb->flags & TBFLAGSAMASKFIX) { genfsqrtt(ctx, rb, rc, fn11); break; } goto invalidopc; default: goto invalidopc; } break; case 0x15: /* VAX floating point */ /* XXX: rounding mode and trap are ignored (!) */ switch (fpfn) { /* fn11 & 0x3F */ case 0x00: /* ADDF */ genfaddf(ra, rb, rc); break; case 0x01: /* SUBF */ genfsubf(ra, rb, rc); break; case 0x02: /* MULF */ genfmulf(ra, rb, rc); break; case 0x03: /* DIVF */ genfdivf(ra, rb, rc); break; case 0x1E: /* CVTDG */ #if 0 // TODO genfcvtdg(rb, rc); #else goto invalidopc; #endif break; case 0x20: /* ADDG */ genfaddg(ra, rb, rc); break; case 0x21: /* SUBG */ genfsubg(ra, rb, rc); break; case 0x22: /* MULG */ genfmulg(ra, rb, rc); break; case 0x23: /* DIVG */ genfdivg(ra, rb, rc); break; case 0x25: /* CMPGEQ */ genfcmpgeq(ra, rb, rc); break; case 0x26: /* CMPGLT */ genfcmpglt(ra, rb, rc); break; case 0x27: /* CMPGLE */ genfcmpgle(ra, rb, rc); break; case 0x2C: /* CVTGF */ genfcvtgf(rb, rc); break; case 0x2D: /* CVTGD */ #if 0 // TODO genfcvtgd(rb, rc); #else goto invalidopc; #endif break; case 0x2F: /* CVTGQ */ genfcvtgq(rb, rc); break; case 0x3C: /* CVTQF */ genfcvtqf(rb, rc); break; case 0x3E: /* CVTQG */ genfcvtqg(rb, rc); break; default: goto invalidopc; } break; case 0x16: /* IEEE floating-point */ switch (fpfn) { /* fn11 & 0x3F */ case 0x00: /* ADDS */ genfadds(ctx, ra, rb, rc, fn11); break; case 0x01: /* SUBS */ genfsubs(ctx, ra, rb, rc, fn11); break; case 0x02: /* MULS */ genfmuls(ctx, ra, rb, rc, fn11); break; case 0x03: /* DIVS */ genfdivs(ctx, ra, rb, rc, fn11); break; case 0x20: /* ADDT */ genfaddt(ctx, ra, rb, rc, fn11); break; case 0x21: /* SUBT */ genfsubt(ctx, ra, rb, rc, fn11); break; case 0x22: /* MULT */ genfmult(ctx, ra, rb, rc, fn11); break; case 0x23: /* DIVT */ genfdivt(ctx, ra, rb, rc, fn11); break; case 0x24: /* CMPTUN */ genfcmptun(ctx, ra, rb, rc, fn11); break; case 0x25: /* CMPTEQ */ genfcmpteq(ctx, ra, rb, rc, fn11); break; case 0x26: /* CMPTLT */ genfcmptlt(ctx, ra, rb, rc, fn11); break; case 0x27: /* CMPTLE */ genfcmptle(ctx, ra, rb, rc, fn11); break; case 0x2C: if (fn11 == 0x2AC || fn11 == 0x6AC) { /* CVTST */ genfcvtst(ctx, rb, rc, fn11); } else { /* CVTTS */ genfcvtts(ctx, rb, rc, fn11); } break; case 0x2F: /* CVTTQ */ genfcvttq(ctx, rb, rc, fn11); break; case 0x3C: /* CVTQS */ genfcvtqs(ctx, rb, rc, fn11); break; case 0x3E: /* CVTQT */ genfcvtqt(ctx, rb, rc, fn11); break; default: goto invalidopc; } break; case 0x17: switch (fn11) { case 0x010: /* CVTLQ */ genfcvtlq(rb, rc); break; case 0x020: if (likely(rc != 31)) { if (ra == rb) { /* FMOV */ if (ra == 31) { tcggenmovii64(cpufir[rc], 0); } else { tcggenmovi64(cpufir[rc], cpufir[ra]); } } else { /* CPYS */ genfcpys(ra, rb, rc); } } break; case 0x021: /* CPYSN */ genfcpysn(ra, rb, rc); break; case 0x022: /* CPYSE */ genfcpyse(ra, rb, rc); break; case 0x024: /* MTFPCR */ if (likely(ra != 31)) { genhelperstorefpcr(cpuenv, cpufir[ra]); } else { TCGv tmp = tcgconsti64(0); genhelperstorefpcr(cpuenv, tmp); tcgtempfree(tmp); } break; case 0x025: /* MFFPCR */ if (likely(ra != 31)) { genhelperloadfpcr(cpufir[ra], cpuenv); } break; case 0x02A: /* FCMOVEQ */ genfcmov(TCGCONDEQ, ra, rb, rc); break; case 0x02B: /* FCMOVNE */ genfcmov(TCGCONDNE, ra, rb, rc); break; case 0x02C: /* FCMOVLT */ genfcmov(TCGCONDLT, ra, rb, rc); break; case 0x02D: /* FCMOVGE */ genfcmov(TCGCONDGE, ra, rb, rc); break; case 0x02E: /* FCMOVLE */ genfcmov(TCGCONDLE, ra, rb, rc); break; case 0x02F: /* FCMOVGT */ genfcmov(TCGCONDGT, ra, rb, rc); break; case 0x030: /* CVTQL */ genfcvtql(rb, rc); break; case 0x130: /* CVTQL/V */ case 0x530: /* CVTQL/SV */ /* ??? I'm pretty sure there's nothing that /sv needs to do that /v doesn't do. The only thing I can think is that /sv is a valid instruction merely for completeness in the ISA. */ genfcvtqlv(ctx, rb, rc); break; default: goto invalidopc; } break; case 0x18: switch ((uint16t)disp16) { case 0x0000: /* TRAPB */ /* No-op. */ break; case 0x0400: /* EXCB */ /* No-op. */ break; case 0x4000: /* MB */ /* No-op */ break; case 0x4400: /* WMB */ /* No-op */ break; case 0x8000: /* FETCH */ /* No-op */ break; case 0xA000: /* FETCHM */ /* No-op */ break; case 0xC000: /* RPCC */ if (ra != 31) { if (useicount) { geniostart(); genhelperloadpcc(cpuir[ra], cpuenv); genioend(); ret = EXITPCSTALE; } else { genhelperloadpcc(cpuir[ra], cpuenv); } } break; case 0xE000: /* RC */ genrx(ra, 0); break; case 0xE800: /* ECB */ break; case 0xF000: /* RS */ genrx(ra, 1); break; case 0xF800: /* WH64 */ /* No-op */ break; default: goto invalidopc; } break; case 0x19: /* HWMFPR (PALcode) */ #ifndef CONFIGUSERONLY if (ctx->tb->flags & TBFLAGSPALMODE) { return genmfpr(ra, insn & 0xffff); } #endif goto invalidopc; case 0x1A: /* JMP, JSR, RET, JSRCOROUTINE. These only differ by the branch prediction stack action, which of course we don't implement. */ if (rb != 31) { tcggenandii64(cpupc, cpuir[rb], ~3); } else { tcggenmovii64(cpupc, 0); } if (ra != 31) { tcggenmovii64(cpuir[ra], ctx->pc); } ret = EXITPCUPDATED; break; case 0x1B: /* HWLD (PALcode) */ #ifndef CONFIGUSERONLY if (ctx->tb->flags & TBFLAGSPALMODE) { TCGv addr; if (ra == 31) { break; } addr = tcgtempnew(); if (rb != 31) { tcggenaddii64(addr, cpuir[rb], disp12); } else { tcggenmovii64(addr, disp12); } switch ((insn >> 12) & 0xF) { case 0x0: /* Longword physical access (hwldl/p) */ genhelperldlphys(cpuir[ra], cpuenv, addr); break; case 0x1: /* Quadword physical access (hwldq/p) */ genhelperldqphys(cpuir[ra], cpuenv, addr); break; case 0x2: /* Longword physical access with lock (hwldll/p) */ genhelperldllphys(cpuir[ra], cpuenv, addr); break; case 0x3: /* Quadword physical access with lock (hwldql/p) */ genhelperldqlphys(cpuir[ra], cpuenv, addr); break; case 0x4: /* Longword virtual PTE fetch (hwldl/v) */ goto invalidopc; case 0x5: /* Quadword virtual PTE fetch (hwldq/v) */ goto invalidopc; break; case 0x6: /* Incpuir[ra]id */ goto invalidopc; case 0x7: /* Incpuir[ra]id */ goto invalidopc; case 0x8: /* Longword virtual access (hwldl) */ goto invalidopc; case 0x9: /* Quadword virtual access (hwldq) */ goto invalidopc; case 0xA: /* Longword virtual access with protection check (hwldl/w) */ tcggenqemuldi64(cpuir[ra], addr, MMUKERNELIDX, MOLESL); break; case 0xB: /* Quadword virtual access with protection check (hwldq/w) */ tcggenqemuldi64(cpuir[ra], addr, MMUKERNELIDX, MOLEQ); break; case 0xC: /* Longword virtual access with alt access mode (hwldl/a)*/ goto invalidopc; case 0xD: /* Quadword virtual access with alt access mode (hwldq/a) */ goto invalidopc; case 0xE: /* Longword virtual access with alternate access mode and protection checks (hwldl/wa) */ tcggenqemuldi64(cpuir[ra], addr, MMUUSERIDX, MOLESL); break; case 0xF: /* Quadword virtual access with alternate access mode and protection checks (hwldq/wa) */ tcggenqemuldi64(cpuir[ra], addr, MMUUSERIDX, MOLEQ); break; } tcgtempfree(addr); break; } #endif goto invalidopc; case 0x1C: switch (fn7) { case 0x00: /* SEXTB */ if ((ctx->tb->flags & TBFLAGSAMASKBWX) == 0) { goto invalidopc; } if (likely(rc != 31)) { if (islit) { tcggenmovii64(cpuir[rc], (int64t)((int8t)lit)); } else { tcggenext8si64(cpuir[rc], cpuir[rb]); } } break; case 0x01: /* SEXTW */ if (ctx->tb->flags & TBFLAGSAMASKBWX) { if (likely(rc != 31)) { if (islit) { tcggenmovii64(cpuir[rc], (int64t)((int16t)lit)); } else { tcggenext16si64(cpuir[rc], cpuir[rb]); } } break; } goto invalidopc; case 0x30: /* CTPOP */ if (ctx->tb->flags & TBFLAGSAMASKCIX) { if (likely(rc != 31)) { if (islit) { tcggenmovii64(cpuir[rc], ctpop64(lit)); } else { genhelperctpop(cpuir[rc], cpuir[rb]); } } break; } goto invalidopc; case 0x31: /* PERR */ if (ctx->tb->flags & TBFLAGSAMASKMVI) { genperr(ra, rb, rc, islit, lit); break; } goto invalidopc; case 0x32: /* CTLZ */ if (ctx->tb->flags & TBFLAGSAMASKCIX) { if (likely(rc != 31)) { if (islit) { tcggenmovii64(cpuir[rc], clz64(lit)); } else { genhelperctlz(cpuir[rc], cpuir[rb]); } } break; } goto invalidopc; case 0x33: /* CTTZ */ if (ctx->tb->flags & TBFLAGSAMASKCIX) { if (likely(rc != 31)) { if (islit) { tcggenmovii64(cpuir[rc], ctz64(lit)); } else { genhelpercttz(cpuir[rc], cpuir[rb]); } } break; } goto invalidopc; case 0x34: /* UNPKBW */ if (ctx->tb->flags & TBFLAGSAMASKMVI) { if (realislit || ra != 31) { goto invalidopc; } genunpkbw(rb, rc); break; } goto invalidopc; case 0x35: /* UNPKBL */ if (ctx->tb->flags & TBFLAGSAMASKMVI) { if (realislit || ra != 31) { goto invalidopc; } genunpkbl(rb, rc); break; } goto invalidopc; case 0x36: /* PKWB */ if (ctx->tb->flags & TBFLAGSAMASKMVI) { if (realislit || ra != 31) { goto invalidopc; } genpkwb(rb, rc); break; } goto invalidopc; case 0x37: /* PKLB */ if (ctx->tb->flags & TBFLAGSAMASKMVI) { if (realislit || ra != 31) { goto invalidopc; } genpklb(rb, rc); break; } goto invalidopc; case 0x38: /* MINSB8 */ if (ctx->tb->flags & TBFLAGSAMASKMVI) { genminsb8(ra, rb, rc, islit, lit); break; } goto invalidopc; case 0x39: /* MINSW4 */ if (ctx->tb->flags & TBFLAGSAMASKMVI) { genminsw4(ra, rb, rc, islit, lit); break; } goto invalidopc; case 0x3A: /* MINUB8 */ if (ctx->tb->flags & TBFLAGSAMASKMVI) { genminub8(ra, rb, rc, islit, lit); break; } goto invalidopc; case 0x3B: /* MINUW4 */ if (ctx->tb->flags & TBFLAGSAMASKMVI) { genminuw4(ra, rb, rc, islit, lit); break; } goto invalidopc; case 0x3C: /* MAXUB8 */ if (ctx->tb->flags & TBFLAGSAMASKMVI) { genmaxub8(ra, rb, rc, islit, lit); break; } goto invalidopc; case 0x3D: /* MAXUW4 */ if (ctx->tb->flags & TBFLAGSAMASKMVI) { genmaxuw4(ra, rb, rc, islit, lit); break; } goto invalidopc; case 0x3E: /* MAXSB8 */ if (ctx->tb->flags & TBFLAGSAMASKMVI) { genmaxsb8(ra, rb, rc, islit, lit); break; } goto invalidopc; case 0x3F: /* MAXSW4 */ if (ctx->tb->flags & TBFLAGSAMASKMVI) { genmaxsw4(ra, rb, rc, islit, lit); break; } goto invalidopc; case 0x70: /* FTOIT */ if ((ctx->tb->flags & TBFLAGSAMASKFIX) == 0) { goto invalidopc; } if (likely(rc != 31)) { if (ra != 31) { tcggenmovi64(cpuir[rc], cpufir[ra]); } else { tcggenmovii64(cpuir[rc], 0); } } break; case 0x78: /* FTOIS */ if ((ctx->tb->flags & TBFLAGSAMASKFIX) == 0) { goto invalidopc; } if (rc != 31) { TCGvi32 tmp1 = tcgtempnewi32(); if (ra != 31) { genhelperstomemory(tmp1, cpufir[ra]); } else { TCGv tmp2 = tcgconsti64(0); genhelperstomemory(tmp1, tmp2); tcgtempfree(tmp2); } tcggenexti32i64(cpuir[rc], tmp1); tcgtempfreei32(tmp1); } break; default: goto invalidopc; } break; case 0x1D: /* HWMTPR (PALcode) */ #ifndef CONFIGUSERONLY if (ctx->tb->flags & TBFLAGSPALMODE) { return genmtpr(ctx, rb, insn & 0xffff); } #endif goto invalidopc; case 0x1E: /* HWRET (PALcode) */ #ifndef CONFIGUSERONLY if (ctx->tb->flags & TBFLAGSPALMODE) { if (rb == 31) { /* Pre-EV6 CPUs interpreted this as HWREI, loading the return address from EXCADDR. This turns out to be useful for our emulation PALcode, so continue to accept it. */ TCGv tmp = tcgtempnew(); tcggenldi64(tmp, cpuenv, offsetof(CPUAlphaState, excaddr)); genhelperhwret(cpuenv, tmp); tcgtempfree(tmp); } else { genhelperhwret(cpuenv, cpuir[rb]); } ret = EXITPCUPDATED; break; } #endif goto invalidopc; case 0x1F: /* HWST (PALcode) */ #ifndef CONFIGUSERONLY if (ctx->tb->flags & TBFLAGSPALMODE) { TCGv addr, val; addr = tcgtempnew(); if (rb != 31) { tcggenaddii64(addr, cpuir[rb], disp12); } else { tcggenmovii64(addr, disp12); } if (ra != 31) { val = cpuir[ra]; } else { val = tcgtempnew(); tcggenmovii64(val, 0); } switch ((insn >> 12) & 0xF) { case 0x0: /* Longword physical access */ genhelperstlphys(cpuenv, addr, val); break; case 0x1: /* Quadword physical access */ genhelperstqphys(cpuenv, addr, val); break; case 0x2: /* Longword physical access with lock */ genhelperstlcphys(val, cpuenv, addr, val); break; case 0x3: /* Quadword physical access with lock */ genhelperstqcphys(val, cpuenv, addr, val); break; case 0x4: /* Longword virtual access */ goto invalidopc; case 0x5: /* Quadword virtual access */ goto invalidopc; case 0x6: /* Invalid */ goto invalidopc; case 0x7: /* Invalid */ goto invalidopc; case 0x8: /* Invalid */ goto invalidopc; case 0x9: /* Invalid */ goto invalidopc; case 0xA: /* Invalid */ goto invalidopc; case 0xB: /* Invalid */ goto invalidopc; case 0xC: /* Longword virtual access with alternate access mode */ goto invalidopc; case 0xD: /* Quadword virtual access with alternate access mode */ goto invalidopc; case 0xE: /* Invalid */ goto invalidopc; case 0xF: /* Invalid */ goto invalidopc; } if (ra == 31) { tcgtempfree(val); } tcgtempfree(addr); break; } #endif goto invalidopc; case 0x20: /* LDF */ genloadmem(ctx, &genqemuldf, ra, rb, disp16, 1, 0); break; case 0x21: /* LDG */ genloadmem(ctx, &genqemuldg, ra, rb, disp16, 1, 0); break; case 0x22: /* LDS */ genloadmem(ctx, &genqemulds, ra, rb, disp16, 1, 0); break; case 0x23: /* LDT */ genloadmem(ctx, &tcggenqemuld64, ra, rb, disp16, 1, 0); break; case 0x24: /* STF */ genstoremem(ctx, &genqemustf, ra, rb, disp16, 1, 0); break; case 0x25: /* STG */ genstoremem(ctx, &genqemustg, ra, rb, disp16, 1, 0); break; case 0x26: /* STS */ genstoremem(ctx, &genqemusts, ra, rb, disp16, 1, 0); break; case 0x27: /* STT */ genstoremem(ctx, &tcggenqemust64, ra, rb, disp16, 1, 0); break; case 0x28: /* LDL */ genloadmem(ctx, &tcggenqemuld32s, ra, rb, disp16, 0, 0); break; case 0x29: /* LDQ */ genloadmem(ctx, &tcggenqemuld64, ra, rb, disp16, 0, 0); break; case 0x2A: /* LDLL */ genloadmem(ctx, &genqemuldll, ra, rb, disp16, 0, 0); break; case 0x2B: /* LDQL */ genloadmem(ctx, &genqemuldql, ra, rb, disp16, 0, 0); break; case 0x2C: /* STL */ genstoremem(ctx, &tcggenqemust32, ra, rb, disp16, 0, 0); break; case 0x2D: /* STQ */ genstoremem(ctx, &tcggenqemust64, ra, rb, disp16, 0, 0); break; case 0x2E: /* STLC */ ret = genstoreconditional(ctx, ra, rb, disp16, 0); break; case 0x2F: /* STQC */ ret = genstoreconditional(ctx, ra, rb, disp16, 1); break; case 0x30: /* BR */ ret = genbdirect(ctx, ra, disp21); break; case 0x31: /* FBEQ */ ret = genfbcond(ctx, TCGCONDEQ, ra, disp21); break; case 0x32: /* FBLT */ ret = genfbcond(ctx, TCGCONDLT, ra, disp21); break; case 0x33: /* FBLE */ ret = genfbcond(ctx, TCGCONDLE, ra, disp21); break; case 0x34: /* BSR */ ret = genbdirect(ctx, ra, disp21); break; case 0x35: /* FBNE */ ret = genfbcond(ctx, TCGCONDNE, ra, disp21); break; case 0x36: /* FBGE */ ret = genfbcond(ctx, TCGCONDGE, ra, disp21); break; case 0x37: /* FBGT */ ret = genfbcond(ctx, TCGCONDGT, ra, disp21); break; case 0x38: /* BLBC */ ret = genbcond(ctx, TCGCONDEQ, ra, disp21, 1); break; case 0x39: /* BEQ */ ret = genbcond(ctx, TCGCONDEQ, ra, disp21, 0); break; case 0x3A: /* BLT */ ret = genbcond(ctx, TCGCONDLT, ra, disp21, 0); break; case 0x3B: /* BLE */ ret = genbcond(ctx, TCGCONDLE, ra, disp21, 0); break; case 0x3C: /* BLBS */ ret = genbcond(ctx, TCGCONDNE, ra, disp21, 1); break; case 0x3D: /* BNE */ ret = genbcond(ctx, TCGCONDNE, ra, disp21, 0); break; case 0x3E: /* BGE */ ret = genbcond(ctx, TCGCONDGE, ra, disp21, 0); break; case 0x3F: /* BGT */ ret = genbcond(ctx, TCGCONDGT, ra, disp21, 0); break; invalidopc: ret = geninvalid(ctx); break; } return ret; } ", "target": 0}
{"func": "inline static void RENAME(hcscale)(SwsContext *c, uint16t *dst, long dstWidth, const uint8t *src1, const uint8t *src2, int srcW, int xInc, int flags, const int16t *hChrFilter, const int16t *hChrFilterPos, int hChrFilterSize, int srcFormat, uint8t *formatConvBuffer, uint32t *pal) { int32t avunused *mmx2FilterPos = c->chrMmx2FilterPos; int16t avunused *mmx2Filter = c->chrMmx2Filter; int avunused canMMX2BeUsed = c->canMMX2BeUsed; void avunused *mmx2FilterCode= c->chrMmx2FilterCode; if (isGray(srcFormat) || srcFormat==PIXFMTMONOBLACK || srcFormat==PIXFMTMONOWHITE) return; if (srcFormat==PIXFMTRGB321 || srcFormat==PIXFMTBGR321) { src1 += ALT32CORR; src2 += ALT32CORR; } if (srcFormat==PIXFMTRGB48LE) { src1++; src2++; } if (c->hcscaleinternal) { c->hcscaleinternal(formatConvBuffer, formatConvBuffer+VOFW, src1, src2, srcW, pal); src1= formatConvBuffer; src2= formatConvBuffer+VOFW; } #if COMPILETEMPLATEMMX // Use the new MMX scaler if the MMX2 one can't be used (it is faster than the x86 ASM one). if (!(flags&SWSFASTBILINEAR) || (!canMMX2BeUsed)) #else if (!(flags&SWSFASTBILINEAR)) #endif { c->hScale(dst , dstWidth, src1, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize); c->hScale(dst+VOFW, dstWidth, src2, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize); } else { // fast bilinear upscale / crap downscale #if ARCHX86 && CONFIGGPL #if COMPILETEMPLATEMMX2 int i; #if defined(PIC) DECLAREALIGNED(8, uint64t, ebxsave); #endif if (canMMX2BeUsed) { asm volatile( #if defined(PIC) \"mov %%\"REGb\", %6 \\n\\t\" #endif \"pxor %%mm7, %%mm7 \\n\\t\" \"mov %0, %%\"REGc\" \\n\\t\" \"mov %1, %%\"REGD\" \\n\\t\" \"mov %2, %%\"REGd\" \\n\\t\" \"mov %3, %%\"REGb\" \\n\\t\" \"xor %%\"REGa\", %%\"REGa\" \\n\\t\" // i PREFETCH\" (%%\"REGc\") \\n\\t\" PREFETCH\" 32(%%\"REGc\") \\n\\t\" PREFETCH\" 64(%%\"REGc\") \\n\\t\" CALLMMX2FILTERCODE CALLMMX2FILTERCODE CALLMMX2FILTERCODE CALLMMX2FILTERCODE \"xor %%\"REGa\", %%\"REGa\" \\n\\t\" // i \"mov %5, %%\"REGc\" \\n\\t\" // src \"mov %1, %%\"REGD\" \\n\\t\" // buf1 \"add $\"AVSTRINGIFY(VOF)\", %%\"REGD\" \\n\\t\" PREFETCH\" (%%\"REGc\") \\n\\t\" PREFETCH\" 32(%%\"REGc\") \\n\\t\" PREFETCH\" 64(%%\"REGc\") \\n\\t\" CALLMMX2FILTERCODE CALLMMX2FILTERCODE CALLMMX2FILTERCODE CALLMMX2FILTERCODE #if defined(PIC) \"mov %6, %%\"REGb\" \\n\\t\" #endif :: \"m\" (src1), \"m\" (dst), \"m\" (mmx2Filter), \"m\" (mmx2FilterPos), \"m\" (mmx2FilterCode), \"m\" (src2) #if defined(PIC) ,\"m\" (ebxsave) #endif : \"%\"REGa, \"%\"REGc, \"%\"REGd, \"%\"REGS, \"%\"REGD #if !defined(PIC) ,\"%\"REGb #endif ); for (i=dstWidth-1; (i*xInc)>>16 >=srcW-1; i--) { //printf(\"%d %d %d\\n\", dstWidth, i, srcW); dst[i] = src1[srcW-1]*128; dst[i+VOFW] = src2[srcW-1]*128; } } else { #endif /* COMPILETEMPLATEMMX2 */ x86reg xIncshr16 = (x86reg) (xInc >> 16); uint16t xIncmask = xInc & 0xffff; asm volatile( \"xor %%\"REGa\", %%\"REGa\" \\n\\t\" // i \"xor %%\"REGd\", %%\"REGd\" \\n\\t\" // xx \"xorl %%ecx, %%ecx \\n\\t\" // xalpha ASMALIGN(4) \"1: \\n\\t\" \"mov %0, %%\"REGS\" \\n\\t\" \"movzbl (%%\"REGS\", %%\"REGd\"), %%edi \\n\\t\" //src[xx] \"movzbl 1(%%\"REGS\", %%\"REGd\"), %%esi \\n\\t\" //src[xx+1] FASTBILINEARX86 \"movw %%si, (%%\"REGD\", %%\"REGa\", 2) \\n\\t\" \"movzbl (%5, %%\"REGd\"), %%edi \\n\\t\" //src[xx] \"movzbl 1(%5, %%\"REGd\"), %%esi \\n\\t\" //src[xx+1] FASTBILINEARX86 \"movw %%si, \"AVSTRINGIFY(VOF)\"(%%\"REGD\", %%\"REGa\", 2) \\n\\t\" \"addw %4, %%cx \\n\\t\" //xalpha += xInc&0xFFFF \"adc %3, %%\"REGd\" \\n\\t\" //xx+= xInc>>16 + carry \"add $1, %%\"REGa\" \\n\\t\" \"cmp %2, %%\"REGa\" \\n\\t\" \" jb 1b \\n\\t\" /* GCC 3.3 makes MPlayer crash on IA-32 machines when using \"g\" operand here, which is needed to support GCC 4.0. */ #if ARCHX8664 && ((GNUC > 3) || (GNUC == 3 && GNUCMINOR >= 4)) :: \"m\" (src1), \"m\" (dst), \"g\" (dstWidth), \"m\" (xIncshr16), \"m\" (xIncmask), #else :: \"m\" (src1), \"m\" (dst), \"m\" (dstWidth), \"m\" (xIncshr16), \"m\" (xIncmask), #endif \"r\" (src2) : \"%\"REGa, \"%\"REGd, \"%ecx\", \"%\"REGD, \"%esi\" ); #if COMPILETEMPLATEMMX2 } //if MMX2 can't be used #endif #else c->hcscalefast(c, dst, dstWidth, src1, src2, srcW, xInc); #endif /* ARCHX86 */ } if(c->srcRange != c->dstRange && !(isRGB(c->dstFormat) || isBGR(c->dstFormat))) { int i; //FIXME all pal and rgb srcFormats could do this convertion as well //FIXME all scalers more complex than bilinear could do half of this transform if(c->srcRange) { for (i=0; i<dstWidth; i++) { dst[i ]= (dst[i ]*1799 + 4081085)>>11; //1469 dst[i+VOFW]= (dst[i+VOFW]*1799 + 4081085)>>11; //1469 } } else { for (i=0; i<dstWidth; i++) { dst[i ]= (FFMIN(dst[i ],30775)*4663 - 9289992)>>12; //-264 dst[i+VOFW]= (FFMIN(dst[i+VOFW],30775)*4663 - 9289992)>>12; //-264 } } } } ", "target": 0}
{"func": "float32 HELPER(ucf64abss)(float32 a) { return float32abs(a); } ", "target": 0}
{"func": "int qemuthreadequal(QemuThread *thread1, QemuThread *thread2) { return pthreadequal(thread1->thread, thread2->thread); } ", "target": 0}
{"func": "static void ivshmemiowritel(void *opaque, targetphysaddrt addr, uint32t val) { IVShmemState *s = opaque; uint64t writeone = 1; uint16t dest = val >> 16; uint16t vector = val & 0xff; addr &= 0xfc; IVSHMEMDPRINTF(\"writing to addr \" TARGETFMTplx \"\\n\", addr); switch (addr) { case INTRMASK: ivshmemIntrMaskwrite(s, val); break; case INTRSTATUS: ivshmemIntrStatuswrite(s, val); break; case DOORBELL: /* check that dest VM ID is reasonable */ if ((dest < 0) || (dest > s->maxpeer)) { IVSHMEMDPRINTF(\"Invalid destination VM ID (%d)\\n\", dest); break; } /* check doorbell range */ if ((vector >= 0) && (vector < s->peers[dest].nbeventfds)) { IVSHMEMDPRINTF(\"Writing %\" PRId64 \" to VM %d on vector %d\\n\", writeone, dest, vector); if (write(s->peers[dest].eventfds[vector], &(writeone), 8) != 8) { IVSHMEMDPRINTF(\"error writing to eventfd\\n\"); } } break; default: IVSHMEMDPRINTF(\"Invalid VM Doorbell VM %d\\n\", dest); } } ", "target": 0}
{"func": "static inline void genouts(DisasContext *s, TCGMemOp ot) { if (useicount) geniostart(); genstringmovlA0ESI(s); genopldv(s, ot, cpuT[0], cpuA0); tcggentrunctli32(cputmp2i32, cpuregs[REDX]); tcggenandii32(cputmp2i32, cputmp2i32, 0xffff); tcggentrunctli32(cputmp3i32, cpuT[0]); genhelperoutfunc(ot, cputmp2i32, cputmp3i32); genopmovlT0Dshift(ot); genopaddregT0(s->aflag, RESI); if (useicount) genioend(); } ", "target": 0}
{"func": "void testfcmp(double a, double b) { long eflags, fpus; fpuclearexceptions(); asm(\"fcom %2\\n\" \"fstsw %%ax\\n\" : \"=a\" (fpus) : \"t\" (a), \"u\" (b)); printf(\"fcom(%f %f)=%04lx \\n\", a, b, fpus & (0x4500 | FPUSEMASK)); fpuclearexceptions(); asm(\"fucom %2\\n\" \"fstsw %%ax\\n\" : \"=a\" (fpus) : \"t\" (a), \"u\" (b)); printf(\"fucom(%f %f)=%04lx\\n\", a, b, fpus & (0x4500 | FPUSEMASK)); if (TESTFCOMI) { /* test f(u)comi instruction */ fpuclearexceptions(); asm(\"fcomi %3, %2\\n\" \"fstsw %%ax\\n\" \"pushf\\n\" \"pop %0\\n\" : \"=r\" (eflags), \"=a\" (fpus) : \"t\" (a), \"u\" (b)); printf(\"fcomi(%f %f)=%04lx %02lx\\n\", a, b, fpus & FPUSEMASK, eflags & (CCZ | CCP | CCC)); fpuclearexceptions(); asm(\"fucomi %3, %2\\n\" \"fstsw %%ax\\n\" \"pushf\\n\" \"pop %0\\n\" : \"=r\" (eflags), \"=a\" (fpus) : \"t\" (a), \"u\" (b)); printf(\"fucomi(%f %f)=%04lx %02lx\\n\", a, b, fpus & FPUSEMASK, eflags & (CCZ | CCP | CCC)); } fpuclearexceptions(); asm volatile(\"fxam\\n\" \"fstsw %%ax\\n\" : \"=a\" (fpus) : \"t\" (a)); printf(\"fxam(%f)=%04lx\\n\", a, fpus & 0x4700); fpuclearexceptions(); } ", "target": 0}
{"func": "void tlbsetpagewithattrs(CPUState *cpu, targetulong vaddr, hwaddr paddr, MemTxAttrs attrs, int prot, int mmuidx, targetulong size) { CPUArchState *env = cpu->envptr; MemoryRegionSection *section; unsigned int index; targetulong address; targetulong codeaddress; uintptrt addend; CPUTLBEntry *te; hwaddr iotlb, xlat, sz; unsigned vidx = env->vtlbindex++ % CPUVTLBSIZE; int asidx = cpuasidxfromattrs(cpu, attrs); assertcpuisself(cpu); assert(size >= TARGETPAGESIZE); if (size != TARGETPAGESIZE) { tlbaddlargepage(env, vaddr, size); } sz = size; section = addressspacetranslateforiotlb(cpu, asidx, paddr, &xlat, &sz); assert(sz >= TARGETPAGESIZE); tlbdebug(\"vaddr=\" TARGETFMTlx \" paddr=0x\" TARGETFMTplx \" prot=%x idx=%d\\n\", vaddr, paddr, prot, mmuidx); address = vaddr; if (!memoryregionisram(section->mr) && !memoryregionisromd(section->mr)) { /* IO memory case */ address |= TLBMMIO; addend = 0; } else { /* TLBMMIO for rom/romd handled below */ addend = (uintptrt)memoryregiongetramptr(section->mr) + xlat; } codeaddress = address; iotlb = memoryregionsectiongetiotlb(cpu, section, vaddr, paddr, xlat, prot, &address); index = (vaddr >> TARGETPAGEBITS) & (CPUTLBSIZE - 1); te = &env->tlbtable[mmuidx][index]; /* do not discard the translation in te, evict it into a victim tlb */ env->tlbvtable[mmuidx][vidx] = *te; env->iotlbv[mmuidx][vidx] = env->iotlb[mmuidx][index]; /* refill the tlb */ env->iotlb[mmuidx][index].addr = iotlb - vaddr; env->iotlb[mmuidx][index].attrs = attrs; te->addend = addend - vaddr; if (prot & PAGEREAD) { te->addrread = address; } else { te->addrread = -1; } if (prot & PAGEEXEC) { te->addrcode = codeaddress; } else { te->addrcode = -1; } if (prot & PAGEWRITE) { if ((memoryregionisram(section->mr) && section->readonly) || memoryregionisromd(section->mr)) { /* Write access calls the I/O callback. */ te->addrwrite = address | TLBMMIO; } else if (memoryregionisram(section->mr) && cpuphysicalmemoryisclean( memoryregiongetramaddr(section->mr) + xlat)) { te->addrwrite = address | TLBNOTDIRTY; } else { te->addrwrite = address; } } else { te->addrwrite = -1; } } ", "target": 1}
{"func": "static int qcryptocipherinitdesrfb(QCryptoCipher *cipher, const uint8t *key, sizet nkey, Error **errp) { QCryptoCipherBuiltin *ctxt; if (cipher->mode != QCRYPTOCIPHERMODEECB) { errorsetg(errp, \"Unsupported cipher mode %d\", cipher->mode); return -1; } ctxt = gnew0(QCryptoCipherBuiltin, 1); ctxt->state.desrfb.key = gnew0(uint8t, nkey); memcpy(ctxt->state.desrfb.key, key, nkey); ctxt->state.desrfb.nkey = nkey; ctxt->free = qcryptocipherfreedesrfb; ctxt->setiv = qcryptociphersetivdesrfb; ctxt->encrypt = qcryptocipherencryptdesrfb; ctxt->decrypt = qcryptocipherdecryptdesrfb; cipher->opaque = ctxt; return 0; }", "target": 1}
{"func": "static int virtioccwhandlesetvq(SubchDev *sch, CCW1 ccw, bool checklen, bool islegacy) { int ret; VqInfoBlock info; VqInfoBlockLegacy linfo; sizet infolen = islegacy ? sizeof(linfo) : sizeof(info); if (checklen) { if (ccw.count != infolen) { return -EINVAL; } } else if (ccw.count < infolen) { /* Can't execute command. */ return -EINVAL; } if (!ccw.cda) { return -EFAULT; } if (islegacy) { linfo.queue = addressspaceldqbe(&addressspacememory, ccw.cda, MEMTXATTRSUNSPECIFIED, NULL); linfo.align = addressspaceldlbe(&addressspacememory, ccw.cda + sizeof(linfo.queue), MEMTXATTRSUNSPECIFIED, NULL); linfo.index = addressspacelduwbe(&addressspacememory, ccw.cda + sizeof(linfo.queue) + sizeof(linfo.align), MEMTXATTRSUNSPECIFIED, NULL); linfo.num = addressspacelduwbe(&addressspacememory, ccw.cda + sizeof(linfo.queue) + sizeof(linfo.align) + sizeof(linfo.index), MEMTXATTRSUNSPECIFIED, NULL); ret = virtioccwsetvqs(sch, NULL, &linfo); } else { info.desc = addressspaceldqbe(&addressspacememory, ccw.cda, MEMTXATTRSUNSPECIFIED, NULL); info.index = addressspacelduwbe(&addressspacememory, ccw.cda + sizeof(info.desc) + sizeof(info.res0), MEMTXATTRSUNSPECIFIED, NULL); info.num = addressspacelduwbe(&addressspacememory, ccw.cda + sizeof(info.desc) + sizeof(info.res0) + sizeof(info.index), MEMTXATTRSUNSPECIFIED, NULL); info.avail = addressspaceldqbe(&addressspacememory, ccw.cda + sizeof(info.desc) + sizeof(info.res0) + sizeof(info.index) + sizeof(info.num), MEMTXATTRSUNSPECIFIED, NULL); info.used = addressspaceldqbe(&addressspacememory, ccw.cda + sizeof(info.desc) + sizeof(info.res0) + sizeof(info.index) + sizeof(info.num) + sizeof(info.avail), MEMTXATTRSUNSPECIFIED, NULL); ret = virtioccwsetvqs(sch, &info, NULL); } sch->currstatus.scsw.count = 0; return ret; } ", "target": 0}
{"func": "static void vncclientcacheaddr(VncState *client) { Error *err = NULL; client->info = gmalloc0(sizeof(*client->info)); client->info->base = gmalloc0(sizeof(*client->info->base)); vncinitbasicinfofromremoteaddr(client->csock, client->info->base, &err); if (err) { qapifreeVncClientInfo(client->info); client->info = NULL; errorfree(err); } } ", "target": 0}
{"func": "int kvmirqchipaddirqfd(KVMState *s, int fd, int virq) { return kvmirqchipassignirqfd(s, fd, virq, true); } ", "target": 0}
{"func": "static gboolean udpchrread(GIOChannel *chan, GIOCondition cond, void *opaque) { CharDriverState *chr = opaque; NetCharDriver *s = chr->opaque; gsize bytesread = 0; GIOStatus status; if (s->maxsize == 0) return FALSE; status = giochannelreadchars(s->chan, (gchar *)s->buf, sizeof(s->buf), &bytesread, NULL); s->bufcnt = bytesread; s->bufptr = s->bufcnt; if (status != GIOSTATUSNORMAL) { return FALSE; } s->bufptr = 0; while (s->maxsize > 0 && s->bufptr < s->bufcnt) { qemuchrbewrite(chr, &s->buf[s->bufptr], 1); s->bufptr++; s->maxsize = qemuchrbecanwrite(chr); } return TRUE; } ", "target": 0}
{"func": "PCIBus *pciprepinit(qemuirq *pic) { PREPPCIState *s; PCIDevice *d; int PPCiomemory; s = qemumallocz(sizeof(PREPPCIState)); s->bus = pciregisterbus(prepsetirq, prepmapirq, pic, 0, 2); registerioportwrite(0xcf8, 4, 4, pciprepaddrwritel, s); registerioportread(0xcf8, 4, 4, pciprepaddrreadl, s); registerioportwrite(0xcfc, 4, 1, pcihostdatawriteb, s); registerioportwrite(0xcfc, 4, 2, pcihostdatawritew, s); registerioportwrite(0xcfc, 4, 4, pcihostdatawritel, s); registerioportread(0xcfc, 4, 1, pcihostdatareadb, s); registerioportread(0xcfc, 4, 2, pcihostdatareadw, s); registerioportread(0xcfc, 4, 4, pcihostdatareadl, s); PPCiomemory = cpuregisteriomemory(0, PPCPCIIOread, PPCPCIIOwrite, s); cpuregisterphysicalmemory(0x80800000, 0x00400000, PPCiomemory); /* PCI host bridge */ d = pciregisterdevice(s->bus, \"PREP Host Bridge - Motorola Raven\", sizeof(PCIDevice), 0, NULL, NULL); d->config[0x00] = 0x57; // vendorid : Motorola d->config[0x01] = 0x10; d->config[0x02] = 0x01; // deviceid : Raven d->config[0x03] = 0x48; d->config[0x08] = 0x00; // revision d->config[0x0A] = 0x00; // classsub = pci host d->config[0x0B] = 0x06; // classbase = PCIbridge d->config[0x0C] = 0x08; // cachelinesize d->config[0x0D] = 0x10; // latencytimer d->config[0x0E] = 0x00; // headertype d->config[0x34] = 0x00; // capabilitiespointer return s->bus; } ", "target": 1}
{"func": "static int rawinitencoder(AVCodecContext *avctx) { avctx->codedframe = (AVFrame *)avctx->privdata; avctx->codedframe->picttype = FFITYPE; avctx->codedframe->keyframe = 1; avctx->codectag = findFourCC(avctx->pixfmt); return 0; } ", "target": 0}
{"func": "static int decodesequenceheaderadv(VC1Context *v, GetBitContext *gb) { v->resrtmflag = 1; v->level = getbits(gb, 3); if(v->level >= 5) { avlog(v->s.avctx, AVLOGERROR, \"Reserved LEVEL %i\\n\",v->level); } v->chromaformat = getbits(gb, 2); if (v->chromaformat != 1) { avlog(v->s.avctx, AVLOGERROR, \"Only 4:2:0 chroma format supported\\n\"); return -1; } // (fps-2)/4 (->30) v->frmrtqpostproc = getbits(gb, 3); //common // (bitrate-32kbps)/64kbps v->bitrtqpostproc = getbits(gb, 5); //common v->postprocflag = getbits(gb, 1); //common v->s.avctx->codedwidth = (getbits(gb, 12) + 1) << 1; v->s.avctx->codedheight = (getbits(gb, 12) + 1) << 1; v->broadcast = getbits1(gb); v->interlace = getbits1(gb); if(v->interlace){ avlog(v->s.avctx, AVLOGERROR, \"Interlaced mode not supported (yet)\\n\"); return -1; } v->tfcntrflag = getbits1(gb); v->finterpflag = getbits1(gb); getbits1(gb); // reserved v->psf = getbits1(gb); if(v->psf) { //PsF, 6.1.13 avlog(v->s.avctx, AVLOGERROR, \"Progressive Segmented Frame mode: not supported (yet)\\n\"); return -1; } if(getbits1(gb)) { //Display Info - decoding is not affected by it int w, h, ar = 0; avlog(v->s.avctx, AVLOGINFO, \"Display extended info:\\n\"); w = getbits(gb, 14); h = getbits(gb, 14); avlog(v->s.avctx, AVLOGINFO, \"Display dimensions: %ix%i\\n\", w, h); //TODO: store aspect ratio in AVCodecContext if(getbits1(gb)) ar = getbits(gb, 4); if(ar == 15) { w = getbits(gb, 8); h = getbits(gb, 8); } if(getbits1(gb)){ //framerate stuff if(getbits1(gb)) { getbits(gb, 16); } else { getbits(gb, 8); getbits(gb, 4); } } if(getbits1(gb)){ v->colorprim = getbits(gb, 8); v->transferchar = getbits(gb, 8); v->matrixcoef = getbits(gb, 8); } } v->hrdparamflag = getbits1(gb); if(v->hrdparamflag) { int i; v->hrdnumleakybuckets = getbits(gb, 5); getbits(gb, 4); //bitrate exponent getbits(gb, 4); //buffer size exponent for(i = 0; i < v->hrdnumleakybuckets; i++) { getbits(gb, 16); //hrdrate[n] getbits(gb, 16); //hrdbuffer[n] } } return 0; } ", "target": 1}
{"func": "int pageunprotect(targetulong address, uintptrt pc, void *puc) { unsigned int prot; PageDesc *p; targetulong hoststart, hostend, addr; /* Technically this isn't safe inside a signal handler. However we know this only ever happens in a synchronous SEGV handler, so in practice it seems to be ok. */ mmaplock(); p = pagefind(address >> TARGETPAGEBITS); if (!p) { mmapunlock(); return 0; } /* if the page was really writable, then we change its protection back to writable */ if ((p->flags & PAGEWRITEORG) && !(p->flags & PAGEWRITE)) { hoststart = address & qemuhostpagemask; hostend = hoststart + qemuhostpagesize; prot = 0; for (addr = hoststart ; addr < hostend ; addr += TARGETPAGESIZE) { p = pagefind(addr >> TARGETPAGEBITS); p->flags |= PAGEWRITE; prot |= p->flags; /* and since the content will be modified, we must invalidate the corresponding translated code. */ tbinvalidatephyspage(addr, pc, puc); #ifdef DEBUGTBCHECK tbinvalidatecheck(addr); #endif } mprotect((void *)g2h(hoststart), qemuhostpagesize, prot & PAGEBITS); mmapunlock(); return 1; } mmapunlock(); return 0; } ", "target": 1}
{"func": "void ffputh264qpel8mc23msa(uint8t *dst, const uint8t *src, ptrdifft stride) { avclumamidvqrt8wmsa(src - (2 * stride) - 2, stride, dst, stride, 8, 1); } ", "target": 0}
{"func": "static int filmprobe(AVProbeData *p) { if (p->bufsize < 4) return 0; if (AVRB32(&p->buf[0]) != FILMTAG) return 0; return AVPROBESCOREMAX; } ", "target": 0}
{"func": "static void genstorev10conditional(DisasContext *dc, TCGv addr, TCGv val, unsigned int size, int memindex) { int l1 = gennewlabel(); TCGv taddr = tcgtemplocalnew(); TCGv tval = tcgtemplocalnew(); TCGv t1 = tcgtemplocalnew(); dc->postinc = 0; crisevaluateflags(dc); tcggenmovtl(taddr, addr); tcggenmovtl(tval, val); /* Store only if F flag isn't set */ tcggenanditl(t1, cpuPR[PRCCS], FFLAGV10); tcggenbrconditl(TCGCONDNE, t1, 0, l1); if (size == 1) { tcggenqemust8(tval, taddr, memindex); } else if (size == 2) { tcggenqemust16(tval, taddr, memindex); } else { tcggenqemust32(tval, taddr, memindex); } gensetlabel(l1); tcggenshritl(t1, t1, 1); /* shift F to P position */ tcggenortl(cpuPR[PRCCS], cpuPR[PRCCS], t1); /*P=F*/ tcgtempfree(t1); tcgtempfree(tval); tcgtempfree(taddr); } ", "target": 0}
{"func": "static void idetrimbhcb(void *opaque) { TrimAIOCB *iocb = opaque; iocb->common.cb(iocb->common.opaque, iocb->ret); qemubhdelete(iocb->bh); iocb->bh = NULL; qemuaiounref(iocb); } ", "target": 0}
{"func": "static abilong doioctldm(const IOCTLEntry *ie, uint8t *buftemp, int fd, abilong cmd, abilong arg) { void *argptr; struct dmioctl *hostdm; abilong guestdata; uint32t guestdatasize; int targetsize; const argtype *argtype = ie->argtype; abilong ret; void *bigbuf = NULL; char *hostdata; argtype++; targetsize = thunktypesize(argtype, 0); argptr = lockuser(VERIFYREAD, arg, targetsize, 1); if (!argptr) { ret = -TARGETEFAULT; goto out; } thunkconvert(buftemp, argptr, argtype, THUNKHOST); unlockuser(argptr, arg, 0); /* buftemp is too small, so fetch things into a bigger buffer */ bigbuf = gmalloc0(((struct dmioctl*)buftemp)->datasize * 2); memcpy(bigbuf, buftemp, targetsize); buftemp = bigbuf; hostdm = bigbuf; guestdata = arg + hostdm->datastart; if ((guestdata - arg) < 0) { ret = -EINVAL; goto out; } guestdatasize = hostdm->datasize - hostdm->datastart; hostdata = (char*)hostdm + hostdm->datastart; argptr = lockuser(VERIFYREAD, guestdata, guestdatasize, 1); switch (ie->hostcmd) { case DMREMOVEALL: case DMLISTDEVICES: case DMDEVCREATE: case DMDEVREMOVE: case DMDEVSUSPEND: case DMDEVSTATUS: case DMDEVWAIT: case DMTABLESTATUS: case DMTABLECLEAR: case DMTABLEDEPS: case DMLISTVERSIONS: /* no input data */ break; case DMDEVRENAME: case DMDEVSETGEOMETRY: /* data contains only strings */ memcpy(hostdata, argptr, guestdatasize); break; case DMTARGETMSG: memcpy(hostdata, argptr, guestdatasize); *(uint64t*)hostdata = tswap64(*(uint64t*)argptr); break; case DMTABLELOAD: { void *gspec = argptr; void *curdata = hostdata; const argtype argtype[] = { MKSTRUCT(STRUCTdmtargetspec) }; int specsize = thunktypesize(argtype, 0); int i; for (i = 0; i < hostdm->targetcount; i++) { struct dmtargetspec *spec = curdata; uint32t next; int slen; thunkconvert(spec, gspec, argtype, THUNKHOST); slen = strlen((char*)gspec + specsize) + 1; next = spec->next; spec->next = sizeof(*spec) + slen; strcpy((char*)&spec[1], gspec + specsize); gspec += next; curdata += spec->next; } break; } default: ret = -TARGETEINVAL; goto out; } unlockuser(argptr, guestdata, 0); ret = geterrno(ioctl(fd, ie->hostcmd, buftemp)); if (!iserror(ret)) { guestdata = arg + hostdm->datastart; guestdatasize = hostdm->datasize - hostdm->datastart; argptr = lockuser(VERIFYWRITE, guestdata, guestdatasize, 0); switch (ie->hostcmd) { case DMREMOVEALL: case DMDEVCREATE: case DMDEVREMOVE: case DMDEVRENAME: case DMDEVSUSPEND: case DMDEVSTATUS: case DMTABLELOAD: case DMTABLECLEAR: case DMTARGETMSG: case DMDEVSETGEOMETRY: /* no return data */ break; case DMLISTDEVICES: { struct dmnamelist *nl = (void*)hostdm + hostdm->datastart; uint32t remainingdata = guestdatasize; void *curdata = argptr; const argtype argtype[] = { MKSTRUCT(STRUCTdmnamelist) }; int nlsize = 12; /* can't use thunksize due to alignment */ while (1) { uint32t next = nl->next; if (next) { nl->next = nlsize + (strlen(nl->name) + 1); } if (remainingdata < nl->next) { hostdm->flags |= DMBUFFERFULLFLAG; break; } thunkconvert(curdata, nl, argtype, THUNKTARGET); strcpy(curdata + nlsize, nl->name); curdata += nl->next; remainingdata -= nl->next; if (!next) { break; } nl = (void*)nl + next; } break; } case DMDEVWAIT: case DMTABLESTATUS: { struct dmtargetspec *spec = (void*)hostdm + hostdm->datastart; void *curdata = argptr; const argtype argtype[] = { MKSTRUCT(STRUCTdmtargetspec) }; int specsize = thunktypesize(argtype, 0); int i; for (i = 0; i < hostdm->targetcount; i++) { uint32t next = spec->next; int slen = strlen((char*)&spec[1]) + 1; spec->next = (curdata - argptr) + specsize + slen; if (guestdatasize < spec->next) { hostdm->flags |= DMBUFFERFULLFLAG; break; } thunkconvert(curdata, spec, argtype, THUNKTARGET); strcpy(curdata + specsize, (char*)&spec[1]); curdata = argptr + spec->next; spec = (void*)hostdm + hostdm->datastart + next; } break; } case DMTABLEDEPS: { void *hdata = (void*)hostdm + hostdm->datastart; int count = *(uint32t*)hdata; uint64t *hdev = hdata + 8; uint64t *gdev = argptr + 8; int i; *(uint32t*)argptr = tswap32(count); for (i = 0; i < count; i++) { *gdev = tswap64(*hdev); gdev++; hdev++; } break; } case DMLISTVERSIONS: { struct dmtargetversions *vers = (void*)hostdm + hostdm->datastart; uint32t remainingdata = guestdatasize; void *curdata = argptr; const argtype argtype[] = { MKSTRUCT(STRUCTdmtargetversions) }; int verssize = thunktypesize(argtype, 0); while (1) { uint32t next = vers->next; if (next) { vers->next = verssize + (strlen(vers->name) + 1); } if (remainingdata < vers->next) { hostdm->flags |= DMBUFFERFULLFLAG; break; } thunkconvert(curdata, vers, argtype, THUNKTARGET); strcpy(curdata + verssize, vers->name); curdata += vers->next; remainingdata -= vers->next; if (!next) { break; } vers = (void*)vers + next; } break; } default: ret = -TARGETEINVAL; goto out; } unlockuser(argptr, guestdata, guestdatasize); argptr = lockuser(VERIFYWRITE, arg, targetsize, 0); if (!argptr) { ret = -TARGETEFAULT; goto out; } thunkconvert(argptr, buftemp, argtype, THUNKTARGET); unlockuser(argptr, arg, targetsize); } out: if (bigbuf) { free(bigbuf); } return ret; } ", "target": 0}
{"func": "static int dxva2retrievedata(AVCodecContext *s, AVFrame *frame) { InputStream *ist = s->opaque; DXVA2Context *ctx = ist->hwaccelctx; int ret; ret = avhwframetransferdata(ctx->tmpframe, frame, 0); if (ret < 0) return ret; ret = avframecopyprops(ctx->tmpframe, frame); if (ret < 0) { avframeunref(ctx->tmpframe); return ret; } avframeunref(frame); avframemoveref(frame, ctx->tmpframe); return 0; } ", "target": 0}
{"func": "void decodembmode(VP8Context *s, VP8Macroblock *mb, int mbx, int mby, uint8t *segment, uint8t *ref, int layout) { VP56RangeCoder *c = &s->c; if (s->segmentation.updatemap) *segment = vp8racgettree(c, vp8segmentidtree, s->prob->segmentid); else if (s->segmentation.enabled) *segment = ref ? *ref : *segment; mb->segment = *segment; mb->skip = s->mbskipenabled ? vp56racgetprob(c, s->prob->mbskip) : 0; if (s->keyframe) { mb->mode = vp8racgettree(c, vp8pred16x16treeintra, vp8pred16x16probintra); if (mb->mode == MODEI4x4) { decodeintra4x4modes(s, c, mb, mbx, 1, layout); } else { const uint32t modes = vp8pred4x4mode[mb->mode] * 0x01010101u; if (s->mblayout == 1) AVWN32A(mb->intra4x4predmodetop, modes); else AVWN32A(s->intra4x4predmodetop + 4 * mbx, modes); AVWN32A(s->intra4x4predmodeleft, modes); } mb->chromapredmode = vp8racgettree(c, vp8pred8x8ctree, vp8pred8x8cprobintra); mb->refframe = VP56FRAMECURRENT; } else if (vp56racgetprobbranchy(c, s->prob->intra)) { // inter MB, 16.2 if (vp56racgetprobbranchy(c, s->prob->last)) mb->refframe = vp56racgetprob(c, s->prob->golden) ? VP56FRAMEGOLDEN2 /* altref */ : VP56FRAMEGOLDEN; else mb->refframe = VP56FRAMEPREVIOUS; s->refcount[mb->refframe - 1]++; // motion vectors, 16.3 decodemvs(s, mb, mbx, mby, layout); } else { // intra MB, 16.1 mb->mode = vp8racgettree(c, vp8pred16x16treeinter, s->prob->pred16x16); if (mb->mode == MODEI4x4) decodeintra4x4modes(s, c, mb, mbx, 0, layout); mb->chromapredmode = vp8racgettree(c, vp8pred8x8ctree, s->prob->pred8x8c); mb->refframe = VP56FRAMECURRENT; mb->partitioning = VP8SPLITMVMODENONE; AVZERO32(&mb->bmv[0]); } } ", "target": 1}
{"func": "static int decodemicromipsopc (CPUMIPSState *env, DisasContext *ctx, int *isbranch) { uint32t op; /* make sure instructions are on a halfword boundary */ if (ctx->pc & 0x1) { env->CP0BadVAddr = ctx->pc; generateexception(ctx, EXCPAdEL); ctx->bstate = BSSTOP; return 2; } op = (ctx->opcode >> 10) & 0x3f; /* Enforce properly-sized instructions in a delay slot */ if (ctx->hflags & MIPSHFLAGBMASK) { int bits = ctx->hflags & MIPSHFLAGBMASKEXT; switch (op) { case POOL32A: case POOL32B: case POOL32I: case POOL32C: case ADDI32: case ADDIU32: case ORI32: case XORI32: case SLTI32: case SLTIU32: case ANDI32: case JALX32: case LBU32: case LHU32: case POOL32F: case JALS32: case BEQ32: case BNE32: case J32: case JAL32: case SB32: case SH32: case POOL32S: case ADDIUPC: case SWC132: case SDC132: case SD32: case SW32: case LB32: case LH32: case DADDIU32: case LWC132: case LDC132: case LD32: case LW32: if (bits & MIPSHFLAGBDS16) { generateexception(ctx, EXCPRI); /* Just stop translation; the user is confused. */ ctx->bstate = BSSTOP; return 2; } break; case POOL16A: case POOL16B: case POOL16C: case LWGP16: case POOL16F: case LBU16: case LHU16: case LWSP16: case LW16: case SB16: case SH16: case SWSP16: case SW16: case MOVE16: case ANDI16: case POOL16D: case POOL16E: case BEQZ16: case BNEZ16: case B16: case LI16: if (bits & MIPSHFLAGBDS32) { generateexception(ctx, EXCPRI); /* Just stop translation; the user is confused. */ ctx->bstate = BSSTOP; return 2; } break; default: break; } } switch (op) { case POOL16A: { int rd = mmreg(uMIPSRD(ctx->opcode)); int rs1 = mmreg(uMIPSRS1(ctx->opcode)); int rs2 = mmreg(uMIPSRS2(ctx->opcode)); uint32t opc = 0; switch (ctx->opcode & 0x1) { case ADDU16: opc = OPCADDU; break; case SUBU16: opc = OPCSUBU; break; } genarith(ctx, opc, rd, rs1, rs2); } break; case POOL16B: { int rd = mmreg(uMIPSRD(ctx->opcode)); int rs = mmreg(uMIPSRS(ctx->opcode)); int amount = (ctx->opcode >> 1) & 0x7; uint32t opc = 0; amount = amount == 0 ? 8 : amount; switch (ctx->opcode & 0x1) { case SLL16: opc = OPCSLL; break; case SRL16: opc = OPCSRL; break; } genshiftimm(ctx, opc, rd, rs, amount); } break; case POOL16C: genpool16cinsn(ctx, isbranch); break; case LWGP16: { int rd = mmreg(uMIPSRD(ctx->opcode)); int rb = 28; /* GP */ int16t offset = SIMM(ctx->opcode, 0, 7) << 2; genld(ctx, OPCLW, rd, rb, offset); } break; case POOL16F: if (ctx->opcode & 1) { generateexception(ctx, EXCPRI); } else { /* MOVEP */ int encdest = uMIPSRD(ctx->opcode); int encrt = uMIPSRS2(ctx->opcode); int encrs = uMIPSRS1(ctx->opcode); int rd, rs, re, rt; static const int rdenc[] = { 5, 5, 6, 4, 4, 4, 4, 4 }; static const int reenc[] = { 6, 7, 7, 21, 22, 5, 6, 7 }; static const int rsrtenc[] = { 0, 17, 2, 3, 16, 18, 19, 20 }; rd = rdenc[encdest]; re = reenc[encdest]; rs = rsrtenc[encrs]; rt = rsrtenc[encrt]; genarithimm(ctx, OPCADDIU, rd, rs, 0); genarithimm(ctx, OPCADDIU, re, rt, 0); } break; case LBU16: { int rd = mmreg(uMIPSRD(ctx->opcode)); int rb = mmreg(uMIPSRS(ctx->opcode)); int16t offset = ZIMM(ctx->opcode, 0, 4); offset = (offset == 0xf ? -1 : offset); genld(ctx, OPCLBU, rd, rb, offset); } break; case LHU16: { int rd = mmreg(uMIPSRD(ctx->opcode)); int rb = mmreg(uMIPSRS(ctx->opcode)); int16t offset = ZIMM(ctx->opcode, 0, 4) << 1; genld(ctx, OPCLHU, rd, rb, offset); } break; case LWSP16: { int rd = (ctx->opcode >> 5) & 0x1f; int rb = 29; /* SP */ int16t offset = ZIMM(ctx->opcode, 0, 5) << 2; genld(ctx, OPCLW, rd, rb, offset); } break; case LW16: { int rd = mmreg(uMIPSRD(ctx->opcode)); int rb = mmreg(uMIPSRS(ctx->opcode)); int16t offset = ZIMM(ctx->opcode, 0, 4) << 2; genld(ctx, OPCLW, rd, rb, offset); } break; case SB16: { int rd = mmreg2(uMIPSRD(ctx->opcode)); int rb = mmreg(uMIPSRS(ctx->opcode)); int16t offset = ZIMM(ctx->opcode, 0, 4); genst(ctx, OPCSB, rd, rb, offset); } break; case SH16: { int rd = mmreg2(uMIPSRD(ctx->opcode)); int rb = mmreg(uMIPSRS(ctx->opcode)); int16t offset = ZIMM(ctx->opcode, 0, 4) << 1; genst(ctx, OPCSH, rd, rb, offset); } break; case SWSP16: { int rd = (ctx->opcode >> 5) & 0x1f; int rb = 29; /* SP */ int16t offset = ZIMM(ctx->opcode, 0, 5) << 2; genst(ctx, OPCSW, rd, rb, offset); } break; case SW16: { int rd = mmreg2(uMIPSRD(ctx->opcode)); int rb = mmreg(uMIPSRS(ctx->opcode)); int16t offset = ZIMM(ctx->opcode, 0, 4) << 2; genst(ctx, OPCSW, rd, rb, offset); } break; case MOVE16: { int rd = uMIPSRD5(ctx->opcode); int rs = uMIPSRS5(ctx->opcode); genarithimm(ctx, OPCADDIU, rd, rs, 0); } break; case ANDI16: genandi16(ctx); break; case POOL16D: switch (ctx->opcode & 0x1) { case ADDIUS5: genaddius5(ctx); break; case ADDIUSP: genaddiusp(ctx); break; } break; case POOL16E: switch (ctx->opcode & 0x1) { case ADDIUR2: genaddiur2(ctx); break; case ADDIUR1SP: genaddiur1sp(ctx); break; } break; case B16: gencomputebranch(ctx, OPCBEQ, 2, 0, 0, SIMM(ctx->opcode, 0, 10) << 1); *isbranch = 1; break; case BNEZ16: case BEQZ16: gencomputebranch(ctx, op == BNEZ16 ? OPCBNE : OPCBEQ, 2, mmreg(uMIPSRD(ctx->opcode)), 0, SIMM(ctx->opcode, 0, 7) << 1); *isbranch = 1; break; case LI16: { int reg = mmreg(uMIPSRD(ctx->opcode)); int imm = ZIMM(ctx->opcode, 0, 7); imm = (imm == 0x7f ? -1 : imm); tcggenmovitl(cpugpr[reg], imm); } break; case RES20: case RES28: case RES29: case RES30: case RES31: case RES38: case RES39: generateexception(ctx, EXCPRI); break; default: decodemicromips32opc (env, ctx, op, isbranch); return 4; } return 2; } ", "target": 1}
{"func": "static void decoupleinfo(COOKContext *q, COOKSubpacket *p, int *decoupletab) { int i; int vlc = getbits1(&q->gb); int start = cplband[p->jssubbandstart]; int end = cplband[p->subbands - 1]; int length = end - start + 1; if (start > end) return; if (vlc) for (i = 0; i < length; i++) decoupletab[start + i] = getvlc2(&q->gb, p->ccpl.table, p->ccpl.bits, 2); else for (i = 0; i < length; i++) decoupletab[start + i] = getbits(&q->gb, p->jsvlcbits); } ", "target": 0}
{"func": "static int preparepacket(AVPacket *pkt,const FailingMuxerPacketData *pktdata, int64t pts) { int ret; FailingMuxerPacketData *data = avmalloc(sizeof(*data)); memcpy(data, pktdata, sizeof(FailingMuxerPacketData)); ret = avpacketfromdata(pkt, (uint8t*) data, sizeof(*data)); pkt->pts = pkt->dts = pts; pkt->duration = 1; return ret; ", "target": 1}
{"func": "static void findbeststate(uint8t beststate[256][256], const uint8t onestate[256]){ int i,j,k,m; double l2tab[256]; for(i=1; i<256; i++) l2tab[i]= log2(i/256.0); for(i=0; i<256; i++){ double bestlen[256]; double p= i/256.0; for(j=0; j<256; j++) bestlen[j]= 1<<30; for(j=FFMAX(i-10,1); j<FFMIN(i+11,256); j++){ double occ[256]={0}; double len=0; occ[j]=1.0; for(k=0; k<256; k++){ double newocc[256]={0}; for(m=0; m<256; m++){ if(occ[m]){ len -=occ[m]*( p *l2tab[ m] + (1-p)*l2tab[256-m]); } } if(len < bestlen[k]){ bestlen[k]= len; beststate[i][k]= j; } for(m=0; m<256; m++){ if(occ[m]){ newocc[ onestate[ m]] += occ[m]* p ; newocc[256-onestate[256-m]] += occ[m]*(1-p); } } memcpy(occ, newocc, sizeof(occ)); } } } } ", "target": 0}
{"func": "static int getpcm(HEVCContext *s, int x, int y) { int log2minpusize = s->sps->log2minpusize; int xpu = x >> log2minpusize; int ypu = y >> log2minpusize; if (x < 0 || xpu >= s->sps->minpuwidth || y < 0 || ypu >= s->sps->minpuheight) return 2; return s->ispcm[ypu * s->sps->minpuwidth + xpu]; } ", "target": 0}
{"func": "static int h264decodeframe(AVCodecContext *avctx, void *data, int *gotframe, AVPacket *avpkt) { const uint8t *buf = avpkt->data; int bufsize = avpkt->size; H264Context *h = avctx->privdata; AVFrame *pict = data; int bufindex = 0; int ret; const uint8t *newextradata; int newextradatasize; h->flags = avctx->flags; h->setupfinished = 0; /* end of stream, output what is still in the buffers */ out: if (bufsize == 0) { H264Picture *out; int i, outidx; h->curpicptr = NULL; // FIXME factorize this with the output code below out = h->delayedpic[0]; outidx = 0; for (i = 1; h->delayedpic[i] && !h->delayedpic[i]->f->keyframe && !h->delayedpic[i]->mmcoreset; i++) if (h->delayedpic[i]->poc < out->poc) { out = h->delayedpic[i]; outidx = i; } for (i = outidx; h->delayedpic[i]; i++) h->delayedpic[i] = h->delayedpic[i + 1]; if (out) { ret = outputframe(h, pict, out->f); if (ret < 0) return ret; *gotframe = 1; } return bufindex; } newextradatasize = 0; newextradata = avpacketgetsidedata(avpkt, AVPKTDATANEWEXTRADATA, &newextradatasize); if (newextradatasize > 0 && newextradata) { ret = ffh264decodeextradata(newextradata, newextradatasize, &h->ps, &h->isavc, &h->nallengthsize, avctx->errrecognition, avctx); if (ret < 0) return ret; } bufindex = decodenalunits(h, buf, bufsize); if (bufindex < 0) return AVERRORINVALIDDATA; if (!h->curpicptr && h->nalunittype == NALENDSEQUENCE) { bufsize = 0; goto out; } if (!(avctx->flags2 & AVCODECFLAG2CHUNKS) && !h->curpicptr) { if (avctx->skipframe >= AVDISCARDNONREF) return 0; avlog(avctx, AVLOGERROR, \"no frame!\\n\"); return AVERRORINVALIDDATA; } if (!(avctx->flags2 & AVCODECFLAG2CHUNKS) || (h->mby >= h->mbheight && h->mbheight)) { if (avctx->flags2 & AVCODECFLAG2CHUNKS) decodepostinit(h, 1); ffh264fieldend(h, &h->slicectx[0], 0); *gotframe = 0; if (h->nextoutputpic && ((avctx->flags & AVCODECFLAGOUTPUTCORRUPT) || h->nextoutputpic->recovered)) { if (!h->nextoutputpic->recovered) h->nextoutputpic->f->flags |= AVFRAMEFLAGCORRUPT; ret = outputframe(h, pict, h->nextoutputpic->f); if (ret < 0) return ret; *gotframe = 1; } } assert(pict->buf[0] || !*gotframe); return getconsumedbytes(bufindex, bufsize); } ", "target": 0}
{"func": "static inline int16t calclowcomp(int16t a, int16t b0, int16t b1, uint8t bin) { if (bin < 7) { if ((b0 + 256) == b1) a = 384; else if (b0 > b1) a = FFMAX(0, a - 64); } else if (bin < 20) { if ((b0 + 256) == b1) a = 320; else if (b0 > b1) a = FFMAX(0, a - 64); } else { a = FFMAX(0, a - 128); } return a; } ", "target": 0}
{"func": "static inline void RENAME(yuy2toyv12)(const uint8t *src, uint8t *ydst, uint8t *udst, uint8t *vdst, long width, long height, long lumStride, long chromStride, long srcStride) { long y; const x86reg chromWidth= width>>1; for (y=0; y<height; y+=2) { #if COMPILETEMPLATEMMX asm volatile( \"xor %%\"REGa\", %%\"REGa\" \\n\\t\" \"pcmpeqw %%mm7, %%mm7 \\n\\t\" \"psrlw $8, %%mm7 \\n\\t\" // FF,00,FF,00... \".p2align 4 \\n\\t\" \"1: \\n\\t\" PREFETCH\" 64(%0, %%\"REGa\", 4) \\n\\t\" \"movq (%0, %%\"REGa\", 4), %%mm0 \\n\\t\" // YUYV YUYV(0) \"movq 8(%0, %%\"REGa\", 4), %%mm1 \\n\\t\" // YUYV YUYV(4) \"movq %%mm0, %%mm2 \\n\\t\" // YUYV YUYV(0) \"movq %%mm1, %%mm3 \\n\\t\" // YUYV YUYV(4) \"psrlw $8, %%mm0 \\n\\t\" // U0V0 U0V0(0) \"psrlw $8, %%mm1 \\n\\t\" // U0V0 U0V0(4) \"pand %%mm7, %%mm2 \\n\\t\" // Y0Y0 Y0Y0(0) \"pand %%mm7, %%mm3 \\n\\t\" // Y0Y0 Y0Y0(4) \"packuswb %%mm1, %%mm0 \\n\\t\" // UVUV UVUV(0) \"packuswb %%mm3, %%mm2 \\n\\t\" // YYYY YYYY(0) MOVNTQ\" %%mm2, (%1, %%\"REGa\", 2) \\n\\t\" \"movq 16(%0, %%\"REGa\", 4), %%mm1 \\n\\t\" // YUYV YUYV(8) \"movq 24(%0, %%\"REGa\", 4), %%mm2 \\n\\t\" // YUYV YUYV(12) \"movq %%mm1, %%mm3 \\n\\t\" // YUYV YUYV(8) \"movq %%mm2, %%mm4 \\n\\t\" // YUYV YUYV(12) \"psrlw $8, %%mm1 \\n\\t\" // U0V0 U0V0(8) \"psrlw $8, %%mm2 \\n\\t\" // U0V0 U0V0(12) \"pand %%mm7, %%mm3 \\n\\t\" // Y0Y0 Y0Y0(8) \"pand %%mm7, %%mm4 \\n\\t\" // Y0Y0 Y0Y0(12) \"packuswb %%mm2, %%mm1 \\n\\t\" // UVUV UVUV(8) \"packuswb %%mm4, %%mm3 \\n\\t\" // YYYY YYYY(8) MOVNTQ\" %%mm3, 8(%1, %%\"REGa\", 2) \\n\\t\" \"movq %%mm0, %%mm2 \\n\\t\" // UVUV UVUV(0) \"movq %%mm1, %%mm3 \\n\\t\" // UVUV UVUV(8) \"psrlw $8, %%mm0 \\n\\t\" // V0V0 V0V0(0) \"psrlw $8, %%mm1 \\n\\t\" // V0V0 V0V0(8) \"pand %%mm7, %%mm2 \\n\\t\" // U0U0 U0U0(0) \"pand %%mm7, %%mm3 \\n\\t\" // U0U0 U0U0(8) \"packuswb %%mm1, %%mm0 \\n\\t\" // VVVV VVVV(0) \"packuswb %%mm3, %%mm2 \\n\\t\" // UUUU UUUU(0) MOVNTQ\" %%mm0, (%3, %%\"REGa\") \\n\\t\" MOVNTQ\" %%mm2, (%2, %%\"REGa\") \\n\\t\" \"add $8, %%\"REGa\" \\n\\t\" \"cmp %4, %%\"REGa\" \\n\\t\" \" jb 1b \\n\\t\" ::\"r\"(src), \"r\"(ydst), \"r\"(udst), \"r\"(vdst), \"g\" (chromWidth) : \"memory\", \"%\"REGa ); ydst += lumStride; src += srcStride; asm volatile( \"xor %%\"REGa\", %%\"REGa\" \\n\\t\" \".p2align 4 \\n\\t\" \"1: \\n\\t\" PREFETCH\" 64(%0, %%\"REGa\", 4) \\n\\t\" \"movq (%0, %%\"REGa\", 4), %%mm0 \\n\\t\" // YUYV YUYV(0) \"movq 8(%0, %%\"REGa\", 4), %%mm1 \\n\\t\" // YUYV YUYV(4) \"movq 16(%0, %%\"REGa\", 4), %%mm2 \\n\\t\" // YUYV YUYV(8) \"movq 24(%0, %%\"REGa\", 4), %%mm3 \\n\\t\" // YUYV YUYV(12) \"pand %%mm7, %%mm0 \\n\\t\" // Y0Y0 Y0Y0(0) \"pand %%mm7, %%mm1 \\n\\t\" // Y0Y0 Y0Y0(4) \"pand %%mm7, %%mm2 \\n\\t\" // Y0Y0 Y0Y0(8) \"pand %%mm7, %%mm3 \\n\\t\" // Y0Y0 Y0Y0(12) \"packuswb %%mm1, %%mm0 \\n\\t\" // YYYY YYYY(0) \"packuswb %%mm3, %%mm2 \\n\\t\" // YYYY YYYY(8) MOVNTQ\" %%mm0, (%1, %%\"REGa\", 2) \\n\\t\" MOVNTQ\" %%mm2, 8(%1, %%\"REGa\", 2) \\n\\t\" \"add $8, %%\"REGa\" \\n\\t\" \"cmp %4, %%\"REGa\" \\n\\t\" \" jb 1b \\n\\t\" ::\"r\"(src), \"r\"(ydst), \"r\"(udst), \"r\"(vdst), \"g\" (chromWidth) : \"memory\", \"%\"REGa ); #else long i; for (i=0; i<chromWidth; i++) { ydst[2*i+0] = src[4*i+0]; udst[i] = src[4*i+1]; ydst[2*i+1] = src[4*i+2]; vdst[i] = src[4*i+3]; } ydst += lumStride; src += srcStride; for (i=0; i<chromWidth; i++) { ydst[2*i+0] = src[4*i+0]; ydst[2*i+1] = src[4*i+2]; } #endif udst += chromStride; vdst += chromStride; ydst += lumStride; src += srcStride; } #if COMPILETEMPLATEMMX asm volatile(EMMS\" \\n\\t\" SFENCE\" \\n\\t\" :::\"memory\"); #endif } ", "target": 0}
{"func": "static BdrvDirtyBitmap *blockdirtybitmaplookup(const char *node, const char *name, BlockDriverState **pbs, AioContext **paio, Error **errp) { BlockDriverState *bs; BdrvDirtyBitmap *bitmap; AioContext *aiocontext; if (!node) { errorsetg(errp, \"Node cannot be NULL\"); return NULL; } if (!name) { errorsetg(errp, \"Bitmap name cannot be NULL\"); return NULL; } bs = bdrvlookupbs(node, node, NULL); if (!bs) { errorsetg(errp, \"Node '%s' not found\", node); return NULL; } aiocontext = bdrvgetaiocontext(bs); aiocontextacquire(aiocontext); bitmap = bdrvfinddirtybitmap(bs, name); if (!bitmap) { errorsetg(errp, \"Dirty bitmap '%s' not found\", name); goto fail; } if (pbs) { *pbs = bs; } if (paio) { *paio = aiocontext; } else { aiocontextrelease(aiocontext); } return bitmap; fail: aiocontextrelease(aiocontext); return NULL; } ", "target": 0}
{"func": "void ppce500init(MachineState *machine, PPCE500Params *params) { MemoryRegion *addressspacemem = getsystemmemory(); MemoryRegion *ram = gnew(MemoryRegion, 1); PCIBus *pcibus; CPUPPCState *env = NULL; uint64t loadaddr; hwaddr kernelbase = -1LL; int kernelsize = 0; hwaddr dtbase = 0; hwaddr initrdbase = 0; int initrdsize = 0; hwaddr curbase = 0; char *filename; hwaddr biosentry = 0; targetlong biossize; struct bootinfo *bootinfo; int dtsize; int i; /* irq num for pin INTA, INTB, INTC and INTD is 1, 2, 3 and * 4 respectively */ unsigned int pciirqnrs[PCINUMPINS] = {1, 2, 3, 4}; qemuirq **irqs, *mpic; DeviceState *dev; CPUPPCState *firstenv = NULL; MemoryRegion *ccsraddrspace; SysBusDevice *s; PPCE500CCSRState *ccsr; /* Setup CPUs */ if (machine->cpumodel == NULL) { machine->cpumodel = \"e500v2v30\"; } irqs = gmalloc0(smpcpus * sizeof(qemuirq *)); irqs[0] = gmalloc0(smpcpus * sizeof(qemuirq) * OPENPICOUTPUTNB); for (i = 0; i < smpcpus; i++) { PowerPCCPU *cpu; CPUState *cs; qemuirq *input; cpu = cpuppcinit(machine->cpumodel); if (cpu == NULL) { fprintf(stderr, \"Unable to initialize CPU!\\n\"); exit(1); } env = &cpu->env; cs = CPU(cpu); if (!firstenv) { firstenv = env; } irqs[i] = irqs[0] + (i * OPENPICOUTPUTNB); input = (qemuirq *)env->irqinputs; irqs[i][OPENPICOUTPUTINT] = input[PPCE500INPUTINT]; irqs[i][OPENPICOUTPUTCINT] = input[PPCE500INPUTCINT]; env->sprcb[SPRBOOKEPIR].defaultvalue = cs->cpuindex = i; env->mpiciack = params->ccsrbarbase + MPC8544MPICREGSOFFSET + 0xa0; ppcbooketimersinit(cpu, 400000000, PPCTIMERE500); /* Register reset handler */ if (!i) { /* Primary CPU */ struct bootinfo *bootinfo; bootinfo = gmalloc0(sizeof(struct bootinfo)); qemuregisterreset(ppce500cpureset, cpu); env->loadinfo = bootinfo; } else { /* Secondary CPUs */ qemuregisterreset(ppce500cpuresetsec, cpu); } } env = firstenv; /* Fixup Memory size on a alignment boundary */ ramsize &= ~(RAMSIZESALIGN - 1); machine->ramsize = ramsize; /* Register Memory */ memoryregionallocatesystemmemory(ram, NULL, \"mpc8544ds.ram\", ramsize); memoryregionaddsubregion(addressspacemem, 0, ram); dev = qdevcreate(NULL, \"e500-ccsr\"); objectpropertyaddchild(qdevgetmachine(), \"e500-ccsr\", OBJECT(dev), NULL); qdevinitnofail(dev); ccsr = CCSR(dev); ccsraddrspace = &ccsr->ccsrspace; memoryregionaddsubregion(addressspacemem, params->ccsrbarbase, ccsraddrspace); mpic = ppce500initmpic(params, ccsraddrspace, irqs); /* Serial */ if (serialhds[0]) { serialmminit(ccsraddrspace, MPC8544SERIAL0REGSOFFSET, 0, mpic[42], 399193, serialhds[0], DEVICEBIGENDIAN); } if (serialhds[1]) { serialmminit(ccsraddrspace, MPC8544SERIAL1REGSOFFSET, 0, mpic[42], 399193, serialhds[1], DEVICEBIGENDIAN); } /* General Utility device */ dev = qdevcreate(NULL, \"mpc8544-guts\"); qdevinitnofail(dev); s = SYSBUSDEVICE(dev); memoryregionaddsubregion(ccsraddrspace, MPC8544UTILOFFSET, sysbusmmiogetregion(s, 0)); /* PCI */ dev = qdevcreate(NULL, \"e500-pcihost\"); qdevpropsetuint32(dev, \"firstslot\", params->pcifirstslot); qdevpropsetuint32(dev, \"firstpinirq\", pciirqnrs[0]); qdevinitnofail(dev); s = SYSBUSDEVICE(dev); for (i = 0; i < PCINUMPINS; i++) { sysbusconnectirq(s, i, mpic[pciirqnrs[i]]); } memoryregionaddsubregion(ccsraddrspace, MPC8544PCIREGSOFFSET, sysbusmmiogetregion(s, 0)); pcibus = (PCIBus *)qdevgetchildbus(dev, \"pci.0\"); if (!pcibus) printf(\"couldn't create PCI controller!\\n\"); if (pcibus) { /* Register network interfaces. */ for (i = 0; i < nbnics; i++) { pcinicinitnofail(&ndtable[i], pcibus, \"virtio\", NULL); } } /* Register spinning region */ sysbuscreatesimple(\"e500-spin\", params->spinbase, NULL); if (curbase < (32 * 1024 * 1024)) { /* u-boot occupies memory up to 32MB, so load blobs above */ curbase = (32 * 1024 * 1024); } if (params->hasmpc8xxxgpio) { qemuirq poweroffirq; dev = qdevcreate(NULL, \"mpc8xxxgpio\"); s = SYSBUSDEVICE(dev); qdevinitnofail(dev); sysbusconnectirq(s, 0, mpic[MPC8XXXGPIOIRQ]); memoryregionaddsubregion(ccsraddrspace, MPC8XXXGPIOOFFSET, sysbusmmiogetregion(s, 0)); /* Power Off GPIO at Pin 0 */ poweroffirq = qemuallocateirq(ppce500poweroff, NULL, 0); qdevconnectgpioout(dev, 0, poweroffirq); } /* Platform Bus Device */ if (params->hasplatformbus) { dev = qdevcreate(NULL, TYPEPLATFORMBUSDEVICE); dev->id = TYPEPLATFORMBUSDEVICE; qdevpropsetuint32(dev, \"numirqs\", params->platformbusnumirqs); qdevpropsetuint32(dev, \"mmiosize\", params->platformbussize); qdevinitnofail(dev); s = SYSBUSDEVICE(dev); for (i = 0; i < params->platformbusnumirqs; i++) { int irqn = params->platformbusfirstirq + i; sysbusconnectirq(s, i, mpic[irqn]); } memoryregionaddsubregion(addressspacemem, params->platformbusbase, sysbusmmiogetregion(s, 0)); } /* Load kernel. */ if (machine->kernelfilename) { kernelbase = curbase; kernelsize = loadimagetargphys(machine->kernelfilename, curbase, ramsize - curbase); if (kernelsize < 0) { fprintf(stderr, \"qemu: could not load kernel '%s'\\n\", machine->kernelfilename); exit(1); } curbase += kernelsize; } /* Load initrd. */ if (machine->initrdfilename) { initrdbase = (curbase + INITRDLOADPAD) & ~INITRDPADMASK; initrdsize = loadimagetargphys(machine->initrdfilename, initrdbase, ramsize - initrdbase); if (initrdsize < 0) { fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\", machine->initrdfilename); exit(1); } curbase = initrdbase + initrdsize; } /* * Smart firmware defaults ahead! * * We follow the following table to select which payload we execute. * * -kernel | -bios | payload * ---------+-------+--------- * N | Y | u-boot * N | N | u-boot * Y | Y | u-boot * Y | N | kernel * * This ensures backwards compatibility with how we used to expose * -kernel to users but allows them to run through u-boot as well. */ if (biosname == NULL) { if (machine->kernelfilename) { biosname = machine->kernelfilename; } else { biosname = \"u-boot.e500\"; } } filename = qemufindfile(QEMUFILETYPEBIOS, biosname); biossize = loadelf(filename, NULL, NULL, &biosentry, &loadaddr, NULL, 1, ELFMACHINE, 0); if (biossize < 0) { /* * Hrm. No ELF image? Try a uImage, maybe someone is giving us an * ePAPR compliant kernel */ kernelsize = loaduimage(filename, &biosentry, &loadaddr, NULL, NULL, NULL); if (kernelsize < 0) { fprintf(stderr, \"qemu: could not load firmware '%s'\\n\", filename); exit(1); } } /* Reserve space for dtb */ dtbase = (loadaddr + biossize + DTCLOADPAD) & ~DTCPADMASK; dtsize = ppce500prepdevicetree(machine, params, dtbase, initrdbase, initrdsize, kernelbase, kernelsize); if (dtsize < 0) { fprintf(stderr, \"couldn't load device tree\\n\"); exit(1); } assert(dtsize < DTBMAXSIZE); bootinfo = env->loadinfo; bootinfo->entry = biosentry; bootinfo->dtbase = dtbase; bootinfo->dtsize = dtsize; if (kvmenabled()) { kvmppcinit(); } } ", "target": 1}
{"func": "static avalwaysinline int coeffabslevelremainingdecode(HEVCContext *s, int rcriceparam) { int prefix = 0; int suffix = 0; int lastcoeffabslevelremaining; int i; while (prefix < CABACMAXBIN && getcabacbypass(&s->HEVClc->cc)) prefix++; if (prefix < 3) { for (i = 0; i < rcriceparam; i++) suffix = (suffix << 1) | getcabacbypass(&s->HEVClc->cc); lastcoeffabslevelremaining = (prefix << rcriceparam) + suffix; } else { int prefixminus3 = prefix - 3; if (prefix == CABACMAXBIN) { avlog(s->avctx, AVLOGERROR, \"CABACMAXBIN : %d\\n\", prefix); return 0; } for (i = 0; i < prefixminus3 + rcriceparam; i++) suffix = (suffix << 1) | getcabacbypass(&s->HEVClc->cc); lastcoeffabslevelremaining = (((1 << prefixminus3) + 3 - 1) << rcriceparam) + suffix; } return lastcoeffabslevelremaining; } ", "target": 1}
{"func": "static int segmenthlswindow(AVFormatContext *s, int last) { SegmentContext *seg = s->privdata; int i, ret = 0; char buf[1024]; if ((ret = avioopen2(&seg->pb, seg->list, AVIOFLAGWRITE, &s->interruptcallback, NULL)) < 0) goto fail; avioprintf(seg->pb, \"#EXTM3U\\n\"); avioprintf(seg->pb, \"#EXT-X-VERSION:3\\n\"); avioprintf(seg->pb, \"#EXT-X-TARGETDURATION:%d\\n\", (int)seg->time); avioprintf(seg->pb, \"#EXT-X-MEDIA-SEQUENCE:%d\\n\", FFMAX(0, seg->number - seg->size)); avlog(s, AVLOGVERBOSE, \"EXT-X-MEDIA-SEQUENCE:%d\\n\", FFMAX(0, seg->number - seg->size)); for (i = FFMAX(0, seg->number - seg->size); i < seg->number; i++) { avioprintf(seg->pb, \"#EXTINF:%d,\\n\", (int)seg->time); if (seg->entryprefix) { avioprintf(seg->pb, \"%s\", seg->entryprefix); } ret = avgetframefilename(buf, sizeof(buf), s->filename, i); if (ret < 0) { ret = AVERROR(EINVAL); goto fail; } avioprintf(seg->pb, \"%s\\n\", buf); } if (last) avioprintf(seg->pb, \"#EXT-X-ENDLIST\\n\"); fail: avioclosep(&seg->pb); return ret; } ", "target": 0}
{"func": "static inline int crisaddcpim(int a, int **b) { \tasm volatile (\"addc [%1+], %0\\n\" : \"+r\" (a), \"+b\" (*b)); \treturn a; } ", "target": 1}
{"func": "static void vmgenidquerymonitortest(void) { QemuUUID expected, measured; gchar *cmd; gassert(qemuuuidparse(VGIDGUID, &expected) == 0); cmd = gstrdupprintf(\"-machine accel=tcg -device vmgenid,id=testvgid,\" \"guid=%s\", VGIDGUID); qteststart(cmd); /* Read the GUID via the monitor */ readguidfrommonitor(&measured); gassert(memcmp(measured.data, expected.data, sizeof(measured.data)) == 0); qtestquit(globalqtest); gfree(cmd); } ", "target": 1}
{"func": "static int decodeframebyterun1(AVCodecContext *avctx, void *data, int *datasize, AVPacket *avpkt) { IffContext *s = avctx->privdata; const uint8t *buf = avpkt->size >= 2 ? avpkt->data + AVRB16(avpkt->data) : NULL; const int bufsize = avpkt->size >= 2 ? avpkt->size - AVRB16(avpkt->data) : 0; const uint8t *bufend = buf+bufsize; int y, plane, res; if ((res = extractheader(avctx, avpkt)) < 0) return res; if (s->init) { if ((res = avctx->regetbuffer(avctx, &s->frame)) < 0) { avlog(avctx, AVLOGERROR, \"regetbuffer() failed\\n\"); return res; } } else if ((res = avctx->getbuffer(avctx, &s->frame)) < 0) { avlog(avctx, AVLOGERROR, \"getbuffer() failed\\n\"); return res; } else if (avctx->bitspercodedsample <= 8 && avctx->pixfmt != PIXFMTGRAY8) { if ((res = ffcmapreadpalette(avctx, (uint32t*)s->frame.data[1])) < 0) return res; } s->init = 1; if (avctx->codectag == MKTAG('I','L','B','M')) { //interleaved if (avctx->pixfmt == PIXFMTPAL8 || avctx->pixfmt == PIXFMTGRAY8) { for(y = 0; y < avctx->height ; y++ ) { uint8t *row = &s->frame.data[0][ y*s->frame.linesize[0] ]; memset(row, 0, avctx->width); for (plane = 0; plane < s->bpp; plane++) { buf += decodebyterun(s->planebuf, s->planesize, buf, bufend); decodeplane8(row, s->planebuf, s->planesize, plane); } } } else if (s->ham) { // HAM to PIXFMTBGR32 for (y = 0; y < avctx->height ; y++) { uint8t *row = &s->frame.data[0][y*s->frame.linesize[0]]; memset(s->hambuf, 0, avctx->width); for (plane = 0; plane < s->bpp; plane++) { buf += decodebyterun(s->planebuf, s->planesize, buf, bufend); decodeplane8(s->hambuf, s->planebuf, s->planesize, plane); } decodehamplane32((uint32t *) row, s->hambuf, s->hampalbuf, s->planesize); } } else { //PIXFMTBGR32 for(y = 0; y < avctx->height ; y++ ) { uint8t *row = &s->frame.data[0][y*s->frame.linesize[0]]; memset(row, 0, avctx->width << 2); for (plane = 0; plane < s->bpp; plane++) { buf += decodebyterun(s->planebuf, s->planesize, buf, bufend); decodeplane32((uint32t *) row, s->planebuf, s->planesize, plane); } } } } else if (avctx->pixfmt == PIXFMTPAL8 || avctx->pixfmt == PIXFMTGRAY8) { // IFF-PBM for(y = 0; y < avctx->height ; y++ ) { uint8t *row = &s->frame.data[0][y*s->frame.linesize[0]]; buf += decodebyterun(row, avctx->width, buf, bufend); } } else { // IFF-PBM: HAM to PIXFMTBGR32 for (y = 0; y < avctx->height ; y++) { uint8t *row = &s->frame.data[0][y*s->frame.linesize[0]]; buf += decodebyterun(s->hambuf, avctx->width, buf, bufend); decodehamplane32((uint32t *) row, s->hambuf, s->hampalbuf, avctx->width); } } *datasize = sizeof(AVFrame); *(AVFrame*)data = s->frame; return bufsize; } ", "target": 1}
{"func": "int allocpicture(MpegEncContext *s, Picture *pic, int shared){ const int bigmbnum= s->mbstride*(s->mbheight+1) + 1; //the +1 is needed so memset(,,stride*height) does not sig11 const int mbarraysize= s->mbstride*s->mbheight; const int b8arraysize= s->b8stride*s->mbheight*2; const int b4arraysize= s->b4stride*s->mbheight*4; int i; if(shared){ assert(pic->data[0]); assert(pic->type == 0 || pic->type == FFBUFFERTYPESHARED); pic->type= FFBUFFERTYPESHARED; }else{ int r; assert(!pic->data[0]); r= s->avctx->getbuffer(s->avctx, (AVFrame*)pic); if(r<0 || !pic->age || !pic->type || !pic->data[0]){ avlog(s->avctx, AVLOGERROR, \"getbuffer() failed (%d %d %d %p)\\n\", r, pic->age, pic->type, pic->data[0]); return -1; } if(s->linesize && (s->linesize != pic->linesize[0] || s->uvlinesize != pic->linesize[1])){ avlog(s->avctx, AVLOGERROR, \"getbuffer() failed (stride changed)\\n\"); return -1; } if(pic->linesize[1] != pic->linesize[2]){ avlog(s->avctx, AVLOGERROR, \"getbuffer() failed (uv stride mismatch)\\n\"); return -1; } s->linesize = pic->linesize[0]; s->uvlinesize= pic->linesize[1]; } if(pic->qscaletable==NULL){ if (s->encoding) { CHECKEDALLOCZ(pic->mbvar , mbarraysize * sizeof(int16t)) CHECKEDALLOCZ(pic->mcmbvar, mbarraysize * sizeof(int16t)) CHECKEDALLOCZ(pic->mbmean , mbarraysize * sizeof(int8t)) } CHECKEDALLOCZ(pic->mbskiptable , mbarraysize * sizeof(uint8t)+2) //the +2 is for the slice end check CHECKEDALLOCZ(pic->qscaletable , mbarraysize * sizeof(uint8t)) CHECKEDALLOCZ(pic->mbtypebase , bigmbnum * sizeof(uint32t)) pic->mbtype= pic->mbtypebase + s->mbstride+1; if(s->outformat == FMTH264){ for(i=0; i<2; i++){ CHECKEDALLOCZ(pic->motionvalbase[i], 2 * (b4arraysize+4) * sizeof(int16t)) pic->motionval[i]= pic->motionvalbase[i]+4; CHECKEDALLOCZ(pic->refindex[i], b8arraysize * sizeof(uint8t)) } pic->motionsubsamplelog2= 2; }else if(s->outformat == FMTH263 || s->encoding || (s->avctx->debug&FFDEBUGMV) || (s->avctx->debugmv)){ for(i=0; i<2; i++){ CHECKEDALLOCZ(pic->motionvalbase[i], 2 * (b8arraysize+4) * sizeof(int16t)) pic->motionval[i]= pic->motionvalbase[i]+4; CHECKEDALLOCZ(pic->refindex[i], b8arraysize * sizeof(uint8t)) } pic->motionsubsamplelog2= 3; } if(s->avctx->debug&FFDEBUGDCTCOEFF) { CHECKEDALLOCZ(pic->dctcoeff, 64 * mbarraysize * sizeof(DCTELEM)*6) } pic->qstride= s->mbstride; CHECKEDALLOCZ(pic->panscan , 1 * sizeof(AVPanScan)) } /* It might be nicer if the application would keep track of these * but it would require an API change. */ memmove(s->prevpicttypes+1, s->prevpicttypes, PREVPICTTYPESBUFFERSIZE-1); s->prevpicttypes[0]= s->picttype; if(pic->age < PREVPICTTYPESBUFFERSIZE && s->prevpicttypes[pic->age] == BTYPE) pic->age= INTMAX; // Skipped MBs in B-frames are quite rare in MPEG-1/2 and it is a bit tricky to skip them anyway. return 0; fail: //for the CHECKEDALLOCZ macro return -1; } ", "target": 1}
{"func": "static int decodepichdr(IVI5DecContext *ctx, AVCodecContext *avctx) { if (getbits(&ctx->gb, 5) != 0x1F) { avlog(avctx, AVLOGERROR, \"Invalid picture start code!\\n\"); return -1; ctx->prevframetype = ctx->frametype; ctx->frametype = getbits(&ctx->gb, 3); if (ctx->frametype >= 5) { avlog(avctx, AVLOGERROR, \"Invalid frame type: %d \\n\", ctx->frametype); return -1; ctx->framenum = getbits(&ctx->gb, 8); if (ctx->frametype == FRAMETYPEINTRA) { ctx->gopinvalid = 1; if (decodegopheader(ctx, avctx)) return -1; ctx->gopinvalid = 0; if (ctx->frametype != FRAMETYPENULL) { ctx->frameflags = getbits(&ctx->gb, 8); ctx->pichdrsize = (ctx->frameflags & 1) ? getbitslong(&ctx->gb, 24) : 0; ctx->checksum = (ctx->frameflags & 0x10) ? getbits(&ctx->gb, 16) : 0; /* skip unknown extension if any */ if (ctx->frameflags & 0x20) skiphdrextension(&ctx->gb); /* XXX: untested */ /* decode macroblock huffman codebook */ if (ffividechuffdesc(&ctx->gb, ctx->frameflags & 0x40, IVIMBHUFF, &ctx->mbvlc, avctx)) return -1; skipbits(&ctx->gb, 3); /* FIXME: unknown meaning! */ aligngetbits(&ctx->gb); return 0;", "target": 1}
{"func": "static int mpegtswriteheader(AVFormatContext *s) { MpegTSWrite *ts = s->privdata; MpegTSWriteStream *tsst; MpegTSService *service; AVStream *st, *pcrst = NULL; AVDictionaryEntry *title, *provider; int i, j; const char *servicename; const char *providername; int *pids; int ret; if (s->maxdelay < 0) /* Not set by the caller */ s->maxdelay = 0; // round up to a whole number of TS packets ts->pespayloadsize = (ts->pespayloadsize + 14 + 183) / 184 * 184 - 14; ts->tsid = ts->transportstreamid; ts->onid = ts->originalnetworkid; /* allocate a single DVB service */ title = avdictget(s->metadata, \"servicename\", NULL, 0); if (!title) title = avdictget(s->metadata, \"title\", NULL, 0); servicename = title ? title->value : DEFAULTSERVICENAME; provider = avdictget(s->metadata, \"serviceprovider\", NULL, 0); providername = provider ? provider->value : DEFAULTPROVIDERNAME; service = mpegtsaddservice(ts, ts->serviceid, providername, servicename); if (!service) return AVERROR(ENOMEM); service->pmt.writepacket = sectionwritepacket; service->pmt.opaque = s; service->pmt.cc = 15; ts->pat.pid = PATPID; /* Initialize at 15 so that it wraps and is equal to 0 for the * first packet we write. */ ts->pat.cc = 15; ts->pat.writepacket = sectionwritepacket; ts->pat.opaque = s; ts->sdt.pid = SDTPID; ts->sdt.cc = 15; ts->sdt.writepacket = sectionwritepacket; ts->sdt.opaque = s; pids = avmallocarray(s->nbstreams, sizeof(*pids)); if (!pids) { ret = AVERROR(ENOMEM); goto fail; } /* assign pids to each stream */ for (i = 0; i < s->nbstreams; i++) { st = s->streams[i]; tsst = avmallocz(sizeof(MpegTSWriteStream)); if (!tsst) { ret = AVERROR(ENOMEM); goto fail; } st->privdata = tsst; tsst->usertb = st->timebase; avprivsetptsinfo(st, 33, 1, 90000); tsst->payload = avmallocz(ts->pespayloadsize); if (!tsst->payload) { ret = AVERROR(ENOMEM); goto fail; } tsst->service = service; /* MPEG pid values < 16 are reserved. Applications which set st->id in * this range are assigned a calculated pid. */ if (st->id < 16) { tsst->pid = ts->startpid + i; } else if (st->id < 0x1FFF) { tsst->pid = st->id; } else { avlog(s, AVLOGERROR, \"Invalid stream id %d, must be less than 8191\\n\", st->id); ret = AVERROR(EINVAL); goto fail; } if (tsst->pid == service->pmt.pid) { avlog(s, AVLOGERROR, \"Duplicate stream id %d\\n\", tsst->pid); ret = AVERROR(EINVAL); goto fail; } for (j = 0; j < i; j++) { if (pids[j] == tsst->pid) { avlog(s, AVLOGERROR, \"Duplicate stream id %d\\n\", tsst->pid); ret = AVERROR(EINVAL); goto fail; } } pids[i] = tsst->pid; tsst->payloadpts = AVNOPTSVALUE; tsst->payloaddts = AVNOPTSVALUE; tsst->firstptscheck = 1; tsst->cc = 15; /* update PCR pid by using the first video stream */ if (st->codec->codectype == AVMEDIATYPEVIDEO && service->pcrpid == 0x1fff) { service->pcrpid = tsst->pid; pcrst = st; } if (st->codec->codecid == AVCODECIDAAC && st->codec->extradatasize > 0) { AVStream *ast; tsst->amux = avformatalloccontext(); if (!tsst->amux) { ret = AVERROR(ENOMEM); goto fail; } tsst->amux->oformat = avguessformat((ts->flags & MPEGTSFLAGAACLATM) ? \"latm\" : \"adts\", NULL, NULL); if (!tsst->amux->oformat) { ret = AVERROR(EINVAL); goto fail; } if (!(ast = avformatnewstream(tsst->amux, NULL))) { ret = AVERROR(ENOMEM); goto fail; } ret = avcodeccopycontext(ast->codec, st->codec); if (ret != 0) goto fail; ast->timebase = st->timebase; ret = avformatwriteheader(tsst->amux, NULL); if (ret < 0) goto fail; } if (st->codec->codecid == AVCODECIDOPUS) { tsst->opuspendingtrimstart = st->codec->initialpadding * 48000 / st->codec->samplerate; } } avfreep(&pids); /* if no video stream, use the first stream as PCR */ if (service->pcrpid == 0x1fff && s->nbstreams > 0) { pcrst = s->streams[0]; tsst = pcrst->privdata; service->pcrpid = tsst->pid; } else tsst = pcrst->privdata; if (ts->muxrate > 1) { service->pcrpacketperiod = (ts->muxrate * ts->pcrperiod) / (TSPACKETSIZE * 8 * 1000); ts->sdtpacketperiod = (ts->muxrate * SDTRETRANSTIME) / (TSPACKETSIZE * 8 * 1000); ts->patpacketperiod = (ts->muxrate * PATRETRANSTIME) / (TSPACKETSIZE * 8 * 1000); if (ts->copyts < 1) ts->firstpcr = avrescale(s->maxdelay, PCRTIMEBASE, AVTIMEBASE); } else { /* Arbitrary values, PAT/PMT will also be written on video key frames */ ts->sdtpacketperiod = 200; ts->patpacketperiod = 40; if (pcrst->codec->codectype == AVMEDIATYPEAUDIO) { if (!pcrst->codec->framesize) { avlog(s, AVLOGWARNING, \"frame size not set\\n\"); service->pcrpacketperiod = pcrst->codec->samplerate / (10 * 512); } else { service->pcrpacketperiod = pcrst->codec->samplerate / (10 * pcrst->codec->framesize); } } else { // max delta PCR 0.1s // TODO: should be avgframerate service->pcrpacketperiod = tsst->usertb.den / (10 * tsst->usertb.num); } if (!service->pcrpacketperiod) service->pcrpacketperiod = 1; } ts->lastpatts = AVNOPTSVALUE; ts->lastsdtts = AVNOPTSVALUE; // The user specified a period, use only it if (ts->patperiod < INTMAX/2) { ts->patpacketperiod = INTMAX; } if (ts->sdtperiod < INTMAX/2) { ts->sdtpacketperiod = INTMAX; } // output a PCR as soon as possible service->pcrpacketcount = service->pcrpacketperiod; ts->patpacketcount = ts->patpacketperiod - 1; ts->sdtpacketcount = ts->sdtpacketperiod - 1; if (ts->muxrate == 1) avlog(s, AVLOGVERBOSE, \"muxrate VBR, \"); else avlog(s, AVLOGVERBOSE, \"muxrate %d, \", ts->muxrate); avlog(s, AVLOGVERBOSE, \"pcr every %d pkts, sdt every %d, pat/pmt every %d pkts\\n\", service->pcrpacketperiod, ts->sdtpacketperiod, ts->patpacketperiod); if (ts->m2tsmode == -1) { if (avmatchext(s->filename, \"m2ts\")) { ts->m2tsmode = 1; } else { ts->m2tsmode = 0; } } return 0; fail: avfreep(&pids); for (i = 0; i < s->nbstreams; i++) { st = s->streams[i]; tsst = st->privdata; if (tsst) { avfreep(&tsst->payload); if (tsst->amux) { avformatfreecontext(tsst->amux); tsst->amux = NULL; } } avfreep(&st->privdata); } for (i = 0; i < ts->nbservices; i++) { service = ts->services[i]; avfreep(&service->providername); avfreep(&service->name); avfreep(&service); } avfreep(&ts->services); return ret; } ", "target": 1}
{"func": "void dct32(INTFLOAT *out, const INTFLOAT *tab) { INTFLOAT tmp0, tmp1; INTFLOAT val0 , val1 , val2 , val3 , val4 , val5 , val6 , val7 , val8 , val9 , val10, val11, val12, val13, val14, val15, val16, val17, val18, val19, val20, val21, val22, val23, val24, val25, val26, val27, val28, val29, val30, val31; /* pass 1 */ BF0( 0, 31, COS00 , 1); BF0(15, 16, COS015, 5); /* pass 2 */ BF( 0, 15, COS10 , 1); BF(16, 31,-COS10 , 1); /* pass 1 */ BF0( 7, 24, COS07 , 1); BF0( 8, 23, COS08 , 1); /* pass 2 */ BF( 7, 8, COS17 , 4); BF(23, 24,-COS17 , 4); /* pass 3 */ BF( 0, 7, COS20 , 1); BF( 8, 15,-COS20 , 1); BF(16, 23, COS20 , 1); BF(24, 31,-COS20 , 1); /* pass 1 */ BF0( 3, 28, COS03 , 1); BF0(12, 19, COS012, 2); /* pass 2 */ BF( 3, 12, COS13 , 1); BF(19, 28,-COS13 , 1); /* pass 1 */ BF0( 4, 27, COS04 , 1); BF0(11, 20, COS011, 2); /* pass 2 */ BF( 4, 11, COS14 , 1); BF(20, 27,-COS14 , 1); /* pass 3 */ BF( 3, 4, COS23 , 3); BF(11, 12,-COS23 , 3); BF(19, 20, COS23 , 3); BF(27, 28,-COS23 , 3); /* pass 4 */ BF( 0, 3, COS30 , 1); BF( 4, 7,-COS30 , 1); BF( 8, 11, COS30 , 1); BF(12, 15,-COS30 , 1); BF(16, 19, COS30 , 1); BF(20, 23,-COS30 , 1); BF(24, 27, COS30 , 1); BF(28, 31,-COS30 , 1); /* pass 1 */ BF0( 1, 30, COS01 , 1); BF0(14, 17, COS014, 3); /* pass 2 */ BF( 1, 14, COS11 , 1); BF(17, 30,-COS11 , 1); /* pass 1 */ BF0( 6, 25, COS06 , 1); BF0( 9, 22, COS09 , 1); /* pass 2 */ BF( 6, 9, COS16 , 2); BF(22, 25,-COS16 , 2); /* pass 3 */ BF( 1, 6, COS21 , 1); BF( 9, 14,-COS21 , 1); BF(17, 22, COS21 , 1); BF(25, 30,-COS21 , 1); /* pass 1 */ BF0( 2, 29, COS02 , 1); BF0(13, 18, COS013, 3); /* pass 2 */ BF( 2, 13, COS12 , 1); BF(18, 29,-COS12 , 1); /* pass 1 */ BF0( 5, 26, COS05 , 1); BF0(10, 21, COS010, 1); /* pass 2 */ BF( 5, 10, COS15 , 2); BF(21, 26,-COS15 , 2); /* pass 3 */ BF( 2, 5, COS22 , 1); BF(10, 13,-COS22 , 1); BF(18, 21, COS22 , 1); BF(26, 29,-COS22 , 1); /* pass 4 */ BF( 1, 2, COS31 , 2); BF( 5, 6,-COS31 , 2); BF( 9, 10, COS31 , 2); BF(13, 14,-COS31 , 2); BF(17, 18, COS31 , 2); BF(21, 22,-COS31 , 2); BF(25, 26, COS31 , 2); BF(29, 30,-COS31 , 2); /* pass 5 */ BF1( 0, 1, 2, 3); BF2( 4, 5, 6, 7); BF1( 8, 9, 10, 11); BF2(12, 13, 14, 15); BF1(16, 17, 18, 19); BF2(20, 21, 22, 23); BF1(24, 25, 26, 27); BF2(28, 29, 30, 31); /* pass 6 */ ADD( 8, 12); ADD(12, 10); ADD(10, 14); ADD(14, 9); ADD( 9, 13); ADD(13, 11); ADD(11, 15); out[ 0] = val0; out[16] = val1; out[ 8] = val2; out[24] = val3; out[ 4] = val4; out[20] = val5; out[12] = val6; out[28] = val7; out[ 2] = val8; out[18] = val9; out[10] = val10; out[26] = val11; out[ 6] = val12; out[22] = val13; out[14] = val14; out[30] = val15; ADD(24, 28); ADD(28, 26); ADD(26, 30); ADD(30, 25); ADD(25, 29); ADD(29, 27); ADD(27, 31); out[ 1] = val16 + val24; out[17] = val17 + val25; out[ 9] = val18 + val26; out[25] = val19 + val27; out[ 5] = val20 + val28; out[21] = val21 + val29; out[13] = val22 + val30; out[29] = val23 + val31; out[ 3] = val24 + val20; out[19] = val25 + val21; out[11] = val26 + val22; out[27] = val27 + val23; out[ 7] = val28 + val18; out[23] = val29 + val19; out[15] = val30 + val17; out[31] = val31; } ", "target": 1}
{"func": "static inline void genopmovlsegT0vm(int segreg) { tcggenanditl(cpuT[0], cpuT[0], 0xffff); tcggenst32tl(cpuT[0], cpuenv, offsetof(CPUX86State,segs[segreg].selector)); tcggenshlitl(cpuT[0], cpuT[0], 4); tcggensttl(cpuT[0], cpuenv, offsetof(CPUX86State,segs[segreg].base)); } ", "target": 0}
{"func": "static void vc1voverlapc(uint8t* src, int stride) { int i; int a, b, c, d; int d1, d2; int rnd = 1; for(i = 0; i < 8; i++) { a = src[-2*stride]; b = src[-stride]; c = src[0]; d = src[stride]; d1 = (a - d + 3 + rnd) >> 3; d2 = (a - d + b - c + 4 - rnd) >> 3; src[-2*stride] = a - d1; src[-stride] = b - d2; src[0] = c + d2; src[stride] = d + d1; src++; rnd = !rnd; } } ", "target": 1}
{"func": "void qvirtiopcisetmsixconfigurationvector(QVirtioPCIDevice *d, QGuestAllocator *alloc, uint16t entry) { uint16t vector; uint32t control; void *addr; gassert(d->pdev->msixenabled); addr = d->pdev->msixtable + (entry * 16); gassertcmpint(entry, >=, 0); gassertcmpint(entry, <, qpcimsixtablesize(d->pdev)); d->configmsixentry = entry; d->configmsixdata = 0x12345678; d->configmsixaddr = guestalloc(alloc, 4); qpciiowritel(d->pdev, addr + PCIMSIXENTRYLOWERADDR, d->configmsixaddr & ~0UL); qpciiowritel(d->pdev, addr + PCIMSIXENTRYUPPERADDR, (d->configmsixaddr >> 32) & ~0UL); qpciiowritel(d->pdev, addr + PCIMSIXENTRYDATA, d->configmsixdata); control = qpciioreadl(d->pdev, addr + PCIMSIXENTRYVECTORCTRL); qpciiowritel(d->pdev, addr + PCIMSIXENTRYVECTORCTRL, control & ~PCIMSIXENTRYCTRLMASKBIT); qpciiowritew(d->pdev, d->addr + VIRTIOMSICONFIGVECTOR, entry); vector = qpciioreadw(d->pdev, d->addr + VIRTIOMSICONFIGVECTOR); gassertcmphex(vector, !=, VIRTIOMSINOVECTOR); } ", "target": 1}
{"func": "static void genrdhwr(DisasContext *ctx, int rt, int rd) { TCGv t0; #if !defined(CONFIGUSERONLY) /* The Linux kernel will emulate rdhwr if it's not supported natively. Therefore only check the ISA in system mode. */ checkinsn(ctx, ISAMIPS32R2); #endif t0 = tcgtempnew(); switch (rd) { case 0: savecpustate(ctx, 1); genhelperrdhwrcpunum(t0, cpuenv); genstoregpr(t0, rt); break; case 1: savecpustate(ctx, 1); genhelperrdhwrsyncistep(t0, cpuenv); genstoregpr(t0, rt); break; case 2: savecpustate(ctx, 1); genhelperrdhwrcc(t0, cpuenv); genstoregpr(t0, rt); break; case 3: savecpustate(ctx, 1); genhelperrdhwrccres(t0, cpuenv); genstoregpr(t0, rt); break; case 29: #if defined(CONFIGUSERONLY) tcggenldtl(t0, cpuenv, offsetof(CPUMIPSState, tlsvalue)); genstoregpr(t0, rt); break; #else /* XXX: Some CPUs implement this in hardware. Not supported yet. */ #endif default: /* Invalid */ MIPSINVAL(\"rdhwr\"); generateexception(ctx, EXCPRI); break; } tcgtempfree(t0); } ", "target": 1}
{"func": "static void usbmsdrealizebot(USBDevice *dev, Error **errp) { MSDState *s = DOUPCAST(MSDState, dev, dev); usbdesccreateserial(dev); usbdescinit(dev); scsibusnew(&s->bus, sizeof(s->bus), DEVICE(dev), &usbmsdscsiinfobot, NULL); s->bus.qbus.allowhotplug = 0; usbmsdhandlereset(dev); } ", "target": 1}
{"func": "static int decodesliceheader(FFV1Context *f, FFV1Context *fs) { RangeCoder *c = &fs->c; uint8t state[CONTEXTSIZE]; unsigned ps, i, contextcount; memset(state, 128, sizeof(state)); if (fs->ac > 1) { for (i = 1; i < 256; i++) { fs->c.onestate[i] = f->statetransition[i]; fs->c.zerostate[256 - i] = 256 - fs->c.onestate[i]; } } fs->slicex = getsymbol(c, state, 0) * f->width; fs->slicey = getsymbol(c, state, 0) * f->height; fs->slicewidth = (getsymbol(c, state, 0) + 1) * f->width + fs->slicex; fs->sliceheight = (getsymbol(c, state, 0) + 1) * f->height + fs->slicey; fs->slicex /= f->numhslices; fs->slicey /= f->numvslices; fs->slicewidth = fs->slicewidth / f->numhslices - fs->slicex; fs->sliceheight = fs->sliceheight / f->numvslices - fs->slicey; if ((unsigned)fs->slicewidth > f->width || (unsigned)fs->sliceheight > f->height) return AVERRORINVALIDDATA; if ((unsigned)fs->slicex + (uint64t)fs->slicewidth > f->width || (unsigned)fs->slicey + (uint64t)fs->sliceheight > f->height) return AVERRORINVALIDDATA; for (i = 0; i < f->planecount; i++) { PlaneContext *const p = &fs->plane[i]; int idx = getsymbol(c, state, 0); if (idx > (unsigned)f->quanttablecount) { avlog(f->avctx, AVLOGERROR, \"quanttableindex out of range\\n\"); return AVERRORINVALIDDATA; } p->quanttableindex = idx; memcpy(p->quanttable, f->quanttables[idx], sizeof(p->quanttable)); contextcount = f->contextcount[idx]; if (p->contextcount < contextcount) { avfreep(&p->state); avfreep(&p->vlcstate); } p->contextcount = contextcount; } ps = getsymbol(c, state, 0); if (ps == 1) { f->cur->interlacedframe = 1; f->cur->topfieldfirst = 1; } else if (ps == 2) { f->cur->interlacedframe = 1; f->cur->topfieldfirst = 0; } else if (ps == 3) { f->cur->interlacedframe = 0; } f->cur->sampleaspectratio.num = getsymbol(c, state, 0); f->cur->sampleaspectratio.den = getsymbol(c, state, 0); if (avimagechecksar(f->width, f->height, f->cur->sampleaspectratio) < 0) { avlog(f->avctx, AVLOGWARNING, \"ignoring invalid SAR: %u/%u\\n\", f->cur->sampleaspectratio.num, f->cur->sampleaspectratio.den); f->cur->sampleaspectratio = (AVRational){ 0, 1 }; } return 0; } ", "target": 0}
{"func": "int kvmarchinsertswbreakpoint(CPUState *cs, struct kvmswbreakpoint *bp) { if (cpumemoryrwdebug(cs, bp->pc, (uint8t *)&bp->savedinsn, sizeof(diag501), 0) || cpumemoryrwdebug(cs, bp->pc, (uint8t *)diag501, sizeof(diag501), 1)) { return -EINVAL; } return 0; } ", "target": 1}
{"func": "static inline uint8t *ramchunkstart(const RDMALocalBlock *rdmaramblock, uint64t i) { return (uint8t *) (((uintptrt) rdmaramblock->localhostaddr) + (i << RDMAREGCHUNKSHIFT)); } ", "target": 1}
{"func": "static int decodeelement(AVCodecContext *avctx, void *data, int chindex, int channels) { ALACContext *alac = avctx->privdata; int hassize, bps, iscompressed, decorrshift, decorrleftweight, ret; uint32t outputsamples; int i, ch; skipbits(&alac->gb, 4); /* element instance tag */ skipbits(&alac->gb, 12); /* unused header bits */ /* the number of output samples is stored in the frame */ hassize = getbits1(&alac->gb); alac->extrabits = getbits(&alac->gb, 2) << 3; bps = alac->samplesize - alac->extrabits + channels - 1; if (bps > 32) { avlog(avctx, AVLOGERROR, \"bps is unsupported: %d\\n\", bps); return AVERRORPATCHWELCOME; } /* whether the frame is compressed */ iscompressed = !getbits1(&alac->gb); if (hassize) outputsamples = getbitslong(&alac->gb, 32); else outputsamples = alac->maxsamplesperframe; if (!outputsamples || outputsamples > alac->maxsamplesperframe) { avlog(avctx, AVLOGERROR, \"invalid samples per frame: %d\\n\", outputsamples); return AVERRORINVALIDDATA; } if (!alac->nbsamples) { /* get output buffer */ alac->frame.nbsamples = outputsamples; if ((ret = avctx->getbuffer(avctx, &alac->frame)) < 0) { avlog(avctx, AVLOGERROR, \"getbuffer() failed\\n\"); return ret; } } else if (outputsamples != alac->nbsamples) { avlog(avctx, AVLOGERROR, \"sample count mismatch: %u != %d\\n\", outputsamples, alac->nbsamples); return AVERRORINVALIDDATA; } alac->nbsamples = outputsamples; if (alac->directoutput) { for (ch = 0; ch < channels; ch++) alac->outputsamplesbuffer[ch] = (int32t *)alac->frame.extendeddata[chindex + ch]; } if (iscompressed) { int16t lpccoefs[2][32]; int lpcorder[2]; int predictiontype[2]; int lpcquant[2]; int ricehistorymult[2]; decorrshift = getbits(&alac->gb, 8); decorrleftweight = getbits(&alac->gb, 8); for (ch = 0; ch < channels; ch++) { predictiontype[ch] = getbits(&alac->gb, 4); lpcquant[ch] = getbits(&alac->gb, 4); ricehistorymult[ch] = getbits(&alac->gb, 3); lpcorder[ch] = getbits(&alac->gb, 5); /* read the predictor table */ for (i = lpcorder[ch] - 1; i >= 0; i--) lpccoefs[ch][i] = getsbits(&alac->gb, 16); } if (alac->extrabits) { for (i = 0; i < alac->nbsamples; i++) { if(getbitsleft(&alac->gb) <= 0) return -1; for (ch = 0; ch < channels; ch++) alac->extrabitsbuffer[ch][i] = getbits(&alac->gb, alac->extrabits); } } for (ch = 0; ch < channels; ch++) { int ret=ricedecompress(alac, alac->predicterrorbuffer[ch], alac->nbsamples, bps, ricehistorymult[ch] * alac->ricehistorymult / 4); if(ret<0) return ret; /* adaptive FIR filter */ if (predictiontype[ch] == 15) { /* Prediction type 15 runs the adaptive FIR twice. * The first pass uses the special-case coefnum = 31, while * the second pass uses the coefs from the bitstream. * * However, this prediction type is not currently used by the * reference encoder. */ lpcprediction(alac->predicterrorbuffer[ch], alac->predicterrorbuffer[ch], alac->nbsamples, bps, NULL, 31, 0); } else if (predictiontype[ch] > 0) { avlog(avctx, AVLOGWARNING, \"unknown prediction type: %i\\n\", predictiontype[ch]); } lpcprediction(alac->predicterrorbuffer[ch], alac->outputsamplesbuffer[ch], alac->nbsamples, bps, lpccoefs[ch], lpcorder[ch], lpcquant[ch]); } } else { /* not compressed, easy case */ for (i = 0; i < alac->nbsamples; i++) { if(getbitsleft(&alac->gb) <= 0) return -1; for (ch = 0; ch < channels; ch++) { alac->outputsamplesbuffer[ch][i] = getsbitslong(&alac->gb, alac->samplesize); } } alac->extrabits = 0; decorrshift = 0; decorrleftweight = 0; } if (channels == 2 && decorrleftweight) { decorrelatestereo(alac->outputsamplesbuffer, alac->nbsamples, decorrshift, decorrleftweight); } if (alac->extrabits) { appendextrabits(alac->outputsamplesbuffer, alac->extrabitsbuffer, alac->extrabits, channels, alac->nbsamples); } if(avsamplefmtisplanar(avctx->samplefmt)) { switch(alac->samplesize) { case 16: { for (ch = 0; ch < channels; ch++) { int16t *outbuffer = (int16t *)alac->frame.extendeddata[chindex + ch]; for (i = 0; i < alac->nbsamples; i++) *outbuffer++ = alac->outputsamplesbuffer[ch][i]; }} break; case 24: { for (ch = 0; ch < channels; ch++) { for (i = 0; i < alac->nbsamples; i++) alac->outputsamplesbuffer[ch][i] <<= 8; }} break; } }else{ switch(alac->samplesize) { case 16: { int16t *outbuffer = ((int16t *)alac->frame.extendeddata[0]) + chindex; for (i = 0; i < alac->nbsamples; i++) { for (ch = 0; ch < channels; ch++) *outbuffer++ = alac->outputsamplesbuffer[ch][i]; outbuffer += alac->channels - channels; } } break; case 24: { int32t *outbuffer = ((int32t *)alac->frame.extendeddata[0]) + chindex; for (i = 0; i < alac->nbsamples; i++) { for (ch = 0; ch < channels; ch++) *outbuffer++ = alac->outputsamplesbuffer[ch][i] << 8; outbuffer += alac->channels - channels; } } break; case 32: { int32t *outbuffer = ((int32t *)alac->frame.extendeddata[0]) + chindex; for (i = 0; i < alac->nbsamples; i++) { for (ch = 0; ch < channels; ch++) *outbuffer++ = alac->outputsamplesbuffer[ch][i]; outbuffer += alac->channels - channels; } } break; } } return 0; } ", "target": 0}
{"func": "static avalwaysinline float quantizeandencodebandcosttemplate( struct AACEncContext *s, PutBitContext *pb, const float *in, const float *scaled, int size, int scaleidx, int cb, const float lambda, const float uplim, int *bits, int BTZERO, int BTUNSIGNED, int BTPAIR, int BTESC) { const float IQ = ffaacpow2sftab[200 + scaleidx - SCALEONEPOS + SCALEDIV512]; const float Q = ffaacpow2sftab[200 - scaleidx + SCALEONEPOS - SCALEDIV512]; const float CLIPPEDESCAPE = 165140.0f*IQ; int i, j, k; float cost = 0; const int dim = BTPAIR ? 2 : 4; int resbits = 0; const float Q34 = sqrtf(Q * sqrtf(Q)); const int range = aaccbrange[cb]; const int maxval = aaccbmaxval[cb]; int off; if (BTZERO) { for (i = 0; i < size; i++) cost += in[i]*in[i]; if (bits) *bits = 0; return cost * lambda; } if (!scaled) { abspow34v(s->scoefs, in, size); scaled = s->scoefs; } quantizebands(s->qcoefs, in, scaled, size, Q34, !BTUNSIGNED, maxval); if (BTUNSIGNED) { off = 0; } else { off = maxval; } for (i = 0; i < size; i += dim) { const float *vec; int *quants = s->qcoefs + i; int curidx = 0; int curbits; float rd = 0.0f; for (j = 0; j < dim; j++) { curidx *= range; curidx += quants[j] + off; } curbits = ffaacspectralbits[cb-1][curidx]; vec = &ffaaccodebookvectors[cb-1][curidx*dim]; if (BTUNSIGNED) { for (k = 0; k < dim; k++) { float t = fabsf(in[i+k]); float di; if (BTESC && vec[k] == 64.0f) { //FIXME: slow if (t >= CLIPPEDESCAPE) { di = t - CLIPPEDESCAPE; curbits += 21; } else { int c = avclip(quant(t, Q), 0, 8191); di = t - c*cbrtf(c)*IQ; curbits += avlog2(c)*2 - 4 + 1; } } else { di = t - vec[k]*IQ; } if (vec[k] != 0.0f) curbits++; rd += di*di; } } else { for (k = 0; k < dim; k++) { float di = in[i+k] - vec[k]*IQ; rd += di*di; } } cost += rd * lambda + curbits; resbits += curbits; if (cost >= uplim) return uplim; if (pb) { putbits(pb, ffaacspectralbits[cb-1][curidx], ffaacspectralcodes[cb-1][curidx]); if (BTUNSIGNED) for (j = 0; j < dim; j++) if (ffaaccodebookvectors[cb-1][curidx*dim+j] != 0.0f) putbits(pb, 1, in[i+j] < 0.0f); if (BTESC) { for (j = 0; j < 2; j++) { if (ffaaccodebookvectors[cb-1][curidx*2+j] == 64.0f) { int coef = avclip(quant(fabsf(in[i+j]), Q), 0, 8191); int len = avlog2(coef); putbits(pb, len - 4 + 1, (1 << (len - 4 + 1)) - 2); putbits(pb, len, coef & ((1 << len) - 1)); } } } } } if (bits) *bits = resbits; return cost; } ", "target": 0}
{"func": "static void eventloop(VideoState *curstream) { SDLEvent event; double incr, pos, frac; for(;;) { double x; SDLWaitEvent(&event); switch(event.type) { case SDLKEYDOWN: if (exitonkeydown) { doexit(curstream); break; } switch(event.key.keysym.sym) { case SDLKESCAPE: case SDLKq: doexit(curstream); break; case SDLKf: togglefullscreen(curstream); break; case SDLKp: case SDLKSPACE: if (curstream) togglepause(curstream); break; case SDLKs: //S: Step to next frame if (curstream) steptonextframe(curstream); break; case SDLKa: if (curstream) streamcyclechannel(curstream, AVMEDIATYPEAUDIO); break; case SDLKv: if (curstream) streamcyclechannel(curstream, AVMEDIATYPEVIDEO); break; case SDLKt: if (curstream) streamcyclechannel(curstream, AVMEDIATYPESUBTITLE); break; case SDLKw: if (curstream) toggleaudiodisplay(curstream); break; case SDLKLEFT: incr = -10.0; goto doseek; case SDLKRIGHT: incr = 10.0; goto doseek; case SDLKUP: incr = 60.0; goto doseek; case SDLKDOWN: incr = -60.0; doseek: if (curstream) { if (seekbybytes) { if (curstream->videostream >= 0 && curstream->videocurrentpos>=0){ pos= curstream->videocurrentpos; }else if(curstream->audiostream >= 0 && curstream->audiopkt.pos>=0){ pos= curstream->audiopkt.pos; }else pos = aviotell(curstream->ic->pb); if (curstream->ic->bitrate) incr *= curstream->ic->bitrate / 8.0; else incr *= 180000.0; pos += incr; streamseek(curstream, pos, incr, 1); } else { pos = getmasterclock(curstream); pos += incr; streamseek(curstream, (int64t)(pos * AVTIMEBASE), (int64t)(incr * AVTIMEBASE), 0); } } break; default: break; } break; case SDLMOUSEBUTTONDOWN: if (exitonmousedown) { doexit(curstream); break; } case SDLMOUSEMOTION: if(event.type ==SDLMOUSEBUTTONDOWN){ x= event.button.x; }else{ if(event.motion.state != SDLPRESSED) break; x= event.motion.x; } if (curstream) { if(seekbybytes || curstream->ic->duration<=0){ uint64t size= aviosize(curstream->ic->pb); streamseek(curstream, size*x/curstream->width, 0, 1); }else{ int64t ts; int ns, hh, mm, ss; int tns, thh, tmm, tss; tns = curstream->ic->duration/1000000LL; thh = tns/3600; tmm = (tns%3600)/60; tss = (tns%60); frac = x/curstream->width; ns = frac*tns; hh = ns/3600; mm = (ns%3600)/60; ss = (ns%60); fprintf(stderr, \"Seek to %2.0f%% (%2d:%02d:%02d) of total duration (%2d:%02d:%02d) \\n\", frac*100, hh, mm, ss, thh, tmm, tss); ts = frac*curstream->ic->duration; if (curstream->ic->starttime != AVNOPTSVALUE) ts += curstream->ic->starttime; streamseek(curstream, ts, 0, 0); } } break; case SDLVIDEORESIZE: if (curstream) { screen = SDLSetVideoMode(event.resize.w, event.resize.h, 0, SDLHWSURFACE|SDLRESIZABLE|SDLASYNCBLIT|SDLHWACCEL); screenwidth = curstream->width = event.resize.w; screenheight= curstream->height= event.resize.h; } break; case SDLQUIT: case FFQUITEVENT: doexit(curstream); break; case FFALLOCEVENT: videoopen(event.user.data1); allocpicture(event.user.data1); break; case FFREFRESHEVENT: videorefresh(event.user.data1); curstream->refresh=0; break; default: break; } } } ", "target": 0}
{"func": "static int soxreadpacket(AVFormatContext *s, AVPacket *pkt) { int ret, size; if (urlfeof(s->pb)) return AVERROREOF; size = SOXSAMPLES*s->streams[0]->codec->blockalign; ret = avgetpacket(s->pb, pkt, size); if (ret < 0) return AVERROR(EIO); pkt->streamindex = 0; pkt->size = ret; return 0; }", "target": 1}
{"func": "static avcold int svq1encodeinit(AVCodecContext *avctx) { SVQ1Context * const s = avctx->privdata; dsputilinit(&s->dsp, avctx); avctx->codedframe= (AVFrame*)&s->picture; s->framewidth = avctx->width; s->frameheight = avctx->height; s->yblockwidth = (s->framewidth + 15) / 16; s->yblockheight = (s->frameheight + 15) / 16; s->cblockwidth = (s->framewidth / 4 + 15) / 16; s->cblockheight = (s->frameheight / 4 + 15) / 16; s->avctx= avctx; s->m.avctx= avctx; s->m.me.scratchpad= avmallocz((avctx->width+64)*2*16*2*sizeof(uint8t)); s->m.me.map = avmallocz(MEMAPSIZE*sizeof(uint32t)); s->m.me.scoremap = avmallocz(MEMAPSIZE*sizeof(uint32t)); s->mbtype = avmallocz((s->yblockwidth+1)*s->yblockheight*sizeof(int16t)); s->dummy = avmallocz((s->yblockwidth+1)*s->yblockheight*sizeof(int32t)); h263encodeinit(&s->m); //mvpenalty return 0; }", "target": 1}
{"func": "static int ahcipopulatesglist(AHCIDevice *ad, QEMUSGList *sglist, int offset) { AHCICmdHdr *cmd = ad->curcmd; uint32t opts = le32tocpu(cmd->opts); uint64t prdtaddr = le64tocpu(cmd->tbladdr) + 0x80; int sglistallochint = opts >> AHCICMDHDRPRDTLEN; dmaaddrt prdtlen = (sglistallochint * sizeof(AHCISG)); dmaaddrt realprdtlen = prdtlen; uint8t *prdt; int i; int r = 0; int sum = 0; int offidx = -1; int offpos = -1; int tblentrysize; IDEBus *bus = &ad->port; BusState *qbus = BUS(bus); if (!sglistallochint) { DPRINTF(ad->portno, \"no sg list given by guest: 0x%08x\\n\", opts); return -1; } /* map PRDT */ if (!(prdt = dmamemorymap(ad->hba->as, prdtaddr, &prdtlen, DMADIRECTIONTODEVICE))){ DPRINTF(ad->portno, \"map failed\\n\"); return -1; } if (prdtlen < realprdtlen) { DPRINTF(ad->portno, \"mapped less than expected\\n\"); r = -1; goto out; } /* Get entries in the PRDT, init a qemu sglist accordingly */ if (sglistallochint > 0) { AHCISG *tbl = (AHCISG *)prdt; sum = 0; for (i = 0; i < sglistallochint; i++) { /* flagssize is zero-based */ tblentrysize = (le32tocpu(tbl[i].flagssize) + 1); if (offset <= (sum + tblentrysize)) { offidx = i; offpos = offset - sum; break; } sum += tblentrysize; } if ((offidx == -1) || (offpos < 0) || (offpos > tblentrysize)) { DPRINTF(ad->portno, \"%s: Incorrect offset! \" \"offidx: %d, offpos: %d\\n\", func, offidx, offpos); r = -1; goto out; } qemusglistinit(sglist, qbus->parent, (sglistallochint - offidx), ad->hba->as); qemusglistadd(sglist, le64tocpu(tbl[offidx].addr + offpos), le32tocpu(tbl[offidx].flagssize) + 1 - offpos); for (i = offidx + 1; i < sglistallochint; i++) { /* flagssize is zero-based */ qemusglistadd(sglist, le64tocpu(tbl[i].addr), le32tocpu(tbl[i].flagssize) + 1); } } out: dmamemoryunmap(ad->hba->as, prdt, prdtlen, DMADIRECTIONTODEVICE, prdtlen); return r; } ", "target": 1}
{"func": "static avalwaysinline void mpegmotionlowres(MpegEncContext *s, uint8t *desty, uint8t *destcb, uint8t *destcr, int fieldbased, int bottomfield, int fieldselect, uint8t **refpicture, h264chromamcfunc *pixop, int motionx, int motiony, int h, int mby) { uint8t *ptry, *ptrcb, *ptrcr; int mx, my, srcx, srcy, uvsrcx, uvsrcy, uvlinesize, linesize, sx, sy, uvsx, uvsy; const int lowres = s->avctx->lowres; const int opindex = FFMIN(lowres, 2); const int blocks = 8>>lowres; const int smask = (2 << lowres) - 1; const int hedgepos = s->hedgepos >> lowres; const int vedgepos = s->vedgepos >> lowres; linesize = s->currentpicture.f.linesize[0] << fieldbased; uvlinesize = s->currentpicture.f.linesize[1] << fieldbased; // FIXME obviously not perfect but qpel will not work in lowres anyway if (s->quartersample) { motionx /= 2; motiony /= 2; } if (fieldbased) { motiony += (bottomfield - fieldselect) * (1 << lowres - 1); } sx = motionx & smask; sy = motiony & smask; srcx = s->mbx * 2 * blocks + (motionx >> lowres + 1); srcy = (mby * 2 * blocks >> fieldbased) + (motiony >> lowres + 1); if (s->outformat == FMTH263) { uvsx = ((motionx >> 1) & smask) | (sx & 1); uvsy = ((motiony >> 1) & smask) | (sy & 1); uvsrcx = srcx >> 1; uvsrcy = srcy >> 1; } else if (s->outformat == FMTH261) { // even chroma mv's are full pel in H261 mx = motionx / 4; my = motiony / 4; uvsx = (2 * mx) & smask; uvsy = (2 * my) & smask; uvsrcx = s->mbx * blocks + (mx >> lowres); uvsrcy = mby * blocks + (my >> lowres); } else { mx = motionx / 2; my = motiony / 2; uvsx = mx & smask; uvsy = my & smask; uvsrcx = s->mbx * blocks + (mx >> lowres + 1); uvsrcy = (mby * blocks >> fieldbased) + (my >> lowres + 1); } ptry = refpicture[0] + srcy * linesize + srcx; ptrcb = refpicture[1] + uvsrcy * uvlinesize + uvsrcx; ptrcr = refpicture[2] + uvsrcy * uvlinesize + uvsrcx; if ((unsigned) srcx > hedgepos - (!!sx) - 2 * blocks || (unsigned) srcy > (vedgepos >> fieldbased) - (!!sy) - h) { s->dsp.emulatededgemc(s->edgeemubuffer, ptry, s->linesize, 17, 17 + fieldbased, srcx, srcy << fieldbased, hedgepos, vedgepos); ptry = s->edgeemubuffer; if (!CONFIGGRAY || !(s->flags & CODECFLAGGRAY)) { uint8t *uvbuf = s->edgeemubuffer + 18 * s->linesize; s->dsp.emulatededgemc(uvbuf , ptrcb, s->uvlinesize, 9, 9 + fieldbased, uvsrcx, uvsrcy << fieldbased, hedgepos >> 1, vedgepos >> 1); s->dsp.emulatededgemc(uvbuf + 16, ptrcr, s->uvlinesize, 9, 9 + fieldbased, uvsrcx, uvsrcy << fieldbased, hedgepos >> 1, vedgepos >> 1); ptrcb = uvbuf; ptrcr = uvbuf + 16; } } // FIXME use this for field pix too instead of the obnoxious hack which changes picture.f.data if (bottomfield) { desty += s->linesize; destcb += s->uvlinesize; destcr += s->uvlinesize; } if (fieldselect) { ptry += s->linesize; ptrcb += s->uvlinesize; ptrcr += s->uvlinesize; } sx = (sx << 2) >> lowres; sy = (sy << 2) >> lowres; pixop[lowres - 1](desty, ptry, linesize, h, sx, sy); if (!CONFIGGRAY || !(s->flags & CODECFLAGGRAY)) { uvsx = (uvsx << 2) >> lowres; uvsy = (uvsy << 2) >> lowres; pixop[opindex](destcb, ptrcb, uvlinesize, h >> s->chromayshift, uvsx, uvsy); pixop[opindex](destcr, ptrcr, uvlinesize, h >> s->chromayshift, uvsx, uvsy); } // FIXME h261 lowres loop filter } ", "target": 1}
{"func": "static int decodeframe(AVCodecContext *avctx, void *data, int *gotframe, AVPacket *avpkt) { const uint8t *buf = avpkt->data; unsigned int bufsize = avpkt->size; const uint8t *bufend = buf + bufsize; const AVPixFmtDescriptor *desc; EXRContext *const s = avctx->privdata; AVFrame *picture = data; AVFrame *const p = &s->picture; uint8t *ptr; int i, x, y, stride, magicnumber, version, flags, ret; int w = 0; int h = 0; unsigned int xmin = ~0; unsigned int xmax = ~0; unsigned int ymin = ~0; unsigned int ymax = ~0; unsigned int xdelta = ~0; int outlinesize; int bxmin, axmax; int scanlinesperblock; unsigned long scanlinesize; unsigned long uncompressedsize; unsigned int currentchanneloffset = 0; s->channeloffsets[0] = -1; s->channeloffsets[1] = -1; s->channeloffsets[2] = -1; s->channeloffsets[3] = -1; s->bitspercolorid = -1; s->compr = -1; if (bufsize < 10) { avlog(avctx, AVLOGERROR, \"Too short header to parse\\n\"); return AVERRORINVALIDDATA; } magicnumber = bytestreamgetle32(&buf); if (magicnumber != 20000630) { // As per documentation of OpenEXR it's supposed to be int 20000630 little-endian avlog(avctx, AVLOGERROR, \"Wrong magic number %d\\n\", magicnumber); return AVERRORINVALIDDATA; } version = bytestreamgetbyte(&buf); if (version != 2) { avlog(avctx, AVLOGERROR, \"Unsupported version %d\\n\", version); return AVERRORPATCHWELCOME; } flags = bytestreamgetle24(&buf); if (flags & 0x2) { avlog(avctx, AVLOGERROR, \"Tile based images are not supported\\n\"); return AVERRORPATCHWELCOME; } // Parse the header while (buf < bufend && buf[0]) { unsigned int variablebufferdatasize; // Process the channel list if (checkheadervariable(avctx, &buf, bufend, \"channels\", \"chlist\", 38, &variablebufferdatasize) >= 0) { const uint8t *channellistend; if (!variablebufferdatasize) return AVERRORINVALIDDATA; channellistend = buf + variablebufferdatasize; while (channellistend - buf >= 19) { int currentbitspercolorid = -1; int channelindex = -1; if (!strcmp(buf, \"R\")) channelindex = 0; else if (!strcmp(buf, \"G\")) channelindex = 1; else if (!strcmp(buf, \"B\")) channelindex = 2; else if (!strcmp(buf, \"A\")) channelindex = 3; else avlog(avctx, AVLOGWARNING, \"Unsupported channel %.256s\\n\", buf); while (bytestreamgetbyte(&buf) && buf < channellistend) continue; /* skip */ if (channellistend - * &buf < 4) { avlog(avctx, AVLOGERROR, \"Incomplete header\\n\"); return AVERRORINVALIDDATA; } currentbitspercolorid = bytestreamgetle32(&buf); if (currentbitspercolorid > 2) { avlog(avctx, AVLOGERROR, \"Unknown color format\\n\"); return AVERRORINVALIDDATA; } if (channelindex >= 0) { if (s->bitspercolorid != -1 && s->bitspercolorid != currentbitspercolorid) { avlog(avctx, AVLOGERROR, \"RGB channels not of the same depth\\n\"); return AVERRORINVALIDDATA; } s->bitspercolorid = currentbitspercolorid; s->channeloffsets[channelindex] = currentchanneloffset; } currentchanneloffset += 1 << currentbitspercolorid; buf += 12; } /* Check if all channels are set with an offset or if the channels * are causing an overflow */ if (FFMIN3(s->channeloffsets[0], s->channeloffsets[1], s->channeloffsets[2]) < 0) { if (s->channeloffsets[0] < 0) avlog(avctx, AVLOGERROR, \"Missing red channel\\n\"); if (s->channeloffsets[1] < 0) avlog(avctx, AVLOGERROR, \"Missing green channel\\n\"); if (s->channeloffsets[2] < 0) avlog(avctx, AVLOGERROR, \"Missing blue channel\\n\"); return AVERRORINVALIDDATA; } buf = channellistend; continue; } else if (checkheadervariable(avctx, &buf, bufend, \"dataWindow\", \"box2i\", 31, &variablebufferdatasize) >= 0) { if (!variablebufferdatasize) return AVERRORINVALIDDATA; xmin = AVRL32(buf); ymin = AVRL32(buf + 4); xmax = AVRL32(buf + 8); ymax = AVRL32(buf + 12); xdelta = (xmax-xmin) + 1; buf += variablebufferdatasize; continue; } else if (checkheadervariable(avctx, &buf, bufend, \"displayWindow\", \"box2i\", 34, &variablebufferdatasize) >= 0) { if (!variablebufferdatasize) return AVERRORINVALIDDATA; w = AVRL32(buf + 8) + 1; h = AVRL32(buf + 12) + 1; buf += variablebufferdatasize; continue; } else if (checkheadervariable(avctx, &buf, bufend, \"lineOrder\", \"lineOrder\", 25, &variablebufferdatasize) >= 0) { if (!variablebufferdatasize) return AVERRORINVALIDDATA; if (*buf) { avlog(avctx, AVLOGERROR, \"Doesn't support this line order : %d\\n\", *buf); return AVERRORPATCHWELCOME; } buf += variablebufferdatasize; continue; } else if (checkheadervariable(avctx, &buf, bufend, \"pixelAspectRatio\", \"float\", 31, &variablebufferdatasize) >= 0) { if (!variablebufferdatasize) return AVERRORINVALIDDATA; avctx->sampleaspectratio = avd2q(avint2float(AVRL32(buf)), 255); buf += variablebufferdatasize; continue; } else if (checkheadervariable(avctx, &buf, bufend, \"compression\", \"compression\", 29, &variablebufferdatasize) >= 0) { if (!variablebufferdatasize) return AVERRORINVALIDDATA; if (s->compr == -1) s->compr = *buf; else avlog(avctx, AVLOGWARNING, \"Found more than one compression attribute\\n\"); buf += variablebufferdatasize; continue; } // Check if there is enough bytes for a header if (bufend - buf <= 9) { avlog(avctx, AVLOGERROR, \"Incomplete header\\n\"); return AVERRORINVALIDDATA; } // Process unknown variables for (i = 0; i < 2; i++) { // Skip variable name/type while (++buf < bufend) if (buf[0] == 0x0) break; } buf++; // Skip variable length if (bufend - buf >= 5) { variablebufferdatasize = getheadervariablelength(&buf, bufend); if (!variablebufferdatasize) { avlog(avctx, AVLOGERROR, \"Incomplete header\\n\"); return AVERRORINVALIDDATA; } buf += variablebufferdatasize; } } if (s->compr == -1) { avlog(avctx, AVLOGERROR, \"Missing compression attribute\\n\"); return AVERRORINVALIDDATA; } if (buf >= bufend) { avlog(avctx, AVLOGERROR, \"Incomplete frame\\n\"); return AVERRORINVALIDDATA; } buf++; switch (s->bitspercolorid) { case 2: // 32-bit case 1: // 16-bit if (s->channeloffsets[3] >= 0) avctx->pixfmt = AVPIXFMTRGBA64; else avctx->pixfmt = AVPIXFMTRGB48; break; // 8-bit case 0: avlogmissingfeature(avctx, \"8-bit OpenEXR\", 1); return AVERRORPATCHWELCOME; default: avlog(avctx, AVLOGERROR, \"Unknown color format : %d\\n\", s->bitspercolorid); return AVERRORINVALIDDATA; } switch (s->compr) { case EXRRAW: case EXRRLE: case EXRZIP1: scanlinesperblock = 1; break; case EXRZIP16: scanlinesperblock = 16; break; default: avlog(avctx, AVLOGERROR, \"Compression type %d is not supported\\n\", s->compr); return AVERRORPATCHWELCOME; } if (s->picture.data[0]) ffthreadreleasebuffer(avctx, &s->picture); if (avimagechecksize(w, h, 0, avctx)) return AVERRORINVALIDDATA; // Verify the xmin, xmax, ymin, ymax and xdelta before setting the actual image size if (xmin > xmax || ymin > ymax || xdelta != xmax - xmin + 1 || xmax >= w || ymax >= h) { avlog(avctx, AVLOGERROR, \"Wrong sizing or missing size information\\n\"); return AVERRORINVALIDDATA; } if (w != avctx->width || h != avctx->height) { avcodecsetdimensions(avctx, w, h); } desc = avpixfmtdescget(avctx->pixfmt); bxmin = xmin * 2 * desc->nbcomponents; axmax = (avctx->width - (xmax + 1)) * 2 * desc->nbcomponents; outlinesize = avctx->width * 2 * desc->nbcomponents; scanlinesize = xdelta * currentchanneloffset; uncompressedsize = scanlinesize * scanlinesperblock; if (s->compr != EXRRAW) { avfastpaddedmalloc(&s->uncompresseddata, &s->uncompressedsize, uncompressedsize); avfastpaddedmalloc(&s->tmp, &s->tmpsize, uncompressedsize); if (!s->uncompresseddata || !s->tmp) return AVERROR(ENOMEM); } if ((ret = ffthreadgetbuffer(avctx, p)) < 0) { avlog(avctx, AVLOGERROR, \"getbuffer() failed\\n\"); return ret; } ptr = p->data[0]; stride = p->linesize[0]; // Zero out the start if ymin is not 0 for (y = 0; y < ymin; y++) { memset(ptr, 0, outlinesize); ptr += stride; } // Process the actual scan line blocks for (y = ymin; y <= ymax; y += scanlinesperblock) { uint16t *ptrx = (uint16t *)ptr; if (bufend - buf > 8) { /* Read the lineoffset from the line offset table and add 8 bytes to skip the coordinates and data size fields */ const uint64t lineoffset = bytestreamgetle64(&buf) + 8; int32t datasize; // Check if the buffer has the required bytes needed from the offset if ((lineoffset > bufsize) || (s->compr == EXRRAW && lineoffset > avpkt->size - xdelta * currentchanneloffset) || (s->compr != EXRRAW && lineoffset > bufsize - (datasize = AVRL32(avpkt->data + lineoffset - 4)))) { // Line offset is probably wrong and not inside the buffer avlog(avctx, AVLOGWARNING, \"Line offset for line %d is out of reach setting it to black\\n\", y); for (i = 0; i < scanlinesperblock && y + i <= ymax; i++, ptr += stride) { ptrx = (uint16t *)ptr; memset(ptrx, 0, outlinesize); } } else { const uint8t *redchannelbuffer, *greenchannelbuffer, *bluechannelbuffer, *alphachannelbuffer = 0; if (scanlinesperblock > 1) uncompressedsize = scanlinesize * FFMIN(scanlinesperblock, ymax - y + 1); if ((s->compr == EXRZIP1 || s->compr == EXRZIP16) && datasize < uncompressedsize) { unsigned long destlen = uncompressedsize; if (uncompress(s->tmp, &destlen, avpkt->data + lineoffset, datasize) != ZOK || destlen != uncompressedsize) { avlog(avctx, AVLOGERROR, \"error during zlib decompression\\n\"); return AVERROR(EINVAL); } } else if (s->compr == EXRRLE && datasize < uncompressedsize) { if (rleuncompress(avpkt->data + lineoffset, datasize, s->tmp, uncompressedsize)) { avlog(avctx, AVLOGERROR, \"error during rle decompression\\n\"); return AVERROR(EINVAL); } } if (s->compr != EXRRAW && datasize < uncompressedsize) { predictor(s->tmp, uncompressedsize); reorderpixels(s->tmp, s->uncompresseddata, uncompressedsize); redchannelbuffer = s->uncompresseddata + xdelta * s->channeloffsets[0]; greenchannelbuffer = s->uncompresseddata + xdelta * s->channeloffsets[1]; bluechannelbuffer = s->uncompresseddata + xdelta * s->channeloffsets[2]; if (s->channeloffsets[3] >= 0) alphachannelbuffer = s->uncompresseddata + xdelta * s->channeloffsets[3]; } else { redchannelbuffer = avpkt->data + lineoffset + xdelta * s->channeloffsets[0]; greenchannelbuffer = avpkt->data + lineoffset + xdelta * s->channeloffsets[1]; bluechannelbuffer = avpkt->data + lineoffset + xdelta * s->channeloffsets[2]; if (s->channeloffsets[3] >= 0) alphachannelbuffer = avpkt->data + lineoffset + xdelta * s->channeloffsets[3]; } for (i = 0; i < scanlinesperblock && y + i <= ymax; i++, ptr += stride) { const uint8t *r, *g, *b, *a; r = redchannelbuffer; g = greenchannelbuffer; b = bluechannelbuffer; if (alphachannelbuffer) a = alphachannelbuffer; ptrx = (uint16t *)ptr; // Zero out the start if xmin is not 0 memset(ptrx, 0, bxmin); ptrx += xmin * desc->nbcomponents; if (s->bitspercolorid == 2) { // 32-bit for (x = 0; x < xdelta; x++) { *ptrx++ = exrflt2uint(bytestreamgetle32(&r)); *ptrx++ = exrflt2uint(bytestreamgetle32(&g)); *ptrx++ = exrflt2uint(bytestreamgetle32(&b)); if (alphachannelbuffer) *ptrx++ = exrflt2uint(bytestreamgetle32(&a)); } } else { // 16-bit for (x = 0; x < xdelta; x++) { *ptrx++ = exrhalflt2uint(bytestreamgetle16(&r)); *ptrx++ = exrhalflt2uint(bytestreamgetle16(&g)); *ptrx++ = exrhalflt2uint(bytestreamgetle16(&b)); if (alphachannelbuffer) *ptrx++ = exrhalflt2uint(bytestreamgetle16(&a)); } } // Zero out the end if xmax+1 is not w memset(ptrx, 0, axmax); redchannelbuffer += scanlinesize; greenchannelbuffer += scanlinesize; bluechannelbuffer += scanlinesize; if (alphachannelbuffer) alphachannelbuffer += scanlinesize; } } } } // Zero out the end if ymax+1 is not h for (y = ymax + 1; y < avctx->height; y++) { memset(ptr, 0, outlinesize); ptr += stride; } *picture = s->picture; *gotframe = 1; return bufsize; } ", "target": 1}
{"func": "static void csrhcireset(struct csrhcis *s) { s->outlen = 0; s->outsize = FIFOLEN; s->inlen = 0; s->bauddelay = NANOSECONDSPERSECOND; s->enable = 0; s->inhdr = INTMAX; s->indata = INTMAX; s->modemstate = 0; /* After a while... (but sooner than 10ms) */ s->modemstate |= CHRTIOCMCTS; memset(&s->bdaddr, 0, sizeof(bdaddrt)); } ", "target": 1}
{"func": "void rgb15tobgr15(const uint8t *src, uint8t *dst, unsigned int srcsize) { \tunsigned i; \tunsigned numpixels = srcsize >> 1; \t \tfor(i=0; i<numpixels; i++) \t{ \t unsigned b,g,r; \t register uint16t rgb; \t rgb = src[2*i]; \t r = rgb&0x1F; \t g = (rgb&0x3E0)>>5; \t b = (rgb&0x7C00)>>10; \t dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10); \t} } ", "target": 1}
{"func": "int netinitvhostuser(const Netdev *netdev, const char *name, NetClientState *peer, Error **errp) { int queues; const NetdevVhostUserOptions *vhostuseropts; CharDriverState *chr; assert(netdev->type == NETCLIENTDRIVERVHOSTUSER); vhostuseropts = &netdev->u.vhostuser; chr = netvhostparsechardev(vhostuseropts, errp); if (!chr) { return -1; } /* verify net frontend */ if (qemuoptsforeach(qemufindopts(\"device\"), netvhostchecknet, (char *)name, errp)) { return -1; } queues = vhostuseropts->hasqueues ? vhostuseropts->queues : 1; if (queues < 1 || queues > MAXQUEUENUM) { errorsetg(errp, \"vhost-user number of queues must be in range [1, %d]\", MAXQUEUENUM); return -1; } return netvhostuserinit(peer, \"vhostuser\", name, chr, queues); } ", "target": 1}
{"func": "static int lagdecodeprob(GetBitContext *gb, uint32t *value) { static const uint8t series[] = { 1, 2, 3, 5, 8, 13, 21 }; int i; int bit = 0; int bits = 0; int prevbit = 0; unsigned val; for (i = 0; i < 7; i++) { if (prevbit && bit) break; prevbit = bit; bit = getbits1(gb); if (bit && !prevbit) bits += series[i]; } bits--; if (bits < 0 || bits > 31) { *value = 0; return -1; } else if (bits == 0) { *value = 0; return 0; } val = getbitslong(gb, bits); val |= 1 << bits; *value = val - 1; return 0; } ", "target": 1}
{"func": "static void checkaddres(HEVCDSPContext h, int bitdepth) { int i; LOCALALIGNED32(int16t, res0, [32 * 32]); LOCALALIGNED32(int16t, res1, [32 * 32]); LOCALALIGNED32(uint8t, dst0, [32 * 32 * 2]); LOCALALIGNED32(uint8t, dst1, [32 * 32 * 2]); for (i = 2; i <= 5; i++) { int blocksize = 1 << i; int size = blocksize * blocksize; ptrdifft stride = blocksize << (bitdepth > 8); declarefuncemms(AVCPUFLAGMMX, void, uint8t *dst, int16t *res, ptrdifft stride); randomizebuffers(res0, size); randomizebuffers2(dst0, size); memcpy(res1, res0, sizeof(*res0) * size); memcpy(dst1, dst0, size); if (checkfunc(h.addresidual[i - 2], \"addres%dx%d%d\", blocksize, blocksize, bitdepth)) { callref(dst0, res0, stride); callnew(dst1, res1, stride); if (memcmp(dst0, dst1, size)) fail(); benchnew(dst1, res1, stride); } } } ", "target": 1}
{"func": "static void testvalidatefailunionflat(TestInputVisitorData *data, const void *unused) { UserDefFlatUnion *tmp = NULL; Error *errp = NULL; Visitor *v; v = validatetestinit(data, \"{ 'string': 'c', 'integer': 41, 'boolean': true }\"); visittypeUserDefFlatUnion(v, &tmp, NULL, &errp); gassert(errorisset(&errp)); qapifreeUserDefFlatUnion(tmp); } ", "target": 0}
{"func": "void cpux86updatecr4(CPUX86State *env, uint32t newcr4) { #if defined(DEBUGMMU) printf(\"CR4 update: CR4=%08x\\n\", (uint32t)env->cr[4]); #endif if ((newcr4 & (CR4PGEMASK | CR4PAEMASK | CR4PSEMASK)) != (env->cr[4] & (CR4PGEMASK | CR4PAEMASK | CR4PSEMASK))) { tlbflush(env, 1); } /* SSE handling */ if (!(env->cpuidfeatures & CPUIDSSE)) newcr4 &= ~CR4OSFXSRMASK; if (newcr4 & CR4OSFXSRMASK) env->hflags |= HFOSFXSRMASK; else env->hflags &= ~HFOSFXSRMASK; env->cr[4] = newcr4; } ", "target": 0}
{"func": "int driveinit(struct driveopt *arg, int snapshot, void *opaque) { char buf[128]; char file[1024]; char devname[128]; char serial[21]; const char *mediastr = \"\"; BlockInterfaceType type; enum { MEDIADISK, MEDIACDROM } media; int busid, unitid; int cyls, heads, secs, translation; BlockDriverState *bdrv; BlockDriver *drv = NULL; QEMUMachine *machine = opaque; int maxdevs; int index; int cache; int bdrvflags, onerror; int drivestableidx; char *str = arg->opt; static const char * const params[] = { \"bus\", \"unit\", \"if\", \"index\", \"cyls\", \"heads\", \"secs\", \"trans\", \"media\", \"snapshot\", \"file\", \"cache\", \"format\", \"serial\", \"werror\", NULL }; if (checkparams(buf, sizeof(buf), params, str) < 0) { fprintf(stderr, \"qemu: unknown parameter '%s' in '%s'\\n\", buf, str); return -1; } file[0] = 0; cyls = heads = secs = 0; busid = 0; unitid = -1; translation = BIOSATATRANSLATIONAUTO; index = -1; cache = 3; if (machine->usescsi) { type = IFSCSI; maxdevs = MAXSCSIDEVS; pstrcpy(devname, sizeof(devname), \"scsi\"); } else { type = IFIDE; maxdevs = MAXIDEDEVS; pstrcpy(devname, sizeof(devname), \"ide\"); } media = MEDIADISK; /* extract parameters */ if (getparamvalue(buf, sizeof(buf), \"bus\", str)) { busid = strtol(buf, NULL, 0); \tif (busid < 0) { \t fprintf(stderr, \"qemu: '%s' invalid bus id\\n\", str); \t return -1; \t} } if (getparamvalue(buf, sizeof(buf), \"unit\", str)) { unitid = strtol(buf, NULL, 0); \tif (unitid < 0) { \t fprintf(stderr, \"qemu: '%s' invalid unit id\\n\", str); \t return -1; \t} } if (getparamvalue(buf, sizeof(buf), \"if\", str)) { pstrcpy(devname, sizeof(devname), buf); if (!strcmp(buf, \"ide\")) { \t type = IFIDE; maxdevs = MAXIDEDEVS; } else if (!strcmp(buf, \"scsi\")) { \t type = IFSCSI; maxdevs = MAXSCSIDEVS; } else if (!strcmp(buf, \"floppy\")) { \t type = IFFLOPPY; maxdevs = 0; } else if (!strcmp(buf, \"pflash\")) { \t type = IFPFLASH; maxdevs = 0; \t} else if (!strcmp(buf, \"mtd\")) { \t type = IFMTD; maxdevs = 0; \t} else if (!strcmp(buf, \"sd\")) { \t type = IFSD; maxdevs = 0; } else if (!strcmp(buf, \"virtio\")) { type = IFVIRTIO; maxdevs = 0; \t} else if (!strcmp(buf, \"xen\")) { \t type = IFXEN; maxdevs = 0; \t} else { fprintf(stderr, \"qemu: '%s' unsupported bus type '%s'\\n\", str, buf); return -1; \t} } if (getparamvalue(buf, sizeof(buf), \"index\", str)) { index = strtol(buf, NULL, 0); \tif (index < 0) { \t fprintf(stderr, \"qemu: '%s' invalid index\\n\", str); \t return -1; \t} } if (getparamvalue(buf, sizeof(buf), \"cyls\", str)) { cyls = strtol(buf, NULL, 0); } if (getparamvalue(buf, sizeof(buf), \"heads\", str)) { heads = strtol(buf, NULL, 0); } if (getparamvalue(buf, sizeof(buf), \"secs\", str)) { secs = strtol(buf, NULL, 0); } if (cyls || heads || secs) { if (cyls < 1 || cyls > 16383) { fprintf(stderr, \"qemu: '%s' invalid physical cyls number\\n\", str); \t return -1; \t} if (heads < 1 || heads > 16) { fprintf(stderr, \"qemu: '%s' invalid physical heads number\\n\", str); \t return -1; \t} if (secs < 1 || secs > 63) { fprintf(stderr, \"qemu: '%s' invalid physical secs number\\n\", str); \t return -1; \t} } if (getparamvalue(buf, sizeof(buf), \"trans\", str)) { if (!cyls) { fprintf(stderr, \"qemu: '%s' trans must be used with cyls,heads and secs\\n\", str); return -1; } if (!strcmp(buf, \"none\")) translation = BIOSATATRANSLATIONNONE; else if (!strcmp(buf, \"lba\")) translation = BIOSATATRANSLATIONLBA; else if (!strcmp(buf, \"auto\")) translation = BIOSATATRANSLATIONAUTO; \telse { fprintf(stderr, \"qemu: '%s' invalid translation type\\n\", str); \t return -1; \t} } if (getparamvalue(buf, sizeof(buf), \"media\", str)) { if (!strcmp(buf, \"disk\")) { \t media = MEDIADISK; \t} else if (!strcmp(buf, \"cdrom\")) { if (cyls || secs || heads) { fprintf(stderr, \"qemu: '%s' invalid physical CHS format\\n\", str); \t return -1; } \t media = MEDIACDROM; \t} else { \t fprintf(stderr, \"qemu: '%s' invalid media\\n\", str); \t return -1; \t} } if (getparamvalue(buf, sizeof(buf), \"snapshot\", str)) { if (!strcmp(buf, \"on\")) \t snapshot = 1; else if (!strcmp(buf, \"off\")) \t snapshot = 0; \telse { \t fprintf(stderr, \"qemu: '%s' invalid snapshot option\\n\", str); \t return -1; \t} } if (getparamvalue(buf, sizeof(buf), \"cache\", str)) { if (!strcmp(buf, \"off\") || !strcmp(buf, \"none\")) cache = 0; else if (!strcmp(buf, \"writethrough\")) cache = 1; else if (!strcmp(buf, \"writeback\")) cache = 2; else { fprintf(stderr, \"qemu: invalid cache option\\n\"); return -1; } } if (getparamvalue(buf, sizeof(buf), \"format\", str)) { if (strcmp(buf, \"?\") == 0) { fprintf(stderr, \"qemu: Supported formats:\"); bdrviterateformat(bdrvformatprint, NULL); fprintf(stderr, \"\\n\"); \t return -1; } drv = bdrvfindformat(buf); if (!drv) { fprintf(stderr, \"qemu: '%s' invalid format\\n\", buf); return -1; } } if (arg->file == NULL) getparamvalue(file, sizeof(file), \"file\", str); else pstrcpy(file, sizeof(file), arg->file); if (!getparamvalue(serial, sizeof(serial), \"serial\", str)) \t memset(serial, 0, sizeof(serial)); onerror = BLOCKERRSTOPENOSPC; if (getparamvalue(buf, sizeof(serial), \"werror\", str)) { if (type != IFIDE && type != IFSCSI && type != IFVIRTIO) { fprintf(stderr, \"werror is no supported by this format\\n\"); return -1; } if (!strcmp(buf, \"ignore\")) onerror = BLOCKERRIGNORE; else if (!strcmp(buf, \"enospc\")) onerror = BLOCKERRSTOPENOSPC; else if (!strcmp(buf, \"stop\")) onerror = BLOCKERRSTOPANY; else if (!strcmp(buf, \"report\")) onerror = BLOCKERRREPORT; else { fprintf(stderr, \"qemu: '%s' invalid write error action\\n\", buf); return -1; } } /* compute bus and unit according index */ if (index != -1) { if (busid != 0 || unitid != -1) { fprintf(stderr, \"qemu: '%s' index cannot be used with bus and unit\\n\", str); return -1; } if (maxdevs == 0) { unitid = index; busid = 0; } else { unitid = index % maxdevs; busid = index / maxdevs; } } /* if user doesn't specify a unitid, * try to find the first free */ if (unitid == -1) { unitid = 0; while (drivegetindex(type, busid, unitid) != -1) { unitid++; if (maxdevs && unitid >= maxdevs) { unitid -= maxdevs; busid++; } } } /* check unit id */ if (maxdevs && unitid >= maxdevs) { fprintf(stderr, \"qemu: '%s' unit %d too big (max is %d)\\n\", str, unitid, maxdevs - 1); return -1; } /* * ignore multiple definitions */ if (drivegetindex(type, busid, unitid) != -1) return -2; /* init */ if (type == IFIDE || type == IFSCSI) mediastr = (media == MEDIACDROM) ? \"-cd\" : \"-hd\"; if (maxdevs) snprintf(buf, sizeof(buf), \"%s%i%s%i\", devname, busid, mediastr, unitid); else snprintf(buf, sizeof(buf), \"%s%s%i\", devname, mediastr, unitid); bdrv = bdrvnew(buf); drivestableidx = drivegetfreeidx(); drivestable[drivestableidx].bdrv = bdrv; drivestable[drivestableidx].type = type; drivestable[drivestableidx].bus = busid; drivestable[drivestableidx].unit = unitid; drivestable[drivestableidx].onerror = onerror; drivestable[drivestableidx].driveoptidx = arg - drivesopt; strncpy(drivestable[nbdrives].serial, serial, sizeof(serial)); nbdrives++; switch(type) { case IFIDE: case IFSCSI: case IFXEN: switch(media) { \tcase MEDIADISK: if (cyls != 0) { bdrvsetgeometryhint(bdrv, cyls, heads, secs); bdrvsettranslationhint(bdrv, translation); } \t break; \tcase MEDIACDROM: bdrvsettypehint(bdrv, BDRVTYPECDROM); \t break; \t} break; case IFSD: /* FIXME: This isn't really a floppy, but it's a reasonable approximation. */ case IFFLOPPY: bdrvsettypehint(bdrv, BDRVTYPEFLOPPY); break; case IFPFLASH: case IFMTD: case IFVIRTIO: break; } if (!file[0]) return -2; bdrvflags = 0; if (snapshot) { bdrvflags |= BDRVOSNAPSHOT; cache = 2; /* always use write-back with snapshot */ } if (cache == 0) /* no caching */ bdrvflags |= BDRVONOCACHE; else if (cache == 2) /* write-back */ bdrvflags |= BDRVOCACHEWB; else if (cache == 3) /* not specified */ bdrvflags |= BDRVOCACHEDEF; if (bdrvopen2(bdrv, file, bdrvflags, drv) < 0) { fprintf(stderr, \"qemu: could not open disk image %s\\n\", file); return -1; } if (bdrvkeyrequired(bdrv)) autostart = 0; return drivestableidx; } ", "target": 0}
{"func": "static void unixwaitforconnect(int fd, Error *err, void *opaque) { MigrationState *s = opaque; if (fd < 0) { DPRINTF(\"migrate connect error: %s\\n\", errorgetpretty(err)); s->file = NULL; migratefderror(s); } else { DPRINTF(\"migrate connect success\\n\"); s->file = qemufopensocket(fd, \"wb\"); migratefdconnect(s); } } ", "target": 1}
{"func": "static int ljpegencodeframe(AVCodecContext *avctx, AVPacket *pkt, const AVFrame *pict, int *gotpacket) { LJpegEncContext *s = avctx->privdata; PutBitContext pb; const int width = avctx->width; const int height = avctx->height; const int mbwidth = (width + s->hsample[0] - 1) / s->hsample[0]; const int mbheight = (height + s->vsample[0] - 1) / s->vsample[0]; int maxpktsize = AVINPUTBUFFERMINSIZE; int ret, headerbits; if (avctx->pixfmt == AVPIXFMTBGR24) maxpktsize += width * height * 3 * 3; else { maxpktsize += mbwidth * mbheight * 3 * 4 * s->hsample[0] * s->vsample[0]; } if ((ret = ffallocpacket(pkt, maxpktsize)) < 0) { avlog(avctx, AVLOGERROR, \"Error getting output packet of size %d.\\n\", maxpktsize); return ret; } initputbits(&pb, pkt->data, pkt->size); ffmjpegencodepictureheader(avctx, &pb, &s->scantable, s->matrix); headerbits = putbitscount(&pb); if (avctx->pixfmt == AVPIXFMTBGR24) ret = ljpegencodebgr(avctx, &pb, pict); else ret = ljpegencodeyuv(avctx, &pb, pict); if (ret < 0) return ret; emmsc(); ffmjpegencodepicturetrailer(&pb, headerbits); flushputbits(&pb); pkt->size = putbitsptr(&pb) - pb.buf; pkt->flags |= AVPKTFLAGKEY; *gotpacket = 1; return 0; } ", "target": 0}
{"func": "int avvsrcbufferaddvideobufferref(AVFilterContext *bufferfilter, AVFilterBufferRef *picref) { BufferSourceContext *c = bufferfilter->priv; AVFilterLink *outlink = bufferfilter->outputs[0]; int ret; if (c->picref) { avlog(bufferfilter, AVLOGERROR, \"Buffering several frames is not supported. \" \"Please consume all available frames before adding a new one.\\n\" ); //return -1; } if (picref->video->w != c->w || picref->video->h != c->h || picref->format != c->pixfmt) { AVFilterContext *scale = bufferfilter->outputs[0]->dst; AVFilterLink *link; char scaleparam[1024]; avlog(bufferfilter, AVLOGINFO, \"Buffer video input changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s\\n\", c->w, c->h, avpixfmtdescriptors[c->pixfmt].name, picref->video->w, picref->video->h, avpixfmtdescriptors[picref->format].name); if (!scale || strcmp(scale->filter->name, \"scale\")) { AVFilter *f = avfiltergetbyname(\"scale\"); avlog(bufferfilter, AVLOGINFO, \"Inserting scaler filter\\n\"); if ((ret = avfilteropen(&scale, f, \"Input equalizer\")) < 0) return ret; snprintf(scaleparam, sizeof(scaleparam)-1, \"%d:%d:%s\", c->w, c->h, c->swsparam); if ((ret = avfilterinitfilter(scale, scaleparam, NULL)) < 0) { avfilterfree(scale); return ret; } if ((ret = avfilterinsertfilter(bufferfilter->outputs[0], scale, 0, 0)) < 0) { avfilterfree(scale); return ret; } scale->outputs[0]->timebase = scale->inputs[0]->timebase; scale->outputs[0]->format= c->pixfmt; } else if (!strcmp(scale->filter->name, \"scale\")) { snprintf(scaleparam, sizeof(scaleparam)-1, \"%d:%d:%s\", scale->outputs[0]->w, scale->outputs[0]->h, c->swsparam); scale->filter->init(scale, scaleparam, NULL); } c->pixfmt = scale->inputs[0]->format = picref->format; c->w = scale->inputs[0]->w = picref->video->w; c->h = scale->inputs[0]->h = picref->video->h; link = scale->outputs[0]; if ((ret = link->srcpad->configprops(link)) < 0) return ret; } c->picref = avfiltergetvideobuffer(outlink, AVPERMWRITE, picref->video->w, picref->video->h); avimagecopy(c->picref->data, c->picref->linesize, picref->data, picref->linesize, picref->format, picref->video->w, picref->video->h); avfiltercopybufferrefprops(c->picref, picref); return 0; } ", "target": 1}
{"func": "int ffh264decodepictureparameterset(GetBitContext *gb, AVCodecContext *avctx, H264ParamSets *ps, int bitlength) { AVBufferRef *ppsbuf; const SPS *sps; unsigned int ppsid = getuegolomb(gb); PPS *pps; int qpbdoffset; int bitsleft; int ret; if (ppsid >= MAXPPSCOUNT) { avlog(avctx, AVLOGERROR, \"ppsid %u out of range\\n\", ppsid); return AVERRORINVALIDDATA; ppsbuf = avbufferallocz(sizeof(*pps)); if (!ppsbuf) return AVERROR(ENOMEM); pps = (PPS*)ppsbuf->data; pps->datasize = gb->bufferend - gb->buffer; if (pps->datasize > sizeof(pps->data)) { avlog(avctx, AVLOGWARNING, \"Truncating likely oversized PPS \" \"(%\"SIZESPECIFIER\" > %\"SIZESPECIFIER\")\\n\", pps->datasize, sizeof(pps->data)); pps->datasize = sizeof(pps->data); memcpy(pps->data, gb->buffer, pps->datasize); pps->spsid = getuegolomb31(gb); if ((unsigned)pps->spsid >= MAXSPSCOUNT || !ps->spslist[pps->spsid]) { avlog(avctx, AVLOGERROR, \"spsid %u out of range\\n\", pps->spsid); sps = (const SPS*)ps->spslist[pps->spsid]->data; if (sps->bitdepthluma > 14) { avlog(avctx, AVLOGERROR, \"Invalid luma bit depth=%d\\n\", sps->bitdepthluma); } else if (sps->bitdepthluma == 11 || sps->bitdepthluma == 13) { avlog(avctx, AVLOGERROR, \"Unimplemented luma bit depth=%d\\n\", sps->bitdepthluma); ret = AVERRORPATCHWELCOME; pps->cabac = getbits1(gb); pps->picorderpresent = getbits1(gb); pps->slicegroupcount = getuegolomb(gb) + 1; if (pps->slicegroupcount > 1) { pps->mbslicegroupmaptype = getuegolomb(gb); avlog(avctx, AVLOGERROR, \"FMO not supported\\n\"); switch (pps->mbslicegroupmaptype) { case 0: #if 0 | for (i = 0; i <= numslicegroupsminus1; i++) | | | | runlength[i] |1 |ue(v) | #endif break; case 2: #if 0 | for (i = 0; i < numslicegroupsminus1; i++) { | | | | topleftmb[i] |1 |ue(v) | | bottomrightmb[i] |1 |ue(v) | | } | | | #endif break; case 3: case 4: case 5: #if 0 | slicegroupchangedirectionflag |1 |u(1) | | slicegroupchangerateminus1 |1 |ue(v) | #endif break; case 6: #if 0 | slicegroupidcntminus1 |1 |ue(v) | | for (i = 0; i <= slicegroupidcntminus1; i++)| | | | slicegroupid[i] |1 |u(v) | #endif break; pps->refcount[0] = getuegolomb(gb) + 1; pps->refcount[1] = getuegolomb(gb) + 1; if (pps->refcount[0] - 1 > 32 - 1 || pps->refcount[1] - 1 > 32 - 1) { avlog(avctx, AVLOGERROR, \"reference overflow (pps)\\n\"); qpbdoffset = 6 * (sps->bitdepthluma - 8); pps->weightedpred = getbits1(gb); pps->weightedbipredidc = getbits(gb, 2); pps->initqp = getsegolomb(gb) + 26 + qpbdoffset; pps->initqs = getsegolomb(gb) + 26 + qpbdoffset; pps->chromaqpindexoffset[0] = getsegolomb(gb); pps->deblockingfilterparameterspresent = getbits1(gb); pps->constrainedintrapred = getbits1(gb); pps->redundantpiccntpresent = getbits1(gb); pps->transform8x8mode = 0; memcpy(pps->scalingmatrix4, sps->scalingmatrix4, sizeof(pps->scalingmatrix4)); memcpy(pps->scalingmatrix8, sps->scalingmatrix8, sizeof(pps->scalingmatrix8)); bitsleft = bitlength - getbitscount(gb); if (bitsleft > 0 && morerbspdatainpps(sps, avctx)) { pps->transform8x8mode = getbits1(gb); decodescalingmatrices(gb, sps, pps, 0, pps->scalingmatrix4, pps->scalingmatrix8); // secondchromaqpindexoffset pps->chromaqpindexoffset[1] = getsegolomb(gb); if (pps->chromaqpindexoffset[1] < -12 || pps->chromaqpindexoffset[1] > 12) { } else { pps->chromaqpindexoffset[1] = pps->chromaqpindexoffset[0]; buildqptable(pps, 0, pps->chromaqpindexoffset[0], sps->bitdepthluma); buildqptable(pps, 1, pps->chromaqpindexoffset[1], sps->bitdepthluma); initdequanttables(pps, sps); if (pps->chromaqpindexoffset[0] != pps->chromaqpindexoffset[1]) pps->chromaqpdiff = 1; if (avctx->debug & FFDEBUGPICTINFO) { avlog(avctx, AVLOGDEBUG, \"pps:%u sps:%u %s slicegroups:%d ref:%u/%u %s qp:%d/%d/%d/%d %s %s %s %s\\n\", ppsid, pps->spsid, pps->cabac ? \"CABAC\" : \"CAVLC\", pps->slicegroupcount, pps->refcount[0], pps->refcount[1], pps->weightedpred ? \"weighted\" : \"\", pps->initqp, pps->initqs, pps->chromaqpindexoffset[0], pps->chromaqpindexoffset[1], pps->deblockingfilterparameterspresent ? \"LPAR\" : \"\", pps->constrainedintrapred ? \"CONSTR\" : \"\", pps->redundantpiccntpresent ? \"REDU\" : \"\", pps->transform8x8mode ? \"8x8DCT\" : \"\"); removepps(ps, ppsid); ps->ppslist[ppsid] = ppsbuf; return 0; fail: avbufferunref(&ppsbuf); return ret;", "target": 1}
{"func": "static void qxlspicemonitorsconfigasync(PCIQXLDevice *qxl, int replay) { traceqxlspicemonitorsconfig(qxl->id); if (replay) { /* * don't use QXLCOOKIETYPEIO: * - we are not running yet (postload), we will assert * in sendevents * - this is not a guest io, but a reply, so asyncio isn't set. */ spiceqxlmonitorsconfigasync(&qxl->ssd.qxl, qxl->guestmonitorsconfig, MEMSLOTGROUPGUEST, (uintptrt)qxlcookienew( QXLCOOKIETYPEPOSTLOADMONITORSCONFIG, 0)); } else { #if SPICESERVERVERSION >= 0x000c06 /* release 0.12.6 */ if (qxl->maxoutputs) { spiceqxlsetmonitorsconfiglimit(&qxl->ssd.qxl, qxl->maxoutputs); } #endif qxl->guestmonitorsconfig = qxl->ram->monitorsconfig; spiceqxlmonitorsconfigasync(&qxl->ssd.qxl, qxl->ram->monitorsconfig, MEMSLOTGROUPGUEST, (uintptrt)qxlcookienew(QXLCOOKIETYPEIO, QXLIOMONITORSCONFIGASYNC)); } } ", "target": 1}
{"func": "static void virtionetvhoststatus(VirtIONet *n, uint8t status) { VirtIODevice *vdev = VIRTIODEVICE(n); NetClientState *nc = qemugetqueue(n->nic); int queues = n->multiqueue ? n->maxqueues : 1; if (!getvhostnet(nc->peer)) { return; } if (!!n->vhoststarted == (virtionetstarted(n, status) && !nc->peer->linkdown)) { return; } if (!n->vhoststarted) { int r; if (!vhostnetquery(getvhostnet(nc->peer), vdev)) { return; } n->vhoststarted = 1; r = vhostnetstart(vdev, n->nic->ncs, queues); if (r < 0) { errorreport(\"unable to start vhost net: %d: \" \"falling back on userspace virtio\", -r); n->vhoststarted = 0; } } else { vhostnetstop(vdev, n->nic->ncs, queues); n->vhoststarted = 0; } } ", "target": 0}
{"func": "static void spaprcpucorehostinitfn(Object *obj) { sPAPRCPUCore *core = SPAPRCPUCORE(obj); char *name = gstrdupprintf(\"%s-\" TYPEPOWERPCCPU, \"host\"); ObjectClass *oc = objectclassbyname(name); gassert(oc); gfree((void *)name); core->cpuclass = oc; } ", "target": 0}
{"func": "static void initblockmapping(Vp3DecodeContext *s) { int i, j; signed int hilbertwalky[16]; signed int hilbertwalkc[16]; signed int hilbertwalkmb[4]; int currentfragment = 0; int currentwidth = 0; int currentheight = 0; int rightedge = 0; int bottomedge = 0; int superblockrowinc = 0; int *hilbert = NULL; int mappingindex = 0; int currentmacroblock; int cfragment; signed char travelwidth[16] = { 1, 1, 0, -1, 0, 0, 1, 0, 1, 0, 1, 0, 0, -1, 0, 1 }; signed char travelheight[16] = { 0, 0, 1, 0, 1, 1, 0, -1, 0, 1, 0, -1, -1, 0, -1, 0 }; signed char travelwidthmb[4] = { 1, 0, 1, 0 }; signed char travelheightmb[4] = { 0, 1, 0, -1 }; debugvp3(\" vp3: initialize block mapping tables\\n\"); /* figure out hilbert pattern per these frame dimensions */ hilbertwalky[0] = 1; hilbertwalky[1] = 1; hilbertwalky[2] = s->fragmentwidth; hilbertwalky[3] = -1; hilbertwalky[4] = s->fragmentwidth; hilbertwalky[5] = s->fragmentwidth; hilbertwalky[6] = 1; hilbertwalky[7] = -s->fragmentwidth; hilbertwalky[8] = 1; hilbertwalky[9] = s->fragmentwidth; hilbertwalky[10] = 1; hilbertwalky[11] = -s->fragmentwidth; hilbertwalky[12] = -s->fragmentwidth; hilbertwalky[13] = -1; hilbertwalky[14] = -s->fragmentwidth; hilbertwalky[15] = 1; hilbertwalkc[0] = 1; hilbertwalkc[1] = 1; hilbertwalkc[2] = s->fragmentwidth / 2; hilbertwalkc[3] = -1; hilbertwalkc[4] = s->fragmentwidth / 2; hilbertwalkc[5] = s->fragmentwidth / 2; hilbertwalkc[6] = 1; hilbertwalkc[7] = -s->fragmentwidth / 2; hilbertwalkc[8] = 1; hilbertwalkc[9] = s->fragmentwidth / 2; hilbertwalkc[10] = 1; hilbertwalkc[11] = -s->fragmentwidth / 2; hilbertwalkc[12] = -s->fragmentwidth / 2; hilbertwalkc[13] = -1; hilbertwalkc[14] = -s->fragmentwidth / 2; hilbertwalkc[15] = 1; hilbertwalkmb[0] = 1; hilbertwalkmb[1] = s->macroblockwidth; hilbertwalkmb[2] = 1; hilbertwalkmb[3] = -s->macroblockwidth; /* iterate through each superblock (all planes) and map the fragments */ for (i = 0; i < s->superblockcount; i++) { debuginit(\" superblock %d (u starts @ %d, v starts @ %d)\\n\", i, s->usuperblockstart, s->vsuperblockstart); /* time to re-assign the limits? */ if (i == 0) { /* start of Y superblocks */ rightedge = s->fragmentwidth; bottomedge = s->fragmentheight; currentwidth = 0; currentheight = 0; superblockrowinc = 3 * s->fragmentwidth; hilbert = hilbertwalky; /* the first operation for this variable is to advance by 1 */ currentfragment = -1; } else if (i == s->usuperblockstart) { /* start of U superblocks */ rightedge = s->fragmentwidth / 2; bottomedge = s->fragmentheight / 2; currentwidth = 0; currentheight = 0; superblockrowinc = 3 * (s->fragmentwidth / 2); hilbert = hilbertwalkc; /* the first operation for this variable is to advance by 1 */ currentfragment = s->ufragmentstart - 1; } else if (i == s->vsuperblockstart) { /* start of V superblocks */ rightedge = s->fragmentwidth / 2; bottomedge = s->fragmentheight / 2; currentwidth = 0; currentheight = 0; superblockrowinc = 3 * (s->fragmentwidth / 2); hilbert = hilbertwalkc; /* the first operation for this variable is to advance by 1 */ currentfragment = s->vfragmentstart - 1; } if (currentwidth >= rightedge) { /* reset width and move to next superblock row */ currentwidth = 0; currentheight += 4; /* fragment is now at the start of a new superblock row */ currentfragment += superblockrowinc; } /* iterate through all 16 fragments in a superblock */ for (j = 0; j < 16; j++) { currentfragment += hilbert[j]; currentheight += travelheight[j]; /* check if the fragment is in bounds */ if ((currentwidth <= rightedge) && (currentheight < bottomedge)) { s->superblockfragments[mappingindex] = currentfragment; debuginit(\" mapping fragment %d to superblock %d, position %d\\n\", s->superblockfragments[mappingindex], i, j); } else { s->superblockfragments[mappingindex] = -1; debuginit(\" superblock %d, position %d has no fragment\\n\", i, j); } currentwidth += travelwidth[j]; mappingindex++; } } /* initialize the superblock <-> macroblock mapping; iterate through * all of the Y plane superblocks to build this mapping */ rightedge = s->macroblockwidth; bottomedge = s->macroblockheight; currentwidth = 0; currentheight = 0; superblockrowinc = s->macroblockwidth; hilbert = hilbertwalkmb; mappingindex = 0; currentmacroblock = -1; for (i = 0; i < s->usuperblockstart; i++) { if (currentwidth >= rightedge) { /* reset width and move to next superblock row */ currentwidth = 0; currentheight += 2; /* macroblock is now at the start of a new superblock row */ currentmacroblock += superblockrowinc; } /* iterate through each potential macroblock in the superblock */ for (j = 0; j < 4; j++) { currentmacroblock += hilbertwalkmb[j]; currentheight += travelheightmb[j]; /* check if the macroblock is in bounds */ if ((currentwidth <= rightedge) && (currentheight < bottomedge)) { s->superblockmacroblocks[mappingindex] = currentmacroblock; debuginit(\" mapping macroblock %d to superblock %d, position %d\\n\", s->superblockmacroblocks[mappingindex], i, j); } else { s->superblockmacroblocks[mappingindex] = -1; debuginit(\" superblock %d, position %d has no macroblock\\n\", i, j); } currentwidth += travelwidthmb[j]; mappingindex++; } } /* initialize the macroblock <-> fragment mapping */ currentfragment = 0; currentmacroblock = 0; mappingindex = 0; for (i = 0; i < s->fragmentheight; i += 2) { for (j = 0; j < s->fragmentwidth; j += 2) { debuginit(\" macroblock %d contains fragments: \", currentmacroblock); s->allfragments[currentfragment].macroblock = currentmacroblock; s->macroblockfragments[mappingindex++] = currentfragment; debuginit(\"%d \", currentfragment); if (j + 1 < s->fragmentwidth) { s->allfragments[currentfragment + 1].macroblock = currentmacroblock; s->macroblockfragments[mappingindex++] = currentfragment + 1; debuginit(\"%d \", currentfragment + 1); } else s->macroblockfragments[mappingindex++] = -1; if (i + 1 < s->fragmentheight) { s->allfragments[currentfragment + s->fragmentwidth].macroblock = currentmacroblock; s->macroblockfragments[mappingindex++] = currentfragment + s->fragmentwidth; debuginit(\"%d \", currentfragment + s->fragmentwidth); } else s->macroblockfragments[mappingindex++] = -1; if ((j + 1 < s->fragmentwidth) && (i + 1 < s->fragmentheight)) { s->allfragments[currentfragment + s->fragmentwidth + 1].macroblock = currentmacroblock; s->macroblockfragments[mappingindex++] = currentfragment + s->fragmentwidth + 1; debuginit(\"%d \", currentfragment + s->fragmentwidth + 1); } else s->macroblockfragments[mappingindex++] = -1; /* C planes */ cfragment = s->ufragmentstart + (i * s->fragmentwidth / 4) + (j / 2); s->allfragments[cfragment].macroblock = s->macroblockcount; s->macroblockfragments[mappingindex++] = cfragment; debuginit(\"%d \", cfragment); cfragment = s->vfragmentstart + (i * s->fragmentwidth / 4) + (j / 2); s->allfragments[cfragment].macroblock = s->macroblockcount; s->macroblockfragments[mappingindex++] = cfragment; debuginit(\"%d \", cfragment); debuginit(\"\\n\"); if (j + 2 <= s->fragmentwidth) currentfragment += 2; else currentfragment++; currentmacroblock++; } currentfragment += s->fragmentwidth; } } ", "target": 0}
{"func": "void m68kcpulist(FILE *f, int (*cpufprintf)(FILE *f, const char *fmt, ...)) { unsigned int i; for (i = 0; m68kcpudefs[i].name; i++) { (*cpufprintf)(f, \"%s\\n\", m68kcpudefs[i].name); } } ", "target": 0}
{"func": "int acpipcihpdevicehotplug(AcpiPciHpState *s, PCIDevice *dev, PCIHotplugState state) { int slot = PCISLOT(dev->devfn); int bsel = acpipcihpgetbsel(dev->bus); if (bsel < 0) { return -1; } /* Don't send event when device is enabled during qemu machine creation: * it is present on boot, no hotplug event is necessary. We do send an * event when the device is disabled later. */ if (state == PCICOLDPLUGENABLED) { s->acpipcihppcistatus[bsel].devicepresent |= (1U << slot); return 0; } if (state == PCIHOTPLUGENABLED) { enabledevice(s, bsel, slot); } else { disabledevice(s, bsel, slot); } return 0; } ", "target": 0}
{"func": "static void framestart(H264Context *h){ MpegEncContext * const s = &h->s; int i; MPVframestart(s, s->avctx); fferframestart(s); assert(s->linesize && s->uvlinesize); for(i=0; i<16; i++){ h->blockoffset[i]= 4*((scan8[i] - scan8[0])&7) + 4*s->linesize*((scan8[i] - scan8[0])>>3); h->blockoffset[24+i]= 4*((scan8[i] - scan8[0])&7) + 8*s->linesize*((scan8[i] - scan8[0])>>3); } for(i=0; i<4; i++){ h->blockoffset[16+i]= h->blockoffset[20+i]= 4*((scan8[i] - scan8[0])&7) + 4*s->uvlinesize*((scan8[i] - scan8[0])>>3); h->blockoffset[24+16+i]= h->blockoffset[24+20+i]= 4*((scan8[i] - scan8[0])&7) + 8*s->uvlinesize*((scan8[i] - scan8[0])>>3); } /* can't be in alloctables because linesize isn't known there. * FIXME: redo bipred weight to not require extra buffer? */ if(!s->obmcscratchpad) s->obmcscratchpad = avmalloc(16*s->linesize + 2*8*s->uvlinesize); // s->decode= (s->flags&CODECFLAGPSNR) || !s->encoding || s->currentpicture.reference /*|| h->containsintra*/ || 1; } ", "target": 0}
{"func": "static void testflushnodev(void) { QPCIDevice *dev; QPCIBar bmdmabar, idebar; ideteststart(\"\"); dev = getpcidevice(&bmdmabar, &idebar); /* FLUSH CACHE command on device 0*/ qpciiowriteb(dev, idebar, regdevice, 0); qpciiowriteb(dev, idebar, regcommand, CMDFLUSHCACHE); /* Just testing that qemu doesn't crash... */ idetestquit(); }", "target": 1}
{"func": "void qmpguestfileflush(int64t handle, Error **errp) { GuestFileHandle *gfh = guestfilehandlefind(handle, errp); FILE *fh; int ret; if (!gfh) { return; } fh = gfh->fh; ret = fflush(fh); if (ret == EOF) { errorsetgerrno(errp, errno, \"failed to flush file\"); } }", "target": 1}
{"func": "static void fillcolmap(H264Context *h, int map[2][16+32], int list, int field, int colfield, int mbafi){ MpegEncContext * const s = &h->s; Picture * const ref1 = &h->reflist[1][0]; int j, oldref, rfield; int start= mbafi ? 16 : 0; int end = mbafi ? 16+2*h->refcount[0] : h->refcount[0]; int interl= mbafi || s->picturestructure != PICTFRAME; /* bogus; fills in for missing frames */ memset(map[list], 0, sizeof(map[list])); for(rfield=0; rfield<2; rfield++){ for(oldref=0; oldref<ref1->refcount[colfield][list]; oldref++){ int poc = ref1->refpoc[colfield][list][oldref]; if (!interl) poc |= 3; else if( interl && (poc&3) == 3) //FIXME store all MBAFF references so this isnt needed poc= (poc&~3) + rfield + 1; for(j=start; j<end; j++){ if (4 * h->reflist[0][j].framenum + (h->reflist[0][j].f.reference & 3) == poc) { int curref= mbafi ? (j-16)^field : j; map[list][2*oldref + (rfield^field) + 16] = curref; if(rfield == field || !interl) map[list][oldref] = curref; break; } } } } } ", "target": 0}
{"func": "static void computeframeduration(int *pnum, int *pden, AVFormatContext *s, AVStream *st, AVCodecParserContext *pc, AVPacket *pkt) { int framesize; *pnum = 0; *pden = 0; switch(st->codec.codectype) { case CODECTYPEVIDEO: *pnum = st->codec.frameratebase; *pden = st->codec.framerate; if (pc && pc->repeatpict) { *pden *= 2; *pnum = (*pnum) * (2 + pc->repeatpict); } break; case CODECTYPEAUDIO: framesize = getaudioframesize(&st->codec, pkt->size); if (framesize < 0) break; *pnum = framesize; *pden = st->codec.samplerate; break; default: break; } } ", "target": 0}
{"func": "static int oshostmainloopwait(int64t timeout) { GMainContext *context = gmaincontextdefault(); GPollFD pollfds[1024 * 2]; /* this is probably overkill */ int selectret = 0; int gpollret, ret, i, npollfds; PollingEntry *pe; WaitObjects *w = &waitobjects; gint polltimeout; int64t polltimeoutns; static struct timeval tv0; fdset rfds, wfds, xfds; int nfds; /* XXX: need to suppress polling by better using win32 events */ ret = 0; for (pe = firstpollingentry; pe != NULL; pe = pe->next) { ret |= pe->func(pe->opaque); } if (ret != 0) { return ret; } FDZERO(&rfds); FDZERO(&wfds); FDZERO(&xfds); nfds = pollfdsfill(gpollfds, &rfds, &wfds, &xfds); if (nfds >= 0) { selectret = select(nfds + 1, &rfds, &wfds, &xfds, &tv0); if (selectret != 0) { timeout = 0; } if (selectret > 0) { pollfdspoll(gpollfds, nfds, &rfds, &wfds, &xfds); } } gmaincontextprepare(context, &maxpriority); npollfds = gmaincontextquery(context, maxpriority, &polltimeout, pollfds, ARRAYSIZE(pollfds)); gassert(npollfds <= ARRAYSIZE(pollfds)); for (i = 0; i < w->num; i++) { pollfds[npollfds + i].fd = (DWORDPTR)w->events[i]; pollfds[npollfds + i].events = GIOIN; } if (polltimeout < 0) { polltimeoutns = -1; } else { polltimeoutns = (int64t)polltimeout * (int64t)SCALEMS; } polltimeoutns = qemusoonesttimeout(polltimeoutns, timeout); qemumutexunlockiothread(); gpollret = qemupollns(pollfds, npollfds + w->num, polltimeoutns); qemumutexlockiothread(); if (gpollret > 0) { for (i = 0; i < w->num; i++) { w->revents[i] = pollfds[npollfds + i].revents; } for (i = 0; i < w->num; i++) { if (w->revents[i] && w->func[i]) { w->func[i](w->opaque[i]); } } } if (gmaincontextcheck(context, maxpriority, pollfds, npollfds)) { gmaincontextdispatch(context); } return selectret || gpollret; }", "target": 1}
{"func": "int bdrvsnapshotdelete(BlockDriverState *bs, const char *snapshotid) { BlockDriver *drv = bs->drv; if (!drv) { return -ENOMEDIUM; } if (drv->bdrvsnapshotdelete) { return drv->bdrvsnapshotdelete(bs, snapshotid); } if (bs->file) { return bdrvsnapshotdelete(bs->file, snapshotid); } return -ENOTSUP; } ", "target": 1}
{"func": "static uint32t pciapbioreadl (void *opaque, targetphysaddrt addr) { uint32t val; val = bswap32(cpuinl(addr & IOPORTSMASK)); return val; } ", "target": 0}
{"func": "static void qemufillbuffer(QEMUFile *f) { int len; if (f->iswritable) return; if (f->isfile) { fseek(f->outfile, f->bufoffset, SEEKSET); len = fread(f->buf, 1, IOBUFSIZE, f->outfile); if (len < 0) len = 0; } else { len = bdrvpread(f->bs, f->baseoffset + f->bufoffset, f->buf, IOBUFSIZE); if (len < 0) len = 0; } f->bufindex = 0; f->bufsize = len; f->bufoffset += len; } ", "target": 0}
{"func": "void nethubcheckclients(void) { NetHub *hub; NetHubPort *port; NetClientState *peer; QLISTFOREACH(hub, &hubs, next) { int hasnic = 0, hashostdev = 0; QLISTFOREACH(port, &hub->ports, next) { peer = port->nc.peer; if (!peer) { fprintf(stderr, \"Warning: hub port %s has no peer\\n\", port->nc.name); continue; } switch (peer->info->type) { case NETCLIENTDRIVERNIC: hasnic = 1; break; case NETCLIENTDRIVERUSER: case NETCLIENTDRIVERTAP: case NETCLIENTDRIVERSOCKET: case NETCLIENTDRIVERVDE: case NETCLIENTDRIVERVHOSTUSER: hashostdev = 1; break; default: break; } } if (hashostdev && !hasnic) { warnreport(\"vlan %d with no nics\", hub->id); } if (hasnic && !hashostdev) { fprintf(stderr, \"Warning: vlan %d is not connected to host network\\n\", hub->id); } } } ", "target": 0}
{"func": "DVDemuxContext* dvinitdemux(AVFormatContext *s) { DVDemuxContext *c; c = avmallocz(sizeof(DVDemuxContext)); if (!c) return NULL; c->vst = avnewstream(s, 0); c->ast[0] = avnewstream(s, 0); if (!c->vst || !c->ast[0]) goto fail; avsetptsinfo(c->vst, 64, 1, 30000); avsetptsinfo(c->ast[0], 64, 1, 30000); c->fctx = s; c->ast[1] = NULL; c->ach = 0; c->frames = 0; c->abytes = 0; c->audiopkt[0].size = 0; c->audiopkt[1].size = 0; c->vst->codec.codectype = CODECTYPEVIDEO; c->vst->codec.codecid = CODECIDDVVIDEO; c->vst->codec.bitrate = 25000000; c->ast[0]->codec.codectype = CODECTYPEAUDIO; c->ast[0]->codec.codecid = CODECIDPCMS16LE; s->ctxflags |= AVFMTCTXNOHEADER; return c; fail: if (c->vst) avfree(c->vst); if (c->ast[0]) avfree(c->ast[0]); avfree(c); return NULL; } ", "target": 0}
{"func": "static int coroutinefn bdrvcodopwritezeroes(BlockDriverState *bs, int64t offset, int bytes, BdrvRequestFlags flags) { BlockDriver *drv = bs->drv; QEMUIOVector qiov; struct iovec iov = {0}; int ret = 0; bool needflush = false; int head = 0; int tail = 0; int maxwritezeroes = MINNONZERO(bs->bl.maxpwritezeroes, INTMAX); int alignment = MAX(bs->bl.pwritezeroesalignment, bs->bl.requestalignment); int maxtransfer = MINNONZERO(bs->bl.maxtransfer, MAXWRITEZEROESBOUNCEBUFFER); assert(alignment % bs->bl.requestalignment == 0); head = offset % alignment; tail = (offset + bytes) % alignment; maxwritezeroes = QEMUALIGNDOWN(maxwritezeroes, alignment); assert(maxwritezeroes >= bs->bl.requestalignment); while (bytes > 0 && !ret) { int num = bytes; /* Align request. Block drivers can expect the \"bulk\" of the request * to be aligned, and that unaligned requests do not cross cluster * boundaries. */ if (head) { /* Make a small request up to the first aligned sector. For * convenience, limit this request to maxtransfer even if * we don't need to fall back to writes. */ num = MIN(MIN(bytes, maxtransfer), alignment - head); head = (head + num) % alignment; assert(num < maxwritezeroes); } else if (tail && num > alignment) { /* Shorten the request to the last aligned sector. */ num -= tail; } /* limit request size */ if (num > maxwritezeroes) { num = maxwritezeroes; } ret = -ENOTSUP; /* First try the efficient write zeroes operation */ if (drv->bdrvcopwritezeroes) { ret = drv->bdrvcopwritezeroes(bs, offset, num, flags & bs->supportedzeroflags); if (ret != -ENOTSUP && (flags & BDRVREQFUA) && !(bs->supportedzeroflags & BDRVREQFUA)) { needflush = true; } } else { assert(!bs->supportedzeroflags); } if (ret == -ENOTSUP) { /* Fall back to bounce buffer if write zeroes is unsupported */ BdrvRequestFlags writeflags = flags & ~BDRVREQZEROWRITE; if ((flags & BDRVREQFUA) && !(bs->supportedwriteflags & BDRVREQFUA)) { /* No need for bdrvdriverpwrite() to do a fallback * flush on each chunk; use just one at the end */ writeflags &= ~BDRVREQFUA; needflush = true; } num = MIN(num, maxtransfer); iov.iovlen = num; if (iov.iovbase == NULL) { iov.iovbase = qemutryblockalign(bs, num); if (iov.iovbase == NULL) { ret = -ENOMEM; goto fail; } memset(iov.iovbase, 0, num); } qemuiovecinitexternal(&qiov, &iov, 1); ret = bdrvdriverpwritev(bs, offset, num, &qiov, writeflags); /* Keep bounce buffer around if it is big enough for all * all future requests. */ if (num < maxtransfer) { qemuvfree(iov.iovbase); iov.iovbase = NULL; } } offset += num; bytes -= num; } fail: if (ret == 0 && needflush) { ret = bdrvcoflush(bs); } qemuvfree(iov.iovbase); return ret; } ", "target": 0}
{"func": "static void openpicsaveIRQqueue(QEMUFile* f, IRQQueue *q) { unsigned int i; for (i = 0; i < BFWIDTH(MAXIRQ); i++) qemuputbe32s(f, &q->queue[i]); qemuputsbe32s(f, &q->next); qemuputsbe32s(f, &q->priority); } ", "target": 0}
{"func": "static EHCIQueue *ehcistatefetchqh(EHCIState *ehci, int async) { uint32t entry; EHCIQueue *q; int reload; entry = ehcigetfetchaddr(ehci, async); q = ehcifindqueuebyqh(ehci, entry); if (NULL == q) { q = ehciallocqueue(ehci, async); } q->qhaddr = entry; q->seen++; if (q->seen > 1) { /* we are going in circles -- stop processing */ ehcisetstate(ehci, async, ESTACTIVE); q = NULL; goto out; } getdwords(NLPTRGET(q->qhaddr), (uint32t *) &q->qh, sizeof(EHCIqh) >> 2); ehcitraceqh(q, NLPTRGET(q->qhaddr), &q->qh); if (q->async == EHCIASYNCINFLIGHT) { /* I/O still in progress -- skip queue */ ehcisetstate(ehci, async, ESTHORIZONTALQH); goto out; } if (q->async == EHCIASYNCFINISHED) { /* I/O finished -- continue processing queue */ traceusbehciqueueaction(q, \"resume\"); ehcisetstate(ehci, async, ESTEXECUTING); goto out; } if (async && (q->qh.epchar & QHEPCHARH)) { /* EHCI spec version 1.0 Section 4.8.3 & 4.10.1 */ if (ehci->usbsts & USBSTSREC) { ehciclearusbsts(ehci, USBSTSREC); } else { DPRINTF(\"FETCHQH: QH 0x%08x. H-bit set, reclamation status reset\" \" - done processing\\n\", q->qhaddr); ehcisetstate(ehci, async, ESTACTIVE); q = NULL; goto out; } } #if EHCIDEBUG if (q->qhaddr != q->qh.next) { DPRINTF(\"FETCHQH: QH 0x%08x (h %x halt %x active %x) next 0x%08x\\n\", q->qhaddr, q->qh.epchar & QHEPCHARH, q->qh.token & QTDTOKENHALT, q->qh.token & QTDTOKENACTIVE, q->qh.next); } #endif reload = getfield(q->qh.epchar, QHEPCHARRL); if (reload) { setfield(&q->qh.altnextqtd, reload, QHALTNEXTNAKCNT); } if (q->qh.token & QTDTOKENHALT) { ehcisetstate(ehci, async, ESTHORIZONTALQH); } else if ((q->qh.token & QTDTOKENACTIVE) && (q->qh.currentqtd > 0x1000)) { q->qtdaddr = q->qh.currentqtd; ehcisetstate(ehci, async, ESTFETCHQTD); } else { /* EHCI spec version 1.0 Section 4.10.2 */ ehcisetstate(ehci, async, ESTADVANCEQUEUE); } out: return q; } ", "target": 0}
{"func": "static void omaprtcreset(struct omaprtcs *s) { struct tm tm; s->interrupts = 0; s->compreg = 0; s->running = 0; s->pmam = 0; s->autocomp = 0; s->round = 0; s->tick = qemugetclock(rtclock); memset(&s->alarmtm, 0, sizeof(s->alarmtm)); s->alarmtm.tmmday = 0x01; s->status = 1 << 7; qemugettimedate(&tm, 0); s->ti = mktimegm(&tm); omaprtcalarmupdate(s); omaprtctick(s); } ", "target": 0}
{"func": "static void tosainit(MachineState *machine) { const char *cpumodel = machine->cpumodel; const char *kernelfilename = machine->kernelfilename; const char *kernelcmdline = machine->kernelcmdline; const char *initrdfilename = machine->initrdfilename; MemoryRegion *addressspacemem = getsystemmemory(); MemoryRegion *rom = gnew(MemoryRegion, 1); PXA2xxState *mpu; TC6393xbState *tmio; DeviceState *scp0, *scp1; if (!cpumodel) cpumodel = \"pxa255\"; mpu = pxa255init(addressspacemem, tosabinfo.ramsize); memoryregioninitram(rom, NULL, \"tosa.rom\", TOSAROM, &errorabort); vmstateregisterramglobal(rom); memoryregionsetreadonly(rom, true); memoryregionaddsubregion(addressspacemem, 0, rom); tmio = tc6393xbinit(addressspacemem, 0x10000000, qdevgetgpioin(mpu->gpio, TOSAGPIOTC6393XBINT)); scp0 = sysbuscreatesimple(\"scoop\", 0x08800000, NULL); scp1 = sysbuscreatesimple(\"scoop\", 0x14800040, NULL); tosagpiosetup(mpu, scp0, scp1, tmio); tosamicrodriveattach(mpu); tosatginit(mpu); tosabinfo.kernelfilename = kernelfilename; tosabinfo.kernelcmdline = kernelcmdline; tosabinfo.initrdfilename = initrdfilename; tosabinfo.boardid = 0x208; armloadkernel(mpu->cpu, &tosabinfo); slbootparamwrite(SLPXAPARAMBASE); } ", "target": 1}
{"func": "static void getsensorevtenable(IPMIBmcSim *ibs, uint8t *cmd, unsigned int cmdlen, uint8t *rsp, unsigned int *rsplen, unsigned int maxrsplen) { IPMISensor *sens; IPMICHECKCMDLEN(3); if ((cmd[2] > MAXSENSORS) || !IPMISENSORGETPRESENT(ibs->sensors + cmd[2])) { rsp[2] = IPMICCREQENTRYNOTPRESENT; return; } sens = ibs->sensors + cmd[2]; IPMIADDRSPDATA(IPMISENSORGETRETSTATUS(sens)); IPMIADDRSPDATA(sens->assertenable & 0xff); IPMIADDRSPDATA((sens->assertenable >> 8) & 0xff); IPMIADDRSPDATA(sens->deassertenable & 0xff); IPMIADDRSPDATA((sens->deassertenable >> 8) & 0xff); } ", "target": 1}
{"func": "struct omapuarts *omapuartinit(hwaddr base, qemuirq irq, omapclk fclk, omapclk iclk, qemuirq txdma, qemuirq rxdma, const char *label, CharDriverState *chr) { struct omapuarts *s = (struct omapuarts *) gmalloc0(sizeof(struct omapuarts)); s->base = base; s->fclk = fclk; s->irq = irq; s->serial = serialmminit(getsystemmemory(), base, 2, irq, omapclkgetrate(fclk)/16, chr ?: qemuchrnew(label, \"null\", NULL), DEVICENATIVEENDIAN); return s; } ", "target": 1}
{"func": "static int createdynamicdisk(int fd, uint8t *buf, int64t totalsectors) { VHDDynDiskHeader *dyndiskheader = (VHDDynDiskHeader *) buf; sizet blocksize, numbatentries; int i; int ret = -EIO; // Write the footer (twice: at the beginning and at the end) blocksize = 0x200000; numbatentries = (totalsectors + blocksize / 512) / (blocksize / 512); if (write(fd, buf, HEADERSIZE) != HEADERSIZE) { goto fail; } if (lseek(fd, 1536 + ((numbatentries * 4 + 511) & ~511), SEEKSET) < 0) { goto fail; } if (write(fd, buf, HEADERSIZE) != HEADERSIZE) { goto fail; } // Write the initial BAT if (lseek(fd, 3 * 512, SEEKSET) < 0) { goto fail; } memset(buf, 0xFF, 512); for (i = 0; i < (numbatentries * 4 + 511) / 512; i++) { if (write(fd, buf, 512) != 512) { goto fail; } } // Prepare the Dynamic Disk Header memset(buf, 0, 1024); memcpy(dyndiskheader->magic, \"cxsparse\", 8); /* * Note: The spec is actually wrong here for dataoffset, it says * 0xFFFFFFFF, but MS tools expect all 64 bits to be set. */ dyndiskheader->dataoffset = be64tocpu(0xFFFFFFFFFFFFFFFFULL); dyndiskheader->tableoffset = be64tocpu(3 * 512); dyndiskheader->version = be32tocpu(0x00010000); dyndiskheader->blocksize = be32tocpu(blocksize); dyndiskheader->maxtableentries = be32tocpu(numbatentries); dyndiskheader->checksum = be32tocpu(vpcchecksum(buf, 1024)); // Write the header if (lseek(fd, 512, SEEKSET) < 0) { goto fail; } if (write(fd, buf, 1024) != 1024) { goto fail; } ret = 0; fail: return ret; } ", "target": 0}
{"func": "static int qemurbdsnaplist(BlockDriverState *bs, QEMUSnapshotInfo **psntab) { BDRVRBDState *s = bs->opaque; QEMUSnapshotInfo *sninfo, *sntab = NULL; int i, snapcount; rbdsnapinfot *snaps; int maxsnaps = RBDMAXSNAPS; do { snaps = gmalloc(sizeof(*snaps) * maxsnaps); snapcount = rbdsnaplist(s->image, snaps, &maxsnaps); if (snapcount < 0) { gfree(snaps); } } while (snapcount == -ERANGE); if (snapcount <= 0) { return snapcount; } sntab = gmalloc0(snapcount * sizeof(QEMUSnapshotInfo)); for (i = 0; i < snapcount; i++) { const char *snapname = snaps[i].name; sninfo = sntab + i; pstrcpy(sninfo->idstr, sizeof(sninfo->idstr), snapname); pstrcpy(sninfo->name, sizeof(sninfo->name), snapname); sninfo->vmstatesize = snaps[i].size; sninfo->datesec = 0; sninfo->datensec = 0; sninfo->vmclocknsec = 0; } rbdsnaplistend(snaps); *psntab = sntab; return snapcount; } ", "target": 0}
{"func": "static bool getphysaddrpmsav8(CPUARMState *env, uint32t address, MMUAccessType accesstype, ARMMMUIdx mmuidx, hwaddr *physptr, int *prot, uint32t *fsr) { ARMCPU *cpu = armenvgetcpu(env); bool isuser = regimeisuser(env, mmuidx); int n; int matchregion = -1; bool hit = false; *physptr = address; *prot = 0; /* Unlike the ARM ARM pseudocode, we don't need to check whether this * was an exception vector read from the vector table (which is always * done using the default system address map), because those accesses * are done in armv7mloadvector(), which always does a direct * read using addressspaceldl(), rather than going via this function. */ if (regimetranslationdisabled(env, mmuidx)) { /* MPU disabled */ hit = true; } else if (misppbregion(env, address)) { hit = true; } else if (pmsav7usebackgroundregion(cpu, mmuidx, isuser)) { hit = true; } else { for (n = (int)cpu->pmsav7dregion - 1; n >= 0; n--) { /* region search */ /* Note that the base address is bits [31:5] from the register * with bits [4:0] all zeroes, but the limit address is bits * [31:5] from the register with bits [4:0] all ones. */ uint32t base = env->pmsav8.rbar[n] & ~0x1f; uint32t limit = env->pmsav8.rlar[n] | 0x1f; if (!(env->pmsav8.rlar[n] & 0x1)) { /* Region disabled */ continue; } if (address < base || address > limit) { continue; } if (hit) { /* Multiple regions match -- always a failure (unlike * PMSAv7 where highest-numbered-region wins) */ *fsr = 0x00d; /* permission fault */ return true; } matchregion = n; hit = true; if (base & ~TARGETPAGEMASK) { qemulogmask(LOGUNIMP, \"MPURBAR[%d]: No support for MPU region base\" \"address of 0x%\" PRIx32 \". Minimum alignment is \" \"%d\\n\", n, base, TARGETPAGEBITS); continue; } if ((limit + 1) & ~TARGETPAGEMASK) { qemulogmask(LOGUNIMP, \"MPURBAR[%d]: No support for MPU region limit\" \"address of 0x%\" PRIx32 \". Minimum alignment is \" \"%d\\n\", n, limit, TARGETPAGEBITS); continue; } } } if (!hit) { /* background fault */ *fsr = 0; return true; } if (matchregion == -1) { /* hit using the background region */ getphysaddrpmsav7default(env, mmuidx, address, prot); } else { uint32t ap = extract32(env->pmsav8.rbar[matchregion], 1, 2); uint32t xn = extract32(env->pmsav8.rbar[matchregion], 0, 1); if (missystemregion(env, address)) { /* System space is always execute never */ xn = 1; } *prot = simpleaptorwprot(env, mmuidx, ap); if (*prot && !xn) { *prot |= PAGEEXEC; } /* We don't need to look the attribute up in the MAIR0/MAIR1 * registers because that only tells us about cacheability. */ } *fsr = 0x00d; /* Permission fault */ return !(*prot & (1 << accesstype)); } ", "target": 0}
{"func": "static int v9fsxattrread(V9fsState *s, V9fsPDU *pdu, V9fsFidState *fidp, uint64t off, uint32t maxcount) { ssizet err; sizet offset = 7; int readcount; int64t xattrlen; V9fsVirtioState *v = containerof(s, V9fsVirtioState, state); VirtQueueElement *elem = v->elems[pdu->idx]; xattrlen = fidp->fs.xattr.len; readcount = xattrlen - off; if (readcount > maxcount) { readcount = maxcount; } else if (readcount < 0) { /* * read beyond XATTR value */ readcount = 0; } err = pdumarshal(pdu, offset, \"d\", readcount); if (err < 0) { return err; } offset += err; err = v9fspack(elem->insg, elem->innum, offset, ((char *)fidp->fs.xattr.value) + off, readcount); if (err < 0) { return err; } offset += err; return offset; } ", "target": 1}
{"func": "static coroutinefn int vmdkcowrite(BlockDriverState *bs, int64t sectornum, const uint8t *buf, int nbsectors) { int ret; BDRVVmdkState *s = bs->opaque; qemucomutexlock(&s->lock); ret = vmdkwrite(bs, sectornum, buf, nbsectors); qemucomutexunlock(&s->lock); return ret; } ", "target": 1}
{"func": "int xbzrleencodebuffer(uint8t *oldbuf, uint8t *newbuf, int slen, uint8t *dst, int dlen) { uint32t zrunlen = 0, nzrunlen = 0; int d = 0, i = 0; long res, xor; uint8t *nzrunstart = NULL; gassert(!(((uintptrt)oldbuf | (uintptrt)newbuf | slen) % sizeof(long))); while (i < slen) { /* overflow */ if (d + 2 > dlen) { return -1; } /* not aligned to sizeof(long) */ res = (slen - i) % sizeof(long); while (res && oldbuf[i] == newbuf[i]) { zrunlen++; i++; res--; } /* word at a time for speed */ if (!res) { while (i < slen && (*(long *)(oldbuf + i)) == (*(long *)(newbuf + i))) { i += sizeof(long); zrunlen += sizeof(long); } /* go over the rest */ while (i < slen && oldbuf[i] == newbuf[i]) { zrunlen++; i++; } } /* buffer unchanged */ if (zrunlen == slen) { return 0; } /* skip last zero run */ if (i == slen) { return d; } d += uleb128encodesmall(dst + d, zrunlen); zrunlen = 0; nzrunstart = newbuf + i; /* overflow */ if (d + 2 > dlen) { return -1; } /* not aligned to sizeof(long) */ res = (slen - i) % sizeof(long); while (res && oldbuf[i] != newbuf[i]) { i++; nzrunlen++; res--; } /* word at a time for speed, use of 32-bit long okay */ if (!res) { /* truncation to 32-bit long okay */ long mask = (long)0x0101010101010101ULL; while (i < slen) { xor = *(long *)(oldbuf + i) ^ *(long *)(newbuf + i); if ((xor - mask) & ~xor & (mask << 7)) { /* found the end of an nzrun within the current long */ while (oldbuf[i] != newbuf[i]) { nzrunlen++; i++; } break; } else { i += sizeof(long); nzrunlen += sizeof(long); } } } d += uleb128encodesmall(dst + d, nzrunlen); /* overflow */ if (d + nzrunlen > dlen) { return -1; } memcpy(dst + d, nzrunstart, nzrunlen); d += nzrunlen; nzrunlen = 0; } return d; } ", "target": 1}
{"func": "static avcold void initatrac3transforms(ATRAC3Context *q) { float encwindow[256]; int i; /* Generate the mdct window, for details see * http://wiki.multimedia.cx/index.php?title=RealAudioatrc#Windows */ for (i=0 ; i<256; i++) encwindow[i] = (sin(((i + 0.5) / 256.0 - 0.5) * MPI) + 1.0) * 0.5; if (!mdctwindow[0]) for (i=0 ; i<256; i++) { mdctwindow[i] = encwindow[i]/(encwindow[i]*encwindow[i] + encwindow[255-i]*encwindow[255-i]); mdctwindow[511-i] = mdctwindow[i]; } /* Initialize the MDCT transform. */ ffmdctinit(&mdctctx, 9, 1, 1.0); } ", "target": 1}
{"func": "static void gdresize(DisplayChangeListener *dcl, DisplayState *ds) { GtkDisplayState *s = ds->opaque; cairoformatt kind; int stride; DPRINTF(\"resize(width=%d, height=%d)\\n\", dsgetwidth(ds), dsgetheight(ds)); if (s->surface) { cairosurfacedestroy(s->surface); } switch (ds->surface->pf.bitsperpixel) { case 8: kind = CAIROFORMATA8; break; case 16: kind = CAIROFORMATRGB16565; break; case 32: kind = CAIROFORMATRGB24; break; default: gassertnotreached(); break; } stride = cairoformatstrideforwidth(kind, dsgetwidth(ds)); gassert(dsgetlinesize(ds) == stride); s->surface = cairoimagesurfacecreatefordata(dsgetdata(ds), kind, dsgetwidth(ds), dsgetheight(ds), dsgetlinesize(ds)); if (!s->fullscreen) { GtkRequisition req; double sx, sy; if (s->freescale) { sx = s->scalex; sy = s->scaley; s->scaley = 1.0; s->scalex = 1.0; } else { sx = 1.0; sy = 1.0; } gtkwidgetsetsizerequest(s->drawingarea, dsgetwidth(ds) * s->scalex, dsgetheight(ds) * s->scaley); #if GTKCHECKVERSION(3, 0, 0) gtkwidgetgetpreferredsize(s->vbox, NULL, &req); #else gtkwidgetsizerequest(s->vbox, &req); #endif gtkwindowresize(GTKWINDOW(s->window), req.width * sx, req.height * sy); } } ", "target": 1}
{"func": "void lm32juartsetjtx(DeviceState *d, uint32t jtx) { LM32JuartState *s = LM32JUART(d); unsigned char ch = jtx & 0xff; tracelm32juartsetjtx(s->jtx); s->jtx = jtx; if (s->chr) { qemuchrfewriteall(s->chr, &ch, 1); } }", "target": 1}
{"func": "static void matroskafixasspacket(MatroskaDemuxContext *matroska, AVPacket *pkt, uint64t displayduration) { char *line, *layer, *ptr = pkt->data, *end = ptr+pkt->size; for (; *ptr!=',' && ptr<end-1; ptr++); if (*ptr == ',') layer = ++ptr; for (; *ptr!=',' && ptr<end-1; ptr++); if (*ptr == ',') { int64t endpts = pkt->pts + displayduration; int sc = matroska->timescale * pkt->pts / 10000000; int ec = matroska->timescale * endpts / 10000000; int sh, sm, ss, eh, em, es, len; sh = sc/360000; sc -= 360000*sh; sm = sc/ 6000; sc -= 6000*sm; ss = sc/ 100; sc -= 100*ss; eh = ec/360000; ec -= 360000*eh; em = ec/ 6000; ec -= 6000*em; es = ec/ 100; ec -= 100*es; *ptr++ = '\\0'; len = 50 + end-ptr + FFINPUTBUFFERPADDINGSIZE; if (!(line = avmalloc(len))) return; snprintf(line,len,\"Dialogue: %s,%d:%02d:%02d.%02d,%d:%02d:%02d.%02d,%s\", layer, sh, sm, ss, sc, eh, em, es, ec, ptr); avfree(pkt->data); pkt->data = line; pkt->size = strlen(line); } } ", "target": 1}
{"func": "sendmsg( VSCMsgType type, uint32t readerid, const void *msg, unsigned int length ) { VSCMsgHeader mhHeader; qemumutexlock(&sockettosendlock); if (verbose > 10) { printf(\"sending type=%d id=%u, len =%u (0x%x)\\n\", type, readerid, length, length); } mhHeader.type = htonl(type); mhHeader.readerid = 0; mhHeader.length = htonl(length); gbytearrayappend(sockettosend, (guint8 *)&mhHeader, sizeof(mhHeader)); gbytearrayappend(sockettosend, (guint8 *)msg, length); gidleadd(socketpreparesending, NULL); qemumutexunlock(&sockettosendlock); return 0; } ", "target": 0}
{"func": "void FUNCC(ffh264idctdcadd)(uint8t *dst, int16t *block, int stride){ int i, j; int dc = (((dctcoef*)block)[0] + 32) >> 6; pixel *dst = (pixel*)dst; stride >>= sizeof(pixel)-1; for( j = 0; j < 4; j++ ) { for( i = 0; i < 4; i++ ) dst[i] = avclippixel( dst[i] + dc ); dst += stride; } } ", "target": 0}
{"func": "static int encodepicturels(AVCodecContext *avctx, AVPacket *pkt, const AVFrame *pict, int *gotpacket) { const AVFrame *const p = pict; const int near = avctx->predictionmethod; PutBitContext pb, pb2; GetBitContext gb; uint8t *buf2 = NULL; uint8t *zero = NULL; uint8t *cur = NULL; uint8t *last = NULL; JLSState *state; int i, size, ret; int comps; if (avctx->pixfmt == AVPIXFMTGRAY8 || avctx->pixfmt == AVPIXFMTGRAY16) comps = 1; else comps = 3; if ((ret = ffallocpacket(pkt, avctx->width * avctx->height * comps * 4 + AVINPUTBUFFERMINSIZE)) < 0) { avlog(avctx, AVLOGERROR, \"Error getting output packet.\\n\"); return ret; } buf2 = avmalloc(pkt->size); if (!buf2) goto memfail; initputbits(&pb, pkt->data, pkt->size); initputbits(&pb2, buf2, pkt->size); /* write our own JPEG header, can't use mjpegpictureheader */ putmarker(&pb, SOI); putmarker(&pb, SOF48); putbits(&pb, 16, 8 + comps * 3); // header size depends on components putbits(&pb, 8, (avctx->pixfmt == AVPIXFMTGRAY16) ? 16 : 8); // bpp putbits(&pb, 16, avctx->height); putbits(&pb, 16, avctx->width); putbits(&pb, 8, comps); // components for (i = 1; i <= comps; i++) { putbits(&pb, 8, i); // component ID putbits(&pb, 8, 0x11); // subsampling: none putbits(&pb, 8, 0); // Tiq, used by JPEG-LS ext } putmarker(&pb, SOS); putbits(&pb, 16, 6 + comps * 2); putbits(&pb, 8, comps); for (i = 1; i <= comps; i++) { putbits(&pb, 8, i); // component ID putbits(&pb, 8, 0); // mapping index: none } putbits(&pb, 8, near); putbits(&pb, 8, (comps > 1) ? 1 : 0); // interleaving: 0 - plane, 1 - line putbits(&pb, 8, 0); // point transform: none state = avmallocz(sizeof(JLSState)); if (!state) goto memfail; /* initialize JPEG-LS state from JPEG parameters */ state->near = near; state->bpp = (avctx->pixfmt == AVPIXFMTGRAY16) ? 16 : 8; ffjpeglsresetcodingparameters(state, 0); ffjpeglsinitstate(state); lsstorelse(state, &pb); zero = last = avmallocz(p->linesize[0]); if (!zero) goto memfail; cur = p->data[0]; if (avctx->pixfmt == AVPIXFMTGRAY8) { int t = 0; for (i = 0; i < avctx->height; i++) { lsencodeline(state, &pb2, last, cur, t, avctx->width, 1, 0, 8); t = last[0]; last = cur; cur += p->linesize[0]; } } else if (avctx->pixfmt == AVPIXFMTGRAY16) { int t = 0; for (i = 0; i < avctx->height; i++) { lsencodeline(state, &pb2, last, cur, t, avctx->width, 1, 0, 16); t = *((uint16t *)last); last = cur; cur += p->linesize[0]; } } else if (avctx->pixfmt == AVPIXFMTRGB24) { int j, width; int Rc[3] = { 0, 0, 0 }; width = avctx->width * 3; for (i = 0; i < avctx->height; i++) { for (j = 0; j < 3; j++) { lsencodeline(state, &pb2, last + j, cur + j, Rc[j], width, 3, j, 8); Rc[j] = last[j]; } last = cur; cur += p->linesize[0]; } } else if (avctx->pixfmt == AVPIXFMTBGR24) { int j, width; int Rc[3] = { 0, 0, 0 }; width = avctx->width * 3; for (i = 0; i < avctx->height; i++) { for (j = 2; j >= 0; j--) { lsencodeline(state, &pb2, last + j, cur + j, Rc[j], width, 3, j, 8); Rc[j] = last[j]; } last = cur; cur += p->linesize[0]; } } avfreep(&zero); avfreep(&state); /* the specification says that after doing 0xff escaping unused bits in * the last byte must be set to 0, so just append 7 \"optional\" zero-bits * to avoid special-casing. */ putbits(&pb2, 7, 0); size = putbitscount(&pb2); flushputbits(&pb2); /* do escape coding */ initgetbits(&gb, buf2, size); size -= 7; while (getbitscount(&gb) < size) { int v; v = getbits(&gb, 8); putbits(&pb, 8, v); if (v == 0xFF) { v = getbits(&gb, 7); putbits(&pb, 8, v); } } avprivalignputbits(&pb); avfreep(&buf2); /* End of image */ putmarker(&pb, EOI); flushputbits(&pb); emmsc(); pkt->size = putbitscount(&pb) >> 3; pkt->flags |= AVPKTFLAGKEY; *gotpacket = 1; return 0; memfail: avpacketunref(pkt); avfreep(&buf2); avfreep(&state); avfreep(&zero); return AVERROR(ENOMEM); } ", "target": 0}
{"func": "void ffvc1decodeblocks(VC1Context *v) { v->s.esc3levellength = 0; if (v->x8type) { ffintrax8decodepicture(&v->x8, 2*v->pq + v->halfpq, v->pq * !v->pquantizer); fferaddslice(&v->s.er, 0, 0, (v->s.mbx >> 1) - 1, (v->s.mby >> 1) - 1, ERMBEND); } else { v->curblkidx = 0; v->leftblkidx = -1; v->topleftblkidx = 1; v->topblkidx = 2; switch (v->s.picttype) { case AVPICTURETYPEI: if (v->profile == PROFILEADVANCED) vc1decodeiblocksadv(v); else vc1decodeiblocks(v); break; case AVPICTURETYPEP: if (v->pframeskipped) vc1decodeskipblocks(v); else vc1decodepblocks(v); break; case AVPICTURETYPEB: if (v->bitype) { if (v->profile == PROFILEADVANCED) vc1decodeiblocksadv(v); else vc1decodeiblocks(v); } else vc1decodebblocks(v); break; } } } ", "target": 0}
{"func": "paintmousepointer(XImage *image, struct x11grab *s) { int xoff = s->xoff; int yoff = s->yoff; int width = s->width; int height = s->height; Display *dpy = s->dpy; XFixesCursorImage *xcim; int x, y; int line, column; int toline, tocolumn; int imageaddr, xcimaddr; xcim = XFixesGetCursorImage(dpy); x = xcim->x - xcim->xhot; y = xcim->y - xcim->yhot; toline = FFMIN((y + xcim->height), (height + yoff)); tocolumn = FFMIN((x + xcim->width), (width + xoff)); for (line = FFMAX(y, yoff); line < toline; line++) { for (column = FFMAX(x, xoff); column < tocolumn; column++) { xcimaddr = (line - y) * xcim->width + column - x; if ((unsigned char)(xcim->pixels[xcimaddr] >> 24) != 0) { // skip fully transparent pixel imageaddr = ((line - yoff) * width + column - xoff) * 4; image->data[imageaddr] = (unsigned char)(xcim->pixels[xcimaddr] >> 0); image->data[imageaddr+1] = (unsigned char)(xcim->pixels[xcimaddr] >> 8); image->data[imageaddr+2] = (unsigned char)(xcim->pixels[xcimaddr] >> 16); } } } XFree(xcim); xcim = NULL; } ", "target": 1}
{"func": "static uint64t bostonplatregread(void *opaque, hwaddr addr, unsigned size) { BostonState *s = opaque; uint32t gicfreq, val; if (size != 4) { qemulogmask(LOGUNIMP, \"%uB platform register read\", size); return 0; } switch (addr & 0xffff) { case PLATFPGABUILD: case PLATCORECL: case PLATWRAPPERCL: return 0; case PLATDDR3STATUS: return PLATDDR3STATUSLOCKED | PLATDDR3STATUSCALIBRATED; case PLATMMCMDIV: gicfreq = mipsgictimergetfreq(s->cps->gic.gictimer) / 1000000; val = gicfreq << PLATMMCMDIVINPUTSHIFT; val |= 1 << PLATMMCMDIVMULSHIFT; val |= 1 << PLATMMCMDIVCLK0DIVSHIFT; val |= 1 << PLATMMCMDIVCLK1DIVSHIFT; return val; case PLATBUILDCFG: val = PLATBUILDCFGPCIE0EN; val |= PLATBUILDCFGPCIE1EN; val |= PLATBUILDCFGPCIE2EN; return val; case PLATDDRCFG: val = s->mach->ramsize / GBYTE; assert(!(val & ~PLATDDRCFGSIZE)); val |= PLATDDRCFGMHZ; return val; default: qemulogmask(LOGUNIMP, \"Read platform register 0x%\" HWADDRPRIx, addr & 0xffff); return 0; } } ", "target": 1}
{"func": "int avfilterregister(AVFilter *filter) { if (nextregisteredavfilteridx == MAXREGISTEREDAVFILTERSNB) return -1; registeredavfilters[nextregisteredavfilteridx++] = filter; return 0; } ", "target": 0}
{"func": "void qmpmigratecancel(Error **errp) { migratefdcancel(migrategetcurrent()); } ", "target": 1}
{"func": "int loadsnapshot(const char *name, Error **errp) { BlockDriverState *bs, *bsvmstate; QEMUSnapshotInfo sn; QEMUFile *f; int ret; AioContext *aiocontext; MigrationIncomingState *mis = migrationincominggetcurrent(); if (!bdrvallcansnapshot(&bs)) { errorsetg(errp, \"Device '%s' is writable but does not support snapshots\", bdrvgetdevicename(bs)); return -ENOTSUP; } ret = bdrvallfindsnapshot(name, &bs); if (ret < 0) { errorsetg(errp, \"Device '%s' does not have the requested snapshot '%s'\", bdrvgetdevicename(bs), name); return ret; } bsvmstate = bdrvallfindvmstatebs(); if (!bsvmstate) { errorsetg(errp, \"No block device supports snapshots\"); return -ENOTSUP; } aiocontext = bdrvgetaiocontext(bsvmstate); /* Don't even try to load empty VM states */ aiocontextacquire(aiocontext); ret = bdrvsnapshotfind(bsvmstate, &sn, name); aiocontextrelease(aiocontext); if (ret < 0) { return ret; } else if (sn.vmstatesize == 0) { errorsetg(errp, \"This is a disk-only snapshot. Revert to it \" \" offline using qemu-img\"); return -EINVAL; } /* Flush all IO requests so they don't interfere with the new state. */ bdrvdrainall(); ret = bdrvallgotosnapshot(name, &bs); if (ret < 0) { errorsetg(errp, \"Error %d while activating snapshot '%s' on '%s'\", ret, name, bdrvgetdevicename(bs)); return ret; } /* restore the VM state */ f = qemufopenbdrv(bsvmstate, 0); if (!f) { errorsetg(errp, \"Could not open VM state file\"); return -EINVAL; } qemusystemreset(SHUTDOWNCAUSENONE); mis->fromsrcfile = f; aiocontextacquire(aiocontext); ret = qemuloadvmstate(f); qemufclose(f); aiocontextrelease(aiocontext); migrationincomingstatedestroy(); if (ret < 0) { errorsetg(errp, \"Error %d while loading VM state\", ret); return ret; } return 0; } ", "target": 1}
{"func": "static avnoinline void emulatededgemcsse(uint8t *buf, const uint8t *src, ptrdifft bufstride, ptrdifft srcstride, int blockw, int blockh, int srcx, int srcy, int w, int h) { emulatededgemc(buf, src, bufstride, srcstride, blockw, blockh, srcx, srcy, w, h, vfixtblsse, &ffemuedgevvarsse, hfixtblmmxext, &ffemuedgehvarmmxext); } ", "target": 0}
{"func": "static int movtexttx3g(AVCodecContext *avctx, MovTextContext *m) { char *tx3gptr = avctx->extradata; int i, boxsize, fontlength; int8t valign, halign; int stylefontID; StyleBox sdefault; m->countf = 0; m->ftabentries = 0; boxsize = BOXSIZEINITIAL; /* Size till ftabentries */ if (avctx->extradatasize < boxsize) return -1; // Display Flags tx3gptr += 4; // Alignment halign = *tx3gptr++; valign = *tx3gptr++; if (halign == 0) { if (valign == 0) m->d.alignment = TOPLEFT; if (valign == 1) m->d.alignment = MIDDLELEFT; if (valign == -1) m->d.alignment = BOTTOMLEFT; } if (halign == 1) { if (valign == 0) m->d.alignment = TOPCENTER; if (valign == 1) m->d.alignment = MIDDLECENTER; if (valign == -1) m->d.alignment = BOTTOMCENTER; } if (halign == -1) { if (valign == 0) m->d.alignment = TOPRIGHT; if (valign == 1) m->d.alignment = MIDDLERIGHT; if (valign == -1) m->d.alignment = BOTTOMRIGHT; } // Background Color m->d.backcolor = AVRB24(tx3gptr); tx3gptr += 4; // BoxRecord tx3gptr += 8; // StyleRecord tx3gptr += 4; // fontID stylefontID = AVRB16(tx3gptr); tx3gptr += 2; // face-style-flags sdefault.styleflag = *tx3gptr++; m->d.bold = sdefault.styleflag & STYLEFLAGBOLD; m->d.italic = sdefault.styleflag & STYLEFLAGITALIC; m->d.underline = sdefault.styleflag & STYLEFLAGUNDERLINE; // fontsize m->d.fontsize = *tx3gptr++; // Primary color m->d.color = AVRB24(tx3gptr); tx3gptr += 4; // FontRecord // FontRecord Size tx3gptr += 4; // ftab tx3gptr += 4; m->ftabentries = AVRB16(tx3gptr); tx3gptr += 2; for (i = 0; i < m->ftabentries; i++) { boxsize += 3; if (avctx->extradatasize < boxsize) { movtextcleanupftab(m); m->ftabentries = 0; return -1; } m->ftabtemp = avmalloc(sizeof(*m->ftabtemp)); if (!m->ftabtemp) { movtextcleanupftab(m); return AVERROR(ENOMEM); } m->ftabtemp->fontID = AVRB16(tx3gptr); tx3gptr += 2; fontlength = *tx3gptr++; boxsize = boxsize + fontlength; if (avctx->extradatasize < boxsize) { movtextcleanupftab(m); m->ftabentries = 0; return -1; } m->ftabtemp->font = avmalloc(fontlength + 1); if (!m->ftabtemp->font) { movtextcleanupftab(m); return AVERROR(ENOMEM); } memcpy(m->ftabtemp->font, tx3gptr, fontlength); m->ftabtemp->font[fontlength] = '\\0'; avdynarrayadd(&m->ftab, &m->countf, m->ftabtemp); if (!m->ftab) { movtextcleanupftab(m); return AVERROR(ENOMEM); } tx3gptr = tx3gptr + fontlength; } for (i = 0; i < m->ftabentries; i++) { if (stylefontID == m->ftab[i]->fontID) m->d.font = m->ftab[i]->font; } return 0; } ", "target": 1}
{"func": "static void msmousechrclose (struct CharDriverState *chr) { MouseState *mouse = chr->opaque; qemuinputhandlerunregister(mouse->hs); gfree(mouse); gfree(chr); } ", "target": 1}
{"func": "int qemuinitmainloop(void) { int ret; ret = qemusignalinit(); if (ret) { return ret; } qemuinitsigbus(); return qemueventinit(); } ", "target": 1}
{"func": "envlistparse(envlistt *envlist, const char *env, int (*callback)(envlistt *, const char *)) { \tchar *tmpenv, *envvar; \tchar *envsave = NULL; \tassert(callback != NULL); \tif ((envlist == NULL) || (env == NULL)) \t\treturn (EINVAL); \t/* \t * We need to make temporary copy of the env string \t * as strtokr(3) modifies it while it tokenizes. \t */ \tif ((tmpenv = strdup(env)) == NULL) \t\treturn (errno); \tenvvar = strtokr(tmpenv, \",\", &envsave); \twhile (envvar != NULL) { \t\tif ((*callback)(envlist, envvar) != 0) { \t\t\tfree(tmpenv); \t\t\treturn (errno); \t\t} \t\tenvvar = strtokr(NULL, \",\", &envsave); \t} \tfree(tmpenv); \treturn (0); } ", "target": 1}
{"func": "static int aviwritepacket(AVFormatContext *s, AVPacket *pkt) { unsigned char tag[5]; unsigned int flags = 0; const int streamindex = pkt->streamindex; int size = pkt->size; AVIContext *avi = s->privdata; AVIOContext *pb = s->pb; AVIStream *avist = s->streams[streamindex]->privdata; AVCodecParameters *par = s->streams[streamindex]->codecpar; while (par->blockalign == 0 && pkt->dts != AVNOPTSVALUE && pkt->dts > avist->packetcount) { AVPacket emptypacket; avinitpacket(&emptypacket); emptypacket.size = 0; emptypacket.data = NULL; emptypacket.streamindex = streamindex; aviwritepacket(s, &emptypacket); } avist->packetcount++; // Make sure to put an OpenDML chunk when the file size exceeds the limits if (pb->seekable && (aviotell(pb) - avi->riffstart > AVIMAXRIFFSIZE)) { aviwriteix(s); ffendtag(pb, avi->movilist); if (avi->riffid == 1) aviwriteidx1(s); ffendtag(pb, avi->riffstart); avi->movilist = avistartnewriff(s, pb, \"AVIX\", \"movi\"); } avistream2fourcc(tag, streamindex, par->codectype); if (pkt->flags & AVPKTFLAGKEY) flags = 0x10; if (par->codectype == AVMEDIATYPEAUDIO) avist->audiostrmlength += size; if (s->pb->seekable) { int err; AVIIndex *idx = &avist->indexes; int cl = idx->entry / AVIINDEXCLUSTERSIZE; int id = idx->entry % AVIINDEXCLUSTERSIZE; if (idx->entsallocated <= idx->entry) { if ((err = avreallocp(&idx->cluster, (cl + 1) * sizeof(*idx->cluster))) < 0) { idx->entsallocated = 0; idx->entry = 0; return err; } idx->cluster[cl] = avmalloc(AVIINDEXCLUSTERSIZE * sizeof(AVIIentry)); if (!idx->cluster[cl]) return -1; idx->entsallocated += AVIINDEXCLUSTERSIZE; } idx->cluster[cl][id].flags = flags; idx->cluster[cl][id].pos = aviotell(pb) - avi->movilist; idx->cluster[cl][id].len = size; idx->entry++; } aviowrite(pb, tag, 4); aviowl32(pb, size); aviowrite(pb, pkt->data, size); if (size & 1) aviow8(pb, 0); return 0; } ", "target": 0}
{"func": "static avcold int checkcudaerrors(AVCodecContext *avctx, CUresult err, const char *func) { if (err != CUDASUCCESS) { avlog(avctx, AVLOGFATAL, \">> %s - failed with error code 0x%x\\n\", func, err); return 0; } return 1; } ", "target": 0}
{"func": "static void showstream(WriterContext *w, AVFormatContext *fmtctx, int streamidx, int inprogram) { AVStream *stream = fmtctx->streams[streamidx]; AVCodecContext *decctx; const AVCodec *dec; char valstr[128]; const char *s; AVRational sar, dar; AVBPrint pbuf; avbprintinit(&pbuf, 1, AVBPRINTSIZEUNLIMITED); writerprintsectionheader(w, inprogram ? SECTIONIDPROGRAMSTREAM : SECTIONIDSTREAM); printint(\"index\", stream->index); if ((decctx = stream->codec)) { const char *profile = NULL; dec = decctx->codec; if (dec) { printstr(\"codecname\", dec->name); if (!dobitexact) { if (dec->longname) printstr (\"codeclongname\", dec->longname); else printstropt(\"codeclongname\", \"unknown\"); } } else { printstropt(\"codecname\", \"unknown\"); if (!dobitexact) { printstropt(\"codeclongname\", \"unknown\"); } } if (dec && (profile = avgetprofilename(dec, decctx->profile))) printstr(\"profile\", profile); else printstropt(\"profile\", \"unknown\"); s = avgetmediatypestring(decctx->codectype); if (s) printstr (\"codectype\", s); else printstropt(\"codectype\", \"unknown\"); printq(\"codectimebase\", decctx->timebase, '/'); /* print AVI/FourCC tag */ avgetcodectagstring(valstr, sizeof(valstr), decctx->codectag); printstr(\"codectagstring\", valstr); printfmt(\"codectag\", \"0x%04x\", decctx->codectag); switch (decctx->codectype) { case AVMEDIATYPEVIDEO: printint(\"width\", decctx->width); printint(\"height\", decctx->height); printint(\"hasbframes\", decctx->hasbframes); sar = avguesssampleaspectratio(fmtctx, stream, NULL); if (sar.den) { printq(\"sampleaspectratio\", sar, ':'); avreduce(&dar.num, &dar.den, decctx->width * sar.num, decctx->height * sar.den, 1024*1024); printq(\"displayaspectratio\", dar, ':'); } else { printstropt(\"sampleaspectratio\", \"N/A\"); printstropt(\"displayaspectratio\", \"N/A\"); } s = avgetpixfmtname(decctx->pixfmt); if (s) printstr (\"pixfmt\", s); else printstropt(\"pixfmt\", \"unknown\"); printint(\"level\", decctx->level); if (decctx->timecodeframestart >= 0) { char tcbuf[AVTIMECODESTRSIZE]; avtimecodemakempegtcstring(tcbuf, decctx->timecodeframestart); printstr(\"timecode\", tcbuf); } else { printstropt(\"timecode\", \"N/A\"); } break; case AVMEDIATYPEAUDIO: s = avgetsamplefmtname(decctx->samplefmt); if (s) printstr (\"samplefmt\", s); else printstropt(\"samplefmt\", \"unknown\"); printval(\"samplerate\", decctx->samplerate, unithertzstr); printint(\"channels\", decctx->channels); if (decctx->channellayout) { avbprintclear(&pbuf); avbprintchannellayout(&pbuf, decctx->channels, decctx->channellayout); printstr (\"channellayout\", pbuf.str); } else { printstropt(\"channellayout\", \"unknown\"); } printint(\"bitspersample\", avgetbitspersample(decctx->codecid)); break; case AVMEDIATYPESUBTITLE: if (decctx->width) printint(\"width\", decctx->width); else printstropt(\"width\", \"N/A\"); if (decctx->height) printint(\"height\", decctx->height); else printstropt(\"height\", \"N/A\"); break; } } else { printstropt(\"codectype\", \"unknown\"); } if (decctx->codec && decctx->codec->privclass && showprivatedata) { const AVOption *opt = NULL; while (opt = avoptnext(decctx->privdata,opt)) { uint8t *str; if (opt->flags) continue; if (avoptget(decctx->privdata, opt->name, 0, &str) >= 0) { printstr(opt->name, str); avfree(str); } } } if (fmtctx->iformat->flags & AVFMTSHOWIDS) printfmt (\"id\", \"0x%x\", stream->id); else printstropt(\"id\", \"N/A\"); printq(\"rframerate\", stream->rframerate, '/'); printq(\"avgframerate\", stream->avgframerate, '/'); printq(\"timebase\", stream->timebase, '/'); printts (\"startpts\", stream->starttime); printtime(\"starttime\", stream->starttime, &stream->timebase); printts (\"durationts\", stream->duration); printtime(\"duration\", stream->duration, &stream->timebase); if (decctx->bitrate > 0) printval (\"bitrate\", decctx->bitrate, unitbitpersecondstr); else printstropt(\"bitrate\", \"N/A\"); if (stream->nbframes) printfmt (\"nbframes\", \"%\"PRId64, stream->nbframes); else printstropt(\"nbframes\", \"N/A\"); if (nbstreamsframes[streamidx]) printfmt (\"nbreadframes\", \"%\"PRIu64, nbstreamsframes[streamidx]); else printstropt(\"nbreadframes\", \"N/A\"); if (nbstreamspackets[streamidx]) printfmt (\"nbreadpackets\", \"%\"PRIu64, nbstreamspackets[streamidx]); else printstropt(\"nbreadpackets\", \"N/A\"); if (doshowdata) writerprintdata(w, \"extradata\", decctx->extradata, decctx->extradatasize); /* Print disposition information */ #define PRINTDISPOSITION(flagname, name) do { \\ printint(name, !!(stream->disposition & AVDISPOSITION##flagname)); \\ } while (0) if (doshowstreamdisposition) { writerprintsectionheader(w, inprogram ? SECTIONIDPROGRAMSTREAMDISPOSITION : SECTIONIDSTREAMDISPOSITION); PRINTDISPOSITION(DEFAULT, \"default\"); PRINTDISPOSITION(DUB, \"dub\"); PRINTDISPOSITION(ORIGINAL, \"original\"); PRINTDISPOSITION(COMMENT, \"comment\"); PRINTDISPOSITION(LYRICS, \"lyrics\"); PRINTDISPOSITION(KARAOKE, \"karaoke\"); PRINTDISPOSITION(FORCED, \"forced\"); PRINTDISPOSITION(HEARINGIMPAIRED, \"hearingimpaired\"); PRINTDISPOSITION(VISUALIMPAIRED, \"visualimpaired\"); PRINTDISPOSITION(CLEANEFFECTS, \"cleaneffects\"); PRINTDISPOSITION(ATTACHEDPIC, \"attachedpic\"); writerprintsectionfooter(w); } showtags(w, stream->metadata, inprogram ? SECTIONIDPROGRAMSTREAMTAGS : SECTIONIDSTREAMTAGS); writerprintsectionfooter(w); avbprintfinalize(&pbuf, NULL); fflush(stdout); } ", "target": 0}
{"func": "static inline int getblock(GetBitContext *gb, DCTELEM *block, const uint8t *scan, const uint32t *quant) { int coeff, i, n; int8t ac; uint8t dc = getbits(gb, 8); // block not coded if (dc == 255) // number of non-zero coefficients coeff = getbits(gb, 6); if (getbitscount(gb) + (coeff << 1) >= gb->sizeinbits) // normally we would only need to clear the (63 - coeff) last values, // but since we do not know where they are we just clear the whole block memset(block, 0, 64 * sizeof(DCTELEM)); // 2 bits per coefficient while (coeff) { ac = getsbits(gb, 2); if (ac == -2) break; // continue with more bits PUTCOEFF(ac); } // 4 bits per coefficient ALIGN(4); while (coeff) { ac = getsbits(gb, 4); if (ac == -8) break; // continue with more bits PUTCOEFF(ac); } // 8 bits per coefficient ALIGN(8); if (getbitscount(gb) + (coeff << 3) >= gb->sizeinbits) while (coeff) { ac = getsbits(gb, 8); PUTCOEFF(ac); } PUTCOEFF(dc); return 1; }", "target": 1}
{"func": "static void genneontrnu16(TCGv t0, TCGv t1) { TCGv rd, tmp; rd = newtmp(); tmp = newtmp(); tcggenshlii32(rd, t0, 16); tcggenandii32(tmp, t1, 0xffff); tcggenori32(rd, rd, tmp); tcggenshrii32(t1, t1, 16); tcggenandii32(tmp, t0, 0xffff0000); tcggenori32(t1, t1, tmp); tcggenmovi32(t0, rd); deadtmp(tmp); deadtmp(rd); } ", "target": 1}
{"func": "static int parseheader(OutputStream *os, const uint8t *buf, int bufsize) { if (bufsize < 13) return AVERRORINVALIDDATA; if (memcmp(buf, \"FLV\", 3)) return AVERRORINVALIDDATA; buf += 13; bufsize -= 13; while (bufsize >= 11 + 4) { int type = buf[0]; int size = AVRB24(&buf[1]) + 11 + 4; if (size > bufsize) return AVERRORINVALIDDATA; if (type == 8 || type == 9) { if (os->nbextrapackets > FFARRAYELEMS(os->extrapackets)) return AVERRORINVALIDDATA; os->extrapacketsizes[os->nbextrapackets] = size; os->extrapackets[os->nbextrapackets] = avmalloc(size); if (!os->extrapackets[os->nbextrapackets]) return AVERROR(ENOMEM); memcpy(os->extrapackets[os->nbextrapackets], buf, size); os->nbextrapackets++; } else if (type == 0x12) { if (os->metadata) return AVERRORINVALIDDATA; os->metadatasize = size - 11 - 4; os->metadata = avmalloc(os->metadatasize); if (!os->metadata) return AVERROR(ENOMEM); memcpy(os->metadata, buf + 11, os->metadatasize); } buf += size; bufsize -= size; } if (!os->metadata) return AVERRORINVALIDDATA; return 0; } ", "target": 0}
{"func": "restoresigcontext(CPUMIPSState *regs, struct targetsigcontext *sc) { int err = 0; int i; getuser(regs->CP0EPC, &sc->scpc); getuser(regs->activetc.HI[0], &sc->scmdhi); getuser(regs->activetc.LO[0], &sc->scmdlo); for (i = 1; i < 32; ++i) { getuser(regs->activetc.gpr[i], &sc->scregs[i]); } getuser(regs->activetc.HI[1], &sc->schi1); getuser(regs->activetc.HI[2], &sc->schi2); getuser(regs->activetc.HI[3], &sc->schi3); getuser(regs->activetc.LO[1], &sc->sclo1); getuser(regs->activetc.LO[2], &sc->sclo2); getuser(regs->activetc.LO[3], &sc->sclo3); { uint32t dsp; getuser(dsp, &sc->scdsp); cpuwrdsp(dsp, 0x3ff, regs); } for (i = 0; i < 32; ++i) { getuser(regs->activefpu.fpr[i].d, &sc->scfpregs[i]); } return err; } ", "target": 1}
{"func": "static void sdhciwriteblocktocard(SDHCIState *s) { int index = 0; if (s->prnsts & SDHCSPACEAVAILABLE) { if (s->norintstsen & SDHCNISENWBUFRDY) { s->norintsts |= SDHCNISWBUFRDY; } sdhciupdateirq(s); return; } if (s->trnmod & SDHCTRNSBLKCNTEN) { if (s->blkcnt == 0) { return; } else { s->blkcnt--; } } for (index = 0; index < (s->blksize & 0x0fff); index++) { sdwritedata(s->card, s->fifobuffer[index]); } /* Next data can be written through BUFFER DATORT register */ s->prnsts |= SDHCSPACEAVAILABLE; /* Finish transfer if that was the last block of data */ if ((s->trnmod & SDHCTRNSMULTI) == 0 || ((s->trnmod & SDHCTRNSMULTI) && (s->trnmod & SDHCTRNSBLKCNTEN) && (s->blkcnt == 0))) { SDHCIGETCLASS(s)->enddatatransfer(s); } else if (s->norintstsen & SDHCNISENWBUFRDY) { s->norintsts |= SDHCNISWBUFRDY; } /* Generate Block Gap Event if requested and if not the last block */ if (s->stoppedstate == sdhcgapwrite && (s->trnmod & SDHCTRNSMULTI) && s->blkcnt > 0) { s->prnsts &= ~SDHCDOINGWRITE; if (s->norintstsen & SDHCEISENBLKGAP) { s->norintsts |= SDHCEISBLKGAP; } SDHCIGETCLASS(s)->enddatatransfer(s); } sdhciupdateirq(s); } ", "target": 0}
{"func": "static AHCIQState *ahciboot(void) { AHCIQState *s; const char *cli; s = gmalloc0(sizeof(AHCIQState)); cli = \"-drive if=none,id=drive0,file=%s,cache=writeback,serial=%s\" \",format=qcow2\" \" -M q35 \" \"-device ide-hd,drive=drive0 \" \"-global ide-hd.ver=%s\"; s->parent = qtestpcboot(cli, tmppath, \"testdisk\", \"version\"); allocsetflags(s->parent->alloc, ALLOCLEAKASSERT); /* Verify that we have an AHCI device present. */ s->dev = getahcidevice(&s->fingerprint); return s; } ", "target": 0}
{"func": "void addressspacedestroydispatch(AddressSpace *as) { AddressSpaceDispatch *d = as->dispatch; memorylistenerunregister(&d->listener); gfree(d); as->dispatch = NULL; } ", "target": 0}
{"func": "mstfpgareadb(void *opaque, targetphysaddrt addr) { \tmstirqstate *s = (mstirqstate *) opaque; \tswitch (addr) { \tcase MSTLEDDAT1: \t\treturn s->leddat1; \tcase MSTLEDDAT2: \t\treturn s->leddat2; \tcase MSTLEDCTRL: \t\treturn s->ledctrl; \tcase MSTGPSWR: \t\treturn s->gpswr; \tcase MSTMSCWR1: \t\treturn s->mscwr1; \tcase MSTMSCWR2: \t\treturn s->mscwr2; \tcase MSTMSCWR3: \t\treturn s->mscwr3; \tcase MSTMSCRD: \t\treturn s->mscrd; \tcase MSTINTMSKENA: \t\treturn s->intmskena; \tcase MSTINTSETCLR: \t\treturn s->intsetclr; \tcase MSTPCMCIA0: \t\treturn s->pcmcia0; \tcase MSTPCMCIA1: \t\treturn s->pcmcia1; \tdefault: \t\tprintf(\"Mainstone - mstfpgareadb: Bad register offset \" \t\t\t\"0x\" TARGETFMTplx \" \\n\", addr); \t} \treturn 0; } ", "target": 0}
{"func": "static int pcipiixideinitfn(PCIIDEState *d) { uint8t *pciconf = d->dev.config; pciconf[PCICLASSPROG] = 0x80; // legacy ATA mode pciconfigsetclass(pciconf, PCICLASSSTORAGEIDE); qemuregisterreset(piix3reset, d); pciregisterbar(&d->dev, 4, 0x10, PCIBASEADDRESSSPACEIO, bmdmamap); vmstateregister(&d->dev.qdev, 0, &vmstateidepci, d); pcipiixinitports(d); return 0; } ", "target": 0}
{"func": "static void virtionetpcirealize(VirtIOPCIProxy *vpcidev, Error **errp) { DeviceState *qdev = DEVICE(vpcidev); VirtIONetPCI *dev = VIRTIONETPCI(vpcidev); DeviceState *vdev = DEVICE(&dev->vdev); virtionetsetconfigsize(&dev->vdev, vpcidev->hostfeatures); virtionetsetnetclientname(&dev->vdev, qdev->id, objectgettypename(OBJECT(qdev))); qdevsetparentbus(vdev, BUS(&vpcidev->bus)); objectpropertysetbool(OBJECT(vdev), true, \"realized\", errp); } ", "target": 0}
{"func": "static void spaprnvramrealize(VIOsPAPRDevice *dev, Error **errp) { sPAPRNVRAM *nvram = VIOSPAPRNVRAM(dev); int ret; if (nvram->blk) { nvram->size = blkgetlength(nvram->blk); ret = blksetperm(nvram->blk, BLKPERMCONSISTENTREAD | BLKPERMWRITE, BLKPERMALL, errp); if (ret < 0) { return; } } else { nvram->size = DEFAULTNVRAMSIZE; } nvram->buf = gmalloc0(nvram->size); if ((nvram->size < MINNVRAMSIZE) || (nvram->size > MAXNVRAMSIZE)) { errorsetg(errp, \"spapr-nvram must be between %d and %d bytes in size\", MINNVRAMSIZE, MAXNVRAMSIZE); return; } if (nvram->blk) { int alen = blkpread(nvram->blk, 0, nvram->buf, nvram->size); if (alen != nvram->size) { errorsetg(errp, \"can't read spapr-nvram contents\"); return; } } else if (nbpromenvs > 0) { /* Create a system partition to pass the -prom-env variables */ chrpnvramcreatesystempartition(nvram->buf, MINNVRAMSIZE / 4); chrpnvramcreatefreepartition(&nvram->buf[MINNVRAMSIZE / 4], nvram->size - MINNVRAMSIZE / 4); } spaprrtasregister(RTASNVRAMFETCH, \"nvram-fetch\", rtasnvramfetch); spaprrtasregister(RTASNVRAMSTORE, \"nvram-store\", rtasnvramstore); } ", "target": 0}
{"func": "static void ehcifreepacket(EHCIPacket *p) { traceusbehcipacketaction(p->queue, p, \"free\"); if (p->async == EHCIASYNCINFLIGHT) { usbcancelpacket(&p->packet); usbpacketunmap(&p->packet, &p->sgl); qemusglistdestroy(&p->sgl); QTAILQREMOVE(&p->queue->packets, p, next); usbpacketcleanup(&p->packet); gfree(p); ", "target": 1}
{"func": "static inline void RENAME(nv12ToUV)(uint8t *dstU, uint8t *dstV, const uint8t *src1, const uint8t *src2, long width, uint32t *unused) { RENAME(nvXXtoUV)(dstU, dstV, src1, width); } ", "target": 0}
{"func": "int ffthreadinit(AVCodecContext *avctx) { if (avctx->threadopaque) { avlog(avctx, AVLOGERROR, \"avcodecthreadinit is ignored after avcodecopen\\n\"); return -1; } #if HAVEW32THREADS w32threadinit(); #endif if (avctx->codec) { validatethreadparameters(avctx); if (avctx->activethreadtype&FFTHREADSLICE) return threadinit(avctx); else if (avctx->activethreadtype&FFTHREADFRAME) return framethreadinit(avctx); } return 0; } ", "target": 0}
{"func": "static inline bool memoryaccessisdirect(MemoryRegion *mr, bool iswrite) { if (memoryregionisram(mr)) { return !(iswrite && mr->readonly); } if (memoryregionisromd(mr)) { return !iswrite; } return false; } ", "target": 0}
{"func": "VirtIODevice *virtioblkinit(DeviceState *dev, VirtIOBlkConf *blk) { VirtIOBlock *s; int cylinders, heads, secs; static int virtioblkid; DriveInfo *dinfo; if (!blk->conf.bs) { errorreport(\"drive property not set\"); return NULL; } if (!bdrvisinserted(blk->conf.bs)) { errorreport(\"Device needs media, but drive is empty\"); return NULL; } if (!blk->serial) { /* try to fall back to value set with legacy -drive serial=... */ dinfo = drivegetbyblockdev(blk->conf.bs); if (*dinfo->serial) { blk->serial = strdup(dinfo->serial); } } s = (VirtIOBlock *)virtiocommoninit(\"virtio-blk\", VIRTIOIDBLOCK, sizeof(struct virtioblkconfig), sizeof(VirtIOBlock)); s->vdev.getconfig = virtioblkupdateconfig; s->vdev.getfeatures = virtioblkgetfeatures; s->vdev.reset = virtioblkreset; s->bs = blk->conf.bs; s->conf = &blk->conf; s->blk = blk; s->rq = NULL; s->sectormask = (s->conf->logicalblocksize / BDRVSECTORSIZE) - 1; bdrvguessgeometry(s->bs, &cylinders, &heads, &secs); s->vq = virtioaddqueue(&s->vdev, 128, virtioblkhandleoutput); qemuaddvmchangestatehandler(virtioblkdmarestartcb, s); s->qdev = dev; registersavevm(dev, \"virtio-blk\", virtioblkid++, 2, virtioblksave, virtioblkload, s); bdrvsetdevops(s->bs, &virtioblockops, s); bdrvsetbufferalignment(s->bs, s->conf->logicalblocksize); bdrviostatusenable(s->bs); addbootdevicepath(s->conf->bootindex, dev, \"/disk@0,0\"); return &s->vdev; } ", "target": 0}
{"func": "static int pcmdecodeframe(AVCodecContext *avctx, void *data, int *datasize, AVPacket *avpkt) { const uint8t *buf = avpkt->data; int bufsize = avpkt->size; PCMDecode *s = avctx->privdata; int samplesize, c, n, i; short *samples; const uint8t *src, *src8, *src2[MAXCHANNELS]; uint8t *dstu8; int16t *dstint16t; int32t *dstint32t; int64t *dstint64t; uint16t *dstuint16t; uint32t *dstuint32t; samples = data; src = buf; if (avctx->samplefmt!=avctx->codec->samplefmts[0]) { avlog(avctx, AVLOGERROR, \"invalid samplefmt\\n\"); return -1; if(avctx->channels <= 0 || avctx->channels > MAXCHANNELS){ avlog(avctx, AVLOGERROR, \"PCM channels out of bounds\\n\"); return -1; samplesize = avgetbitspersample(avctx->codecid)/8; /* avgetbitspersample returns 0 for CODECIDPCMDVD */ if (CODECIDPCMDVD == avctx->codecid) /* 2 samples are interleaved per block in PCMDVD */ samplesize = avctx->bitspercodedsample * 2 / 8; else if (avctx->codecid == CODECIDPCMLXF) /* we process 40-bit blocks per channel for LXF */ samplesize = 5; n = avctx->channels * samplesize; if(n && bufsize % n){ if (bufsize < n) { avlog(avctx, AVLOGERROR, \"invalid PCM packet\\n\"); return -1; }else bufsize -= bufsize % n; bufsize= FFMIN(bufsize, *datasize/2); *datasize=0; n = bufsize/samplesize; switch(avctx->codec->id) { case CODECIDPCMU32LE: DECODE(uint32t, le32, src, samples, n, 0, 0x80000000) break; case CODECIDPCMU32BE: DECODE(uint32t, be32, src, samples, n, 0, 0x80000000) break; case CODECIDPCMS24LE: DECODE(int32t, le24, src, samples, n, 8, 0) break; case CODECIDPCMS24BE: DECODE(int32t, be24, src, samples, n, 8, 0) break; case CODECIDPCMU24LE: DECODE(uint32t, le24, src, samples, n, 8, 0x800000) break; case CODECIDPCMU24BE: DECODE(uint32t, be24, src, samples, n, 8, 0x800000) break; case CODECIDPCMS24DAUD: for(;n>0;n--) { uint32t v = bytestreamgetbe24(&src); v >>= 4; // sync flags are here *samples++ = avreverse[(v >> 8) & 0xff] + (avreverse[v & 0xff] << 8); break; case CODECIDPCMS16LEPLANAR: n /= avctx->channels; for(c=0;c<avctx->channels;c++) src2[c] = &src[c*n*2]; for(;n>0;n--) for(c=0;c<avctx->channels;c++) *samples++ = bytestreamgetle16(&src2[c]); src = src2[avctx->channels-1]; break; case CODECIDPCMU16LE: DECODE(uint16t, le16, src, samples, n, 0, 0x8000) break; case CODECIDPCMU16BE: DECODE(uint16t, be16, src, samples, n, 0, 0x8000) break; case CODECIDPCMS8: dstu8= (uint8t*)samples; for(;n>0;n--) { *dstu8++ = *src++ + 128; samples= (short*)dstu8; break; #if HAVEBIGENDIAN case CODECIDPCMF64LE: DECODE(int64t, le64, src, samples, n, 0, 0) break; case CODECIDPCMS32LE: case CODECIDPCMF32LE: DECODE(int32t, le32, src, samples, n, 0, 0) break; case CODECIDPCMS16LE: DECODE(int16t, le16, src, samples, n, 0, 0) break; case CODECIDPCMF64BE: case CODECIDPCMF32BE: case CODECIDPCMS32BE: case CODECIDPCMS16BE: #else case CODECIDPCMF64BE: DECODE(int64t, be64, src, samples, n, 0, 0) break; case CODECIDPCMF32BE: case CODECIDPCMS32BE: DECODE(int32t, be32, src, samples, n, 0, 0) break; case CODECIDPCMS16BE: DECODE(int16t, be16, src, samples, n, 0, 0) break; case CODECIDPCMF64LE: case CODECIDPCMF32LE: case CODECIDPCMS32LE: case CODECIDPCMS16LE: #endif /* HAVEBIGENDIAN */ case CODECIDPCMU8: memcpy(samples, src, n*samplesize); src += n*samplesize; samples = (short*)((uint8t*)data + n*samplesize); break; case CODECIDPCMZORK: for(;n>0;n--) { int x= *src++; if(x&128) x-= 128; else x = -x; *samples++ = x << 8; break; case CODECIDPCMALAW: case CODECIDPCMMULAW: for(;n>0;n--) { *samples++ = s->table[*src++]; break; case CODECIDPCMDVD: dstint32t = data; n /= avctx->channels; switch (avctx->bitspercodedsample) { case 20: while (n--) { c = avctx->channels; src8 = src + 4*c; while (c--) { *dstint32t++ = (bytestreamgetbe16(&src) << 16) + ((*src8 &0xf0) << 8); *dstint32t++ = (bytestreamgetbe16(&src) << 16) + ((*src8++ &0x0f) << 12); src = src8; break; case 24: while (n--) { c = avctx->channels; src8 = src + 4*c; while (c--) { *dstint32t++ = (bytestreamgetbe16(&src) << 16) + ((*src8++) << 8); *dstint32t++ = (bytestreamgetbe16(&src) << 16) + ((*src8++) << 8); src = src8; break; default: avlog(avctx, AVLOGERROR, \"PCM DVD unsupported sample depth\\n\"); return -1; break; samples = (short *) dstint32t; break; case CODECIDPCMLXF: dstint32t = data; n /= avctx->channels; //unpack and de-planerize for (i = 0; i < n; i++) { for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) { //extract low 20 bits and expand to 32 bits *dstint32t++ = (src8[2] << 28) | (src8[1] << 20) | (src8[0] << 12) | ((src8[2] & 0xF) << 8) | src8[1]; for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) { //extract high 20 bits and expand to 32 bits *dstint32t++ = (src8[4] << 24) | (src8[3] << 16) | ((src8[2] & 0xF0) << 8) | (src8[4] << 4) | (src8[3] >> 4); src += n * avctx->channels * 5; samples = (short *) dstint32t; break; default: return -1; *datasize = (uint8t *)samples - (uint8t *)data; return src - buf;", "target": 1}
{"func": "static int arm946prbswrite(CPUARMState *env, const ARMCPRegInfo *ri, uint64t value) { if (ri->crm > 8) { return EXCPUDEF; } env->cp15.c6region[ri->crm] = value; return 0; } ", "target": 1}
{"func": "static int usbhostopen(USBHostDevice *dev, int busnum, int addr, const char *port, const char *prodname, int speed) { int fd = -1, ret; traceusbhostopenstarted(busnum, addr); if (dev->fd != -1) { goto fail; } fd = usbhostopendevice(busnum, addr); if (fd < 0) { goto fail; } DPRINTF(\"husb: opened %s\\n\", buf); dev->busnum = busnum; dev->addr = addr; strcpy(dev->port, port); dev->fd = fd; /* read the device description */ dev->descrlen = read(fd, dev->descr, sizeof(dev->descr)); if (dev->descrlen <= 0) { perror(\"husb: reading device data failed\"); goto fail; } #ifdef DEBUG { int x; printf(\"=== begin dumping device descriptor data ===\\n\"); for (x = 0; x < dev->descrlen; x++) { printf(\"%02x \", dev->descr[x]); } printf(\"\\n=== end dumping device descriptor data ===\\n\"); } #endif /* start unconfigured -- we'll wait for the guest to set a configuration */ if (!usbhostclaiminterfaces(dev, 0)) { goto fail; } usbepinit(&dev->dev); usblinuxupdateendptable(dev); if (speed == -1) { struct usbdevfsconnectinfo ci; ret = ioctl(fd, USBDEVFSCONNECTINFO, &ci); if (ret < 0) { perror(\"usbhostdeviceopen: USBDEVFSCONNECTINFO\"); goto fail; } if (ci.slow) { speed = USBSPEEDLOW; } else { speed = USBSPEEDHIGH; } } dev->dev.speed = speed; dev->dev.speedmask = (1 << speed); if (dev->dev.speed == USBSPEEDHIGH && usblinuxfullspeedcompat(dev)) { dev->dev.speedmask |= USBSPEEDMASKFULL; } traceusbhostopensuccess(busnum, addr); if (!prodname || prodname[0] == '\\0') { snprintf(dev->dev.productdesc, sizeof(dev->dev.productdesc), \"host:%d.%d\", busnum, addr); } else { pstrcpy(dev->dev.productdesc, sizeof(dev->dev.productdesc), prodname); } ret = usbdeviceattach(&dev->dev); if (ret) { goto fail; } /* USB devio uses 'write' flag to check for async completions */ qemusetfdhandler(dev->fd, NULL, asynccomplete, dev); return 0; fail: traceusbhostopenfailure(busnum, addr); if (dev->fd != -1) { close(dev->fd); dev->fd = -1; } return -1; } ", "target": 1}
{"func": "static int esppciscsiinit(PCIDevice *dev) { PCIESPState *pci = PCIESP(dev); DeviceState *d = DEVICE(dev); ESPState *s = &pci->esp; uint8t *pciconf; Error *err = NULL; pciconf = dev->config; /* Interrupt pin A */ pciconf[PCIINTERRUPTPIN] = 0x01; s->dmamemoryread = esppcidmamemoryread; s->dmamemorywrite = esppcidmamemorywrite; s->dmaopaque = pci; s->chipid = TCHIAM53C974; memoryregioninitio(&pci->io, OBJECT(pci), &esppciioops, pci, \"esp-io\", 0x80); pciregisterbar(dev, 0, PCIBASEADDRESSSPACEIO, &pci->io); s->irq = pciallocateirq(dev); scsibusnew(&s->bus, sizeof(s->bus), d, &esppciscsiinfo, NULL); if (!d->hotplugged) { scsibuslegacyhandlecmdline(&s->bus, &err); if (err != NULL) { errorfree(err); return -1; } } return 0; }", "target": 1}
{"func": "static void copyframe(Jpeg2000EncoderContext *s) { int tileno, compno, i, y, x; uint8t *line; for (tileno = 0; tileno < s->numXtiles * s->numYtiles; tileno++){ Jpeg2000Tile *tile = s->tile + tileno; if (s->planar){ for (compno = 0; compno < s->ncomponents; compno++){ Jpeg2000Component *comp = tile->comp + compno; int *dst = comp->data; line = s->picture.data[compno] + comp->coord[1][0] * s->picture.linesize[compno] + comp->coord[0][0]; for (y = comp->coord[1][0]; y < comp->coord[1][1]; y++){ uint8t *ptr = line; for (x = comp->coord[0][0]; x < comp->coord[0][1]; x++) *dst++ = *ptr++ - (1 << 7); line += s->picture.linesize[compno]; } } } else{ line = s->picture.data[0] + tile->comp[0].coord[1][0] * s->picture.linesize[0] + tile->comp[0].coord[0][0] * s->ncomponents; i = 0; for (y = tile->comp[0].coord[1][0]; y < tile->comp[0].coord[1][1]; y++){ uint8t *ptr = line; for (x = tile->comp[0].coord[0][0]; x < tile->comp[0].coord[0][1]; x++, i++){ for (compno = 0; compno < s->ncomponents; compno++){ tile->comp[compno].data[i] = *ptr++ - (1 << 7); } } line += s->picture.linesize[0]; } } } } ", "target": 1}
{"func": "static offt proxytelldir(FsContext *ctx, V9fsFidOpenState *fs) { return telldir(fs->dir); } ", "target": 0}
{"func": "static int filtersamples(AVFilterLink *inlink, AVFilterBufferRef *insamplesref) { AResampleContext *aresample = inlink->dst->priv; const int nin = insamplesref->audio->nbsamples; int nout = FFMAX(nin * aresample->ratio * 2, 1); AVFilterLink *const outlink = inlink->dst->outputs[0]; AVFilterBufferRef *outsamplesref = ffgetaudiobuffer(outlink, AVPERMWRITE, nout); int ret; if(!outsamplesref) return AVERROR(ENOMEM); avfiltercopybufferrefprops(outsamplesref, insamplesref); outsamplesref->format = outlink->format; outsamplesref->audio->channellayout = outlink->channellayout; outsamplesref->audio->samplerate = outlink->samplerate; if(insamplesref->pts != AVNOPTSVALUE) { int64t inpts = avrescale(insamplesref->pts, inlink->timebase.num * (int64t)outlink->samplerate * inlink->samplerate, inlink->timebase.den); int64t outpts= swrnextpts(aresample->swr, inpts); aresample->nextpts = outsamplesref->pts = (outpts + inlink->samplerate/2) / inlink->samplerate; } else { outsamplesref->pts = AVNOPTSVALUE; } nout = swrconvert(aresample->swr, outsamplesref->extendeddata, nout, (void *)insamplesref->extendeddata, nin); if (nout <= 0) { avfilterunrefbuffer(outsamplesref); avfilterunrefbuffer(insamplesref); return 0; } outsamplesref->audio->nbsamples = nout; ret = fffiltersamples(outlink, outsamplesref); aresample->reqfullfilled= 1; avfilterunrefbuffer(insamplesref); return ret; } ", "target": 0}
{"func": "static int movreadctts(MOVContext *c, ByteIOContext *pb, MOVatomt atom) { AVStream *st = c->fc->streams[c->fc->nbstreams-1]; MOVStreamContext *sc = st->privdata; unsigned int i, entries; getbyte(pb); /* version */ getbe24(pb); /* flags */ entries = getbe32(pb); if(entries >= UINTMAX / sizeof(MOVsttst)) return -1; sc->cttscount = entries; sc->cttsdata = avmalloc(entries * sizeof(MOVsttst)); if (!sc->cttsdata) return -1; dprintf(c->fc, \"track[%i].ctts.entries = %i\\n\", c->fc->nbstreams-1, entries); for(i=0; i<entries; i++) { int count =getbe32(pb); int duration =getbe32(pb); if (duration < 0) { avlog(c->fc, AVLOGERROR, \"negative ctts, ignoring\\n\"); sc->cttscount = 0; urlfskip(pb, 8 * (entries - i - 1)); break; } sc->cttsdata[i].count = count; sc->cttsdata[i].duration= duration; sc->timerate= ffgcd(sc->timerate, duration); } return 0; } ", "target": 0}
{"func": "int64t avgetint(void *obj, const char *name, const AVOption **oout) { int64t intnum=1; double num=1; int den=1; avgetnumber(obj, name, oout, &num, &den, &intnum); return num*intnum/den; } ", "target": 1}
{"func": "void commitactivestart(BlockDriverState *bs, BlockDriverState *base, int64t speed, BlockdevOnError onerror, BlockDriverCompletionFunc *cb, void *opaque, Error **errp) { int64t length, baselength; int origbaseflags; origbaseflags = bdrvgetflags(base); if (bdrvreopen(base, bs->openflags, errp)) { return; } length = bdrvgetlength(bs); if (length < 0) { errorsetg(errp, \"Unable to determine length of %s\", bs->filename); goto errorrestoreflags; } baselength = bdrvgetlength(base); if (baselength < 0) { errorsetg(errp, \"Unable to determine length of %s\", base->filename); goto errorrestoreflags; } if (length > baselength) { if (bdrvtruncate(base, length) < 0) { errorsetg(errp, \"Top image %s is larger than base image %s, and \" \"resize of base image failed\", bs->filename, base->filename); goto errorrestoreflags; } } bdrvref(base); mirrorstartjob(bs, base, speed, 0, 0, onerror, onerror, cb, opaque, errp, &commitactivejobdriver, false, base); if (errorisset(errp)) { goto errorrestoreflags; } return; errorrestoreflags: /* ignore error and errp for bdrvreopen, because we want to propagate * the original error */ bdrvreopen(base, origbaseflags, NULL); return; } ", "target": 1}
{"func": "static int matroskadecodebuffer(uint8t** buf, int* bufsize, MatroskaTrack *track) { MatroskaTrackEncoding *encodings = track->encodings.elem; uint8t* data = *buf; int isize = *bufsize; uint8t* pktdata = NULL; int pktsize = isize; int result = 0; int olen; switch (encodings[0].compression.algo) { case MATROSKATRACKENCODINGCOMPHEADERSTRIP: return encodings[0].compression.settings.size; case MATROSKATRACKENCODINGCOMPLZO: do { olen = pktsize *= 3; pktdata = avrealloc(pktdata, pktsize+AVLZOOUTPUTPADDING); result = avlzo1xdecode(pktdata, &olen, data, &isize); } while (result==AVLZOOUTPUTFULL && pktsize<10000000); if (result) goto failed; pktsize -= olen; break; #if CONFIGZLIB case MATROSKATRACKENCODINGCOMPZLIB: { zstream zstream = {0}; if (inflateInit(&zstream) != ZOK) zstream.nextin = data; zstream.availin = isize; do { pktsize *= 3; pktdata = avrealloc(pktdata, pktsize); zstream.availout = pktsize - zstream.totalout; zstream.nextout = pktdata + zstream.totalout; result = inflate(&zstream, ZNOFLUSH); } while (result==ZOK && pktsize<10000000); pktsize = zstream.totalout; inflateEnd(&zstream); if (result != ZSTREAMEND) goto failed; break; } #endif #if CONFIGBZLIB case MATROSKATRACKENCODINGCOMPBZLIB: { bzstream bzstream = {0}; if (BZ2bzDecompressInit(&bzstream, 0, 0) != BZOK) bzstream.nextin = data; bzstream.availin = isize; do { pktsize *= 3; pktdata = avrealloc(pktdata, pktsize); bzstream.availout = pktsize - bzstream.totaloutlo32; bzstream.nextout = pktdata + bzstream.totaloutlo32; result = BZ2bzDecompress(&bzstream); } while (result==BZOK && pktsize<10000000); pktsize = bzstream.totaloutlo32; BZ2bzDecompressEnd(&bzstream); if (result != BZSTREAMEND) goto failed; break; } #endif default: } *buf = pktdata; *bufsize = pktsize; return 0; failed: avfree(pktdata); }", "target": 1}
{"func": "void alphacpuunassignedaccess(CPUState *cs, hwaddr addr, bool iswrite, bool isexec, int unused, unsigned size) { AlphaCPU *cpu = ALPHACPU(cs); CPUAlphaState *env = &cpu->env; env->traparg0 = addr; env->traparg1 = iswrite ? 1 : 0; dynamicexcp(env, 0, EXCPMCHK, 0); } ", "target": 0}
{"func": "static int virtioserialinitpci(PCIDevice *pcidev) { VirtIOPCIProxy *proxy = DOUPCAST(VirtIOPCIProxy, pcidev, pcidev); VirtIODevice *vdev; if (proxy->classcode != PCICLASSCOMMUNICATIONOTHER && proxy->classcode != PCICLASSDISPLAYOTHER && /* qemu 0.10 */ proxy->classcode != PCICLASSOTHERS) /* qemu-kvm */ proxy->classcode = PCICLASSCOMMUNICATIONOTHER; vdev = virtioserialinit(&pcidev->qdev, &proxy->serial); if (!vdev) { return -1; } vdev->nvectors = proxy->nvectors == DEVNVECTORSUNSPECIFIED ? proxy->serial.maxvirtserialports + 1 : proxy->nvectors; virtioinitpci(proxy, vdev, PCIVENDORIDREDHATQUMRANET, PCIDEVICEIDVIRTIOCONSOLE, proxy->classcode, 0x00); proxy->nvectors = vdev->nvectors; return 0; } ", "target": 0}
{"func": "static CharDriverState *qmpchardevopenserial(const char *id, ChardevBackend *backend, ChardevReturn *ret, Error **errp) { ChardevHostdev *serial = backend->serial; int fd; fd = qmpchardevopenfilesource(serial->device, ORDWR, errp); if (fd < 0) { return NULL; } qemusetnonblock(fd); return qemuchropenttyfd(fd); } ", "target": 0}
{"func": "void alphapcivgasetup(PCIBus *pcibus) { switch (vgainterfacetype) { #ifdef CONFIGSPICE case VGAQXL: pcicreatesimple(pcibus, -1, \"qxl-vga\"); return; #endif case VGACIRRUS: pcicirrusvgainit(pcibus); return; case VGAVMWARE: if (pcivmsvgainit(pcibus)) { return; } break; } /* If VGA is enabled at all, and one of the above didn't work, then fallback to Standard VGA. */ if (vgainterfacetype != VGANONE) { pcivgainit(pcibus); } } ", "target": 0}
{"func": "struct omapuarts *omap2uartinit(struct omaptargetagents *ta, qemuirq irq, omapclk fclk, omapclk iclk, qemuirq txdma, qemuirq rxdma, CharDriverState *chr) { targetphysaddrt base = omapl4attach(ta, 0, 0); struct omapuarts *s = omapuartinit(base, irq, fclk, iclk, txdma, rxdma, chr); int iomemtype = cpuregisteriomemory(0, omapuartreadfn, omapuartwritefn, s); s->ta = ta; s->base = base; cpuregisterphysicalmemory(s->base + 0x20, 0x100, iomemtype); return s; } ", "target": 0}
{"func": "static void QEMUNORETURN help(void) { const char *helpmsg = QEMUIMGVERSION \"usage: qemu-img [standard options] command [command options]\\n\" \"QEMU disk image utility\\n\" \"\\n\" \" '-h', '--help' display this help and exit\\n\" \" '-V', '--version' output version information and exit\\n\" \" '-T', '--trace' [[enable=]<pattern>][,events=<file>][,file=<file>]\\n\" \" specify tracing options\\n\" \"\\n\" \"Command syntax:\\n\" #define DEF(option, callback, argstring) \\ \" \" argstring \"\\n\" #include \"qemu-img-cmds.h\" #undef DEF #undef GENDOCS \"\\n\" \"Command parameters:\\n\" \" 'filename' is a disk image filename\\n\" \" 'objectdef' is a QEMU user creatable object definition. See the qemu(1)\\n\" \" manual page for a description of the object properties. The most common\\n\" \" object type is a 'secret', which is used to supply passwords and/or\\n\" \" encryption keys.\\n\" \" 'fmt' is the disk image format. It is guessed automatically in most cases\\n\" \" 'cache' is the cache mode used to write the output disk image, the valid\\n\" \" options are: 'none', 'writeback' (default, except for convert), 'writethrough',\\n\" \" 'directsync' and 'unsafe' (default for convert)\\n\" \" 'srccache' is the cache mode used to read input disk images, the valid\\n\" \" options are the same as for the 'cache' option\\n\" \" 'size' is the disk image size in bytes. Optional suffixes\\n\" \" 'k' or 'K' (kilobyte, 1024), 'M' (megabyte, 1024k), 'G' (gigabyte, 1024M),\\n\" \" 'T' (terabyte, 1024G), 'P' (petabyte, 1024T) and 'E' (exabyte, 1024P) are\\n\" \" supported. 'b' is ignored.\\n\" \" 'outputfilename' is the destination disk image filename\\n\" \" 'outputfmt' is the destination format\\n\" \" 'options' is a comma separated list of format specific options in a\\n\" \" name=value format. Use -o ? for an overview of the options supported by the\\n\" \" used format\\n\" \" 'snapshotparam' is param used for internal snapshot, format\\n\" \" is 'snapshot.id=[ID],snapshot.name=[NAME]', or\\n\" \" '[IDORNAME]'\\n\" \" 'snapshotidorname' is deprecated, use 'snapshotparam'\\n\" \" instead\\n\" \" '-c' indicates that target image must be compressed (qcow format only)\\n\" \" '-u' enables unsafe rebasing. It is assumed that old and new backing file\\n\" \" match exactly. The image doesn't need a working backing file before\\n\" \" rebasing in this case (useful for renaming the backing file)\\n\" \" '-h' with or without a command shows this help and lists the supported formats\\n\" \" '-p' show progress of command (only certain commands)\\n\" \" '-q' use Quiet mode - do not print any output (except errors)\\n\" \" '-S' indicates the consecutive number of bytes (defaults to 4k) that must\\n\" \" contain only zeros for qemu-img to create a sparse image during\\n\" \" conversion. If the number of bytes is 0, the source will not be scanned for\\n\" \" unallocated or zero sectors, and the destination image will always be\\n\" \" fully allocated\\n\" \" '--output' takes the format in which the output must be done (human or json)\\n\" \" '-n' skips the target volume creation (useful if the volume is created\\n\" \" prior to running qemu-img)\\n\" \"\\n\" \"Parameters to check subcommand:\\n\" \" '-r' tries to repair any inconsistencies that are found during the check.\\n\" \" '-r leaks' repairs only cluster leaks, whereas '-r all' fixes all\\n\" \" kinds of errors, with a higher risk of choosing the wrong fix or\\n\" \" hiding corruption that has already occurred.\\n\" \"\\n\" \"Parameters to convert subcommand:\\n\" \" '-m' specifies how many coroutines work in parallel during the convert\\n\" \" process (defaults to 8)\\n\" \" '-W' allow to write to the target out of order rather than sequential\\n\" \"\\n\" \"Parameters to snapshot subcommand:\\n\" \" 'snapshot' is the name of the snapshot to create, apply or delete\\n\" \" '-a' applies a snapshot (revert disk to saved state)\\n\" \" '-c' creates a snapshot\\n\" \" '-d' deletes a snapshot\\n\" \" '-l' lists all snapshots in the given image\\n\" \"\\n\" \"Parameters to compare subcommand:\\n\" \" '-f' first image format\\n\" \" '-F' second image format\\n\" \" '-s' run in Strict mode - fail on different image size or sector allocation\\n\" \"\\n\" \"Parameters to dd subcommand:\\n\" \" 'bs=BYTES' read and write up to BYTES bytes at a time \" \"(default: 512)\\n\" \" 'count=N' copy only N input blocks\\n\" \" 'if=FILE' read from FILE\\n\" \" 'of=FILE' write to FILE\\n\" \" 'skip=N' skip N bs-sized blocks at the start of input\\n\"; printf(\"%s\\nSupported formats:\", helpmsg); bdrviterateformat(formatprint, NULL); printf(\"\\n\"); exit(EXITSUCCESS); } ", "target": 0}
{"func": "static void coroutinefn bdrvcreatecoentry(void *opaque) { Error *localerr = NULL; int ret; CreateCo *cco = opaque; assert(cco->drv); ret = cco->drv->bdrvcreate(cco->filename, cco->opts, &localerr); if (localerr) { errorpropagate(&cco->err, localerr); } cco->ret = ret; } ", "target": 0}
{"func": "void helpermtc0entryhi(CPUMIPSState *env, targetulong arg1) { targetulong old, val, mask; mask = (TARGETPAGEMASK << 1) | env->CP0EntryHiASIDmask; if (((env->CP0Config4 >> CP0C4IE) & 0x3) >= 2) { mask |= 1 << CP0EnHiEHINV; } /* 1k pages not implemented */ #if defined(TARGETMIPS64) if (env->insnflags & ISAMIPS32R6) { int entryhir = extract64(arg1, 62, 2); int config0at = extract32(env->CP0Config0, 13, 2); bool nosupervisor = (env->CP0Statusrwbitmask & 0x8) == 0; if ((entryhir == 2) || (entryhir == 1 && (nosupervisor || config0at == 1))) { /* skip EntryHi.R field if new value is reserved */ mask &= ~(0x3ull << 62); } } mask &= env->SEGMask; #endif old = env->CP0EntryHi; val = (arg1 & mask) | (old & ~mask); env->CP0EntryHi = val; if (env->CP0Config3 & (1 << CP0C3MT)) { syncc0entryhi(env, env->currenttc); } /* If the ASID changes, flush qemu's TLB. */ if ((old & env->CP0EntryHiASIDmask) != (val & env->CP0EntryHiASIDmask)) { cpumipstlbflush(env); } } ", "target": 0}
{"func": "static bool vmxnet3verifydrivermagic(hwaddr dshmem) { return (VMXNET3READDRVSHARED32(dshmem, magic) == VMXNET3REV1MAGIC); } ", "target": 1}
{"func": "ramaddrt qemuramaddrfromhostnofail(void *ptr) { ramaddrt ramaddr; if (qemuramaddrfromhost(ptr, &ramaddr)) { fprintf(stderr, \"Bad ram pointer %p\\n\", ptr); abort(); } return ramaddr; } ", "target": 1}
{"func": "static int decodeformat80(VqaContext *s, int srcsize, unsigned char *dest, int destsize, int checksize) { int destindex = 0; int count, opcode, start; int srcpos; unsigned char color; int i; start = bytestream2tell(&s->gb); while (bytestream2tell(&s->gb) - start < srcsize) { opcode = bytestream2getbyte(&s->gb); avdlog(s->avctx, \"opcode %02X: \", opcode); /* 0x80 means that frame is finished */ if (opcode == 0x80) break; if (destindex >= destsize) { avlog(s->avctx, AVLOGERROR, \"decodeformat80 problem: destindex (%d) exceeded destsize (%d)\\n\", destindex, destsize); return AVERRORINVALIDDATA; } if (opcode == 0xFF) { count = bytestream2getle16(&s->gb); srcpos = bytestream2getle16(&s->gb); avdlog(s->avctx, \"(1) copy %X bytes from absolute pos %X\\n\", count, srcpos); CHECKCOUNT(); CHECKCOPY(srcpos); for (i = 0; i < count; i++) dest[destindex + i] = dest[srcpos + i]; destindex += count; } else if (opcode == 0xFE) { count = bytestream2getle16(&s->gb); color = bytestream2getbyte(&s->gb); avdlog(s->avctx, \"(2) set %X bytes to %02X\\n\", count, color); CHECKCOUNT(); memset(&dest[destindex], color, count); destindex += count; } else if ((opcode & 0xC0) == 0xC0) { count = (opcode & 0x3F) + 3; srcpos = bytestream2getle16(&s->gb); avdlog(s->avctx, \"(3) copy %X bytes from absolute pos %X\\n\", count, srcpos); CHECKCOUNT(); CHECKCOPY(srcpos); for (i = 0; i < count; i++) dest[destindex + i] = dest[srcpos + i]; destindex += count; } else if (opcode > 0x80) { count = opcode & 0x3F; avdlog(s->avctx, \"(4) copy %X bytes from source to dest\\n\", count); CHECKCOUNT(); bytestream2getbuffer(&s->gb, &dest[destindex], count); destindex += count; } else { count = ((opcode & 0x70) >> 4) + 3; srcpos = bytestream2getbyte(&s->gb) | ((opcode & 0x0F) << 8); avdlog(s->avctx, \"(5) copy %X bytes from relpos %X\\n\", count, srcpos); CHECKCOUNT(); CHECKCOPY(destindex - srcpos); for (i = 0; i < count; i++) dest[destindex + i] = dest[destindex - srcpos + i]; destindex += count; } } /* validate that the entire destination buffer was filled; this is * important for decoding frame maps since each vector needs to have a * codebook entry; it is not important for compressed codebooks because * not every entry needs to be filled */ if (checksize) if (destindex < destsize) avlog(s->avctx, AVLOGERROR, \"decodeformat80 problem: decode finished with destindex (%d) < destsize (%d)\\n\", destindex, destsize); return 0; // let's display what we decoded anyway } ", "target": 1}
{"func": "static int zero12vdecodeframe(AVCodecContext *avctx, void *data, int *gotframe, AVPacket *avpkt) { int line = 0, ret; const int width = avctx->width; AVFrame *pic = data; uint16t *y, *u, *v; const uint8t *lineend, *src = avpkt->data; int stride = avctx->width * 8 / 3; if (width == 1) { avlog(avctx, AVLOGERROR, \"Width 1 not supported.\\n\"); return AVERRORINVALIDDATA; } if ( avctx->codectag == MKTAG('0', '1', '2', 'v') && avpkt->size % avctx->height == 0 && avpkt->size / avctx->height * 3 >= width * 8) stride = avpkt->size / avctx->height; if (avpkt->size < avctx->height * stride) { avlog(avctx, AVLOGERROR, \"Packet too small: %d instead of %d\\n\", avpkt->size, avctx->height * stride); return AVERRORINVALIDDATA; } if ((ret = ffgetbuffer(avctx, pic, 0)) < 0) return ret; pic->picttype = AVPICTURETYPEI; pic->keyframe = 1; y = (uint16t *)pic->data[0]; u = (uint16t *)pic->data[1]; v = (uint16t *)pic->data[2]; lineend = avpkt->data + stride; while (line++ < avctx->height) { while (1) { uint32t t = AVRL32(src); src += 4; *u++ = t << 6 & 0xFFC0; *y++ = t >> 4 & 0xFFC0; *v++ = t >> 14 & 0xFFC0; if (src >= lineend - 1) { *y = 0x80; src++; lineend += stride; y = (uint16t *)(pic->data[0] + line * pic->linesize[0]); u = (uint16t *)(pic->data[1] + line * pic->linesize[1]); v = (uint16t *)(pic->data[2] + line * pic->linesize[2]); break; } t = AVRL32(src); src += 4; *y++ = t << 6 & 0xFFC0; *u++ = t >> 4 & 0xFFC0; *y++ = t >> 14 & 0xFFC0; if (src >= lineend - 2) { if (!(width & 1)) { *y = 0x80; src += 2; } lineend += stride; y = (uint16t *)(pic->data[0] + line * pic->linesize[0]); u = (uint16t *)(pic->data[1] + line * pic->linesize[1]); v = (uint16t *)(pic->data[2] + line * pic->linesize[2]); break; } t = AVRL32(src); src += 4; *v++ = t << 6 & 0xFFC0; *y++ = t >> 4 & 0xFFC0; *u++ = t >> 14 & 0xFFC0; if (src >= lineend - 1) { *y = 0x80; src++; lineend += stride; y = (uint16t *)(pic->data[0] + line * pic->linesize[0]); u = (uint16t *)(pic->data[1] + line * pic->linesize[1]); v = (uint16t *)(pic->data[2] + line * pic->linesize[2]); break; } t = AVRL32(src); src += 4; *y++ = t << 6 & 0xFFC0; *v++ = t >> 4 & 0xFFC0; *y++ = t >> 14 & 0xFFC0; if (src >= lineend - 2) { if (width & 1) { *y = 0x80; src += 2; } lineend += stride; y = (uint16t *)(pic->data[0] + line * pic->linesize[0]); u = (uint16t *)(pic->data[1] + line * pic->linesize[1]); v = (uint16t *)(pic->data[2] + line * pic->linesize[2]); break; } } } *gotframe = 1; return avpkt->size; } ", "target": 1}
{"func": "static inline int testbit(uint32t *field, int bit) { return (field[bit >> 5] & 1 << (bit & 0x1F)) != 0; } ", "target": 0}
{"func": "static void testqemustrtouldecimal(void) { const char *str = \"0123\"; char f = 'X'; const char *endptr = &f; unsigned long res = 999; int err; err = qemustrtoul(str, &endptr, 10, &res); gassertcmpint(err, ==, 0); gassertcmpint(res, ==, 123); gassert(endptr == str + strlen(str)); str = \"123\"; res = 999; endptr = &f; err = qemustrtoul(str, &endptr, 0, &res); gassertcmpint(err, ==, 0); gassertcmpint(res, ==, 123); gassert(endptr == str + strlen(str)); } ", "target": 0}
{"func": "static void piix3classinit(ObjectClass *klass, void *data) { DeviceClass *dc = DEVICECLASS(klass); PCIDeviceClass *k = PCIDEVICECLASS(klass); dc->desc = \"ISA bridge\"; dc->vmsd = &vmstatepiix3; dc->nouser = 1, k->nohotplug = 1; k->init = piix3initfn; k->configwrite = piix3writeconfig; k->vendorid = PCIVENDORIDINTEL; /* 82371SB PIIX3 PCI-to-ISA bridge (Step A1) */ k->deviceid = PCIDEVICEIDINTEL82371SB0; k->classid = PCICLASSBRIDGEISA; } ", "target": 1}
{"func": "qiochannelwebsocksourcedispatch(GSource *source, GSourceFunc callback, gpointer userdata) { QIOChannelFunc func = (QIOChannelFunc)callback; QIOChannelWebsockSource *wsource = (QIOChannelWebsockSource *)source; GIOCondition cond = 0; if (wsource->wioc->rawinput.offset) { cond |= GIOIN; } if (wsource->wioc->rawoutput.offset < QIOCHANNELWEBSOCKMAXBUFFER) { cond |= GIOOUT; } return (*func)(QIOCHANNEL(wsource->wioc), (cond & wsource->condition), userdata); } ", "target": 1}
{"func": "static void acpidsdtaddpci(Aml *scope, const MemMapEntry *memmap, uint32t irq, bool usehighmem) { Aml *method, *crs, *ifctx, *UUID, *ifctx1, *elsectx, *buf; int i, busno; hwaddr basemmio = memmap[VIRTPCIEMMIO].base; hwaddr sizemmio = memmap[VIRTPCIEMMIO].size; hwaddr basepio = memmap[VIRTPCIEPIO].base; hwaddr sizepio = memmap[VIRTPCIEPIO].size; hwaddr baseecam = memmap[VIRTPCIEECAM].base; hwaddr sizeecam = memmap[VIRTPCIEECAM].size; int nrpciebuses = sizeecam / PCIEMMCFGSIZEMIN; Aml *dev = amldevice(\"%s\", \"PCI0\"); amlappend(dev, amlnamedecl(\"HID\", amlstring(\"PNP0A08\"))); amlappend(dev, amlnamedecl(\"CID\", amlstring(\"PNP0A03\"))); amlappend(dev, amlnamedecl(\"SEG\", amlint(0))); amlappend(dev, amlnamedecl(\"BBN\", amlint(0))); amlappend(dev, amlnamedecl(\"ADR\", amlint(0))); amlappend(dev, amlnamedecl(\"UID\", amlstring(\"PCI0\"))); amlappend(dev, amlnamedecl(\"STR\", amlunicode(\"PCIe 0 Device\"))); amlappend(dev, amlnamedecl(\"CCA\", amlint(1))); /* Declare the PCI Routing Table. */ Aml *rtpkg = amlpackage(nrpciebuses * PCINUMPINS); for (busno = 0; busno < nrpciebuses; busno++) { for (i = 0; i < PCINUMPINS; i++) { int gsi = (i + busno) % PCINUMPINS; Aml *pkg = amlpackage(4); amlappend(pkg, amlint((busno << 16) | 0xFFFF)); amlappend(pkg, amlint(i)); amlappend(pkg, amlname(\"GSI%d\", gsi)); amlappend(pkg, amlint(0)); amlappend(rtpkg, pkg); } } amlappend(dev, amlnamedecl(\"PRT\", rtpkg)); /* Create GSI link device */ for (i = 0; i < PCINUMPINS; i++) { uint32t irqs = irq + i; Aml *devgsi = amldevice(\"GSI%d\", i); amlappend(devgsi, amlnamedecl(\"HID\", amlstring(\"PNP0C0F\"))); amlappend(devgsi, amlnamedecl(\"UID\", amlint(0))); crs = amlresourcetemplate(); amlappend(crs, amlinterrupt(AMLCONSUMER, AMLLEVEL, AMLACTIVEHIGH, AMLEXCLUSIVE, &irqs, 1)); amlappend(devgsi, amlnamedecl(\"PRS\", crs)); crs = amlresourcetemplate(); amlappend(crs, amlinterrupt(AMLCONSUMER, AMLLEVEL, AMLACTIVEHIGH, AMLEXCLUSIVE, &irqs, 1)); amlappend(devgsi, amlnamedecl(\"CRS\", crs)); method = amlmethod(\"SRS\", 1, AMLNOTSERIALIZED); amlappend(devgsi, method); amlappend(dev, devgsi); } method = amlmethod(\"CBA\", 0, AMLNOTSERIALIZED); amlappend(method, amlreturn(amlint(baseecam))); amlappend(dev, method); method = amlmethod(\"CRS\", 0, AMLNOTSERIALIZED); Aml *rbuf = amlresourcetemplate(); amlappend(rbuf, amlwordbusnumber(AMLMINFIXED, AMLMAXFIXED, AMLPOSDECODE, 0x0000, 0x0000, nrpciebuses - 1, 0x0000, nrpciebuses)); amlappend(rbuf, amldwordmemory(AMLPOSDECODE, AMLMINFIXED, AMLMAXFIXED, AMLNONCACHEABLE, AMLREADWRITE, 0x0000, basemmio, basemmio + sizemmio - 1, 0x0000, sizemmio)); amlappend(rbuf, amldwordio(AMLMINFIXED, AMLMAXFIXED, AMLPOSDECODE, AMLENTIRERANGE, 0x0000, 0x0000, sizepio - 1, basepio, sizepio)); if (usehighmem) { hwaddr basemmiohigh = memmap[VIRTPCIEMMIOHIGH].base; hwaddr sizemmiohigh = memmap[VIRTPCIEMMIOHIGH].size; amlappend(rbuf, amlqwordmemory(AMLPOSDECODE, AMLMINFIXED, AMLMAXFIXED, AMLNONCACHEABLE, AMLREADWRITE, 0x0000, basemmiohigh, basemmiohigh, 0x0000, sizemmiohigh)); } amlappend(method, amlnamedecl(\"RBUF\", rbuf)); amlappend(method, amlreturn(rbuf)); amlappend(dev, method); /* Declare an OSC (OS Control Handoff) method */ amlappend(dev, amlnamedecl(\"SUPP\", amlint(0))); amlappend(dev, amlnamedecl(\"CTRL\", amlint(0))); method = amlmethod(\"OSC\", 4, AMLNOTSERIALIZED); amlappend(method, amlcreatedwordfield(amlarg(3), amlint(0), \"CDW1\")); /* PCI Firmware Specification 3.0 * 4.5.1. OSC Interface for PCI Host Bridge Devices * The OSC interface for a PCI/PCI-X/PCI Express hierarchy is * identified by the Universal Unique IDentifier (UUID) * 33DB4D5B-1FF7-401C-9657-7441C03DD766 */ UUID = amltouuid(\"33DB4D5B-1FF7-401C-9657-7441C03DD766\"); ifctx = amlif(amlequal(amlarg(0), UUID)); amlappend(ifctx, amlcreatedwordfield(amlarg(3), amlint(4), \"CDW2\")); amlappend(ifctx, amlcreatedwordfield(amlarg(3), amlint(8), \"CDW3\")); amlappend(ifctx, amlstore(amlname(\"CDW2\"), amlname(\"SUPP\"))); amlappend(ifctx, amlstore(amlname(\"CDW3\"), amlname(\"CTRL\"))); amlappend(ifctx, amlstore(amland(amlname(\"CTRL\"), amlint(0x1D), NULL), amlname(\"CTRL\"))); ifctx1 = amlif(amllnot(amlequal(amlarg(1), amlint(0x1)))); amlappend(ifctx1, amlstore(amlor(amlname(\"CDW1\"), amlint(0x08), NULL), amlname(\"CDW1\"))); amlappend(ifctx, ifctx1); ifctx1 = amlif(amllnot(amlequal(amlname(\"CDW3\"), amlname(\"CTRL\")))); amlappend(ifctx1, amlstore(amlor(amlname(\"CDW1\"), amlint(0x10), NULL), amlname(\"CDW1\"))); amlappend(ifctx, ifctx1); amlappend(ifctx, amlstore(amlname(\"CTRL\"), amlname(\"CDW3\"))); amlappend(ifctx, amlreturn(amlarg(3))); amlappend(method, ifctx); elsectx = amlelse(); amlappend(elsectx, amlstore(amlor(amlname(\"CDW1\"), amlint(4), NULL), amlname(\"CDW1\"))); amlappend(elsectx, amlreturn(amlarg(3))); amlappend(method, elsectx); amlappend(dev, method); method = amlmethod(\"DSM\", 4, AMLNOTSERIALIZED); /* PCI Firmware Specification 3.0 * 4.6.1. DSM for PCI Express Slot Information * The UUID in DSM in this context is * {E5C937D0-3553-4D7A-9117-EA4D19C3434D} */ UUID = amltouuid(\"E5C937D0-3553-4D7A-9117-EA4D19C3434D\"); ifctx = amlif(amlequal(amlarg(0), UUID)); ifctx1 = amlif(amlequal(amlarg(2), amlint(0))); uint8t bytelist[1] = {1}; buf = amlbuffer(1, bytelist); amlappend(ifctx1, amlreturn(buf)); amlappend(ifctx, ifctx1); amlappend(method, ifctx); bytelist[0] = 0; buf = amlbuffer(1, bytelist); amlappend(method, amlreturn(buf)); amlappend(dev, method); Aml *devrp0 = amldevice(\"%s\", \"RP0\"); amlappend(devrp0, amlnamedecl(\"ADR\", amlint(0))); amlappend(dev, devrp0); amlappend(scope, dev); } ", "target": 0}
{"func": "static int vmdkparentopen(BlockDriverState *bs) { char *pname; char desc[DESCSIZE + 1]; BDRVVmdkState *s = bs->opaque; desc[DESCSIZE] = '\\0'; if (bdrvpread(bs->file, s->descoffset, desc, DESCSIZE) != DESCSIZE) { return -1; } if ((pname = strstr(desc,\"parentFileNameHint\")) != NULL) { char *endname; pname += sizeof(\"parentFileNameHint\") + 1; if ((endname = strchr(pname,'\\\"')) == NULL) return -1; if ((endname - pname) > sizeof (bs->backingfile) - 1) return -1; pstrcpy(bs->backingfile, endname - pname + 1, pname); } return 0; } ", "target": 0}
{"func": "static MemoryRegionSection addressspacedotranslate(AddressSpace *as, hwaddr addr, hwaddr *xlat, hwaddr *plen, bool iswrite, bool ismmio) { IOMMUTLBEntry iotlb; MemoryRegionSection *section; MemoryRegion *mr; for (;;) { AddressSpaceDispatch *d = atomicrcuread(&as->dispatch); section = addressspacetranslateinternal(d, addr, &addr, plen, ismmio); mr = section->mr; if (!mr->iommuops) { break; } iotlb = mr->iommuops->translate(mr, addr, iswrite); addr = ((iotlb.translatedaddr & ~iotlb.addrmask) | (addr & iotlb.addrmask)); *plen = MIN(*plen, (addr | iotlb.addrmask) - addr + 1); if (!(iotlb.perm & (1 << iswrite))) { goto translatefail; } as = iotlb.targetas; } *xlat = addr; return *section; translatefail: return (MemoryRegionSection) { .mr = &iomemunassigned }; } ", "target": 0}
{"func": "static void readguestmem(void) { uint32t *guestmem; gint64 endtime; int i, j; sizet size; gmutexlock(datamutex); endtime = ggetmonotonictime() + 5 * GTIMESPANSECOND; while (!fdsnum) { if (!condwaituntil(datacond, datamutex, endtime)) { /* timeout has passed */ gassert(fdsnum); break; } } /* check for sanity */ gassertcmpint(fdsnum, >, 0); gassertcmpint(fdsnum, ==, memory.nregions); /* iterate all regions */ for (i = 0; i < fdsnum; i++) { /* We'll check only the region statring at 0x0*/ if (memory.regions[i].guestphysaddr != 0x0) { continue; } gassertcmpint(memory.regions[i].memorysize, >, 1024); size = memory.regions[i].memorysize + memory.regions[i].mmapoffset; guestmem = mmap(0, size, PROTREAD | PROTWRITE, MAPSHARED, fds[i], 0); gassert(guestmem != MAPFAILED); guestmem += (memory.regions[i].mmapoffset / sizeof(*guestmem)); for (j = 0; j < 256; j++) { uint32t a = readl(memory.regions[i].guestphysaddr + j*4); uint32t b = guestmem[j]; gassertcmpint(a, ==, b); } munmap(guestmem, memory.regions[i].memorysize); } gassertcmpint(1, ==, 1); gmutexunlock(datamutex); } ", "target": 0}
{"func": "static uint64t qemurdmapoll(RDMAContext *rdma, uint64t *wridout, uint32t *bytelen) { int ret; struct ibvwc wc; uint64t wrid; ret = ibvpollcq(rdma->cq, 1, &wc); if (!ret) { *wridout = RDMAWRIDNONE; return 0; } if (ret < 0) { fprintf(stderr, \"ibvpollcq return %d!\\n\", ret); return ret; } wrid = wc.wrid & RDMAWRIDTYPEMASK; if (wc.status != IBVWCSUCCESS) { fprintf(stderr, \"ibvpollcq wc.status=%d %s!\\n\", wc.status, ibvwcstatusstr(wc.status)); fprintf(stderr, \"ibvpollcq wrid=%s!\\n\", wriddesc[wrid]); return -1; } if (rdma->controlreadyexpected && (wrid >= RDMAWRIDRECVCONTROL)) { DDDPRINTF(\"completion %s #%\" PRId64 \" received (%\" PRId64 \")\" \" left %d\\n\", wriddesc[RDMAWRIDRECVCONTROL], wrid - RDMAWRIDRECVCONTROL, wrid, rdma->nbsent); rdma->controlreadyexpected = 0; } if (wrid == RDMAWRIDRDMAWRITE) { uint64t chunk = (wc.wrid & RDMAWRIDCHUNKMASK) >> RDMAWRIDCHUNKSHIFT; uint64t index = (wc.wrid & RDMAWRIDBLOCKMASK) >> RDMAWRIDBLOCKSHIFT; RDMALocalBlock *block = &(rdma->localramblocks.block[index]); DDDPRINTF(\"completions %s (%\" PRId64 \") left %d, \" \"block %\" PRIu64 \", chunk: %\" PRIu64 \" %p %p\\n\", printwrid(wrid), wrid, rdma->nbsent, index, chunk, block->localhostaddr, (void *)block->remotehostaddr); clearbit(chunk, block->transitbitmap); if (rdma->nbsent > 0) { rdma->nbsent--; } if (!rdma->pinall) { /* * FYI: If one wanted to signal a specific chunk to be unregistered * using LRU or workload-specific information, this is the function * you would call to do so. That chunk would then get asynchronously * unregistered later. */ #ifdef RDMAUNREGISTRATIONEXAMPLE qemurdmasignalunregister(rdma, index, chunk, wc.wrid); #endif } } else { DDDPRINTF(\"other completion %s (%\" PRId64 \") received left %d\\n\", printwrid(wrid), wrid, rdma->nbsent); } *wridout = wc.wrid; if (bytelen) { *bytelen = wc.bytelen; } return 0; } ", "target": 1}
{"func": "static int movreadftyp(MOVContext *c, AVIOContext *pb, MOVAtom atom) { uint32t minorver; int compbrandsize; char minorverstr[11]; /* 32 bit integer -> 10 digits + null */ char* compbrandsstr; uint8t type[5] = {0}; avioread(pb, type, 4); if (strcmp(type, \"qt \")) c->isom = 1; avlog(c->fc, AVLOGDEBUG, \"ISO: File Type Major Brand: %.4s\\n\",(char *)&type); avdictset(&c->fc->metadata, \"majorbrand\", type, 0); minorver = aviorb32(pb); /* minor version */ snprintf(minorverstr, sizeof(minorverstr), \"%\"PRIu32\"\", minorver); avdictset(&c->fc->metadata, \"minorversion\", minorverstr, 0); compbrandsize = atom.size - 8; if (compbrandsize < 0) return AVERRORINVALIDDATA; compbrandsstr = avmalloc(compbrandsize + 1); /* Add null terminator */ if (!compbrandsstr) return AVERROR(ENOMEM); avioread(pb, compbrandsstr, compbrandsize); compbrandsstr[compbrandsize] = 0; avdictset(&c->fc->metadata, \"compatiblebrands\", compbrandsstr, 0); avfreep(&compbrandsstr); return 0; } ", "target": 1}
{"func": "static void qpcipcconfigwritew(QPCIBus *bus, int devfn, uint8t offset, uint16t value) { outl(0xcf8, (1 << 31) | (devfn << 8) | offset); outw(0xcfc, value); } ", "target": 1}
{"func": "static int decodestreamheader(NUTContext *nut){ AVFormatContext *s= nut->avf; ByteIOContext *bc = &s->pb; StreamContext *stc; int class, streamid; uint64t tmp, end; AVStream *st; end= getpacketheader(nut, bc, 1); end += urlftell(bc); GETV(streamid, tmp < s->nbstreams && !nut->stream[tmp].timebase); stc= &nut->stream[streamid]; st = s->streams[streamid]; if (!st) return AVERROR(ENOMEM); class = getv(bc); tmp = getfourcc(bc); st->codec->codectag= tmp; switch(class) { case 0: st->codec->codectype = CODECTYPEVIDEO; st->codec->codecid = codecgetid(codecbmptags, tmp); if (st->codec->codecid == CODECIDNONE) avlog(s, AVLOGERROR, \"Unknown codec?!\\n\"); break; case 1: st->codec->codectype = CODECTYPEAUDIO; st->codec->codecid = codecgetid(codecwavtags, tmp); if (st->codec->codecid == CODECIDNONE) avlog(s, AVLOGERROR, \"Unknown codec?!\\n\"); break; case 2: // st->codec->codectype = CODECTYPETEXT; // break; case 3: st->codec->codectype = CODECTYPEDATA; break; default: avlog(s, AVLOGERROR, \"Unknown stream class (%d)\\n\", class); return -1; } GETV(stc->timebaseid , tmp < nut->timebasecount); GETV(stc->msbptsshift , tmp < 16); stc->maxptsdistance= getv(bc); GETV(stc->decodedelay , tmp < 1000); //sanity limit, raise this if moors law is true st->codec->hasbframes= stc->decodedelay; getv(bc); //stream flags GETV(st->codec->extradatasize, tmp < (1<<30)); if(st->codec->extradatasize){ st->codec->extradata= avmallocz(st->codec->extradatasize + FFINPUTBUFFERPADDINGSIZE); getbuffer(bc, st->codec->extradata, st->codec->extradatasize); } if (st->codec->codectype == CODECTYPEVIDEO){ GETV(st->codec->width , tmp > 0) GETV(st->codec->height, tmp > 0) st->codec->sampleaspectratio.num= getv(bc); st->codec->sampleaspectratio.den= getv(bc); if((!st->codec->sampleaspectratio.num) != (!st->codec->sampleaspectratio.den)){ avlog(s, AVLOGERROR, \"invalid aspect ratio\\n\"); return -1; } getv(bc); /* csp type */ }else if (st->codec->codectype == CODECTYPEAUDIO){ GETV(st->codec->samplerate , tmp > 0) tmp= getv(bc); // samplerateden if(tmp > st->codec->samplerate){ avlog(s, AVLOGERROR, \"bleh, libnut muxed this ;)\\n\"); st->codec->samplerate= tmp; } GETV(st->codec->channels, tmp > 0) } if(skipreserved(bc, end) || getchecksum(bc)){ avlog(s, AVLOGERROR, \"Stream header %d checksum mismatch\\n\", streamid); return -1; } stc->timebase= &nut->timebase[stc->timebaseid]; avsetptsinfo(s->streams[streamid], 63, stc->timebase->num, stc->timebase->den); return 0; } ", "target": 0}
{"func": "static void lzunpack(const unsigned char *src, unsigned char *dest, int destlen) { const unsigned char *s; unsigned char *d; unsigned char *dend; unsigned char queue[QUEUESIZE]; unsigned int qpos; unsigned int dataleft; unsigned int chainofs; unsigned int chainlen; unsigned int speclen; unsigned char tag; unsigned int i, j; s = src; d = dest; dend = d + destlen; dataleft = AVRL32(s); s += 4; memset(queue, 0x20, QUEUESIZE); if (AVRL32(s) == 0x56781234) { s += 4; qpos = 0x111; speclen = 0xF + 3; } else { qpos = 0xFEE; speclen = 100; /* no speclen */ } while (dataleft > 0) { tag = *s++; if ((tag == 0xFF) && (dataleft > 8)) { if (d + 8 > dend) return; for (i = 0; i < 8; i++) { queue[qpos++] = *d++ = *s++; qpos &= QUEUEMASK; } dataleft -= 8; } else { for (i = 0; i < 8; i++) { if (dataleft == 0) break; if (tag & 0x01) { if (d + 1 > dend) return; queue[qpos++] = *d++ = *s++; qpos &= QUEUEMASK; dataleft--; } else { chainofs = *s++; chainofs |= ((*s & 0xF0) << 4); chainlen = (*s++ & 0x0F) + 3; if (chainlen == speclen) chainlen = *s++ + 0xF + 3; if (d + chainlen > dend) return; for (j = 0; j < chainlen; j++) { *d = queue[chainofs++ & QUEUEMASK]; queue[qpos++] = *d++; qpos &= QUEUEMASK; } dataleft -= chainlen; } tag >>= 1; } } } } ", "target": 1}
{"func": "void scsireqcancel(SCSIRequest *req) { tracescsireqcancel(req->dev->id, req->lun, req->tag); if (!req->enqueued) { return; } scsireqref(req); scsireqdequeue(req); req->iocanceled = true; if (req->aiocb) { blkaiocancel(req->aiocb); } else { scsireqcancelcomplete(req); } }", "target": 1}
{"func": "static void genexceptionreturn(DisasContext *s, TCGvi32 pc) { TCGvi32 tmp; storereg(s, 15, pc); tmp = loadcpufield(spsr); gensetcpsr(tmp, CPSRERETMASK); tcgtempfreei32(tmp); s->isjmp = DISASUPDATE; } ", "target": 1}
{"func": "static void qiochannelwebsockwriteclose(QIOChannelWebsock *ioc, uint16t code, const char *reason) { struct iovec iov; bufferreserve(&ioc->rawoutput, 2 + (reason ? strlen(reason) : 0)); *(uint16t *)(ioc->rawoutput.buffer + ioc->rawoutput.offset) = cputobe16(code); ioc->rawoutput.offset += 2; if (reason) { bufferappend(&ioc->rawoutput, reason, strlen(reason)); } iov.iovbase = ioc->rawoutput.buffer; iov.iovlen = ioc->rawoutput.offset; qiochannelwebsockencode(ioc, QIOCHANNELWEBSOCKOPCODECLOSE, &iov, 1, iov.iovlen); bufferreset(&ioc->rawoutput); qiochannelwebsockwritewire(ioc, NULL); qiochannelshutdown(ioc->master, QIOCHANNELSHUTDOWNBOTH, NULL); } ", "target": 0}
{"func": "static void fadtsetup(AcpiFadtDescriptorRev1 *fadt, AcpiPmInfo *pm) { fadt->model = 1; fadt->reserved1 = 0; fadt->sciint = cputole16(pm->sciint); fadt->smicmd = cputole32(ACPIPORTSMICMD); fadt->acpienable = pm->acpienablecmd; fadt->acpidisable = pm->acpidisablecmd; /* EVT, CNT, TMR offset matches hw/acpi/core.c */ fadt->pm1aevtblk = cputole32(pm->iobase); fadt->pm1acntblk = cputole32(pm->iobase + 0x04); fadt->pmtmrblk = cputole32(pm->iobase + 0x08); fadt->gpe0blk = cputole32(pm->gpe0blk); /* EVT, CNT, TMR length matches hw/acpi/core.c */ fadt->pm1evtlen = 4; fadt->pm1cntlen = 2; fadt->pmtmrlen = 4; fadt->gpe0blklen = pm->gpe0blklen; fadt->plvl2lat = cputole16(0xfff); /* C2 state not supported */ fadt->plvl3lat = cputole16(0xfff); /* C3 state not supported */ fadt->flags = cputole32((1 << ACPIFADTFWBINVD) | (1 << ACPIFADTFPROCC1) | (1 << ACPIFADTFSLPBUTTON) | (1 << ACPIFADTFRTCS4)); fadt->flags |= cputole32(1 << ACPIFADTFUSEPLATFORMCLOCK); /* APIC destination mode (\"Flat Logical\") has an upper limit of 8 CPUs * For more than 8 CPUs, \"Clustered Logical\" mode has to be used */ if (maxcpus > 8) { fadt->flags |= cputole32(1 << ACPIFADTFFORCEAPICCLUSTERMODEL); } fadt->century = RTCCENTURY; } ", "target": 0}
{"func": "void acpipm1cntwrite(ACPIREGS *ar, uint16t val) { ar->pm1.cnt.cnt = val & ~(ACPIBITMASKSLEEPENABLE); if (val & ACPIBITMASKSLEEPENABLE) { /* change suspend type */ uint16t sustyp = (val >> 10) & 7; switch(sustyp) { case 0: /* soft power off */ qemusystemshutdownrequest(); break; case 1: /* ACPIBITMASKWAKESTATUS should be set on resume. Pretend that resume was caused by power button */ ar->pm1.evt.sts |= (ACPIBITMASKWAKESTATUS | ACPIBITMASKPOWERBUTTONSTATUS); qemusystemresetrequest(); qemuirqraise(ar->pm1.cnt.cmoss3); default: break; } } } ", "target": 0}
{"func": "static void win32rearmtimer(struct qemualarmtimer *t) { struct qemualarmwin32 *data = t->priv; uint64t nearestdeltaus; if (!activetimers[QEMUTIMERREALTIME] && !activetimers[QEMUTIMERVIRTUAL]) return; nearestdeltaus = qemunextdeadlinedyntick(); nearestdeltaus /= 1000; timeKillEvent(data->timerId); data->timerId = timeSetEvent(1, data->period, hostalarmhandler, (DWORD)t, TIMEONESHOT | TIMEPERIODIC); if (!data->timerId) { fprintf(stderr, \"Failed to re-arm win32 alarm timer %ld\\n\", GetLastError()); timeEndPeriod(data->period); exit(1); } } ", "target": 0}
{"func": "static void qapideallocendstruct(Visitor *v, Error **errp) { QapiDeallocVisitor *qov = toqov(v); void **obj = qapideallocpop(qov); if (obj) { gfree(*obj); } } ", "target": 1}
{"func": "static void filecompletion(const char *input) { DIR *ffs; struct dirent *d; char path[1024]; char file[1024], fileprefix[1024]; int inputpathlen; const char *p; p = strrchr(input, '/'); if (!p) { inputpathlen = 0; pstrcpy(fileprefix, sizeof(fileprefix), input); pstrcpy(path, sizeof(path), \".\"); } else { inputpathlen = p - input + 1; memcpy(path, input, inputpathlen); if (inputpathlen > sizeof(path) - 1) inputpathlen = sizeof(path) - 1; path[inputpathlen] = '\\0'; pstrcpy(fileprefix, sizeof(fileprefix), p + 1); } #ifdef DEBUGCOMPLETION monitorprintf(curmon, \"input='%s' path='%s' prefix='%s'\\n\", input, path, fileprefix); #endif ffs = opendir(path); if (!ffs) return; for(;;) { struct stat sb; d = readdir(ffs); if (!d) break; if (strcmp(d->dname, \".\") == 0 || strcmp(d->dname, \"..\") == 0) { continue; } if (strstart(d->dname, fileprefix, NULL)) { memcpy(file, input, inputpathlen); if (inputpathlen < sizeof(file)) pstrcpy(file + inputpathlen, sizeof(file) - inputpathlen, d->dname); /* stat the file to find out if it's a directory. * In that case add a slash to speed up typing long paths */ stat(file, &sb); if(SISDIR(sb.stmode)) pstrcat(file, sizeof(file), \"/\"); readlineaddcompletion(curmon->rs, file); } } closedir(ffs); } ", "target": 1}
{"func": "static void setint8(Object *obj, Visitor *v, void *opaque, const char *name, Error **errp) { DeviceState *dev = DEVICE(obj); Property *prop = opaque; int8t *ptr = qdevgetpropptr(dev, prop); Error *localerr = NULL; int64t value; if (dev->state != DEVSTATECREATED) { errorset(errp, QERRPERMISSIONDENIED); return; } visittypeint(v, &value, name, &localerr); if (localerr) { errorpropagate(errp, localerr); return; } if (value > prop->info->min && value <= prop->info->max) { *ptr = value; } else { errorset(errp, QERRPROPERTYVALUEOUTOFRANGE, dev->id?:\"\", name, value, prop->info->min, prop->info->max); } } ", "target": 1}
{"func": "static void entermigrationcoroutine(void *opaque) { Coroutine *co = opaque; qemucoroutineenter(co, NULL); } ", "target": 1}
{"func": "static int decodechannelresidues(WmallDecodeCtx *s, int ch, int tilesize) { int i = 0; unsigned int avemean; s->transient[ch] = getbits1(&s->gb); if (s->transient[ch]) { s->transientpos[ch] = getbits(&s->gb, avlog2(tilesize)); if (s->transientpos[ch]) s->transient[ch] = 0; s->channel[ch].transientcounter = FFMAX(s->channel[ch].transientcounter, s->samplesperframe / 2); } else if (s->channel[ch].transientcounter) s->transient[ch] = 1; if (s->seekabletile) { avemean = getbits(&s->gb, s->bitspersample); s->avesum[ch] = avemean << (s->movavescaling + 1); } if (s->seekabletile) { if (s->dointerchdecorr) s->channelresidues[ch][0] = getsbits(&s->gb, s->bitspersample + 1); else s->channelresidues[ch][0] = getsbits(&s->gb, s->bitspersample); i++; } for (; i < tilesize; i++) { int quo = 0, rem, rembits, residue; while(getbits1(&s->gb)) { quo++; if (getbitsleft(&s->gb) <= 0) return -1; } if (quo >= 32) quo += getbitslong(&s->gb, getbits(&s->gb, 5) + 1); avemean = (s->avesum[ch] + (1 << s->movavescaling)) >> (s->movavescaling + 1); if (avemean <= 1) residue = quo; else { rembits = avceillog2(avemean); rem = rembits ? getbits(&s->gb, rembits) : 0; residue = (quo << rembits) + rem; } s->avesum[ch] = residue + s->avesum[ch] - (s->avesum[ch] >> s->movavescaling); if (residue & 1) residue = -(residue >> 1) - 1; else residue = residue >> 1; s->channelresidues[ch][i] = residue; } return 0; } ", "target": 1}
{"func": "static int cinaudiodecodeframe(AVCodecContext *avctx, void *data, int *datasize, AVPacket *avpkt) { const uint8t *buf = avpkt->data; int bufsize = avpkt->size; CinAudioContext *cin = avctx->privdata; const uint8t *src = buf; int16t *samples = data; int delta; bufsize = FFMIN(bufsize, *datasize/2); delta = cin->delta; if (cin->initialdecodeframe) { cin->initialdecodeframe = 0; delta = (int16t)AVRL16(src); src += 2; *samples++ = delta; bufsize -= 2; } while (bufsize > 0) { delta += cinaudiodelta16table[*src++]; delta = avclipint16(delta); *samples++ = delta; --bufsize; } cin->delta = delta; *datasize = (uint8t *)samples - (uint8t *)data; return src - buf; } ", "target": 0}
{"func": "static void rv34predmvrv3(RV34DecContext *r, int blocktype, int dir) { MpegEncContext *s = &r->s; int mvpos = s->mbx * 2 + s->mby * 2 * s->b8stride; int A[2] = {0}, B[2], C[2]; int i, j, k; int mx, my; int availindex = availindexes[0]; if(r->availcache[availindex - 1]){ A[0] = s->currentpictureptr->f.motionval[0][mvpos - 1][0]; A[1] = s->currentpictureptr->f.motionval[0][mvpos - 1][1]; } if(r->availcache[availindex - 4]){ B[0] = s->currentpictureptr->f.motionval[0][mvpos - s->b8stride][0]; B[1] = s->currentpictureptr->f.motionval[0][mvpos - s->b8stride][1]; }else{ B[0] = A[0]; B[1] = A[1]; } if(!r->availcache[availindex - 4 + 2]){ if(r->availcache[availindex - 4] && (r->availcache[availindex - 1])){ C[0] = s->currentpictureptr->f.motionval[0][mvpos - s->b8stride - 1][0]; C[1] = s->currentpictureptr->f.motionval[0][mvpos - s->b8stride - 1][1]; }else{ C[0] = A[0]; C[1] = A[1]; } }else{ C[0] = s->currentpictureptr->f.motionval[0][mvpos - s->b8stride + 2][0]; C[1] = s->currentpictureptr->f.motionval[0][mvpos - s->b8stride + 2][1]; } mx = midpred(A[0], B[0], C[0]); my = midpred(A[1], B[1], C[1]); mx += r->dmv[0][0]; my += r->dmv[0][1]; for(j = 0; j < 2; j++){ for(i = 0; i < 2; i++){ for(k = 0; k < 2; k++){ s->currentpictureptr->f.motionval[k][mvpos + i + j*s->b8stride][0] = mx; s->currentpictureptr->f.motionval[k][mvpos + i + j*s->b8stride][1] = my; } } } } ", "target": 0}
{"func": "int qemupaioinit(struct qemupaioinit *aioinit) { int ret; ret = pthreadattrinit(&attr); if (ret) die2(ret, \"pthreadattrinit\"); ret = pthreadattrsetdetachstate(&attr, PTHREADCREATEDETACHED); if (ret) die2(ret, \"pthreadattrsetdetachstate\"); TAILQINIT(&requestlist); return 0; } ", "target": 0}
{"func": "dprint(int level, const char *fmt, ...) { valist args; if (level <= debug) { vastart(args, fmt); vfprintf(stderr, fmt, args); vaend(args); } } ", "target": 0}
{"func": "static void s390pcihosthotplug(HotplugHandler *hotplugdev, DeviceState *dev, Error **errp) { PCIDevice *pcidev = PCIDEVICE(dev); S390PCIBusDevice *pbdev; S390pciState *s = S390PCIHOSTBRIDGE(pcidevicerootbus(pcidev) ->qbus.parent); pbdev = &s->pbdev[PCISLOT(pcidev->devfn)]; pbdev->fid = s390pcigetpfid(pcidev); pbdev->pdev = pcidev; pbdev->configured = true; pbdev->fh = s390pcigetpfh(pcidev); s390pcihostsetupmsix(pbdev); if (dev->hotplugged) { s390pcigenerateplugevent(HPEVENTRESERVEDTOSTANDBY, pbdev->fh, pbdev->fid); s390pcigenerateplugevent(HPEVENTTOCONFIGURED, pbdev->fh, pbdev->fid); } } ", "target": 0}
{"func": "static uint64t pxa2xxmmread(void *opaque, hwaddr addr, unsigned size) { PXA2xxState *s = (PXA2xxState *) opaque; switch (addr) { case MDCNFG ... SA1110: if ((addr & 3) == 0) return s->mmregs[addr >> 2]; default: printf(\"%s: Bad register \" REGFMT \"\\n\", FUNCTION, addr); break; } return 0; } ", "target": 0}
{"func": "static int vhostverifyringmappings(struct vhostdev *dev, uint64t startaddr, uint64t size) { int i, j; int r = 0; const char *partname[] = { \"descriptor table\", \"available ring\", \"used ring\" }; for (i = 0; i < dev->nvqs; ++i) { struct vhostvirtqueue *vq = dev->vqs + i; j = 0; r = vhostverifyringpartmapping(vq->desc, vq->descphys, vq->descsize, startaddr, size); if (!r) { break; } j++; r = vhostverifyringpartmapping(vq->avail, vq->availphys, vq->availsize, startaddr, size); if (!r) { break; } j++; r = vhostverifyringpartmapping(vq->used, vq->usedphys, vq->usedsize, startaddr, size); if (!r) { break; } } if (r == -ENOMEM) { errorreport(\"Unable to map %s for ring %d\", partname[j], i); } else if (r == -EBUSY) { errorreport(\"%s relocated for ring %d\", partname[j], i); } return r; } ", "target": 0}
{"func": "void qemuramremap(ramaddrt addr, ramaddrt length) { RAMBlock *block; ramaddrt offset; int flags; void *area, *vaddr; QTAILQFOREACH(block, &ramlist.blocks, next) { offset = addr - block->offset; if (offset < block->length) { vaddr = block->host + offset; if (block->flags & RAMPREALLOCMASK) { ; } else if (xenenabled()) { abort(); } else { flags = MAPFIXED; munmap(vaddr, length); if (mempath) { #if defined(linux) && !defined(TARGETS390X) if (block->fd) { #ifdef MAPPOPULATE flags |= memprealloc ? MAPPOPULATE | MAPSHARED : MAPPRIVATE; #else flags |= MAPPRIVATE; #endif area = mmap(vaddr, length, PROTREAD | PROTWRITE, flags, block->fd, offset); } else { flags |= MAPPRIVATE | MAPANONYMOUS; area = mmap(vaddr, length, PROTREAD | PROTWRITE, flags, -1, 0); } #else abort(); #endif } else { #if defined(TARGETS390X) && defined(CONFIGKVM) flags |= MAPSHARED | MAPANONYMOUS; area = mmap(vaddr, length, PROTEXEC|PROTREAD|PROTWRITE, flags, -1, 0); #else flags |= MAPPRIVATE | MAPANONYMOUS; area = mmap(vaddr, length, PROTREAD | PROTWRITE, flags, -1, 0); #endif } if (area != vaddr) { fprintf(stderr, \"Could not remap addr: \" RAMADDRFMT \"@\" RAMADDRFMT \"\\n\", length, addr); exit(1); } memorytryenablemerging(vaddr, length); qemuramsetupdump(vaddr, length); } return; } } } ", "target": 0}
{"func": "const char *objectgettypename(Object *obj) { return obj->class->type->name; } ", "target": 1}
{"func": "static int vaapibuilddecoderconfig(VAAPIDecoderContext *ctx, AVCodecContext *avctx, int fallbackallowed) { AVVAAPIDeviceContext *hwctx = ctx->device->hwctx; AVVAAPIHWConfig *hwconfig = NULL; AVHWFramesConstraints *constraints = NULL; VAStatus vas; int err, i, j; int loglevel = fallbackallowed ? AVLOGVERBOSE : AVLOGERROR; const AVCodecDescriptor *codecdesc; const AVPixFmtDescriptor *pixdesc; enum AVPixelFormat pixfmt; VAProfile profile, *profilelist = NULL; int profilecount, exactmatch, altprofile; codecdesc = avcodecdescriptorget(avctx->codecid); if (!codecdesc) { err = AVERROR(EINVAL); goto fail; } profilecount = vaMaxNumProfiles(hwctx->display); profilelist = avmalloc(profilecount * sizeof(VAProfile)); if (!profilelist) { err = AVERROR(ENOMEM); goto fail; } vas = vaQueryConfigProfiles(hwctx->display, profilelist, &profilecount); if (vas != VASTATUSSUCCESS) { avlog(ctx, loglevel, \"Failed to query profiles: %d (%s).\\n\", vas, vaErrorStr(vas)); err = AVERROR(EIO); goto fail; } profile = VAProfileNone; exactmatch = 0; for (i = 0; i < FFARRAYELEMS(vaapiprofilemap); i++) { int profilematch = 0; if (avctx->codecid != vaapiprofilemap[i].codecid) continue; if (avctx->profile == vaapiprofilemap[i].codecprofile) profilematch = 1; profile = vaapiprofilemap[i].vaprofile; for (j = 0; j < profilecount; j++) { if (profile == profilelist[j]) { exactmatch = profilematch; break; } } if (j < profilecount) { if (exactmatch) break; altprofile = vaapiprofilemap[i].codecprofile; } } avfreep(&profilelist); if (profile == VAProfileNone) { avlog(ctx, loglevel, \"No VAAPI support for codec %s.\\n\", codecdesc->name); err = AVERROR(ENOSYS); goto fail; } if (!exactmatch) { if (fallbackallowed || !hwaccellaxprofilecheck) { avlog(ctx, loglevel, \"No VAAPI support for codec %s \" \"profile %d.\\n\", codecdesc->name, avctx->profile); if (!fallbackallowed) { avlog(ctx, AVLOGWARNING, \"If you want attempt decoding \" \"anyway with a possibly-incompatible profile, add \" \"the option -hwaccellaxprofilecheck.\\n\"); } err = AVERROR(EINVAL); goto fail; } else { avlog(ctx, AVLOGWARNING, \"No VAAPI support for codec %s \" \"profile %d: trying instead with profile %d.\\n\", codecdesc->name, avctx->profile, altprofile); avlog(ctx, AVLOGWARNING, \"This may fail or give \" \"incorrect results, depending on your hardware.\\n\"); } } ctx->vaprofile = profile; ctx->vaentrypoint = VAEntrypointVLD; vas = vaCreateConfig(hwctx->display, ctx->vaprofile, ctx->vaentrypoint, 0, 0, &ctx->vaconfig); if (vas != VASTATUSSUCCESS) { avlog(ctx, AVLOGERROR, \"Failed to create decode pipeline \" \"configuration: %d (%s).\\n\", vas, vaErrorStr(vas)); err = AVERROR(EIO); goto fail; } hwconfig = avhwdevicehwconfigalloc(ctx->deviceref); if (!hwconfig) { err = AVERROR(ENOMEM); goto fail; } hwconfig->configid = ctx->vaconfig; constraints = avhwdevicegethwframeconstraints(ctx->deviceref, hwconfig); if (!constraints) goto fail; // Decide on the decoder target format. // If the user specified something with -hwacceloutputformat then // try to use that to minimise conversions later. ctx->decodeformat = AVPIXFMTNONE; if (ctx->outputformat != AVPIXFMTNONE && ctx->outputformat != AVPIXFMTVAAPI) { for (i = 0; constraints->validswformats[i] != AVPIXFMTNONE; i++) { if (constraints->validswformats[i] == ctx->decodeformat) { ctx->decodeformat = ctx->outputformat; avlog(ctx, AVLOGDEBUG, \"Using decode format %s (output \" \"format).\\n\", avgetpixfmtname(ctx->decodeformat)); break; } } } // Otherwise, we would like to try to choose something which matches the // decoder output, but there isn't enough information available here to // do so. Assume for now that we are always dealing with YUV 4:2:0, so // pick a format which does that. if (ctx->decodeformat == AVPIXFMTNONE) { for (i = 0; constraints->validswformats[i] != AVPIXFMTNONE; i++) { pixfmt = constraints->validswformats[i]; pixdesc = avpixfmtdescget(pixfmt); if (pixdesc->nbcomponents == 3 && pixdesc->log2chromaw == 1 && pixdesc->log2chromah == 1) { ctx->decodeformat = pixfmt; avlog(ctx, AVLOGDEBUG, \"Using decode format %s (format \" \"matched).\\n\", avgetpixfmtname(ctx->decodeformat)); break; } } } // Otherwise pick the first in the list and hope for the best. if (ctx->decodeformat == AVPIXFMTNONE) { ctx->decodeformat = constraints->validswformats[0]; avlog(ctx, AVLOGDEBUG, \"Using decode format %s (first in list).\\n\", avgetpixfmtname(ctx->decodeformat)); if (i > 1) { // There was a choice, and we picked randomly. Warn the user // that they might want to choose intelligently instead. avlog(ctx, AVLOGWARNING, \"Using randomly chosen decode \" \"format %s.\\n\", avgetpixfmtname(ctx->decodeformat)); } } // Ensure the picture size is supported by the hardware. ctx->decodewidth = avctx->codedwidth; ctx->decodeheight = avctx->codedheight; if (ctx->decodewidth < constraints->minwidth || ctx->decodeheight < constraints->minheight || ctx->decodewidth > constraints->maxwidth || ctx->decodeheight >constraints->maxheight) { avlog(ctx, AVLOGERROR, \"VAAPI hardware does not support image \" \"size %dx%d (constraints: width %d-%d height %d-%d).\\n\", ctx->decodewidth, ctx->decodeheight, constraints->minwidth, constraints->maxwidth, constraints->minheight, constraints->maxheight); err = AVERROR(EINVAL); goto fail; } avhwframeconstraintsfree(&constraints); avfreep(&hwconfig); // Decide how many reference frames we need. This might be doable more // nicely based on the codec and input stream? ctx->decodesurfaces = DEFAULTSURFACES; // For frame-threaded decoding, one additional surfaces is needed for // each thread. if (avctx->activethreadtype & FFTHREADFRAME) ctx->decodesurfaces += avctx->threadcount; return 0; fail: avhwframeconstraintsfree(&constraints); avfreep(&hwconfig); vaDestroyConfig(hwctx->display, ctx->vaconfig); avfreep(&profilelist); return err; } ", "target": 0}
{"func": "static int parse(AVCodecParserContext *ctx, AVCodecContext *avctx, const uint8t **outdata, int *outsize, const uint8t *data, int size) { VP9ParseContext *s = ctx->privdata; int marker; if (size <= 0) { *outsize = 0; *outdata = data; return 0; } if (s->nframes > 0) { *outdata = data; *outsize = s->size[--s->nframes]; parseframe(ctx, *outdata, *outsize); return s->nframes > 0 ? *outsize : size /* i.e. include idx tail */; } marker = data[size - 1]; if ((marker & 0xe0) == 0xc0) { int nbytes = 1 + ((marker >> 3) & 0x3); int nframes = 1 + (marker & 0x7), idxsz = 2 + nframes * nbytes; if (size >= idxsz && data[size - idxsz] == marker) { const uint8t *idx = data + size + 1 - idxsz; int first = 1; switch (nbytes) { #define casen(a, rd) \\ case a: \\ while (nframes--) { \\ int sz = rd; \\ idx += a; \\ if (sz > size) { \\ s->nframes = 0; \\ avlog(avctx, AVLOGERROR, \\ \"Superframe packet size too big: %d > %d\\n\", \\ sz, size); \\ return AVERRORINVALIDDATA; \\ } \\ if (first) { \\ first = 0; \\ *outdata = data; \\ *outsize = sz; \\ s->nframes = nframes; \\ } else { \\ s->size[nframes] = sz; \\ } \\ data += sz; \\ size -= sz; \\ } \\ parseframe(ctx, *outdata, *outsize); \\ return *outsize casen(1, *idx); casen(2, AVRL16(idx)); casen(3, AVRL24(idx)); casen(4, AVRL32(idx)); } } } *outdata = data; *outsize = size; parseframe(ctx, data, size); return size; } ", "target": 0}
{"func": "static int raminit1(SysBusDevice *dev) { RamDevice *d = SUN4URAM(dev); memoryregioninitram(&d->ram, OBJECT(d), \"sun4u.ram\", d->size, &errorabort); vmstateregisterramglobal(&d->ram); sysbusinitmmio(dev, &d->ram); return 0; } ", "target": 1}
{"func": "static void stoptco(const TestData *d) { uint32t val; val = qpciioreadw(d->dev, d->tcoiobase + TCO1CNT); val |= TCOTMRHLT; qpciiowritew(d->dev, d->tcoiobase + TCO1CNT, val); } ", "target": 1}
{"func": "void qemuputbe32(QEMUFile *f, unsigned int v) { qemuputbyte(f, v >> 24); qemuputbyte(f, v >> 16); qemuputbyte(f, v >> 8); qemuputbyte(f, v); } ", "target": 1}
{"func": "static const unsigned char *sequnpackrleblock(const unsigned char *src, unsigned char *dst, int dstsize) { int i, len, sz; GetBitContext gb; int codetable[64]; /* get the rle codes (at most 64 bytes) */ initgetbits(&gb, src, 64 * 8); for (i = 0, sz = 0; i < 64 && sz < dstsize; i++) { codetable[i] = getsbits(&gb, 4); sz += FFABS(codetable[i]); } src += (getbitscount(&gb) + 7) / 8; /* do the rle unpacking */ for (i = 0; i < 64 && dstsize > 0; i++) { len = codetable[i]; if (len < 0) { len = -len; memset(dst, *src++, FFMIN(len, dstsize)); } else { memcpy(dst, src, FFMIN(len, dstsize)); src += len; } dst += len; dstsize -= len; } return src; } ", "target": 1}
{"func": "bool bdrvisfirstnonfilter(BlockDriverState *candidate) { BlockDriverState *bs; BdrvNextIterator *it = NULL; /* walk down the bs forest recursively */ while ((it = bdrvnext(it, &bs)) != NULL) { bool perm; /* try to recurse in this top level bs */ perm = bdrvrecurseisfirstnonfilter(bs, candidate); /* candidate is the first non filter */ if (perm) { return true; } } return false; } ", "target": 1}
{"func": "static int vhostusersetmemtable(struct vhostdev *dev, struct vhostmemory *mem) { int fds[VHOSTMEMORYMAXNREGIONS]; int i, fd; sizet fdnum = 0; bool replysupported = virtiohasfeature(dev->protocolfeatures, VHOSTUSERPROTOCOLFREPLYACK); VhostUserMsg msg = { .hdr.request = VHOSTUSERSETMEMTABLE, .hdr.flags = VHOSTUSERVERSION, }; if (replysupported) { msg.hdr.flags |= VHOSTUSERNEEDREPLYMASK; } for (i = 0; i < dev->mem->nregions; ++i) { struct vhostmemoryregion *reg = dev->mem->regions + i; ramaddrt offset; MemoryRegion *mr; assert((uintptrt)reg->userspaceaddr == reg->userspaceaddr); mr = memoryregionfromhost((void *)(uintptrt)reg->userspaceaddr, &offset); fd = memoryregiongetfd(mr); if (fd > 0) { msg.payload.memory.regions[fdnum].userspaceaddr = reg->userspaceaddr; msg.payload.memory.regions[fdnum].memorysize = reg->memorysize; msg.payload.memory.regions[fdnum].guestphysaddr = reg->guestphysaddr; msg.payload.memory.regions[fdnum].mmapoffset = offset; assert(fdnum < VHOSTMEMORYMAXNREGIONS); fds[fdnum++] = fd; } } msg.payload.memory.nregions = fdnum; if (!fdnum) { errorreport(\"Failed initializing vhost-user memory map, \" \"consider using -object memory-backend-file share=on\"); return -1; } msg.hdr.size = sizeof(msg.payload.memory.nregions); msg.hdr.size += sizeof(msg.payload.memory.padding); msg.hdr.size += fdnum * sizeof(VhostUserMemoryRegion); if (vhostuserwrite(dev, &msg, fds, fdnum) < 0) { return -1; } if (replysupported) { return processmessagereply(dev, &msg); } return 0; } ", "target": 1}
{"func": "int avparserparse2(AVCodecParserContext *s, AVCodecContext *avctx, uint8t **poutbuf, int *poutbufsize, const uint8t *buf, int bufsize, int64t pts, int64t dts, int64t pos) { int index, i; uint8t dummybuf[AVINPUTBUFFERPADDINGSIZE]; if (!(s->flags & PARSERFLAGFETCHEDOFFSET)) { s->nextframeoffset = s->curoffset = pos; s->flags |= PARSERFLAGFETCHEDOFFSET; } if (bufsize == 0) { /* padding is always necessary even if EOF, so we add it here */ memset(dummybuf, 0, sizeof(dummybuf)); buf = dummybuf; } else if (s->curoffset + bufsize != s->curframeend[s->curframestartindex]) { /* skip remainder packets */ /* add a new packet descriptor */ i = (s->curframestartindex + 1) & (AVPARSERPTSNB - 1); s->curframestartindex = i; s->curframeoffset[i] = s->curoffset; s->curframeend[i] = s->curoffset + bufsize; s->curframepts[i] = pts; s->curframedts[i] = dts; s->curframepos[i] = pos; } if (s->fetchtimestamp) { s->fetchtimestamp = 0; s->lastpts = s->pts; s->lastdts = s->dts; s->lastpos = s->pos; fffetchtimestamp(s, 0, 0, 0); } /* WARNING: the returned index can be negative */ index = s->parser->parserparse(s, avctx, (const uint8t **) poutbuf, poutbufsize, buf, bufsize); avassert0(index > -0x20000000); // The API does not allow returning AVERROR codes /* update the file pointer */ if (*poutbufsize) { /* fill the data for the current frame */ s->frameoffset = s->nextframeoffset; /* offset of the next frame */ s->nextframeoffset = s->curoffset + index; s->fetchtimestamp = 1; } if (index < 0) index = 0; s->curoffset += index; return index; }", "target": 1}
{"func": "static int nbdcoreadv1(NbdClientSession *client, int64t sectornum, int nbsectors, QEMUIOVector *qiov, int offset) { struct nbdrequest request; struct nbdreply reply; ssizet ret; request.type = NBDCMDREAD; request.from = sectornum * 512; request.len = nbsectors * 512; nbdcoroutinestart(client, &request); ret = nbdcosendrequest(client, &request, NULL, 0); if (ret < 0) { reply.error = -ret; } else { nbdcoreceivereply(client, &request, &reply, qiov, offset); } nbdcoroutineend(client, &request); return -reply.error; } ", "target": 1}
{"func": "static AVIOContext * wtvfileopen2(AVFormatContext *s, const uint8t *buf, int bufsize, const uint8t *filename, int filenamesize) { const uint8t *bufend = buf + bufsize; while(buf + 48 <= bufend) { int dirlength, namesize, firstsector, depth; uint64t filelength; const uint8t *name; if (ffguidcmp(buf, direntryguid)) { avlog(s, AVLOGERROR, \"unknown guid \"FFPRIGUID\", expected direntryguid; \" \"remaining directory entries ignored\\n\", FFARGGUID(buf)); break; } dirlength = AVRL16(buf + 16); filelength = AVRL64(buf + 24); namesize = 2 * AVRL32(buf + 32); if (buf + 48 + namesize > bufend) { avlog(s, AVLOGERROR, \"filename exceeds buffer size; remaining directory entries ignored\\n\"); break; } firstsector = AVRL32(buf + 40 + namesize); depth = AVRL32(buf + 44 + namesize); /* compare file name; test optional null terminator */ name = buf + 40; if (namesize >= filenamesize && !memcmp(name, filename, filenamesize) && (namesize < filenamesize + 2 || !AVRN16(name + filenamesize))) return wtvfileopensector(firstsector, filelength, depth, s); buf += dirlength; } return 0; } ", "target": 1}
{"func": "static void stereoprocessing(PSContext *ps, INTFLOAT (*l)[32][2], INTFLOAT (*r)[32][2], int is34) { int e, b, k; INTFLOAT (*H11)[PSMAXNUMENV+1][PSMAXNRIIDICC] = ps->H11; INTFLOAT (*H12)[PSMAXNUMENV+1][PSMAXNRIIDICC] = ps->H12; INTFLOAT (*H21)[PSMAXNUMENV+1][PSMAXNRIIDICC] = ps->H21; INTFLOAT (*H22)[PSMAXNUMENV+1][PSMAXNRIIDICC] = ps->H22; int8t *opdhist = ps->opdhist; int8t *ipdhist = ps->ipdhist; int8t iidmappedbuf[PSMAXNUMENV][PSMAXNRIIDICC]; int8t iccmappedbuf[PSMAXNUMENV][PSMAXNRIIDICC]; int8t ipdmappedbuf[PSMAXNUMENV][PSMAXNRIIDICC]; int8t opdmappedbuf[PSMAXNUMENV][PSMAXNRIIDICC]; int8t (*iidmapped)[PSMAXNRIIDICC] = iidmappedbuf; int8t (*iccmapped)[PSMAXNRIIDICC] = iccmappedbuf; int8t (*ipdmapped)[PSMAXNRIIDICC] = ipdmappedbuf; int8t (*opdmapped)[PSMAXNRIIDICC] = opdmappedbuf; const int8t *ktoi = is34 ? ktoi34 : ktoi20; TABLECONST INTFLOAT (*HLUT)[8][4] = (PSBASELINE || ps->iccmode < 3) ? HA : HB; //Remapping if (ps->numenvold) { memcpy(H11[0][0], H11[0][ps->numenvold], PSMAXNRIIDICC*sizeof(H11[0][0][0])); memcpy(H11[1][0], H11[1][ps->numenvold], PSMAXNRIIDICC*sizeof(H11[1][0][0])); memcpy(H12[0][0], H12[0][ps->numenvold], PSMAXNRIIDICC*sizeof(H12[0][0][0])); memcpy(H12[1][0], H12[1][ps->numenvold], PSMAXNRIIDICC*sizeof(H12[1][0][0])); memcpy(H21[0][0], H21[0][ps->numenvold], PSMAXNRIIDICC*sizeof(H21[0][0][0])); memcpy(H21[1][0], H21[1][ps->numenvold], PSMAXNRIIDICC*sizeof(H21[1][0][0])); memcpy(H22[0][0], H22[0][ps->numenvold], PSMAXNRIIDICC*sizeof(H22[0][0][0])); memcpy(H22[1][0], H22[1][ps->numenvold], PSMAXNRIIDICC*sizeof(H22[1][0][0])); } if (is34) { remap34(&iidmapped, ps->iidpar, ps->nriidpar, ps->numenv, 1); remap34(&iccmapped, ps->iccpar, ps->nriccpar, ps->numenv, 1); if (ps->enableipdopd) { remap34(&ipdmapped, ps->ipdpar, ps->nripdopdpar, ps->numenv, 0); remap34(&opdmapped, ps->opdpar, ps->nripdopdpar, ps->numenv, 0); } if (!ps->is34bandsold) { mapval20to34(H11[0][0]); mapval20to34(H11[1][0]); mapval20to34(H12[0][0]); mapval20to34(H12[1][0]); mapval20to34(H21[0][0]); mapval20to34(H21[1][0]); mapval20to34(H22[0][0]); mapval20to34(H22[1][0]); ipdopdreset(ipdhist, opdhist); } } else { remap20(&iidmapped, ps->iidpar, ps->nriidpar, ps->numenv, 1); remap20(&iccmapped, ps->iccpar, ps->nriccpar, ps->numenv, 1); if (ps->enableipdopd) { remap20(&ipdmapped, ps->ipdpar, ps->nripdopdpar, ps->numenv, 0); remap20(&opdmapped, ps->opdpar, ps->nripdopdpar, ps->numenv, 0); } if (ps->is34bandsold) { mapval34to20(H11[0][0]); mapval34to20(H11[1][0]); mapval34to20(H12[0][0]); mapval34to20(H12[1][0]); mapval34to20(H21[0][0]); mapval34to20(H21[1][0]); mapval34to20(H22[0][0]); mapval34to20(H22[1][0]); ipdopdreset(ipdhist, opdhist); } } //Mixing for (e = 0; e < ps->numenv; e++) { for (b = 0; b < NRPARBANDS[is34]; b++) { INTFLOAT h11, h12, h21, h22; h11 = HLUT[iidmapped[e][b] + 7 + 23 * ps->iidquant][iccmapped[e][b]][0]; h12 = HLUT[iidmapped[e][b] + 7 + 23 * ps->iidquant][iccmapped[e][b]][1]; h21 = HLUT[iidmapped[e][b] + 7 + 23 * ps->iidquant][iccmapped[e][b]][2]; h22 = HLUT[iidmapped[e][b] + 7 + 23 * ps->iidquant][iccmapped[e][b]][3]; if (!PSBASELINE && ps->enableipdopd && b < NRIPDOPDBANDS[is34]) { //The spec say says to only run this smoother when enableipdopd //is set but the reference decoder appears to run it constantly INTFLOAT h11i, h12i, h21i, h22i; INTFLOAT ipdadjre, ipdadjim; int opdidx = opdhist[b] * 8 + opdmapped[e][b]; int ipdidx = ipdhist[b] * 8 + ipdmapped[e][b]; INTFLOAT opdre = pdresmooth[opdidx]; INTFLOAT opdim = pdimsmooth[opdidx]; INTFLOAT ipdre = pdresmooth[ipdidx]; INTFLOAT ipdim = pdimsmooth[ipdidx]; opdhist[b] = opdidx & 0x3F; ipdhist[b] = ipdidx & 0x3F; ipdadjre = AACMADD30(opdre, ipdre, opdim, ipdim); ipdadjim = AACMSUB30(opdim, ipdre, opdre, ipdim); h11i = AACMUL30(h11, opdim); h11 = AACMUL30(h11, opdre); h12i = AACMUL30(h12, ipdadjim); h12 = AACMUL30(h12, ipdadjre); h21i = AACMUL30(h21, opdim); h21 = AACMUL30(h21, opdre); h22i = AACMUL30(h22, ipdadjim); h22 = AACMUL30(h22, ipdadjre); H11[1][e+1][b] = h11i; H12[1][e+1][b] = h12i; H21[1][e+1][b] = h21i; H22[1][e+1][b] = h22i; } H11[0][e+1][b] = h11; H12[0][e+1][b] = h12; H21[0][e+1][b] = h21; H22[0][e+1][b] = h22; } for (k = 0; k < NRBANDS[is34]; k++) { LOCALALIGNED16(INTFLOAT, h, [2], [4]); LOCALALIGNED16(INTFLOAT, hstep, [2], [4]); int start = ps->borderposition[e]; int stop = ps->borderposition[e+1]; INTFLOAT width = Q30(1.f) / ((stop - start) ? (stop - start) : 1); #if USEFIXED width <<= 1; #endif b = ktoi[k]; h[0][0] = H11[0][e][b]; h[0][1] = H12[0][e][b]; h[0][2] = H21[0][e][b]; h[0][3] = H22[0][e][b]; if (!PSBASELINE && ps->enableipdopd) { //Is this necessary? ps04new seems unchanged if ((is34 && k <= 13 && k >= 9) || (!is34 && k <= 1)) { h[1][0] = -H11[1][e][b]; h[1][1] = -H12[1][e][b]; h[1][2] = -H21[1][e][b]; h[1][3] = -H22[1][e][b]; } else { h[1][0] = H11[1][e][b]; h[1][1] = H12[1][e][b]; h[1][2] = H21[1][e][b]; h[1][3] = H22[1][e][b]; } } //Interpolation hstep[0][0] = AACMSUB31V3(H11[0][e+1][b], h[0][0], width); hstep[0][1] = AACMSUB31V3(H12[0][e+1][b], h[0][1], width); hstep[0][2] = AACMSUB31V3(H21[0][e+1][b], h[0][2], width); hstep[0][3] = AACMSUB31V3(H22[0][e+1][b], h[0][3], width); if (!PSBASELINE && ps->enableipdopd) { hstep[1][0] = AACMSUB31V3(H11[1][e+1][b], h[1][0], width); hstep[1][1] = AACMSUB31V3(H12[1][e+1][b], h[1][1], width); hstep[1][2] = AACMSUB31V3(H21[1][e+1][b], h[1][2], width); hstep[1][3] = AACMSUB31V3(H22[1][e+1][b], h[1][3], width); } ps->dsp.stereointerpolate[!PSBASELINE && ps->enableipdopd]( l[k] + start + 1, r[k] + start + 1, h, hstep, stop - start); } } } ", "target": 1}
{"func": "static void handleqmpcommand(JSONMessageParser *parser, QList *tokens) { int err; QObject *obj; QDict *input, *args; const moncmdt *cmd; Monitor *mon = curmon; const char *cmdname, *infoitem; args = NULL; obj = jsonparserparse(tokens, NULL); if (!obj) { // FIXME: should be triggered in jsonparserparse() qerrorreport(QERRJSONPARSING); goto errout; qerrorreport(QERRQMPBADINPUTOBJECT, \"object\"); qobjectdecref(obj); goto errout; } input = qobjecttoqdict(obj); mon->mc->id = qdictget(input, \"id\"); qobjectincref(mon->mc->id); obj = qdictget(input, \"execute\"); if (!obj) { qerrorreport(QERRQMPBADINPUTOBJECT, \"execute\"); } else if (qobjecttype(obj) != QTYPEQSTRING) { qerrorreport(QERRQMPBADINPUTOBJECTMEMBER, \"execute\", \"string\"); } cmdname = qstringgetstr(qobjecttoqstring(obj)); if (invalidqmpmode(mon, cmdname)) { qerrorreport(QERRCOMMANDNOTFOUND, cmdname); } /* * XXX: We need this special case until we get info handlers * converted into 'query-' commands */ if (comparecmd(cmdname, \"info\")) { qerrorreport(QERRCOMMANDNOTFOUND, cmdname); } else if (strstart(cmdname, \"query-\", &infoitem)) { cmd = monitorfindcommand(\"info\"); qdictputobj(input, \"arguments\", qobjectfromjsonf(\"{ 'item': %s }\", infoitem)); } else { cmd = monitorfindcommand(cmdname); if (!cmd || !monitorhandlerported(cmd)) { qerrorreport(QERRCOMMANDNOTFOUND, cmdname); } } obj = qdictget(input, \"arguments\"); if (!obj) { args = qdictnew(); } else { args = qobjecttoqdict(obj); QINCREF(args); } QDECREF(input); err = monitorcheckqmpargs(cmd, args); if (err < 0) { goto errout; } if (monitorhandlerisasync(cmd)) { qmpasynccmdhandler(mon, cmd, args); } else { monitorcallhandler(mon, cmd, args); } goto out; errinput: QDECREF(input); errout: monitorprotocolemitter(mon, NULL); out: QDECREF(args); }", "target": 1}
{"func": "static int idcindecodeinit(AVCodecContext *avctx) { IdcinContext *s = avctx->privdata; int i, j, histogramindex = 0; unsigned char *histograms; s->avctx = avctx; avctx->pixfmt = PIXFMTPAL8; dsputilinit(&s->dsp, avctx); /* make sure the Huffman tables make it */ if (s->avctx->extradatasize != HUFFMANTABLESIZE) { avlog(s->avctx, AVLOGERROR, \" Id CIN video: expected extradata size of %d\\n\", HUFFMANTABLESIZE); return -1; } /* build the 256 Huffman decode trees */ histograms = (unsigned char *)s->avctx->extradata; for (i = 0; i < 256; i++) { for(j = 0; j < HUFTOKENS; j++) s->huffnodes[i][j].count = histograms[histogramindex++]; huffbuildtree(s, i); } s->frame.data[0] = NULL; return 0; } ", "target": 0}
{"func": "static void findbestsolidarea(VncState *vs, int x, int y, int w, int h, uint32t color, int *wptr, int *hptr) { int dx, dy, dw, dh; int wprev; int wbest = 0, hbest = 0; wprev = w; for (dy = y; dy < y + h; dy += VNCTIGHTMAXSPLITTILESIZE) { dh = MIN(VNCTIGHTMAXSPLITTILESIZE, y + h - dy); dw = MIN(VNCTIGHTMAXSPLITTILESIZE, wprev); if (!checksolidtile(vs, x, dy, dw, dh, &color, true)) { break; } for (dx = x + dw; dx < x + wprev;) { dw = MIN(VNCTIGHTMAXSPLITTILESIZE, x + wprev - dx); if (!checksolidtile(vs, dx, dy, dw, dh, &color, true)) { break; } dx += dw; } wprev = dx - x; if (wprev * (dy + dh - y) > wbest * hbest) { wbest = wprev; hbest = dy + dh - y; } } *wptr = wbest; *hptr = hbest; } ", "target": 0}
{"func": "static RAMBlock *qemugetramblock(ramaddrt addr) { RAMBlock *block; /* The list is protected by the iothread lock here. */ block = ramlist.mrublock; if (block && addr - block->offset < block->maxlength) { goto found; } QTAILQFOREACH(block, &ramlist.blocks, next) { if (addr - block->offset < block->maxlength) { goto found; } } fprintf(stderr, \"Bad ram offset %\" PRIx64 \"\\n\", (uint64t)addr); abort(); found: ramlist.mrublock = block; return block; } ", "target": 0}
{"func": "static int usbnetcanreceive(VLANClientState *nc) { USBNetState *s = DOUPCAST(NICState, nc, nc)->opaque; if (s->rndis && !s->rndisstate == RNDISDATAINITIALIZED) return 1; return !s->inlen; } ", "target": 0}
{"func": "static int scsidiskemulatemodesense(SCSIRequest *req, uint8t *outbuf) { SCSIDiskState *s = DOUPCAST(SCSIDiskState, qdev, req->dev); uint64t nbsectors; int page, dbd, buflen, pagecontrol; uint8t *p; uint8t devspecificparam; dbd = req->cmd.buf[1] & 0x8; page = req->cmd.buf[2] & 0x3f; pagecontrol = (req->cmd.buf[2] & 0xc0) >> 6; DPRINTF(\"Mode Sense(%d) (page %d, len %d, pagecontrol %d)\\n\", (req->cmd.buf[0] == MODESENSE) ? 6 : 10, page, len, pagecontrol); memset(outbuf, 0, req->cmd.xfer); p = outbuf; if (bdrvisreadonly(s->bs)) { devspecificparam = 0x80; /* Readonly. */ } else { devspecificparam = 0x00; } if (req->cmd.buf[0] == MODESENSE) { p[1] = 0; /* Default media type. */ p[2] = devspecificparam; p[3] = 0; /* Block descriptor length. */ p += 4; } else { /* MODESENSE10 */ p[2] = 0; /* Default media type. */ p[3] = devspecificparam; p[6] = p[7] = 0; /* Block descriptor length. */ p += 8; } bdrvgetgeometry(s->bs, &nbsectors); if ((~dbd) & nbsectors) { if (req->cmd.buf[0] == MODESENSE) { outbuf[3] = 8; /* Block descriptor length */ } else { /* MODESENSE10 */ outbuf[7] = 8; /* Block descriptor length */ } nbsectors /= s->clustersize; if (nbsectors > 0xffffff) nbsectors = 0; p[0] = 0; /* media density code */ p[1] = (nbsectors >> 16) & 0xff; p[2] = (nbsectors >> 8) & 0xff; p[3] = nbsectors & 0xff; p[4] = 0; /* reserved */ p[5] = 0; /* bytes 5-7 are the sector size in bytes */ p[6] = s->clustersize * 2; p[7] = 0; p += 8; } if (pagecontrol == 3) { /* Saved Values */ return -1; /* ILLEGALREQUEST */ } switch (page) { case 0x04: case 0x05: case 0x08: case 0x2a: p += modesensepage(req, page, p, pagecontrol); break; case 0x3f: p += modesensepage(req, 0x08, p, pagecontrol); p += modesensepage(req, 0x2a, p, pagecontrol); break; default: return -1; /* ILLEGALREQUEST */ } buflen = p - outbuf; /* * The mode data length field specifies the length in bytes of the * following data that is available to be transferred. The mode data * length does not include itself. */ if (req->cmd.buf[0] == MODESENSE) { outbuf[0] = buflen - 1; } else { /* MODESENSE10 */ outbuf[0] = ((buflen - 2) >> 8) & 0xff; outbuf[1] = (buflen - 2) & 0xff; } if (buflen > req->cmd.xfer) buflen = req->cmd.xfer; return buflen; } ", "target": 0}
{"func": "void tcgaddtargetaddopdefs(const TCGTargetOpDef *tdefs) { TCGOpcode op; TCGOpDef *def; const char *ctstr; int i, nbargs; for(;;) { if (tdefs->op == (TCGOpcode)-1) break; op = tdefs->op; assert((unsigned)op < NBOPS); def = &tcgopdefs[op]; #if defined(CONFIGDEBUGTCG) /* Duplicate entry in op definitions? */ assert(!def->used); def->used = 1; #endif nbargs = def->nbiargs + def->nboargs; for(i = 0; i < nbargs; i++) { ctstr = tdefs->argsctstr[i]; /* Incomplete TCGTargetOpDef entry? */ assert(ctstr != NULL); tcgregsetclear(def->argsct[i].u.regs); def->argsct[i].ct = 0; if (ctstr[0] >= '0' && ctstr[0] <= '9') { int oarg; oarg = ctstr[0] - '0'; assert(oarg < def->nboargs); assert(def->argsct[oarg].ct & TCGCTREG); /* TCGCTALIAS is for the output arguments. The input argument is tagged with TCGCTIALIAS. */ def->argsct[i] = def->argsct[oarg]; def->argsct[oarg].ct = TCGCTALIAS; def->argsct[oarg].aliasindex = i; def->argsct[i].ct |= TCGCTIALIAS; def->argsct[i].aliasindex = oarg; } else { for(;;) { if (*ctstr == '\\0') break; switch(*ctstr) { case 'i': def->argsct[i].ct |= TCGCTCONST; ctstr++; break; default: if (targetparseconstraint(&def->argsct[i], &ctstr) < 0) { fprintf(stderr, \"Invalid constraint '%s' for arg %d of operation '%s'\\n\", ctstr, i, def->name); exit(1); } } } } } /* TCGTargetOpDef entry with too much information? */ assert(i == TCGMAXOPARGS || tdefs->argsctstr[i] == NULL); /* sort the constraints (XXX: this is just an heuristic) */ sortconstraints(def, 0, def->nboargs); sortconstraints(def, def->nboargs, def->nbiargs); #if 0 { int i; printf(\"%s: sorted=\", def->name); for(i = 0; i < def->nboargs + def->nbiargs; i++) printf(\" %d\", def->sortedargs[i]); printf(\"\\n\"); } #endif tdefs++; } #if defined(CONFIGDEBUGTCG) i = 0; for (op = 0; op < tcgopdefsmax; op++) { const TCGOpDef *def = &tcgopdefs[op]; if (def->flags & TCGOPFNOTPRESENT) { /* Wrong entry in op definitions? */ if (def->used) { fprintf(stderr, \"Invalid op definition for %s\\n\", def->name); i = 1; } } else { /* Missing entry in op definitions? */ if (!def->used) { fprintf(stderr, \"Missing op definition for %s\\n\", def->name); i = 1; } } } if (i == 1) { tcgabort(); } #endif } ", "target": 0}
{"func": "void AUDvlog (const char *cap, const char *fmt, valist ap) { if (conf.logtomonitor) { if (cap) { monitorprintf(defaultmon, \"%s: \", cap); } monitorvprintf(defaultmon, fmt, ap); } else { if (cap) { fprintf (stderr, \"%s: \", cap); } vfprintf (stderr, fmt, ap); } } ", "target": 1}
{"func": "static int oggbuildflacheaders(const uint8t *extradata, int extradatasize, OGGStreamContext *oggstream, int bitexact) { const char *vendor = bitexact ? \"ffmpeg\" : LIBAVFORMATIDENT; uint8t *p; if (extradatasize != 34) return -1; oggstream->headerlen[0] = 51; oggstream->header[0] = avmallocz(51); // per ogg flac specs p = oggstream->header[0]; bytestreamputbyte(&p, 0x7F); bytestreamputbuffer(&p, \"FLAC\", 4); bytestreamputbyte(&p, 1); // major version bytestreamputbyte(&p, 0); // minor version bytestreamputbe16(&p, 1); // headers packets without this one bytestreamputbuffer(&p, \"fLaC\", 4); bytestreamputbyte(&p, 0x00); // streaminfo bytestreamputbe24(&p, 34); bytestreamputbuffer(&p, extradata, 34); oggstream->headerlen[1] = 1+3+4+strlen(vendor)+4; oggstream->header[1] = avmallocz(oggstream->headerlen[1]); p = oggstream->header[1]; bytestreamputbyte(&p, 0x84); // last metadata block and vorbis comment bytestreamputbe24(&p, oggstream->headerlen[1] - 4); bytestreamputle32(&p, strlen(vendor)); bytestreamputbuffer(&p, vendor, strlen(vendor)); bytestreamputle32(&p, 0); // user comment list length return 0; } ", "target": 0}
{"func": "static void putsubframe(DCAEncContext *c, int subframe) { int i, band, ss, ch; /* Subsubframes count */ putbits(&c->pb, 2, SUBSUBFRAMES -1); /* Partial subsubframe sample count: dummy */ putbits(&c->pb, 3, 0); /* Prediction mode: no ADPCM, in each channel and subband */ for (ch = 0; ch < c->fullbandchannels; ch++) for (band = 0; band < DCAENCSUBBANDS; band++) putbits(&c->pb, 1, 0); /* Prediction VQ address: not transmitted */ /* Bit allocation index */ for (ch = 0; ch < c->fullbandchannels; ch++) for (band = 0; band < DCAENCSUBBANDS; band++) putbits(&c->pb, 5, c->abits[band][ch]); if (SUBSUBFRAMES > 1) { /* Transition mode: none for each channel and subband */ for (ch = 0; ch < c->fullbandchannels; ch++) for (band = 0; band < DCAENCSUBBANDS; band++) putbits(&c->pb, 1, 0); /* codebook A4 */ } /* Scale factors */ for (ch = 0; ch < c->fullbandchannels; ch++) for (band = 0; band < DCAENCSUBBANDS; band++) putbits(&c->pb, 7, c->scalefactor[band][ch]); /* Joint subband scale factor codebook select: not transmitted */ /* Scale factors for joint subband coding: not transmitted */ /* Stereo down-mix coefficients: not transmitted */ /* Dynamic range coefficient: not transmitted */ /* Stde information CRC check word: not transmitted */ /* VQ encoded high frequency subbands: not transmitted */ /* LFE data: 8 samples and scalefactor */ if (c->lfechannel) { for (i = 0; i < DCALFESAMPLES; i++) putbits(&c->pb, 8, quantizevalue(c->downsampledlfe[i], c->lfequant) & 0xff); putbits(&c->pb, 8, c->lfescalefactor); } /* Audio data (subsubframes) */ for (ss = 0; ss < SUBSUBFRAMES ; ss++) for (ch = 0; ch < c->fullbandchannels; ch++) for (band = 0; band < DCAENCSUBBANDS; band++) putsubframesamples(c, ss, band, ch); /* DSYNC */ putbits(&c->pb, 16, 0xffff); } ", "target": 0}
{"func": "static void decodegraybitstream(HYuvContext *s, int count) { int i; count/=2; if (count >= (getbitsleft(&s->gb)) / (31 * 2)) { for (i = 0; i < count && getbitsleft(&s->gb) > 0; i++) { READ2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0); } } else { for(i=0; i<count; i++){ READ2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0); } } } ", "target": 0}
{"func": "static int startauthvencryptsubauth(VncState *vs) { switch (vs->vd->subauth) { case VNCAUTHVENCRYPTTLSNONE: case VNCAUTHVENCRYPTX509NONE: VNCDEBUG(\"Accept TLS auth none\\n\"); vncwriteu32(vs, 0); /* Accept auth completion */ vncreadwhen(vs, protocolclientinit, 1); break; case VNCAUTHVENCRYPTTLSVNC: case VNCAUTHVENCRYPTX509VNC: VNCDEBUG(\"Start TLS auth VNC\\n\"); return startauthvnc(vs); default: /* Should not be possible, but just in case */ VNCDEBUG(\"Reject auth %d\\n\", vs->vd->auth); vncwriteu8(vs, 1); if (vs->minor >= 8) { static const char err[] = \"Unsupported authentication type\"; vncwriteu32(vs, sizeof(err)); vncwrite(vs, err, sizeof(err)); } vncclienterror(vs); } return 0; } ", "target": 0}
{"func": "iscsiunmapcb(struct iscsicontext *iscsi, int status, void *commanddata, void *opaque) { IscsiAIOCB *acb = opaque; if (acb->canceled != 0) { return; } acb->status = 0; if (status < 0) { errorreport(\"Failed to unmap data on iSCSI lun. %s\", iscsigeterror(iscsi)); acb->status = -EIO; } iscsischedulebh(acb); } ", "target": 0}
{"func": "static void virtionotify(struct subchannelid schid) { kvmhypercall(KVMS390VIRTIOCCWNOTIFY, *(u32*)&schid, 0); } ", "target": 0}
{"func": "static void kvmmceinjsraomemscrub2(CPUState *env, targetphysaddrt paddr) { struct kvmx86mce mce = { .bank = 9, .status = MCISTATUSVAL | MCISTATUSUC | MCISTATUSEN | MCISTATUSMISCV | MCISTATUSADDRV | MCISTATUSS | 0xc0, .mcgstatus = MCGSTATUSMCIP | MCGSTATUSRIPV, .addr = paddr, .misc = (MCMADDRPHYS << 6) | 0xc, }; kvminjectx86mceon(env, &mce, ABORTONERROR); kvmmcebroadcastrest(env); } ", "target": 0}
{"func": "static void lm32evrinit(QEMUMachineInitArgs *args) { const char *cpumodel = args->cpumodel; const char *kernelfilename = args->kernelfilename; LM32CPU *cpu; CPULM32State *env; DriveInfo *dinfo; MemoryRegion *addressspacemem = getsystemmemory(); MemoryRegion *physram = gnew(MemoryRegion, 1); qemuirq *cpuirq, irq[32]; ResetInfo *resetinfo; int i; /* memory map */ targetphysaddrt flashbase = 0x04000000; sizet flashsectorsize = 256 * 1024; sizet flashsize = 32 * 1024 * 1024; targetphysaddrt rambase = 0x08000000; sizet ramsize = 64 * 1024 * 1024; targetphysaddrt timer0base = 0x80002000; targetphysaddrt uart0base = 0x80006000; targetphysaddrt timer1base = 0x8000a000; int uart0irq = 0; int timer0irq = 1; int timer1irq = 3; resetinfo = gmalloc0(sizeof(ResetInfo)); if (cpumodel == NULL) { cpumodel = \"lm32-full\"; } cpu = cpulm32init(cpumodel); env = &cpu->env; resetinfo->cpu = cpu; resetinfo->flashbase = flashbase; memoryregioninitram(physram, \"lm32evr.sdram\", ramsize); vmstateregisterramglobal(physram); memoryregionaddsubregion(addressspacemem, rambase, physram); dinfo = driveget(IFPFLASH, 0, 0); /* Spansion S29NS128P */ pflashcfi02register(flashbase, NULL, \"lm32evr.flash\", flashsize, dinfo ? dinfo->bdrv : NULL, flashsectorsize, flashsize / flashsectorsize, 1, 2, 0x01, 0x7e, 0x43, 0x00, 0x555, 0x2aa, 1); /* create irq lines */ cpuirq = qemuallocateirqs(cpuirqhandler, env, 1); env->picstate = lm32picinit(*cpuirq); for (i = 0; i < 32; i++) { irq[i] = qdevgetgpioin(env->picstate, i); } sysbuscreatesimple(\"lm32-uart\", uart0base, irq[uart0irq]); sysbuscreatesimple(\"lm32-timer\", timer0base, irq[timer0irq]); sysbuscreatesimple(\"lm32-timer\", timer1base, irq[timer1irq]); /* make sure juart isn't the first chardev */ env->juartstate = lm32juartinit(); resetinfo->bootstrappc = flashbase; if (kernelfilename) { uint64t entry; int kernelsize; kernelsize = loadelf(kernelfilename, NULL, NULL, &entry, NULL, NULL, 1, ELFMACHINE, 0); resetinfo->bootstrappc = entry; if (kernelsize < 0) { kernelsize = loadimagetargphys(kernelfilename, rambase, ramsize); resetinfo->bootstrappc = rambase; } if (kernelsize < 0) { fprintf(stderr, \"qemu: could not load kernel '%s'\\n\", kernelfilename); exit(1); } } qemuregisterreset(maincpureset, resetinfo); } ", "target": 0}
{"func": "static void genmsabranch(CPUMIPSState *env, DisasContext *ctx, uint32t op1) { uint8t df = (ctx->opcode >> 21) & 0x3; uint8t wt = (ctx->opcode >> 16) & 0x1f; int64t s16 = (int16t)ctx->opcode; checkmsaaccess(ctx); if (ctx->insnflags & ISAMIPS32R6 && ctx->hflags & MIPSHFLAGBMASK) { generateexceptionend(ctx, EXCPRI); return; } switch (op1) { case OPCBZV: case OPCBNZV: { TCGvi64 t0 = tcgtempnewi64(); tcggenori64(t0, msawrd[wt<<1], msawrd[(wt<<1)+1]); tcggensetcondii64((op1 == OPCBZV) ? TCGCONDEQ : TCGCONDNE, t0, t0, 0); tcggentrunci64tl(bcond, t0); tcgtempfreei64(t0); } break; case OPCBZB: case OPCBZH: case OPCBZW: case OPCBZD: gencheckzeroelement(bcond, df, wt); break; case OPCBNZB: case OPCBNZH: case OPCBNZW: case OPCBNZD: gencheckzeroelement(bcond, df, wt); tcggensetconditl(TCGCONDEQ, bcond, bcond, 0); break; } ctx->btarget = ctx->pc + (s16 << 2) + 4; ctx->hflags |= MIPSHFLAGBC; ctx->hflags |= MIPSHFLAGBDS32; } ", "target": 0}
{"func": "static QObject *parsekeyword(JSONParserContext *ctxt, QList **tokens) { QObject *token, *ret; QList *working = qlistcopy(*tokens); token = qlistpop(working); if (token == NULL) { goto out; } if (tokengettype(token) != JSONKEYWORD) { goto out; } if (tokeniskeyword(token, \"true\")) { ret = QOBJECT(qboolfromint(true)); } else if (tokeniskeyword(token, \"false\")) { ret = QOBJECT(qboolfromint(false)); } else { parseerror(ctxt, token, \"invalid keyword `%s'\", tokengetvalue(token)); goto out; } qobjectdecref(token); QDECREF(*tokens); *tokens = working; return ret; out: qobjectdecref(token); QDECREF(working); return NULL; } ", "target": 0}
{"func": "static avcold int vaapiencodeconfigattributes(AVCodecContext *avctx) { VAAPIEncodeContext *ctx = avctx->privdata; VAStatus vas; int i, n, err; VAProfile *profiles = NULL; VAEntrypoint *entrypoints = NULL; VAConfigAttrib attr[] = { { VAConfigAttribRTFormat }, { VAConfigAttribRateControl }, { VAConfigAttribEncMaxRefFrames }, }; n = vaMaxNumProfiles(ctx->hwctx->display); profiles = avmallocarray(n, sizeof(VAProfile)); if (!profiles) { err = AVERROR(ENOMEM); goto fail; } vas = vaQueryConfigProfiles(ctx->hwctx->display, profiles, &n); if (vas != VASTATUSSUCCESS) { avlog(ctx, AVLOGERROR, \"Failed to query profiles: %d (%s).\\n\", vas, vaErrorStr(vas)); err = AVERROR(ENOSYS); goto fail; } for (i = 0; i < n; i++) { if (profiles[i] == ctx->vaprofile) break; } if (i >= n) { avlog(ctx, AVLOGERROR, \"Encoding profile not found (%d).\\n\", ctx->vaprofile); err = AVERROR(ENOSYS); goto fail; } n = vaMaxNumEntrypoints(ctx->hwctx->display); entrypoints = avmallocarray(n, sizeof(VAEntrypoint)); if (!entrypoints) { err = AVERROR(ENOMEM); goto fail; } vas = vaQueryConfigEntrypoints(ctx->hwctx->display, ctx->vaprofile, entrypoints, &n); if (vas != VASTATUSSUCCESS) { avlog(ctx, AVLOGERROR, \"Failed to query entrypoints for \" \"profile %u: %d (%s).\\n\", ctx->vaprofile, vas, vaErrorStr(vas)); err = AVERROR(ENOSYS); goto fail; } for (i = 0; i < n; i++) { if (entrypoints[i] == ctx->vaentrypoint) break; } if (i >= n) { avlog(ctx, AVLOGERROR, \"Encoding entrypoint not found \" \"(%d / %d).\\n\", ctx->vaprofile, ctx->vaentrypoint); err = AVERROR(ENOSYS); goto fail; } vas = vaGetConfigAttributes(ctx->hwctx->display, ctx->vaprofile, ctx->vaentrypoint, attr, FFARRAYELEMS(attr)); if (vas != VASTATUSSUCCESS) { avlog(avctx, AVLOGERROR, \"Failed to fetch config \" \"attributes: %d (%s).\\n\", vas, vaErrorStr(vas)); return AVERROR(EINVAL); } for (i = 0; i < FFARRAYELEMS(attr); i++) { if (attr[i].value == VAATTRIBNOTSUPPORTED) { // Unfortunately we have to treat this as \"don't know\" and hope // for the best, because the Intel MJPEG encoder returns this // for all the interesting attributes. continue; } switch (attr[i].type) { case VAConfigAttribRTFormat: if (!(ctx->vartformat & attr[i].value)) { avlog(avctx, AVLOGERROR, \"Surface RT format %#x \" \"is not supported (mask %#x).\\n\", ctx->vartformat, attr[i].value); err = AVERROR(EINVAL); goto fail; } ctx->configattributes[ctx->nbconfigattributes++] = (VAConfigAttrib) { .type = VAConfigAttribRTFormat, .value = ctx->vartformat, }; break; case VAConfigAttribRateControl: if (!(ctx->varcmode & attr[i].value)) { avlog(avctx, AVLOGERROR, \"Rate control mode %#x \" \"is not supported (mask: %#x).\\n\", ctx->varcmode, attr[i].value); err = AVERROR(EINVAL); goto fail; } ctx->configattributes[ctx->nbconfigattributes++] = (VAConfigAttrib) { .type = VAConfigAttribRateControl, .value = ctx->varcmode, }; break; case VAConfigAttribEncMaxRefFrames: { unsigned int refl0 = attr[i].value & 0xffff; unsigned int refl1 = (attr[i].value >> 16) & 0xffff; if (avctx->gopsize > 1 && refl0 < 1) { avlog(avctx, AVLOGERROR, \"P frames are not \" \"supported (%#x).\\n\", attr[i].value); err = AVERROR(EINVAL); goto fail; } if (avctx->maxbframes > 0 && refl1 < 1) { avlog(avctx, AVLOGERROR, \"B frames are not \" \"supported (%#x).\\n\", attr[i].value); err = AVERROR(EINVAL); goto fail; } } break; default: avassert0(0 && \"Unexpected config attribute.\"); } } err = 0; fail: avfreep(&profiles); avfreep(&entrypoints); return err; } ", "target": 0}
{"func": "static int targaencodeframe(AVCodecContext *avctx, AVPacket *pkt, const AVFrame *p, int *gotpacket) { int bpp, picsize, datasize = -1, ret; uint8t *out; if(avctx->width > 0xffff || avctx->height > 0xffff) { avlog(avctx, AVLOGERROR, \"image dimensions too large\\n\"); return AVERROR(EINVAL); } picsize = avimagegetbuffersize(avctx->pixfmt, avctx->width, avctx->height, 1); if ((ret = ffallocpacket(pkt, picsize + 45)) < 0) { avlog(avctx, AVLOGERROR, \"encoded frame too large\\n\"); return ret; } /* zero out the header and only set applicable fields */ memset(pkt->data, 0, 12); AVWL16(pkt->data+12, avctx->width); AVWL16(pkt->data+14, avctx->height); /* image descriptor byte: origin is always top-left, bits 0-3 specify alpha */ pkt->data[17] = 0x20 | (avctx->pixfmt == AVPIXFMTBGRA ? 8 : 0); switch(avctx->pixfmt) { case AVPIXFMTGRAY8: pkt->data[2] = TGABW; /* uncompressed grayscale image */ pkt->data[16] = 8; /* bpp */ break; case AVPIXFMTRGB555LE: pkt->data[2] = TGARGB; /* uncompresses true-color image */ pkt->data[16] = 16; /* bpp */ break; case AVPIXFMTBGR24: pkt->data[2] = TGARGB; /* uncompressed true-color image */ pkt->data[16] = 24; /* bpp */ break; case AVPIXFMTBGRA: pkt->data[2] = TGARGB; /* uncompressed true-color image */ pkt->data[16] = 32; /* bpp */ break; default: avlog(avctx, AVLOGERROR, \"Pixel format '%s' not supported.\\n\", avgetpixfmtname(avctx->pixfmt)); return AVERROR(EINVAL); } bpp = pkt->data[16] >> 3; out = pkt->data + 18; /* skip past the header we just output */ /* try RLE compression */ if (avctx->codertype != FFCODERTYPERAW) datasize = targaencoderle(out, picsize, p, bpp, avctx->width, avctx->height); /* if that worked well, mark the picture as RLE compressed */ if(datasize >= 0) pkt->data[2] |= 8; /* if RLE didn't make it smaller, go back to no compression */ else datasize = targaencodenormal(out, p, bpp, avctx->width, avctx->height); out += datasize; /* The standard recommends including this section, even if we don't use * any of the features it affords. TODO: take advantage of the pixel * aspect ratio and encoder ID fields available? */ memcpy(out, \"\\0\\0\\0\\0\\0\\0\\0\\0TRUEVISION-XFILE.\", 26); pkt->size = out + 26 - pkt->data; pkt->flags |= AVPKTFLAGKEY; *gotpacket = 1; return 0; } ", "target": 0}
{"func": "static int scsireqlength(SCSICommand *cmd, SCSIDevice *dev, uint8t *buf) { cmd->xfer = scsicdblength(buf); switch (buf[0]) { case TESTUNITREADY: case REWIND: case STARTSTOP: case SETCAPACITY: case WRITEFILEMARKS: case WRITEFILEMARKS16: case SPACE: case RESERVE: case RELEASE: case ERASE: case ALLOWMEDIUMREMOVAL: case SEEK10: case SYNCHRONIZECACHE: case SYNCHRONIZECACHE16: case LOCATE16: case LOCKUNLOCKCACHE: case SETCDSPEED: case SETLIMITS: case WRITELONG10: case UPDATEBLOCK: case RESERVETRACK: case SETREADAHEAD: case PREFETCH: case PREFETCH16: case ALLOWOVERWRITE: cmd->xfer = 0; break; case VERIFY10: case VERIFY12: case VERIFY16: if ((buf[1] & 2) == 0) { cmd->xfer = 0; } else if ((buf[1] & 4) == 1) { cmd->xfer = 1; } cmd->xfer *= dev->blocksize; break; case MODESENSE: break; case WRITESAME10: case WRITESAME16: cmd->xfer = dev->blocksize; break; case READCAPACITY10: cmd->xfer = 8; break; case READBLOCKLIMITS: cmd->xfer = 6; break; case SENDVOLUMETAG: /* GPCMDSETSTREAMING from multimedia commands. */ if (dev->type == TYPEROM) { cmd->xfer = buf[10] | (buf[9] << 8); } else { cmd->xfer = buf[9] | (buf[8] << 8); } break; case WRITE6: /* length 0 means 256 blocks */ if (cmd->xfer == 0) { cmd->xfer = 256; } case WRITE10: case WRITEVERIFY10: case WRITE12: case WRITEVERIFY12: case WRITE16: case WRITEVERIFY16: cmd->xfer *= dev->blocksize; break; case READ6: case READREVERSE: /* length 0 means 256 blocks */ if (cmd->xfer == 0) { cmd->xfer = 256; } case READ10: case RECOVERBUFFEREDDATA: case READ12: case READ16: cmd->xfer *= dev->blocksize; break; case FORMATUNIT: /* MMC mandates the parameter list to be 12-bytes long. Parameters * for block devices are restricted to the header right now. */ if (dev->type == TYPEROM && (buf[1] & 16)) { cmd->xfer = 12; } else { cmd->xfer = (buf[1] & 16) == 0 ? 0 : (buf[1] & 32 ? 8 : 4); } break; case INQUIRY: case RECEIVEDIAGNOSTIC: case SENDDIAGNOSTIC: cmd->xfer = buf[4] | (buf[3] << 8); break; case READCD: case READBUFFER: case WRITEBUFFER: case SENDCUESHEET: cmd->xfer = buf[8] | (buf[7] << 8) | (buf[6] << 16); break; case PERSISTENTRESERVEOUT: cmd->xfer = ldlbep(&buf[5]) & 0xffffffffULL; break; case ERASE12: if (dev->type == TYPEROM) { /* MMC command GET PERFORMANCE. */ cmd->xfer = scsigetperformancelength(buf[9] | (buf[8] << 8), buf[10], buf[1] & 0x1f); } break; case MECHANISMSTATUS: case READDVDSTRUCTURE: case SENDDVDSTRUCTURE: case MAINTENANCEOUT: case MAINTENANCEIN: if (dev->type == TYPEROM) { /* GPCMDREPORTKEY and GPCMDSENDKEY from multi media commands */ cmd->xfer = buf[9] | (buf[8] << 8); } break; case ATAPASSTHROUGH12: if (dev->type == TYPEROM) { /* BLANK command of MMC */ cmd->xfer = 0; } else { cmd->xfer = atapassthrough12xfersize(dev, buf); } break; case ATAPASSTHROUGH16: cmd->xfer = atapassthrough16xfersize(dev, buf); break; } return 0; } ", "target": 1}
{"func": "static void qdm2init(QDM2Context *q) { static int inited = 0; if (inited != 0) return; inited = 1; qdm2initvlc(); ffmpasynthinit(mpawindow); softcliptableinit(); rndtableinit(); initnoisesamples(); avlog(NULL, AVLOGDEBUG, \"init done\\n\"); } ", "target": 0}
{"func": "static int encodeframe(FlacEncodeContext *s) { int ch, count; count = countframeheader(s); for (ch = 0; ch < s->channels; ch++) count += encoderesidualch(s, ch); count += (8 - (count & 7)) & 7; // byte alignment count += 16; // CRC-16 return count >> 3; } ", "target": 1}
{"func": "static int vfioaddstdcap(VFIOPCIDevice *vdev, uint8t pos) { PCIDevice *pdev = &vdev->pdev; uint8t capid, next, size; int ret; capid = pdev->config[pos]; next = pdev->config[pos + PCICAPLISTNEXT]; /* * If it becomes important to configure capabilities to their actual * size, use this as the default when it's something we don't recognize. * Since QEMU doesn't actually handle many of the config accesses, * exact size doesn't seem worthwhile. */ size = vfiostdcapmaxsize(pdev, pos); /* * pciaddcapability always inserts the new capability at the head * of the chain. Therefore to end up with a chain that matches the * physical device, we insert from the end by making this recursive. * This is also why we pre-calculate size above as cached config space * will be changed as we unwind the stack. */ if (next) { ret = vfioaddstdcap(vdev, next); if (ret) { return ret; } } else { /* Begin the rebuild, use QEMU emulated list bits */ pdev->config[PCICAPABILITYLIST] = 0; vdev->emulatedconfigbits[PCICAPABILITYLIST] = 0xff; vdev->emulatedconfigbits[PCISTATUS] |= PCISTATUSCAPLIST; } /* Use emulated next pointer to allow dropping caps */ pcisetbyte(vdev->emulatedconfigbits + pos + PCICAPLISTNEXT, 0xff); switch (capid) { case PCICAPIDMSI: ret = vfiomsisetup(vdev, pos); break; case PCICAPIDEXP: vfiocheckpcieflr(vdev, pos); ret = vfiosetuppciecap(vdev, pos, size); break; case PCICAPIDMSIX: ret = vfiomsixsetup(vdev, pos); break; case PCICAPIDPM: vfiocheckpmreset(vdev, pos); vdev->pmcap = pos; ret = pciaddcapability(pdev, capid, pos, size); break; case PCICAPIDAF: vfiocheckafflr(vdev, pos); ret = pciaddcapability(pdev, capid, pos, size); break; default: ret = pciaddcapability(pdev, capid, pos, size); break; } if (ret < 0) { errorreport(\"vfio: %04x:%02x:%02x.%x Error adding PCI capability \" \"0x%x[0x%x]@0x%x: %d\", vdev->host.domain, vdev->host.bus, vdev->host.slot, vdev->host.function, capid, size, pos, ret); return ret; } return 0; } ", "target": 0}
{"func": "int cpuexec(CPUState *env1) { #define DECLAREHOSTREGS 1 #include \"hostregshelper.h\" int ret, interruptrequest; TranslationBlock *tb; uint8t *tcptr; unsigned long nexttb; if (cpuhalted(env1) == EXCPHALTED) return EXCPHALTED; cpusingleenv = env1; /* first we save global registers */ #define SAVEHOSTREGS 1 #include \"hostregshelper.h\" env = env1; #if defined(TARGETI386) /* put eflags in CPU temporary format */ CCSRC = env->eflags & (CCO | CCS | CCZ | CCA | CCP | CCC); DF = 1 - (2 * ((env->eflags >> 10) & 1)); CCOP = CCOPEFLAGS; env->eflags &= ~(DFMASK | CCO | CCS | CCZ | CCA | CCP | CCC); #elif defined(TARGETSPARC) #elif defined(TARGETM68K) env->ccop = CCOPFLAGS; env->ccdest = env->sr & 0xf; env->ccx = (env->sr >> 4) & 1; #elif defined(TARGETALPHA) #elif defined(TARGETARM) #elif defined(TARGETPPC) #elif defined(TARGETMICROBLAZE) #elif defined(TARGETMIPS) #elif defined(TARGETSH4) #elif defined(TARGETCRIS) #elif defined(TARGETS390X) /* XXXXX */ #else #error unsupported target CPU #endif env->exceptionindex = -1; /* prepare setjmp context for exception handling */ for(;;) { if (setjmp(env->jmpenv) == 0) { #if defined(sparc) && !defined(CONFIGSOLARIS) #undef env env = cpusingleenv; #define env cpusingleenv #endif /* if an exception is pending, we execute it here */ if (env->exceptionindex >= 0) { if (env->exceptionindex >= EXCPINTERRUPT) { /* exit request from the cpu execution loop */ ret = env->exceptionindex; if (ret == EXCPDEBUG) cpuhandledebugexception(env); break; } else { #if defined(CONFIGUSERONLY) /* if user mode only, we simulate a fake exception which will be handled outside the cpu execution loop */ #if defined(TARGETI386) dointerruptuser(env->exceptionindex, env->exceptionisint, env->errorcode, env->exceptionnexteip); /* successfully delivered */ env->oldexception = -1; #endif ret = env->exceptionindex; break; #else #if defined(TARGETI386) /* simulate a real cpu exception. On i386, it can trigger new exceptions, but we do not handle double or triple faults yet. */ dointerrupt(env->exceptionindex, env->exceptionisint, env->errorcode, env->exceptionnexteip, 0); /* successfully delivered */ env->oldexception = -1; #elif defined(TARGETPPC) dointerrupt(env); #elif defined(TARGETMICROBLAZE) dointerrupt(env); #elif defined(TARGETMIPS) dointerrupt(env); #elif defined(TARGETSPARC) dointerrupt(env); #elif defined(TARGETARM) dointerrupt(env); #elif defined(TARGETSH4) \t\t dointerrupt(env); #elif defined(TARGETALPHA) dointerrupt(env); #elif defined(TARGETCRIS) dointerrupt(env); #elif defined(TARGETM68K) dointerrupt(0); #endif env->exceptionindex = -1; #endif } } if (kvmenabled()) { kvmcpuexec(env); longjmp(env->jmpenv, 1); } nexttb = 0; /* force lookup of first TB */ for(;;) { interruptrequest = env->interruptrequest; if (unlikely(interruptrequest)) { if (unlikely(env->singlestepenabled & SSTEPNOIRQ)) { /* Mask out external interrupts for this step. */ interruptrequest &= ~(CPUINTERRUPTHARD | CPUINTERRUPTFIQ | CPUINTERRUPTSMI | CPUINTERRUPTNMI); } if (interruptrequest & CPUINTERRUPTDEBUG) { env->interruptrequest &= ~CPUINTERRUPTDEBUG; env->exceptionindex = EXCPDEBUG; cpuloopexit(); } #if defined(TARGETARM) || defined(TARGETSPARC) || defined(TARGETMIPS) || \\ defined(TARGETPPC) || defined(TARGETALPHA) || defined(TARGETCRIS) || \\ defined(TARGETMICROBLAZE) if (interruptrequest & CPUINTERRUPTHALT) { env->interruptrequest &= ~CPUINTERRUPTHALT; env->halted = 1; env->exceptionindex = EXCPHLT; cpuloopexit(); } #endif #if defined(TARGETI386) if (interruptrequest & CPUINTERRUPTINIT) { svmcheckintercept(SVMEXITINIT); docpuinit(env); env->exceptionindex = EXCPHALTED; cpuloopexit(); } else if (interruptrequest & CPUINTERRUPTSIPI) { docpusipi(env); } else if (env->hflags2 & HF2GIFMASK) { if ((interruptrequest & CPUINTERRUPTSMI) && !(env->hflags & HFSMMMASK)) { svmcheckintercept(SVMEXITSMI); env->interruptrequest &= ~CPUINTERRUPTSMI; dosmmenter(); nexttb = 0; } else if ((interruptrequest & CPUINTERRUPTNMI) && !(env->hflags2 & HF2NMIMASK)) { env->interruptrequest &= ~CPUINTERRUPTNMI; env->hflags2 |= HF2NMIMASK; dointerrupt(EXCP02NMI, 0, 0, 0, 1); nexttb = 0; \t\t\t} else if (interruptrequest & CPUINTERRUPTMCE) { env->interruptrequest &= ~CPUINTERRUPTMCE; dointerrupt(EXCP12MCHK, 0, 0, 0, 0); nexttb = 0; } else if ((interruptrequest & CPUINTERRUPTHARD) && (((env->hflags2 & HF2VINTRMASK) && (env->hflags2 & HF2HIFMASK)) || (!(env->hflags2 & HF2VINTRMASK) && (env->eflags & IFMASK && !(env->hflags & HFINHIBITIRQMASK))))) { int intno; svmcheckintercept(SVMEXITINTR); env->interruptrequest &= ~(CPUINTERRUPTHARD | CPUINTERRUPTVIRQ); intno = cpugetpicinterrupt(env); qemulogmask(CPULOGTBINASM, \"Servicing hardware INT=0x%02x\\n\", intno); #if defined(sparc) && !defined(CONFIGSOLARIS) #undef env env = cpusingleenv; #define env cpusingleenv #endif dointerrupt(intno, 0, 0, 0, 1); /* ensure that no TB jump will be modified as the program flow was changed */ nexttb = 0; #if !defined(CONFIGUSERONLY) } else if ((interruptrequest & CPUINTERRUPTVIRQ) && (env->eflags & IFMASK) && !(env->hflags & HFINHIBITIRQMASK)) { int intno; /* FIXME: this should respect TPR */ svmcheckintercept(SVMEXITVINTR); intno = ldlphys(env->vmvmcb + offsetof(struct vmcb, control.intvector)); qemulogmask(CPULOGTBINASM, \"Servicing virtual hardware INT=0x%02x\\n\", intno); dointerrupt(intno, 0, 0, 0, 1); env->interruptrequest &= ~CPUINTERRUPTVIRQ; nexttb = 0; #endif } } #elif defined(TARGETPPC) #if 0 if ((interruptrequest & CPUINTERRUPTRESET)) { cpureset(env); } #endif if (interruptrequest & CPUINTERRUPTHARD) { ppchwinterrupt(env); if (env->pendinginterrupts == 0) env->interruptrequest &= ~CPUINTERRUPTHARD; nexttb = 0; } #elif defined(TARGETMICROBLAZE) if ((interruptrequest & CPUINTERRUPTHARD) && (env->sregs[SRMSR] & MSRIE) && !(env->sregs[SRMSR] & (MSREIP | MSRBIP)) && !(env->iflags & (DFLAG | IMMFLAG))) { env->exceptionindex = EXCPIRQ; dointerrupt(env); nexttb = 0; } #elif defined(TARGETMIPS) if ((interruptrequest & CPUINTERRUPTHARD) && (env->CP0Status & env->CP0Cause & CP0CaIPmask) && (env->CP0Status & (1 << CP0StIE)) && !(env->CP0Status & (1 << CP0StEXL)) && !(env->CP0Status & (1 << CP0StERL)) && !(env->hflags & MIPSHFLAGDM)) { /* Raise it */ env->exceptionindex = EXCPEXTINTERRUPT; env->errorcode = 0; dointerrupt(env); nexttb = 0; } #elif defined(TARGETSPARC) if (interruptrequest & CPUINTERRUPTHARD) { if (cpuinterruptsenabled(env) && env->interruptindex > 0) { int pil = env->interruptindex & 0xf; int type = env->interruptindex & 0xf0; if (((type == TTEXTINT) && cpupilallowed(env, pil)) || type != TTEXTINT) { env->exceptionindex = env->interruptindex; dointerrupt(env); nexttb = 0; } } \t\t } else if (interruptrequest & CPUINTERRUPTTIMER) { \t\t\t//dointerrupt(0, 0, 0, 0, 0); \t\t\tenv->interruptrequest &= ~CPUINTERRUPTTIMER; \t\t } #elif defined(TARGETARM) if (interruptrequest & CPUINTERRUPTFIQ && !(env->uncachedcpsr & CPSRF)) { env->exceptionindex = EXCPFIQ; dointerrupt(env); nexttb = 0; } /* ARMv7-M interrupt return works by loading a magic value into the PC. On real hardware the load causes the return to occur. The qemu implementation performs the jump normally, then does the exception return when the CPU tries to execute code at the magic address. This will cause the magic PC value to be pushed to the stack if an interrupt occured at the wrong time. We avoid this by disabling interrupts when pc contains a magic address. */ if (interruptrequest & CPUINTERRUPTHARD && ((ISM(env) && env->regs[15] < 0xfffffff0) || !(env->uncachedcpsr & CPSRI))) { env->exceptionindex = EXCPIRQ; dointerrupt(env); nexttb = 0; } #elif defined(TARGETSH4) if (interruptrequest & CPUINTERRUPTHARD) { dointerrupt(env); nexttb = 0; } #elif defined(TARGETALPHA) if (interruptrequest & CPUINTERRUPTHARD) { dointerrupt(env); nexttb = 0; } #elif defined(TARGETCRIS) if (interruptrequest & CPUINTERRUPTHARD && (env->pregs[PRCCS] & IFLAG)) { env->exceptionindex = EXCPIRQ; dointerrupt(env); nexttb = 0; } if (interruptrequest & CPUINTERRUPTNMI && (env->pregs[PRCCS] & MFLAG)) { env->exceptionindex = EXCPNMI; dointerrupt(env); nexttb = 0; } #elif defined(TARGETM68K) if (interruptrequest & CPUINTERRUPTHARD && ((env->sr & SRI) >> SRISHIFT) < env->pendinglevel) { /* Real hardware gets the interrupt vector via an IACK cycle at this point. Current emulated hardware doesn't rely on this, so we provide/save the vector when the interrupt is first signalled. */ env->exceptionindex = env->pendingvector; dointerrupt(1); nexttb = 0; } #endif /* Don't use the cached interuptrequest value, dointerrupt may have updated the EXITTB flag. */ if (env->interruptrequest & CPUINTERRUPTEXITTB) { env->interruptrequest &= ~CPUINTERRUPTEXITTB; /* ensure that no TB jump will be modified as the program flow was changed */ nexttb = 0; } } if (unlikely(env->exitrequest)) { env->exitrequest = 0; env->exceptionindex = EXCPINTERRUPT; cpuloopexit(); } #ifdef CONFIGDEBUGEXEC if (qemuloglevelmask(CPULOGTBCPU)) { /* restore flags in standard format */ #if defined(TARGETI386) env->eflags = env->eflags | helpercccomputeall(CCOP) | (DF & DFMASK); logcpustate(env, X86DUMPCCOP); env->eflags &= ~(DFMASK | CCO | CCS | CCZ | CCA | CCP | CCC); #elif defined(TARGETARM) logcpustate(env, 0); #elif defined(TARGETSPARC) logcpustate(env, 0); #elif defined(TARGETPPC) logcpustate(env, 0); #elif defined(TARGETM68K) cpum68kflushflags(env, env->ccop); env->ccop = CCOPFLAGS; env->sr = (env->sr & 0xffe0) | env->ccdest | (env->ccx << 4); logcpustate(env, 0); #elif defined(TARGETMICROBLAZE) logcpustate(env, 0); #elif defined(TARGETMIPS) logcpustate(env, 0); #elif defined(TARGETSH4) \t\t logcpustate(env, 0); #elif defined(TARGETALPHA) logcpustate(env, 0); #elif defined(TARGETCRIS) logcpustate(env, 0); #else #error unsupported target CPU #endif } #endif spinlock(&tblock); tb = tbfindfast(); /* Note: we do it here to avoid a gcc bug on Mac OS X when doing it in tbfindslow */ if (tbinvalidatedflag) { /* as some TB could have been invalidated because of memory exceptions while generating the code, we must recompute the hash index here */ nexttb = 0; tbinvalidatedflag = 0; } #ifdef CONFIGDEBUGEXEC qemulogmask(CPULOGEXEC, \"Trace 0x%08lx [\" TARGETFMTlx \"] %s\\n\", (long)tb->tcptr, tb->pc, lookupsymbol(tb->pc)); #endif /* see if we can patch the calling TB. When the TB spans two pages, we cannot safely do a direct jump. */ if (nexttb != 0 && tb->pageaddr[1] == -1) { tbaddjump((TranslationBlock *)(nexttb & ~3), nexttb & 3, tb); } spinunlock(&tblock); /* cpuinterrupt might be called while translating the TB, but before it is linked into a potentially infinite loop and becomes env->currenttb. Avoid starting execution if there is a pending interrupt. */ if (!unlikely (env->exitrequest)) { env->currenttb = tb; tcptr = tb->tcptr; /* execute the generated code */ #if defined(sparc) && !defined(CONFIGSOLARIS) #undef env env = cpusingleenv; #define env cpusingleenv #endif nexttb = tcgqemutbexec(tcptr); env->currenttb = NULL; if ((nexttb & 3) == 2) { /* Instruction counter expired. */ int insnsleft; tb = (TranslationBlock *)(long)(nexttb & ~3); /* Restore PC. */ cpupcfromtb(env, tb); insnsleft = env->icountdecr.u32; if (env->icountextra && insnsleft >= 0) { /* Refill decrementer and continue execution. */ env->icountextra += insnsleft; if (env->icountextra > 0xffff) { insnsleft = 0xffff; } else { insnsleft = env->icountextra; } env->icountextra -= insnsleft; env->icountdecr.u16.low = insnsleft; } else { if (insnsleft > 0) { /* Execute remaining instructions. */ cpuexecnocache(insnsleft, tb); } env->exceptionindex = EXCPINTERRUPT; nexttb = 0; cpuloopexit(); } } } /* reset soft MMU for next block (it can currently only be set by a memory fault) */ } /* for(;;) */ } } /* for(;;) */ #if defined(TARGETI386) /* restore flags in standard format */ env->eflags = env->eflags | helpercccomputeall(CCOP) | (DF & DFMASK); #elif defined(TARGETARM) /* XXX: Save/restore host fpu exception state?. */ #elif defined(TARGETSPARC) #elif defined(TARGETPPC) #elif defined(TARGETM68K) cpum68kflushflags(env, env->ccop); env->ccop = CCOPFLAGS; env->sr = (env->sr & 0xffe0) | env->ccdest | (env->ccx << 4); #elif defined(TARGETMICROBLAZE) #elif defined(TARGETMIPS) #elif defined(TARGETSH4) #elif defined(TARGETALPHA) #elif defined(TARGETCRIS) #elif defined(TARGETS390X) /* XXXXX */ #else #error unsupported target CPU #endif /* restore global registers */ #include \"hostregshelper.h\" /* fail safe : never use cpusingleenv outside cpuexec() */ cpusingleenv = NULL; return ret; } ", "target": 0}
{"func": "void HELPER(v7mmsr)(CPUARMState *env, uint32t maskreg, uint32t val) { /* We're passed bits [11..0] of the instruction; extract * SYSm and the mask bits. * Invalid combinations of SYSm and mask are UNPREDICTABLE; * we choose to treat them as if the mask bits were valid. * NB that the pseudocode 'mask' variable is bits [11..10], * whereas ours is [11..8]. */ uint32t mask = extract32(maskreg, 8, 4); uint32t reg = extract32(maskreg, 0, 8); if (armcurrentel(env) == 0 && reg > 7) { /* only xPSR sub-fields may be written by unprivileged */ return; } switch (reg) { case 0 ... 7: /* xPSR sub-fields */ /* only APSR is actually writable */ if (!(reg & 4)) { uint32t apsrmask = 0; if (mask & 8) { apsrmask |= XPSRNZCV | XPSRQ; } if ((mask & 4) && armfeature(env, ARMFEATURETHUMBDSP)) { apsrmask |= XPSRGE; } xpsrwrite(env, val, apsrmask); } break; case 8: /* MSP */ if (env->v7m.control & RV7MCONTROLSPSELMASK) { env->v7m.othersp = val; } else { env->regs[13] = val; } break; case 9: /* PSP */ if (env->v7m.control & RV7MCONTROLSPSELMASK) { env->regs[13] = val; } else { env->v7m.othersp = val; } break; case 16: /* PRIMASK */ env->v7m.primask[env->v7m.secure] = val & 1; break; case 17: /* BASEPRI */ env->v7m.basepri[env->v7m.secure] = val & 0xff; break; case 18: /* BASEPRIMAX */ val &= 0xff; if (val != 0 && (val < env->v7m.basepri[env->v7m.secure] || env->v7m.basepri[env->v7m.secure] == 0)) { env->v7m.basepri[env->v7m.secure] = val; } break; case 19: /* FAULTMASK */ env->v7m.faultmask = val & 1; break; case 20: /* CONTROL */ /* Writing to the SPSEL bit only has an effect if we are in * thread mode; other bits can be updated by any privileged code. * switchv7msp() deals with updating the SPSEL bit in * env->v7m.control, so we only need update the others. */ if (!armv7mishandlermode(env)) { switchv7msp(env, (val & RV7MCONTROLSPSELMASK) != 0); } env->v7m.control &= ~RV7MCONTROLNPRIVMASK; env->v7m.control |= val & RV7MCONTROLNPRIVMASK; break; default: qemulogmask(LOGGUESTERROR, \"Attempt to write unknown special\" \" register %d\\n\", reg); return; } } ", "target": 0}
{"func": "static bool migratecapscheck(bool *caplist, MigrationCapabilityStatusList *params, Error **errp) { MigrationCapabilityStatusList *cap; bool oldpostcopycap; oldpostcopycap = caplist[MIGRATIONCAPABILITYPOSTCOPYRAM]; for (cap = params; cap; cap = cap->next) { caplist[cap->value->capability] = cap->value->state; } #ifndef CONFIGLIVEBLOCKMIGRATION if (caplist[MIGRATIONCAPABILITYBLOCK]) { errorsetg(errp, \"QEMU compiled without old-style (blk/-b, inc/-i) \" \"block migration\"); errorappendhint(errp, \"Use drivemirror+NBD instead.\\n\"); return false; } #endif if (caplist[MIGRATIONCAPABILITYPOSTCOPYRAM]) { if (caplist[MIGRATIONCAPABILITYCOMPRESS]) { /* The decompression threads asynchronously write into RAM * rather than use the atomic copies needed to avoid * userfaulting. It should be possible to fix the decompression * threads for compatibility in future. */ errorsetg(errp, \"Postcopy is not currently compatible \" \"with compression\"); return false; } /* This check is reasonably expensive, so only when it's being * set the first time, also it's only the destination that needs * special support. */ if (!oldpostcopycap && runstatecheck(RUNSTATEINMIGRATE) && !postcopyramsupportedbyhost()) { /* postcopyramsupportedbyhost will have emitted a more * detailed message */ errorsetg(errp, \"Postcopy is not supported\"); return false; } } return true; } ", "target": 0}
{"func": "static int virtioblkhandlerwerror(VirtIOBlockReq *req, int error, bool isread) { BlockErrorAction action = bdrvgeterroraction(req->dev->bs, isread, error); VirtIOBlock *s = req->dev; if (action == BLOCKERRORACTIONSTOP) { req->next = s->rq; s->rq = req; } else if (action == BLOCKERRORACTIONREPORT) { virtioblkreqcomplete(req, VIRTIOBLKSIOERR); blockacctdone(bdrvgetstats(s->bs), &req->acct); virtioblkfreerequest(req); } bdrverroraction(s->bs, action, isread, error); return action != BLOCKERRORACTIONIGNORE; } ", "target": 0}
{"func": "static inline void FUNC(idctRowCondDCextrashift)(int16t *row, int extrashift) #else static inline void FUNC(idctRowCondDC)(int16t *row, int extrashift) #endif { int a0, a1, a2, a3, b0, b1, b2, b3; #if HAVEFAST64BIT #define ROW0MASK (0xffffLL << 48 * HAVEBIGENDIAN) if (((AVRN64A(row) & ~ROW0MASK) | AVRN64A(row+4)) == 0) { uint64t temp; if (DCSHIFT - extrashift >= 0) { temp = (row[0] * (1 << (DCSHIFT - extrashift))) & 0xffff; } else { temp = ((row[0] + (1<<(extrashift - DCSHIFT-1))) >> (extrashift - DCSHIFT)) & 0xffff; } temp += temp * (1 << 16); temp += temp * ((uint64t) 1 << 32); AVWN64A(row, temp); AVWN64A(row + 4, temp); return; } #else if (!(AVRN32A(row+2) | AVRN32A(row+4) | AVRN32A(row+6) | row[1])) { uint32t temp; if (DCSHIFT - extrashift >= 0) { temp = (row[0] * (1 << (DCSHIFT - extrashift))) & 0xffff; } else { temp = ((row[0] + (1<<(extrashift - DCSHIFT-1))) >> (extrashift - DCSHIFT)) & 0xffff; } temp += temp * (1 << 16); AVWN32A(row, temp); AVWN32A(row+2, temp); AVWN32A(row+4, temp); AVWN32A(row+6, temp); return; } #endif a0 = (W4 * row[0]) + (1 << (ROWSHIFT + extrashift - 1)); a1 = a0; a2 = a0; a3 = a0; a0 += W2 * row[2]; a1 += W6 * row[2]; a2 -= W6 * row[2]; a3 -= W2 * row[2]; b0 = MUL(W1, row[1]); MAC(b0, W3, row[3]); b1 = MUL(W3, row[1]); MAC(b1, -W7, row[3]); b2 = MUL(W5, row[1]); MAC(b2, -W1, row[3]); b3 = MUL(W7, row[1]); MAC(b3, -W5, row[3]); if (AVRN64A(row + 4)) { a0 += W4*row[4] + W6*row[6]; a1 += - W4*row[4] - W2*row[6]; a2 += - W4*row[4] + W2*row[6]; a3 += W4*row[4] - W6*row[6]; MAC(b0, W5, row[5]); MAC(b0, W7, row[7]); MAC(b1, -W1, row[5]); MAC(b1, -W5, row[7]); MAC(b2, W7, row[5]); MAC(b2, W3, row[7]); MAC(b3, W3, row[5]); MAC(b3, -W1, row[7]); } row[0] = (a0 + b0) >> (ROWSHIFT + extrashift); row[7] = (a0 - b0) >> (ROWSHIFT + extrashift); row[1] = (a1 + b1) >> (ROWSHIFT + extrashift); row[6] = (a1 - b1) >> (ROWSHIFT + extrashift); row[2] = (a2 + b2) >> (ROWSHIFT + extrashift); row[5] = (a2 - b2) >> (ROWSHIFT + extrashift); row[3] = (a3 + b3) >> (ROWSHIFT + extrashift); row[4] = (a3 - b3) >> (ROWSHIFT + extrashift); } ", "target": 1}
{"func": "struct omapmmcs *omap2mmcinit(struct omaptargetagents *ta, BlockDriverState *bd, qemuirq irq, qemuirq dma[], omapclk fclk, omapclk iclk) { struct omapmmcs *s = (struct omapmmcs *) gmalloc0(sizeof(struct omapmmcs)); s->irq = irq; s->dma = dma; s->clk = fclk; s->lines = 4; s->rev = 2; omapmmcreset(s); memoryregioninitio(&s->iomem, NULL, &omapmmcops, s, \"omap.mmc\", omapl4regionsize(ta, 0)); omapl4attach(ta, 0, &s->iomem); /* Instantiate the storage */ s->card = sdinit(bd, false); if (s->card == NULL) { exit(1); } s->cdet = qemuallocateirqs(omapmmccovercb, s, 1)[0]; sdsetcb(s->card, NULL, s->cdet); return s; } ", "target": 1}
{"func": "static void calxedainit(MachineState *machine, enum cxmachines machineid) { ramaddrt ramsize = machine->ramsize; const char *cpumodel = machine->cpumodel; const char *kernelfilename = machine->kernelfilename; const char *kernelcmdline = machine->kernelcmdline; const char *initrdfilename = machine->initrdfilename; DeviceState *dev = NULL; SysBusDevice *busdev; qemuirq pic[128]; int n; qemuirq cpuirq[4]; qemuirq cpufiq[4]; MemoryRegion *sysram; MemoryRegion *dram; MemoryRegion *sysmem; char *sysbootfilename; if (!cpumodel) { switch (machineid) { case CALXEDAHIGHBANK: cpumodel = \"cortex-a9\"; break; case CALXEDAMIDWAY: cpumodel = \"cortex-a15\"; break; } } for (n = 0; n < smpcpus; n++) { ObjectClass *oc = cpuclassbyname(TYPEARMCPU, cpumodel); Object *cpuobj; ARMCPU *cpu; Error *err = NULL; if (!oc) { errorreport(\"Unable to find CPU definition\"); exit(1); } cpuobj = objectnew(objectclassgetname(oc)); cpu = ARMCPU(cpuobj); /* By default A9 and A15 CPUs have EL3 enabled. This board does not * currently support EL3 so the CPU EL3 property is disabled before * realization. */ if (objectpropertyfind(cpuobj, \"hasel3\", NULL)) { objectpropertysetbool(cpuobj, false, \"hasel3\", &err); if (err) { errorreporterr(err); exit(1); } } if (objectpropertyfind(cpuobj, \"reset-cbar\", NULL)) { objectpropertysetint(cpuobj, MPCOREPERIPHBASE, \"reset-cbar\", &errorabort); } objectpropertysetbool(cpuobj, true, \"realized\", &err); if (err) { errorreporterr(err); exit(1); } cpuirq[n] = qdevgetgpioin(DEVICE(cpu), ARMCPUIRQ); cpufiq[n] = qdevgetgpioin(DEVICE(cpu), ARMCPUFIQ); } sysmem = getsystemmemory(); dram = gnew(MemoryRegion, 1); memoryregionallocatesystemmemory(dram, NULL, \"highbank.dram\", ramsize); /* SDRAM at address zero. */ memoryregionaddsubregion(sysmem, 0, dram); sysram = gnew(MemoryRegion, 1); memoryregioninitram(sysram, NULL, \"highbank.sysram\", 0x8000, &errorfatal); memoryregionaddsubregion(sysmem, 0xfff88000, sysram); if (biosname != NULL) { sysbootfilename = qemufindfile(QEMUFILETYPEBIOS, biosname); if (sysbootfilename != NULL) { if (loadimagetargphys(sysbootfilename, 0xfff88000, 0x8000) < 0) { hwerror(\"Unable to load %s\\n\", biosname); } gfree(sysbootfilename); } else { hwerror(\"Unable to find %s\\n\", biosname); } } switch (machineid) { case CALXEDAHIGHBANK: dev = qdevcreate(NULL, \"l2x0\"); qdevinitnofail(dev); busdev = SYSBUSDEVICE(dev); sysbusmmiomap(busdev, 0, 0xfff12000); dev = qdevcreate(NULL, \"a9mpcorepriv\"); break; case CALXEDAMIDWAY: dev = qdevcreate(NULL, \"a15mpcorepriv\"); break; } qdevpropsetuint32(dev, \"num-cpu\", smpcpus); qdevpropsetuint32(dev, \"num-irq\", NIRQGIC); qdevinitnofail(dev); busdev = SYSBUSDEVICE(dev); sysbusmmiomap(busdev, 0, MPCOREPERIPHBASE); for (n = 0; n < smpcpus; n++) { sysbusconnectirq(busdev, n, cpuirq[n]); sysbusconnectirq(busdev, n + smpcpus, cpufiq[n]); } for (n = 0; n < 128; n++) { pic[n] = qdevgetgpioin(dev, n); } dev = qdevcreate(NULL, \"sp804\"); qdevpropsetuint32(dev, \"freq0\", 150000000); qdevpropsetuint32(dev, \"freq1\", 150000000); qdevinitnofail(dev); busdev = SYSBUSDEVICE(dev); sysbusmmiomap(busdev, 0, 0xfff34000); sysbusconnectirq(busdev, 0, pic[18]); sysbuscreatesimple(\"pl011\", 0xfff36000, pic[20]); dev = qdevcreate(NULL, \"highbank-regs\"); qdevinitnofail(dev); busdev = SYSBUSDEVICE(dev); sysbusmmiomap(busdev, 0, 0xfff3c000); sysbuscreatesimple(\"pl061\", 0xfff30000, pic[14]); sysbuscreatesimple(\"pl061\", 0xfff31000, pic[15]); sysbuscreatesimple(\"pl061\", 0xfff32000, pic[16]); sysbuscreatesimple(\"pl061\", 0xfff33000, pic[17]); sysbuscreatesimple(\"pl031\", 0xfff35000, pic[19]); sysbuscreatesimple(\"pl022\", 0xfff39000, pic[23]); sysbuscreatesimple(\"sysbus-ahci\", 0xffe08000, pic[83]); if (ndtable[0].used) { qemuchecknicmodel(&ndtable[0], \"xgmac\"); dev = qdevcreate(NULL, \"xgmac\"); qdevsetnicproperties(dev, &ndtable[0]); qdevinitnofail(dev); sysbusmmiomap(SYSBUSDEVICE(dev), 0, 0xfff50000); sysbusconnectirq(SYSBUSDEVICE(dev), 0, pic[77]); sysbusconnectirq(SYSBUSDEVICE(dev), 1, pic[78]); sysbusconnectirq(SYSBUSDEVICE(dev), 2, pic[79]); qemuchecknicmodel(&ndtable[1], \"xgmac\"); dev = qdevcreate(NULL, \"xgmac\"); qdevsetnicproperties(dev, &ndtable[1]); qdevinitnofail(dev); sysbusmmiomap(SYSBUSDEVICE(dev), 0, 0xfff51000); sysbusconnectirq(SYSBUSDEVICE(dev), 0, pic[80]); sysbusconnectirq(SYSBUSDEVICE(dev), 1, pic[81]); sysbusconnectirq(SYSBUSDEVICE(dev), 2, pic[82]); } highbankbinfo.ramsize = ramsize; highbankbinfo.kernelfilename = kernelfilename; highbankbinfo.kernelcmdline = kernelcmdline; highbankbinfo.initrdfilename = initrdfilename; /* highbank requires a dtb in order to boot, and the dtb will override * the board ID. The following value is ignored, so set it to -1 to be * clear that the value is meaningless. */ highbankbinfo.boardid = -1; highbankbinfo.nbcpus = smpcpus; highbankbinfo.loaderstart = 0; highbankbinfo.writesecondaryboot = hbwritesecondary; highbankbinfo.secondarycpuresethook = hbresetsecondary; armloadkernel(ARMCPU(firstcpu), &highbankbinfo); } ", "target": 0}
{"func": "static int getphysaddrv5(CPUState *env, uint32t address, int accesstype, \t\t\t int isuser, uint32t *physptr, int *prot) { int code; uint32t table; uint32t desc; int type; int ap; int domain; uint32t physaddr; /* Pagetable walk. */ /* Lookup l1 descriptor. */ table = getlevel1tableaddress(env, address); desc = ldlphys(table); type = (desc & 3); domain = (env->cp15.c3 >> ((desc >> 4) & 0x1e)) & 3; if (type == 0) { /* Section translation fault. */ code = 5; goto dofault; } if (domain == 0 || domain == 2) { if (type == 2) code = 9; /* Section domain fault. */ else code = 11; /* Page domain fault. */ goto dofault; } if (type == 2) { /* 1Mb section. */ physaddr = (desc & 0xfff00000) | (address & 0x000fffff); ap = (desc >> 10) & 3; code = 13; } else { /* Lookup l2 entry. */ \tif (type == 1) { \t /* Coarse pagetable. */ \t table = (desc & 0xfffffc00) | ((address >> 10) & 0x3fc); \t} else { \t /* Fine pagetable. */ \t table = (desc & 0xfffff000) | ((address >> 8) & 0xffc); \t} desc = ldlphys(table); switch (desc & 3) { case 0: /* Page translation fault. */ code = 7; goto dofault; case 1: /* 64k page. */ physaddr = (desc & 0xffff0000) | (address & 0xffff); ap = (desc >> (4 + ((address >> 13) & 6))) & 3; break; case 2: /* 4k page. */ physaddr = (desc & 0xfffff000) | (address & 0xfff); ap = (desc >> (4 + ((address >> 13) & 6))) & 3; break; case 3: /* 1k page. */ \t if (type == 1) { \t\tif (armfeature(env, ARMFEATUREXSCALE)) { \t\t physaddr = (desc & 0xfffff000) | (address & 0xfff); \t\t} else { \t\t /* Page translation fault. */ \t\t code = 7; \t\t goto dofault; \t\t} \t } else { \t\tphysaddr = (desc & 0xfffffc00) | (address & 0x3ff); \t } ap = (desc >> 4) & 3; break; default: /* Never happens, but compiler isn't smart enough to tell. */ abort(); } code = 15; } *prot = checkap(env, ap, domain, accesstype, isuser); if (!*prot) { /* Access permission fault. */ goto dofault; } *physptr = physaddr; return 0; dofault: return code | (domain << 4); } ", "target": 0}
{"func": "static void vmxnet3updatemcastfilters(VMXNET3State *s) { uint16t listbytes = VMXNET3READDRVSHARED16(s->drvshmem, devRead.rxFilterConf.mfTableLen); s->mcastlistlen = listbytes / sizeof(s->mcastlist[0]); s->mcastlist = grealloc(s->mcastlist, listbytes); if (!s->mcastlist) { if (s->mcastlistlen == 0) { VMWCFPRN(\"Current multicast list is empty\"); } else { VMWERPRN(\"Failed to allocate multicast list of %d elements\", s->mcastlistlen); } s->mcastlistlen = 0; } else { int i; hwaddr mcastlistpa = VMXNET3READDRVSHARED64(s->drvshmem, devRead.rxFilterConf.mfTablePA); pcidmaread(PCIDEVICE(s), mcastlistpa, s->mcastlist, listbytes); VMWCFPRN(\"Current multicast list len is %d:\", s->mcastlistlen); for (i = 0; i < s->mcastlistlen; i++) { VMWCFPRN(\"\\t\" MACFMT, MACARG(s->mcastlist[i].a)); } } } ", "target": 1}
{"func": "int ffnvdecdecodeinit(AVCodecContext *avctx, unsigned int dpbsize) { NVDECContext *ctx = avctx->internal->hwaccelprivdata; NVDECFramePool *pool; AVHWFramesContext *framesctx; const AVPixFmtDescriptor *swdesc; CUVIDDECODECREATEINFO params = { 0 }; int cuvidcodectype, cuvidchromaformat; int ret = 0; swdesc = avpixfmtdescget(avctx->swpixfmt); if (!swdesc) return AVERRORBUG; cuvidcodectype = mapavcodecid(avctx->codecid); if (cuvidcodectype < 0) { avlog(avctx, AVLOGERROR, \"Unsupported codec ID\\n\"); return AVERRORBUG; } cuvidchromaformat = mapchromaformat(avctx->swpixfmt); if (cuvidchromaformat < 0) { avlog(avctx, AVLOGERROR, \"Unsupported chroma format\\n\"); return AVERROR(ENOSYS); } if (avctx->threadtype & FFTHREADFRAME) dpbsize += avctx->threadcount; if (!avctx->hwframesctx) { AVHWFramesContext *framesctx; if (!avctx->hwdevicectx) { avlog(avctx, AVLOGERROR, \"A hardware device or frames context \" \"is required for CUVID decoding.\\n\"); return AVERROR(EINVAL); } avctx->hwframesctx = avhwframectxalloc(avctx->hwdevicectx); if (!avctx->hwframesctx) return AVERROR(ENOMEM); framesctx = (AVHWFramesContext*)avctx->hwframesctx->data; framesctx->format = AVPIXFMTCUDA; framesctx->width = avctx->codedwidth; framesctx->height = avctx->codedheight; framesctx->swformat = AVPIXFMTNV12; framesctx->swformat = swdesc->comp[0].depth > 8 ? AVPIXFMTP010 : AVPIXFMTNV12; framesctx->initialpoolsize = dpbsize; ret = avhwframectxinit(avctx->hwframesctx); if (ret < 0) { avlog(avctx, AVLOGERROR, \"Error initializing internal frames context\\n\"); return ret; } } framesctx = (AVHWFramesContext*)avctx->hwframesctx->data; params.ulWidth = avctx->codedwidth; params.ulHeight = avctx->codedheight; params.ulTargetWidth = avctx->codedwidth; params.ulTargetHeight = avctx->codedheight; params.bitDepthMinus8 = swdesc->comp[0].depth - 8; params.OutputFormat = params.bitDepthMinus8 ? cudaVideoSurfaceFormatP016 : cudaVideoSurfaceFormatNV12; params.CodecType = cuvidcodectype; params.ChromaFormat = cuvidchromaformat; params.ulNumDecodeSurfaces = dpbsize; params.ulNumOutputSurfaces = 1; ret = nvdecdecodercreate(&ctx->decoderref, framesctx->deviceref, &params, avctx); if (ret < 0) return ret; pool = avmallocz(sizeof(*pool)); if (!pool) { ret = AVERROR(ENOMEM); goto fail; } pool->dpbsize = dpbsize; ctx->decoderpool = avbufferpoolinit2(sizeof(int), pool, nvdecdecoderframealloc, avfree); if (!ctx->decoderpool) { ret = AVERROR(ENOMEM); goto fail; } return 0; fail: ffnvdecdecodeuninit(avctx); return ret; } ", "target": 0}
{"func": "void hmpinfosnapshots(Monitor *mon, const QDict *qdict) { BlockDriverState *bs, *bs1; QEMUSnapshotInfo *sntab, *sn, s, *sninfo = &s; int nbsns, i, ret, available; int total; int *availablesnapshots; bs = findvmstatebs(); if (!bs) { monitorprintf(mon, \"No available block device supports snapshots\\n\"); return; } nbsns = bdrvsnapshotlist(bs, &sntab); if (nbsns < 0) { monitorprintf(mon, \"bdrvsnapshotlist: error %d\\n\", nbsns); return; } if (nbsns == 0) { monitorprintf(mon, \"There is no snapshot available.\\n\"); return; } availablesnapshots = gmalloc0(sizeof(int) * nbsns); total = 0; for (i = 0; i < nbsns; i++) { sn = &sntab[i]; available = 1; bs1 = NULL; while ((bs1 = bdrvnext(bs1))) { if (bdrvcansnapshot(bs1) && bs1 != bs) { ret = bdrvsnapshotfind(bs1, sninfo, sn->idstr); if (ret < 0) { available = 0; break; } } } if (available) { availablesnapshots[total] = i; total++; } } if (total > 0) { bdrvsnapshotdump((fprintffunction)monitorprintf, mon, NULL); monitorprintf(mon, \"\\n\"); for (i = 0; i < total; i++) { sn = &sntab[availablesnapshots[i]]; bdrvsnapshotdump((fprintffunction)monitorprintf, mon, sn); monitorprintf(mon, \"\\n\"); } } else { monitorprintf(mon, \"There is no suitable snapshot available\\n\"); } gfree(sntab); gfree(availablesnapshots); } ", "target": 1}
{"func": "int decodeblockcoeffs(VP56RangeCoder *c, int16t block[16], uint8t probs[16][3][NUMDCTTOKENS - 1], int i, int zeronhood, int16t qmul[2]) { uint8t *tokenprob = probs[i][zeronhood]; if (!vp56racgetprobbranchy(c, tokenprob[0])) // DCTEOB return 0; return decodeblockcoeffsinternal(c, block, probs, i, tokenprob, qmul); } ", "target": 1}
{"func": "static int cirrusbitbltsolidfill(CirrusVGAState *s, int bltrop) { cirrusfillt ropfunc; if (blitisunsafe(s)) { return 0; } ropfunc = cirrusfill[roptoindex[bltrop]][s->cirrusbltpixelwidth - 1]; ropfunc(s, s->vga.vramptr + (s->cirrusbltdstaddr & s->cirrusaddrmask), s->cirrusbltdstpitch, s->cirrusbltwidth, s->cirrusbltheight); cirrusinvalidateregion(s, s->cirrusbltdstaddr, \t\t\t s->cirrusbltdstpitch, s->cirrusbltwidth, \t\t\t s->cirrusbltheight); cirrusbitbltreset(s); return 1; } ", "target": 1}
{"func": "static int loadipmoviepacket(IPMVEContext *s, AVIOContext *pb, AVPacket *pkt) { int chunktype; if (s->audiochunkoffset) { /* adjust for PCM audio by skipping chunk header */ if (s->audiotype != CODECIDINTERPLAYDPCM) { s->audiochunkoffset += 6; s->audiochunksize -= 6; avioseek(pb, s->audiochunkoffset, SEEKSET); s->audiochunkoffset = 0; if (s->audiochunksize != avgetpacket(pb, pkt, s->audiochunksize)) return CHUNKEOF; pkt->streamindex = s->audiostreamindex; pkt->pts = s->audioframecount; /* audio frame maintenance */ if (s->audiotype != CODECIDINTERPLAYDPCM) s->audioframecount += (s->audiochunksize / s->audiochannels / (s->audiobits / 8)); else s->audioframecount += (s->audiochunksize - 6) / s->audiochannels; avdlog(NULL, \"sending audio frame with pts %\"PRId64\" (%d audio frames)\\n\", pkt->pts, s->audioframecount); chunktype = CHUNKVIDEO; } else if (s->decodemapchunkoffset) { /* send both the decode map and the video data together */ if (avnewpacket(pkt, s->decodemapchunksize + s->videochunksize)) return CHUNKNOMEM; if (s->haspalette) { uint8t *pal; pal = avpacketnewsidedata(pkt, AVPKTDATAPALETTE, AVPALETTESIZE); if (pal) { memcpy(pal, s->palette, AVPALETTESIZE); s->haspalette = 0; pkt->pos= s->decodemapchunkoffset; avioseek(pb, s->decodemapchunkoffset, SEEKSET); s->decodemapchunkoffset = 0; if (avioread(pb, pkt->data, s->decodemapchunksize) != s->decodemapchunksize) { avfreepacket(pkt); return CHUNKEOF; avioseek(pb, s->videochunkoffset, SEEKSET); s->videochunkoffset = 0; if (avioread(pb, pkt->data + s->decodemapchunksize, s->videochunksize) != s->videochunksize) { avfreepacket(pkt); return CHUNKEOF; pkt->streamindex = s->videostreamindex; pkt->pts = s->videopts; avdlog(NULL, \"sending video frame with pts %\"PRId64\"\\n\", pkt->pts); s->videopts += s->frameptsinc; chunktype = CHUNKVIDEO; } else { avioseek(pb, s->nextchunkoffset, SEEKSET); chunktype = CHUNKDONE; return chunktype; ", "target": 1}
{"func": "static int encodehqslice(AVCodecContext *avctx, void *arg) { SliceArgs *slicedat = arg; VC2EncContext *s = slicedat->ctx; PutBitContext *pb = &slicedat->pb; const int slicex = slicedat->x; const int slicey = slicedat->y; const int quantidx = slicedat->quantidx; const int slicebytesmax = slicedat->bytes; uint8t quants[MAXDWTLEVELS][4]; int p, level, orientation; avprivalignputbits(pb); skipputbytes(pb, s->prefixbytes); putbits(pb, 8, quantidx); /* Slice quantization (slicequantizers() in the specs) */ for (level = 0; level < s->waveletdepth; level++) for (orientation = !!level; orientation < 4; orientation++) quants[level][orientation] = FFMAX(quantidx - s->quant[level][orientation], 0); /* Luma + 2 Chroma planes */ for (p = 0; p < 3; p++) { int bytesstart, byteslen, pads, padc; bytesstart = putbitscount(pb) >> 3; putbits(pb, 8, 0); for (level = 0; level < s->waveletdepth; level++) { for (orientation = !!level; orientation < 4; orientation++) { encodesubband(s, pb, slicex, slicey, &s->plane[p].band[level][orientation], quants[level][orientation]); } } avprivalignputbits(pb); byteslen = (putbitscount(pb) >> 3) - bytesstart - 1; if (p == 2) { int lendiff = slicebytesmax - (putbitscount(pb) >> 3); pads = FFALIGN((byteslen + lendiff), s->sizescaler)/s->sizescaler; padc = (pads*s->sizescaler) - byteslen; } else { pads = FFALIGN(byteslen, s->sizescaler)/s->sizescaler; padc = (pads*s->sizescaler) - byteslen; } pb->buf[bytesstart] = pads; flushputbits(pb); skipputbytes(pb, padc); } return 0; } ", "target": 0}
{"func": "static void doinfocommands(Monitor *mon, QObject **retdata) { QList *cmdlist; const moncmdt *cmd; cmdlist = qlistnew(); for (cmd = qmpcmds; cmd->name != NULL; cmd++) { if (monitorhandlerported(cmd) && !monitorcmduseronly(cmd) && !comparecmd(cmd->name, \"info\")) { qlistappendobj(cmdlist, getcmddict(cmd->name)); } } for (cmd = qmpquerycmds; cmd->name != NULL; cmd++) { if (monitorhandlerported(cmd) && !monitorcmduseronly(cmd)) { char buf[128]; snprintf(buf, sizeof(buf), \"query-%s\", cmd->name); qlistappendobj(cmdlist, getcmddict(buf)); } } *retdata = QOBJECT(cmdlist); } ", "target": 0}
{"func": "static void spaprmsiwrite(void *opaque, hwaddr addr, uint64t data, unsigned size) { sPAPRPHBState *phb = opaque; int ndev = addr >> 16; int vec = ((addr & 0xFFFF) >> 2) | data; uint32t irq = phb->msitable[ndev].irq + vec; tracespaprpcimsiwrite(addr, data, irq); qemuirqpulse(xicsgetqirq(spapr->icp, irq)); } ", "target": 0}
{"func": "static void pxa2xxpmwrite(void *opaque, targetphysaddrt addr, uint32t value) { struct pxa2xxstates *s = (struct pxa2xxstates *) opaque; if (addr > s->pmbase + PCMD31) { /* Special case: PWRI2C registers appear in the same range. */ pxa2xxi2cwrite(s->i2c[1], addr, value); return; } addr -= s->pmbase; switch (addr) { case PMCR: s->pmregs[addr >> 2] &= 0x15 & ~(value & 0x2a); s->pmregs[addr >> 2] |= value & 0x15; break; case PSSR:\t/* Read-clean registers */ case RCSR: case PKSR: s->pmregs[addr >> 2] &= ~value; break; default:\t/* Read-write registers */ if (addr >= PMCR && addr <= PCMD31 && !(addr & 3)) { s->pmregs[addr >> 2] = value; break; } printf(\"%s: Bad register \" REGFMT \"\\n\", FUNCTION, addr); break; } } ", "target": 0}
{"func": "CPUX86State *cpux86init(void) { CPUX86State *env; int i; static int inited; cpux86tblocksinit(); env = malloc(sizeof(CPUX86State)); if (!env) return NULL; memset(env, 0, sizeof(CPUX86State)); /* basic FPU init */ for(i = 0;i < 8; i++) env->fptags[i] = 1; env->fpuc = 0x37f; /* flags setup */ env->eflags = 0; /* init various static tables */ if (!inited) { inited = 1; optimizeflagsinit(); } return env; } ", "target": 0}
{"func": "void readlineshowprompt(ReadLineState *rs) { monitorprintf(rs->mon, \"%s\", rs->prompt); monitorflush(rs->mon); rs->lastcmdbufindex = 0; rs->lastcmdbufsize = 0; rs->escstate = ISNORM; } ", "target": 0}
{"func": "static int parallelparse(const char *devname) { static int index = 0; char label[32]; if (strcmp(devname, \"none\") == 0) return 0; if (index == MAXPARALLELPORTS) { fprintf(stderr, \"qemu: too many parallel ports\\n\"); exit(1); } snprintf(label, sizeof(label), \"parallel%d\", index); parallelhds[index] = qemuchrnew(label, devname, NULL); if (!parallelhds[index]) { fprintf(stderr, \"qemu: could not connect parallel device\" \" to character backend '%s'\\n\", devname); return -1; } index++; return 0; } ", "target": 0}
{"func": "STARTTEST(qfloatdestroytest) { QFloat *qf = qfloatfromdouble(0.0); QDECREF(qf); } ", "target": 0}
{"func": "static int locallstat(FsContext *fsctx, V9fsPath *fspath, struct stat *stbuf) { int err; char buffer[PATHMAX]; char *path = fspath->data; err = lstat(rpath(fsctx, path, buffer), stbuf); if (err) { return err; } if (fsctx->fssm == SMMAPPED) { /* Actual credentials are part of extended attrs */ uidt tmpuid; gidt tmpgid; modet tmpmode; devt tmpdev; if (getxattr(rpath(fsctx, path, buffer), \"user.virtfs.uid\", &tmpuid, sizeof(uidt)) > 0) { stbuf->stuid = tmpuid; } if (getxattr(rpath(fsctx, path, buffer), \"user.virtfs.gid\", &tmpgid, sizeof(gidt)) > 0) { stbuf->stgid = tmpgid; } if (getxattr(rpath(fsctx, path, buffer), \"user.virtfs.mode\", &tmpmode, sizeof(modet)) > 0) { stbuf->stmode = tmpmode; } if (getxattr(rpath(fsctx, path, buffer), \"user.virtfs.rdev\", &tmpdev, sizeof(devt)) > 0) { stbuf->strdev = tmpdev; } } return err; } ", "target": 0}
{"func": "void QEMUNORETURN runtimeexception(CPUS390XState *env, int excp, uintptrt retaddr) { CPUState *cs = CPU(s390envgetcpu(env)); int t; cs->exceptionindex = EXCPPGM; env->intpgmcode = excp; /* Use the (ultimate) callers address to find the insn that trapped. */ cpurestorestate(cs, retaddr); /* Advance past the insn. */ t = cpuldubcode(env, env->psw.addr); env->intpgmilen = t = getilen(t); env->psw.addr += t; cpuloopexit(cs); } ", "target": 0}
{"func": "static int usbhostinit(void) { const struct libusbpollfd **poll; int i, rc; if (ctx) { return 0; } rc = libusbinit(&ctx); if (rc != 0) { return -1; } libusbsetdebug(ctx, loglevel); libusbsetpollfdnotifiers(ctx, usbhostaddfd, usbhostdelfd, ctx); poll = libusbgetpollfds(ctx); if (poll) { for (i = 0; poll[i] != NULL; i++) { usbhostaddfd(poll[i]->fd, poll[i]->events, ctx); } } free(poll); return 0; } ", "target": 0}
{"func": "SnapshotInfo *qmpblockdevsnapshotdeleteinternalsync(const char *device, bool hasid, const char *id, bool hasname, const char *name, Error **errp) { BlockDriverState *bs; BlockBackend *blk; AioContext *aiocontext; QEMUSnapshotInfo sn; Error *localerr = NULL; SnapshotInfo *info = NULL; int ret; blk = blkbyname(device); if (!blk) { errorset(errp, ERRORCLASSDEVICENOTFOUND, \"Device '%s' not found\", device); return NULL; } aiocontext = blkgetaiocontext(blk); aiocontextacquire(aiocontext); if (!hasid) { id = NULL; } if (!hasname) { name = NULL; } if (!id && !name) { errorsetg(errp, \"Name or id must be provided\"); goto outaiocontext; } if (!blkisavailable(blk)) { errorsetg(errp, \"Device '%s' has no medium\", device); goto outaiocontext; } bs = blkbs(blk); if (bdrvopisblocked(bs, BLOCKOPTYPEINTERNALSNAPSHOTDELETE, errp)) { goto outaiocontext; } ret = bdrvsnapshotfindbyidandname(bs, id, name, &sn, &localerr); if (localerr) { errorpropagate(errp, localerr); goto outaiocontext; } if (!ret) { errorsetg(errp, \"Snapshot with id '%s' and name '%s' does not exist on \" \"device '%s'\", STRORNULL(id), STRORNULL(name), device); goto outaiocontext; } bdrvsnapshotdelete(bs, id, name, &localerr); if (localerr) { errorpropagate(errp, localerr); goto outaiocontext; } aiocontextrelease(aiocontext); info = gnew0(SnapshotInfo, 1); info->id = gstrdup(sn.idstr); info->name = gstrdup(sn.name); info->datensec = sn.datensec; info->datesec = sn.datesec; info->vmstatesize = sn.vmstatesize; info->vmclocknsec = sn.vmclocknsec % 1000000000; info->vmclocksec = sn.vmclocknsec / 1000000000; return info; outaiocontext: aiocontextrelease(aiocontext); return NULL; } ", "target": 0}
{"func": "static void virtioscsicompletereq(VirtIOSCSIReq *req) { VirtIOSCSI *s = req->dev; VirtQueue *vq = req->vq; VirtIODevice *vdev = VIRTIODEVICE(s); virtqueuepush(vq, &req->elem, req->qsgl.size + req->elem.insg[0].iovlen); if (req->sreq) { req->sreq->hbaprivate = NULL; scsirequnref(req->sreq); } virtioscsifreereq(req); virtionotify(vdev, vq); } ", "target": 0}
{"func": "bool timerpending(QEMUTimer *ts) { QEMUTimer *t; for (t = ts->timerlist->activetimers; t != NULL; t = t->next) { if (t == ts) { return true; } } return false; } ", "target": 0}
{"func": "static int avcold libopusencodeinit(AVCodecContext *avctx) { LibopusEncContext *opus = avctx->privdata; const uint8t *channelmapping; OpusMSEncoder *enc; int ret = OPUSOK; int coupledstreamcount, headersize, framesize; coupledstreamcount = opuscoupledstreams[avctx->channels - 1]; opus->streamcount = avctx->channels - coupledstreamcount; channelmapping = libavlibopuschannelmap[avctx->channels - 1]; /* FIXME: Opus can handle up to 255 channels. However, the mapping for * anything greater than 8 is undefined. */ if (avctx->channels > 8) avlog(avctx, AVLOGWARNING, \"Channel layout undefined for %d channels.\\n\", avctx->channels); if (!avctx->bitrate) { /* Sane default copied from opusenc */ avctx->bitrate = 64000 * opus->streamcount + 32000 * coupledstreamcount; avlog(avctx, AVLOGWARNING, \"No bit rate set. Defaulting to %d bps.\\n\", avctx->bitrate); } if (avctx->bitrate < 500 || avctx->bitrate > 256000 * avctx->channels) { avlog(avctx, AVLOGERROR, \"The bit rate %d bps is unsupported. \" \"Please choose a value between 500 and %d.\\n\", avctx->bitrate, 256000 * avctx->channels); return AVERROR(EINVAL); } framesize = opus->opts.frameduration * 48000 / 1000; switch (framesize) { case 120: case 240: if (opus->opts.application != OPUSAPPLICATIONRESTRICTEDLOWDELAY) avlog(avctx, AVLOGWARNING, \"LPC mode cannot be used with a frame duration of less \" \"than 10ms. Enabling restricted low-delay mode.\\n\" \"Use a longer frame duration if this is not what you want.\\n\"); /* Frame sizes less than 10 ms can only use MDCT mode, so switching to * RESTRICTEDLOWDELAY avoids an unnecessary extra 2.5ms lookahead. */ opus->opts.application = OPUSAPPLICATIONRESTRICTEDLOWDELAY; case 480: case 960: case 1920: case 2880: opus->opts.packetsize = avctx->framesize = framesize * avctx->samplerate / 48000; break; default: avlog(avctx, AVLOGERROR, \"Invalid frame duration: %g.\\n\" \"Frame duration must be exactly one of: 2.5, 5, 10, 20, 40 or 60.\\n\", opus->opts.frameduration); return AVERROR(EINVAL); } if (avctx->compressionlevel < 0 || avctx->compressionlevel > 10) { avlog(avctx, AVLOGWARNING, \"Compression level must be in the range 0 to 10. \" \"Defaulting to 10.\\n\"); opus->opts.complexity = 10; } else { opus->opts.complexity = avctx->compressionlevel; } if (avctx->cutoff) { switch (avctx->cutoff) { case 4000: opus->opts.maxbandwidth = OPUSBANDWIDTHNARROWBAND; break; case 6000: opus->opts.maxbandwidth = OPUSBANDWIDTHMEDIUMBAND; break; case 8000: opus->opts.maxbandwidth = OPUSBANDWIDTHWIDEBAND; break; case 12000: opus->opts.maxbandwidth = OPUSBANDWIDTHSUPERWIDEBAND; break; case 20000: opus->opts.maxbandwidth = OPUSBANDWIDTHFULLBAND; break; default: avlog(avctx, AVLOGWARNING, \"Invalid frequency cutoff: %d. Using default maximum bandwidth.\\n\" \"Cutoff frequency must be exactly one of: 4000, 6000, 8000, 12000 or 20000.\\n\", avctx->cutoff); avctx->cutoff = 0; } } enc = opusmultistreamencodercreate(avctx->samplerate, avctx->channels, opus->streamcount, coupledstreamcount, channelmapping, opus->opts.application, &ret); if (ret != OPUSOK) { avlog(avctx, AVLOGERROR, \"Failed to create encoder: %s\\n\", opusstrerror(ret)); return ffopuserrortoaverror(ret); } ret = libopusconfigureencoder(avctx, enc, &opus->opts); if (ret != OPUSOK) { ret = ffopuserrortoaverror(ret); goto fail; } headersize = 19 + (avctx->channels > 2 ? 2 + avctx->channels : 0); avctx->extradata = avmalloc(headersize + FFINPUTBUFFERPADDINGSIZE); if (!avctx->extradata) { avlog(avctx, AVLOGERROR, \"Failed to allocate extradata.\\n\"); ret = AVERROR(ENOMEM); goto fail; } avctx->extradatasize = headersize; opus->samples = avmallocz(framesize * avctx->channels * avgetbytespersample(avctx->samplefmt)); if (!opus->samples) { avlog(avctx, AVLOGERROR, \"Failed to allocate samples buffer.\\n\"); ret = AVERROR(ENOMEM); goto fail; } ret = opusmultistreamencoderctl(enc, OPUSGETLOOKAHEAD(&avctx->delay)); if (ret != OPUSOK) avlog(avctx, AVLOGWARNING, \"Unable to get number of lookahead samples: %s\\n\", opusstrerror(ret)); libopuswriteheader(avctx, opus->streamcount, coupledstreamcount, opusvorbischannelmap[avctx->channels - 1]); ffafqueueinit(avctx, &opus->afq); opus->enc = enc; return 0; fail: opusmultistreamencoderdestroy(enc); avfreep(&avctx->extradata); return ret; } ", "target": 0}
{"func": "static void setuprtframe(int sig, struct emulatedsigaction *ka, targetsiginfot *info, \t\t\t targetsigsett *set, CPUX86State *env) { \tstruct rtsigframe *frame; \tint err = 0; \tframe = getsigframe(ka, env, sizeof(*frame)); #if 0 \tif (!accessok(VERIFYWRITE, frame, sizeof(*frame))) \t\tgoto givesigsegv; #endif \terr |= putuser((/*current->execdomain \t\t \t && current->execdomain->signalinvmap \t\t \t && sig < 32 \t\t \t ? current->execdomain->signalinvmap[sig] \t\t\t : */sig), \t\t\t &frame->sig); \terr |= putuser((targetulong)&frame->info, &frame->pinfo); \terr |= putuser((targetulong)&frame->uc, &frame->puc); \terr |= copysiginfotouser(&frame->info, info); \tif (err) \t\tgoto givesigsegv; \t/* Create the ucontext. */ \terr |= putuser(0, &frame->uc.ucflags); \terr |= putuser(0, &frame->uc.uclink); \terr |= putuser(/*current->sassssp*/ 0, &frame->uc.ucstack.sssp); \terr |= putuser(/* sasssflags(regs->esp) */ 0, \t\t\t &frame->uc.ucstack.ssflags); \terr |= putuser(/* current->sassssize */ 0, &frame->uc.ucstack.sssize); \terr |= setupsigcontext(&frame->uc.ucmcontext, &frame->fpstate, \t\t\t env, set->sig[0]); \terr |= copytouser(&frame->uc.ucsigmask, set, sizeof(*set)); \tif (err) \t\tgoto givesigsegv; \t/* Set up to return from userspace. If provided, use a stub \t already in userspace. */ \tif (ka->sa.saflags & TARGETSARESTORER) { \t\terr |= putuser(ka->sa.sarestorer, &frame->pretcode); \t} else { \t\terr |= putuser(frame->retcode, &frame->pretcode); \t\t/* This is movl $,%eax ; int $0x80 */ \t\terr |= putuser(0xb8, (char *)(frame->retcode+0)); \t\terr |= putuser(TARGETNRrtsigreturn, (int *)(frame->retcode+1)); \t\terr |= putuser(0x80cd, (short *)(frame->retcode+5)); \t} \tif (err) \t\tgoto givesigsegv; \t/* Set up registers for signal handler */ \tenv->regs[RESP] = (unsigned long) frame; \tenv->eip = (unsigned long) ka->sa.sahandler; cpux86loadseg(env, RDS, USERDS); cpux86loadseg(env, RES, USERDS); cpux86loadseg(env, RSS, USERDS); cpux86loadseg(env, RCS, USERCS); \tenv->eflags &= ~TFMASK; \treturn; givesigsegv: \tif (sig == TARGETSIGSEGV) \t\tka->sa.sahandler = TARGETSIGDFL; \tforcesig(TARGETSIGSEGV /* , current */); } ", "target": 0}
{"func": "static void tcpchrtelnetinit(QIOChannel *ioc) { char buf[3]; /* Send the telnet negotion to put telnet in binary, no echo, single char mode */ IACSET(buf, 0xff, 0xfb, 0x01); /* IAC WILL ECHO */ qiochannelwrite(ioc, buf, 3, NULL); IACSET(buf, 0xff, 0xfb, 0x03); /* IAC WILL Suppress go ahead */ qiochannelwrite(ioc, buf, 3, NULL); IACSET(buf, 0xff, 0xfb, 0x00); /* IAC WILL Binary */ qiochannelwrite(ioc, buf, 3, NULL); IACSET(buf, 0xff, 0xfd, 0x00); /* IAC DO Binary */ qiochannelwrite(ioc, buf, 3, NULL); } ", "target": 0}
{"func": "static void blkdelete(BlockBackend *blk) { assert(!blk->refcnt); assert(!blk->name); assert(!blk->dev); if (blk->root) { blkremovebs(blk); assert(QLISTEMPTY(&blk->removebsnotifiers.notifiers)); assert(QLISTEMPTY(&blk->insertbsnotifiers.notifiers)); QTAILQREMOVE(&blockbackends, blk, link); driveinfodel(blk->legacydinfo); blockacctcleanup(&blk->stats); gfree(blk); ", "target": 1}
{"func": "static int gdbserveropen(int port) { struct sockaddrin sockaddr; int fd, val, ret; fd = socket(PFINET, SOCKSTREAM, 0); if (fd < 0) { perror(\"socket\"); return -1; } #ifndef WIN32 fcntl(fd, FSETFD, FDCLOEXEC); #endif /* allow fast reuse */ val = 1; setsockopt(fd, SOLSOCKET, SOREUSEADDR, (char *)&val, sizeof(val)); sockaddr.sinfamily = AFINET; sockaddr.sinport = htons(port); sockaddr.sinaddr.saddr = 0; ret = bind(fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr)); if (ret < 0) { perror(\"bind\"); return -1; } ret = listen(fd, 0); if (ret < 0) { perror(\"listen\"); return -1; } return fd; }", "target": 1}
{"func": "static void spaprnvramclassinit(ObjectClass *klass, void *data) { DeviceClass *dc = DEVICECLASS(klass); VIOsPAPRDeviceClass *k = VIOSPAPRDEVICECLASS(klass); k->realize = spaprnvramrealize; k->devnode = spaprnvramdevnode; k->dtname = \"nvram\"; k->dttype = \"nvram\"; k->dtcompatible = \"qemu,spapr-nvram\"; setbit(DEVICECATEGORYMISC, dc->categories); dc->props = spaprnvramproperties; dc->vmsd = &vmstatespaprnvram; }", "target": 1}
{"func": "static void cpuhandleioreq(void *opaque) { XenIOState *state = opaque; ioreqt *req = cpugetioreq(state); handlebufferediopage(state); if (req) { ioreqt copy = *req; xenrmb(); handleioreq(state, &copy); req->data = copy.data; if (req->state != STATEIOREQINPROCESS) { fprintf(stderr, \"Badness in I/O request ... not in service?!: \" \"%x, ptr: %x, port: %\"PRIx64\", \" \"data: %\"PRIx64\", count: %u, size: %u, type: %u\\n\", req->state, req->dataisptr, req->addr, req->data, req->count, req->size, req->type); destroyhvmdomain(false); return; } xenwmb(); /* Update ioreq contents /then/ update state. */ /* * We do this before we send the response so that the tools * have the opportunity to pick up on the reset before the * guest resumes and does a hlt with interrupts disabled which * causes Xen to powerdown the domain. */ if (runstateisrunning()) { if (qemushutdownrequestedget()) { destroyhvmdomain(false); } if (qemuresetrequestedget()) { qemusystemreset(VMRESETREPORT); destroyhvmdomain(true); } } req->state = STATEIORESPREADY; xenevtchnnotify(state->xcehandle, state->ioreqlocalport[state->sendvcpu]); } } ", "target": 1}
{"func": "static bool scsitargetemulateinquiry(SCSITargetReq *r) { assert(r->req.dev->lun != r->req.lun); if (r->req.cmd.buf[1] & 0x2) { /* Command support data - optional, not implemented */ return false; } if (r->req.cmd.buf[1] & 0x1) { /* Vital product data */ uint8t pagecode = r->req.cmd.buf[2]; r->buf[r->len++] = pagecode ; /* this page */ r->buf[r->len++] = 0x00; switch (pagecode) { case 0x00: /* Supported page codes, mandatory */ { int pages; pages = r->len++; r->buf[r->len++] = 0x00; /* list of supported pages (this page) */ r->buf[pages] = r->len - pages - 1; /* number of pages */ break; } default: return false; } /* done with EVPD */ assert(r->len < sizeof(r->buf)); r->len = MIN(r->req.cmd.xfer, r->len); return true; } /* Standard INQUIRY data */ if (r->req.cmd.buf[2] != 0) { return false; } /* PAGE CODE == 0 */ r->len = MIN(r->req.cmd.xfer, 36); memset(r->buf, 0, r->len); if (r->req.lun != 0) { r->buf[0] = TYPENOLUN; } else { r->buf[0] = TYPENOTPRESENT | TYPEINACTIVE; r->buf[2] = 5; /* Version */ r->buf[3] = 2 | 0x10; /* HiSup, response data format */ r->buf[4] = r->len - 5; /* Additional Length = (Len - 1) - 4 */ r->buf[7] = 0x10 | (r->req.bus->info->tcq ? 0x02 : 0); /* Sync, TCQ. */ memcpy(&r->buf[8], \"QEMU \", 8); memcpy(&r->buf[16], \"QEMU TARGET \", 16); pstrcpy((char *) &r->buf[32], 4, qemugetversion()); } return true; } ", "target": 1}
{"func": "int qcow2expandzeroclusters(BlockDriverState *bs) { BDRVQcowState *s = bs->opaque; uint64t *l1table = NULL; uint64t nbclusters; uint8t *expandedclusters; int ret; int i, j; nbclusters = sizetoclusters(s, bs->file->totalsectors * BDRVSECTORSIZE); expandedclusters = gmalloc0((nbclusters + 7) / 8); ret = expandzeroclustersinl1(bs, s->l1table, s->l1size, &expandedclusters, &nbclusters); if (ret < 0) { goto fail; } /* Inactive L1 tables may point to active L2 tables - therefore it is * necessary to flush the L2 table cache before trying to access the L2 * tables pointed to by inactive L1 entries (else we might try to expand * zero clusters that have already been expanded); furthermore, it is also * necessary to empty the L2 table cache, since it may contain tables which * are now going to be modified directly on disk, bypassing the cache. * qcow2cacheempty() does both for us. */ ret = qcow2cacheempty(bs, s->l2tablecache); if (ret < 0) { goto fail; } for (i = 0; i < s->nbsnapshots; i++) { int l1sectors = (s->snapshots[i].l1size * sizeof(uint64t) + BDRVSECTORSIZE - 1) / BDRVSECTORSIZE; l1table = grealloc(l1table, l1sectors * BDRVSECTORSIZE); ret = bdrvread(bs->file, s->snapshots[i].l1tableoffset / BDRVSECTORSIZE, (void *)l1table, l1sectors); if (ret < 0) { goto fail; } for (j = 0; j < s->snapshots[i].l1size; j++) { be64tocpus(&l1table[j]); } ret = expandzeroclustersinl1(bs, l1table, s->snapshots[i].l1size, &expandedclusters, &nbclusters); if (ret < 0) { goto fail; } } ret = 0; fail: gfree(expandedclusters); gfree(l1table); return ret; } ", "target": 1}
{"func": "static int localopen2(FsContext *fsctx, const char *path, int flags, FsCred *credp) { int fd = -1; int err = -1; int serrno = 0; /* Determine the security model */ if (fsctx->fssm == SMMAPPED) { fd = open(rpath(fsctx, path), flags, SMLOCALMODEBITS); if (fd == -1) { return fd; } credp->fcmode = credp->fcmode|SIFREG; /* Set cleint credentials in xattr */ err = localsetxattr(rpath(fsctx, path), credp); if (err == -1) { serrno = errno; goto errend; } } else if (fsctx->fssm == SMPASSTHROUGH) { fd = open(rpath(fsctx, path), flags, credp->fcmode); if (fd == -1) { return fd; } err = localpostcreatepassthrough(fsctx, path, credp); if (err == -1) { serrno = errno; goto errend; } } return fd; errend: close(fd); remove(rpath(fsctx, path)); errno = serrno; return err; } ", "target": 1}
{"func": "static inline void yuv2packedXinC(SwsContext *c, int16t *lumFilter, int16t **lumSrc, int lumFilterSize, \t\t\t\t int16t *chrFilter, int16t **chrSrc, int chrFilterSize, \t\t\t\t uint8t *dest, int dstW, int y) { \tint i; \tswitch(c->dstFormat) \t{ \tcase PIXFMTBGR32: \tcase PIXFMTRGB32: \t\tYSCALEYUV2RGBXC(uint32t) \t\t\t((uint32t*)dest)[i2+0]= r[Y1] + g[Y1] + b[Y1]; \t\t\t((uint32t*)dest)[i2+1]= r[Y2] + g[Y2] + b[Y2]; \t\t} \t\tbreak; \tcase PIXFMTRGB24: \t\tYSCALEYUV2RGBXC(uint8t) \t\t\t((uint8t*)dest)[0]= r[Y1]; \t\t\t((uint8t*)dest)[1]= g[Y1]; \t\t\t((uint8t*)dest)[2]= b[Y1]; \t\t\t((uint8t*)dest)[3]= r[Y2]; \t\t\t((uint8t*)dest)[4]= g[Y2]; \t\t\t((uint8t*)dest)[5]= b[Y2]; \t\t\tdest+=6; \t\t} ", "target": 1}
{"func": "static int writepacket(AVFormatContext *s, AVPacket *pkt) { int ret, didsplit; if (s->outputtsoffset) { AVStream *st = s->streams[pkt->streamindex]; int64t offset = avrescaleq(s->outputtsoffset, AVTIMEBASEQ, st->timebase); if (pkt->dts != AVNOPTSVALUE) pkt->dts += offset; if (pkt->pts != AVNOPTSVALUE) pkt->pts += offset; } if (s->avoidnegativets > 0) { AVStream *st = s->streams[pkt->streamindex]; int64t offset = st->muxtsoffset; int64t ts = s->internal->avoidnegativetsusepts ? pkt->pts : pkt->dts; if (s->internal->offset == AVNOPTSVALUE && ts != AVNOPTSVALUE && (ts < 0 || s->avoidnegativets == AVFMTAVOIDNEGTSMAKEZERO)) { s->internal->offset = -ts; s->internal->offsettimebase = st->timebase; } if (s->internal->offset != AVNOPTSVALUE && !offset) { offset = st->muxtsoffset = avrescaleqrnd(s->internal->offset, s->internal->offsettimebase, st->timebase, AVROUNDUP); } if (pkt->dts != AVNOPTSVALUE) pkt->dts += offset; if (pkt->pts != AVNOPTSVALUE) pkt->pts += offset; if (s->internal->avoidnegativetsusepts) { if (pkt->pts != AVNOPTSVALUE && pkt->pts < 0) { avlog(s, AVLOGWARNING, \"failed to avoid negative \" \"pts %s in stream %d.\\n\" \"Try -avoidnegativets 1 as a possible workaround.\\n\", avts2str(pkt->dts), pkt->streamindex ); } } else { avassert2(pkt->dts == AVNOPTSVALUE || pkt->dts >= 0 || s->maxinterleavedelta > 0); if (pkt->dts != AVNOPTSVALUE && pkt->dts < 0) { avlog(s, AVLOGWARNING, \"Packets poorly interleaved, failed to avoid negative \" \"timestamp %s in stream %d.\\n\" \"Try -maxinterleavedelta 0 as a possible workaround.\\n\", avts2str(pkt->dts), pkt->streamindex ); } } } didsplit = avpacketsplitsidedata(pkt); if (!s->internal->headerwritten) { ret = s->internal->writeheaderret ? s->internal->writeheaderret : writeheaderinternal(s); if (ret < 0) goto fail; } if ((pkt->flags & AVPKTFLAGUNCODEDFRAME)) { AVFrame *frame = (AVFrame *)pkt->data; avassert0(pkt->size == UNCODEDFRAMEPACKETSIZE); ret = s->oformat->writeuncodedframe(s, pkt->streamindex, &frame, 0); avframefree(&frame); } else { ret = s->oformat->writepacket(s, pkt); } if (s->pb && ret >= 0) { if (s->flushpackets && s->flags & AVFMTFLAGFLUSHPACKETS) avioflush(s->pb); if (s->pb->error < 0) ret = s->pb->error; } fail: if (didsplit) avpacketmergesidedata(pkt); if (ret < 0) { pkt->pts = ptsbackup; pkt->dts = dtsbackup; } return ret; }", "target": 1}
{"func": "static void readsgiheader(ByteIOContext *f, SGIInfo *info) { info->magic = (unsigned short) getbe16(f); info->rle = getbyte(f); info->bytesperchannel = getbyte(f); info->dimension = (unsigned short)getbe16(f); info->xsize = (unsigned short) getbe16(f); info->ysize = (unsigned short) getbe16(f); info->zsize = (unsigned short) getbe16(f); #ifdef DEBUG printf(\"sgi header fields:\\n\"); printf(\" magic: %d\\n\", info->magic); printf(\" rle: %d\\n\", info->rle); printf(\" bpc: %d\\n\", info->bytesperchannel); printf(\" dim: %d\\n\", info->dimension); printf(\" xsize: %d\\n\", info->xsize); printf(\" ysize: %d\\n\", info->ysize); printf(\" zsize: %d\\n\", info->zsize); #endif return; }", "target": 1}
{"func": "static void pcinit1(ramaddrt ramsize, int vgaramsize, const char *bootdevice, DisplayState *ds, const char *kernelfilename, const char *kernelcmdline, const char *initrdfilename, int pcienabled, const char *cpumodel) { char buf[1024]; int ret, linuxboot, i; ramaddrt ramaddr, vgaramaddr, biosoffset, vgabiosoffset; ramaddrt below4gmemsize, above4gmemsize = 0; int biossize, isabiossize, vgabiossize; PCIBus *pcibus; int piix3devfn = -1; CPUState *env; qemuirq *cpuirq; qemuirq *i8259; int index; BlockDriverState *hd[MAXIDEBUS * MAXIDEDEVS]; BlockDriverState *fd[MAXFD]; if (ramsize >= 0xe0000000 ) { above4gmemsize = ramsize - 0xe0000000; below4gmemsize = 0xe0000000; } else { below4gmemsize = ramsize; } linuxboot = (kernelfilename != NULL); /* init CPUs */ if (cpumodel == NULL) { #ifdef TARGETX8664 cpumodel = \"qemu64\"; #else cpumodel = \"qemu32\"; #endif } for(i = 0; i < smpcpus; i++) { env = cpuinit(cpumodel); if (!env) { fprintf(stderr, \"Unable to find x86 CPU definition\\n\"); exit(1); } if (i != 0) env->halted = 1; if (smpcpus > 1) { /* XXX: enable it in all cases */ env->cpuidfeatures |= CPUIDAPIC; } qemuregisterreset(maincpureset, env); if (pcienabled) { apicinit(env); } } vmportinit(); /* allocate RAM */ ramaddr = qemuramalloc(0xa0000); cpuregisterphysicalmemory(0, 0xa0000, ramaddr); /* Allocate, even though we won't register, so we don't break the * physrambase + PA assumption. This range includes vga (0xa0000 - 0xc0000), * and some bios areas, which will be registered later */ ramaddr = qemuramalloc(0x100000 - 0xa0000); ramaddr = qemuramalloc(below4gmemsize - 0x100000); cpuregisterphysicalmemory(0x100000, below4gmemsize - 0x100000, ramaddr); /* above 4giga memory allocation */ if (above4gmemsize > 0) { ramaddr = qemuramalloc(above4gmemsize); cpuregisterphysicalmemory(0x100000000ULL, above4gmemsize, ramaddr); } /* allocate VGA RAM */ vgaramaddr = qemuramalloc(vgaramsize); /* BIOS load */ if (biosname == NULL) biosname = BIOSFILENAME; snprintf(buf, sizeof(buf), \"%s/%s\", biosdir, biosname); biossize = getimagesize(buf); if (biossize <= 0 || (biossize % 65536) != 0) { goto bioserror; } biosoffset = qemuramalloc(biossize); ret = loadimage(buf, physrambase + biosoffset); if (ret != biossize) { bioserror: fprintf(stderr, \"qemu: could not load PC BIOS '%s'\\n\", buf); exit(1); } if (cirrusvgaenabled || stdvgaenabled || vmsvgaenabled) { /* VGA BIOS load */ if (cirrusvgaenabled) { snprintf(buf, sizeof(buf), \"%s/%s\", biosdir, VGABIOSCIRRUSFILENAME); } else { snprintf(buf, sizeof(buf), \"%s/%s\", biosdir, VGABIOSFILENAME); } vgabiossize = getimagesize(buf); if (vgabiossize <= 0 || vgabiossize > 65536) goto vgabioserror; vgabiosoffset = qemuramalloc(65536); ret = loadimage(buf, physrambase + vgabiosoffset); if (ret != vgabiossize) { vgabioserror: fprintf(stderr, \"qemu: could not load VGA BIOS '%s'\\n\", buf); exit(1); } } /* setup basic memory access */ cpuregisterphysicalmemory(0xc0000, 0x10000, vgabiosoffset | IOMEMROM); /* map the last 128KB of the BIOS in ISA space */ isabiossize = biossize; if (isabiossize > (128 * 1024)) isabiossize = 128 * 1024; cpuregisterphysicalmemory(0x100000 - isabiossize, isabiossize, (biosoffset + biossize - isabiossize) | IOMEMROM); { ramaddrt optionromoffset; int size, offset; offset = 0; if (linuxboot) { optionromoffset = qemuramalloc(TARGETPAGESIZE); loadlinux(physrambase + optionromoffset, kernelfilename, initrdfilename, kernelcmdline); cpuregisterphysicalmemory(0xd0000, TARGETPAGESIZE, optionromoffset | IOMEMROM); offset = TARGETPAGESIZE; } for (i = 0; i < nboptionroms; i++) { size = getimagesize(optionrom[i]); if (size < 0) { fprintf(stderr, \"Could not load option rom '%s'\\n\", optionrom[i]); exit(1); } if (size > (0x10000 - offset)) goto optionromerror; optionromoffset = qemuramalloc(size); ret = loadimage(optionrom[i], physrambase + optionromoffset); if (ret != size) { optionromerror: fprintf(stderr, \"Too many option ROMS\\n\"); exit(1); } size = (size + 4095) & ~4095; cpuregisterphysicalmemory(0xd0000 + offset, size, optionromoffset | IOMEMROM); offset += size; } } /* map all the bios at the top of memory */ cpuregisterphysicalmemory((uint32t)(-biossize), biossize, biosoffset | IOMEMROM); bochsbiosinit(); cpuirq = qemuallocateirqs(picirqrequest, NULL, 1); i8259 = i8259init(cpuirq[0]); ferrirq = i8259[13]; if (pcienabled) { pcibus = i440fxinit(&i440fxstate, i8259); piix3devfn = piix3init(pcibus, -1); } else { pcibus = NULL; } /* init basic PC hardware */ registerioportwrite(0x80, 1, 1, ioport80write, NULL); registerioportwrite(0xf0, 1, 1, ioportF0write, NULL); if (cirrusvgaenabled) { if (pcienabled) { pcicirrusvgainit(pcibus, ds, physrambase + vgaramaddr, vgaramaddr, vgaramsize); } else { isacirrusvgainit(ds, physrambase + vgaramaddr, vgaramaddr, vgaramsize); } } else if (vmsvgaenabled) { if (pcienabled) pcivmsvgainit(pcibus, ds, physrambase + vgaramaddr, vgaramaddr, vgaramsize); else fprintf(stderr, \"%s: vmwarevga: no PCI bus\\n\", FUNCTION); } else if (stdvgaenabled) { if (pcienabled) { pcivgainit(pcibus, ds, physrambase + vgaramaddr, vgaramaddr, vgaramsize, 0, 0); } else { isavgainit(ds, physrambase + vgaramaddr, vgaramaddr, vgaramsize); } } rtcstate = rtcinit(0x70, i8259[8]); qemuregisterbootset(pcbootset, rtcstate); registerioportread(0x92, 1, 1, ioport92read, NULL); registerioportwrite(0x92, 1, 1, ioport92write, NULL); if (pcienabled) { ioapic = ioapicinit(); } pit = pitinit(0x40, i8259[0]); pcspkinit(pit); if (!nohpet) { hpetinit(i8259); } if (pcienabled) { picsetaltirqfunc(isapic, ioapicsetirq, ioapic); } for(i = 0; i < MAXSERIALPORTS; i++) { if (serialhds[i]) { serialinit(serialio[i], i8259[serialirq[i]], 115200, serialhds[i]); } } for(i = 0; i < MAXPARALLELPORTS; i++) { if (parallelhds[i]) { parallelinit(parallelio[i], i8259[parallelirq[i]], parallelhds[i]); } } for(i = 0; i < nbnics; i++) { NICInfo *nd = &ndtable[i]; if (!pcienabled || (nd->model && strcmp(nd->model, \"ne2kisa\") == 0)) pcinitne2kisa(nd, i8259); else pcinicinit(pcibus, nd, -1, \"ne2kpci\"); } if (drivegetmaxbus(IFIDE) >= MAXIDEBUS) { fprintf(stderr, \"qemu: too many IDE bus\\n\"); exit(1); } for(i = 0; i < MAXIDEBUS * MAXIDEDEVS; i++) { index = drivegetindex(IFIDE, i / MAXIDEDEVS, i % MAXIDEDEVS); \tif (index != -1) \t hd[i] = drivestable[index].bdrv; \telse \t hd[i] = NULL; } if (pcienabled) { pcipiix3ideinit(pcibus, hd, piix3devfn + 1, i8259); } else { for(i = 0; i < MAXIDEBUS; i++) { isaideinit(ideiobase[i], ideiobase2[i], i8259[ideirq[i]], \t hd[MAXIDEDEVS * i], hd[MAXIDEDEVS * i + 1]); } } i8042init(i8259[1], i8259[12], 0x60); DMAinit(0); #ifdef HASAUDIO audioinit(pcienabled ? pcibus : NULL, i8259); #endif for(i = 0; i < MAXFD; i++) { index = drivegetindex(IFFLOPPY, 0, i); \tif (index != -1) \t fd[i] = drivestable[index].bdrv; \telse \t fd[i] = NULL; } floppycontroller = fdctrlinit(i8259[6], 2, 0, 0x3f0, fd); cmosinit(below4gmemsize, above4gmemsize, bootdevice, hd); if (pcienabled && usbenabled) { usbuhcipiix3init(pcibus, piix3devfn + 2); } if (pcienabled && acpienabled) { uint8t *eeprombuf = qemumallocz(8 * 256); /* XXX: make this persistent */ i2cbus *smbus; /* TODO: Populate SPD eeprom data. */ smbus = piix4pminit(pcibus, piix3devfn + 3, 0xb100, i8259[9]); for (i = 0; i < 8; i++) { smbuseepromdeviceinit(smbus, 0x50 + i, eeprombuf + (i * 256)); } } if (i440fxstate) { i440fxinitmemorymappings(i440fxstate); } if (pcienabled) { \tint maxbus; int bus, unit; void *scsi; maxbus = drivegetmaxbus(IFSCSI); \tfor (bus = 0; bus <= maxbus; bus++) { scsi = lsiscsiinit(pcibus, -1); for (unit = 0; unit < LSIMAXDEVS; unit++) { \t index = drivegetindex(IFSCSI, bus, unit); \t\tif (index == -1) \t\t continue; \t\tlsiscsiattach(scsi, drivestable[index].bdrv, unit); \t } } } /* Add virtio block devices */ if (pcienabled) { int index; int unitid = 0; while ((index = drivegetindex(IFVIRTIO, 0, unitid)) != -1) { virtioblkinit(pcibus, drivestable[index].bdrv); unitid++; } } /* Add virtio balloon device */ if (pcienabled) virtioballooninit(pcibus); /* Add virtio console devices */ if (pcienabled) { for(i = 0; i < MAXVIRTIOCONSOLES; i++) { if (virtconhds[i]) virtioconsoleinit(pcibus, virtconhds[i]); } } } ", "target": 1}
{"func": "static int slirphostfwd(SlirpState *s, const char *redirstr, int legacyformat) { struct inaddr hostaddr = { .saddr = INADDRANY }; struct inaddr guestaddr = { .saddr = 0 }; int hostport, guestport; const char *p; char buf[256]; int isudp; char *end; p = redirstr; if (!p || getstrsep(buf, sizeof(buf), &p, ':') < 0) { goto failsyntax; } if (!strcmp(buf, \"tcp\") || buf[0] == '\\0') { isudp = 0; } else if (!strcmp(buf, \"udp\")) { isudp = 1; } else { goto failsyntax; } if (!legacyformat) { if (getstrsep(buf, sizeof(buf), &p, ':') < 0) { goto failsyntax; } if (buf[0] != '\\0' && !inetaton(buf, &hostaddr)) { goto failsyntax; } } if (getstrsep(buf, sizeof(buf), &p, legacyformat ? ':' : '-') < 0) { goto failsyntax; } hostport = strtol(buf, &end, 0); if (*end != '\\0' || hostport < 1 || hostport > 65535) { goto failsyntax; } if (getstrsep(buf, sizeof(buf), &p, ':') < 0) { goto failsyntax; } if (buf[0] != '\\0' && !inetaton(buf, &guestaddr)) { goto failsyntax; } guestport = strtol(p, &end, 0); if (*end != '\\0' || guestport < 1 || guestport > 65535) { goto failsyntax; } if (slirpaddhostfwd(s->slirp, isudp, hostaddr, hostport, guestaddr, guestport) < 0) { errorreport(\"could not set up host forwarding rule '%s'\", redirstr); return -1; } return 0; failsyntax: errorreport(\"invalid host forwarding rule '%s'\", redirstr); return -1; } ", "target": 0}
{"func": "int kvmarchputregisters(CPUState *cs, int level) { S390CPU *cpu = S390CPU(cs); CPUS390XState *env = &cpu->env; struct kvmsregs sregs; struct kvmregs regs; struct kvmfpu fpu; int r; int i; /* always save the PSW and the GPRS*/ cs->kvmrun->pswaddr = env->psw.addr; cs->kvmrun->pswmask = env->psw.mask; if (capsyncregs && cs->kvmrun->kvmvalidregs & KVMSYNCGPRS) { for (i = 0; i < 16; i++) { cs->kvmrun->s.regs.gprs[i] = env->regs[i]; cs->kvmrun->kvmdirtyregs |= KVMSYNCGPRS; } } else { for (i = 0; i < 16; i++) { regs.gprs[i] = env->regs[i]; } r = kvmvcpuioctl(cs, KVMSETREGS, &regs); if (r < 0) { return r; } } /* Floating point */ for (i = 0; i < 16; i++) { fpu.fprs[i] = env->fregs[i].ll; } fpu.fpc = env->fpc; r = kvmvcpuioctl(cs, KVMSETFPU, &fpu); if (r < 0) { return r; } /* Do we need to save more than that? */ if (level == KVMPUTRUNTIMESTATE) { return 0; } /* * These ONEREGS are not protected by a capability. As they are only * necessary for migration we just trace a possible error, but don't * return with an error return code. */ kvmsetonereg(cs, KVMREGS390CPUTIMER, &env->cputm); kvmsetonereg(cs, KVMREGS390CLOCKCOMP, &env->ckc); kvmsetonereg(cs, KVMREGS390TODPR, &env->todpr); kvmsetonereg(cs, KVMREGS390GBEA, &env->gbea); kvmsetonereg(cs, KVMREGS390PP, &env->pp); if (capasyncpf) { r = kvmsetonereg(cs, KVMREGS390PFTOKEN, &env->pfaulttoken); if (r < 0) { return r; } r = kvmsetonereg(cs, KVMREGS390PFCOMPARE, &env->pfaultcompare); if (r < 0) { return r; } r = kvmsetonereg(cs, KVMREGS390PFSELECT, &env->pfaultselect); if (r < 0) { return r; } } if (capsyncregs && cs->kvmrun->kvmvalidregs & KVMSYNCACRS && cs->kvmrun->kvmvalidregs & KVMSYNCCRS) { for (i = 0; i < 16; i++) { cs->kvmrun->s.regs.acrs[i] = env->aregs[i]; cs->kvmrun->s.regs.crs[i] = env->cregs[i]; } cs->kvmrun->kvmdirtyregs |= KVMSYNCACRS; cs->kvmrun->kvmdirtyregs |= KVMSYNCCRS; } else { for (i = 0; i < 16; i++) { sregs.acrs[i] = env->aregs[i]; sregs.crs[i] = env->cregs[i]; } r = kvmvcpuioctl(cs, KVMSETSREGS, &sregs); if (r < 0) { return r; } } /* Finally the prefix */ if (capsyncregs && cs->kvmrun->kvmvalidregs & KVMSYNCPREFIX) { cs->kvmrun->s.regs.prefix = env->psa; cs->kvmrun->kvmdirtyregs |= KVMSYNCPREFIX; } else { /* prefix is only supported via sync regs */ } return 0; } ", "target": 0}
{"func": "static void spaprhotplugreqevent(uint8t hpid, uint8t hpaction, sPAPRDRConnectorType drctype, uint32t drc) { sPAPRMachineState *spapr = SPAPRMACHINE(qdevgetmachine()); struct hplogfull *newhp; struct rtaserrorlog *hdr; struct rtaseventlogv6 *v6hdr; struct rtaseventlogv6maina *maina; struct rtaseventlogv6mainb *mainb; struct rtaseventlogv6hp *hp; newhp = gmalloc0(sizeof(struct hplogfull)); hdr = &newhp->hdr; v6hdr = &newhp->v6hdr; maina = &newhp->maina; mainb = &newhp->mainb; hp = &newhp->hp; hdr->summary = cputobe32(RTASLOGVERSION6 | RTASLOGSEVERITYEVENT | RTASLOGDISPOSITIONNOTRECOVERED | RTASLOGOPTIONALPARTPRESENT | RTASLOGINITIATORHOTPLUG | RTASLOGTYPEHOTPLUG); hdr->extendedlength = cputobe32(sizeof(*newhp) - sizeof(newhp->hdr)); spaprinitv6hdr(v6hdr); spaprinitmaina(maina, 3 /* Main-A, Main-B, HP */); mainb->hdr.sectionid = cputobe16(RTASLOGV6SECTIONIDMAINB); mainb->hdr.sectionlength = cputobe16(sizeof(*mainb)); mainb->subsystemid = 0x80; /* External environment */ mainb->eventseverity = 0x00; /* Informational / non-error */ mainb->eventsubtype = 0x00; /* Normal shutdown */ hp->hdr.sectionid = cputobe16(RTASLOGV6SECTIONIDHOTPLUG); hp->hdr.sectionlength = cputobe16(sizeof(*hp)); hp->hdr.sectionversion = 1; /* includes extended modifier */ hp->hotplugaction = hpaction; hp->hotplugidentifier = hpid; switch (drctype) { case SPAPRDRCONNECTORTYPEPCI: hp->hotplugtype = RTASLOGV6HPTYPEPCI; if (hp->hotplugaction == RTASLOGV6HPACTIONADD) { spaprhotplugsetsignalled(drc); } break; case SPAPRDRCONNECTORTYPELMB: hp->hotplugtype = RTASLOGV6HPTYPEMEMORY; break; case SPAPRDRCONNECTORTYPECPU: hp->hotplugtype = RTASLOGV6HPTYPECPU; break; default: /* we shouldn't be signaling hotplug events for resources * that don't support them */ gassert(false); return; } if (hpid == RTASLOGV6HPIDDRCCOUNT) { hp->drc.count = cputobe32(drc); } else if (hpid == RTASLOGV6HPIDDRCINDEX) { hp->drc.index = cputobe32(drc); } rtaseventlogqueue(RTASLOGTYPEHOTPLUG, newhp, true); qemuirqpulse(xicsgetqirq(spapr->xics, spapr->checkexceptionirq)); } ", "target": 0}
{"func": "static int usbhubbroadcastpacket(USBHubState *s, USBPacket *p) { USBHubPort *port; USBDevice *dev; int i, ret; for(i = 0; i < NUMPORTS; i++) { port = &s->ports[i]; dev = port->port.dev; if (dev && (port->wPortStatus & PORTSTATENABLE)) { ret = usbhandlepacket(dev, p); if (ret != USBRETNODEV) { return ret; } } } return USBRETNODEV; } ", "target": 0}
{"func": "BlockDriverAIOCB *bdrvaiowritev(BlockDriverState *bs, int64t sectornum, QEMUIOVector *qiov, int nbsectors, BlockDriverCompletionFunc *cb, void *opaque) { BlockDriver *drv = bs->drv; BlockDriverAIOCB *ret; if (!drv) return NULL; if (bs->readonly) return NULL; if (bdrvcheckrequest(bs, sectornum, nbsectors)) return NULL; if (bs->dirtytracking) { setdirtybitmap(bs, sectornum, nbsectors, 1); } ret = drv->bdrvaiowritev(bs, sectornum, qiov, nbsectors, cb, opaque); if (ret) { \t/* Update stats even though technically transfer has not happened. */ \tbs->wrbytes += (unsigned) nbsectors * BDRVSECTORSIZE; \tbs->wrops ++; } return ret; } ", "target": 1}
{"func": "avcold void ffdctinitx86(DCTContext *s) { int cpuflags = avgetcpuflags(); if (EXTERNALSSE(cpuflags)) s->dct32 = ffdct32floatsse; if (EXTERNALSSE2(cpuflags)) s->dct32 = ffdct32floatsse2; if (EXTERNALAVX(cpuflags)) s->dct32 = ffdct32floatavx; } ", "target": 0}
{"func": "static int msrledecodepal4(AVCodecContext *avctx, AVPicture *pic, GetByteContext *gb) { unsigned char rlecode; unsigned char extrabyte, oddpixel; unsigned char streambyte; unsigned int pixelptr = 0; int rowdec = pic->linesize[0]; int rowptr = (avctx->height - 1) * rowdec; int framesize = rowdec * avctx->height; int i; while (rowptr >= 0) { if (bytestream2getbytesleft(gb) <= 0) { avlog(avctx, AVLOGERROR, \"MS RLE: bytestream overrun, %d rows left\\n\", rowptr); return AVERRORINVALIDDATA; } rlecode = streambyte = bytestream2getbyteu(gb); if (rlecode == 0) { /* fetch the next byte to see how to handle escape code */ streambyte = bytestream2getbyte(gb); if (streambyte == 0) { /* line is done, goto the next one */ rowptr -= rowdec; pixelptr = 0; } else if (streambyte == 1) { /* decode is done */ return 0; } else if (streambyte == 2) { /* reposition frame decode coordinates */ streambyte = bytestream2getbyte(gb); pixelptr += streambyte; streambyte = bytestream2getbyte(gb); rowptr -= streambyte * rowdec; } else { // copy pixels from encoded stream oddpixel = streambyte & 1; rlecode = (streambyte + 1) / 2; extrabyte = rlecode & 0x01; if (rowptr + pixelptr + streambyte > framesize || bytestream2getbytesleft(gb) < rlecode) { avlog(avctx, AVLOGERROR, \"MS RLE: frame/stream ptr just went out of bounds (copy)\\n\"); return AVERRORINVALIDDATA; } for (i = 0; i < rlecode; i++) { if (pixelptr >= avctx->width) break; streambyte = bytestream2getbyteu(gb); pic->data[0][rowptr + pixelptr] = streambyte >> 4; pixelptr++; if (i + 1 == rlecode && oddpixel) break; if (pixelptr >= avctx->width) break; pic->data[0][rowptr + pixelptr] = streambyte & 0x0F; pixelptr++; } // if the RLE code is odd, skip a byte in the stream if (extrabyte) bytestream2skip(gb, 1); } } else { // decode a run of data if (rowptr + pixelptr + streambyte > framesize) { avlog(avctx, AVLOGERROR, \"MS RLE: frame ptr just went out of bounds (run)\\n\"); return AVERRORINVALIDDATA; } streambyte = bytestream2getbyte(gb); for (i = 0; i < rlecode; i++) { if (pixelptr >= avctx->width) break; if ((i & 1) == 0) pic->data[0][rowptr + pixelptr] = streambyte >> 4; else pic->data[0][rowptr + pixelptr] = streambyte & 0x0F; pixelptr++; } } } /* one last sanity check on the way out */ if (bytestream2getbytesleft(gb)) { avlog(avctx, AVLOGERROR, \"MS RLE: ended frame decode with %d bytes left over\\n\", bytestream2getbytesleft(gb)); return AVERRORINVALIDDATA; } return 0; } ", "target": 1}
{"func": "void HELPER(mvc)(CPUS390XState *env, uint32t l, uint64t dest, uint64t src) { int i = 0; int x = 0; uint32t l64 = (l + 1) / 8; HELPERLOG(\"%s l %d dest %\" PRIx64 \" src %\" PRIx64 \"\\n\", func, l, dest, src); #ifndef CONFIGUSERONLY if ((l > 32) && (src & TARGETPAGEMASK) == ((src + l) & TARGETPAGEMASK) && (dest & TARGETPAGEMASK) == ((dest + l) & TARGETPAGEMASK)) { if (dest == (src + 1)) { mvcfastmemset(env, l + 1, dest, cpuldubdata(env, src)); return; } else if ((src & TARGETPAGEMASK) != (dest & TARGETPAGEMASK)) { mvcfastmemmove(env, l + 1, dest, src); return; } } #else if (dest == (src + 1)) { memset(g2h(dest), cpuldubdata(env, src), l + 1); return; } else { memmove(g2h(dest), g2h(src), l + 1); return; } #endif /* handle the parts that fit into 8-byte loads/stores */ if (dest != (src + 1)) { for (i = 0; i < l64; i++) { cpustqdata(env, dest + x, cpuldqdata(env, src + x)); x += 8; } } /* slow version crossing pages with byte accesses */ for (i = x; i <= l; i++) { cpustbdata(env, dest + i, cpuldubdata(env, src + i)); } } ", "target": 1}
{"func": "static void testproperties(const char *path, bool recurse) { char *childpath; QDict *response, *tuple; QList *list; QListEntry *entry; gtestmessage(\"Obtaining properties of %s\", path); response = qmp(\"{ 'execute': 'qom-list',\" \" 'arguments': { 'path': %s } }\", path); gassert(response); if (!recurse) { return; } gassert(qdicthaskey(response, \"return\")); list = qobjecttoqlist(qdictget(response, \"return\")); QLISTFOREACHENTRY(list, entry) { tuple = qobjecttoqdict(qlistentryobj(entry)); bool ischild = strstart(qdictgetstr(tuple, \"type\"), \"child<\", NULL); bool islink = strstart(qdictgetstr(tuple, \"type\"), \"link<\", NULL); if (ischild || islink) { childpath = gstrdupprintf(\"%s/%s\", path, qdictgetstr(tuple, \"name\")); testproperties(childpath, ischild); gfree(childpath); } else { const char *prop = qdictgetstr(tuple, \"name\"); gtestmessage(\"Testing property %s.%s\", path, prop); response = qmp(\"{ 'execute': 'qom-get',\" \" 'arguments': { 'path': %s,\" \" 'property': %s } }\", path, prop); /* qom-get may fail but should not, e.g., segfault. */ gassert(response); } } } ", "target": 1}
{"func": "static int thpreadheader(AVFormatContext *s, AVFormatParameters *ap) { ThpDemuxContext *thp = s->privdata; AVStream *st; AVIOContext *pb = s->pb; int i; /* Read the file header. */ aviorb32(pb); /* Skip Magic. */ thp->version = aviorb32(pb); aviorb32(pb); /* Max buf size. */ aviorb32(pb); /* Max samples. */ thp->fps = avd2q(avint2float(aviorb32(pb)), INTMAX); thp->framecnt = aviorb32(pb); thp->firstframesz = aviorb32(pb); aviorb32(pb); /* Data size. */ thp->compoff = aviorb32(pb); aviorb32(pb); /* offsetDataOffset. */ thp->firstframe = aviorb32(pb); thp->lastframe = aviorb32(pb); thp->nextframesz = thp->firstframesz; thp->nextframe = thp->firstframe; /* Read the component structure. */ avioseek (pb, thp->compoff, SEEKSET); thp->compcount = aviorb32(pb); /* Read the list of component types. */ avioread(pb, thp->components, 16); for (i = 0; i < thp->compcount; i++) { if (thp->components[i] == 0) { if (thp->vst != 0) break; /* Video component. */ st = avformatnewstream(s, NULL); if (!st) return AVERROR(ENOMEM); /* The denominator and numerator are switched because 1/fps is required. */ avprivsetptsinfo(st, 64, thp->fps.den, thp->fps.num); st->codec->codectype = AVMEDIATYPEVIDEO; st->codec->codecid = CODECIDTHP; st->codec->codectag = 0; /* no fourcc */ st->codec->width = aviorb32(pb); st->codec->height = aviorb32(pb); st->codec->samplerate = avq2d(thp->fps); thp->vst = st; thp->videostreamindex = st->index; if (thp->version == 0x11000) aviorb32(pb); /* Unknown. */ } else if (thp->components[i] == 1) { if (thp->hasaudio != 0) break; /* Audio component. */ st = avformatnewstream(s, NULL); if (!st) return AVERROR(ENOMEM); st->codec->codectype = AVMEDIATYPEAUDIO; st->codec->codecid = CODECIDADPCMTHP; st->codec->codectag = 0; /* no fourcc */ st->codec->channels = aviorb32(pb); /* numChannels. */ st->codec->samplerate = aviorb32(pb); /* Frequency. */ avprivsetptsinfo(st, 64, 1, st->codec->samplerate); thp->audiostreamindex = st->index; thp->hasaudio = 1; } } return 0; } ", "target": 1}
{"func": "static int rdmaaddblock(RDMAContext *rdma, const char *blockname, void *hostaddr, ramaddrt blockoffset, uint64t length) { RDMALocalBlocks *local = &rdma->localramblocks; RDMALocalBlock *block; RDMALocalBlock *old = local->block; local->block = gmalloc0(sizeof(RDMALocalBlock) * (local->nbblocks + 1)); if (local->nbblocks) { int x; if (rdma->blockmap) { for (x = 0; x < local->nbblocks; x++) { ghashtableremove(rdma->blockmap, (void *)(uintptrt)old[x].offset); ghashtableinsert(rdma->blockmap, (void *)(uintptrt)old[x].offset, &local->block[x]); } } memcpy(local->block, old, sizeof(RDMALocalBlock) * local->nbblocks); gfree(old); } block = &local->block[local->nbblocks]; block->blockname = gstrdup(blockname); block->localhostaddr = hostaddr; block->offset = blockoffset; block->length = length; block->index = local->nbblocks; block->srcindex = ~0U; /* Filled in by the receipt of the block list */ block->nbchunks = ramchunkindex(hostaddr, hostaddr + length) + 1UL; block->transitbitmap = bitmapnew(block->nbchunks); bitmapclear(block->transitbitmap, 0, block->nbchunks); block->unregisterbitmap = bitmapnew(block->nbchunks); bitmapclear(block->unregisterbitmap, 0, block->nbchunks); block->remotekeys = gmalloc0(block->nbchunks * sizeof(uint32t)); block->isramblock = local->init ? false : true; if (rdma->blockmap) { ghashtableinsert(rdma->blockmap, (void *) blockoffset, block); } tracerdmaaddblock(blockname, local->nbblocks, (uintptrt) block->localhostaddr, block->offset, block->length, (uintptrt) (block->localhostaddr + block->length), BITSTOLONGS(block->nbchunks) * sizeof(unsigned long) * 8, block->nbchunks); local->nbblocks++; return 0; } ", "target": 1}
{"func": "processtxdesc(E1000State *s, struct e1000txdesc *dp) { uint32t txdlower = le32tocpu(dp->lower.data); uint32t dtype = txdlower & (E1000TXDCMDDEXT | E1000TXDDTYPD); unsigned int splitsize = txdlower & 0xffff, bytes, sz, op; unsigned int msh = 0xfffff, hdr = 0; uint64t addr; struct e1000contextdesc *xp = (struct e1000contextdesc *)dp; struct e1000tx *tp = &s->tx; if (dtype == E1000TXDCMDDEXT) {\t// context descriptor op = le32tocpu(xp->cmdandlength); tp->ipcss = xp->lowersetup.ipfields.ipcss; tp->ipcso = xp->lowersetup.ipfields.ipcso; tp->ipcse = le16tocpu(xp->lowersetup.ipfields.ipcse); tp->tucss = xp->uppersetup.tcpfields.tucss; tp->tucso = xp->uppersetup.tcpfields.tucso; tp->tucse = le16tocpu(xp->uppersetup.tcpfields.tucse); tp->paylen = op & 0xfffff; tp->hdrlen = xp->tcpsegsetup.fields.hdrlen; tp->mss = le16tocpu(xp->tcpsegsetup.fields.mss); tp->ip = (op & E1000TXDCMDIP) ? 1 : 0; tp->tcp = (op & E1000TXDCMDTCP) ? 1 : 0; tp->tse = (op & E1000TXDCMDTSE) ? 1 : 0; tp->tsoframes = 0; if (tp->tucso == 0) {\t// this is probably wrong DBGOUT(TXSUM, \"TCP/UDP: cso 0!\\n\"); tp->tucso = tp->tucss + (tp->tcp ? 16 : 6); } return; } else if (dtype == (E1000TXDCMDDEXT | E1000TXDDTYPD)) { // data descriptor if (tp->size == 0) { tp->sumneeded = le32tocpu(dp->upper.data) >> 8; } tp->cptse = ( txdlower & E1000TXDCMDTSE ) ? 1 : 0; } else { // legacy descriptor tp->cptse = 0; } if (vlanenabled(s) && isvlantxd(txdlower) && (tp->cptse || txdlower & E1000TXDCMDEOP)) { tp->vlanneeded = 1; cputobe16wu((uint16t *)(tp->vlanheader), le16tocpup((uint16t *)(s->macreg + VET))); cputobe16wu((uint16t *)(tp->vlanheader + 2), le16tocpu(dp->upper.fields.special)); } addr = le64tocpu(dp->bufferaddr); if (tp->tse && tp->cptse) { hdr = tp->hdrlen; msh = hdr + tp->mss; do { bytes = splitsize; if (tp->size + bytes > msh) bytes = msh - tp->size; bytes = MIN(sizeof(tp->data) - tp->size, bytes); pcidmaread(&s->dev, addr, tp->data + tp->size, bytes); if ((sz = tp->size + bytes) >= hdr && tp->size < hdr) memmove(tp->header, tp->data, hdr); tp->size = sz; addr += bytes; if (sz == msh) { xmitseg(s); memmove(tp->data, tp->header, hdr); tp->size = hdr; } } while (splitsize -= bytes); } else if (!tp->tse && tp->cptse) { // context descriptor TSE is not set, while data descriptor TSE is set DBGOUT(TXERR, \"TCP segmentaion Error\\n\"); } else { pcidmaread(&s->dev, addr, tp->data + tp->size, splitsize); tp->size += splitsize; } if (!(txdlower & E1000TXDCMDEOP)) return; if (!(tp->tse && tp->cptse && tp->size < hdr)) xmitseg(s); tp->tsoframes = 0; tp->sumneeded = 0; tp->vlanneeded = 0; tp->size = 0; tp->cptse = 0; }", "target": 1}
{"func": "static void virtioinputpcirealize(VirtIOPCIProxy *vpcidev, Error **errp) { VirtIOInputPCI *vinput = VIRTIOINPUTPCI(vpcidev); DeviceState *vdev = DEVICE(&vinput->vdev); qdevsetparentbus(vdev, BUS(&vpcidev->bus)); /* force virtio-1.0 */ vpcidev->flags &= ~VIRTIOPCIFLAGDISABLEMODERN; vpcidev->flags |= VIRTIOPCIFLAGDISABLELEGACY; objectpropertysetbool(OBJECT(vdev), true, \"realized\", errp); } ", "target": 0}
{"func": "static void testvisitoroutstring(TestOutputVisitorData *data, const void *unused) { char *string = (char *) \"Q E M U\"; Error *err = NULL; QObject *obj; visittypestr(data->ov, &string, NULL, &err); gassert(!err); obj = qmpoutputgetqobject(data->qov); gassert(obj != NULL); gassert(qobjecttype(obj) == QTYPEQSTRING); gassertcmpstr(qstringgetstr(qobjecttoqstring(obj)), ==, string); qobjectdecref(obj); } ", "target": 0}
{"func": "static void pcmachinesetvmport(Object *obj, bool value, Error **errp) { PCMachineState *pcms = PCMACHINE(obj); pcms->vmport = value; } ", "target": 0}
{"func": "static int movreadtrak(MOVContext *c, AVIOContext *pb, MOVAtom atom) { AVStream *st; MOVStreamContext *sc; int ret; st = avformatnewstream(c->fc, NULL); if (!st) return AVERROR(ENOMEM); st->id = c->fc->nbstreams; sc = avmallocz(sizeof(MOVStreamContext)); if (!sc) return AVERROR(ENOMEM); st->privdata = sc; st->codec->codectype = AVMEDIATYPEDATA; sc->ffindex = st->index; if ((ret = movreaddefault(c, pb, atom)) < 0) return ret; /* sanity checks */ if (sc->chunkcount && (!sc->sttscount || !sc->stsccount || (!sc->samplesize && !sc->samplecount))) { avlog(c->fc, AVLOGERROR, \"stream %d, missing mandatory atoms, broken header\\n\", st->index); return 0; } fixtimescale(c, sc); avprivsetptsinfo(st, 64, 1, sc->timescale); movbuildindex(c, st); if (sc->drefid-1 < sc->drefscount && sc->drefs[sc->drefid-1].path) { MOVDref *dref = &sc->drefs[sc->drefid - 1]; if (movopendref(&sc->pb, c->fc->filename, dref, &c->fc->interruptcallback, c->useabsolutepath, c->fc) < 0) avlog(c->fc, AVLOGERROR, \"stream %d, error opening alias: path='%s', dir='%s', \" \"filename='%s', volume='%s', nlvlfrom=%d, nlvlto=%d\\n\", st->index, dref->path, dref->dir, dref->filename, dref->volume, dref->nlvlfrom, dref->nlvlto); } else { sc->pb = c->fc->pb; sc->pbiscopied = 1; } if (st->codec->codectype == AVMEDIATYPEVIDEO) { if (!st->sampleaspectratio.num && (st->codec->width != sc->width || st->codec->height != sc->height)) { st->sampleaspectratio = avd2q(((double)st->codec->height * sc->width) / ((double)st->codec->width * sc->height), INTMAX); } #if FFAPIRFRAMERATE if (sc->sttscount == 1 || (sc->sttscount == 2 && sc->sttsdata[1].count == 1)) avreduce(&st->rframerate.num, &st->rframerate.den, sc->timescale, sc->sttsdata[0].duration, INTMAX); #endif } // done for ai5q, ai52, ai55, ai1q, ai12 and ai15. if (!st->codec->extradatasize && st->codec->codecid == AVCODECIDH264 && TAGISAVCI(st->codec->codectag)) { ret = ffgenerateavciextradata(st); if (ret < 0) return ret; } switch (st->codec->codecid) { #if CONFIGH261DECODER case AVCODECIDH261: #endif #if CONFIGH263DECODER case AVCODECIDH263: #endif #if CONFIGMPEG4DECODER case AVCODECIDMPEG4: #endif st->codec->width = 0; /* let decoder init width/height */ st->codec->height= 0; break; } /* Do not need those anymore. */ avfreep(&sc->chunkoffsets); avfreep(&sc->stscdata); avfreep(&sc->samplesizes); avfreep(&sc->keyframes); avfreep(&sc->sttsdata); avfreep(&sc->stpsdata); avfreep(&sc->elstdata); avfreep(&sc->rapgroup); return 0; } ", "target": 1}
{"func": "static int bufferempty(Buffer *buffer) { return buffer->offset == 0; } ", "target": 1}
{"func": "static gboolean ptychrtimer(gpointer opaque) { struct CharDriverState *chr = opaque; PtyCharDriver *s = chr->opaque; if (s->connected) { goto out; } /* Next poll ... */ ptychrupdatereadhandler(chr); out: s->timertag = 0; return FALSE; } ", "target": 1}
{"func": "void h263encodeinit(MpegEncContext *s) { static int done = 0; if (!done) { done = 1; initunidctab(); initrl(&rlinter); initrl(&rlintra); initrl(&rlintraaic); initunimpeg4rltab(&rlintra, unimpeg4intrarlbits, unimpeg4intrarllen); initunimpeg4rltab(&rlinter, unimpeg4interrlbits, unimpeg4interrllen); initunih263rltab(&rlintraaic, NULL, unih263intraaicrllen); initunih263rltab(&rlinter , NULL, unih263interrllen); initmvpenaltyandfcode(s); } s->me.mvpenalty= mvpenalty; //FIXME exact table for msmpeg4 & h263p s->intraacvlclength =s->interacvlclength = unih263interrllen; s->intraacvlclastlength=s->interacvlclastlength= unih263interrllen + 128*64; if(s->h263aic){ s->intraacvlclength = unih263intraaicrllen; s->intraacvlclastlength= unih263intraaicrllen + 128*64; } s->acesclength= 7+1+6+8; // use fcodes >1 only for mpeg4 & h263 & h263p FIXME switch(s->codecid){ case CODECIDMPEG4: s->fcodetab= fcodetab; s->minqcoeff= -2048; s->maxqcoeff= 2047; s->intraacvlclength = unimpeg4intrarllen; s->intraacvlclastlength= unimpeg4intrarllen + 128*64; s->interacvlclength = unimpeg4interrllen; s->interacvlclastlength= unimpeg4interrllen + 128*64; s->lumadcvlclength= uniDCtablumlen; s->chromadcvlclength= uniDCtabchromlen; s->acesclength= 7+2+1+6+1+12+1; s->ydcscaletable= ffmpeg4ydcscaletable; s->cdcscaletable= ffmpeg4cdcscaletable; if(s->flags & CODECFLAGGLOBALHEADER){ s->avctx->extradata= avmalloc(1024); initputbits(&s->pb, s->avctx->extradata, 1024); mpeg4encodevisualobjectheader(s); mpeg4encodevolheader(s, 0, 0); // ffmpeg4stuffing(&s->pb); ? flushputbits(&s->pb); s->avctx->extradatasize= (putbitscount(&s->pb)+7)>>3; } break; case CODECIDH263P: if(s->umvplus) s->fcodetab= umvfcodetab; if(s->modifiedquant){ s->minqcoeff= -2047; s->maxqcoeff= 2047; }else{ s->minqcoeff= -127; s->maxqcoeff= 127; } break; //Note for mpeg4 & h263 the dc-scale table will be set per frame as needed later case CODECIDFLV1: if (s->h263flv > 1) { s->minqcoeff= -1023; s->maxqcoeff= 1023; } else { s->minqcoeff= -127; s->maxqcoeff= 127; } s->ydcscaletable= s->cdcscaletable= ffmpeg1dcscaletable; break; default: //nothing needed default table allready set in mpegvideo.c s->minqcoeff= -127; s->maxqcoeff= 127; s->ydcscaletable= s->cdcscaletable= ffmpeg1dcscaletable; } } ", "target": 1}
{"func": "static int checkoflagcopied(BlockDriverState *bs, BdrvCheckResult *res, BdrvCheckMode fix) { BDRVQcow2State *s = bs->opaque; uint64t *l2table = qemublockalign(bs, s->clustersize); int ret; uint64t refcount; int i, j; for (i = 0; i < s->l1size; i++) { uint64t l1entry = s->l1table[i]; uint64t l2offset = l1entry & L1EOFFSETMASK; bool l2dirty = false; if (!l2offset) { continue; } ret = qcow2getrefcount(bs, l2offset >> s->clusterbits, &refcount); if (ret < 0) { /* don't print message nor increment checkerrors */ continue; } if ((refcount == 1) != ((l1entry & QCOWOFLAGCOPIED) != 0)) { fprintf(stderr, \"%s OFLAGCOPIED L2 cluster: l1index=%d \" \"l1entry=%\" PRIx64 \" refcount=%\" PRIu64 \"\\n\", fix & BDRVFIXERRORS ? \"Repairing\" : \"ERROR\", i, l1entry, refcount); if (fix & BDRVFIXERRORS) { s->l1table[i] = refcount == 1 ? l1entry | QCOWOFLAGCOPIED : l1entry & ~QCOWOFLAGCOPIED; ret = qcow2writel1entry(bs, i); if (ret < 0) { res->checkerrors++; goto fail; } res->corruptionsfixed++; } else { res->corruptions++; } } ret = bdrvpread(bs->file, l2offset, l2table, s->l2size * sizeof(uint64t)); if (ret < 0) { fprintf(stderr, \"ERROR: Could not read L2 table: %s\\n\", strerror(-ret)); res->checkerrors++; goto fail; } for (j = 0; j < s->l2size; j++) { uint64t l2entry = be64tocpu(l2table[j]); uint64t dataoffset = l2entry & L2EOFFSETMASK; QCow2ClusterType clustertype = qcow2getclustertype(l2entry); if ((clustertype == QCOW2CLUSTERNORMAL) || ((clustertype == QCOW2CLUSTERZERO) && (dataoffset != 0))) { ret = qcow2getrefcount(bs, dataoffset >> s->clusterbits, &refcount); if (ret < 0) { /* don't print message nor increment checkerrors */ continue; } if ((refcount == 1) != ((l2entry & QCOWOFLAGCOPIED) != 0)) { fprintf(stderr, \"%s OFLAGCOPIED data cluster: \" \"l2entry=%\" PRIx64 \" refcount=%\" PRIu64 \"\\n\", fix & BDRVFIXERRORS ? \"Repairing\" : \"ERROR\", l2entry, refcount); if (fix & BDRVFIXERRORS) { l2table[j] = cputobe64(refcount == 1 ? l2entry | QCOWOFLAGCOPIED : l2entry & ~QCOWOFLAGCOPIED); l2dirty = true; res->corruptionsfixed++; } else { res->corruptions++; } } } } if (l2dirty) { ret = qcow2prewriteoverlapcheck(bs, QCOW2OLACTIVEL2, l2offset, s->clustersize); if (ret < 0) { fprintf(stderr, \"ERROR: Could not write L2 table; metadata \" \"overlap check failed: %s\\n\", strerror(-ret)); res->checkerrors++; goto fail; } ret = bdrvpwrite(bs->file, l2offset, l2table, s->clustersize); if (ret < 0) { fprintf(stderr, \"ERROR: Could not write L2 table: %s\\n\", strerror(-ret)); res->checkerrors++; goto fail; } } } ret = 0; fail: qemuvfree(l2table); return ret; } ", "target": 0}
{"func": "static void mainstonecommoninit(MemoryRegion *addressspacemem, MachineState *machine, enum mainstonemodele model, int armid) { uint32t sectorlen = 256 * 1024; hwaddr mainstoneflashbase[] = { MSTFLASH0, MSTFLASH1 }; PXA2xxState *mpu; DeviceState *mstirq; DriveInfo *dinfo; int i; int be; MemoryRegion *rom = gnew(MemoryRegion, 1); const char *cpumodel = machine->cpumodel; if (!cpumodel) cpumodel = \"pxa270-c5\"; /* Setup CPU & memory */ mpu = pxa270init(addressspacemem, mainstonebinfo.ramsize, cpumodel); memoryregioninitram(rom, NULL, \"mainstone.rom\", MAINSTONEROM, &errorabort); vmstateregisterramglobal(rom); memoryregionsetreadonly(rom, true); memoryregionaddsubregion(addressspacemem, 0, rom); #ifdef TARGETWORDSBIGENDIAN be = 1; #else be = 0; #endif /* There are two 32MiB flash devices on the board */ for (i = 0; i < 2; i ++) { dinfo = driveget(IFPFLASH, 0, i); if (!dinfo) { if (qtestenabled()) { break; } fprintf(stderr, \"Two flash images must be given with the \" \"'pflash' parameter\\n\"); exit(1); } if (!pflashcfi01register(mainstoneflashbase[i], NULL, i ? \"mainstone.flash1\" : \"mainstone.flash0\", MAINSTONEFLASH, blkbs(blkbylegacydinfo(dinfo)), sectorlen, MAINSTONEFLASH / sectorlen, 4, 0, 0, 0, 0, be)) { fprintf(stderr, \"qemu: Error registering flash memory.\\n\"); exit(1); } } mstirq = sysbuscreatesimple(\"mainstone-fpga\", MSTFPGAPHYS, qdevgetgpioin(mpu->gpio, 0)); /* setup keypad */ pxa27xregisterkeypad(mpu->kp, map, 0xe0); /* MMC/SD host */ pxa2xxmmcihandlers(mpu->mmc, NULL, qdevgetgpioin(mstirq, MMCIRQ)); pxa2xxpcmciasetirqcb(mpu->pcmcia[0], qdevgetgpioin(mstirq, S0IRQ), qdevgetgpioin(mstirq, S0CDIRQ)); pxa2xxpcmciasetirqcb(mpu->pcmcia[1], qdevgetgpioin(mstirq, S1IRQ), qdevgetgpioin(mstirq, S1CDIRQ)); smc91c111init(&ndtable[0], MSTETHPHYS, qdevgetgpioin(mstirq, ETHERNETIRQ)); mainstonebinfo.kernelfilename = machine->kernelfilename; mainstonebinfo.kernelcmdline = machine->kernelcmdline; mainstonebinfo.initrdfilename = machine->initrdfilename; mainstonebinfo.boardid = armid; armloadkernel(mpu->cpu, &mainstonebinfo); } ", "target": 0}
{"func": "static inline void RENAME(vu9tovu12)(const uint8t *src1, const uint8t *src2, \t\t\tuint8t *dst1, uint8t *dst2, \t\t\tlong width, long height, \t\t\tlong srcStride1, long srcStride2, \t\t\tlong dstStride1, long dstStride2) { long y,x,w,h; w=width/2; h=height/2; #ifdef HAVEMMX asm volatile( \tPREFETCH\" %0\\n\\t\" \tPREFETCH\" %1\\n\\t\" \t::\"m\"(*(src1+srcStride1)),\"m\"(*(src2+srcStride2)):\"memory\"); #endif for(y=0;y<h;y++){ \tconst uint8t* s1=src1+srcStride1*(y>>1); \tuint8t* d=dst1+dstStride1*y; \tx=0; #ifdef HAVEMMX \tfor(;x<w-31;x+=32) \t{ \t asm volatile( \t\tPREFETCH\" 32%1\\n\\t\" \t \"movq\t%1, %%mm0\\n\\t\" \t \"movq\t8%1, %%mm2\\n\\t\" \t \"movq\t16%1, %%mm4\\n\\t\" \t \"movq\t24%1, %%mm6\\n\\t\" \t \"movq\t%%mm0, %%mm1\\n\\t\" \t \"movq\t%%mm2, %%mm3\\n\\t\" \t \"movq\t%%mm4, %%mm5\\n\\t\" \t \"movq\t%%mm6, %%mm7\\n\\t\" \t\t\"punpcklbw %%mm0, %%mm0\\n\\t\" \t\t\"punpckhbw %%mm1, %%mm1\\n\\t\" \t\t\"punpcklbw %%mm2, %%mm2\\n\\t\" \t\t\"punpckhbw %%mm3, %%mm3\\n\\t\" \t\t\"punpcklbw %%mm4, %%mm4\\n\\t\" \t\t\"punpckhbw %%mm5, %%mm5\\n\\t\" \t\t\"punpcklbw %%mm6, %%mm6\\n\\t\" \t\t\"punpckhbw %%mm7, %%mm7\\n\\t\" \t\tMOVNTQ\"\t%%mm0, %0\\n\\t\" \t\tMOVNTQ\"\t%%mm1, 8%0\\n\\t\" \t\tMOVNTQ\"\t%%mm2, 16%0\\n\\t\" \t\tMOVNTQ\"\t%%mm3, 24%0\\n\\t\" \t\tMOVNTQ\"\t%%mm4, 32%0\\n\\t\" \t\tMOVNTQ\"\t%%mm5, 40%0\\n\\t\" \t\tMOVNTQ\"\t%%mm6, 48%0\\n\\t\" \t\tMOVNTQ\"\t%%mm7, 56%0\" \t\t:\"=m\"(d[2*x]) \t\t:\"m\"(s1[x]) \t\t:\"memory\"); \t} #endif \tfor(;x<w;x++) d[2*x]=d[2*x+1]=s1[x]; } for(y=0;y<h;y++){ \tconst uint8t* s2=src2+srcStride2*(y>>1); \tuint8t* d=dst2+dstStride2*y; \tx=0; #ifdef HAVEMMX \tfor(;x<w-31;x+=32) \t{ \t asm volatile( \t\tPREFETCH\" 32%1\\n\\t\" \t \"movq\t%1, %%mm0\\n\\t\" \t \"movq\t8%1, %%mm2\\n\\t\" \t \"movq\t16%1, %%mm4\\n\\t\" \t \"movq\t24%1, %%mm6\\n\\t\" \t \"movq\t%%mm0, %%mm1\\n\\t\" \t \"movq\t%%mm2, %%mm3\\n\\t\" \t \"movq\t%%mm4, %%mm5\\n\\t\" \t \"movq\t%%mm6, %%mm7\\n\\t\" \t\t\"punpcklbw %%mm0, %%mm0\\n\\t\" \t\t\"punpckhbw %%mm1, %%mm1\\n\\t\" \t\t\"punpcklbw %%mm2, %%mm2\\n\\t\" \t\t\"punpckhbw %%mm3, %%mm3\\n\\t\" \t\t\"punpcklbw %%mm4, %%mm4\\n\\t\" \t\t\"punpckhbw %%mm5, %%mm5\\n\\t\" \t\t\"punpcklbw %%mm6, %%mm6\\n\\t\" \t\t\"punpckhbw %%mm7, %%mm7\\n\\t\" \t\tMOVNTQ\"\t%%mm0, %0\\n\\t\" \t\tMOVNTQ\"\t%%mm1, 8%0\\n\\t\" \t\tMOVNTQ\"\t%%mm2, 16%0\\n\\t\" \t\tMOVNTQ\"\t%%mm3, 24%0\\n\\t\" \t\tMOVNTQ\"\t%%mm4, 32%0\\n\\t\" \t\tMOVNTQ\"\t%%mm5, 40%0\\n\\t\" \t\tMOVNTQ\"\t%%mm6, 48%0\\n\\t\" \t\tMOVNTQ\"\t%%mm7, 56%0\" \t\t:\"=m\"(d[2*x]) \t\t:\"m\"(s2[x]) \t\t:\"memory\"); \t} #endif \tfor(;x<w;x++) d[2*x]=d[2*x+1]=s2[x]; } #ifdef HAVEMMX \tasm( \t\tEMMS\" \\n\\t\" \t\tSFENCE\" \\n\\t\" \t\t::: \"memory\" \t\t); #endif } ", "target": 1}
{"func": "static void puv3init(MachineState *machine) { ramaddrt ramsize = machine->ramsize; const char *cpumodel = machine->cpumodel; const char *kernelfilename = machine->kernelfilename; const char *initrdfilename = machine->initrdfilename; CPUUniCore32State *env; UniCore32CPU *cpu; if (initrdfilename) { errorreport(\"Please use kernel built-in initramdisk\"); exit(1); } if (!cpumodel) { cpumodel = \"UniCore-II\"; } cpu = UNICORE32CPU(cpugenericinit(TYPEUNICORE32CPU, cpumodel)); if (!cpu) { errorreport(\"Unable to find CPU definition\"); exit(1); } env = &cpu->env; puv3socinit(env); puv3boardinit(env, ramsize); puv3loadkernel(kernelfilename); } ", "target": 1}
{"func": "static int outputdatainternal(MLPDecodeContext *m, unsigned int substr, uint8t *data, unsigned int *datasize, int is32) { SubStream *s = &m->substream[substr]; unsigned int i, outch = 0; int32t *data32 = (int32t*) data; int16t *data16 = (int16t*) data; if (*datasize < (s->maxchannel + 1) * s->blockpos * (is32 ? 4 : 2)) return -1; for (i = 0; i < s->blockpos; i++) { for (outch = 0; outch <= s->maxmatrixchannel; outch++) { int match = s->chassign[outch]; int32t sample = m->samplebuffer[i][match] << s->outputshift[match]; s->losslesscheckdata ^= (sample & 0xffffff) << match; if (is32) *data32++ = sample << 8; else *data16++ = sample >> 8; } } *datasize = i * outch * (is32 ? 4 : 2); return 0; } ", "target": 0}
{"func": "static int qcow2readextensions(BlockDriverState *bs, uint64t startoffset, uint64t endoffset, void **pfeaturetable, Error **errp) { BDRVQcowState *s = bs->opaque; QCowExtension ext; uint64t offset; int ret; #ifdef DEBUGEXT printf(\"qcow2readextensions: start=%ld end=%ld\\n\", startoffset, endoffset); #endif offset = startoffset; while (offset < endoffset) { #ifdef DEBUGEXT /* Sanity check */ if (offset > s->clustersize) printf(\"qcow2readextension: suspicious offset %lu\\n\", offset); printf(\"attempting to read extended header in offset %lu\\n\", offset); #endif ret = bdrvpread(bs->file, offset, &ext, sizeof(ext)); if (ret < 0) { errorsetgerrno(errp, -ret, \"qcow2readextension: ERROR: \" \"pread fail from offset %\" PRIu64, offset); return 1; } be32tocpus(&ext.magic); be32tocpus(&ext.len); offset += sizeof(ext); #ifdef DEBUGEXT printf(\"ext.magic = 0x%x\\n\", ext.magic); #endif if (ext.len > endoffset - offset) { errorsetg(errp, \"Header extension too large\"); return -EINVAL; } switch (ext.magic) { case QCOW2EXTMAGICEND: return 0; case QCOW2EXTMAGICBACKINGFORMAT: if (ext.len >= sizeof(bs->backingformat)) { errorsetg(errp, \"ERROR: extbackingformat: len=%\" PRIu32 \" too large (>=%zu)\", ext.len, sizeof(bs->backingformat)); return 2; } ret = bdrvpread(bs->file, offset, bs->backingformat, ext.len); if (ret < 0) { errorsetgerrno(errp, -ret, \"ERROR: extbackingformat: \" \"Could not read format name\"); return 3; } bs->backingformat[ext.len] = '\\0'; #ifdef DEBUGEXT printf(\"Qcow2: Got format extension %s\\n\", bs->backingformat); #endif break; case QCOW2EXTMAGICFEATURETABLE: if (pfeaturetable != NULL) { void* featuretable = gmalloc0(ext.len + 2 * sizeof(Qcow2Feature)); ret = bdrvpread(bs->file, offset , featuretable, ext.len); if (ret < 0) { errorsetgerrno(errp, -ret, \"ERROR: extfeaturetable: \" \"Could not read table\"); return ret; } *pfeaturetable = featuretable; } break; default: /* unknown magic - save it in case we need to rewrite the header */ { Qcow2UnknownHeaderExtension *uext; uext = gmalloc0(sizeof(*uext) + ext.len); uext->magic = ext.magic; uext->len = ext.len; QLISTINSERTHEAD(&s->unknownheaderext, uext, next); ret = bdrvpread(bs->file, offset , uext->data, uext->len); if (ret < 0) { errorsetgerrno(errp, -ret, \"ERROR: unknown extension: \" \"Could not read data\"); return ret; } } break; } offset += ((ext.len + 7) & ~7); } return 0; } ", "target": 1}
{"func": "inline static void RENAME(hcscale)(SwsContext *c, uint16t *dst, int dstWidth, const uint8t *src1, const uint8t *src2, int srcW, int xInc, const int16t *hChrFilter, const int16t *hChrFilterPos, int hChrFilterSize, uint8t *formatConvBuffer, uint32t *pal) { src1 += c->chrSrcOffset; src2 += c->chrSrcOffset; if (c->chrToYV12) { c->chrToYV12(formatConvBuffer, formatConvBuffer+VOFW, src1, src2, srcW, pal); src1= formatConvBuffer; src2= formatConvBuffer+VOFW; } if (!c->hcscalefast) { c->hScale(dst , dstWidth, src1, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize); c->hScale(dst+VOFW, dstWidth, src2, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize); } else { // fast bilinear upscale / crap downscale c->hcscalefast(c, dst, dstWidth, src1, src2, srcW, xInc); } if (c->chrConvertRange) c->chrConvertRange(dst, dstWidth); } ", "target": 1}
{"func": "void pl011init(uint32t base, qemuirq irq, CharDriverState *chr) { int iomemtype; pl011state *s; s = (pl011state *)qemumallocz(sizeof(pl011state)); iomemtype = cpuregisteriomemory(0, pl011readfn, pl011writefn, s); cpuregisterphysicalmemory(base, 0x00000fff, iomemtype); s->base = base; s->irq = irq; s->chr = chr; s->readtrigger = 1; s->ifl = 0x12; s->cr = 0x300; s->flags = 0x90; if (chr){ qemuchraddhandlers(chr, pl011canrecieve, pl011recieve, pl011event, s); } /* ??? Save/restore. */ } ", "target": 1}
{"func": "static void sprreadxer (DisasContext *ctx, int gprn, int sprn) { genreadxer(cpugpr[gprn]); } ", "target": 1}
{"func": "static int cpuloadold(QEMUFile *f, void *opaque, int versionid) { PowerPCCPU *cpu = opaque; CPUPPCState *env = &cpu->env; unsigned int i, j; targetulong sdr1; uint32t fpscr; targetulong xer; for (i = 0; i < 32; i++) qemugetbetls(f, &env->gpr[i]); #if !defined(TARGETPPC64) for (i = 0; i < 32; i++) qemugetbetls(f, &env->gprh[i]); #endif qemugetbetls(f, &env->lr); qemugetbetls(f, &env->ctr); for (i = 0; i < 8; i++) qemugetbe32s(f, &env->crf[i]); qemugetbetls(f, &xer); cpuwritexer(env, xer); qemugetbetls(f, &env->reserveaddr); qemugetbetls(f, &env->msr); for (i = 0; i < 4; i++) qemugetbetls(f, &env->tgpr[i]); for (i = 0; i < 32; i++) { union { float64 d; uint64t l; } u; u.l = qemugetbe64(f); env->fpr[i] = u.d; } qemugetbe32s(f, &fpscr); env->fpscr = fpscr; qemugetsbe32s(f, &env->accesstype); #if defined(TARGETPPC64) qemugetbetls(f, &env->spr[SPRASR]); qemugetsbe32s(f, &env->slbnr); #endif qemugetbetls(f, &sdr1); for (i = 0; i < 32; i++) qemugetbetls(f, &env->sr[i]); for (i = 0; i < 2; i++) for (j = 0; j < 8; j++) qemugetbetls(f, &env->DBAT[i][j]); for (i = 0; i < 2; i++) for (j = 0; j < 8; j++) qemugetbetls(f, &env->IBAT[i][j]); qemugetsbe32s(f, &env->nbtlb); qemugetsbe32s(f, &env->tlbperway); qemugetsbe32s(f, &env->nbways); qemugetsbe32s(f, &env->lastway); qemugetsbe32s(f, &env->idtlbs); qemugetsbe32s(f, &env->nbpids); if (env->tlb.tlb6) { // XXX assumes 6xx for (i = 0; i < env->nbtlb; i++) { qemugetbetls(f, &env->tlb.tlb6[i].pte0); qemugetbetls(f, &env->tlb.tlb6[i].pte1); qemugetbetls(f, &env->tlb.tlb6[i].EPN); } } for (i = 0; i < 4; i++) qemugetbetls(f, &env->pb[i]); for (i = 0; i < 1024; i++) qemugetbetls(f, &env->spr[i]); ppcstoresdr1(env, sdr1); qemugetbe32s(f, &env->vscr); qemugetbe64s(f, &env->speacc); qemugetbe32s(f, &env->spefscr); qemugetbetls(f, &env->msrmask); qemugetbe32s(f, &env->flags); qemugetsbe32s(f, &env->errorcode); qemugetbe32s(f, &env->pendinginterrupts); qemugetbe32s(f, &env->irqinputstate); for (i = 0; i < POWERPCEXCPNB; i++) qemugetbetls(f, &env->excpvectors[i]); qemugetbetls(f, &env->excpprefix); qemugetbetls(f, &env->ivormask); qemugetbetls(f, &env->ivprmask); qemugetbetls(f, &env->hresetvector); qemugetbetls(f, &env->nip); qemugetbetls(f, &env->hflags); qemugetbetls(f, &env->hflagsnmsr); qemugetsbe32s(f, &env->mmuidx); qemugetsbe32(f); /* Discard unused powermode */ return 0; } ", "target": 1}
{"func": "static void testqemustrtoulinvalid(void) { const char *str = \" xxxx \\t abc\"; char f = 'X'; const char *endptr = &f; unsigned long res = 999; int err; err = qemustrtoul(str, &endptr, 0, &res); gassertcmpint(err, ==, 0); gassert(endptr == str); } ", "target": 1}
{"func": "static void avclumamidvqrt4wmsa(const uint8t *src, int32t srcstride, uint8t *dst, int32t dststride, int32t height, uint8t veroffset) { uint32t loopcnt; v16i8 src0, src1, src2, src3, src4; v16i8 mask0, mask1, mask2; v8i16 hzout0, hzout1, hzout2, hzout3; v8i16 hzout4, hzout5, hzout6, hzout7, hzout8; v8i16 dst0, dst1, dst2, dst3, dst4, dst5, dst6, dst7; LDSB3(&lumamaskarr[48], 16, mask0, mask1, mask2); LDSB5(src, srcstride, src0, src1, src2, src3, src4); src += (5 * srcstride); XORIB5128SB(src0, src1, src2, src3, src4); hzout0 = AVCXORVSHFBANDAPPLY6TAPHORIZFILTSH(src0, src1, mask0, mask1, mask2); hzout2 = AVCXORVSHFBANDAPPLY6TAPHORIZFILTSH(src2, src3, mask0, mask1, mask2); PCKODD2SH(hzout0, hzout0, hzout2, hzout2, hzout1, hzout3); hzout4 = AVCHORZFILTERSH(src4, mask0, mask1, mask2); for (loopcnt = (height >> 2); loopcnt--;) { LDSB4(src, srcstride, src0, src1, src2, src3); src += (4 * srcstride); XORIB4128SB(src0, src1, src2, src3); hzout5 = AVCXORVSHFBANDAPPLY6TAPHORIZFILTSH(src0, src1, mask0, mask1, mask2); hzout7 = AVCXORVSHFBANDAPPLY6TAPHORIZFILTSH(src2, src3, mask0, mask1, mask2); PCKODD2SH(hzout5, hzout5, hzout7, hzout7, hzout6, hzout8); dst0 = AVCCALCDPADDH6PIX2COEFFSH(hzout0, hzout1, hzout2, hzout3, hzout4, hzout5); dst2 = AVCCALCDPADDH6PIX2COEFFSH(hzout1, hzout2, hzout3, hzout4, hzout5, hzout6); dst4 = AVCCALCDPADDH6PIX2COEFFSH(hzout2, hzout3, hzout4, hzout5, hzout6, hzout7); dst6 = AVCCALCDPADDH6PIX2COEFFSH(hzout3, hzout4, hzout5, hzout6, hzout7, hzout8); if (veroffset) { dst1 = msasrarih(hzout3, 5); dst3 = msasrarih(hzout4, 5); dst5 = msasrarih(hzout5, 5); dst7 = msasrarih(hzout6, 5); } else { dst1 = msasrarih(hzout2, 5); dst3 = msasrarih(hzout3, 5); dst5 = msasrarih(hzout4, 5); dst7 = msasrarih(hzout5, 5); } SATSH4SH(dst1, dst3, dst5, dst7, 7); dst0 = msaaversh(dst0, dst1); dst1 = msaaversh(dst2, dst3); dst2 = msaaversh(dst4, dst5); dst3 = msaaversh(dst6, dst7); PCKEVB2SB(dst1, dst0, dst3, dst2, src0, src1); XORIB2128SB(src0, src1); ST4x4UB(src0, src1, 0, 2, 0, 2, dst, dststride); dst += (4 * dststride); hzout0 = hzout4; hzout1 = hzout5; hzout2 = hzout6; hzout3 = hzout7; hzout4 = hzout8; } } ", "target": 0}
{"func": "static void amlfree(gpointer data, gpointer userdata) { Aml *var = data; buildfreearray(var->buf); }", "target": 1}
{"func": "static void virtioscsihandlecmd(VirtIODevice *vdev, VirtQueue *vq) { /* use non-QOM casts in the data path */ VirtIOSCSI *s = (VirtIOSCSI *)vdev; VirtIOSCSICommon *vs = &s->parentobj; VirtIOSCSIReq *req; int n; while ((req = virtioscsipopreq(s, vq))) { SCSIDevice *d; int outsize, insize; if (req->elem.outnum < 1 || req->elem.innum < 1) { virtioscsibadreq(); } outsize = req->elem.outsg[0].iovlen; insize = req->elem.insg[0].iovlen; if (outsize < sizeof(VirtIOSCSICmdReq) + vs->cdbsize || insize < sizeof(VirtIOSCSICmdResp) + vs->sensesize) { virtioscsibadreq(); } if (req->elem.outnum > 1 && req->elem.innum > 1) { virtioscsifailcmdreq(req); continue; } d = virtioscsidevicefind(s, req->req.cmd->lun); if (!d) { req->resp.cmd->response = VIRTIOSCSISBADTARGET; virtioscsicompletereq(req); continue; } req->sreq = scsireqnew(d, req->req.cmd->tag, virtioscsigetlun(req->req.cmd->lun), req->req.cmd->cdb, req); if (req->sreq->cmd.mode != SCSIXFERNONE) { int reqmode = (req->elem.innum > 1 ? SCSIXFERFROMDEV : SCSIXFERTODEV); if (req->sreq->cmd.mode != reqmode || req->sreq->cmd.xfer > req->qsgl.size) { req->resp.cmd->response = VIRTIOSCSISOVERRUN; virtioscsicompletereq(req); continue; } } n = scsireqenqueue(req->sreq); if (n) { scsireqcontinue(req->sreq); } } } ", "target": 0}
{"func": "CharDriverState *textconsoleinit(QemuOpts *opts) { CharDriverState *chr; QemuConsole *s; unsigned width; unsigned height; chr = gmalloc0(sizeof(CharDriverState)); width = qemuoptgetnumber(opts, \"width\", 0); if (width == 0) width = qemuoptgetnumber(opts, \"cols\", 0) * FONTWIDTH; height = qemuoptgetnumber(opts, \"height\", 0); if (height == 0) height = qemuoptgetnumber(opts, \"rows\", 0) * FONTHEIGHT; if (width == 0 || height == 0) { s = newconsole(NULL, TEXTCONSOLE); } else { s = newconsole(NULL, TEXTCONSOLEFIXEDSIZE); } if (!s) { gfree(chr); return NULL; } s->chr = chr; s->gwidth = width; s->gheight = height; chr->opaque = s; chr->chrsetecho = textconsolesetecho; return chr; } ", "target": 0}
{"func": "static uint64t eepro100read(void *opaque, targetphysaddrt addr, unsigned size) { EEPRO100State *s = opaque; switch (size) { case 1: return eepro100read1(s, addr); case 2: return eepro100read2(s, addr); case 4: return eepro100read4(s, addr); default: abort(); } } ", "target": 0}
{"func": "bool vringshouldnotify(VirtIODevice *vdev, Vring *vring) { uint16t old, new; bool v; /* Flush out used index updates. This is paired * with the barrier that the Guest executes when enabling * interrupts. */ smpmb(); if ((vdev->guestfeatures & (1 << VIRTIOFNOTIFYONEMPTY)) && unlikely(!vringmoreavail(vdev, vring))) { return true; } if (!(vdev->guestfeatures & (1 << VIRTIORINGFEVENTIDX))) { return !(vringgetavailflags(vdev, vring) & VRINGAVAILFNOINTERRUPT); } old = vring->signalledused; v = vring->signalledusedvalid; new = vring->signalledused = vring->lastusedidx; vring->signalledusedvalid = true; if (unlikely(!v)) { return true; } return vringneedevent(vringusedevent(&vring->vr), new, old); } ", "target": 0}
{"func": "static int amrnbencodeframe(AVCodecContext *avctx, AVPacket *avpkt, const AVFrame *frame, int *gotpacketptr) { AMRContext *s = avctx->privdata; int written, ret; int16t *flushbuf = NULL; const int16t *samples = frame ? (const int16t *)frame->data[0] : NULL; if (s->encbitrate != avctx->bitrate) { s->encmode = getbitratemode(avctx->bitrate, avctx); s->encbitrate = avctx->bitrate; } if ((ret = ffallocpacket(avpkt, 32))) { avlog(avctx, AVLOGERROR, \"Error getting output packet\\n\"); return ret; } if (frame) { if (frame->nbsamples < avctx->framesize) { flushbuf = avmallocz(avctx->framesize * sizeof(*flushbuf)); if (!flushbuf) return AVERROR(ENOMEM); memcpy(flushbuf, samples, frame->nbsamples * sizeof(*flushbuf)); samples = flushbuf; if (frame->nbsamples < avctx->framesize - avctx->delay) s->enclastframe = -1; } if ((ret = ffafqueueadd(&s->afq, frame)) < 0) { avfreep(&flushbuf); return ret; } } else { if (s->enclastframe < 0) return 0; flushbuf = avmallocz(avctx->framesize * sizeof(*flushbuf)); if (!flushbuf) return AVERROR(ENOMEM); samples = flushbuf; s->enclastframe = -1; } written = EncoderInterfaceEncode(s->encstate, s->encmode, samples, avpkt->data, 0); avdlog(avctx, \"amrnbencodeframe encoded %u bytes, bitrate %u, first byte was %#02x\\n\", written, s->encmode, frame[0]); /* Get the next frame pts/duration */ ffafqueueremove(&s->afq, avctx->framesize, &avpkt->pts, &avpkt->duration); avpkt->size = written; *gotpacketptr = 1; avfreep(&flushbuf); return 0; } ", "target": 0}
{"func": "void dounassignedaccess(targetphysaddrt addr, int iswrite, int isexec, int isasi, int size) { CPUState *savedenv; /* XXX: hack to restore env in all cases, even if not called from generated code */ savedenv = env; env = cpusingleenv; qemulog(\"Unassigned \" TARGETFMTplx \" wr=%d exe=%d\\n\", addr, iswrite, isexec); if (!(env->sregs[SRMSR] & MSREE)) { return; } if (isexec) { if (!(env->pvr.regs[2] & PVR2IOPBBUSEXCMASK)) { env->sregs[SRESR] = ESRECINSNBUS; helperraiseexception(EXCPHWEXCP); } } else { if (!(env->pvr.regs[2] & PVR2DOPBBUSEXCMASK)) { env->sregs[SRESR] = ESRECDATABUS; helperraiseexception(EXCPHWEXCP); } } } ", "target": 0}
{"func": "static int RENAME(swScale)(SwsContext *c, uint8t* src[], int srcStride[], int srcSliceY, int srcSliceH, uint8t* dst[], int dstStride[]){ \t/* load a few things into local vars to make the code more readable? and faster */ \tconst int srcW= c->srcW; \tconst int dstW= c->dstW; \tconst int dstH= c->dstH; \tconst int chrDstW= c->chrDstW; \tconst int chrSrcW= c->chrSrcW; \tconst int lumXInc= c->lumXInc; \tconst int chrXInc= c->chrXInc; \tconst int dstFormat= c->dstFormat; \tconst int srcFormat= c->srcFormat; \tconst int flags= c->flags; \tconst int canMMX2BeUsed= c->canMMX2BeUsed; \tint16t *vLumFilterPos= c->vLumFilterPos; \tint16t *vChrFilterPos= c->vChrFilterPos; \tint16t *hLumFilterPos= c->hLumFilterPos; \tint16t *hChrFilterPos= c->hChrFilterPos; \tint16t *vLumFilter= c->vLumFilter; \tint16t *vChrFilter= c->vChrFilter; \tint16t *hLumFilter= c->hLumFilter; \tint16t *hChrFilter= c->hChrFilter; \tint32t *lumMmxFilter= c->lumMmxFilter; \tint32t *chrMmxFilter= c->chrMmxFilter; \tconst int vLumFilterSize= c->vLumFilterSize; \tconst int vChrFilterSize= c->vChrFilterSize; \tconst int hLumFilterSize= c->hLumFilterSize; \tconst int hChrFilterSize= c->hChrFilterSize; \tint16t **lumPixBuf= c->lumPixBuf; \tint16t **chrPixBuf= c->chrPixBuf; \tconst int vLumBufSize= c->vLumBufSize; \tconst int vChrBufSize= c->vChrBufSize; \tuint8t *funnyYCode= c->funnyYCode; \tuint8t *funnyUVCode= c->funnyUVCode; \tuint8t *formatConvBuffer= c->formatConvBuffer; \tconst int chrSrcSliceY= srcSliceY >> c->chrSrcVSubSample; \tconst int chrSrcSliceH= -((-srcSliceH) >> c->chrSrcVSubSample); \tint lastDstY; uint8t *pal=NULL; \t/* vars whch will change and which we need to storw back in the context */ \tint dstY= c->dstY; \tint lumBufIndex= c->lumBufIndex; \tint chrBufIndex= c->chrBufIndex; \tint lastInLumBuf= c->lastInLumBuf; \tint lastInChrBuf= c->lastInChrBuf; \t \tif(isPacked(c->srcFormat)){ pal= src[1]; \t\tsrc[0]= \t\tsrc[1]= \t\tsrc[2]= src[0]; \t\tsrcStride[0]= \t\tsrcStride[1]= \t\tsrcStride[2]= srcStride[0]; \t} \tsrcStride[1]<<= c->vChrDrop; \tsrcStride[2]<<= c->vChrDrop; //\tprintf(\"swscale %X %X %X -> %X %X %X\\n\", (int)src[0], (int)src[1], (int)src[2], //\t\t(int)dst[0], (int)dst[1], (int)dst[2]); #if 0 //self test FIXME move to a vfilter or something { static volatile int i=0; i++; if(srcFormat==PIXFMTYUV420P && i==1 && srcSliceH>= c->srcH) \tselfTest(src, srcStride, c->srcW, c->srcH); i--; } #endif //printf(\"sws Strides:%d %d %d -> %d %d %d\\n\", srcStride[0],srcStride[1],srcStride[2], //dstStride[0],dstStride[1],dstStride[2]); \tif(dstStride[0]%8 !=0 || dstStride[1]%8 !=0 || dstStride[2]%8 !=0) \t{ \t\tstatic int firstTime=1; //FIXME move this into the context perhaps \t\tif(flags & SWSPRINTINFO && firstTime) \t\t{ \t\t\tavlog(c, AVLOGWARNING, \"SwScaler: Warning: dstStride is not aligned!\\n\" \t\t\t\t\t\"SwScaler: ->cannot do aligned memory acesses anymore\\n\"); \t\t\tfirstTime=0; \t\t} \t} \t/* Note the user might start scaling the picture in the middle so this will not get executed \t this is not really intended but works currently, so ppl might do it */ \tif(srcSliceY ==0){ \t\tlumBufIndex=0; \t\tchrBufIndex=0; \t\tdstY=0;\t \t\tlastInLumBuf= -1; \t\tlastInChrBuf= -1; \t} \tlastDstY= dstY; \tfor(;dstY < dstH; dstY++){ \t\tunsigned char *dest =dst[0]+dstStride[0]*dstY; \t\tconst int chrDstY= dstY>>c->chrDstVSubSample; \t\tunsigned char *uDest=dst[1]+dstStride[1]*chrDstY; \t\tunsigned char *vDest=dst[2]+dstStride[2]*chrDstY; \t\tconst int firstLumSrcY= vLumFilterPos[dstY]; //First line needed as input \t\tconst int firstChrSrcY= vChrFilterPos[chrDstY]; //First line needed as input \t\tconst int lastLumSrcY= firstLumSrcY + vLumFilterSize -1; // Last line needed as input \t\tconst int lastChrSrcY= firstChrSrcY + vChrFilterSize -1; // Last line needed as input //printf(\"dstY:%d dstH:%d firstLumSrcY:%d lastInLumBuf:%d vLumBufSize: %d vChrBufSize: %d slice: %d %d vLumFilterSize: %d firstChrSrcY: %d vChrFilterSize: %d c->chrSrcVSubSample: %d\\n\", // dstY, dstH, firstLumSrcY, lastInLumBuf, vLumBufSize, vChrBufSize, srcSliceY, srcSliceH, vLumFilterSize, firstChrSrcY, vChrFilterSize, c->chrSrcVSubSample); \t\t//handle holes (FASTBILINEAR & weird filters) \t\tif(firstLumSrcY > lastInLumBuf) lastInLumBuf= firstLumSrcY-1; \t\tif(firstChrSrcY > lastInChrBuf) lastInChrBuf= firstChrSrcY-1; //printf(\"%d %d %d\\n\", firstChrSrcY, lastInChrBuf, vChrBufSize); \t\tASSERT(firstLumSrcY >= lastInLumBuf - vLumBufSize + 1) \t\tASSERT(firstChrSrcY >= lastInChrBuf - vChrBufSize + 1) \t\t// Do we have enough lines in this slice to output the dstY line \t\tif(lastLumSrcY < srcSliceY + srcSliceH && lastChrSrcY < -((-srcSliceY - srcSliceH)>>c->chrSrcVSubSample)) \t\t{ \t\t\t//Do horizontal scaling \t\t\twhile(lastInLumBuf < lastLumSrcY) \t\t\t{ \t\t\t\tuint8t *s= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0]; \t\t\t\tlumBufIndex++; //\t\t\t\tprintf(\"%d %d %d %d\\n\", lumBufIndex, vLumBufSize, lastInLumBuf, lastLumSrcY); \t\t\t\tASSERT(lumBufIndex < 2*vLumBufSize) \t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY < srcSliceH) \t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY >= 0) //\t\t\t\tprintf(\"%d %d\\n\", lumBufIndex, vLumBufSize); \t\t\t\tRENAME(hyscale)(lumPixBuf[ lumBufIndex ], dstW, s, srcW, lumXInc, \t\t\t\t\t\tflags, canMMX2BeUsed, hLumFilter, hLumFilterPos, hLumFilterSize, \t\t\t\t\t\tfunnyYCode, c->srcFormat, formatConvBuffer, \t\t\t\t\t\tc->lumMmx2Filter, c->lumMmx2FilterPos, pal); \t\t\t\tlastInLumBuf++; \t\t\t} \t\t\twhile(lastInChrBuf < lastChrSrcY) \t\t\t{ \t\t\t\tuint8t *src1= src[1]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[1]; \t\t\t\tuint8t *src2= src[2]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[2]; \t\t\t\tchrBufIndex++; \t\t\t\tASSERT(chrBufIndex < 2*vChrBufSize) \t\t\t\tASSERT(lastInChrBuf + 1 - chrSrcSliceY < (chrSrcSliceH)) \t\t\t\tASSERT(lastInChrBuf + 1 - chrSrcSliceY >= 0) \t\t\t\t//FIXME replace parameters through context struct (some at least) \t\t\t\tif(!(isGray(srcFormat) || isGray(dstFormat))) \t\t\t\t\tRENAME(hcscale)(chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, chrSrcW, chrXInc, \t\t\t\t\t\tflags, canMMX2BeUsed, hChrFilter, hChrFilterPos, hChrFilterSize, \t\t\t\t\t\tfunnyUVCode, c->srcFormat, formatConvBuffer, \t\t\t\t\t\tc->chrMmx2Filter, c->chrMmx2FilterPos, pal); \t\t\t\tlastInChrBuf++; \t\t\t} \t\t\t//wrap buf index around to stay inside the ring buffer \t\t\tif(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize; \t\t\tif(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize; \t\t} \t\telse // not enough lines left in this slice -> load the rest in the buffer \t\t{ /*\t\tprintf(\"%d %d Last:%d %d LastInBuf:%d %d Index:%d %d Y:%d FSize: %d %d BSize: %d %d\\n\", \t\t\tfirstChrSrcY,firstLumSrcY,lastChrSrcY,lastLumSrcY, \t\t\tlastInChrBuf,lastInLumBuf,chrBufIndex,lumBufIndex,dstY,vChrFilterSize,vLumFilterSize, \t\t\tvChrBufSize, vLumBufSize);*/ \t\t\t//Do horizontal scaling \t\t\twhile(lastInLumBuf+1 < srcSliceY + srcSliceH) \t\t\t{ \t\t\t\tuint8t *s= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0]; \t\t\t\tlumBufIndex++; \t\t\t\tASSERT(lumBufIndex < 2*vLumBufSize) \t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY < srcSliceH) \t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY >= 0) \t\t\t\tRENAME(hyscale)(lumPixBuf[ lumBufIndex ], dstW, s, srcW, lumXInc, \t\t\t\t\t\tflags, canMMX2BeUsed, hLumFilter, hLumFilterPos, hLumFilterSize, \t\t\t\t\t\tfunnyYCode, c->srcFormat, formatConvBuffer, \t\t\t\t\t\tc->lumMmx2Filter, c->lumMmx2FilterPos, pal); \t\t\t\tlastInLumBuf++; \t\t\t} \t\t\twhile(lastInChrBuf+1 < (chrSrcSliceY + chrSrcSliceH)) \t\t\t{ \t\t\t\tuint8t *src1= src[1]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[1]; \t\t\t\tuint8t *src2= src[2]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[2]; \t\t\t\tchrBufIndex++; \t\t\t\tASSERT(chrBufIndex < 2*vChrBufSize) \t\t\t\tASSERT(lastInChrBuf + 1 - chrSrcSliceY < chrSrcSliceH) \t\t\t\tASSERT(lastInChrBuf + 1 - chrSrcSliceY >= 0) \t\t\t\tif(!(isGray(srcFormat) || isGray(dstFormat))) \t\t\t\t\tRENAME(hcscale)(chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, chrSrcW, chrXInc, \t\t\t\t\t\tflags, canMMX2BeUsed, hChrFilter, hChrFilterPos, hChrFilterSize, \t\t\t\t\t\tfunnyUVCode, c->srcFormat, formatConvBuffer, \t\t\t\t\t\tc->chrMmx2Filter, c->chrMmx2FilterPos, pal); \t\t\t\tlastInChrBuf++; \t\t\t} \t\t\t//wrap buf index around to stay inside the ring buffer \t\t\tif(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize; \t\t\tif(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize; \t\t\tbreak; //we can't output a dstY line so let's try with the next slice \t\t} #ifdef HAVEMMX \t\tb5Dither= dither8[dstY&1]; \t\tg6Dither= dither4[dstY&1]; \t\tg5Dither= dither8[dstY&1]; \t\tr5Dither= dither8[(dstY+1)&1]; #endif \t if(dstY < dstH-2) \t { \t\tint16t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize; \t\tint16t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize; #ifdef HAVEMMX \t\tint i; if(flags & SWSACCURATERND){ for(i=0; i<vLumFilterSize; i+=2){ lumMmxFilter[2*i+0]= (int32t)lumSrcPtr[i ]; lumMmxFilter[2*i+1]= (int32t)lumSrcPtr[i+(vLumFilterSize>1)]; lumMmxFilter[2*i+2]= lumMmxFilter[2*i+3]= vLumFilter[dstY*vLumFilterSize + i ] + (vLumFilterSize>1 ? vLumFilter[dstY*vLumFilterSize + i + 1]<<16 : 0); } for(i=0; i<vChrFilterSize; i+=2){ chrMmxFilter[2*i+0]= (int32t)chrSrcPtr[i ]; chrMmxFilter[2*i+1]= (int32t)chrSrcPtr[i+(vChrFilterSize>1)]; chrMmxFilter[2*i+2]= chrMmxFilter[2*i+3]= vChrFilter[chrDstY*vChrFilterSize + i ] + (vChrFilterSize>1 ? vChrFilter[chrDstY*vChrFilterSize + i + 1]<<16 : 0); } }else{ \t\tfor(i=0; i<vLumFilterSize; i++) \t\t{ \t\t\tlumMmxFilter[4*i+0]= (int32t)lumSrcPtr[i]; \t\t\tlumMmxFilter[4*i+1]= (uint64t)lumSrcPtr[i] >> 32; \t\t\tlumMmxFilter[4*i+2]= \t\t\tlumMmxFilter[4*i+3]= \t\t\t\t((uint16t)vLumFilter[dstY*vLumFilterSize + i])*0x10001; \t\t} \t\tfor(i=0; i<vChrFilterSize; i++) \t\t{ \t\t\tchrMmxFilter[4*i+0]= (int32t)chrSrcPtr[i]; \t\t\tchrMmxFilter[4*i+2]= \t\t\tchrMmxFilter[4*i+3]= \t\t\t\t((uint16t)vChrFilter[chrDstY*vChrFilterSize + i])*0x10001; \t\t} } #endif \t\tif(dstFormat == PIXFMTNV12 || dstFormat == PIXFMTNV21){ \t\t\tconst int chrSkipMask= (1<<c->chrDstVSubSample)-1; \t\t\tif(dstY&chrSkipMask) uDest= NULL; //FIXME split functions in lumi / chromi \t\t\tRENAME(yuv2nv12X)(c, \t\t\t\tvLumFilter+dstY*vLumFilterSize , lumSrcPtr, vLumFilterSize, \t\t\t\tvChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize, \t\t\t\tdest, uDest, dstW, chrDstW, dstFormat); \t\t} \t\telse if(isPlanarYUV(dstFormat) || isGray(dstFormat)) //YV12 like \t\t{ \t\t\tconst int chrSkipMask= (1<<c->chrDstVSubSample)-1; \t\t\tif((dstY&chrSkipMask) || isGray(dstFormat)) uDest=vDest= NULL; //FIXME split functions in lumi / chromi \t\t\tif(vLumFilterSize == 1 && vChrFilterSize == 1) // Unscaled YV12 \t\t\t{ \t\t\t\tint16t *lumBuf = lumPixBuf[0]; \t\t\t\tint16t *chrBuf= chrPixBuf[0]; \t\t\t\tRENAME(yuv2yuv1)(lumBuf, chrBuf, dest, uDest, vDest, dstW, chrDstW); \t\t\t} \t\t\telse //General YV12 \t\t\t{ \t\t\t\tRENAME(yuv2yuvX)(c, \t\t\t\t\tvLumFilter+dstY*vLumFilterSize , lumSrcPtr, vLumFilterSize, \t\t\t\t\tvChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize, \t\t\t\t\tdest, uDest, vDest, dstW, chrDstW); \t\t\t} \t\t} \t\telse \t\t{ \t\t\tASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2); \t\t\tASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2); \t\t\tif(vLumFilterSize == 1 && vChrFilterSize == 2) //Unscaled RGB \t\t\t{ \t\t\t\tint chrAlpha= vChrFilter[2*dstY+1]; \t\t\t\tRENAME(yuv2packed1)(c, *lumSrcPtr, *chrSrcPtr, *(chrSrcPtr+1), \t\t\t\t\t\t dest, dstW, chrAlpha, dstFormat, flags, dstY); \t\t\t} \t\t\telse if(vLumFilterSize == 2 && vChrFilterSize == 2) //BiLinear Upscale RGB \t\t\t{ \t\t\t\tint lumAlpha= vLumFilter[2*dstY+1]; \t\t\t\tint chrAlpha= vChrFilter[2*dstY+1]; lumMmxFilter[2]= lumMmxFilter[3]= vLumFilter[2*dstY ]*0x10001; chrMmxFilter[2]= chrMmxFilter[3]= vChrFilter[2*chrDstY]*0x10001; \t\t\t\tRENAME(yuv2packed2)(c, *lumSrcPtr, *(lumSrcPtr+1), *chrSrcPtr, *(chrSrcPtr+1), \t\t\t\t\t\t dest, dstW, lumAlpha, chrAlpha, dstY); \t\t\t} \t\t\telse //General RGB \t\t\t{ \t\t\t\tRENAME(yuv2packedX)(c, \t\t\t\t\tvLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize, \t\t\t\t\tvChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize, \t\t\t\t\tdest, dstW, dstY); \t\t\t} \t\t} } \t else // hmm looks like we can't use MMX here without overwriting this array's tail \t { \t\tint16t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize; \t\tint16t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize; \t\tif(dstFormat == PIXFMTNV12 || dstFormat == PIXFMTNV21){ \t\t\tconst int chrSkipMask= (1<<c->chrDstVSubSample)-1; \t\t\tif(dstY&chrSkipMask) uDest= NULL; //FIXME split functions in lumi / chromi \t\t\tyuv2nv12XinC( \t\t\t\tvLumFilter+dstY*vLumFilterSize , lumSrcPtr, vLumFilterSize, \t\t\t\tvChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize, \t\t\t\tdest, uDest, dstW, chrDstW, dstFormat); \t\t} \t\telse if(isPlanarYUV(dstFormat) || isGray(dstFormat)) //YV12 \t\t{ \t\t\tconst int chrSkipMask= (1<<c->chrDstVSubSample)-1; \t\t\tif((dstY&chrSkipMask) || isGray(dstFormat)) uDest=vDest= NULL; //FIXME split functions in lumi / chromi \t\t\tyuv2yuvXinC( \t\t\t\tvLumFilter+dstY*vLumFilterSize , lumSrcPtr, vLumFilterSize, \t\t\t\tvChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize, \t\t\t\tdest, uDest, vDest, dstW, chrDstW); \t\t} \t\telse \t\t{ \t\t\tASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2); \t\t\tASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2); \t\t\tyuv2packedXinC(c, \t\t\t\tvLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize, \t\t\t\tvChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize, \t\t\t\tdest, dstW, dstY); \t\t} \t } \t} #ifdef HAVEMMX \tasm volatile(SFENCE:::\"memory\"); \tasm volatile(EMMS:::\"memory\"); #endif \t/* store changed local vars back in the context */ \tc->dstY= dstY; \tc->lumBufIndex= lumBufIndex; \tc->chrBufIndex= chrBufIndex; \tc->lastInLumBuf= lastInLumBuf; \tc->lastInChrBuf= lastInChrBuf; \treturn dstY - lastDstY; }", "target": 1}
{"func": "static inline void RENAME(bgr24ToY)(uint8t *dst, const uint8t *src, int width, uint32t *unused) { #if COMPILETEMPLATEMMX RENAME(bgr24ToYmmx)(dst, src, width, PIXFMTBGR24); #else int i; for (i=0; i<width; i++) { int b= src[i*3+0]; int g= src[i*3+1]; int r= src[i*3+2]; dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUVSHIFT-1)))>>RGB2YUVSHIFT); } #endif /* COMPILETEMPLATEMMX */ } ", "target": 1}
{"func": "void FUNC(ffsimpleidct)(DCTELEM *block) { int i; for (i = 0; i < 8; i++) FUNC(idctRowCondDC)(block + i*8); for (i = 0; i < 8; i++) FUNC(idctSparseCol)(block + i); } ", "target": 1}
{"func": "static void ohciasynccanceldevice(OHCIState *ohci, USBDevice *dev) { if (ohci->asynctd && ohci->usbpacket.owner != NULL && ohci->usbpacket.owner->dev == dev) { usbcancelpacket(&ohci->usbpacket); ohci->asynctd = 0; } } ", "target": 1}
{"func": "static int avencode(AVFormatContext **outputfiles, int nboutputfiles, AVFormatContext **inputfiles, int nbinputfiles, AVStreamMap *streammaps, int nbstreammaps) { int ret, i, j, k, n, nbistreams = 0, nbostreams = 0; AVFormatContext *is, *os; AVCodecContext *codec, *icodec; AVOutputStream *ost, **osttable = NULL; AVInputStream *ist, **isttable = NULL; AVInputFile *filetable; AVFormatContext *streamnodata; int key; filetable= (AVInputFile*) avmallocz(nbinputfiles * sizeof(AVInputFile)); if (!filetable) goto fail; /* input stream init */ j = 0; for(i=0;i<nbinputfiles;i++) { is = inputfiles[i]; filetable[i].istindex = j; filetable[i].nbstreams = is->nbstreams; j += is->nbstreams; } nbistreams = j; isttable = avmallocz(nbistreams * sizeof(AVInputStream *)); if (!isttable) goto fail; for(i=0;i<nbistreams;i++) { ist = avmallocz(sizeof(AVInputStream)); if (!ist) goto fail; isttable[i] = ist; } j = 0; for(i=0;i<nbinputfiles;i++) { is = inputfiles[i]; for(k=0;k<is->nbstreams;k++) { ist = isttable[j++]; ist->st = is->streams[k]; ist->fileindex = i; ist->index = k; ist->discard = 1; /* the stream is discarded by default (changed later) */ if (ist->st->codec.rateemu) { ist->start = avgettime(); ist->frame = 0; } } } /* output stream init */ nbostreams = 0; for(i=0;i<nboutputfiles;i++) { os = outputfiles[i]; nbostreams += os->nbstreams; } if (nbstreammaps > 0 && nbstreammaps != nbostreams) { fprintf(stderr, \"Number of stream maps must match number of output streams\\n\"); exit(1); } /* Sanity check the mapping args -- do the input files & streams exist? */ for(i=0;i<nbstreammaps;i++) { int fi = streammaps[i].fileindex; int si = streammaps[i].streamindex; if (fi < 0 || fi > nbinputfiles - 1 || si < 0 || si > filetable[fi].nbstreams - 1) { fprintf(stderr,\"Could not find input stream #%d.%d\\n\", fi, si); exit(1); } } osttable = avmallocz(sizeof(AVOutputStream *) * nbostreams); if (!osttable) goto fail; for(i=0;i<nbostreams;i++) { ost = avmallocz(sizeof(AVOutputStream)); if (!ost) goto fail; osttable[i] = ost; } n = 0; for(k=0;k<nboutputfiles;k++) { os = outputfiles[k]; for(i=0;i<os->nbstreams;i++) { int found; ost = osttable[n++]; ost->fileindex = k; ost->index = i; ost->st = os->streams[i]; if (nbstreammaps > 0) { ost->sourceindex = filetable[streammaps[n-1].fileindex].istindex + streammaps[n-1].streamindex; /* Sanity check that the stream types match */ if (isttable[ost->sourceindex]->st->codec.codectype != ost->st->codec.codectype) { fprintf(stderr, \"Codec type mismatch for mapping #%d.%d -> #%d.%d\\n\", streammaps[n-1].fileindex, streammaps[n-1].streamindex, ost->fileindex, ost->index); exit(1); } } else { /* get corresponding input stream index : we select the first one with the right type */ found = 0; for(j=0;j<nbistreams;j++) { ist = isttable[j]; if (ist->discard && ist->st->codec.codectype == ost->st->codec.codectype) { ost->sourceindex = j; found = 1; } } if (!found) { /* try again and reuse existing stream */ for(j=0;j<nbistreams;j++) { ist = isttable[j]; if (ist->st->codec.codectype == ost->st->codec.codectype) { ost->sourceindex = j; found = 1; } } if (!found) { fprintf(stderr, \"Could not find input stream matching output stream #%d.%d\\n\", ost->fileindex, ost->index); exit(1); } } } ist = isttable[ost->sourceindex]; ist->discard = 0; } } /* for each output stream, we compute the right encoding parameters */ for(i=0;i<nbostreams;i++) { ost = osttable[i]; ist = isttable[ost->sourceindex]; codec = &ost->st->codec; icodec = &ist->st->codec; if (ost->st->streamcopy) { /* if streamcopy is selected, no need to decode or encode */ codec->codecid = icodec->codecid; codec->codectype = icodec->codectype; codec->codectag = icodec->codectag; codec->bitrate = icodec->bitrate; switch(codec->codectype) { case CODECTYPEAUDIO: codec->samplerate = icodec->samplerate; codec->channels = icodec->channels; break; case CODECTYPEVIDEO: codec->framerate = icodec->framerate; codec->frameratebase = icodec->frameratebase; codec->width = icodec->width; codec->height = icodec->height; break; default: avabort(); } } else { switch(codec->codectype) { case CODECTYPEAUDIO: if (fifoinit(&ost->fifo, 2 * MAXAUDIOPACKETSIZE)) goto fail; if (codec->channels == icodec->channels && codec->samplerate == icodec->samplerate) { ost->audioresample = 0; } else { if (codec->channels != icodec->channels && icodec->codecid == CODECIDAC3) { /* Special case for 5:1 AC3 input */ /* and mono or stereo output */ /* Request specific number of channels */ icodec->channels = codec->channels; if (codec->samplerate == icodec->samplerate) ost->audioresample = 0; else { ost->audioresample = 1; ost->resample = audioresampleinit(codec->channels, icodec->channels, codec->samplerate, icodec->samplerate); \t\t\t if(!ost->resample) \t\t\t { \t\t\t\tprintf(\"Can't resample. Aborting.\\n\"); \t\t\t\tavabort(); \t\t\t } } /* Request specific number of channels */ icodec->channels = codec->channels; } else { ost->audioresample = 1; ost->resample = audioresampleinit(codec->channels, icodec->channels, codec->samplerate, icodec->samplerate); \t\t\tif(!ost->resample) \t\t\t { \t\t\t printf(\"Can't resample. Aborting.\\n\"); \t\t\t avabort(); \t\t\t } } } ist->decodingneeded = 1; ost->encodingneeded = 1; break; case CODECTYPEVIDEO: if (codec->width == icodec->width && codec->height == icodec->height && frametopBand == 0 && framebottomBand == 0 && frameleftBand == 0 && framerightBand == 0) { ost->videoresample = 0; ost->videocrop = 0; } else if ((codec->width == icodec->width - (frameleftBand + framerightBand)) && (codec->height == icodec->height - (frametopBand + framebottomBand))) { ost->videoresample = 0; ost->videocrop = 1; ost->topBand = frametopBand; ost->leftBand = frameleftBand; } else { uint8t *buf; ost->videoresample = 1; ost->videocrop = 0; // cropping is handled as part of resample buf = avmalloc((codec->width * codec->height * 3) / 2); if (!buf) goto fail; ost->picttmp.data[0] = buf; ost->picttmp.data[1] = ost->picttmp.data[0] + (codec->width * codec->height); ost->picttmp.data[2] = ost->picttmp.data[1] + (codec->width * codec->height) / 4; ost->picttmp.linesize[0] = codec->width; ost->picttmp.linesize[1] = codec->width / 2; ost->picttmp.linesize[2] = codec->width / 2; ost->imgresamplectx = imgresamplefullinit( ost->st->codec.width, ost->st->codec.height, ist->st->codec.width, ist->st->codec.height, frametopBand, framebottomBand, frameleftBand, framerightBand); } ost->encodingneeded = 1; ist->decodingneeded = 1; break; default: avabort(); } /* two pass mode */ if (ost->encodingneeded && (codec->flags & (CODECFLAGPASS1 | CODECFLAGPASS2))) { char logfilename[1024]; FILE *f; int size; char *logbuffer; snprintf(logfilename, sizeof(logfilename), \"%s-%d.log\", passlogfilename ? passlogfilename : DEFAULTPASSLOGFILENAME, i); if (codec->flags & CODECFLAGPASS1) { f = fopen(logfilename, \"w\"); if (!f) { perror(logfilename); exit(1); } ost->logfile = f; } else { /* read the log file */ f = fopen(logfilename, \"r\"); if (!f) { perror(logfilename); exit(1); } fseek(f, 0, SEEKEND); size = ftell(f); fseek(f, 0, SEEKSET); logbuffer = avmalloc(size + 1); if (!logbuffer) { fprintf(stderr, \"Could not allocate log buffer\\n\"); exit(1); } fread(logbuffer, 1, size, f); fclose(f); logbuffer[size] = '\\0'; codec->statsin = logbuffer; } } } } /* dump the file output parameters - cannot be done before in case of stream copy */ for(i=0;i<nboutputfiles;i++) { dumpformat(outputfiles[i], i, outputfiles[i]->filename, 1); } /* dump the stream mapping */ fprintf(stderr, \"Stream mapping:\\n\"); for(i=0;i<nbostreams;i++) { ost = osttable[i]; fprintf(stderr, \" Stream #%d.%d -> #%d.%d\\n\", isttable[ost->sourceindex]->fileindex, isttable[ost->sourceindex]->index, ost->fileindex, ost->index); } /* open each encoder */ for(i=0;i<nbostreams;i++) { ost = osttable[i]; if (ost->encodingneeded) { AVCodec *codec; codec = avcodecfindencoder(ost->st->codec.codecid); if (!codec) { fprintf(stderr, \"Unsupported codec for output stream #%d.%d\\n\", ost->fileindex, ost->index); exit(1); } if (avcodecopen(&ost->st->codec, codec) < 0) { fprintf(stderr, \"Error while opening codec for stream #%d.%d - maybe incorrect parameters such as bitrate, rate, width or height\\n\", ost->fileindex, ost->index); exit(1); } } } /* open each decoder */ for(i=0;i<nbistreams;i++) { ist = isttable[i]; if (ist->decodingneeded) { AVCodec *codec; codec = avcodecfinddecoder(ist->st->codec.codecid); if (!codec) { fprintf(stderr, \"Unsupported codec (id=%d) for input stream #%d.%d\\n\", ist->st->codec.codecid, ist->fileindex, ist->index); exit(1); } if (avcodecopen(&ist->st->codec, codec) < 0) { fprintf(stderr, \"Error while opening codec for input stream #%d.%d\\n\", ist->fileindex, ist->index); exit(1); } //if (ist->st->codec.codectype == CODECTYPEVIDEO) // ist->st->codec.flags |= CODECFLAGREPEATFIELD; ist->framedecoded = 1; } } /* init pts */ for(i=0;i<nbistreams;i++) { ist = isttable[i]; \tis = inputfiles[ist->fileindex]; ist->pts = 0; if (ist->decodingneeded) { switch (ist->st->codec.codectype) { case CODECTYPEAUDIO: avfracinit(&ist->nextpts, 0, 0, is->ptsnum * ist->st->codec.samplerate); break; case CODECTYPEVIDEO: avfracinit(&ist->nextpts, 0, 0, is->ptsnum * ist->st->codec.framerate); break; default: break; } } } /* compute buffer size max (should use a complete heuristic) */ for(i=0;i<nbinputfiles;i++) { filetable[i].buffersizemax = 2048; } /* open files and write file headers */ for(i=0;i<nboutputfiles;i++) { os = outputfiles[i]; if (avwriteheader(os) < 0) { fprintf(stderr, \"Could not write header for output file #%d (incorrect codec paramters ?)\\n\", i); ret = -EINVAL; goto fail; } } #ifndef CONFIGWIN32 if ( !usingstdin ) fprintf(stderr, \"Press [q] to stop encoding\\n\"); #endif terminit(); streamnodata = 0; key = -1; for(; receivedsigterm == 0;) { int fileindex, istindex; AVPacket pkt; uint8t *ptr; int len; uint8t *databuf; int datasize, gotpicture; AVPicture picture; short samples[AVCODECMAXAUDIOFRAMESIZE / 2]; void *buffertofree; double ptsmin; redo: /* if 'q' pressed, exits */ if (!usingstdin) { /* readkey() returns 0 on EOF */ key = readkey(); if (key == 'q') break; } /* select the stream that we must read now by looking at the smallest output pts */ fileindex = -1; ptsmin = 1e10; for(i=0;i<nbostreams;i++) { double pts; ost = osttable[i]; os = outputfiles[ost->fileindex]; ist = isttable[ost->sourceindex]; pts = (double)ost->st->pts.val * os->ptsnum / os->ptsden; if (!filetable[ist->fileindex].eofreached && pts < ptsmin) { ptsmin = pts; fileindex = ist->fileindex; } } /* if none, if is finished */ if (fileindex < 0) { break; } /* finish if recording time exhausted */ if (recordingtime > 0 && ptsmin >= (recordingtime / 1000000.0)) break; /* read a packet from it and output it in the fifo */ is = inputfiles[fileindex]; if (avreadpacket(is, &pkt) < 0) { filetable[fileindex].eofreached = 1; continue; } if (!pkt.size) { streamnodata = is; } else { streamnodata = 0; } if (dohexdump) { printf(\"stream #%d, size=%d:\\n\", pkt.streamindex, pkt.size); avhexdump(pkt.data, pkt.size); } /* the following test is needed in case new streams appear dynamically in stream : we ignore them */ if (pkt.streamindex >= filetable[fileindex].nbstreams) goto discardpacket; istindex = filetable[fileindex].istindex + pkt.streamindex; ist = isttable[istindex]; if (ist->discard) goto discardpacket; // printf(\"read #%d.%d size=%d\\n\", ist->fileindex, ist->index, pkt.size); len = pkt.size; ptr = pkt.data; while (len > 0) { /* decode the packet if needed */ databuf = NULL; /* fail safe */ datasize = 0; if (ist->decodingneeded) { /* NOTE1: we only take into account the PTS if a new frame has begun (MPEG semantics) */ /* NOTE2: even if the fraction is not initialized, avfracset can be used to set the integer part */ if (ist->framedecoded) { /* If pts is unavailable -- we have to use synthetic one */ if( pkt.pts != AVNOPTSVALUE ) { ist->pts = ist->nextpts.val = pkt.pts; } else { ist->pts = ist->nextpts.val; } ist->framedecoded = 0; } switch(ist->st->codec.codectype) { case CODECTYPEAUDIO: /* XXX: could avoid copy if PCM 16 bits with same endianness as CPU */ ret = avcodecdecodeaudio(&ist->st->codec, samples, &datasize, ptr, len); if (ret < 0) goto faildecode; /* Some bug in mpeg audio decoder gives */ /* datasize < 0, it seems they are overflows */ if (datasize <= 0) { /* no audio frame */ ptr += ret; len -= ret; continue; } databuf = (uint8t *)samples; \t\t avfracadd(&ist->nextpts, \t\t\t is->ptsden * datasize / (2 * ist->st->codec.channels)); break; case CODECTYPEVIDEO: { AVFrame bigpicture; datasize = (ist->st->codec.width * ist->st->codec.height * 3) / 2; ret = avcodecdecodevideo(&ist->st->codec, &bigpicture, &gotpicture, ptr, len); picture= *(AVPicture*)&bigpicture; ist->st->quality= bigpicture.quality; if (ret < 0) { faildecode: fprintf(stderr, \"Error while decoding stream #%d.%d\\n\", ist->fileindex, ist->index); avfreepacket(&pkt); goto redo; } if (!gotpicture) { /* no picture yet */ ptr += ret; len -= ret; continue; } avfracadd(&ist->nextpts, \t\t\t is->ptsden * ist->st->codec.frameratebase); } break; default: goto faildecode; } } else { databuf = ptr; datasize = len; ret = len; } ptr += ret; len -= ret; buffertofree = 0; if (ist->st->codec.codectype == CODECTYPEVIDEO) { preprocessvideoframe(ist, &picture, &buffertofree); } ist->framedecoded = 1; /* frame rate emulation */ if (ist->st->codec.rateemu) { int64t pts = avrescale((int64t) ist->frame * ist->st->codec.frameratebase, 1000000, ist->st->codec.framerate); int64t now = avgettime() - ist->start; if (pts > now) usleep(pts - now); ist->frame++; } #if 0 /* mpeg PTS deordering : if it is a P or I frame, the PTS is the one of the next displayed one */ /* XXX: add mpeg4 too ? */ if (ist->st->codec.codecid == CODECIDMPEG1VIDEO) { if (ist->st->codec.picttype != BTYPE) { int64t tmp; tmp = ist->lastippts; ist->lastippts = ist->fracpts.val; ist->fracpts.val = tmp; } } #endif /* transcode raw format, encode packets and output them */ for(i=0;i<nbostreams;i++) { int framesize; ost = osttable[i]; if (ost->sourceindex == istindex) { os = outputfiles[ost->fileindex]; #if 0 printf(\"%d: got pts=%f %f\\n\", i, pkt.pts / 90000.0, (ist->pts - ost->st->pts.val) / 90000.0); #endif /* set the input output pts pairs */ ost->syncipts = (double)ist->pts * is->ptsnum / is->ptsden; /* XXX: take into account the various fifos, in particular for audio */ ost->syncopts = ost->st->pts.val; //printf(\"ipts=%lld syncipts=%f syncopts=%lld pts.val=%lld pkt.pts=%lld\\n\", ist->pts, ost->syncipts, ost->syncopts, ost->st->pts.val, pkt.pts); if (ost->encodingneeded) { switch(ost->st->codec.codectype) { case CODECTYPEAUDIO: doaudioout(os, ost, ist, databuf, datasize); break; case CODECTYPEVIDEO: /* find an audio stream for synchro */ { int i; AVOutputStream *audiosync, *ost1; audiosync = NULL; for(i=0;i<nbostreams;i++) { ost1 = osttable[i]; if (ost1->fileindex == ost->fileindex && ost1->st->codec.codectype == CODECTYPEAUDIO) { audiosync = ost1; break; } } dovideoout(os, ost, ist, &picture, &framesize, audiosync); if (dovstats && framesize) dovideostats(os, ost, framesize); } break; default: avabort(); } } else { AVFrame avframe; /* no reencoding needed : output the packet directly */ /* force the input stream PTS */ memset(&avframe, 0, sizeof(AVFrame)); ost->st->codec.codedframe= &avframe; \t\t\tavframe.keyframe = pkt.flags & PKTFLAGKEY; avwriteframe(os, ost->index, databuf, datasize); \t\t\tost->st->codec.framenumber++; \t\t\tost->framenumber++; } } } avfree(buffertofree); } discardpacket: avfreepacket(&pkt); /* dump report by using the output first video and audio streams */ printreport(outputfiles, osttable, nbostreams, 0); } termexit(); /* dump report by using the first video and audio streams */ printreport(outputfiles, osttable, nbostreams, 1); /* close each encoder */ for(i=0;i<nbostreams;i++) { ost = osttable[i]; if (ost->encodingneeded) { avfreep(&ost->st->codec.statsin); avcodecclose(&ost->st->codec); } } /* close each decoder */ for(i=0;i<nbistreams;i++) { ist = isttable[i]; if (ist->decodingneeded) { avcodecclose(&ist->st->codec); } } /* write the trailer if needed and close file */ for(i=0;i<nboutputfiles;i++) { os = outputfiles[i]; avwritetrailer(os); } /* finished ! */ ret = 0; fail1: avfree(filetable); if (isttable) { for(i=0;i<nbistreams;i++) { ist = isttable[i]; avfree(ist); } avfree(isttable); } if (osttable) { for(i=0;i<nbostreams;i++) { ost = osttable[i]; if (ost) { if (ost->logfile) { fclose(ost->logfile); ost->logfile = NULL; } fifofree(&ost->fifo); /* works even if fifo is not initialized but set to zero */ avfree(ost->picttmp.data[0]); if (ost->videoresample) imgresampleclose(ost->imgresamplectx); if (ost->audioresample) audioresampleclose(ost->resample); avfree(ost); } } avfree(osttable); } return ret; fail: ret = -ENOMEM; goto fail1; } ", "target": 1}
{"func": "int avprivmpeg4audiogetconfig(MPEG4AudioConfig *c, const uint8t *buf, int bitsize, int syncextension) { GetBitContext gb; int specificconfigbitindex; initgetbits(&gb, buf, bitsize); c->objecttype = getobjecttype(&gb); c->samplerate = getsamplerate(&gb, &c->samplingindex); c->chanconfig = getbits(&gb, 4); if (c->chanconfig < FFARRAYELEMS(ffmpeg4audiochannels)) c->channels = ffmpeg4audiochannels[c->chanconfig]; c->sbr = -1; c->ps = -1; if (c->objecttype == AOTSBR || (c->objecttype == AOTPS && // check for W6132 Annex YYYY draft MP3onMP4 !(showbits(&gb, 3) & 0x03 && !(showbits(&gb, 9) & 0x3F)))) { if (c->objecttype == AOTPS) c->ps = 1; c->extobjecttype = AOTSBR; c->sbr = 1; c->extsamplerate = getsamplerate(&gb, &c->extsamplingindex); c->objecttype = getobjecttype(&gb); if (c->objecttype == AOTERBSAC) c->extchanconfig = getbits(&gb, 4); } else { c->extobjecttype = AOTNULL; c->extsamplerate = 0; } specificconfigbitindex = getbitscount(&gb); if (c->objecttype == AOTALS) { skipbits(&gb, 5); if (showbitslong(&gb, 24) != MKBETAG('\\0','A','L','S')) skipbitslong(&gb, 24); specificconfigbitindex = getbitscount(&gb); if (parseconfigALS(&gb, c)) return -1; } if (c->extobjecttype != AOTSBR && syncextension) { while (getbitsleft(&gb) > 15) { if (showbits(&gb, 11) == 0x2b7) { // sync extension getbits(&gb, 11); c->extobjecttype = getobjecttype(&gb); if (c->extobjecttype == AOTSBR && (c->sbr = getbits1(&gb)) == 1) c->extsamplerate = getsamplerate(&gb, &c->extsamplingindex); if (getbitsleft(&gb) > 11 && getbits(&gb, 11) == 0x548) c->ps = getbits1(&gb); break; } else getbits1(&gb); // skip 1 bit } } //PS requires SBR if (!c->sbr) c->ps = 0; //Limit implicit PS to the HE-AACv2 Profile if ((c->ps == -1 && c->objecttype != AOTAACLC) || c->channels & ~0x01) c->ps = 0; return specificconfigbitindex; }", "target": 1}
{"func": "static avalwaysinline void vc1applyphloopfilter(VC1Context *v, int blocknum) { MpegEncContext *s = &v->s; int mbcbp = v->cbp[s->mbx - 1 - s->mbstride], blockcbp = mbcbp >> (blocknum * 4), rightcbp, mbisintra = v->isintra[s->mbx - 1 - s->mbstride], blockisintra = mbisintra >> (blocknum * 4), rightisintra; int idx, linesize = blocknum > 3 ? s->uvlinesize : s->linesize, ttblk; uint8t *dst; if (blocknum > 3) { dst = s->dest[blocknum - 3] - 8 * linesize; } else { dst = s->dest[0] + (blocknum & 1) * 8 + ((blocknum & 2) * 4 - 16) * linesize - 8; } if (s->mbx != s->mbwidth || !(blocknum & 5)) { int16t (*mv)[2]; if (blocknum > 3) { rightcbp = v->cbp[s->mbx - s->mbstride] >> (blocknum * 4); rightisintra = v->isintra[s->mbx - s->mbstride] >> (blocknum * 4); mv = &v->lumamv[s->mbx - s->mbstride - 1]; } else { rightcbp = (blocknum & 1) ? (v->cbp[s->mbx - s->mbstride] >> ((blocknum - 1) * 4)) : (mbcbp >> ((blocknum + 1) * 4)); rightisintra = (blocknum & 1) ? (v->isintra[s->mbx - s->mbstride] >> ((blocknum - 1) * 4)) : (mbisintra >> ((blocknum + 1) * 4)); mv = &s->currentpicture.motionval[0][s->blockindex[blocknum] - s->b8stride * 2 - 2]; } if (blockisintra & 1 || rightisintra & 1 || mv[0][0] != mv[1][0] || mv[0][1] != mv[1][1]) { v->vc1dsp.vc1hloopfilter8(dst, linesize, v->pq); } else { idx = ((rightcbp >> 1) | blockcbp) & 5; // FIXME check if (idx == 5) { v->vc1dsp.vc1hloopfilter8(dst, linesize, v->pq); } else if (idx) { if (idx == 1) v->vc1dsp.vc1hloopfilter4(dst + 4 * linesize, linesize, v->pq); else v->vc1dsp.vc1hloopfilter4(dst, linesize, v->pq); } } } dst -= 4; ttblk = (v->ttblk[s->mbx - s->mbstride - 1] >> (blocknum * 4)) & 0xf; if (ttblk == TT4X4 || ttblk == TT4X8) { idx = (blockcbp | (blockcbp >> 1)) & 5; if (idx == 5) { v->vc1dsp.vc1hloopfilter8(dst, linesize, v->pq); } else if (idx) { if (idx == 1) v->vc1dsp.vc1hloopfilter4(dst + linesize * 4, linesize, v->pq); else v->vc1dsp.vc1hloopfilter4(dst, linesize, v->pq); } } } ", "target": 1}
{"func": "static int readpacket(AVFormatContext *s, uint8t *buf, int rawpacketsize, uint8t **data) { AVIOContext *pb = s->pb; int len; for(;;) { len = ffioreadindirect(pb, buf, TSPACKETSIZE, data); if (len != TSPACKETSIZE) return len < 0 ? len : AVERROREOF; /* check packet sync byte */ if ((*data)[0] != 0x47) { /* find a new packet start */ avioseek(pb, -TSPACKETSIZE, SEEKCUR); if (mpegtsresync(s) < 0) return AVERROR(EAGAIN); else continue; } else { break; } } return 0; } ", "target": 1}
{"func": "int ffparsesamplerate(unsigned *ret, const char *arg, void *logctx) { char *tail; double srate = avstrtod(arg, &tail); if (*tail || srate < 1 || (int)srate != srate) { avlog(logctx, AVLOGERROR, \"Invalid sample rate '%s'\\n\", arg); return AVERROR(EINVAL); } *ret = srate; return 0; } ", "target": 0}
{"func": "static void decodeabsstore(CPUTriCoreState *env, DisasContext *ctx) { int32t op2; int32t r1; uint32t address; TCGv temp; r1 = MASKOPABSS1D(ctx->opcode); address = MASKOPABSOFF18(ctx->opcode); op2 = MASKOPABSOP2(ctx->opcode); temp = tcgconsti32(EAABSFORMAT(address)); switch (op2) { case OPC232ABSSTA: tcggenqemusttl(cpugpra[r1], temp, ctx->memidx, MOLESL); break; case OPC232ABSSTD: genst2regs64(cpugprd[r1+1], cpugprd[r1], temp, ctx); break; case OPC232ABSSTDA: genst2regs64(cpugpra[r1+1], cpugpra[r1], temp, ctx); break; case OPC232ABSSTW: tcggenqemusttl(cpugprd[r1], temp, ctx->memidx, MOLESL); break; } tcgtempfree(temp); } ", "target": 1}
{"func": "static void v9fsreaddir(void *opaque) { int32t fid; V9fsFidState *fidp; ssizet retval = 0; sizet offset = 7; uint64t initialoffset; int32t count; uint32t maxcount; V9fsPDU *pdu = opaque; V9fsState *s = pdu->s; pduunmarshal(pdu, offset, \"dqd\", &fid, &initialoffset, &maxcount); tracev9fsreaddir(pdu->tag, pdu->id, fid, initialoffset, maxcount); fidp = getfid(pdu, fid); if (fidp == NULL) { retval = -EINVAL; goto outnofid; } if (!fidp->fs.dir) { retval = -EINVAL; goto out; } if (initialoffset == 0) { v9fscorewinddir(pdu, fidp); } else { v9fscoseekdir(pdu, fidp, initialoffset); } count = v9fsdoreaddir(pdu, fidp, maxcount); if (count < 0) { retval = count; goto out; } retval = offset; retval += pdumarshal(pdu, offset, \"d\", count); retval += count; tracev9fsreaddirreturn(pdu->tag, pdu->id, count, retval); out: putfid(pdu, fidp); outnofid: completepdu(s, pdu, retval); } ", "target": 0}
{"func": "uint64t HELPER(lra)(CPUS390XState *env, uint64t addr) { CPUState *cs = CPU(s390envgetcpu(env)); uint32t cc = 0; int oldexc = cs->exceptionindex; uint64t asc = env->psw.mask & PSWMASKASC; uint64t ret; int flags; /* XXX incomplete - has more corner cases */ if (!(env->psw.mask & PSWMASK64) && (addr >> 32)) { programinterrupt(env, PGMSPECIALOP, 2); } cs->exceptionindex = oldexc; if (mmutranslate(env, addr, 0, asc, &ret, &flags)) { cc = 3; } if (cs->exceptionindex == EXCPPGM) { ret = env->intpgmcode | 0x80000000; } else { ret |= addr & ~TARGETPAGEMASK; } cs->exceptionindex = oldexc; env->ccop = cc; return ret; } ", "target": 0}
{"func": "static int bdrvcheckupdateperm(BlockDriverState *bs, uint64t newusedperm, uint64t newsharedperm, BdrvChild *ignorechild, Error **errp) { BdrvChild *c; uint64t cumulativeperms = newusedperm; uint64t cumulativesharedperms = newsharedperm; /* There is no reason why anyone couldn't tolerate writeunchanged */ assert(newsharedperm & BLKPERMWRITEUNCHANGED); QLISTFOREACH(c, &bs->parents, nextparent) { if (c == ignorechild) { continue; } if ((newusedperm & c->sharedperm) != newusedperm) { char *user = bdrvchilduserdesc(c); char *permnames = bdrvpermnames(newusedperm & ~c->sharedperm); errorsetg(errp, \"Conflicts with use by %s as '%s', which does not \" \"allow '%s' on %s\", user, c->name, permnames, bdrvgetnodename(c->bs)); gfree(user); gfree(permnames); return -EPERM; } if ((c->perm & newsharedperm) != c->perm) { char *user = bdrvchilduserdesc(c); char *permnames = bdrvpermnames(c->perm & ~newsharedperm); errorsetg(errp, \"Conflicts with use by %s as '%s', which uses \" \"'%s' on %s\", user, c->name, permnames, bdrvgetnodename(c->bs)); gfree(user); gfree(permnames); return -EPERM; } cumulativeperms |= c->perm; cumulativesharedperms &= c->sharedperm; } return bdrvcheckperm(bs, cumulativeperms, cumulativesharedperms, errp); } ", "target": 0}
{"func": "static void monitorprotocolemitter(Monitor *mon, QObject *data) { QDict *qmp; qmp = qdictnew(); if (!monitorhaserror(mon)) { /* success response */ if (data) { assert(qobjecttype(data) == QTYPEQDICT); qobjectincref(data); qdictputobj(qmp, \"return\", data); } else { /* return an empty QDict by default */ qdictput(qmp, \"return\", qdictnew()); } } else { /* error response */ qdictput(mon->error->error, \"desc\", qerrorhuman(mon->error)); qdictput(qmp, \"error\", mon->error->error); QINCREF(mon->error->error); QDECREF(mon->error); mon->error = NULL; } if (mon->mc->id) { qdictputobj(qmp, \"id\", mon->mc->id); mon->mc->id = NULL; } monitorjsonemitter(mon, QOBJECT(qmp)); QDECREF(qmp); } ", "target": 0}
{"func": "static inline int decodevuiparameters(H264Context *h, SPS *sps) { int aspectratioinfopresentflag; unsigned int aspectratioidc; aspectratioinfopresentflag = getbits1(&h->gb); if (aspectratioinfopresentflag) { aspectratioidc = getbits(&h->gb, 8); if (aspectratioidc == EXTENDEDSAR) { sps->sar.num = getbits(&h->gb, 16); sps->sar.den = getbits(&h->gb, 16); } else if (aspectratioidc < FFARRAYELEMS(pixelaspect)) { sps->sar = pixelaspect[aspectratioidc]; } else { avlog(h->avctx, AVLOGERROR, \"illegal aspect ratio\\n\"); return AVERRORINVALIDDATA; } } else { sps->sar.num = sps->sar.den = 0; } if (getbits1(&h->gb)) /* overscaninfopresentflag */ getbits1(&h->gb); /* overscanappropriateflag */ sps->videosignaltypepresentflag = getbits1(&h->gb); if (sps->videosignaltypepresentflag) { getbits(&h->gb, 3); /* videoformat */ sps->fullrange = getbits1(&h->gb); /* videofullrangeflag */ sps->colourdescriptionpresentflag = getbits1(&h->gb); if (sps->colourdescriptionpresentflag) { sps->colorprimaries = getbits(&h->gb, 8); /* colourprimaries */ sps->colortrc = getbits(&h->gb, 8); /* transfercharacteristics */ sps->colorspace = getbits(&h->gb, 8); /* matrixcoefficients */ if (sps->colorprimaries >= AVCOLPRINB) sps->colorprimaries = AVCOLPRIUNSPECIFIED; if (sps->colortrc >= AVCOLTRCNB) sps->colortrc = AVCOLTRCUNSPECIFIED; if (sps->colorspace >= AVCOLSPCNB) sps->colorspace = AVCOLSPCUNSPECIFIED; } } /* chromalocationinfopresentflag */ if (getbits1(&h->gb)) { /* chromasamplelocationtypetopfield */ h->avctx->chromasamplelocation = getuegolomb(&h->gb) + 1; getuegolomb(&h->gb); /* chromasamplelocationtypebottomfield */ } sps->timinginfopresentflag = getbits1(&h->gb); if (sps->timinginfopresentflag) { sps->numunitsintick = getbitslong(&h->gb, 32); sps->timescale = getbitslong(&h->gb, 32); if (!sps->numunitsintick || !sps->timescale) { avlog(h->avctx, AVLOGERROR, \"timescale/numunitsintick invalid or unsupported (%\"PRIu32\"/%\"PRIu32\")\\n\", sps->timescale, sps->numunitsintick); return AVERRORINVALIDDATA; } sps->fixedframerateflag = getbits1(&h->gb); } sps->nalhrdparameterspresentflag = getbits1(&h->gb); if (sps->nalhrdparameterspresentflag) if (decodehrdparameters(h, sps) < 0) return AVERRORINVALIDDATA; sps->vclhrdparameterspresentflag = getbits1(&h->gb); if (sps->vclhrdparameterspresentflag) if (decodehrdparameters(h, sps) < 0) return AVERRORINVALIDDATA; if (sps->nalhrdparameterspresentflag || sps->vclhrdparameterspresentflag) getbits1(&h->gb); /* lowdelayhrdflag */ sps->picstructpresentflag = getbits1(&h->gb); sps->bitstreamrestrictionflag = getbits1(&h->gb); if (sps->bitstreamrestrictionflag) { getbits1(&h->gb); /* motionvectorsoverpicboundariesflag */ getuegolomb(&h->gb); /* maxbytesperpicdenom */ getuegolomb(&h->gb); /* maxbitspermbdenom */ getuegolomb(&h->gb); /* log2maxmvlengthhorizontal */ getuegolomb(&h->gb); /* log2maxmvlengthvertical */ sps->numreorderframes = getuegolomb(&h->gb); getuegolomb(&h->gb); /*maxdecframebuffering*/ if (getbitsleft(&h->gb) < 0) { sps->numreorderframes = 0; sps->bitstreamrestrictionflag = 0; } if (sps->numreorderframes > 16U /* maxdecframebuffering || maxdecframebuffering > 16 */) { avlog(h->avctx, AVLOGERROR, \"Clipping illegal numreorderframes %d\\n\", sps->numreorderframes); sps->numreorderframes = 16; return AVERRORINVALIDDATA; } } if (getbitsleft(&h->gb) < 0) { avlog(h->avctx, AVLOGERROR, \"Overread VUI by %d bits\\n\", -getbitsleft(&h->gb)); return AVERRORINVALIDDATA; } return 0; } ", "target": 0}
{"func": "int bdrvwritecompressed(BlockDriverState *bs, int64t sectornum, const uint8t *buf, int nbsectors) { BlockDriver *drv = bs->drv; int ret; if (!drv) { return -ENOMEDIUM; } if (!drv->bdrvwritecompressed) { return -ENOTSUP; } ret = bdrvcheckrequest(bs, sectornum, nbsectors); if (ret < 0) { return ret; } assert(QLISTEMPTY(&bs->dirtybitmaps)); return drv->bdrvwritecompressed(bs, sectornum, buf, nbsectors); } ", "target": 0}
{"func": "static int usbhosthandlecontrol(USBDevice *dev, USBPacket *p, int request, int value, int index, int length, uint8t *data) { USBHostDevice *s = DOUPCAST(USBHostDevice, dev, dev); struct usbdevfsurb *urb; AsyncURB *aurb; int ret; /* * Process certain standard device requests. * These are infrequent and are processed synchronously. */ /* Note request is (bRequestType << 8) | bRequest */ traceusbhostreqcontrol(s->busnum, s->addr, request, value, index); switch (request) { case DeviceOutRequest | USBREQSETADDRESS: return usbhostsetaddress(s, value); case DeviceOutRequest | USBREQSETCONFIGURATION: return usbhostsetconfig(s, value & 0xff); case InterfaceOutRequest | USBREQSETINTERFACE: return usbhostsetinterface(s, index, value); } /* The rest are asynchronous */ if (length > sizeof(dev->databuf)) { fprintf(stderr, \"husb: ctrl buffer too small (%d > %zu)\\n\", length, sizeof(dev->databuf)); return USBRETSTALL; } aurb = asyncalloc(s); aurb->packet = p; /* * Setup ctrl transfer. * * s->ctrl is laid out such that data buffer immediately follows * 'req' struct which is exactly what usbdevfs expects. */ urb = &aurb->urb; urb->type = USBDEVFSURBTYPECONTROL; urb->endpoint = p->devep; urb->buffer = &dev->setupbuf; urb->bufferlength = length + 8; urb->usercontext = s; traceusbhosturbsubmit(s->busnum, s->addr, aurb, urb->bufferlength, aurb->more); ret = ioctl(s->fd, USBDEVFSSUBMITURB, urb); DPRINTF(\"husb: submit ctrl. len %u aurb %p\\n\", urb->bufferlength, aurb); if (ret < 0) { DPRINTF(\"husb: submit failed. errno %d\\n\", errno); asyncfree(aurb); switch(errno) { case ETIMEDOUT: return USBRETNAK; case EPIPE: default: return USBRETSTALL; } } return USBRETASYNC; } ", "target": 0}
{"func": "static int dshowreadheader(AVFormatContext *avctx) { struct dshowctx *ctx = avctx->privdata; IGraphBuilder *graph = NULL; ICreateDevEnum *devenum = NULL; IMediaControl *control = NULL; IMediaEvent *mediaevent = NULL; HANDLE mediaeventhandle; HANDLE proc; int ret = AVERROR(EIO); int r; CoInitialize(0); if (!ctx->listdevices && !parsedevicename(avctx)) { avlog(avctx, AVLOGERROR, \"Malformed dshow input string.\\n\"); goto error; } ctx->videocodecid = avctx->videocodecid ? avctx->videocodecid : AVCODECIDRAWVIDEO; if (ctx->pixelformat != AVPIXFMTNONE) { if (ctx->videocodecid != AVCODECIDRAWVIDEO) { avlog(avctx, AVLOGERROR, \"Pixel format may only be set when \" \"video codec is not set or set to rawvideo\\n\"); ret = AVERROR(EINVAL); goto error; } } if (ctx->framerate) { r = avparsevideorate(&ctx->requestedframerate, ctx->framerate); if (r < 0) { avlog(avctx, AVLOGERROR, \"Could not parse framerate '%s'.\\n\", ctx->framerate); goto error; } } r = CoCreateInstance(&CLSIDFilterGraph, NULL, CLSCTXINPROCSERVER, &IIDIGraphBuilder, (void **) &graph); if (r != SOK) { avlog(avctx, AVLOGERROR, \"Could not create capture graph.\\n\"); goto error; } ctx->graph = graph; r = CoCreateInstance(&CLSIDSystemDeviceEnum, NULL, CLSCTXINPROCSERVER, &IIDICreateDevEnum, (void **) &devenum); if (r != SOK) { avlog(avctx, AVLOGERROR, \"Could not enumerate system devices.\\n\"); goto error; } if (ctx->listdevices) { avlog(avctx, AVLOGINFO, \"DirectShow video devices\\n\"); dshowcycledevices(avctx, devenum, VideoDevice, NULL); avlog(avctx, AVLOGINFO, \"DirectShow audio devices\\n\"); dshowcycledevices(avctx, devenum, AudioDevice, NULL); ret = AVERROREXIT; goto error; } if (ctx->listoptions) { if (ctx->devicename[VideoDevice]) dshowlistdeviceoptions(avctx, devenum, VideoDevice); if (ctx->devicename[AudioDevice]) dshowlistdeviceoptions(avctx, devenum, AudioDevice); ret = AVERROREXIT; goto error; } if (ctx->devicename[VideoDevice]) { if ((r = dshowopendevice(avctx, devenum, VideoDevice)) < 0 || (r = dshowadddevice(avctx, VideoDevice)) < 0) { ret = r; goto error; } } if (ctx->devicename[AudioDevice]) { if ((r = dshowopendevice(avctx, devenum, AudioDevice)) < 0 || (r = dshowadddevice(avctx, AudioDevice)) < 0) { ret = r; goto error; } } ctx->mutex = CreateMutex(NULL, 0, NULL); if (!ctx->mutex) { avlog(avctx, AVLOGERROR, \"Could not create Mutex\\n\"); goto error; } ctx->event[1] = CreateEvent(NULL, 1, 0, NULL); if (!ctx->event[1]) { avlog(avctx, AVLOGERROR, \"Could not create Event\\n\"); goto error; } r = IGraphBuilderQueryInterface(graph, &IIDIMediaControl, (void **) &control); if (r != SOK) { avlog(avctx, AVLOGERROR, \"Could not get media control.\\n\"); goto error; } ctx->control = control; r = IGraphBuilderQueryInterface(graph, &IIDIMediaEvent, (void **) &mediaevent); if (r != SOK) { avlog(avctx, AVLOGERROR, \"Could not get media event.\\n\"); goto error; } ctx->mediaevent = mediaevent; r = IMediaEventGetEventHandle(mediaevent, (void *) &mediaeventhandle); if (r != SOK) { avlog(avctx, AVLOGERROR, \"Could not get media event handle.\\n\"); goto error; } proc = GetCurrentProcess(); r = DuplicateHandle(proc, mediaeventhandle, proc, &ctx->event[0], 0, 0, DUPLICATESAMEACCESS); if (!r) { avlog(avctx, AVLOGERROR, \"Could not duplicate media event handle.\\n\"); goto error; } r = IMediaControlRun(control); if (r == SFALSE) { OAFilterState pfs; r = IMediaControlGetState(control, 0, &pfs); } if (r != SOK) { avlog(avctx, AVLOGERROR, \"Could not run filter\\n\"); goto error; } ret = 0; error: if (devenum) ICreateDevEnumRelease(devenum); if (ret < 0) dshowreadclose(avctx); return ret; } ", "target": 1}
{"func": "static inline void s390machineinitfn(Object *obj) { objectpropertyaddbool(obj, \"aes-key-wrap\", machinegetaeskeywrap, machinesetaeskeywrap, NULL); objectpropertysetdescription(obj, \"aes-key-wrap\", \"enable/disable AES key wrapping using the CPACF wrapping key\", objectpropertysetbool(obj, true, \"aes-key-wrap\", NULL); objectpropertyaddbool(obj, \"dea-key-wrap\", machinegetdeakeywrap, machinesetdeakeywrap, NULL); objectpropertysetdescription(obj, \"dea-key-wrap\", \"enable/disable DEA key wrapping using the CPACF wrapping key\", objectpropertysetbool(obj, true, \"dea-key-wrap\", NULL); objectpropertyaddstr(obj, \"loadparm\", machinegetloadparm, machinesetloadparm, NULL); objectpropertysetdescription(obj, \"loadparm\", \"Up to 8 chars in set of [A-Za-z0-9. ] (lower case chars converted\" \" to upper case) to pass to machine loader, boot manager,\" \" and guest kernel\", }", "target": 1}
{"func": "static int ljpegdecodergbscan(MJpegDecodeContext *s, int nbcomponents, int predictor, int pointtransform) { int i, mbx, mby; uint16t (*buffer)[4]; int left[4], top[4], topleft[4]; const int linesize = s->linesize[0]; const int mask = ((1 << s->bits) - 1) << pointtransform; int resyncmby = 0; int resyncmbx = 0; if (s->nbcomponents != 3 && s->nbcomponents != 4) return AVERRORINVALIDDATA; if (s->vmax != 1 || s->hmax != 1 || !s->lossless) return AVERRORINVALIDDATA; s->restartcount = s->restartinterval; avfastmalloc(&s->ljpegbuffer, &s->ljpegbuffersize, (unsigned)s->mbwidth * 4 * sizeof(s->ljpegbuffer[0][0])); buffer = s->ljpegbuffer; for (i = 0; i < 4; i++) buffer[0][i] = 1 << (s->bits - 1); for (mby = 0; mby < s->mbheight; mby++) { uint8t *ptr = s->pictureptr->data[0] + (linesize * mby); if (s->interlaced && s->bottomfield) ptr += linesize >> 1; for (i = 0; i < 4; i++) top[i] = left[i] = topleft[i] = buffer[0][i]; for (mbx = 0; mbx < s->mbwidth; mbx++) { int modifiedpredictor = predictor; if (s->restartinterval && !s->restartcount){ s->restartcount = s->restartinterval; resyncmbx = mbx; resyncmby = mby; for(i=0; i<4; i++) top[i] = left[i]= topleft[i]= 1 << (s->bits - 1); } if (mby == resyncmby || mby == resyncmby+1 && mbx < resyncmbx || !mbx) modifiedpredictor = 1; for (i=0;i<nbcomponents;i++) { int pred, dc; topleft[i] = top[i]; top[i] = buffer[mbx][i]; PREDICT(pred, topleft[i], top[i], left[i], modifiedpredictor); dc = mjpegdecodedc(s, s->dcindex[i]); if(dc == 0xFFFFF) return -1; left[i] = buffer[mbx][i] = mask & (pred + (dc << pointtransform)); } if (s->restartinterval && !--s->restartcount) { aligngetbits(&s->gb); skipbits(&s->gb, 16); /* skip RSTn */ } } if (s->rct && s->nbcomponents == 4) { for (mbx = 0; mbx < s->mbwidth; mbx++) { ptr[4*mbx + 2] = buffer[mbx][0] - ((buffer[mbx][1] + buffer[mbx][2] - 0x200) >> 2); ptr[4*mbx + 1] = buffer[mbx][1] + ptr[4*mbx + 2]; ptr[4*mbx + 3] = buffer[mbx][2] + ptr[4*mbx + 2]; ptr[4*mbx + 0] = buffer[mbx][3]; } } else if (s->nbcomponents == 4) { for(i=0; i<nbcomponents; i++) { int c= s->compindex[i]; if (s->bits <= 8) { for(mbx = 0; mbx < s->mbwidth; mbx++) { ptr[4*mbx+3-c] = buffer[mbx][i]; } } else if(s->bits == 9) { return AVERRORPATCHWELCOME; } else { for(mbx = 0; mbx < s->mbwidth; mbx++) { ((uint16t*)ptr)[4*mbx+c] = buffer[mbx][i]; } } } } else if (s->rct) { for (mbx = 0; mbx < s->mbwidth; mbx++) { ptr[3*mbx + 1] = buffer[mbx][0] - ((buffer[mbx][1] + buffer[mbx][2] - 0x200) >> 2); ptr[3*mbx + 0] = buffer[mbx][1] + ptr[3*mbx + 1]; ptr[3*mbx + 2] = buffer[mbx][2] + ptr[3*mbx + 1]; } } else if (s->pegasusrct) { for (mbx = 0; mbx < s->mbwidth; mbx++) { ptr[3*mbx + 1] = buffer[mbx][0] - ((buffer[mbx][1] + buffer[mbx][2]) >> 2); ptr[3*mbx + 0] = buffer[mbx][1] + ptr[3*mbx + 1]; ptr[3*mbx + 2] = buffer[mbx][2] + ptr[3*mbx + 1]; } } else { for(i=0; i<nbcomponents; i++) { int c= s->compindex[i]; if (s->bits <= 8) { for(mbx = 0; mbx < s->mbwidth; mbx++) { ptr[3*mbx+2-c] = buffer[mbx][i]; } } else if(s->bits == 9) { return AVERRORPATCHWELCOME; } else { for(mbx = 0; mbx < s->mbwidth; mbx++) { ((uint16t*)ptr)[3*mbx+2-c] = buffer[mbx][i]; } } } } } return 0; } ", "target": 0}
{"func": "static void qemuspicedisplayinitone(QemuConsole *con) { SimpleSpiceDisplay *ssd = gnew0(SimpleSpiceDisplay, 1); qemuspicedisplayinitcommon(ssd); ssd->qxl.base.sif = &dpyinterface.base; qemuspiceadddisplayinterface(&ssd->qxl, con); assert(ssd->worker); qemuspicecreatehostmemslot(ssd); ssd->dcl.ops = &displaylistenerops; ssd->dcl.con = con; registerdisplaychangelistener(&ssd->dcl); } ", "target": 1}
{"func": "int ffindexsearchtimestamp(const AVIndexEntry *entries, int nbentries, int64t wantedtimestamp, int flags) { int a, b, m; int64t timestamp; a = -1; b = nbentries; // Optimize appending index entries at the end. if (b && entries[b - 1].timestamp < wantedtimestamp) a = b - 1; while (b - a > 1) { m = (a + b) >> 1; // Search for the next non-discarded packet. while ((entries[m].flags & AVINDEXDISCARDFRAME) && m < b) { m++; if (m == b && entries[m].timestamp >= wantedtimestamp) { m = b - 1; break; } } timestamp = entries[m].timestamp; if (timestamp >= wantedtimestamp) b = m; if (timestamp <= wantedtimestamp) a = m; } m = (flags & AVSEEKFLAGBACKWARD) ? a : b; if (!(flags & AVSEEKFLAGANY)) while (m >= 0 && m < nbentries && !(entries[m].flags & AVINDEXKEYFRAME)) m += (flags & AVSEEKFLAGBACKWARD) ? -1 : 1; if (m == nbentries) return -1; return m; } ", "target": 0}
{"func": "static int codecgetbuffer(AVCodecContext *s, AVFrame *frame) { InputStream *ist = s->opaque; FrameBuffer *buf; int ret, i; if (!ist->bufferpool && (ret = allocbuffer(s, ist, &ist->bufferpool)) < 0) return ret; buf = ist->bufferpool; ist->bufferpool = buf->next; buf->next = NULL; if (buf->w != s->width || buf->h != s->height || buf->pixfmt != s->pixfmt) { avfreep(&buf->base[0]); avfree(buf); ist->dr1 = 0; if ((ret = allocbuffer(s, ist, &buf)) < 0) return ret; } buf->refcount++; frame->opaque = buf; frame->type = FFBUFFERTYPEUSER; frame->extendeddata = frame->data; frame->pktpts = s->pkt ? s->pkt->pts : AVNOPTSVALUE; for (i = 0; i < FFARRAYELEMS(buf->data); i++) { frame->base[i] = buf->base[i]; // XXX h264.c uses base though it shouldn't frame->data[i] = buf->data[i]; frame->linesize[i] = buf->linesize[i]; } return 0; }", "target": 1}
{"func": "static int filterframe(AVFilterLink *inlink, AVFrame *inpic) { AVFilterContext *ctx = inlink->dst; HisteqContext *histeq = ctx->priv; AVFilterLink *outlink = ctx->outputs[0]; int strength = histeq->strength * 1000; int intensity = histeq->intensity * 1000; int x, y, i, luthi, lutlo, lut, luma, oluma, m; AVFrame *outpic; unsigned int r, g, b, jran; uint8t *src, *dst; outpic = ffgetvideobuffer(outlink, outlink->w, outlink->h); if (!outpic) { avframefree(&inpic); return AVERROR(ENOMEM); } avframecopyprops(outpic, inpic); /* Seed random generator for antibanding. */ jran = LCGSEED; /* Calculate and store the luminance and calculate the global histogram based on the luminance. */ memset(histeq->inhistogram, 0, sizeof(histeq->inhistogram)); src = inpic->data[0]; dst = outpic->data[0]; for (y = 0; y < inlink->h; y++) { for (x = 0; x < inlink->w * histeq->bpp; x += histeq->bpp) { GETRGBVALUES(r, g, b, src, histeq->rgbamap); luma = (55 * r + 182 * g + 19 * b) >> 8; dst[x + histeq->rgbamap[A]] = luma; histeq->inhistogram[luma]++; } src += inpic->linesize[0]; dst += outpic->linesize[0]; } #ifdef DEBUG for (x = 0; x < 256; x++) avdlog(ctx, \"in[%d]: %u\\n\", x, histeq->inhistogram[x]); #endif /* Calculate the lookup table. */ histeq->LUT[0] = histeq->inhistogram[0]; /* Accumulate */ for (x = 1; x < 256; x++) histeq->LUT[x] = histeq->LUT[x-1] + histeq->inhistogram[x]; /* Normalize */ for (x = 0; x < 256; x++) histeq->LUT[x] = (histeq->LUT[x] * intensity) / (inlink->h * inlink->w); /* Adjust the LUT based on the selected strength. This is an alpha mix of the calculated LUT and a linear LUT with gain 1. */ for (x = 0; x < 256; x++) histeq->LUT[x] = (strength * histeq->LUT[x]) / 255 + ((255 - strength) * x) / 255; /* Output the equalized frame. */ memset(histeq->outhistogram, 0, sizeof(histeq->outhistogram)); src = inpic->data[0]; dst = outpic->data[0]; for (y = 0; y < inlink->h; y++) { for (x = 0; x < inlink->w * histeq->bpp; x += histeq->bpp) { luma = dst[x + histeq->rgbamap[A]]; if (luma == 0) { for (i = 0; i < histeq->bpp; ++i) dst[x + i] = 0; histeq->outhistogram[0]++; } else { lut = histeq->LUT[luma]; if (histeq->antibanding != HISTEQANTIBANDINGNONE) { if (luma > 0) { lutlo = histeq->antibanding == HISTEQANTIBANDINGWEAK ? (histeq->LUT[luma] + histeq->LUT[luma - 1]) / 2 : histeq->LUT[luma - 1]; } else lutlo = lut; if (luma < 255) { luthi = (histeq->antibanding == HISTEQANTIBANDINGWEAK) ? (histeq->LUT[luma] + histeq->LUT[luma + 1]) / 2 : histeq->LUT[luma + 1]; } else luthi = lut; if (lutlo != luthi) { jran = LCG(jran); lut = lutlo + ((luthi - lutlo + 1) * jran) / LCGM; } } GETRGBVALUES(r, g, b, src, histeq->rgbamap); if (((m = FFMAX3(r, g, b)) * lut) / luma > 255) { r = (r * 255) / m; g = (g * 255) / m; b = (b * 255) / m; } else { r = (r * lut) / luma; g = (g * lut) / luma; b = (b * lut) / luma; } dst[x + histeq->rgbamap[R]] = r; dst[x + histeq->rgbamap[G]] = g; dst[x + histeq->rgbamap[B]] = b; oluma = (55 * r + 182 * g + 19 * b) >> 8; histeq->outhistogram[oluma]++; } } src += inpic->linesize[0]; dst += outpic->linesize[0]; } #ifdef DEBUG for (x = 0; x < 256; x++) avdlog(ctx, \"out[%d]: %u\\n\", x, histeq->outhistogram[x]); #endif avframefree(&inpic); return fffilterframe(outlink, outpic); } ", "target": 0}
{"func": "static void testvisitorinnativelistint32(TestInputVisitorData *data, const void *unused) { testnativelistintegerhelper(data, unused, USERDEFNATIVELISTUNIONKINDS32); } ", "target": 0}
{"func": "static void nbdtrip(void *opaque) { NBDClient *client = opaque; NBDExport *exp = client->exp; NBDRequest *req; struct nbdrequest request; struct nbdreply reply; ssizet ret; uint32t command; TRACE(\"Reading request.\"); if (client->closing) { return; } req = nbdrequestget(client); ret = nbdcoreceiverequest(req, &request); if (ret == -EAGAIN) { goto done; } if (ret == -EIO) { goto out; } reply.handle = request.handle; reply.error = 0; if (ret < 0) { reply.error = -ret; goto errorreply; } command = request.type & NBDCMDMASKCOMMAND; if (command != NBDCMDDISC && (request.from + request.len) > exp->size) { LOG(\"From: %\" PRIu64 \", Len: %u, Size: %\" PRIu64 \", Offset: %\" PRIu64 \"\\n\", request.from, request.len, (uint64t)exp->size, (uint64t)exp->devoffset); LOG(\"requested operation past EOF--bad client?\"); goto invalidrequest; } if (client->closing) { /* * The client may be closed when we are blocked in * nbdcoreceiverequest() */ goto done; } switch (command) { case NBDCMDREAD: TRACE(\"Request type is READ\"); if (request.type & NBDCMDFLAGFUA) { ret = blkcoflush(exp->blk); if (ret < 0) { LOG(\"flush failed\"); reply.error = -ret; goto errorreply; } } ret = blkpread(exp->blk, request.from + exp->devoffset, req->data, request.len); if (ret < 0) { LOG(\"reading from file failed\"); reply.error = -ret; goto errorreply; } TRACE(\"Read %u byte(s)\", request.len); if (nbdcosendreply(req, &reply, request.len) < 0) goto out; break; case NBDCMDWRITE: TRACE(\"Request type is WRITE\"); if (exp->nbdflags & NBDFLAGREADONLY) { TRACE(\"Server is read-only, return error\"); reply.error = EROFS; goto errorreply; } TRACE(\"Writing to device\"); ret = blkpwrite(exp->blk, request.from + exp->devoffset, req->data, request.len, 0); if (ret < 0) { LOG(\"writing to file failed\"); reply.error = -ret; goto errorreply; } if (request.type & NBDCMDFLAGFUA) { ret = blkcoflush(exp->blk); if (ret < 0) { LOG(\"flush failed\"); reply.error = -ret; goto errorreply; } } if (nbdcosendreply(req, &reply, 0) < 0) { goto out; } break; case NBDCMDDISC: TRACE(\"Request type is DISCONNECT\"); errno = 0; goto out; case NBDCMDFLUSH: TRACE(\"Request type is FLUSH\"); ret = blkcoflush(exp->blk); if (ret < 0) { LOG(\"flush failed\"); reply.error = -ret; } if (nbdcosendreply(req, &reply, 0) < 0) { goto out; } break; case NBDCMDTRIM: TRACE(\"Request type is TRIM\"); ret = blkcodiscard(exp->blk, (request.from + exp->devoffset) / BDRVSECTORSIZE, request.len / BDRVSECTORSIZE); if (ret < 0) { LOG(\"discard failed\"); reply.error = -ret; } if (nbdcosendreply(req, &reply, 0) < 0) { goto out; } break; default: LOG(\"invalid request type (%u) received\", request.type); invalidrequest: reply.error = EINVAL; errorreply: if (nbdcosendreply(req, &reply, 0) < 0) { goto out; } break; } TRACE(\"Request/Reply complete\"); done: nbdrequestput(req); return; out: nbdrequestput(req); clientclose(client); } ", "target": 0}
{"func": "void qemuregisterreset(QEMUResetHandler *func, void *opaque) { QEMUResetEntry *re = qemumallocz(sizeof(QEMUResetEntry)); re->func = func; re->opaque = opaque; TAILQINSERTTAIL(&resethandlers, re, entry); } ", "target": 0}
{"func": "void stlphysnotdirty(hwaddr addr, uint32t val) { uint8t *ptr; MemoryRegionSection *section; section = physpagefind(addressspacememory.dispatch, addr >> TARGETPAGEBITS); if (!memoryregionisram(section->mr) || section->readonly) { addr = memoryregionsectionaddr(section, addr); if (memoryregionisram(section->mr)) { section = &physsections[physsectionrom]; } iomemwrite(section->mr, addr, val, 4); } else { unsigned long addr1 = (memoryregiongetramaddr(section->mr) & TARGETPAGEMASK) + memoryregionsectionaddr(section, addr); ptr = qemugetramptr(addr1); stlp(ptr, val); if (unlikely(inmigration)) { if (!cpuphysicalmemoryisdirty(addr1)) { /* invalidate code */ tbinvalidatephyspagerange(addr1, addr1 + 4, 0); /* set dirty bit */ cpuphysicalmemorysetdirtyflags( addr1, (0xff & ~CODEDIRTYFLAG)); } } } } ", "target": 0}
{"func": "static void computeantialiasfloat(MPADecodeContext *s, GranuleDef *g) { float *ptr; int n, i; /* we antialias only \"long\" bands */ if (g->blocktype == 2) { if (!g->switchpoint) return; /* XXX: check this for 8000Hz case */ n = 1; } else { n = SBLIMIT - 1; } ptr = g->sbhybrid + 18; for(i = n;i > 0;i--) { float tmp0, tmp1; float *csa = &csatablefloat[0][0]; #define FLOATAA(j)\\ tmp0= ptr[-1-j];\\ tmp1= ptr[ j];\\ ptr[-1-j] = tmp0 * csa[0+4*j] - tmp1 * csa[1+4*j];\\ ptr[ j] = tmp0 * csa[1+4*j] + tmp1 * csa[0+4*j]; FLOATAA(0) FLOATAA(1) FLOATAA(2) FLOATAA(3) FLOATAA(4) FLOATAA(5) FLOATAA(6) FLOATAA(7) ptr += 18; } } ", "target": 0}
{"func": "PCIBus *i440fxinit(PCII440FXState **pi440fxstate, int *piix3devfn, qemuirq *pic, int ramsize) { DeviceState *dev; PCIBus *b; PCIDevice *d; I440FXState *s; PIIX3State *piix3; dev = qdevcreate(NULL, \"i440FX-pcihost\"); s = FROMSYSBUS(I440FXState, sysbusfromqdev(dev)); b = pcibusnew(&s->busdev.qdev, NULL, 0); s->bus = b; qdevinitnofail(dev); d = pcicreatesimple(b, 0, \"i440FX\"); *pi440fxstate = DOUPCAST(PCII440FXState, dev, d); piix3 = DOUPCAST(PIIX3State, dev, pcicreatesimple(b, -1, \"PIIX3\")); piix3->pic = pic; pcibusirqs(b, piix3setirq, pcislotgetpirq, piix3, 4); (*pi440fxstate)->piix3 = piix3; *piix3devfn = piix3->dev.devfn; ramsize = ramsize / 8 / 1024 / 1024; if (ramsize > 255) ramsize = 255; (*pi440fxstate)->dev.config[0x57]=ramsize; return b; } ", "target": 1}
{"func": "uint64t helpercvttqc(CPUAlphaState *env, uint64t a) { return inlinecvttq(env, a, floatroundtozero, 0); } ", "target": 1}
{"func": "int ffdcacoreparse(DCACoreDecoder *s, uint8t *data, int size) { int ret; s->extaudiomask = 0; s->xchpos = s->xxchpos = s->x96pos = 0; if ((ret = initgetbits8(&s->gb, data, size)) < 0) return ret; s->gbin = s->gb; if ((ret = parseframeheader(s)) < 0) return ret; if ((ret = allocsamplebuffer(s)) < 0) return ret; if ((ret = parseframedata(s, HEADERCORE, 0)) < 0) return ret; if ((ret = parseoptionalinfo(s)) < 0) return ret; // Workaround for DTS in WAV if (s->framesize > size && s->framesize < size + 4) s->framesize = size; if (ffdcaseekbits(&s->gb, s->framesize * 8)) { avlog(s->avctx, AVLOGERROR, \"Read past end of core frame\\n\"); if (s->avctx->errrecognition & AVEFEXPLODE) return AVERRORINVALIDDATA; } return 0; } ", "target": 0}
{"func": "static void genmulu(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb) { TCGv srcy = tcgtempnew(); tcggenmuls2tl(dest, srcy, srca, srcb); tcggensetconditl(TCGCONDNE, srcy, srcy, 0); tcggendeposittl(cpusr, cpusr, srcy, ctz32(SRCY), 1); genovecy(dc, srcy); tcgtempfree(srcy); } ", "target": 1}
{"func": "static int decodeinitmp3on4(AVCodecContext * avctx) { MP3On4DecodeContext *s = avctx->privdata; int i; if ((avctx->extradatasize < 2) || (avctx->extradata == NULL)) { avlog(avctx, AVLOGERROR, \"Codec extradata missing or too short.\\n\"); return -1; } s->chancfg = (((unsigned char *)avctx->extradata)[1] >> 3) & 0x0f; s->frames = mp3Frames[s->chancfg]; if(!s->frames) { avlog(avctx, AVLOGERROR, \"Invalid channel config number.\\n\"); return -1; } avctx->channels = mp3Channels[s->chancfg]; /* Init the first mp3 decoder in standard way, so that all tables get builded * We replace avctx->privdata with the context of the first decoder so that * decodeinit() does not have to be changed. * Other decoders will be inited here copying data from the first context */ // Allocate zeroed memory for the first decoder context s->mp3decctx[0] = avmallocz(sizeof(MPADecodeContext)); // Put decoder context in place to make initdecode() happy avctx->privdata = s->mp3decctx[0]; decodeinit(avctx); // Restore mp3on4 context pointer avctx->privdata = s; s->mp3decctx[0]->adumode = 1; // Set adu mode /* Create a separate codec/context for each frame (first is already ok). * Each frame is 1 or 2 channels - up to 5 frames allowed */ for (i = 1; i < s->frames; i++) { s->mp3decctx[i] = avmallocz(sizeof(MPADecodeContext)); s->mp3decctx[i]->computeantialias = s->mp3decctx[0]->computeantialias; s->mp3decctx[i]->adumode = 1; s->mp3decctx[i]->avctx = avctx; } return 0; } ", "target": 0}
{"func": "syscall4(int,sysutimensat,int,dirfd,const char *,pathname, const struct timespec *,tsp,int,flags) #endif #endif /* CONFIGUTIMENSAT */ #ifdef CONFIGINOTIFY #include <sys/inotify.h> #if defined(TARGETNRinotifyinit) && defined(NRinotifyinit) static int sysinotifyinit(void) { return (inotifyinit()); } ", "target": 0}
{"func": "static void curlreadvbhcb(void *p) { CURLState *state; int running; CURLAIOCB *acb = p; BDRVCURLState *s = acb->common.bs->opaque; qemubhdelete(acb->bh); acb->bh = NULL; sizet start = acb->sectornum * SECTORSIZE; sizet end; // In case we have the requested data already (e.g. read-ahead), // we can just call the callback and be done. switch (curlfindbuf(s, start, acb->nbsectors * SECTORSIZE, acb)) { case FINDRETOK: qemuaiorelease(acb); // fall through case FINDRETWAIT: return; default: break; } // No cache found, so let's start a new request state = curlinitstate(s); if (!state) { acb->common.cb(acb->common.opaque, -EIO); qemuaiorelease(acb); return; } acb->start = 0; acb->end = (acb->nbsectors * SECTORSIZE); state->bufoff = 0; gfree(state->origbuf); state->bufstart = start; state->buflen = acb->end + s->readaheadsize; end = MIN(start + state->buflen, s->len) - 1; state->origbuf = gmalloc(state->buflen); state->acb[0] = acb; snprintf(state->range, 127, \"%zd-%zd\", start, end); DPRINTF(\"CURL (AIO): Reading %d at %zd (%s)\\n\", (acb->nbsectors * SECTORSIZE), start, state->range); curleasysetopt(state->curl, CURLOPTRANGE, state->range); curlmultiaddhandle(s->multi, state->curl); /* Tell curl it needs to kick things off */ curlmultisocketaction(s->multi, CURLSOCKETTIMEOUT, 0, &running); } ", "target": 1}
{"func": "static int dnxhdencoderdo(AVCodecContext *avctx, DNXHDEncContext *ctx) { int lambda, upstep, downstep; int lastlower = INTMAX, lasthigher = 0; int x, y, q; for (q = 1; q < avctx->qmax; q++) { ctx->qscale = q; avctx->execute2(avctx, dnxhdcalcbitsthread, NULL, NULL, ctx->m.mbheight); } upstep = downstep = 2<<LAMBDAFRACBITS; lambda = ctx->lambda; for (;;) { int bits = 0; int end = 0; if (lambda == lasthigher) { lambda++; end = 1; // need to set final qscales/bits } for (y = 0; y < ctx->m.mbheight; y++) { for (x = 0; x < ctx->m.mbwidth; x++) { unsigned min = UINTMAX; int qscale = 1; int mb = y*ctx->m.mbwidth+x; for (q = 1; q < avctx->qmax; q++) { unsigned score = ctx->mbrc[q][mb].bits*lambda+(ctx->mbrc[q][mb].ssd<<LAMBDAFRACBITS); if (score < min) { min = score; qscale = q; } } bits += ctx->mbrc[qscale][mb].bits; ctx->mbqscale[mb] = qscale; ctx->mbbits[mb] = ctx->mbrc[qscale][mb].bits; } bits = (bits+31)&~31; // padding if (bits > ctx->framebits) break; } //avdlog(ctx->m.avctx, \"lambda %d, up %u, down %u, bits %d, frame %d\\n\", // lambda, lasthigher, lastlower, bits, ctx->framebits); if (end) { if (bits > ctx->framebits) return -1; break; } if (bits < ctx->framebits) { lastlower = FFMIN(lambda, lastlower); if (lasthigher != 0) lambda = (lambda+lasthigher)>>1; else lambda -= downstep; downstep *= 5; // XXX tune ? upstep = 1<<LAMBDAFRACBITS; lambda = FFMAX(1, lambda); if (lambda == lastlower) break; } else { lasthigher = FFMAX(lambda, lasthigher); if (lastlower != INTMAX) lambda = (lambda+lastlower)>>1; else if ((int64t)lambda + upstep > INTMAX) return -1; else lambda += upstep; upstep = FFMIN((int64t)upstep*5, INTMAX); downstep = 1<<LAMBDAFRACBITS; } } //avdlog(ctx->m.avctx, \"out lambda %d\\n\", lambda); ctx->lambda = lambda; return 0; } ", "target": 1}
{"func": "static int findanddecodeindex(NUTContext *nut) { AVFormatContext *s = nut->avf; AVIOContext *bc = s->pb; uint64t tmp, end; int i, j, syncpointcount; int64t filesize = aviosize(bc); int64t *syncpoints; int8t *haskeyframe; int ret = AVERRORINVALIDDATA; avioseek(bc, filesize - 12, SEEKSET); avioseek(bc, filesize - aviorb64(bc), SEEKSET); if (aviorb64(bc) != INDEXSTARTCODE) { avlog(s, AVLOGERROR, \"no index at the end\\n\"); return ret; } end = getpacketheader(nut, bc, 1, INDEXSTARTCODE); end += aviotell(bc); ffioreadvarlen(bc); // maxpts GETV(syncpointcount, tmp < INTMAX / 8 && tmp > 0); syncpoints = avmalloc(sizeof(int64t) * syncpointcount); haskeyframe = avmalloc(sizeof(int8t) * (syncpointcount + 1)); if (!syncpoints || !haskeyframe) return AVERROR(ENOMEM); for (i = 0; i < syncpointcount; i++) { syncpoints[i] = ffioreadvarlen(bc); if (syncpoints[i] <= 0) goto fail; if (i) syncpoints[i] += syncpoints[i - 1]; } for (i = 0; i < s->nbstreams; i++) { int64t lastpts = -1; for (j = 0; j < syncpointcount;) { uint64t x = ffioreadvarlen(bc); int type = x & 1; int n = j; x >>= 1; if (type) { int flag = x & 1; x >>= 1; if (n + x >= syncpointcount + 1) { avlog(s, AVLOGERROR, \"index overflow A\\n\"); goto fail; } while (x--) haskeyframe[n++] = flag; haskeyframe[n++] = !flag; } else { while (x != 1) { if (n >= syncpointcount + 1) { avlog(s, AVLOGERROR, \"index overflow B\\n\"); goto fail; } haskeyframe[n++] = x & 1; x >>= 1; } } if (haskeyframe[0]) { avlog(s, AVLOGERROR, \"keyframe before first syncpoint in index\\n\"); goto fail; } assert(n <= syncpointcount + 1); for (; j < n && j < syncpointcount; j++) { if (haskeyframe[j]) { uint64t B, A = ffioreadvarlen(bc); if (!A) { A = ffioreadvarlen(bc); B = ffioreadvarlen(bc); // eorpts[j][i] = lastpts + A + B } else B = 0; avaddindexentry(s->streams[i], 16 * syncpoints[j - 1], lastpts + A, 0, 0, AVINDEXKEYFRAME); lastpts += A + B; } } } } if (skipreserved(bc, end) || ffiogetchecksum(bc)) { avlog(s, AVLOGERROR, \"index checksum mismatch\\n\"); goto fail; } ret = 0; fail: avfree(syncpoints); avfree(haskeyframe); return ret; } ", "target": 1}
{"func": "static inline void menelausrtcstop(struct menelauss *s) { qemudeltimer(s->rtc.hz); s->rtc.next =- qemugetclock(rtclock); if (s->rtc.next < 1) s->rtc.next = 1; } ", "target": 1}
{"func": "int driveinit(struct driveopt *arg, int snapshot, void *opaque) { char buf[128]; char file[1024]; char devname[128]; char serial[21]; const char *mediastr = \"\"; BlockInterfaceType type; enum { MEDIADISK, MEDIACDROM } media; int busid, unitid; int cyls, heads, secs, translation; BlockDriverState *bdrv; BlockDriver *drv = NULL; QEMUMachine *machine = opaque; int maxdevs; int index; int cache; int bdrvflags, onerror; int drivestableidx; char *str = arg->opt; static const char * const params[] = { \"bus\", \"unit\", \"if\", \"index\", \"cyls\", \"heads\", \"secs\", \"trans\", \"media\", \"snapshot\", \"file\", \"cache\", \"format\", \"serial\", \"werror\", NULL }; if (checkparams(params, str) < 0) { fprintf(stderr, \"qemu: unknown parameter '%s' in '%s'\\n\", buf, str); return -1; } file[0] = 0; cyls = heads = secs = 0; busid = 0; unitid = -1; translation = BIOSATATRANSLATIONAUTO; index = -1; cache = 3; if (machine->usescsi) { type = IFSCSI; maxdevs = MAXSCSIDEVS; pstrcpy(devname, sizeof(devname), \"scsi\"); } else { type = IFIDE; maxdevs = MAXIDEDEVS; pstrcpy(devname, sizeof(devname), \"ide\"); } media = MEDIADISK; /* extract parameters */ if (getparamvalue(buf, sizeof(buf), \"bus\", str)) { busid = strtol(buf, NULL, 0); \tif (busid < 0) { \t fprintf(stderr, \"qemu: '%s' invalid bus id\\n\", str); \t return -1; \t} } if (getparamvalue(buf, sizeof(buf), \"unit\", str)) { unitid = strtol(buf, NULL, 0); \tif (unitid < 0) { \t fprintf(stderr, \"qemu: '%s' invalid unit id\\n\", str); \t return -1; \t} } if (getparamvalue(buf, sizeof(buf), \"if\", str)) { pstrcpy(devname, sizeof(devname), buf); if (!strcmp(buf, \"ide\")) { \t type = IFIDE; maxdevs = MAXIDEDEVS; } else if (!strcmp(buf, \"scsi\")) { \t type = IFSCSI; maxdevs = MAXSCSIDEVS; } else if (!strcmp(buf, \"floppy\")) { \t type = IFFLOPPY; maxdevs = 0; } else if (!strcmp(buf, \"pflash\")) { \t type = IFPFLASH; maxdevs = 0; \t} else if (!strcmp(buf, \"mtd\")) { \t type = IFMTD; maxdevs = 0; \t} else if (!strcmp(buf, \"sd\")) { \t type = IFSD; maxdevs = 0; } else if (!strcmp(buf, \"virtio\")) { type = IFVIRTIO; maxdevs = 0; \t} else if (!strcmp(buf, \"xen\")) { \t type = IFXEN; maxdevs = 0; \t} else { fprintf(stderr, \"qemu: '%s' unsupported bus type '%s'\\n\", str, buf); return -1; \t} } if (getparamvalue(buf, sizeof(buf), \"index\", str)) { index = strtol(buf, NULL, 0); \tif (index < 0) { \t fprintf(stderr, \"qemu: '%s' invalid index\\n\", str); \t return -1; \t} } if (getparamvalue(buf, sizeof(buf), \"cyls\", str)) { cyls = strtol(buf, NULL, 0); } if (getparamvalue(buf, sizeof(buf), \"heads\", str)) { heads = strtol(buf, NULL, 0); } if (getparamvalue(buf, sizeof(buf), \"secs\", str)) { secs = strtol(buf, NULL, 0); } if (cyls || heads || secs) { if (cyls < 1 || cyls > 16383) { fprintf(stderr, \"qemu: '%s' invalid physical cyls number\\n\", str); \t return -1; \t} if (heads < 1 || heads > 16) { fprintf(stderr, \"qemu: '%s' invalid physical heads number\\n\", str); \t return -1; \t} if (secs < 1 || secs > 63) { fprintf(stderr, \"qemu: '%s' invalid physical secs number\\n\", str); \t return -1; \t} } if (getparamvalue(buf, sizeof(buf), \"trans\", str)) { if (!cyls) { fprintf(stderr, \"qemu: '%s' trans must be used with cyls,heads and secs\\n\", str); return -1; } if (!strcmp(buf, \"none\")) translation = BIOSATATRANSLATIONNONE; else if (!strcmp(buf, \"lba\")) translation = BIOSATATRANSLATIONLBA; else if (!strcmp(buf, \"auto\")) translation = BIOSATATRANSLATIONAUTO; \telse { fprintf(stderr, \"qemu: '%s' invalid translation type\\n\", str); \t return -1; \t} } if (getparamvalue(buf, sizeof(buf), \"media\", str)) { if (!strcmp(buf, \"disk\")) { \t media = MEDIADISK; \t} else if (!strcmp(buf, \"cdrom\")) { if (cyls || secs || heads) { fprintf(stderr, \"qemu: '%s' invalid physical CHS format\\n\", str); \t return -1; } \t media = MEDIACDROM; \t} else { \t fprintf(stderr, \"qemu: '%s' invalid media\\n\", str); \t return -1; \t} } if (getparamvalue(buf, sizeof(buf), \"snapshot\", str)) { if (!strcmp(buf, \"on\")) \t snapshot = 1; else if (!strcmp(buf, \"off\")) \t snapshot = 0; \telse { \t fprintf(stderr, \"qemu: '%s' invalid snapshot option\\n\", str); \t return -1; \t} } if (getparamvalue(buf, sizeof(buf), \"cache\", str)) { if (!strcmp(buf, \"off\") || !strcmp(buf, \"none\")) cache = 0; else if (!strcmp(buf, \"writethrough\")) cache = 1; else if (!strcmp(buf, \"writeback\")) cache = 2; else { fprintf(stderr, \"qemu: invalid cache option\\n\"); return -1; } } if (getparamvalue(buf, sizeof(buf), \"format\", str)) { if (strcmp(buf, \"?\") == 0) { fprintf(stderr, \"qemu: Supported formats:\"); bdrviterateformat(bdrvformatprint, NULL); fprintf(stderr, \"\\n\"); \t return -1; } drv = bdrvfindformat(buf); if (!drv) { fprintf(stderr, \"qemu: '%s' invalid format\\n\", buf); return -1; } } if (arg->file == NULL) getparamvalue(file, sizeof(file), \"file\", str); else pstrcpy(file, sizeof(file), arg->file); if (!getparamvalue(serial, sizeof(serial), \"serial\", str)) \t memset(serial, 0, sizeof(serial)); onerror = BLOCKERRSTOPENOSPC; if (getparamvalue(buf, sizeof(serial), \"werror\", str)) { if (type != IFIDE && type != IFSCSI && type != IFVIRTIO) { fprintf(stderr, \"werror is no supported by this format\\n\"); return -1; } if (!strcmp(buf, \"ignore\")) onerror = BLOCKERRIGNORE; else if (!strcmp(buf, \"enospc\")) onerror = BLOCKERRSTOPENOSPC; else if (!strcmp(buf, \"stop\")) onerror = BLOCKERRSTOPANY; else if (!strcmp(buf, \"report\")) onerror = BLOCKERRREPORT; else { fprintf(stderr, \"qemu: '%s' invalid write error action\\n\", buf); return -1; } } /* compute bus and unit according index */ if (index != -1) { if (busid != 0 || unitid != -1) { fprintf(stderr, \"qemu: '%s' index cannot be used with bus and unit\\n\", str); return -1; } if (maxdevs == 0) { unitid = index; busid = 0; } else { unitid = index % maxdevs; busid = index / maxdevs; } } /* if user doesn't specify a unitid, * try to find the first free */ if (unitid == -1) { unitid = 0; while (drivegetindex(type, busid, unitid) != -1) { unitid++; if (maxdevs && unitid >= maxdevs) { unitid -= maxdevs; busid++; } } } /* check unit id */ if (maxdevs && unitid >= maxdevs) { fprintf(stderr, \"qemu: '%s' unit %d too big (max is %d)\\n\", str, unitid, maxdevs - 1); return -1; } /* * ignore multiple definitions */ if (drivegetindex(type, busid, unitid) != -1) return -2; /* init */ if (type == IFIDE || type == IFSCSI) mediastr = (media == MEDIACDROM) ? \"-cd\" : \"-hd\"; if (maxdevs) snprintf(buf, sizeof(buf), \"%s%i%s%i\", devname, busid, mediastr, unitid); else snprintf(buf, sizeof(buf), \"%s%s%i\", devname, mediastr, unitid); bdrv = bdrvnew(buf); drivestableidx = drivegetfreeidx(); drivestable[drivestableidx].bdrv = bdrv; drivestable[drivestableidx].type = type; drivestable[drivestableidx].bus = busid; drivestable[drivestableidx].unit = unitid; drivestable[drivestableidx].onerror = onerror; drivestable[drivestableidx].driveoptidx = arg - drivesopt; strncpy(drivestable[drivestableidx].serial, serial, sizeof(serial)); nbdrives++; switch(type) { case IFIDE: case IFSCSI: case IFXEN: switch(media) { \tcase MEDIADISK: if (cyls != 0) { bdrvsetgeometryhint(bdrv, cyls, heads, secs); bdrvsettranslationhint(bdrv, translation); } \t break; \tcase MEDIACDROM: bdrvsettypehint(bdrv, BDRVTYPECDROM); \t break; \t} break; case IFSD: /* FIXME: This isn't really a floppy, but it's a reasonable approximation. */ case IFFLOPPY: bdrvsettypehint(bdrv, BDRVTYPEFLOPPY); break; case IFPFLASH: case IFMTD: case IFVIRTIO: break; case IFCOUNT: abort(); } if (!file[0]) return -2; bdrvflags = 0; if (snapshot) { bdrvflags |= BDRVOSNAPSHOT; cache = 2; /* always use write-back with snapshot */ } if (cache == 0) /* no caching */ bdrvflags |= BDRVONOCACHE; else if (cache == 2) /* write-back */ bdrvflags |= BDRVOCACHEWB; else if (cache == 3) /* not specified */ bdrvflags |= BDRVOCACHEDEF; if (bdrvopen2(bdrv, file, bdrvflags, drv) < 0) { fprintf(stderr, \"qemu: could not open disk image %s\\n\", file); return -1; } if (bdrvkeyrequired(bdrv)) autostart = 0; return drivestableidx; } ", "target": 1}
{"func": "static void giccompleteirq(gicstate * s, int cpu, int irq) { int update = 0; int cm = 1 << cpu; DPRINTF(\"EOI %d\\n\", irq); if (s->runningirq[cpu] == 1023) return; /* No active IRQ. */ if (irq != 1023) { /* Mark level triggered interrupts as pending if they are still raised. */ if (!GICTESTTRIGGER(irq) && GICTESTENABLED(irq, cm) && GICTESTLEVEL(irq, cm) && (GICTARGET(irq) & cm) != 0) { DPRINTF(\"Set %d pending mask %x\\n\", irq, cm); GICSETPENDING(irq, cm); update = 1; } } if (irq != s->runningirq[cpu]) { /* Complete an IRQ that is not currently running. */ int tmp = s->runningirq[cpu]; while (s->lastactive[tmp][cpu] != 1023) { if (s->lastactive[tmp][cpu] == irq) { s->lastactive[tmp][cpu] = s->lastactive[irq][cpu]; break; } tmp = s->lastactive[tmp][cpu]; } if (update) { gicupdate(s); } } else { /* Complete the current running IRQ. */ gicsetrunningirq(s, cpu, s->lastactive[s->runningirq[cpu]][cpu]); } } ", "target": 1}
{"func": "static void initdequant8coefftable(H264Context *h){ int i,q,x; const int transpose = (h->h264dsp.h264idct8add != ffh264idct8addc); //FIXME ugly h->dequant8coeff[0] = h->dequant8buffer[0]; h->dequant8coeff[1] = h->dequant8buffer[1]; for(i=0; i<2; i++ ){ if(i && !memcmp(h->pps.scalingmatrix8[0], h->pps.scalingmatrix8[1], 64*sizeof(uint8t))){ h->dequant8coeff[1] = h->dequant8buffer[0]; break; } for(q=0; q<52; q++){ int shift = div6[q]; int idx = rem6[q]; for(x=0; x<64; x++) h->dequant8coeff[i][q][transpose ? (x>>3)|((x&7)<<3) : x] = ((uint32t)dequant8coeffinit[idx][ dequant8coeffinitscan[((x>>1)&12) | (x&3)] ] * h->pps.scalingmatrix8[i][x]) << shift; } } } ", "target": 0}
{"func": "char *vncdisplaylocaladdr(const char *id) { VncDisplay *vs = vncdisplayfind(id); return vncsocketlocaladdr(\"%s:%s\", vs->lsock); }", "target": 1}
{"func": "PPCOP(setT0) { T0 = PARAM(1); RETURN(); } ", "target": 1}
{"func": "static void testvalidatefailstructnested(TestInputVisitorData *data, const void *unused) { UserDefTwo *udp = NULL; Error *err = NULL; Visitor *v; v = validatetestinit(data, \"{ 'string0': 'string0', 'dict1': { 'string1': 'string1', 'dict2': { 'userdef1': { 'integer': 42, 'string': 'string', 'extra': [42, 23, {'foo':'bar'}] }, 'string2': 'string2'}}}\"); visittypeUserDefTwo(v, NULL, &udp, &err); errorfreeorabort(&err); qapifreeUserDefTwo(udp); } ", "target": 1}
{"func": "static int socketgetbuffer(void *opaque, uint8t *buf, int64t pos, int size) { QEMUFileSocket *s = opaque; ssizet len; do { len = qemurecv(s->fd, buf, size, 0); } while (len == -1 && socketerror() == EINTR); if (len == -1) len = -socketerror(); return len; } ", "target": 1}
{"func": "static GIOStatus gachannelwrite(GAChannel *c, const char *buf, sizet size, sizet *count) { GIOStatus status; OVERLAPPED ov = {0}; BOOL ret; DWORD written; ov.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL); ret = WriteFile(c->handle, buf, size, &written, &ov); if (!ret) { if (GetLastError() == ERRORIOPENDING) { /* write is pending */ ret = GetOverlappedResult(c->handle, &ov, &written, TRUE); if (!ret) { if (!GetLastError()) { status = GIOSTATUSAGAIN; } else { status = GIOSTATUSERROR; } else { /* write is complete */ status = GIOSTATUSNORMAL; *count = written; } else { status = GIOSTATUSERROR; } else { /* write returned immediately */ status = GIOSTATUSNORMAL; *count = written; return status; ", "target": 1}
{"func": "int ffjniexceptiongetsummary(JNIEnv *env, jthrowable exception, char **error, void *logctx) { int ret = 0; AVBPrint bp; char *name = NULL; char *message = NULL; jclass classclass = NULL; jmethodID getnameid = NULL; jclass exceptionclass = NULL; jmethodID getmessageid = NULL; jstring string; avbprintinit(&bp, 0, AVBPRINTSIZEAUTOMATIC); exceptionclass = (*env)->GetObjectClass(env, exception); if ((*env)->ExceptionCheck(env)) { (*env)->ExceptionClear(env); avlog(logctx, AVLOGERROR, \"Could not find Throwable class\\n\"); ret = AVERROREXTERNAL; goto done; } classclass = (*env)->GetObjectClass(env, exceptionclass); if ((*env)->ExceptionCheck(env)) { (*env)->ExceptionClear(env); avlog(logctx, AVLOGERROR, \"Could not find Throwable class's class\\n\"); ret = AVERROREXTERNAL; goto done; } getnameid = (*env)->GetMethodID(env, classclass, \"getName\", \"()Ljava/lang/String;\"); if ((*env)->ExceptionCheck(env)) { (*env)->ExceptionClear(env); avlog(logctx, AVLOGERROR, \"Could not find method Class.getName()\\n\"); ret = AVERROREXTERNAL; goto done; } string = (*env)->CallObjectMethod(env, exceptionclass, getnameid); if ((*env)->ExceptionCheck(env)) { (*env)->ExceptionClear(env); avlog(logctx, AVLOGERROR, \"Class.getName() threw an exception\\n\"); ret = AVERROREXTERNAL; goto done; } if (string) { name = ffjnijstringtoutfchars(env, string, logctx); (*env)->DeleteLocalRef(env, string); string = NULL; } getmessageid = (*env)->GetMethodID(env, exceptionclass, \"getMessage\", \"()Ljava/lang/String;\"); if ((*env)->ExceptionCheck(env)) { (*env)->ExceptionClear(env); avlog(logctx, AVLOGERROR, \"Could not find method java/lang/Throwable.getMessage()\\n\"); ret = AVERROREXTERNAL; goto done; } string = (*env)->CallObjectMethod(env, exception, getmessageid); if ((*env)->ExceptionCheck(env)) { (*env)->ExceptionClear(env); avlog(logctx, AVLOGERROR, \"Throwable.getMessage() threw an exception\\n\"); ret = AVERROREXTERNAL; goto done; } if (string) { message = ffjnijstringtoutfchars(env, string, logctx); (*env)->DeleteLocalRef(env, string); string = NULL; } if (name && message) { avbprintf(&bp, \"%s: %s\", name, message); } else if (name && !message) { avbprintf(&bp, \"%s occurred\", name); } else if (!name && message) { avbprintf(&bp, \"Exception: %s\", message); } else { avlog(logctx, AVLOGWARNING, \"Could not retreive exception name and message\\n\"); avbprintf(&bp, \"Exception occurred\"); } ret = avbprintfinalize(&bp, error); done: avfree(name); avfree(message); if (classclass) { (*env)->DeleteLocalRef(env, classclass); } if (exceptionclass) { (*env)->DeleteLocalRef(env, exceptionclass); } if (string) { (*env)->DeleteLocalRef(env, string); } return ret; } ", "target": 1}
{"func": "static void vscsicommandcomplete(SCSIBus *bus, int reason, uint32t tag, uint32t arg) { VSCSIState *s = DOUPCAST(VSCSIState, vdev.qdev, bus->qbus.parent); vscsireq *req = vscsifindreq(s, tag); SCSIDevice *sdev; uint8t *buf; int32t resin = 0, resout = 0; int len, rc = 0; dprintf(\"VSCSI: SCSI cmd complete, r=0x%x tag=0x%x arg=0x%x, req=%p\\n\", reason, tag, arg, req); if (req == NULL) { fprintf(stderr, \"VSCSI: Can't find request for tag 0x%x\\n\", tag); return; } sdev = req->sdev; if (req->sensing) { if (reason == SCSIREASONDONE) { dprintf(\"VSCSI: Sense done !\\n\"); vscsisendrsp(s, req, CHECKCONDITION, 0, 0); vscsiputreq(s, req); } else { uint8t *buf = sdev->info->getbuf(sdev, tag); len = MIN(arg, SCSISENSEBUFSIZE); dprintf(\"VSCSI: Sense data, %d bytes:\\n\", len); dprintf(\" %02x %02x %02x %02x %02x %02x %02x %02x\\n\", buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6], buf[7]); dprintf(\" %02x %02x %02x %02x %02x %02x %02x %02x\\n\", buf[8], buf[9], buf[10], buf[11], buf[12], buf[13], buf[14], buf[15]); memcpy(req->sense, buf, len); req->senselen = len; sdev->info->readdata(sdev, req->qtag); } return; } if (reason == SCSIREASONDONE) { dprintf(\"VSCSI: Command complete err=%d\\n\", arg); if (arg == 0) { /* We handle overflows, not underflows for normal commands, * but hopefully nobody cares */ if (req->writing) { resout = req->datalen; } else { resin = req->datalen; } vscsisendrsp(s, req, 0, resin, resout); } else if (arg == CHECKCONDITION) { dprintf(\"VSCSI: Got CHECKCONDITION, requesting sense...\\n\"); vscsisendrequestsense(s, req); return; } else { vscsisendrsp(s, req, arg, 0, 0); } vscsiputreq(s, req); return; } /* \"arg\" is how much we have read for reads and how much we want * to write for writes (ie, how much is to be DMA'd) */ if (arg) { buf = sdev->info->getbuf(sdev, tag); rc = vscsisrptransferdata(s, req, req->writing, buf, arg); } if (rc < 0) { fprintf(stderr, \"VSCSI: RDMA error rc=%d!\\n\", rc); sdev->info->cancelio(sdev, req->qtag); vscsimakeupsense(s, req, HARDWAREERROR, 0, 0); vscsisendrsp(s, req, CHECKCONDITION, 0, 0); vscsiputreq(s, req); return; } /* Start next chunk */ req->datalen -= rc; if (req->writing) { sdev->info->writedata(sdev, req->qtag); } else { sdev->info->readdata(sdev, req->qtag); } } ", "target": 1}
{"func": "void helperstoresdr1(CPUPPCState *env, targetulong val) { PowerPCCPU *cpu = ppcenvgetcpu(env); if (!env->externalhtab) { if (env->spr[SPRSDR1] != val) { ppcstoresdr1(env, val); tlbflush(CPU(cpu)); } } } ", "target": 0}
{"func": "static bool fwcfgcombvalid(void *opaque, targetphysaddrt addr, unsigned size, bool iswrite) { return (size == 1) || (iswrite && size == 2); } ", "target": 0}
{"func": "sPAPRTCETable *spaprtcenewtable(DeviceState *owner, uint32t liobn, uint64t busoffset, uint32t pageshift, uint32t nbtable, bool vfioaccel) { sPAPRTCETable *tcet; char tmp[64]; if (spaprtcefindbyliobn(liobn)) { fprintf(stderr, \"Attempted to create TCE table with duplicate\" \" LIOBN 0x%x\\n\", liobn); return NULL; } if (!nbtable) { return NULL; } tcet = SPAPRTCETABLE(objectnew(TYPESPAPRTCETABLE)); tcet->liobn = liobn; tcet->busoffset = busoffset; tcet->pageshift = pageshift; tcet->nbtable = nbtable; tcet->vfioaccel = vfioaccel; snprintf(tmp, sizeof(tmp), \"tce-table-%x\", liobn); objectpropertyaddchild(OBJECT(owner), tmp, OBJECT(tcet), NULL); objectpropertysetbool(OBJECT(tcet), true, \"realized\", NULL); return tcet; } ", "target": 0}
{"func": "static void debugprintfis(uint8t *fis, int cmdlen) { #ifdef DEBUGAHCI int i; fprintf(stderr, \"fis:\"); for (i = 0; i < cmdlen; i++) { if ((i & 0xf) == 0) { fprintf(stderr, \"\\n%02x:\",i); } fprintf(stderr, \"%02x \",fis[i]); } fprintf(stderr, \"\\n\"); #endif } ", "target": 1}
{"func": "static avcold int svcencodeinit(AVCodecContext *avctx) { SVCContext *s = avctx->privdata; SEncParamExt param = { 0 }; int err = AVERRORUNKNOWN; int loglevel; WelsTraceCallback callbackfunction; AVCPBProperties *props; // Mingw GCC < 4.7 on x8632 uses an incorrect/buggy ABI for the WelsGetCodecVersion // function (for functions returning larger structs), thus skip the check in those // configurations. #if !defined(WIN32) || !defined(GNUC) || !ARCHX8632 || AVGCCVERSIONATLEAST(4, 7) OpenH264Version libver = WelsGetCodecVersion(); if (memcmp(&libver, &gstCodecVersion, sizeof(libver))) { avlog(avctx, AVLOGERROR, \"Incorrect library version loaded\\n\"); return AVERROR(EINVAL); } #endif if (WelsCreateSVCEncoder(&s->encoder)) { avlog(avctx, AVLOGERROR, \"Unable to create encoder\\n\"); return AVERRORUNKNOWN; } // Pass all libopenh264 messages to our callback, to allow ourselves to filter them. loglevel = WELSLOGDETAIL; (*s->encoder)->SetOption(s->encoder, ENCODEROPTIONTRACELEVEL, &loglevel); // Set the logging callback function to one that uses avlog() (see implementation above). callbackfunction = (WelsTraceCallback) libopenh264tracecallback; (*s->encoder)->SetOption(s->encoder, ENCODEROPTIONTRACECALLBACK, (void *)&callbackfunction); // Set the AVCodecContext as the libopenh264 callback context so that it can be passed to avlog(). (*s->encoder)->SetOption(s->encoder, ENCODEROPTIONTRACECALLBACKCONTEXT, (void *)&avctx); (*s->encoder)->GetDefaultParams(s->encoder, &param); param.fMaxFrameRate = avctx->timebase.den / avctx->timebase.num; param.iPicWidth = avctx->width; param.iPicHeight = avctx->height; param.iTargetBitrate = avctx->bitrate; param.iMaxBitrate = FFMAX(avctx->rcmaxrate, avctx->bitrate); param.iRCMode = RCQUALITYMODE; param.iTemporalLayerNum = 1; param.iSpatialLayerNum = 1; param.bEnableDenoise = 0; param.bEnableBackgroundDetection = 1; param.bEnableAdaptiveQuant = 1; param.bEnableFrameSkip = s->skipframes; param.bEnableLongTermReference = 0; param.iLtrMarkPeriod = 30; param.uiIntraPeriod = avctx->gopsize; #if OPENH264VERATLEAST(1, 4) param.eSpsPpsIdStrategy = CONSTANTID; #else param.bEnableSpsPpsIdAddition = 0; #endif param.bPrefixNalAddingCtrl = 0; param.iLoopFilterDisableIdc = !s->loopfilter; param.iEntropyCodingModeFlag = 0; param.iMultipleThreadIdc = avctx->threadcount; if (s->profile && !strcmp(s->profile, \"main\")) param.iEntropyCodingModeFlag = 1; else if (!s->profile && avctx->codertype == FFCODERTYPEAC) param.iEntropyCodingModeFlag = 1; param.sSpatialLayers[0].iVideoWidth = param.iPicWidth; param.sSpatialLayers[0].iVideoHeight = param.iPicHeight; param.sSpatialLayers[0].fFrameRate = param.fMaxFrameRate; param.sSpatialLayers[0].iSpatialBitrate = param.iTargetBitrate; param.sSpatialLayers[0].iMaxSpatialBitrate = param.iMaxBitrate; if ((avctx->slices > 1) && (s->maxnalsize)){ avlog(avctx,AVLOGERROR,\"Invalid combination -slices %d and -maxnalsize %d.\\n\",avctx->slices,s->maxnalsize); goto fail; } if (avctx->slices > 1) s->slicemode = SMFIXEDSLCNUMSLICE; if (s->maxnalsize) s->slicemode = SMDYNSLICE; param.sSpatialLayers[0].sSliceCfg.uiSliceMode = s->slicemode; param.sSpatialLayers[0].sSliceCfg.sSliceArgument.uiSliceNum = avctx->slices; if (s->slicemode == SMDYNSLICE) { if (s->maxnalsize){ param.uiMaxNalSize = s->maxnalsize; param.sSpatialLayers[0].sSliceCfg.sSliceArgument.uiSliceSizeConstraint = s->maxnalsize; } else { if (avctx->rtppayloadsize) { avlog(avctx,AVLOGDEBUG,\"Using RTP Payload size for uiMaxNalSize\"); param.uiMaxNalSize = avctx->rtppayloadsize; param.sSpatialLayers[0].sSliceCfg.sSliceArgument.uiSliceSizeConstraint = avctx->rtppayloadsize; } else { avlog(avctx,AVLOGERROR,\"Invalid -maxnalsize, specify a valid maxnalsize to use -slicemode dyn\\n\"); goto fail; } } } if ((*s->encoder)->InitializeExt(s->encoder, &param) != cmResultSuccess) { avlog(avctx, AVLOGERROR, \"Initialize failed\\n\"); goto fail; } if (avctx->flags & AVCODECFLAGGLOBALHEADER) { SFrameBSInfo fbi = { 0 }; int i, size = 0; (*s->encoder)->EncodeParameterSets(s->encoder, &fbi); for (i = 0; i < fbi.sLayerInfo[0].iNalCount; i++) size += fbi.sLayerInfo[0].pNalLengthInByte[i]; avctx->extradata = avmallocz(size + AVINPUTBUFFERPADDINGSIZE); if (!avctx->extradata) { err = AVERROR(ENOMEM); goto fail; } avctx->extradatasize = size; memcpy(avctx->extradata, fbi.sLayerInfo[0].pBsBuf, size); } props = ffaddcpbsidedata(avctx); if (!props) { err = AVERROR(ENOMEM); goto fail; } props->maxbitrate = param.iMaxBitrate; props->avgbitrate = param.iTargetBitrate; return 0; fail: svcencodeclose(avctx); return err; } ", "target": 0}
{"func": "static void sm501dispctrlwrite(void *opaque, hwaddr addr, uint64t value, unsigned size) { SM501State *s = (SM501State *)opaque; SM501DPRINTF(\"sm501 disp ctrl regs : write addr=%x, val=%x\\n\", (unsigned)addr, (unsigned)value); switch (addr) { case SM501DCPANELCONTROL: s->dcpanelcontrol = value & 0x0FFF73FF; break; case SM501DCPANELPANNINGCONTROL: s->dcpanelpanningcontrol = value & 0xFF3FFF3F; break; case SM501DCPANELFBADDR: s->dcpanelfbaddr = value & 0x8FFFFFF0; break; case SM501DCPANELFBOFFSET: s->dcpanelfboffset = value & 0x3FF03FF0; break; case SM501DCPANELFBWIDTH: s->dcpanelfbwidth = value & 0x0FFF0FFF; break; case SM501DCPANELFBHEIGHT: s->dcpanelfbheight = value & 0x0FFF0FFF; break; case SM501DCPANELTLLOC: s->dcpaneltllocation = value & 0x07FF07FF; break; case SM501DCPANELBRLOC: s->dcpanelbrlocation = value & 0x07FF07FF; break; case SM501DCPANELHTOT: s->dcpanelhtotal = value & 0x0FFF0FFF; break; case SM501DCPANELHSYNC: s->dcpanelhsync = value & 0x00FF0FFF; break; case SM501DCPANELVTOT: s->dcpanelvtotal = value & 0x0FFF0FFF; break; case SM501DCPANELVSYNC: s->dcpanelvsync = value & 0x003F0FFF; break; case SM501DCPANELHWCADDR: s->dcpanelhwcaddr = value & 0x8FFFFFF0; break; case SM501DCPANELHWCLOC: s->dcpanelhwclocation = value & 0x0FFF0FFF; break; case SM501DCPANELHWCCOLOR12: s->dcpanelhwccolor12 = value; break; case SM501DCPANELHWCCOLOR3: s->dcpanelhwccolor3 = value & 0x0000FFFF; break; case SM501DCCRTCONTROL: s->dccrtcontrol = value & 0x0003FFFF; break; case SM501DCCRTFBADDR: s->dccrtfbaddr = value & 0x8FFFFFF0; break; case SM501DCCRTFBOFFSET: s->dccrtfboffset = value & 0x3FF03FF0; break; case SM501DCCRTHTOT: s->dccrthtotal = value & 0x0FFF0FFF; break; case SM501DCCRTHSYNC: s->dccrthsync = value & 0x00FF0FFF; break; case SM501DCCRTVTOT: s->dccrtvtotal = value & 0x0FFF0FFF; break; case SM501DCCRTVSYNC: s->dccrtvsync = value & 0x003F0FFF; break; case SM501DCCRTHWCADDR: s->dccrthwcaddr = value & 0x8FFFFFF0; break; case SM501DCCRTHWCLOC: s->dccrthwclocation = value & 0x0FFF0FFF; break; case SM501DCCRTHWCCOLOR12: s->dccrthwccolor12 = value; break; case SM501DCCRTHWCCOLOR3: s->dccrthwccolor3 = value & 0x0000FFFF; break; case SM501DCPANELPALETTE ... SM501DCPANELPALETTE + 0x400 * 3 - 4: sm501palettewrite(opaque, addr - SM501DCPANELPALETTE, value); break; default: printf(\"sm501 disp ctrl : not implemented register write.\" \" addr=%x, val=%x\\n\", (int)addr, (unsigned)value); abort(); } } ", "target": 0}
{"func": "void rgb15to16(const uint8t *src,uint8t *dst,uint32t srcsize) { #ifdef HAVEMMX register const char* s=src+srcsize; register char* d=dst+srcsize; register int offs=-srcsize; asm volatile(PREFETCH\"\t%0\"::\"m\"(*(s+offs)):\"memory\"); asm volatile( \t\"movq\t%0, %%mm4\\n\\t\" \t\"movq\t%1, %%mm5\" \t::\"m\"(mask15b), \"m\"(mask15rg):\"memory\"); while(offs<0) { \tasm volatile( \t\tPREFETCH\"\t32%1\\n\\t\" \t\t\"movq\t%1, %%mm0\\n\\t\" \t\t\"movq\t8%1, %%mm2\\n\\t\" \t\t\"movq\t%%mm0, %%mm1\\n\\t\" \t\t\"movq\t%%mm2, %%mm3\\n\\t\" \t\t\"pand\t%%mm4, %%mm0\\n\\t\" \t\t\"pand\t%%mm5, %%mm1\\n\\t\" \t\t\"pand\t%%mm4, %%mm2\\n\\t\" \t\t\"pand\t%%mm5, %%mm3\\n\\t\" \t\t\"psllq\t$1, %%mm1\\n\\t\" \t\t\"psllq\t$1, %%mm3\\n\\t\" \t\t\"por\t%%mm1, %%mm0\\n\\t\" \t\t\"por\t%%mm3, %%mm2\\n\\t\" \t\tMOVNTQ\"\t%%mm0, %0\\n\\t\" \t\tMOVNTQ\"\t%%mm2, 8%0\" \t\t:\"=m\"(*(d+offs)) \t\t:\"m\"(*(s+offs)) \t\t:\"memory\"); \toffs+=16; } asm volatile(SFENCE:::\"memory\"); asm volatile(EMMS:::\"memory\"); #else const uint16t *s1=( uint16t * )src; uint16t *d1=( uint16t * )dst; uint16t *e=((uint8t *)s1)+srcsize; while( s1<e ){ register int x=*( s1++ ); /* rrrrrggggggbbbbb 0rrrrrgggggbbbbb 0111 1111 1110 0000=0x7FE0 00000000000001 1111=0x001F */ *( d1++ )=( x&0x001F )|( ( x&0x7FE0 )<<1 ); } #endif } ", "target": 0}
{"func": "static int rleunpack(const unsigned char *src, unsigned char *dest, int srclen, int destlen) { const unsigned char *ps; unsigned char *pd; int i, l; unsigned char *destend = dest + destlen; ps = src; pd = dest; if (srclen & 1) *pd++ = *ps++; srclen >>= 1; i = 0; do { l = *ps++; if (l & 0x80) { l = (l & 0x7F) * 2; if (pd + l > destend) return ps - src; memcpy(pd, ps, l); ps += l; pd += l; } else { if (pd + i > destend) return ps - src; for (i = 0; i < l; i++) { *pd++ = ps[0]; *pd++ = ps[1]; } ps += 2; } i += l; } while (i < srclen); return ps - src; } ", "target": 1}
{"func": "void ffavgh264qpel16mc33msa(uint8t *dst, const uint8t *src, ptrdifft stride) { avclumahvqrtandaverdst16x16msa(src + stride - 2, src - (stride * 2) + sizeof(uint8t), stride, dst, stride); } ", "target": 0}
{"func": "static int vorbisparse(AVCodecParserContext *s1, AVCodecContext *avctx, const uint8t **poutbuf, int *poutbufsize, const uint8t *buf, int bufsize) { VorbisParseContext *s = s1->privdata; int duration; if (!s->vp && avctx->extradata && avctx->extradatasize) { s->vp = avvorbisparseinit(avctx->extradata, avctx->extradatasize); if (!s->vp) goto end; } if ((duration = avvorbisparseframe(s->vp, buf, bufsize)) >= 0) s1->duration = duration; end: /* always return the full packet. this parser isn't doing any splitting or combining, only packet analysis */ *poutbuf = buf; *poutbufsize = bufsize; return bufsize; } ", "target": 1}
{"func": "static void xenraminit(PCMachineState *pcms, ramaddrt ramsize, MemoryRegion **rammemoryp) { MemoryRegion *sysmem = getsystemmemory(); ramaddrt blocklen; uint64t userlowmem = objectpropertygetint(qdevgetmachine(), PCMACHINEMAXRAMBELOW4G, &errorabort); /* Handle the machine opt max-ram-below-4g. It is basically doing * min(xen limit, user limit). */ if (HVMBELOW4GRAMEND <= userlowmem) { userlowmem = HVMBELOW4GRAMEND; } if (ramsize >= userlowmem) { pcms->above4gmemsize = ramsize - userlowmem; pcms->below4gmemsize = userlowmem; } else { pcms->above4gmemsize = 0; pcms->below4gmemsize = ramsize; } if (!pcms->above4gmemsize) { blocklen = ramsize; } else { /* * Xen does not allocate the memory continuously, it keeps a * hole of the size computed above or passed in. */ blocklen = (1ULL << 32) + pcms->above4gmemsize; } memoryregioninitram(&rammemory, NULL, \"xen.ram\", blocklen, &errorabort); *rammemoryp = &rammemory; vmstateregisterramglobal(&rammemory); memoryregioninitalias(&ram640k, NULL, \"xen.ram.640k\", &rammemory, 0, 0xa0000); memoryregionaddsubregion(sysmem, 0, &ram640k); /* Skip of the VGA IO memory space, it will be registered later by the VGA * emulated device. * * The area between 0xc0000 and 0x100000 will be used by SeaBIOS to load * the Options ROM, so it is registered here as RAM. */ memoryregioninitalias(&ramlo, NULL, \"xen.ram.lo\", &rammemory, 0xc0000, pcms->below4gmemsize - 0xc0000); memoryregionaddsubregion(sysmem, 0xc0000, &ramlo); if (pcms->above4gmemsize > 0) { memoryregioninitalias(&ramhi, NULL, \"xen.ram.hi\", &rammemory, 0x100000000ULL, pcms->above4gmemsize); memoryregionaddsubregion(sysmem, 0x100000000ULL, &ramhi); } } ", "target": 1}
{"func": "static void pcispaprsetirq(void *opaque, int irqnum, int level) { /* * Here we use the number returned by pcispaprmapirq to find a * corresponding qemuirq. */ sPAPRPHBState *phb = opaque; tracespaprpcilsiset(phb->busname, irqnum, phb->lsitable[irqnum].irq); qemusetirq(spaprphblsiqirq(phb, irqnum), level); } ", "target": 1}
{"func": "static int allocsequencebuffers(DiracContext *s) { int sbwidth = DIVRNDUP(s->source.width, 4); int sbheight = DIVRNDUP(s->source.height, 4); int i, w, h, toppadding; /* todo: think more about this / use or set Plane here */ for (i = 0; i < 3; i++) { int maxxblen = MAXBLOCKSIZE >> (i ? s->chromaxshift : 0); int maxyblen = MAXBLOCKSIZE >> (i ? s->chromayshift : 0); w = s->source.width >> (i ? s->chromaxshift : 0); h = s->source.height >> (i ? s->chromayshift : 0); /* we allocate the max we support here since num decompositions can * change from frame to frame. Stride is aligned to 16 for SIMD, and * 1<<MAXDWTLEVELS top padding to avoid if(y>0) in arith decoding * MAXBLOCKSIZE padding for MC: blocks can spill up to half of that * on each side */ toppadding = FFMAX(1<<MAXDWTLEVELS, maxyblen/2); w = FFALIGN(CALCPADDING(w, MAXDWTLEVELS), 8); /* FIXME: Should this be 16 for SSE??? */ h = toppadding + CALCPADDING(h, MAXDWTLEVELS) + maxyblen/2; s->plane[i].idwtbufbase = avmallocz((w+maxxblen)*h * sizeof(IDWTELEM)); s->plane[i].idwttmp = avmalloc((w+16) * sizeof(IDWTELEM)); s->plane[i].idwtbuf = s->plane[i].idwtbufbase + toppadding*w; if (!s->plane[i].idwtbufbase || !s->plane[i].idwttmp) return AVERROR(ENOMEM); } w = s->source.width; h = s->source.height; /* fixme: allocate using real stride here */ s->sbsplit = avmalloc(sbwidth * sbheight); s->blmotion = avmalloc(sbwidth * sbheight * 16 * sizeof(*s->blmotion)); s->edgeemubufferbase = avmalloc((w+64)*MAXBLOCKSIZE); s->mctmp = avmalloc((w+64+MAXBLOCKSIZE) * (h*MAXBLOCKSIZE) * sizeof(*s->mctmp)); s->mcscratch = avmalloc((w+64)*MAXBLOCKSIZE); if (!s->sbsplit || !s->blmotion) return AVERROR(ENOMEM); return 0; } ", "target": 1}
{"func": "static int hevchandlepacket(AVFormatContext *ctx, PayloadContext *rtphevcctx, AVStream *st, AVPacket *pkt, uint32t *timestamp, const uint8t *buf, int len, uint16t seq, int flags) { const uint8t *rtppl = buf; int tid, lid, naltype; int firstfragment, lastfragment, futype; uint8t newnalheader[2]; int res = 0; /* sanity check for size of input packet: 1 byte payload at least */ if (len < RTPHEVCPAYLOADHEADERSIZE + 1) { avlog(ctx, AVLOGERROR, \"Too short RTP/HEVC packet, got %d bytes\\n\", len); return AVERRORINVALIDDATA; } /* * decode the HEVC payload header according to section 4 of draft version 6: * * 0 1 * 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ * |F| Type | LayerId | TID | * +-------------+-----------------+ * * Forbidden zero (F): 1 bit * NAL unit type (Type): 6 bits * NUH layer ID (LayerId): 6 bits * NUH temporal ID plus 1 (TID): 3 bits */ naltype = (buf[0] >> 1) & 0x3f; lid = ((buf[0] << 5) & 0x20) | ((buf[1] >> 3) & 0x1f); tid = buf[1] & 0x07; /* sanity check for correct layer ID */ if (lid) { /* future scalable or 3D video coding extensions */ avprivreportmissingfeature(ctx, \"Multi-layer HEVC coding\\n\"); return AVERRORPATCHWELCOME; } /* sanity check for correct temporal ID */ if (!tid) { avlog(ctx, AVLOGERROR, \"Illegal temporal ID in RTP/HEVC packet\\n\"); return AVERRORINVALIDDATA; } /* sanity check for correct NAL unit type */ if (naltype > 50) { avlog(ctx, AVLOGERROR, \"Unsupported (HEVC) NAL type (%d)\\n\", naltype); return AVERRORINVALIDDATA; } switch (naltype) { /* video parameter set (VPS) */ case 32: /* sequence parameter set (SPS) */ case 33: /* picture parameter set (PPS) */ case 34: /* supplemental enhancement information (SEI) */ case 39: /* single NAL unit packet */ default: /* sanity check for size of input packet: 1 byte payload at least */ if (len < 1) { avlog(ctx, AVLOGERROR, \"Too short RTP/HEVC packet, got %d bytes of NAL unit type %d\\n\", len, naltype); return AVERRORINVALIDDATA; } /* create A/V packet */ if ((res = avnewpacket(pkt, sizeof(startsequence) + len)) < 0) return res; /* A/V packet: copy start sequence */ memcpy(pkt->data, startsequence, sizeof(startsequence)); /* A/V packet: copy NAL unit data */ memcpy(pkt->data + sizeof(startsequence), buf, len); break; /* aggregated packet (AP) - with two or more NAL units */ case 48: /* pass the HEVC payload header */ buf += RTPHEVCPAYLOADHEADERSIZE; len -= RTPHEVCPAYLOADHEADERSIZE; /* pass the HEVC DONL field */ if (rtphevcctx->usingdonlfield) { buf += RTPHEVCDONLFIELDSIZE; len -= RTPHEVCDONLFIELDSIZE; } res = ffh264handleaggregatedpacket(ctx, pkt, buf, len, rtphevcctx->usingdonlfield ? RTPHEVCDONDFIELDSIZE : 0, NULL, 0); if (res < 0) return res; break; /* fragmentation unit (FU) */ case 49: /* pass the HEVC payload header */ buf += RTPHEVCPAYLOADHEADERSIZE; len -= RTPHEVCPAYLOADHEADERSIZE; /* * decode the FU header * * 0 1 2 3 4 5 6 7 * +-+-+-+-+-+-+-+-+ * |S|E| FuType | * +---------------+ * * Start fragment (S): 1 bit * End fragment (E): 1 bit * FuType: 6 bits */ firstfragment = buf[0] & 0x80; lastfragment = buf[0] & 0x40; futype = buf[0] & 0x3f; /* pass the HEVC FU header */ buf += RTPHEVCFUHEADERSIZE; len -= RTPHEVCFUHEADERSIZE; /* pass the HEVC DONL field */ if (rtphevcctx->usingdonlfield) { buf += RTPHEVCDONLFIELDSIZE; len -= RTPHEVCDONLFIELDSIZE; } avdlog(ctx, \" FU type %d with %d bytes\\n\", futype, len); if (len <= 0) { /* sanity check for size of input packet: 1 byte payload at least */ avlog(ctx, AVLOGERROR, \"Too short RTP/HEVC packet, got %d bytes of NAL unit type %d\\n\", len, naltype); return AVERRORINVALIDDATA; } if (firstfragment && lastfragment) { avlog(ctx, AVLOGERROR, \"Illegal combination of S and E bit in RTP/HEVC packet\\n\"); return AVERRORINVALIDDATA; } newnalheader[0] = (rtppl[0] & 0x81) | (futype << 1); newnalheader[1] = rtppl[1]; res = ffh264handlefragpacket(pkt, buf, len, firstfragment, newnalheader, sizeof(newnalheader)); break; /* PACI packet */ case 50: /* Temporal scalability control information (TSCI) */ avprivreportmissingfeature(ctx, \"PACI packets for RTP/HEVC\\n\"); res = AVERRORPATCHWELCOME; break; } pkt->streamindex = st->index; return res; } ", "target": 1}
{"func": "int avprivlockavformat(void) { if (lockmgrcb) { if ((*lockmgrcb)(&avformatmutex, AVLOCKOBTAIN)) return -1; } return 0; } ", "target": 1}
{"func": "static int libschroedingerencodeclose(AVCodecContext *avctx) { SchroEncoderParams *pschroparams = avctx->privdata; /* Close the encoder. */ schroencoderfree(pschroparams->encoder); /* Free data in the output frame queue. */ ffschroqueuefree(&pschroparams->encframequeue, libschroedingerfreeframe); /* Free the encoder buffer. */ if (pschroparams->encbufsize) avfreep(&pschroparams->encbuf); /* Free the video format structure. */ avfreep(&pschroparams->format); return 0; } ", "target": 1}
{"func": "static int cinepakdecodeframe(AVCodecContext *avctx, void *data, int *gotframe, AVPacket *avpkt) { const uint8t *buf = avpkt->data; int ret = 0, bufsize = avpkt->size; CinepakContext *s = avctx->privdata; s->data = buf; s->size = bufsize; if ((ret = ffregetbuffer(avctx, s->frame)) < 0) return ret; if (s->palettevideo) { const uint8t *pal = avpacketgetsidedata(avpkt, AVPKTDATAPALETTE, NULL); if (pal) { s->frame->palettehaschanged = 1; memcpy(s->pal, pal, AVPALETTESIZE); } } if ((ret = cinepakdecode(s)) < 0) { avlog(avctx, AVLOGERROR, \"cinepakdecode failed\\n\"); } if (s->palettevideo) memcpy (s->frame->data[1], s->pal, AVPALETTESIZE); if ((ret = avframeref(data, s->frame)) < 0) return ret; *gotframe = 1; /* report that the buffer was completely consumed */ return bufsize; } ", "target": 0}
{"func": "static void taihu405epinit(MachineState *machine) { ramaddrt ramsize = machine->ramsize; const char *kernelfilename = machine->kernelfilename; const char *initrdfilename = machine->initrdfilename; char *filename; qemuirq *pic; MemoryRegion *sysmem = getsystemmemory(); MemoryRegion *bios; MemoryRegion *rammemories = gmalloc(2 * sizeof(*rammemories)); MemoryRegion *ram = gmalloc0(sizeof(*ram)); hwaddr rambases[2], ramsizes[2]; long biossize; targetulong kernelbase, initrdbase; long kernelsize, initrdsize; int linuxboot; int flidx, flsectors; DriveInfo *dinfo; /* RAM is soldered to the board so the size cannot be changed */ ramsize = 0x08000000; memoryregionallocatesystemmemory(ram, NULL, \"taihu405ep.ram\", ramsize); rambases[0] = 0; ramsizes[0] = 0x04000000; memoryregioninitalias(&rammemories[0], NULL, \"taihu405ep.ram-0\", ram, rambases[0], ramsizes[0]); rambases[1] = 0x04000000; ramsizes[1] = 0x04000000; memoryregioninitalias(&rammemories[1], NULL, \"taihu405ep.ram-1\", ram, rambases[1], ramsizes[1]); #ifdef DEBUGBOARDINIT printf(\"%s: register cpu\\n\", func); #endif ppc405epinit(sysmem, rammemories, rambases, ramsizes, 33333333, &pic, kernelfilename == NULL ? 0 : 1); /* allocate and load BIOS */ #ifdef DEBUGBOARDINIT printf(\"%s: register BIOS\\n\", func); #endif flidx = 0; #if defined(USEFLASHBIOS) dinfo = driveget(IFPFLASH, 0, flidx); if (dinfo) { BlockDriverState *bs = blkbs(blkbylegacydinfo(dinfo)); biossize = bdrvgetlength(bs); /* XXX: should check that size is 2MB */ // biossize = 2 * 1024 * 1024; flsectors = (biossize + 65535) >> 16; #ifdef DEBUGBOARDINIT printf(\"Register parallel flash %d size %lx\" \" at addr %lx '%s' %d\\n\", flidx, biossize, -biossize, bdrvgetdevicename(bs), flsectors); #endif pflashcfi02register((uint32t)(-biossize), NULL, \"taihu405ep.bios\", biossize, bs, 65536, flsectors, 1, 4, 0x0001, 0x22DA, 0x0000, 0x0000, 0x555, 0x2AA, 1); flidx++; } else #endif { #ifdef DEBUGBOARDINIT printf(\"Load BIOS from file\\n\"); #endif if (biosname == NULL) biosname = BIOSFILENAME; bios = gnew(MemoryRegion, 1); memoryregioninitram(bios, NULL, \"taihu405ep.bios\", BIOSSIZE, &errorabort); vmstateregisterramglobal(bios); filename = qemufindfile(QEMUFILETYPEBIOS, biosname); if (filename) { biossize = loadimage(filename, memoryregiongetramptr(bios)); gfree(filename); if (biossize < 0 || biossize > BIOSSIZE) { errorreport(\"Could not load PowerPC BIOS '%s'\", biosname); exit(1); } biossize = (biossize + 0xfff) & ~0xfff; memoryregionaddsubregion(sysmem, (uint32t)(-biossize), bios); } else if (!qtestenabled()) { errorreport(\"Could not load PowerPC BIOS '%s'\", biosname); exit(1); } memoryregionsetreadonly(bios, true); } /* Register Linux flash */ dinfo = driveget(IFPFLASH, 0, flidx); if (dinfo) { BlockDriverState *bs = blkbs(blkbylegacydinfo(dinfo)); biossize = bdrvgetlength(bs); /* XXX: should check that size is 32MB */ biossize = 32 * 1024 * 1024; flsectors = (biossize + 65535) >> 16; #ifdef DEBUGBOARDINIT printf(\"Register parallel flash %d size %lx\" \" at addr \" TARGETFMTlx \" '%s'\\n\", flidx, biossize, (targetulong)0xfc000000, bdrvgetdevicename(bs)); #endif pflashcfi02register(0xfc000000, NULL, \"taihu405ep.flash\", biossize, bs, 65536, flsectors, 1, 4, 0x0001, 0x22DA, 0x0000, 0x0000, 0x555, 0x2AA, 1); flidx++; } /* Register CLPD & LCD display */ #ifdef DEBUGBOARDINIT printf(\"%s: register CPLD\\n\", func); #endif taihucpldinit(sysmem, 0x50100000); /* Load kernel */ linuxboot = (kernelfilename != NULL); if (linuxboot) { #ifdef DEBUGBOARDINIT printf(\"%s: load kernel\\n\", func); #endif kernelbase = KERNELLOADADDR; /* now we can load the kernel */ kernelsize = loadimagetargphys(kernelfilename, kernelbase, ramsize - kernelbase); if (kernelsize < 0) { fprintf(stderr, \"qemu: could not load kernel '%s'\\n\", kernelfilename); exit(1); } /* load initrd */ if (initrdfilename) { initrdbase = INITRDLOADADDR; initrdsize = loadimagetargphys(initrdfilename, initrdbase, ramsize - initrdbase); if (initrdsize < 0) { fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\", initrdfilename); exit(1); } } else { initrdbase = 0; initrdsize = 0; } } else { kernelbase = 0; kernelsize = 0; initrdbase = 0; initrdsize = 0; } #ifdef DEBUGBOARDINIT printf(\"%s: Done\\n\", func); #endif } ", "target": 0}
{"func": "static void *ffaviochildnext(void *obj, void *prev) { AVIOContext *s = obj; AVIOInternal *internal = s->opaque; return prev ? NULL : internal->h; } ", "target": 1}
{"func": "static void pmioportread(IORange *ioport, uint64t addr, unsigned width, uint64t *data) { PIIX4PMState *s = containerof(ioport, PIIX4PMState, ioport); uint32t val; switch(addr) { case 0x00: val = acpipm1evtgetsts(&s->ar, s->ar.tmr.overflowtime); break; case 0x02: val = s->ar.pm1.evt.en; break; case 0x04: val = s->ar.pm1.cnt.cnt; break; case 0x08: val = acpipmtmrget(&s->ar); break; default: val = 0; break; } PIIX4DPRINTF(\"PM readw port=0x%04x val=0x%04x\\n\", (unsigned int)addr, val); *data = val; } ", "target": 1}
{"func": "static int updatedimensions(VP8Context *s, int width, int height) { if (width != s->avctx->width || height != s->avctx->height) { if (avimagechecksize(width, height, 0, s->avctx)) return AVERRORINVALIDDATA; vp8decodeflushimpl(s->avctx, 1, 0, 1); avcodecsetdimensions(s->avctx, width, height); } s->mbwidth = (s->avctx->codedwidth +15) / 16; s->mbheight = (s->avctx->codedheight+15) / 16; s->macroblocksbase = avmallocz((s->mbwidth+s->mbheight*2+1)*sizeof(*s->macroblocks)); s->filterstrength = avmallocz(s->mbwidth*sizeof(*s->filterstrength)); s->intra4x4predmodetop = avmallocz(s->mbwidth*4); s->topnnz = avmallocz(s->mbwidth*sizeof(*s->topnnz)); s->topborder = avmallocz((s->mbwidth+1)*sizeof(*s->topborder)); if (!s->macroblocksbase || !s->filterstrength || !s->intra4x4predmodetop || !s->topnnz || !s->topborder) return AVERROR(ENOMEM); s->macroblocks = s->macroblocksbase + 1; return 0; } ", "target": 1}
{"func": "int nbdreceivereply(QIOChannel *ioc, NBDReply *reply, Error **errp) { int ret; const char *type; ret = nbdreadeof(ioc, &reply->magic, sizeof(reply->magic), errp); if (ret <= 0) { return ret; } be32tocpus(&reply->magic); switch (reply->magic) { case NBDSIMPLEREPLYMAGIC: ret = nbdreceivesimplereply(ioc, &reply->simple, errp); if (ret < 0) { break; } tracenbdreceivesimplereply(reply->simple.error, nbderrlookup(reply->simple.error), reply->handle); if (reply->simple.error == NBDESHUTDOWN) { /* This works even on mingw which lacks a native ESHUTDOWN */ errorsetg(errp, \"server shutting down\"); return -EINVAL; } break; case NBDSTRUCTUREDREPLYMAGIC: ret = nbdreceivestructuredreplychunk(ioc, &reply->structured, errp); if (ret < 0) { break; } type = nbdreplytypelookup(reply->structured.type); tracenbdreceivestructuredreplychunk(reply->structured.flags, reply->structured.type, type, reply->structured.handle, reply->structured.length); break; default: errorsetg(errp, \"invalid magic (got 0x%\" PRIx32 \")\", reply->magic); return -EINVAL; } if (ret < 0) { return ret; } return 1; } ", "target": 1}
{"func": "static void ne2000receive(void *opaque, const uint8t *buf, int size) { NE2000State *s = opaque; uint8t *p; int totallen, next, avail, len, index, mcastidx; uint8t buf1[60]; static const uint8t broadcastmacaddr[6] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }; #if defined(DEBUGNE2000) printf(\"NE2000: received len=%d\\n\", size); #endif if (!ne2000canreceive(s)) return; /* XXX: check this */ if (s->rxcr & 0x10) { /* promiscuous: receive all */ } else { if (!memcmp(buf, broadcastmacaddr, 6)) { /* broadcast address */ if (!(s->rxcr & 0x04)) return; } else if (buf[0] & 0x01) { /* multicast */ if (!(s->rxcr & 0x08)) return; mcastidx = computemcastidx(buf); if (!(s->mult[mcastidx >> 3] & (1 << (mcastidx & 7)))) return; } else if (s->mem[0] == buf[0] && s->mem[2] == buf[1] && s->mem[4] == buf[2] && s->mem[6] == buf[3] && s->mem[8] == buf[4] && s->mem[10] == buf[5]) { /* match */ } else { return; } } /* if too small buffer, then expand it */ if (size < MINBUFSIZE) { memcpy(buf1, buf, size); memset(buf1 + size, 0, MINBUFSIZE - size); buf = buf1; size = MINBUFSIZE; } index = s->curpag << 8; /* 4 bytes for header */ totallen = size + 4; /* address for next packet (4 bytes for CRC) */ next = index + ((totallen + 4 + 255) & ~0xff); if (next >= s->stop) next -= (s->stop - s->start); /* prepare packet header */ p = s->mem + index; s->rsr = ENRSRRXOK; /* receive status */ /* XXX: check this */ if (buf[0] & 0x01) s->rsr |= ENRSRPHY; p[0] = s->rsr; p[1] = next >> 8; p[2] = totallen; p[3] = totallen >> 8; index += 4; /* write packet data */ while (size > 0) { avail = s->stop - index; len = size; if (len > avail) len = avail; memcpy(s->mem + index, buf, len); buf += len; index += len; if (index == s->stop) index = s->start; size -= len; } s->curpag = next >> 8; /* now we can signal we have receive something */ s->isr |= ENISRRX; ne2000updateirq(s); } ", "target": 1}
{"func": "static void truespeechapplytwopointfilter(TSContext *dec, int quart) { int16t tmp[146 + 60], *ptr0, *ptr1; const int16t *filter; int i, t, off; t = dec->offset2[quart]; if(t == 127){ memset(dec->newvec, 0, 60 * sizeof(*dec->newvec)); return; } for(i = 0; i < 146; i++) tmp[i] = dec->filtbuf[i]; off = (t / 25) + dec->offset1[quart >> 1] + 18; ptr0 = tmp + 145 - off; ptr1 = tmp + 146; filter = (const int16t*)tsorder2coeffs + (t % 25) * 2; for(i = 0; i < 60; i++){ t = (ptr0[0] * filter[0] + ptr0[1] * filter[1] + 0x2000) >> 14; ptr0++; dec->newvec[i] = t; ptr1[i] = t; } }", "target": 1}
{"func": "static void scsidiskpurgerequests(SCSIDiskState *s) { SCSIDiskReq *r; while (!QTAILQEMPTY(&s->qdev.requests)) { r = DOUPCAST(SCSIDiskReq, req, QTAILQFIRST(&s->qdev.requests)); if (r->req.aiocb) { bdrvaiocancel(r->req.aiocb); } scsiremoverequest(r); } } ", "target": 1}
{"func": "static int netslirpinit(VLANState *vlan) { if (!slirpinited) { slirpinited = 1; slirpinit(); } slirpvc = qemunewvlanclient(vlan, slirpreceive, NULL); snprintf(slirpvc->infostr, sizeof(slirpvc->infostr), \"user redirector\"); return 0; } ", "target": 1}
{"func": "static int pnmdecodeheader(AVCodecContext *avctx, PNMContext * const s){ char buf1[32], tupletype[32]; int h, w, depth, maxval;; pnmget(s, buf1, sizeof(buf1)); if (!strcmp(buf1, \"P4\")) { avctx->pixfmt = PIXFMTMONOWHITE; } else if (!strcmp(buf1, \"P5\")) { if (avctx->codecid == CODECIDPGMYUV) avctx->pixfmt = PIXFMTYUV420P; else avctx->pixfmt = PIXFMTGRAY8; } else if (!strcmp(buf1, \"P6\")) { avctx->pixfmt = PIXFMTRGB24; } else if (!strcmp(buf1, \"P7\")) { w = -1; h = -1; maxval = -1; depth = -1; tupletype[0] = '\\0'; for(;;) { pnmget(s, buf1, sizeof(buf1)); if (!strcmp(buf1, \"WIDTH\")) { pnmget(s, buf1, sizeof(buf1)); w = strtol(buf1, NULL, 10); } else if (!strcmp(buf1, \"HEIGHT\")) { pnmget(s, buf1, sizeof(buf1)); h = strtol(buf1, NULL, 10); } else if (!strcmp(buf1, \"DEPTH\")) { pnmget(s, buf1, sizeof(buf1)); depth = strtol(buf1, NULL, 10); } else if (!strcmp(buf1, \"MAXVAL\")) { pnmget(s, buf1, sizeof(buf1)); maxval = strtol(buf1, NULL, 10); } else if (!strcmp(buf1, \"TUPLETYPE\")) { pnmget(s, tupletype, sizeof(tupletype)); } else if (!strcmp(buf1, \"ENDHDR\")) { break; } else { return -1; } } /* check that all tags are present */ if (w <= 0 || h <= 0 || maxval <= 0 || depth <= 0 || tupletype[0] == '\\0') return -1; avctx->width = w; avctx->height = h; if (depth == 1) { if (maxval == 1) avctx->pixfmt = PIXFMTMONOWHITE; else avctx->pixfmt = PIXFMTGRAY8; } else if (depth == 3) { avctx->pixfmt = PIXFMTRGB24; } else if (depth == 4) { avctx->pixfmt = PIXFMTRGBA32; } else { return -1; } return 0; } else { return -1; } pnmget(s, buf1, sizeof(buf1)); avctx->width = atoi(buf1); if (avctx->width <= 0) return -1; pnmget(s, buf1, sizeof(buf1)); avctx->height = atoi(buf1); if (avctx->height <= 0) return -1; if (avctx->pixfmt != PIXFMTMONOWHITE) { pnmget(s, buf1, sizeof(buf1)); } /* more check if YUV420 */ if (avctx->pixfmt == PIXFMTYUV420P) { if ((avctx->width & 1) != 0) return -1; h = (avctx->height * 2); if ((h % 3) != 0) return -1; h /= 3; avctx->height = h; } return 0; } ", "target": 1}
{"func": "void cpuphysicalmemoryrw(targetphysaddrt addr, uint8t *buf, int len, int iswrite) { return addressspacerw(&addressspacememory, addr, buf, len, iswrite); } ", "target": 0}
{"func": "static void v9fslink(void *opaque) { V9fsPDU *pdu = opaque; V9fsState *s = pdu->s; int32t dfid, oldfid; V9fsFidState *dfidp, *oldfidp; V9fsString name; sizet offset = 7; int err = 0; pduunmarshal(pdu, offset, \"dds\", &dfid, &oldfid, &name); tracev9fslink(pdu->tag, pdu->id, dfid, oldfid, name.data); dfidp = getfid(pdu, dfid); if (dfidp == NULL) { err = -ENOENT; goto outnofid; } oldfidp = getfid(pdu, oldfid); if (oldfidp == NULL) { err = -ENOENT; goto out; } err = v9fscolink(pdu, oldfidp, dfidp, &name); if (!err) { err = offset; } out: putfid(pdu, dfidp); outnofid: v9fsstringfree(&name); completepdu(s, pdu, err); } ", "target": 0}
{"func": "int dxva2init(AVCodecContext *s) { InputStream *ist = s->opaque; int loglevel = (ist->hwaccelid == HWACCELAUTO) ? AVLOGVERBOSE : AVLOGERROR; DXVA2Context *ctx; int ret; if (!ist->hwaccelctx) { ret = dxva2alloc(s); if (ret < 0) return ret; } ctx = ist->hwaccelctx; if (s->codecid == AVCODECIDH264 && (s->profile & ~FFPROFILEH264CONSTRAINED) > FFPROFILEH264HIGH) { avlog(NULL, loglevel, \"Unsupported H.264 profile for DXVA2 HWAccel: %d\\n\", s->profile); return AVERROR(EINVAL); } if (s->codecid == AVCODECIDHEVC && s->profile != FFPROFILEHEVCMAIN && s->profile != FFPROFILEHEVCMAIN10) { avlog(NULL, loglevel, \"Unsupported HEVC profile for DXVA2 HWAccel: %d\\n\", s->profile); return AVERROR(EINVAL); } avbufferunref(&ctx->hwframesctx); ret = dxva2createdecoder(s); if (ret < 0) { avlog(NULL, loglevel, \"Error creating the DXVA2 decoder\\n\"); return ret; } return 0; } ", "target": 0}
{"func": "static XenPTBarFlag xenptbarregparse(XenPCIPassthroughState *s, XenPTRegInfo *reg) { PCIDevice *d = &s->dev; XenPTRegion *region = NULL; PCIIORegion *r; int index = 0; /* check 64bit BAR */ index = xenptbaroffsettoindex(reg->offset); if ((0 < index) && (index < PCIROMSLOT)) { int type = s->realdevice.ioregions[index - 1].type; if ((type & XENHOSTPCIREGIONTYPEMEM) && (type & XENHOSTPCIREGIONTYPEMEM64)) { region = &s->bases[index - 1]; if (region->barflag != XENPTBARFLAGUPPER) { return XENPTBARFLAGUPPER; } } } /* check unused BAR */ r = &d->ioregions[index]; if (!xenptgetbarsize(r)) { return XENPTBARFLAGUNUSED; } /* for ExpROM BAR */ if (index == PCIROMSLOT) { return XENPTBARFLAGMEM; } /* check BAR I/O indicator */ if (s->realdevice.ioregions[index].type & XENHOSTPCIREGIONTYPEIO) { return XENPTBARFLAGIO; } else { return XENPTBARFLAGMEM; } } ", "target": 0}
{"func": "static avcold int g726encodeinit(AVCodecContext *avctx) { G726Context* c = avctx->privdata; if (avctx->strictstdcompliance > FFCOMPLIANCEUNOFFICIAL && avctx->samplerate != 8000) { avlog(avctx, AVLOGERROR, \"Sample rates other than 8kHz are not \" \"allowed when the compliance level is higher than unofficial. \" \"Resample or reduce the compliance level.\\n\"); return AVERROR(EINVAL); } if (avctx->samplerate <= 0) { avlog(avctx, AVLOGERROR, \"Samplerate is invalid\\n\"); return -1; } if(avctx->channels != 1){ avlog(avctx, AVLOGERROR, \"Only mono is supported\\n\"); return -1; } if (avctx->bitrate % avctx->samplerate) { avlog(avctx, AVLOGERROR, \"Bitrate - Samplerate combination is invalid\\n\"); return AVERROR(EINVAL); } c->codesize = (avctx->bitrate + avctx->samplerate/2) / avctx->samplerate; if (c->codesize < 2 || c->codesize > 5) { avlog(avctx, AVLOGERROR, \"Invalid number of bits %d\\n\", c->codesize); return AVERROR(EINVAL); } avctx->bitspercodedsample = c->codesize; g726reset(c, c->codesize - 2); avctx->codedframe = avcodecallocframe(); if (!avctx->codedframe) return AVERROR(ENOMEM); avctx->codedframe->keyframe = 1; /* select a frame size that will end on a byte boundary and have a size of approximately 1024 bytes */ avctx->framesize = ((int[]){ 4096, 2736, 2048, 1640 })[c->codesize - 2]; return 0; } ", "target": 1}
{"func": "static int dvreadseek(AVFormatContext *s, int streamindex, int64t timestamp, int flags) { RawDVContext *r = s->privdata; DVDemuxContext *c = r->dvdemux; int64t offset = dvframeoffset(s, c, timestamp, flags); dvoffsetreset(c, offset / c->sys->framesize); offset = avioseek(s->pb, offset, SEEKSET); return (offset < 0) ? offset : 0; } ", "target": 1}
{"func": "static void spaprphbhotplugchild(HotplugHandler *plughandler, DeviceState *pluggeddev, Error **errp) { sPAPRPHBState *phb = SPAPRPCIHOSTBRIDGE(DEVICE(plughandler)); PCIDevice *pdev = PCIDEVICE(pluggeddev); sPAPRDRConnector *drc = spaprphbgetpcidrc(phb, pdev); Error *localerr = NULL; /* if DR is disabled we don't need to do anything in the case of * hotplug or coldplug callbacks */ if (!phb->drenabled) { /* if this is a hotplug operation initiated by the user * we need to let them know it's not enabled */ if (pluggeddev->hotplugged) { errorsetg(errp, QERRBUSNOHOTPLUG, objectgettypename(OBJECT(phb))); } return; } gassert(drc); spaprphbaddpcidevice(drc, phb, pdev, &localerr); if (localerr) { errorpropagate(errp, localerr); return; } if (pluggeddev->hotplugged) { spaprhotplugreqaddbyindex(drc); } } ", "target": 1}
{"func": "avcold int ffdvvideoinit(AVCodecContext *avctx) { DVVideoContext *s = avctx->privdata; DSPContext dsp; static int done = 0; int i, j; if (!done) { VLC dvvlc; uint16t newdvvlcbits[NBDVVLC*2]; uint8t newdvvlclen[NBDVVLC*2]; uint8t newdvvlcrun[NBDVVLC*2]; int16t newdvvlclevel[NBDVVLC*2]; done = 1; /* it's faster to include sign bit in a generic VLC parsing scheme */ for (i = 0, j = 0; i < NBDVVLC; i++, j++) { newdvvlcbits[j] = dvvlcbits[i]; newdvvlclen[j] = dvvlclen[i]; newdvvlcrun[j] = dvvlcrun[i]; newdvvlclevel[j] = dvvlclevel[i]; if (dvvlclevel[i]) { newdvvlcbits[j] <<= 1; newdvvlclen[j]++; j++; newdvvlcbits[j] = (dvvlcbits[i] << 1) | 1; newdvvlclen[j] = dvvlclen[i] + 1; newdvvlcrun[j] = dvvlcrun[i]; newdvvlclevel[j] = -dvvlclevel[i]; } } /* NOTE: as a trick, we use the fact the no codes are unused to accelerate the parsing of partial codes */ initvlc(&dvvlc, TEXVLCBITS, j, newdvvlclen, 1, 1, newdvvlcbits, 2, 2, 0); assert(dvvlc.tablesize == 1184); for (i = 0; i < dvvlc.tablesize; i++){ int code = dvvlc.table[i][0]; int len = dvvlc.table[i][1]; int level, run; if (len < 0){ //more bits needed run = 0; level = code; } else { run = newdvvlcrun [code] + 1; level = newdvvlclevel[code]; } ffdvrlvlc[i].len = len; ffdvrlvlc[i].level = level; ffdvrlvlc[i].run = run; } fffreevlc(&dvvlc); } /* Generic DSP setup */ ffdsputilinit(&dsp, avctx); ffsetcmp(&dsp, dsp.ildctcmp, avctx->ildctcmp); s->getpixels = dsp.getpixels; s->ildctcmp = dsp.ildctcmp[5]; /* 88DCT setup */ s->fdct[0] = dsp.fdct; s->idctput[0] = dsp.idctput; for (i = 0; i < 64; i++) s->dvzigzag[0][i] = dsp.idctpermutation[ffzigzagdirect[i]]; /* 248DCT setup */ s->fdct[1] = dsp.fdct248; s->idctput[1] = ffsimpleidct248put; // FIXME: need to add it to DSP memcpy(s->dvzigzag[1], ffzigzag248direct, 64); avctx->codedframe = &s->picture; s->avctx = avctx; avctx->chromasamplelocation = AVCHROMALOCTOPLEFT; return 0; } ", "target": 0}
{"func": "static int libquvireadheader(AVFormatContext *s) { int i, ret; quvit q; quvimediat m; QUVIcode rc; LibQuviContext *qc = s->privdata; char *mediaurl, *pagetitle; rc = quviinit(&q); if (rc != QUVIOK) goto quvifail; quvisetopt(q, QUVIOPTFORMAT, qc->format); rc = quviparse(q, s->filename, &m); if (rc != QUVIOK) goto quvifail; rc = quvigetprop(m, QUVIPROPMEDIAURL, &mediaurl); if (rc != QUVIOK) goto quvifail; avassert0(!qc->fmtctx->codecwhitelist && !qc->fmtctx->formatwhitelist); qc->fmtctx-> codecwhitelist = avstrdup(s->codecwhitelist); qc->fmtctx->formatwhitelist = avstrdup(s->formatwhitelist); ret = avformatopeninput(&qc->fmtctx, mediaurl, NULL, NULL); if (ret < 0) goto end; rc = quvigetprop(m, QUVIPROPPAGETITLE, &pagetitle); if (rc == QUVIOK) avdictset(&s->metadata, \"title\", pagetitle, 0); for (i = 0; i < qc->fmtctx->nbstreams; i++) { AVStream *st = avformatnewstream(s, NULL); AVStream *ist = qc->fmtctx->streams[i]; if (!st) { ret = AVERROR(ENOMEM); goto end; } avprivsetptsinfo(st, ist->ptswrapbits, ist->timebase.num, ist->timebase.den); avcodeccopycontext(st->codec, qc->fmtctx->streams[i]->codec); } return 0; quvifail: avlog(s, AVLOGERROR, \"%s\\n\", quvistrerror(q, rc)); ret = AVERROREXTERNAL; end: quviparseclose(&m); quviclose(&q); return ret; } ", "target": 1}
{"func": "static int addoldstyleoptions(const char *fmt, QemuOpts *opts, const char *basefilename, const char *basefmt) { if (basefilename) { if (qemuoptset(opts, BLOCKOPTBACKINGFILE, basefilename)) { errorreport(\"Backing file not supported for file format '%s'\", fmt); return -1; } } if (basefmt) { if (qemuoptset(opts, BLOCKOPTBACKINGFMT, basefmt)) { errorreport(\"Backing file format not supported for file \" \"format '%s'\", fmt); return -1; } } return 0; } ", "target": 0}
{"func": "void qemuflushqueuedpackets(VLANClientState *vc) { while (!TAILQEMPTY(&vc->vlan->sendqueue)) { VLANPacket *packet; int ret; packet = TAILQFIRST(&vc->vlan->sendqueue); TAILQREMOVE(&vc->vlan->sendqueue, packet, entry); ret = qemudeliverpacket(packet->sender, packet->data, packet->size); if (ret == 0 && packet->sentcb != NULL) { TAILQINSERTHEAD(&vc->vlan->sendqueue, packet, entry); break; } if (packet->sentcb) packet->sentcb(packet->sender, ret); qemufree(packet); } } ", "target": 0}
{"func": "LFFUNC (h, luma, sse2) LFIFUNC(h, lumaintra, sse2) LFFUNC (v, luma, sse2) LFIFUNC(v, lumaintra, sse2) /***********************************/ /* weighted prediction */ #define H264WEIGHT(W, H, OPT) \\ void ffh264weight ## W ## x ## H ## ## OPT(uint8t *dst, \\ int stride, int log2denom, int weight, int offset); #define H264BIWEIGHT(W, H, OPT) \\ void ffh264biweight ## W ## x ## H ## ## OPT(uint8t *dst, \\ uint8t *src, int stride, int log2denom, int weightd, \\ int weights, int offset); #define H264BIWEIGHTMMX(W,H) \\ H264WEIGHT (W, H, mmx2) \\ H264BIWEIGHT(W, H, mmx2) #define H264BIWEIGHTMMXSSE(W,H) \\ H264BIWEIGHTMMX(W, H) \\ H264WEIGHT (W, H, sse2) \\ H264BIWEIGHT (W, H, sse2) \\ H264BIWEIGHT (W, H, ssse3) H264BIWEIGHTMMXSSE(16, 16) H264BIWEIGHTMMXSSE(16, 8) H264BIWEIGHTMMXSSE( 8, 16) H264BIWEIGHTMMXSSE( 8, 8) H264BIWEIGHTMMXSSE( 8, 4) H264BIWEIGHTMMX ( 4, 8) H264BIWEIGHTMMX ( 4, 4) H264BIWEIGHTMMX ( 4, 2) void ffh264dspinitx86(H264DSPContext *c) { int mmflags = avgetcpuflags(); if (mmflags & AVCPUFLAGMMX2) { c->h264loopfilterstrength= h264loopfilterstrengthmmx2; } #if HAVEYASM if (mmflags & AVCPUFLAGMMX) { c->h264idctdcadd= c->h264idctadd= ffh264idctaddmmx; c->h264idct8dcadd= c->h264idct8add= ffh264idct8addmmx; c->h264idctadd16 = ffh264idctadd16mmx; c->h264idct8add4 = ffh264idct8add4mmx; c->h264idctadd8 = ffh264idctadd8mmx; c->h264idctadd16intra= ffh264idctadd16intrammx; if (mmflags & AVCPUFLAGMMX2) { c->h264idctdcadd= ffh264idctdcaddmmx2; c->h264idct8dcadd= ffh264idct8dcaddmmx2; c->h264idctadd16 = ffh264idctadd16mmx2; c->h264idct8add4 = ffh264idct8add4mmx2; c->h264idctadd8 = ffh264idctadd8mmx2; c->h264idctadd16intra= ffh264idctadd16intrammx2; c->h264vloopfilterchroma= ffx264deblockvchromammxext; c->h264hloopfilterchroma= ffx264deblockhchromammxext; c->h264vloopfilterchromaintra= ffx264deblockvchromaintrammxext; c->h264hloopfilterchromaintra= ffx264deblockhchromaintrammxext; #if ARCHX8632 c->h264vloopfilterluma= ffx264deblockvlumammxext; c->h264hloopfilterluma= ffx264deblockhlumammxext; c->h264vloopfilterlumaintra = ffx264deblockvlumaintrammxext; c->h264hloopfilterlumaintra = ffx264deblockhlumaintrammxext; c->weighth264pixelstab[0]= ffh264weight16x16mmx2; c->weighth264pixelstab[1]= ffh264weight16x8mmx2; c->weighth264pixelstab[2]= ffh264weight8x16mmx2; c->weighth264pixelstab[3]= ffh264weight8x8mmx2; c->weighth264pixelstab[4]= ffh264weight8x4mmx2; c->weighth264pixelstab[5]= ffh264weight4x8mmx2; c->weighth264pixelstab[6]= ffh264weight4x4mmx2; c->weighth264pixelstab[7]= ffh264weight4x2mmx2; c->biweighth264pixelstab[0]= ffh264biweight16x16mmx2; c->biweighth264pixelstab[1]= ffh264biweight16x8mmx2; c->biweighth264pixelstab[2]= ffh264biweight8x16mmx2; c->biweighth264pixelstab[3]= ffh264biweight8x8mmx2; c->biweighth264pixelstab[4]= ffh264biweight8x4mmx2; c->biweighth264pixelstab[5]= ffh264biweight4x8mmx2; c->biweighth264pixelstab[6]= ffh264biweight4x4mmx2; c->biweighth264pixelstab[7]= ffh264biweight4x2mmx2; if (mmflags&AVCPUFLAGSSE2) { c->h264idct8add = ffh264idct8addsse2; c->h264idct8add4= ffh264idct8add4sse2; c->weighth264pixelstab[0]= ffh264weight16x16sse2; c->weighth264pixelstab[1]= ffh264weight16x8sse2; c->weighth264pixelstab[2]= ffh264weight8x16sse2; c->weighth264pixelstab[3]= ffh264weight8x8sse2; c->weighth264pixelstab[4]= ffh264weight8x4sse2; c->biweighth264pixelstab[0]= ffh264biweight16x16sse2; c->biweighth264pixelstab[1]= ffh264biweight16x8sse2; c->biweighth264pixelstab[2]= ffh264biweight8x16sse2; c->biweighth264pixelstab[3]= ffh264biweight8x8sse2; c->biweighth264pixelstab[4]= ffh264biweight8x4sse2; c->h264vloopfilterluma = ffx264deblockvlumasse2; c->h264hloopfilterluma = ffx264deblockhlumasse2; c->h264vloopfilterlumaintra = ffx264deblockvlumaintrasse2; c->h264hloopfilterlumaintra = ffx264deblockhlumaintrasse2; c->h264idctadd16 = ffh264idctadd16sse2; c->h264idctadd8 = ffh264idctadd8sse2; c->h264idctadd16intra = ffh264idctadd16intrasse2; } if (mmflags&AVCPUFLAGSSSE3) { c->biweighth264pixelstab[0]= ffh264biweight16x16ssse3; c->biweighth264pixelstab[1]= ffh264biweight16x8ssse3; c->biweighth264pixelstab[2]= ffh264biweight8x16ssse3; c->biweighth264pixelstab[3]= ffh264biweight8x8ssse3; c->biweighth264pixelstab[4]= ffh264biweight8x4ssse3; } } } }", "target": 1}
{"func": "static int decodebandhdr(IVI45DecContext *ctx, IVIBandDesc *band, AVCodecContext *avctx) { int plane, bandnum, indx, transformid, scanindx; int i; plane = getbits(&ctx->gb, 2); bandnum = getbits(&ctx->gb, 4); if (band->plane != plane || band->bandnum != bandnum) { avlog(avctx, AVLOGERROR, \"Invalid band header sequence!\\n\"); return AVERRORINVALIDDATA; } band->isempty = getbits1(&ctx->gb); if (!band->isempty) { int oldblksize = band->blksize; /* skip header size * If header size is not given, header size is 4 bytes. */ if (getbits1(&ctx->gb)) skipbits(&ctx->gb, 16); band->ishalfpel = getbits(&ctx->gb, 2); if (band->ishalfpel >= 2) { avlog(avctx, AVLOGERROR, \"Invalid/unsupported mv resolution: %d!\\n\", band->ishalfpel); return AVERRORINVALIDDATA; } #if IVI4STREAMANALYSER if (!band->ishalfpel) ctx->usesfullpel = 1; #endif band->checksumpresent = getbits1(&ctx->gb); if (band->checksumpresent) band->checksum = getbits(&ctx->gb, 16); indx = getbits(&ctx->gb, 2); if (indx == 3) { avlog(avctx, AVLOGERROR, \"Invalid block size!\\n\"); return AVERRORINVALIDDATA; } band->mbsize = 16 >> indx; band->blksize = 8 >> (indx >> 1); band->inheritmv = getbits1(&ctx->gb); band->inheritqdelta = getbits1(&ctx->gb); band->globquant = getbits(&ctx->gb, 5); if (!getbits1(&ctx->gb) || ctx->frametype == IVI4FRAMETYPEINTRA) { transformid = getbits(&ctx->gb, 5); if (transformid >= FFARRAYELEMS(transforms) || !transforms[transformid].invtrans) { avprivrequestsample(avctx, \"Transform %d\", transformid); return AVERRORPATCHWELCOME; } if ((transformid >= 7 && transformid <= 9) || transformid == 17) { avprivrequestsample(avctx, \"DCT transform\"); return AVERRORPATCHWELCOME; } #if IVI4STREAMANALYSER if ((transformid >= 0 && transformid <= 2) || transformid == 10) ctx->useshaar = 1; #endif band->invtransform = transforms[transformid].invtrans; band->dctransform = transforms[transformid].dctrans; band->is2dtrans = transforms[transformid].is2dtrans; if (transformid < 10) band->transformsize = 8; else band->transformsize = 4; if (band->blksize != band->transformsize) return AVERRORINVALIDDATA; scanindx = getbits(&ctx->gb, 4); if (scanindx == 15) { avlog(avctx, AVLOGERROR, \"Custom scan pattern encountered!\\n\"); return AVERRORINVALIDDATA; } if (scanindx > 4 && scanindx < 10) { if (band->blksize != 4) return AVERRORINVALIDDATA; } else if (band->blksize != 8) return AVERRORINVALIDDATA; band->scan = scanindextotab[scanindx]; band->quantmat = getbits(&ctx->gb, 5); if (band->quantmat >= FFARRAYELEMS(quantindextotab)) { if (band->quantmat == 31) avlog(avctx, AVLOGERROR, \"Custom quant matrix encountered!\\n\"); else avprivrequestsample(avctx, \"Quantization matrix %d\", band->quantmat); band->quantmat = -1; return AVERRORINVALIDDATA; } } else { if (oldblksize != band->blksize) { avlog(avctx, AVLOGERROR, \"The band block size does not match the configuration \" \"inherited\\n\"); return AVERRORINVALIDDATA; } if (band->quantmat < 0) { avlog(avctx, AVLOGERROR, \"Invalid quantmat inherited\\n\"); return AVERRORINVALIDDATA; } } /* decode block huffman codebook */ if (!getbits1(&ctx->gb)) band->blkvlc.tab = ctx->blkvlc.tab; else if (ffividechuffdesc(&ctx->gb, 1, IVIBLKHUFF, &band->blkvlc, avctx)) return AVERRORINVALIDDATA; /* select appropriate rvmap table for this band */ band->rvmapsel = getbits1(&ctx->gb) ? getbits(&ctx->gb, 3) : 8; /* decode rvmap probability corrections if any */ band->numcorr = 0; /* there is no corrections */ if (getbits1(&ctx->gb)) { band->numcorr = getbits(&ctx->gb, 8); /* get number of correction pairs */ if (band->numcorr > 61) { avlog(avctx, AVLOGERROR, \"Too many corrections: %d\\n\", band->numcorr); return AVERRORINVALIDDATA; } /* read correction pairs */ for (i = 0; i < band->numcorr * 2; i++) band->corr[i] = getbits(&ctx->gb, 8); } } if (band->blksize == 8) { band->intrabase = &ivi4quant8x8intra[quantindextotab[band->quantmat]][0]; band->interbase = &ivi4quant8x8inter[quantindextotab[band->quantmat]][0]; } else { band->intrabase = &ivi4quant4x4intra[quantindextotab[band->quantmat]][0]; band->interbase = &ivi4quant4x4inter[quantindextotab[band->quantmat]][0]; } /* Indeo 4 doesn't use scale tables */ band->intrascale = NULL; band->interscale = NULL; aligngetbits(&ctx->gb); return 0; } ", "target": 0}
{"func": "long dosyscall(void *cpuenv, int num, long arg1, long arg2, long arg3, long arg4, long arg5, long arg6) { long ret; struct stat st; struct kernelstatfs *stfs; #ifdef DEBUG gemulog(\"syscall %d\\n\", num); #endif switch(num) { case TARGETNRexit: #ifdef HAVEGPROF mcleanup(); #endif exit(arg1); ret = 0; /* avoid warning */ break; case TARGETNRread: ret = geterrno(read(arg1, (void *)arg2, arg3)); break; case TARGETNRwrite: ret = geterrno(write(arg1, (void *)arg2, arg3)); break; case TARGETNRopen: ret = geterrno(open((const char *)arg1, arg2, arg3)); break; case TARGETNRclose: ret = geterrno(close(arg1)); break; case TARGETNRbrk: ret = dobrk((char *)arg1); break; case TARGETNRfork: ret = geterrno(fork()); break; case TARGETNRwaitpid: { int *status = (int *)arg2; ret = geterrno(waitpid(arg1, status, arg3)); if (!iserror(ret) && status) tswapls((long *)&status); } break; case TARGETNRcreat: ret = geterrno(creat((const char *)arg1, arg2)); break; case TARGETNRlink: ret = geterrno(link((const char *)arg1, (const char *)arg2)); break; case TARGETNRunlink: ret = geterrno(unlink((const char *)arg1)); break; case TARGETNRexecve: ret = geterrno(execve((const char *)arg1, (void *)arg2, (void *)arg3)); break; case TARGETNRchdir: ret = geterrno(chdir((const char *)arg1)); break; case TARGETNRtime: { int *timeptr = (int *)arg1; ret = geterrno(time((timet *)timeptr)); if (!iserror(ret) && timeptr) tswap32s(timeptr); } break; case TARGETNRmknod: ret = geterrno(mknod((const char *)arg1, arg2, arg3)); break; case TARGETNRchmod: ret = geterrno(chmod((const char *)arg1, arg2)); break; case TARGETNRlchown: ret = geterrno(chown((const char *)arg1, arg2, arg3)); break; case TARGETNRbreak: goto unimplemented; case TARGETNRoldstat: goto unimplemented; case TARGETNRlseek: ret = geterrno(lseek(arg1, arg2, arg3)); break; case TARGETNRgetpid: ret = geterrno(getpid()); break; case TARGETNRmount: /* need to look at the data field */ goto unimplemented; case TARGETNRumount: ret = geterrno(umount((const char *)arg1)); break; case TARGETNRsetuid: ret = geterrno(setuid(arg1)); break; case TARGETNRgetuid: ret = geterrno(getuid()); break; case TARGETNRstime: { int *timeptr = (int *)arg1; if (timeptr) tswap32s(timeptr); ret = geterrno(stime((timet *)timeptr)); } break; case TARGETNRptrace: goto unimplemented; case TARGETNRalarm: ret = alarm(arg1); break; case TARGETNRoldfstat: goto unimplemented; case TARGETNRpause: ret = geterrno(pause()); break; case TARGETNRutime: goto unimplemented; case TARGETNRstty: goto unimplemented; case TARGETNRgtty: goto unimplemented; case TARGETNRaccess: ret = geterrno(access((const char *)arg1, arg2)); break; case TARGETNRnice: ret = geterrno(nice(arg1)); break; case TARGETNRftime: goto unimplemented; case TARGETNRsync: ret = geterrno(sync()); break; case TARGETNRkill: ret = geterrno(kill(arg1, arg2)); break; case TARGETNRrename: ret = geterrno(rename((const char *)arg1, (const char *)arg2)); break; case TARGETNRmkdir: ret = geterrno(mkdir((const char *)arg1, arg2)); break; case TARGETNRrmdir: ret = geterrno(rmdir((const char *)arg1)); break; case TARGETNRdup: ret = geterrno(dup(arg1)); break; case TARGETNRpipe: { int *pipeptr = (int *)arg1; ret = geterrno(pipe(pipeptr)); if (!iserror(ret)) { tswap32s(&pipeptr[0]); tswap32s(&pipeptr[1]); } } break; case TARGETNRtimes: goto unimplemented; case TARGETNRprof: goto unimplemented; case TARGETNRsetgid: ret = geterrno(setgid(arg1)); break; case TARGETNRgetgid: ret = geterrno(getgid()); break; case TARGETNRsignal: goto unimplemented; case TARGETNRgeteuid: ret = geterrno(geteuid()); break; case TARGETNRgetegid: ret = geterrno(getegid()); break; case TARGETNRacct: goto unimplemented; case TARGETNRumount2: ret = geterrno(umount2((const char *)arg1, arg2)); break; case TARGETNRlock: goto unimplemented; case TARGETNRioctl: ret = doioctl(arg1, arg2, arg3); break; case TARGETNRfcntl: switch(arg2) { case FGETLK: case FSETLK: case FSETLKW: goto unimplemented; default: ret = geterrno(fcntl(arg1, arg2, arg3)); break; } break; case TARGETNRmpx: goto unimplemented; case TARGETNRsetpgid: ret = geterrno(setpgid(arg1, arg2)); break; case TARGETNRulimit: goto unimplemented; case TARGETNRoldolduname: goto unimplemented; case TARGETNRumask: ret = geterrno(umask(arg1)); break; case TARGETNRchroot: ret = geterrno(chroot((const char *)arg1)); break; case TARGETNRustat: goto unimplemented; case TARGETNRdup2: ret = geterrno(dup2(arg1, arg2)); break; case TARGETNRgetppid: ret = geterrno(getppid()); break; case TARGETNRgetpgrp: ret = geterrno(getpgrp()); break; case TARGETNRsetsid: ret = geterrno(setsid()); break; case TARGETNRsigaction: #if 0 { int signum = arg1; struct targetoldsigaction *tact = arg2, *toldact = arg3; ret = geterrno(setsid()); } break; #else goto unimplemented; #endif case TARGETNRsgetmask: goto unimplemented; case TARGETNRssetmask: goto unimplemented; case TARGETNRsetreuid: ret = geterrno(setreuid(arg1, arg2)); break; case TARGETNRsetregid: ret = geterrno(setregid(arg1, arg2)); break; case TARGETNRsigsuspend: goto unimplemented; case TARGETNRsigpending: goto unimplemented; case TARGETNRsethostname: ret = geterrno(sethostname((const char *)arg1, arg2)); break; case TARGETNRsetrlimit: goto unimplemented; case TARGETNRgetrlimit: goto unimplemented; case TARGETNRgetrusage: goto unimplemented; case TARGETNRgettimeofday: { struct targettimeval *targettv = (void *)arg1; struct timeval tv; ret = geterrno(gettimeofday(&tv, NULL)); if (!iserror(ret)) { targettv->tvsec = tswapl(tv.tvsec); targettv->tvusec = tswapl(tv.tvusec); } } break; case TARGETNRsettimeofday: { struct targettimeval *targettv = (void *)arg1; struct timeval tv; tv.tvsec = tswapl(targettv->tvsec); tv.tvusec = tswapl(targettv->tvusec); ret = geterrno(settimeofday(&tv, NULL)); } break; case TARGETNRgetgroups: goto unimplemented; case TARGETNRsetgroups: goto unimplemented; case TARGETNRselect: goto unimplemented; case TARGETNRsymlink: ret = geterrno(symlink((const char *)arg1, (const char *)arg2)); break; case TARGETNRoldlstat: goto unimplemented; case TARGETNRreadlink: ret = geterrno(readlink((const char *)arg1, (char *)arg2, arg3)); break; case TARGETNRuselib: goto unimplemented; case TARGETNRswapon: ret = geterrno(swapon((const char *)arg1, arg2)); break; case TARGETNRreboot: goto unimplemented; case TARGETNRreaddir: goto unimplemented; #ifdef TARGETI386 case TARGETNRmmap: { uint32t v1, v2, v3, v4, v5, v6, *vptr; vptr = (uint32t *)arg1; v1 = tswap32(vptr[0]); v2 = tswap32(vptr[1]); v3 = tswap32(vptr[2]); v4 = tswap32(vptr[3]); v5 = tswap32(vptr[4]); v6 = tswap32(vptr[5]); ret = geterrno((long)mmap((void *)v1, v2, v3, v4, v5, v6)); } break; #endif #ifdef TARGETI386 case TARGETNRmmap2: #else case TARGETNRmmap: #endif ret = geterrno((long)mmap((void *)arg1, arg2, arg3, arg4, arg5, arg6)); break; case TARGETNRmunmap: ret = geterrno(munmap((void *)arg1, arg2)); break; case TARGETNRtruncate: ret = geterrno(truncate((const char *)arg1, arg2)); break; case TARGETNRftruncate: ret = geterrno(ftruncate(arg1, arg2)); break; case TARGETNRfchmod: ret = geterrno(fchmod(arg1, arg2)); break; case TARGETNRfchown: ret = geterrno(fchown(arg1, arg2, arg3)); break; case TARGETNRgetpriority: ret = geterrno(getpriority(arg1, arg2)); break; case TARGETNRsetpriority: ret = geterrno(setpriority(arg1, arg2, arg3)); break; case TARGETNRprofil: goto unimplemented; case TARGETNRstatfs: stfs = (void *)arg2; ret = geterrno(sysstatfs((const char *)arg1, stfs)); convertstatfs: if (!iserror(ret)) { tswap32s(&stfs->ftype); tswap32s(&stfs->fbsize); tswap32s(&stfs->fblocks); tswap32s(&stfs->fbfree); tswap32s(&stfs->fbavail); tswap32s(&stfs->ffiles); tswap32s(&stfs->fffree); tswap32s(&stfs->ffsid.val[0]); tswap32s(&stfs->ffsid.val[1]); tswap32s(&stfs->fnamelen); } break; case TARGETNRfstatfs: stfs = (void *)arg2; ret = geterrno(sysfstatfs(arg1, stfs)); goto convertstatfs; case TARGETNRioperm: goto unimplemented; case TARGETNRsocketcall: ret = dosocketcall(arg1, (long *)arg2); break; case TARGETNRsyslog: goto unimplemented; case TARGETNRsetitimer: goto unimplemented; case TARGETNRgetitimer: goto unimplemented; case TARGETNRstat: ret = geterrno(stat((const char *)arg1, &st)); goto dostat; case TARGETNRlstat: ret = geterrno(lstat((const char *)arg1, &st)); goto dostat; case TARGETNRfstat: { ret = geterrno(fstat(arg1, &st)); dostat: if (!iserror(ret)) { struct targetstat *targetst = (void *)arg2; targetst->stdev = tswap16(st.stdev); targetst->stino = tswapl(st.stino); targetst->stmode = tswap16(st.stmode); targetst->stnlink = tswap16(st.stnlink); targetst->stuid = tswap16(st.stuid); targetst->stgid = tswap16(st.stgid); targetst->strdev = tswap16(st.strdev); targetst->stsize = tswapl(st.stsize); targetst->stblksize = tswapl(st.stblksize); targetst->stblocks = tswapl(st.stblocks); targetst->statime = tswapl(st.statime); targetst->stmtime = tswapl(st.stmtime); targetst->stctime = tswapl(st.stctime); } } break; case TARGETNRolduname: goto unimplemented; case TARGETNRiopl: goto unimplemented; case TARGETNRvhangup: ret = geterrno(vhangup()); break; case TARGETNRidle: goto unimplemented; case TARGETNRvm86old: goto unimplemented; case TARGETNRwait4: { int status; targetlong *statusptr = (void *)arg2; struct rusage rusage, *rusageptr; struct targetrusage *targetrusage = (void *)arg4; if (targetrusage) rusageptr = &rusage; else rusageptr = NULL; ret = geterrno(wait4(arg1, &status, arg3, rusageptr)); if (!iserror(ret)) { if (statusptr) *statusptr = tswap32(status); if (targetrusage) { targetrusage->ruutime.tvsec = tswapl(rusage.ruutime.tvsec); targetrusage->ruutime.tvusec = tswapl(rusage.ruutime.tvusec); targetrusage->rustime.tvsec = tswapl(rusage.rustime.tvsec); targetrusage->rustime.tvusec = tswapl(rusage.rustime.tvusec); targetrusage->rumaxrss = tswapl(rusage.rumaxrss); targetrusage->ruixrss = tswapl(rusage.ruixrss); targetrusage->ruidrss = tswapl(rusage.ruidrss); targetrusage->ruisrss = tswapl(rusage.ruisrss); targetrusage->ruminflt = tswapl(rusage.ruminflt); targetrusage->rumajflt = tswapl(rusage.rumajflt); targetrusage->runswap = tswapl(rusage.runswap); targetrusage->ruinblock = tswapl(rusage.ruinblock); targetrusage->ruoublock = tswapl(rusage.ruoublock); targetrusage->rumsgsnd = tswapl(rusage.rumsgsnd); targetrusage->rumsgrcv = tswapl(rusage.rumsgrcv); targetrusage->runsignals = tswapl(rusage.runsignals); targetrusage->runvcsw = tswapl(rusage.runvcsw); targetrusage->runivcsw = tswapl(rusage.runivcsw); } } } break; case TARGETNRswapoff: ret = geterrno(swapoff((const char *)arg1)); break; case TARGETNRsysinfo: goto unimplemented; case TARGETNRipc: goto unimplemented; case TARGETNRfsync: ret = geterrno(fsync(arg1)); break; case TARGETNRsigreturn: goto unimplemented; case TARGETNRclone: goto unimplemented; case TARGETNRsetdomainname: ret = geterrno(setdomainname((const char *)arg1, arg2)); break; case TARGETNRuname: /* no need to transcode because we use the linux syscall */ ret = geterrno(sysuname((struct newutsname *)arg1)); break; #ifdef TARGETI386 case TARGETNRmodifyldt: ret = geterrno(gemumodifyldt(cpuenv, arg1, (void *)arg2, arg3)); break; #endif case TARGETNRadjtimex: goto unimplemented; case TARGETNRmprotect: ret = geterrno(mprotect((void *)arg1, arg2, arg3)); break; case TARGETNRsigprocmask: { int how = arg1; sigsett set, oldset, *setptr; targetulong *pset = (void *)arg2, *poldset = (void *)arg3; switch(how) { case TARGETSIGBLOCK: how = SIGBLOCK; break; case TARGETSIGUNBLOCK: how = SIGUNBLOCK; break; case TARGETSIGSETMASK: how = SIGSETMASK; break; default: ret = -EINVAL; goto fail; } if (pset) { targettohostoldsigset(&set, pset); setptr = &set; } else { setptr = NULL; } ret = geterrno(sigprocmask(arg1, setptr, &oldset)); if (!iserror(ret) && poldset) { hosttotargetoldsigset(poldset, &oldset); } } break; case TARGETNRcreatemodule: case TARGETNRinitmodule: case TARGETNRdeletemodule: case TARGETNRgetkernelsyms: goto unimplemented; case TARGETNRquotactl: goto unimplemented; case TARGETNRgetpgid: ret = geterrno(getpgid(arg1)); break; case TARGETNRfchdir: ret = geterrno(fchdir(arg1)); break; case TARGETNRbdflush: goto unimplemented; case TARGETNRsysfs: goto unimplemented; case TARGETNRpersonality: ret = geterrno(mprotect((void *)arg1, arg2, arg3)); break; case TARGETNRafssyscall: goto unimplemented; case TARGETNRsetfsuid: goto unimplemented; case TARGETNRsetfsgid: goto unimplemented; case TARGETNRllseek: { int64t res; ret = geterrno(llseek(arg1, arg2, arg3, &res, arg5)); *(int64t *)arg4 = tswap64(res); } break; case TARGETNRgetdents: #if TARGETLONGSIZE != 4 #error not supported #endif { struct dirent *dirp = (void *)arg2; long count = arg3; ret = geterrno(sysgetdents(arg1, dirp, count)); if (!iserror(ret)) { struct dirent *de; int len = ret; int reclen; de = dirp; while (len > 0) { reclen = tswap16(de->dreclen); if (reclen > len) break; de->dreclen = reclen; tswapls(&de->dino); tswapls(&de->doff); de = (struct dirent *)((char *)de + reclen); len -= reclen; } } } break; case TARGETNRnewselect: ret = doselect(arg1, (void *)arg2, (void *)arg3, (void *)arg4, (void *)arg5); break; case TARGETNRflock: goto unimplemented; case TARGETNRmsync: ret = geterrno(msync((void *)arg1, arg2, arg3)); break; case TARGETNRreadv: { int count = arg3; int i; struct iovec *vec; struct targetiovec *targetvec = (void *)arg2; vec = alloca(count * sizeof(struct iovec)); for(i = 0;i < count; i++) { vec[i].iovbase = (void *)tswapl(targetvec[i].iovbase); vec[i].iovlen = tswapl(targetvec[i].iovlen); } ret = geterrno(readv(arg1, vec, count)); } break; case TARGETNRwritev: { int count = arg3; int i; struct iovec *vec; struct targetiovec *targetvec = (void *)arg2; vec = alloca(count * sizeof(struct iovec)); for(i = 0;i < count; i++) { vec[i].iovbase = (void *)tswapl(targetvec[i].iovbase); vec[i].iovlen = tswapl(targetvec[i].iovlen); } ret = geterrno(writev(arg1, vec, count)); } break; case TARGETNRgetsid: ret = geterrno(getsid(arg1)); break; case TARGETNRfdatasync: goto unimplemented; case TARGETNRsysctl: goto unimplemented; case TARGETNRmlock: ret = geterrno(mlock((void *)arg1, arg2)); break; case TARGETNRmunlock: ret = geterrno(munlock((void *)arg1, arg2)); break; case TARGETNRmlockall: ret = geterrno(mlockall(arg1)); break; case TARGETNRmunlockall: ret = geterrno(munlockall()); break; case TARGETNRschedsetparam: goto unimplemented; case TARGETNRschedgetparam: goto unimplemented; case TARGETNRschedsetscheduler: goto unimplemented; case TARGETNRschedgetscheduler: goto unimplemented; case TARGETNRschedyield: ret = geterrno(schedyield()); break; case TARGETNRschedgetprioritymax: case TARGETNRschedgetprioritymin: case TARGETNRschedrrgetinterval: case TARGETNRnanosleep: case TARGETNRmremap: case TARGETNRsetresuid: case TARGETNRgetresuid: case TARGETNRvm86: case TARGETNRquerymodule: case TARGETNRpoll: case TARGETNRnfsservctl: case TARGETNRsetresgid: case TARGETNRgetresgid: case TARGETNRprctl: case TARGETNRrtsigreturn: case TARGETNRrtsigaction: case TARGETNRrtsigprocmask: case TARGETNRrtsigpending: case TARGETNRrtsigtimedwait: case TARGETNRrtsigqueueinfo: case TARGETNRrtsigsuspend: case TARGETNRpread: case TARGETNRpwrite: goto unimplemented; case TARGETNRchown: ret = geterrno(chown((const char *)arg1, arg2, arg3)); break; case TARGETNRgetcwd: ret = geterrno(sysgetcwd1((char *)arg1, arg2)); break; case TARGETNRcapget: case TARGETNRcapset: case TARGETNRsigaltstack: case TARGETNRsendfile: case TARGETNRgetpmsg: case TARGETNRputpmsg: case TARGETNRvfork: ret = geterrno(vfork()); break; case TARGETNRugetrlimit: case TARGETNRtruncate64: case TARGETNRftruncate64: case TARGETNRstat64: case TARGETNRlstat64: case TARGETNRfstat64: case TARGETNRlchown32: case TARGETNRgetuid32: case TARGETNRgetgid32: case TARGETNRgeteuid32: case TARGETNRgetegid32: case TARGETNRsetreuid32: case TARGETNRsetregid32: case TARGETNRgetgroups32: case TARGETNRsetgroups32: case TARGETNRfchown32: case TARGETNRsetresuid32: case TARGETNRgetresuid32: case TARGETNRsetresgid32: case TARGETNRgetresgid32: case TARGETNRchown32: case TARGETNRsetuid32: case TARGETNRsetgid32: case TARGETNRsetfsuid32: case TARGETNRsetfsgid32: case TARGETNRpivotroot: case TARGETNRmincore: case TARGETNRmadvise: case TARGETNRgetdents64: case TARGETNRfcntl64: case TARGETNRsecurity: goto unimplemented; case TARGETNRgettid: ret = geterrno(gettid()); break; case TARGETNRreadahead: case TARGETNRsetxattr: case TARGETNRlsetxattr: case TARGETNRfsetxattr: case TARGETNRgetxattr: case TARGETNRlgetxattr: case TARGETNRfgetxattr: case TARGETNRlistxattr: case TARGETNRllistxattr: case TARGETNRflistxattr: case TARGETNRremovexattr: case TARGETNRlremovexattr: case TARGETNRfremovexattr: goto unimplemented; default: unimplemented: gemulog(\"Unsupported syscall: %d\\n\", num); ret = -ENOSYS; break; } fail: return ret; } ", "target": 0}
{"func": "static int rebuildrefcountstructure(BlockDriverState *bs, BdrvCheckResult *res, void **refcounttable, int64t *nbclusters) { BDRVQcow2State *s = bs->opaque; int64t firstfreecluster = 0, reftableoffset = -1, cluster = 0; int64t refblockoffset, refblockstart, refblockindex; uint32t reftablesize = 0; uint64t *ondiskreftable = NULL; void *ondiskrefblock; int ret = 0; struct { uint64t reftableoffset; uint32t reftableclusters; } QEMUPACKED reftableoffsetandclusters; qcow2cacheempty(bs, s->refcountblockcache); writerefblocks: for (; cluster < *nbclusters; cluster++) { if (!s->getrefcount(*refcounttable, cluster)) { continue; } refblockindex = cluster >> s->refcountblockbits; refblockstart = refblockindex << s->refcountblockbits; /* Don't allocate a cluster in a refblock already written to disk */ if (firstfreecluster < refblockstart) { firstfreecluster = refblockstart; } refblockoffset = allocclustersimrt(bs, 1, refcounttable, nbclusters, &firstfreecluster); if (refblockoffset < 0) { fprintf(stderr, \"ERROR allocating refblock: %s\\n\", strerror(-refblockoffset)); res->checkerrors++; ret = refblockoffset; goto fail; } if (reftablesize <= refblockindex) { uint32t oldreftablesize = reftablesize; uint64t *newondiskreftable; reftablesize = ROUNDUP((refblockindex + 1) * sizeof(uint64t), s->clustersize) / sizeof(uint64t); newondiskreftable = gtryrealloc(ondiskreftable, reftablesize * sizeof(uint64t)); if (!newondiskreftable) { res->checkerrors++; ret = -ENOMEM; goto fail; } ondiskreftable = newondiskreftable; memset(ondiskreftable + oldreftablesize, 0, (reftablesize - oldreftablesize) * sizeof(uint64t)); /* The offset we have for the reftable is now no longer valid; * this will leak that range, but we can easily fix that by running * a leak-fixing check after this rebuild operation */ reftableoffset = -1; } ondiskreftable[refblockindex] = refblockoffset; /* If this is apparently the last refblock (for now), try to squeeze the * reftable in */ if (refblockindex == (*nbclusters - 1) >> s->refcountblockbits && reftableoffset < 0) { uint64t reftableclusters = sizetoclusters(s, reftablesize * sizeof(uint64t)); reftableoffset = allocclustersimrt(bs, reftableclusters, refcounttable, nbclusters, &firstfreecluster); if (reftableoffset < 0) { fprintf(stderr, \"ERROR allocating reftable: %s\\n\", strerror(-reftableoffset)); res->checkerrors++; ret = reftableoffset; goto fail; } } ret = qcow2prewriteoverlapcheck(bs, 0, refblockoffset, s->clustersize); if (ret < 0) { fprintf(stderr, \"ERROR writing refblock: %s\\n\", strerror(-ret)); goto fail; } /* The size of *refcounttable is always cluster-aligned, therefore the * write operation will not overflow */ ondiskrefblock = (void *)((char *) *refcounttable + refblockindex * s->clustersize); ret = bdrvwrite(bs->file, refblockoffset / BDRVSECTORSIZE, ondiskrefblock, s->clustersectors); if (ret < 0) { fprintf(stderr, \"ERROR writing refblock: %s\\n\", strerror(-ret)); goto fail; } /* Go to the end of this refblock */ cluster = refblockstart + s->refcountblocksize - 1; } if (reftableoffset < 0) { uint64t postrefblockstart, reftableclusters; postrefblockstart = ROUNDUP(*nbclusters, s->refcountblocksize); reftableclusters = sizetoclusters(s, reftablesize * sizeof(uint64t)); /* Not pretty but simple */ if (firstfreecluster < postrefblockstart) { firstfreecluster = postrefblockstart; } reftableoffset = allocclustersimrt(bs, reftableclusters, refcounttable, nbclusters, &firstfreecluster); if (reftableoffset < 0) { fprintf(stderr, \"ERROR allocating reftable: %s\\n\", strerror(-reftableoffset)); res->checkerrors++; ret = reftableoffset; goto fail; } goto writerefblocks; } assert(ondiskreftable); for (refblockindex = 0; refblockindex < reftablesize; refblockindex++) { cputobe64s(&ondiskreftable[refblockindex]); } ret = qcow2prewriteoverlapcheck(bs, 0, reftableoffset, reftablesize * sizeof(uint64t)); if (ret < 0) { fprintf(stderr, \"ERROR writing reftable: %s\\n\", strerror(-ret)); goto fail; } assert(reftablesize < INTMAX / sizeof(uint64t)); ret = bdrvpwrite(bs->file, reftableoffset, ondiskreftable, reftablesize * sizeof(uint64t)); if (ret < 0) { fprintf(stderr, \"ERROR writing reftable: %s\\n\", strerror(-ret)); goto fail; } /* Enter new reftable into the image header */ reftableoffsetandclusters.reftableoffset = cputobe64(reftableoffset); reftableoffsetandclusters.reftableclusters = cputobe32(sizetoclusters(s, reftablesize * sizeof(uint64t))); ret = bdrvpwritesync(bs->file, offsetof(QCowHeader, refcounttableoffset), &reftableoffsetandclusters, sizeof(reftableoffsetandclusters)); if (ret < 0) { fprintf(stderr, \"ERROR setting reftable: %s\\n\", strerror(-ret)); goto fail; } for (refblockindex = 0; refblockindex < reftablesize; refblockindex++) { be64tocpus(&ondiskreftable[refblockindex]); } s->refcounttable = ondiskreftable; s->refcounttableoffset = reftableoffset; s->refcounttablesize = reftablesize; updatemaxrefcounttableindex(s); return 0; fail: gfree(ondiskreftable); return ret; } ", "target": 1}
{"func": "static int synchronizeaudio(VideoState *is, short *samples, int samplessize1, double pts) { int n, samplessize; double refclock; n = 2 * is->audiost->codec->channels; samplessize = samplessize1; /* if not master, then we try to remove or add samples to correct the clock */ if (((is->avsynctype == AVSYNCVIDEOMASTER && is->videost) || is->avsynctype == AVSYNCEXTERNALCLOCK)) { double diff, avgdiff; int wantedsize, minsize, maxsize, nbsamples; refclock = getmasterclock(is); diff = getaudioclock(is) - refclock; if (diff < AVNOSYNCTHRESHOLD) { is->audiodiffcum = diff + is->audiodiffavgcoef * is->audiodiffcum; if (is->audiodiffavgcount < AUDIODIFFAVGNB) { /* not enough measures to have a correct estimate */ is->audiodiffavgcount++; } else { /* estimate the A-V difference */ avgdiff = is->audiodiffcum * (1.0 - is->audiodiffavgcoef); if (fabs(avgdiff) >= is->audiodiffthreshold) { wantedsize = samplessize + ((int)(diff * is->audiost->codec->samplerate) * n); nbsamples = samplessize / n; minsize = ((nbsamples * (100 - SAMPLECORRECTIONPERCENTMAX)) / 100) * n; maxsize = ((nbsamples * (100 + SAMPLECORRECTIONPERCENTMAX)) / 100) * n; if (wantedsize < minsize) wantedsize = minsize; else if (wantedsize > maxsize) wantedsize = maxsize; /* add or remove samples to correction the synchro */ if (wantedsize < samplessize) { /* remove samples */ samplessize = wantedsize; } else if (wantedsize > samplessize) { uint8t *samplesend, *q; int nb; /* add samples */ nb = (samplessize - wantedsize); samplesend = (uint8t *)samples + samplessize - n; q = samplesend + n; while (nb > 0) { memcpy(q, samplesend, n); q += n; nb -= n; } samplessize = wantedsize; } } avdlog(NULL, \"diff=%f adiff=%f samplediff=%d apts=%0.3f vpts=%0.3f %f\\n\", diff, avgdiff, samplessize - samplessize1, is->audioclock, is->videoclock, is->audiodiffthreshold); } } else { /* too big difference : may be initial PTS errors, so reset A-V filter */ is->audiodiffavgcount = 0; is->audiodiffcum = 0; } } return samplessize; } ", "target": 0}
{"func": "avcold int ffiviinitplanes(IVIPlaneDesc *planes, const IVIPicConfig *cfg, int isindeo4) { int p, b; uint32t bwidth, bheight, alignfac, widthaligned, heightaligned, bufsize; IVIBandDesc *band; ivifreebuffers(planes); if (avimagechecksize(cfg->picwidth, cfg->picheight, 0, NULL) < 0 || cfg->lumabands < 1 || cfg->chromabands < 1) return AVERRORINVALIDDATA; /* fill in the descriptor of the luminance plane */ planes[0].width = cfg->picwidth; planes[0].height = cfg->picheight; planes[0].numbands = cfg->lumabands; /* fill in the descriptors of the chrominance planes */ planes[1].width = planes[2].width = (cfg->picwidth + 3) >> 2; planes[1].height = planes[2].height = (cfg->picheight + 3) >> 2; planes[1].numbands = planes[2].numbands = cfg->chromabands; for (p = 0; p < 3; p++) { planes[p].bands = avmalloczarray(planes[p].numbands, sizeof(IVIBandDesc)); if (!planes[p].bands) return AVERROR(ENOMEM); /* select band dimensions: if there is only one band then it * has the full size, if there are several bands each of them * has only half size */ bwidth = planes[p].numbands == 1 ? planes[p].width : (planes[p].width + 1) >> 1; bheight = planes[p].numbands == 1 ? planes[p].height : (planes[p].height + 1) >> 1; /* luma band buffers will be aligned on 16x16 (max macroblock size) */ /* chroma band buffers will be aligned on 8x8 (max macroblock size) */ alignfac = p ? 8 : 16; widthaligned = FFALIGN(bwidth , alignfac); heightaligned = FFALIGN(bheight, alignfac); bufsize = widthaligned * heightaligned * sizeof(int16t); for (b = 0; b < planes[p].numbands; b++) { band = &planes[p].bands[b]; /* select appropriate plane/band */ band->plane = p; band->bandnum = b; band->width = bwidth; band->height = bheight; band->pitch = widthaligned; band->aheight = heightaligned; band->bufs[0] = avmallocz(bufsize); band->bufs[1] = avmallocz(bufsize); band->bufsize = bufsize/2; if (!band->bufs[0] || !band->bufs[1]) return AVERROR(ENOMEM); /* allocate the 3rd band buffer for scalability mode */ if (cfg->lumabands > 1) { band->bufs[2] = avmallocz(bufsize); if (!band->bufs[2]) return AVERROR(ENOMEM); } if (isindeo4) { band->bufs[3] = avmallocz(bufsize); if (!band->bufs[3]) return AVERROR(ENOMEM); } /* reset custom vlc */ planes[p].bands[0].blkvlc.custdesc.numrows = 0; } } return 0; } ", "target": 1}
{"func": "static avcold int seqvideodecodeinit(AVCodecContext *avctx) { SeqVideoContext *seq = avctx->privdata; seq->avctx = avctx; avctx->pixfmt = AVPIXFMTPAL8; seq->frame = avframealloc(); if (!seq->frame) return AVERROR(ENOMEM); return 0; }", "target": 1}
{"func": "static BlockAIOCB *bdrvcoaiorwvector(BdrvChild *child, int64t sectornum, QEMUIOVector *qiov, int nbsectors, BdrvRequestFlags flags, BlockCompletionFunc *cb, void *opaque, bool iswrite) { Coroutine *co; BlockAIOCBCoroutine *acb; acb = qemuaioget(&bdrvemcoaiocbinfo, child->bs, cb, opaque); acb->child = child; acb->needbh = true; acb->req.error = -EINPROGRESS; acb->req.sector = sectornum; acb->req.nbsectors = nbsectors; acb->req.qiov = qiov; acb->req.flags = flags; acb->iswrite = iswrite; co = qemucoroutinecreate(bdrvcodorw); qemucoroutineenter(co, acb); bdrvcomaybeschedulebh(acb); return &acb->common; } ", "target": 1}
{"func": "static int standarddecodepicturesecondaryheader(VC9Context *v) { GetBitContext *gb = &v->s.gb; int status = 0, index; switch (v->s.picttype) { case PTYPE: status = decodeppicturesecondaryheader(v); break; case BTYPE: status = decodebpicturesecondaryheader(v); break; case BITYPE: case ITYPE: break; //Nothing needed as it's done in the epilog } if (status < 0) return FRAMESKIPED; /* AC Syntax */ v->actablelevel = decode012(gb); if (v->s.picttype == ITYPE || v->s.picttype == BITYPE) { v->ac2tablelevel = decode012(gb); } /* DC Syntax */ index = decode012(gb); v->lumadcvlc = &ffmsmp4dclumavlc[index]; v->chromadcvlc = &ffmsmp4dcchromavlc[index]; return 0; } ", "target": 1}
{"func": "static void ccwmachineclassinit(ObjectClass *oc, void *data) { MachineClass *mc = MACHINECLASS(oc); NMIClass *nc = NMICLASS(oc); HotplugHandlerClass *hc = HOTPLUGHANDLERCLASS(oc); S390CcwMachineClass *s390mc = S390MACHINECLASS(mc); s390mc->riallowed = true; s390mc->cpumodelallowed = true; s390mc->cssmigrationenabled = true; s390mc->gsallowed = true; mc->init = ccwinit; mc->reset = s390machinereset; mc->hotaddcpu = s390hotaddcpu; mc->blockdefaulttype = IFVIRTIO; mc->nocdrom = 1; mc->nofloppy = 1; mc->noserial = 1; mc->noparallel = 1; mc->nosdcard = 1; mc->usesclp = 1; mc->maxcpus = S390MAXCPUS; mc->hashotpluggablecpus = true; mc->gethotplughandler = s390gethotplughandler; mc->cpuindextoinstanceprops = s390cpuindextoprops; mc->possiblecpuarchids = s390possiblecpuarchids; /* it is overridden with 'host' cpu *in kvmarchinit* */ mc->defaultcputype = S390CPUTYPENAME(\"qemu\"); hc->plug = s390machinedeviceplug; hc->unplugrequest = s390machinedeviceunplugrequest; nc->nmimonitorhandler = s390nmi; } ", "target": 1}
{"func": "static int writecvidheader(CinepakEncContext *s, unsigned char *buf, int numstrips, int datasize) { buf[0] = 0; AVWB24(&buf[1], datasize + CVIDHEADERSIZE); AVWB16(&buf[4], s->w); AVWB16(&buf[6], s->h); AVWB16(&buf[8], numstrips); return CVIDHEADERSIZE; } ", "target": 1}
{"func": "static avcold int mpeg4videoparseinit(AVCodecParserContext *s) { ParseContext1 *pc = s->privdata; pc->enc = avmallocz(sizeof(MpegEncContext)); if (!pc->enc) return -1; pc->firstpicture = 1; return 0; }", "target": 1}
{"func": "const AVOption *avoptnext(void *obj, const AVOption *last) { AVClass *class = *(AVClass**)obj; if (!last && class->option[0].name) return class->option; if (last && last[1].name) return ++last; return NULL; } ", "target": 1}
{"func": "static void doaudioout(AVFormatContext *s, OutputStream *ost, InputStream *ist, AVFrame *decodedframe) { uint8t *buftmp; int sizeout, framebytes, resamplechanged, ret; AVCodecContext *enc = ost->st->codec; AVCodecContext *dec = ist->st->codec; int osize = avgetbytespersample(enc->samplefmt); int isize = avgetbytespersample(dec->samplefmt); uint8t *buf = decodedframe->data[0]; int size = decodedframe->nbsamples * dec->channels * isize; int outlinesize = 0; int buflinesize = decodedframe->linesize[0]; getdefaultchannellayouts(ost, ist); if (allocaudiooutputbuf(dec, enc, decodedframe->nbsamples, &outlinesize) < 0) { avlog(NULL, AVLOGFATAL, \"Error allocating audio buffer\\n\"); exitprogram(1); } if (audiosyncmethod > 1 || enc->channels != dec->channels || enc->channellayout != dec->channellayout || enc->samplerate != dec->samplerate || dec->samplefmt != enc->samplefmt) ost->audioresample = 1; resamplechanged = ost->resamplesamplefmt != dec->samplefmt || ost->resamplechannels != dec->channels || ost->resamplechannellayout != dec->channellayout || ost->resamplesamplerate != dec->samplerate; if ((ost->audioresample && !ost->avr) || resamplechanged) { if (resamplechanged) { avlog(NULL, AVLOGINFO, \"Input stream #%d:%d frame changed from rate:%d fmt:%s ch:%d chl:0x%\"PRIx64\" to rate:%d fmt:%s ch:%d chl:0x%\"PRIx64\"\\n\", ist->fileindex, ist->st->index, ost->resamplesamplerate, avgetsamplefmtname(ost->resamplesamplefmt), ost->resamplechannels, ost->resamplechannellayout, dec->samplerate, avgetsamplefmtname(dec->samplefmt), dec->channels, dec->channellayout); ost->resamplesamplefmt = dec->samplefmt; ost->resamplechannels = dec->channels; ost->resamplechannellayout = dec->channellayout; ost->resamplesamplerate = dec->samplerate; if (ost->avr) avresampleclose(ost->avr); } /* if audiosyncmethod is >1 the resampler is needed for audio drift compensation */ if (audiosyncmethod <= 1 && ost->resamplesamplefmt == enc->samplefmt && ost->resamplechannels == enc->channels && ost->resamplechannellayout == enc->channellayout && ost->resamplesamplerate == enc->samplerate) { ost->audioresample = 0; } else if (ost->audioresample) { if (!ost->avr) { ost->avr = avresamplealloccontext(); if (!ost->avr) { avlog(NULL, AVLOGFATAL, \"Error allocating context for libavresample\\n\"); exitprogram(1); } } avoptsetint(ost->avr, \"inchannellayout\", dec->channellayout, 0); avoptsetint(ost->avr, \"insamplefmt\", dec->samplefmt, 0); avoptsetint(ost->avr, \"insamplerate\", dec->samplerate, 0); avoptsetint(ost->avr, \"outchannellayout\", enc->channellayout, 0); avoptsetint(ost->avr, \"outsamplefmt\", enc->samplefmt, 0); avoptsetint(ost->avr, \"outsamplerate\", enc->samplerate, 0); if (audiosyncmethod > 1) avoptsetint(ost->avr, \"forceresampling\", 1, 0); /* if both the input and output formats are s16 or u8, use s16 as the internal sample format */ if (avgetbytespersample(dec->samplefmt) <= 2 && avgetbytespersample(enc->samplefmt) <= 2) { avoptsetint(ost->avr, \"internalsamplefmt\", AVSAMPLEFMTS16P, 0); } ret = avresampleopen(ost->avr); if (ret < 0) { avlog(NULL, AVLOGFATAL, \"Error opening libavresample\\n\"); exitprogram(1); } } } if (audiosyncmethod > 0) { double delta = getsyncipts(ost, ist->lastdts) * enc->samplerate - ost->syncopts - avfifosize(ost->fifo) / (enc->channels * osize); int idelta = delta * dec->samplerate / enc->samplerate; int bytedelta = idelta * isize * dec->channels; // FIXME resample delay if (fabs(delta) > 50) { if (ist->isstart || fabs(delta) > audiodriftthreshold*enc->samplerate) { if (bytedelta < 0) { bytedelta = FFMAX(bytedelta, -size); size += bytedelta; buf -= bytedelta; avlog(NULL, AVLOGVERBOSE, \"discarding %d audio samples\\n\", -bytedelta / (isize * dec->channels)); if (!size) return; ist->isstart = 0; } else { avfastmalloc(&asyncbuf, &allocatedasyncbufsize, bytedelta + size); if (!asyncbuf) { avlog(NULL, AVLOGFATAL, \"Out of memory in doaudioout\\n\"); exitprogram(1); } if (allocaudiooutputbuf(dec, enc, decodedframe->nbsamples + idelta, &outlinesize) < 0) { avlog(NULL, AVLOGFATAL, \"Error allocating audio buffer\\n\"); exitprogram(1); } ist->isstart = 0; generatesilence(asyncbuf, dec->samplefmt, bytedelta); memcpy(asyncbuf + bytedelta, buf, size); buf = asyncbuf; size += bytedelta; buflinesize = allocatedasyncbufsize; avlog(NULL, AVLOGVERBOSE, \"adding %d audio samples of silence\\n\", idelta); } } else if (audiosyncmethod > 1) { int comp = avclip(delta, -audiosyncmethod, audiosyncmethod); avlog(NULL, AVLOGVERBOSE, \"compensating audio timestamp drift:%f compensation:%d in:%d\\n\", delta, comp, enc->samplerate); // fprintf(stderr, \"drift:%f len:%d opts:%\"PRId64\" ipts:%\"PRId64\" fifo:%d\\n\", delta, -1, ost->syncopts, (int64t)(getsyncipts(ost) * enc->samplerate), avfifosize(ost->fifo)/(ost->st->codec->channels * 2)); avresamplesetcompensation(ost->avr, comp, enc->samplerate); } } } else if (audiosyncmethod == 0) ost->syncopts = lrintf(getsyncipts(ost, ist->lastdts) * enc->samplerate) - avfifosize(ost->fifo) / (enc->channels * osize); // FIXME wrong if (ost->audioresample) { buftmp = audiobuf; sizeout = avresampleconvert(ost->avr, (void **)&buftmp, allocatedaudiobufsize, outlinesize, (void **)&buf, buflinesize, size / (dec->channels * isize)); sizeout = sizeout * enc->channels * osize; } else { buftmp = buf; sizeout = size; } /* now encode as many frames as possible */ if (!(enc->codec->capabilities & CODECCAPVARIABLEFRAMESIZE)) { /* output resampled raw samples */ if (avfiforealloc2(ost->fifo, avfifosize(ost->fifo) + sizeout) < 0) { avlog(NULL, AVLOGFATAL, \"avfiforealloc2() failed\\n\"); exitprogram(1); } avfifogenericwrite(ost->fifo, buftmp, sizeout, NULL); framebytes = enc->framesize * osize * enc->channels; while (avfifosize(ost->fifo) >= framebytes) { avfifogenericread(ost->fifo, audiobuf, framebytes, NULL); encodeaudioframe(s, ost, audiobuf, framebytes); } } else { encodeaudioframe(s, ost, buftmp, sizeout); } } ", "target": 1}
{"func": "static inline void genarmshiftim(TCGv var, int shiftop, int shift, int flags) { switch (shiftop) { case 0: /* LSL */ if (shift != 0) { if (flags) shifteroutim(var, 32 - shift); tcggenshlii32(var, var, shift); } break; case 1: /* LSR */ if (shift == 0) { if (flags) { tcggenshrii32(var, var, 31); gensetCF(var); } tcggenmovii32(var, 0); } else { if (flags) shifteroutim(var, shift - 1); tcggenshrii32(var, var, shift); } break; case 2: /* ASR */ if (shift == 0) shift = 32; if (flags) shifteroutim(var, shift - 1); if (shift == 32) shift = 31; tcggensarii32(var, var, shift); break; case 3: /* ROR/RRX */ if (shift != 0) { if (flags) shifteroutim(var, shift - 1); tcggenrotrii32(var, var, shift); break; } else { TCGv tmp = loadcpufield(CF); if (flags) shifteroutim(var, 0); tcggenshrii32(var, var, 1); tcggenshlii32(tmp, tmp, 31); tcggenori32(var, var, tmp); deadtmp(tmp); } } }; ", "target": 1}
{"func": "static void vmxnet3updatevlanfilters(VMXNET3State *s) { int i; /* Copy configuration from shared memory */ VMXNET3READDRVSHARED(s->drvshmem, devRead.rxFilterConf.vfTable, s->vlantable, sizeof(s->vlantable)); /* Invert byte order when needed */ for (i = 0; i < ARRAYSIZE(s->vlantable); i++) { s->vlantable[i] = le32tocpu(s->vlantable[i]); } /* Dump configuration for debugging purposes */ VMWCFPRN(\"Configured VLANs:\"); for (i = 0; i < sizeof(s->vlantable) * 8; i++) { if (VMXNET3VFTABLEENTRYISSET(s->vlantable, i)) { VMWCFPRN(\"\\tVLAN %d is present\", i); } } } ", "target": 1}
{"func": "static void armtimerrecalibrate(armtimerstate *s, int reload) { uint32t limit; if ((s->control & TIMERCTRLPERIODIC) == 0) { /* Free running. */ if (s->control & TIMERCTRL32BIT) limit = 0xffffffff; else limit = 0xffff; } else { /* Periodic. */ limit = s->limit; } ptimersetlimit(s->timer, limit, reload); } ", "target": 0}
{"func": "static void termdownchar(void) { if (termhistentry == TERMMAXCMDS - 1 || termhistentry == -1) \treturn; if (termhistory[++termhistentry] != NULL) { \tpstrcpy(termcmdbuf, sizeof(termcmdbuf), termhistory[termhistentry]); } else { \ttermhistentry = -1; } termcmdbufindex = termcmdbufsize = strlen(termcmdbuf); } ", "target": 0}
{"func": "int kvmlogstart(targetphysaddrt physaddr, ramaddrt size) { return kvmdirtypageslogchange(physaddr, size, KVMMEMLOGDIRTYPAGES, KVMMEMLOGDIRTYPAGES); } ", "target": 0}
{"func": "static void dolog(int argc, const char **argv) { int mask; if (argc != 2) goto help; if (!strcmp(argv[1], \"none\")) { mask = 0; } else { mask = cpustrtologmask(argv[1]); if (!mask) { help: helpcmd(argv[0]); return; } } cpusetlog(mask); } ", "target": 0}
{"func": "static int hlsdecodeentry(AVCodecContext *avctxt, void *isFilterThread) { HEVCContext *s = avctxt->privdata; int ctbsize = 1 << s->sps->log2ctbsize; int moredata = 1; int xctb = 0; int yctb = 0; int ctbaddrts = s->pps->ctbaddrrstots[s->sh.slicectbaddrrs]; if (!ctbaddrts && s->sh.dependentslicesegmentflag) { avlog(s->avctx, AVLOGERROR, \"Impossible initial tile.\\n\"); return AVERRORINVALIDDATA; } if (s->sh.dependentslicesegmentflag) { int prevrs = s->pps->ctbaddrtstors[ctbaddrts - 1]; if (s->tabsliceaddress[prevrs] == -1) { avlog(s->avctx, AVLOGERROR, \"Previous slice segment missing\\n\"); return AVERRORINVALIDDATA; } } while (moredata && ctbaddrts < s->sps->ctbsize) { int ctbaddrrs = s->pps->ctbaddrtstors[ctbaddrts]; xctb = (ctbaddrrs % ((s->sps->width + ctbsize - 1) >> s->sps->log2ctbsize)) << s->sps->log2ctbsize; yctb = (ctbaddrrs / ((s->sps->width + ctbsize - 1) >> s->sps->log2ctbsize)) << s->sps->log2ctbsize; hlsdecodeneighbour(s, xctb, yctb, ctbaddrts); ffhevccabacinit(s, ctbaddrts); hlssaoparam(s, xctb >> s->sps->log2ctbsize, yctb >> s->sps->log2ctbsize); s->deblock[ctbaddrrs].betaoffset = s->sh.betaoffset; s->deblock[ctbaddrrs].tcoffset = s->sh.tcoffset; s->filtersliceedges[ctbaddrrs] = s->sh.sliceloopfilteracrossslicesenabledflag; moredata = hlscodingquadtree(s, xctb, yctb, s->sps->log2ctbsize, 0); if (moredata < 0) { s->tabsliceaddress[ctbaddrrs] = -1; return moredata; } ctbaddrts++; ffhevcsavestates(s, ctbaddrts); ffhevchlsfilters(s, xctb, yctb, ctbsize); } if (xctb + ctbsize >= s->sps->width && yctb + ctbsize >= s->sps->height) ffhevchlsfilter(s, xctb, yctb); return ctbaddrts; } ", "target": 0}
{"func": "static int decodeheader(MPADecodeContext *s, UINT32 header) { int samplerate, framesize, mpeg25, padding; int samplerateindex, bitrateindex; if (header & (1<<20)) { s->lsf = (header & (1<<19)) ? 0 : 1; mpeg25 = 0; } else { s->lsf = 1; mpeg25 = 1; } s->layer = 4 - ((header >> 17) & 3); /* extract frequency */ samplerateindex = (header >> 10) & 3; samplerate = mpafreqtab[samplerateindex] >> (s->lsf + mpeg25); if (samplerate == 0) return 1; samplerateindex += 3 * (s->lsf + mpeg25); s->samplerateindex = samplerateindex; s->errorprotection = ((header >> 16) & 1) ^ 1; bitrateindex = (header >> 12) & 0xf; padding = (header >> 9) & 1; //extension = (header >> 8) & 1; s->mode = (header >> 6) & 3; s->modeext = (header >> 4) & 3; //copyright = (header >> 3) & 1; //original = (header >> 2) & 1; //emphasis = header & 3; if (s->mode == MPAMONO) s->nbchannels = 1; else s->nbchannels = 2; if (bitrateindex != 0) { framesize = mpabitratetab[s->lsf][s->layer - 1][bitrateindex]; s->bitrate = framesize * 1000; switch(s->layer) { case 1: framesize = (framesize * 12000) / samplerate; framesize = (framesize + padding) * 4; break; case 2: framesize = (framesize * 144000) / samplerate; framesize += padding; break; default: case 3: framesize = (framesize * 144000) / (samplerate << s->lsf); framesize += padding; break; } s->framesize = framesize; } else { /* if no frame size computed, signal it */ if (!s->freeformatframesize) return 1; /* free format: compute bitrate and real frame size from the frame size we extracted by reading the bitstream */ s->framesize = s->freeformatframesize; switch(s->layer) { case 1: s->framesize += padding * 4; s->bitrate = (s->framesize * samplerate) / 48000; break; case 2: s->framesize += padding; s->bitrate = (s->framesize * samplerate) / 144000; break; default: case 3: s->framesize += padding; s->bitrate = (s->framesize * (samplerate << s->lsf)) / 144000; break; } } s->samplerate = samplerate; #if defined(DEBUG) printf(\"layer%d, %d Hz, %d kbits/s, \", s->layer, s->samplerate, s->bitrate); if (s->nbchannels == 2) { if (s->layer == 3) { if (s->modeext & MODEEXTMSSTEREO) printf(\"ms-\"); if (s->modeext & MODEEXTISTEREO) printf(\"i-\"); } printf(\"stereo\"); } else { printf(\"mono\"); } printf(\"\\n\"); #endif return 0; } ", "target": 1}
{"func": "static avcold int init(AVFilterContext *ctx, const char *args) { GradFunContext *gf = ctx->priv; float thresh = 1.2; int radius = 16; if (args) sscanf(args, \"%f:%d\", &thresh, &radius); thresh = avclipf(thresh, 0.51, 255); gf->thresh = (1 << 15) / thresh; gf->radius = avclip((radius + 1) & ~1, 4, 32); gf->blurline = ffgradfunblurlinec; gf->filterline = ffgradfunfilterlinec; if (ARCHX86) ffgradfuninitx86(gf); avlog(ctx, AVLOGVERBOSE, \"threshold:%.2f radius:%d\\n\", thresh, gf->radius); return 0; } ", "target": 1}
{"func": "static int kvmclientmigrationlog(struct CPUPhysMemoryClient *client, \t\t\t\t int enable) { \treturn kvmsetmigrationlog(enable); } ", "target": 0}
{"func": "static int64t rtmpreadseek(URLContext *s, int streamindex, int64t timestamp, int flags) { RTMP *r = s->privdata; if (flags & AVSEEKFLAGBYTE) return AVERROR(ENOSYS); /* seeks are in milliseconds */ timestamp = avrescale(timestamp, AVTIMEBASE, 1000); if (!RTMPSendSeek(r, timestamp)) return -1; return timestamp; } ", "target": 0}
{"func": "static avcold int macedecodeinit(AVCodecContext * avctx) { MACEContext *ctx = avctx->privdata; if (avctx->channels > 2) return -1; avctx->samplefmt = AVSAMPLEFMTS16; avcodecgetframedefaults(&ctx->frame); avctx->codedframe = &ctx->frame; return 0; } ", "target": 0}
{"func": "float16 float32tofloat16(float32 a, flag ieee STATUSPARAM) { flag aSign; intfast16t aExp; uint32t aSig; uint32t mask; uint32t increment; int8 roundingMode; a = float32squashinputdenormal(a STATUSVAR); aSig = extractFloat32Frac( a ); aExp = extractFloat32Exp( a ); aSign = extractFloat32Sign( a ); if ( aExp == 0xFF ) { if (aSig) { /* Input is a NaN */ float16 r = commonNaNToFloat16( float32ToCommonNaN( a STATUSVAR ) STATUSVAR ); if (!ieee) { return packFloat16(aSign, 0, 0); } return r; } /* Infinity */ if (!ieee) { floatraise(floatflaginvalid STATUSVAR); return packFloat16(aSign, 0x1f, 0x3ff); } return packFloat16(aSign, 0x1f, 0); } if (aExp == 0 && aSig == 0) { return packFloat16(aSign, 0, 0); } /* Decimal point between bits 22 and 23. */ aSig |= 0x00800000; aExp -= 0x7f; if (aExp < -14) { mask = 0x00ffffff; if (aExp >= -24) { mask >>= 25 + aExp; } } else { mask = 0x00001fff; } if (aSig & mask) { floatraise( floatflagunderflow STATUSVAR ); roundingMode = STATUS(floatroundingmode); switch (roundingMode) { case floatroundnearesteven: increment = (mask + 1) >> 1; if ((aSig & mask) == increment) { increment = aSig & (increment << 1); } break; case floatroundup: increment = aSign ? 0 : mask; break; case floatrounddown: increment = aSign ? mask : 0; break; default: /* roundtozero */ increment = 0; break; } aSig += increment; if (aSig >= 0x01000000) { aSig >>= 1; aExp++; } } else if (aExp < -14 && STATUS(floatdetecttininess) == floattininessbeforerounding) { floatraise( floatflagunderflow STATUSVAR); } if (ieee) { if (aExp > 15) { floatraise( floatflagoverflow | floatflaginexact STATUSVAR); return packFloat16(aSign, 0x1f, 0); } } else { if (aExp > 16) { floatraise(floatflaginvalid | floatflaginexact STATUSVAR); return packFloat16(aSign, 0x1f, 0x3ff); } } if (aExp < -24) { return packFloat16(aSign, 0, 0); } if (aExp < -14) { aSig >>= -14 - aExp; aExp = -14; } return packFloat16(aSign, aExp + 14, aSig >> 13); } ", "target": 1}
{"func": "int virtqueueavailbytes(VirtQueue *vq, int inbytes, int outbytes) { unsigned int idx; unsigned int totalbufs, intotal, outtotal; idx = vq->lastavailidx; totalbufs = intotal = outtotal = 0; while (virtqueuenumheads(vq, idx)) { unsigned int max, numbufs, indirect = 0; targetphysaddrt descpa; int i; max = vq->vring.num; numbufs = totalbufs; i = virtqueuegethead(vq, idx++); descpa = vq->vring.desc; if (vringdescflags(descpa, i) & VRINGDESCFINDIRECT) { if (vringdesclen(descpa, i) % sizeof(VRingDesc)) { errorreport(\"Invalid size for indirect buffer table\"); exit(1); } /* If we've got too many, that implies a descriptor loop. */ if (numbufs >= max) { errorreport(\"Looped descriptor\"); exit(1); } /* loop over the indirect descriptor table */ indirect = 1; max = vringdesclen(descpa, i) / sizeof(VRingDesc); numbufs = i = 0; descpa = vringdescaddr(descpa, i); } do { /* If we've got too many, that implies a descriptor loop. */ if (++numbufs > max) { errorreport(\"Looped descriptor\"); exit(1); } if (vringdescflags(descpa, i) & VRINGDESCFWRITE) { if (inbytes > 0 && (intotal += vringdesclen(descpa, i)) >= inbytes) return 1; } else { if (outbytes > 0 && (outtotal += vringdesclen(descpa, i)) >= outbytes) return 1; } } while ((i = virtqueuenextdesc(descpa, i, max)) != max); if (!indirect) totalbufs = numbufs; else totalbufs++; } return 0; } ", "target": 0}
{"func": "static CharDriverState *qemuchropenfd(int fdin, int fdout) { CharDriverState *chr; FDCharDriver *s; chr = gmalloc0(sizeof(CharDriverState)); s = gmalloc0(sizeof(FDCharDriver)); s->fdin = iochannelfromfd(fdin); s->fdout = iochannelfromfd(fdout); fcntl(fdout, FSETFL, ONONBLOCK); s->chr = chr; chr->opaque = s; chr->chraddwatch = fdchraddwatch; chr->chrwrite = fdchrwrite; chr->chrupdatereadhandler = fdchrupdatereadhandler; chr->chrclose = fdchrclose; qemuchrbegenericopen(chr); return chr; } ", "target": 0}
{"func": "static int g722encodeframe(AVCodecContext *avctx, AVPacket *avpkt, const AVFrame *frame, int *gotpacketptr) { G722Context *c = avctx->privdata; const int16t *samples = (const int16t *)frame->data[0]; int nbsamples, outsize, ret; outsize = (frame->nbsamples + 1) / 2; if ((ret = ffallocpacket2(avctx, avpkt, outsize))) return ret; nbsamples = frame->nbsamples - (frame->nbsamples & 1); if (avctx->trellis) g722encodetrellis(c, avctx->trellis, avpkt->data, nbsamples, samples); else g722encodenotrellis(c, avpkt->data, nbsamples, samples); /* handle last frame with odd framesize */ if (nbsamples < frame->nbsamples) { int16t lastsamples[2] = { samples[nbsamples], samples[nbsamples] }; encodebyte(c, &avpkt->data[nbsamples >> 1], lastsamples); } if (frame->pts != AVNOPTSVALUE) avpkt->pts = frame->pts - ffsamplestotimebase(avctx, avctx->delay); *gotpacketptr = 1; return 0; } ", "target": 0}
{"func": "static int gifimagewriteimage(AVCodecContext *avctx, uint8t **bytestream, uint8t *end, const uint32t *palette, const uint8t *buf, const int linesize, AVPacket *pkt) { GIFContext *s = avctx->privdata; int len = 0, height = avctx->height, width = avctx->width, x, y; int xstart = 0, ystart = 0, trans = s->transparentindex; int honortransparency = (s->flags & GFTRANSDIFF) && s->lastframe; const uint8t *ptr; /* Crop image */ if ((s->flags & GFOFFSETTING) && s->lastframe && !palette) { const uint8t *ref = s->lastframe->data[0]; const int reflinesize = s->lastframe->linesize[0]; int xend = avctx->width - 1, yend = avctx->height - 1; /* skip common lines */ while (ystart < yend) { if (memcmp(ref + ystart*reflinesize, buf + ystart*linesize, width)) break; ystart++; } while (yend > ystart) { if (memcmp(ref + yend*reflinesize, buf + yend*linesize, width)) break; yend--; } height = yend + 1 - ystart; /* skip common columns */ while (xstart < xend) { int samecolumn = 1; for (y = ystart; y <= yend; y++) { if (ref[y*reflinesize + xstart] != buf[y*linesize + xstart]) { samecolumn = 0; break; } } if (!samecolumn) break; xstart++; } while (xend > xstart) { int samecolumn = 1; for (y = ystart; y <= yend; y++) { if (ref[y*reflinesize + xend] != buf[y*linesize + xend]) { samecolumn = 0; break; } } if (!samecolumn) break; xend--; } width = xend + 1 - xstart; avlog(avctx, AVLOGDEBUG,\"%dx%d image at pos (%d;%d) [area:%dx%d]\\n\", width, height, xstart, ystart, avctx->width, avctx->height); } /* image block */ bytestreamputbyte(bytestream, GIFIMAGESEPARATOR); bytestreamputle16(bytestream, xstart); bytestreamputle16(bytestream, ystart); bytestreamputle16(bytestream, width); bytestreamputle16(bytestream, height); if (!palette) { bytestreamputbyte(bytestream, 0x00); /* flags */ } else { unsigned i; bytestreamputbyte(bytestream, 1<<7 | 0x7); /* flags */ for (i = 0; i < AVPALETTECOUNT; i++) { const uint32t v = palette[i]; bytestreamputbe24(bytestream, v); } } if (honortransparency && trans < 0) { trans = pickpaletteentry(buf + ystart*linesize + xstart, linesize, width, height); if (trans < 0) { // TODO, patch welcome avlog(avctx, AVLOGDEBUG, \"No available color, can not use transparency\\n\"); } else { uint8t *palexdata = s->palexdata; if (!palexdata) palexdata = avpacketnewsidedata(pkt, AVPKTDATAPALETTE, AVPALETTESIZE); if (!palexdata) return AVERROR(ENOMEM); memcpy(palexdata, s->palette, AVPALETTESIZE); palexdata[trans*4 + 3*!HAVEBIGENDIAN] = 0x00; } } if (trans < 0) honortransparency = 0; bytestreamputbyte(bytestream, 0x08); fflzwencodeinit(s->lzw, s->buf, 2 * width * height, 12, FFLZWGIF, putbits); ptr = buf + ystart*linesize + xstart; if (honortransparency) { const int reflinesize = s->lastframe->linesize[0]; const uint8t *ref = s->lastframe->data[0] + ystart*reflinesize + xstart; for (y = 0; y < height; y++) { memcpy(s->tmpl, ptr, width); for (x = 0; x < width; x++) if (ref[x] == ptr[x]) s->tmpl[x] = trans; len += fflzwencode(s->lzw, s->tmpl, width); ptr += linesize; ref += reflinesize; } } else { for (y = 0; y < height; y++) { len += fflzwencode(s->lzw, ptr, width); ptr += linesize; } } len += fflzwencodeflush(s->lzw, flushputbits); ptr = s->buf; while (len > 0) { int size = FFMIN(255, len); bytestreamputbyte(bytestream, size); if (end - *bytestream < size) return -1; bytestreamputbuffer(bytestream, ptr, size); ptr += size; len -= size; } bytestreamputbyte(bytestream, 0x00); /* end of image block */ return 0; } ", "target": 0}
{"func": "static int openfile(char *name, int flags) { \tif (bs) { \t\tfprintf(stderr, \"file open already, try 'help close'\\n\"); \t\treturn 1; \t} \tbs = bdrvnew(\"hda\"); \tif (!bs) \t\treturn 1; \tif (bdrvopen(bs, name, flags) == -1) { \t\tfprintf(stderr, \"%s: can't open device %s\\n\", progname, name); \t\tbs = NULL; \t\treturn 1; \t} \treturn 0; } ", "target": 0}
{"func": "static void e500pcihostbridgerealize(PCIDevice *d, Error **errp) { PPCE500PCIBridgeState *b = PPCE500PCIBRIDGE(d); PPCE500CCSRState *ccsr = CCSR(containerget(qdevgetmachine(), \"/e500-ccsr\")); pciconfigsetclass(d->config, PCICLASSBRIDGEPCI); d->config[PCIHEADERTYPE] = (d->config[PCIHEADERTYPE] & PCIHEADERTYPEMULTIFUNCTION) | PCIHEADERTYPEBRIDGE; memoryregioninitalias(&b->bar0, OBJECT(ccsr), \"e500-pci-bar0\", &ccsr->ccsrspace, 0, int128get64(ccsr->ccsrspace.size)); pciregisterbar(d, 0, PCIBASEADDRESSSPACEMEMORY, &b->bar0); } ", "target": 0}
{"func": "void ffclearfixedvector(float *out, const AMRFixed *in, int size) { int i; for (i=0; i < in->n; i++) { int x = in->x[i], repeats = !((in->norepeatmask >> i) & 1); do { out[x] = 0.0; x += in->pitchlag; } while (x < size && repeats); } }", "target": 1}
{"func": "static int filmreadheader(AVFormatContext *s, AVFormatParameters *ap) { FilmDemuxContext *film = s->privdata; AVIOContext *pb = s->pb; AVStream *st; unsigned char scratch[256]; int i; unsigned int dataoffset; unsigned int audioframecounter; film->sampletable = NULL; film->stereobuffer = NULL; film->stereobuffersize = 0; /* load the main FILM header */ if (avioread(pb, scratch, 16) != 16) return AVERROR(EIO); dataoffset = AVRB32(&scratch[4]); film->version = AVRB32(&scratch[8]); /* load the FDSC chunk */ if (film->version == 0) { /* special case for Lemmings .film files; 20-byte header */ if (avioread(pb, scratch, 20) != 20) return AVERROR(EIO); /* make some assumptions about the audio parameters */ film->audiotype = CODECIDPCMS8; film->audiosamplerate = 22050; film->audiochannels = 1; film->audiobits = 8; } else { /* normal Saturn .cpk files; 32-byte header */ if (avioread(pb, scratch, 32) != 32) return AVERROR(EIO); film->audiosamplerate = AVRB16(&scratch[24]); film->audiochannels = scratch[21]; film->audiobits = scratch[22]; if (scratch[23] == 2) film->audiotype = CODECIDADPCMADX; else if (film->audiobits == 8) film->audiotype = CODECIDPCMS8; else if (film->audiobits == 16) film->audiotype = CODECIDPCMS16BE; else film->audiotype = CODECIDNONE; } if (AVRB32(&scratch[0]) != FDSCTAG) return AVERRORINVALIDDATA; if (AVRB32(&scratch[8]) == CVIDTAG) { film->videotype = CODECIDCINEPAK; } else film->videotype = CODECIDNONE; /* initialize the decoder streams */ if (film->videotype) { st = avnewstream(s, 0); if (!st) return AVERROR(ENOMEM); film->videostreamindex = st->index; st->codec->codectype = AVMEDIATYPEVIDEO; st->codec->codecid = film->videotype; st->codec->codectag = 0; /* no fourcc */ st->codec->width = AVRB32(&scratch[16]); st->codec->height = AVRB32(&scratch[12]); } if (film->audiotype) { st = avnewstream(s, 0); if (!st) return AVERROR(ENOMEM); film->audiostreamindex = st->index; st->codec->codectype = AVMEDIATYPEAUDIO; st->codec->codecid = film->audiotype; st->codec->codectag = 1; st->codec->channels = film->audiochannels; st->codec->samplerate = film->audiosamplerate; if (film->audiotype == CODECIDADPCMADX) { st->codec->bitspercodedsample = 18 * 8 / 32; st->codec->blockalign = st->codec->channels * 18; } else { st->codec->bitspercodedsample = film->audiobits; st->codec->blockalign = st->codec->channels * st->codec->bitspercodedsample / 8; } st->codec->bitrate = st->codec->channels * st->codec->samplerate * st->codec->bitspercodedsample; } /* load the sample table */ if (avioread(pb, scratch, 16) != 16) return AVERROR(EIO); if (AVRB32(&scratch[0]) != STABTAG) return AVERRORINVALIDDATA; film->baseclock = AVRB32(&scratch[8]); film->samplecount = AVRB32(&scratch[12]); if(film->samplecount >= UINTMAX / sizeof(filmsample)) return -1; film->sampletable = avmalloc(film->samplecount * sizeof(filmsample)); if (!film->sampletable) return AVERROR(ENOMEM); for(i=0; i<s->nbstreams; i++) avsetptsinfo(s->streams[i], 33, 1, film->baseclock); audioframecounter = 0; for (i = 0; i < film->samplecount; i++) { /* load the next sample record and transfer it to an internal struct */ if (avioread(pb, scratch, 16) != 16) { avfree(film->sampletable); return AVERROR(EIO); } film->sampletable[i].sampleoffset = dataoffset + AVRB32(&scratch[0]); film->sampletable[i].samplesize = AVRB32(&scratch[4]); if (AVRB32(&scratch[8]) == 0xFFFFFFFF) { film->sampletable[i].stream = film->audiostreamindex; film->sampletable[i].pts = audioframecounter; film->sampletable[i].pts *= film->baseclock; film->sampletable[i].pts /= film->audiosamplerate; if (film->audiotype == CODECIDADPCMADX) audioframecounter += (film->sampletable[i].samplesize * 32 / (18 * film->audiochannels)); else audioframecounter += (film->sampletable[i].samplesize / (film->audiochannels * film->audiobits / 8)); } else { film->sampletable[i].stream = film->videostreamindex; film->sampletable[i].pts = AVRB32(&scratch[8]) & 0x7FFFFFFF; film->sampletable[i].keyframe = (scratch[8] & 0x80) ? 0 : 1; } } film->currentsample = 0; return 0; } ", "target": 1}
{"func": "static int vlcdecodeblock(MimicContext *ctx, int numcoeffs, int qscale) { int16t *block = ctx->dctblock; unsigned int pos; ctx->bdsp.clearblock(block); block[0] = getbits(&ctx->gb, 8) << 3; for (pos = 1; pos < numcoeffs; pos++) { uint32t vlc, numbits; int value; int coeff; vlc = getvlc2(&ctx->gb, ctx->vlc.table, ctx->vlc.bits, 3); if (!vlc) /* end-of-block code */ return 0; if (vlc == -1) return AVERRORINVALIDDATA; /* posadd and numbits are coded in the vlc code */ pos += vlc & 15; // posadd numbits = vlc >> 4; // numbits if (pos >= 64) return AVERRORINVALIDDATA; value = getbits(&ctx->gb, numbits); /* FFmpeg's IDCT behaves somewhat different from the original code, so * a factor of 4 was added to the input */ coeff = vlcdeclookup[numbits][value]; if (pos < 3) coeff *= 16; else /* TODO Use >> 10 instead of / 1001 */ coeff = (coeff * qscale) / 1001; block[ctx->scantable.permutated[pos]] = coeff; } return 0; } ", "target": 1}
{"func": "static int svq3decodeframe(AVCodecContext *avctx, void *data, int *datasize, AVPacket *avpkt) { const uint8t *buf = avpkt->data; int bufsize = avpkt->size; MpegEncContext *const s = avctx->privdata; H264Context *const h = avctx->privdata; int m, mbtype; /* special case for last picture */ if (bufsize == 0) { if (s->nextpictureptr && !s->lowdelay) { *(AVFrame *) data = *(AVFrame *) &s->nextpicture; s->nextpictureptr = NULL; *datasize = sizeof(AVFrame); } return 0; } initgetbits (&s->gb, buf, 8*bufsize); s->mbx = s->mby = h->mbxy = 0; if (svq3decodesliceheader(h)) return -1; s->picttype = h->slicetype; s->picturenumber = h->slicenum; if (avctx->debug&FFDEBUGPICTINFO){ avlog(h->s.avctx, AVLOGDEBUG, \"%c hpel:%d, tpel:%d aqp:%d qp:%d, slicenum:%02X\\n\", avgetpicttypechar(s->picttype), h->halfpelflag, h->thirdpelflag, s->adaptivequant, s->qscale, h->slicenum); } /* for hurryup == 5 */ s->currentpicture.picttype = s->picttype; s->currentpicture.keyframe = (s->picttype == FFITYPE); /* Skip B-frames if we do not have reference frames. */ if (s->lastpictureptr == NULL && s->picttype == FFBTYPE) return 0; /* Skip B-frames if we are in a hurry. */ if (avctx->hurryup && s->picttype == FFBTYPE) return 0; /* Skip everything if we are in a hurry >= 5. */ if (avctx->hurryup >= 5) return 0; if ( (avctx->skipframe >= AVDISCARDNONREF && s->picttype == FFBTYPE) ||(avctx->skipframe >= AVDISCARDNONKEY && s->picttype != FFITYPE) || avctx->skipframe >= AVDISCARDALL) return 0; if (s->nextpframedamaged) { if (s->picttype == FFBTYPE) return 0; else s->nextpframedamaged = 0; } if (framestart(h) < 0) return -1; if (s->picttype == FFBTYPE) { h->framenumoffset = (h->slicenum - h->prevframenum); if (h->framenumoffset < 0) { h->framenumoffset += 256; } if (h->framenumoffset == 0 || h->framenumoffset >= h->prevframenumoffset) { avlog(h->s.avctx, AVLOGERROR, \"error in B-frame picture id\\n\"); return -1; } } else { h->prevframenum = h->framenum; h->framenum = h->slicenum; h->prevframenumoffset = (h->framenum - h->prevframenum); if (h->prevframenumoffset < 0) { h->prevframenumoffset += 256; } } for (m = 0; m < 2; m++){ int i; for (i = 0; i < 4; i++){ int j; for (j = -1; j < 4; j++) h->refcache[m][scan8[0] + 8*i + j]= 1; if (i < 3) h->refcache[m][scan8[0] + 8*i + j]= PARTNOTAVAILABLE; } } for (s->mby = 0; s->mby < s->mbheight; s->mby++) { for (s->mbx = 0; s->mbx < s->mbwidth; s->mbx++) { h->mbxy = s->mbx + s->mby*s->mbstride; if ( (getbitscount(&s->gb) + 7) >= s->gb.sizeinbits && ((getbitscount(&s->gb) & 7) == 0 || showbits(&s->gb, (-getbitscount(&s->gb) & 7)) == 0)) { skipbits(&s->gb, h->nextsliceindex - getbitscount(&s->gb)); s->gb.sizeinbits = 8*bufsize; if (svq3decodesliceheader(h)) return -1; /* TODO: support s->mbskiprun */ } mbtype = svq3getuegolomb(&s->gb); if (s->picttype == FFITYPE) { mbtype += 8; } else if (s->picttype == FFBTYPE && mbtype >= 4) { mbtype += 4; } if (mbtype > 33 || svq3decodemb(h, mbtype)) { avlog(h->s.avctx, AVLOGERROR, \"error while decoding MB %d %d\\n\", s->mbx, s->mby); return -1; } if (mbtype != 0) { hldecodemb (h); } if (s->picttype != FFBTYPE && !s->lowdelay) { s->currentpicture.mbtype[s->mbx + s->mby*s->mbstride] = (s->picttype == FFPTYPE && mbtype < 8) ? (mbtype - 1) : -1; } } ffdrawhorizband(s, 16*s->mby, 16); } MPVframeend(s); if (s->picttype == FFBTYPE || s->lowdelay) { *(AVFrame *) data = *(AVFrame *) &s->currentpicture; } else { *(AVFrame *) data = *(AVFrame *) &s->lastpicture; } avctx->framenumber = s->picturenumber - 1; /* Do not output the last pic after seeking. */ if (s->lastpictureptr || s->lowdelay) { *datasize = sizeof(AVFrame); } return bufsize; } ", "target": 0}
{"func": "static avcold int rl2decodeinit(AVCodecContext *avctx) { Rl2Context *s = avctx->privdata; int backsize; int i; s->avctx = avctx; avctx->pixfmt = AVPIXFMTPAL8; avcodecgetframedefaults(&s->frame); /** parse extra data */ if(!avctx->extradata || avctx->extradatasize < EXTRADATA1SIZE){ avlog(avctx, AVLOGERROR, \"invalid extradata size\\n\"); return -1; } /** get frameoffset */ s->videobase = AVRL16(&avctx->extradata[0]); s->clrcount = AVRL32(&avctx->extradata[2]); if(s->videobase >= avctx->width * avctx->height){ avlog(avctx, AVLOGERROR, \"invalid videobase\\n\"); return -1; } /** initialize palette */ for(i=0;i<AVPALETTECOUNT;i++) s->palette[i] = 0xFF << 24 | AVRB24(&avctx->extradata[6 + i * 3]); /** decode background frame if present */ backsize = avctx->extradatasize - EXTRADATA1SIZE; if(backsize > 0){ unsigned char* backframe = avmallocz(avctx->width*avctx->height); if(!backframe) return -1; rl2rledecode(s,avctx->extradata + EXTRADATA1SIZE,backsize, backframe,avctx->width,0); s->backframe = backframe; } return 0; } ", "target": 1}
{"func": "static void picmemset(PicContext *s, AVFrame *frame, int value, int run, int *x, int *y, int *plane, int bitsperplane) { uint8t *d; int shift = *plane * bitsperplane; int mask = ((1 << bitsperplane) - 1) << shift; value <<= shift; while (run > 0) { int j; for (j = 8-bitsperplane; j >= 0; j -= bitsperplane) { d = frame->data[0] + *y * frame->linesize[0]; d[*x] |= (value >> j) & mask; *x += 1; if (*x == s->width) { *y -= 1; *x = 0; if (*y < 0) { *y = s->height - 1; *plane += 1; if (*plane >= s->nbplanes) return; value <<= bitsperplane; mask <<= bitsperplane; } } } run--; } } ", "target": 1}
{"func": "static inline void silkstabilizelsf(int16t nlsf[16], int order, const uint16t mindelta[17]) { int pass, i; for (pass = 0; pass < 20; pass++) { int k, mindiff = 0; for (i = 0; i < order+1; i++) { int low = i != 0 ? nlsf[i-1] : 0; int high = i != order ? nlsf[i] : 32768; int diff = (high - low) - (mindelta[i]); if (diff < mindiff) { mindiff = diff; k = i; if (pass == 20) break; } } if (mindiff == 0) /* no issues; stabilized */ return; /* wiggle one or two LSFs */ if (k == 0) { /* repel away from lower bound */ nlsf[0] = mindelta[0]; } else if (k == order) { /* repel away from higher bound */ nlsf[order-1] = 32768 - mindelta[order]; } else { /* repel away from current position */ int mincenter = 0, maxcenter = 32768, centerval; /* lower extent */ for (i = 0; i < k; i++) mincenter += mindelta[i]; mincenter += mindelta[k] >> 1; /* upper extent */ for (i = order; i > k; i--) maxcenter -= mindelta[k]; maxcenter -= mindelta[k] >> 1; /* move apart */ centerval = nlsf[k - 1] + nlsf[k]; centerval = (centerval >> 1) + (centerval & 1); // rounded divide by 2 centerval = FFMIN(maxcenter, FFMAX(mincenter, centerval)); nlsf[k - 1] = centerval - (mindelta[k] >> 1); nlsf[k] = nlsf[k - 1] + mindelta[k]; } } /* resort to the fall-back method, the standard method for LSF stabilization */ /* sort; as the LSFs should be nearly sorted, use insertion sort */ for (i = 1; i < order; i++) { int j, value = nlsf[i]; for (j = i - 1; j >= 0 && nlsf[j] > value; j--) nlsf[j + 1] = nlsf[j]; nlsf[j + 1] = value; } /* push forwards to increase distance */ if (nlsf[0] < mindelta[0]) nlsf[0] = mindelta[0]; for (i = 1; i < order; i++) if (nlsf[i] < nlsf[i - 1] + mindelta[i]) nlsf[i] = nlsf[i - 1] + mindelta[i]; /* push backwards to increase distance */ if (nlsf[order-1] > 32768 - mindelta[order]) nlsf[order-1] = 32768 - mindelta[order]; for (i = order-2; i >= 0; i--) if (nlsf[i] > nlsf[i + 1] - mindelta[i+1]) nlsf[i] = nlsf[i + 1] - mindelta[i+1]; return; } ", "target": 0}
{"func": "static void pciuninmainconfigwritel (void *opaque, targetphysaddrt addr, uint32t val) { UNINState *s = opaque; UNINDPRINTF(\"configwritel addr \" TARGETFMTplx \" val %x\\n\", addr, val); #ifdef TARGETWORDSBIGENDIAN val = bswap32(val); #endif s->configreg = val; } ", "target": 1}
{"func": "vubrsetvringaddrexec(VubrDev *dev, VhostUserMsg *vmsg) { struct vhostvringaddr *vra = &vmsg->payload.addr; unsigned int index = vra->index; VubrVirtq *vq = &dev->vq[index]; DPRINT(\"vhostvringaddr:\\n\"); DPRINT(\" index: %d\\n\", vra->index); DPRINT(\" flags: %d\\n\", vra->flags); DPRINT(\" descuseraddr: 0x%016llx\\n\", vra->descuseraddr); DPRINT(\" useduseraddr: 0x%016llx\\n\", vra->useduseraddr); DPRINT(\" availuseraddr: 0x%016llx\\n\", vra->availuseraddr); DPRINT(\" logguestaddr: 0x%016llx\\n\", vra->logguestaddr); vq->desc = (struct vringdesc *)(uintptrt)qvatova(dev, vra->descuseraddr); vq->used = (struct vringused *)(uintptrt)qvatova(dev, vra->useduseraddr); vq->avail = (struct vringavail *)(uintptrt)qvatova(dev, vra->availuseraddr); vq->logguestaddr = vra->logguestaddr; DPRINT(\"Setting virtq addresses:\\n\"); DPRINT(\" vringdesc at %p\\n\", vq->desc); DPRINT(\" vringused at %p\\n\", vq->used); DPRINT(\" vringavail at %p\\n\", vq->avail); vq->lastusedindex = vq->used->idx; return 0;", "target": 1}
{"func": "void ffgetunscaledswscale(SwsContext *c) { const enum PixelFormat srcFormat = c->srcFormat; const enum PixelFormat dstFormat = c->dstFormat; const int flags = c->flags; const int dstH = c->dstH; int needsDither; needsDither = isAnyRGB(dstFormat) && c->dstFormatBpp < 24 && (c->dstFormatBpp < c->srcFormatBpp || (!isAnyRGB(srcFormat))); /* yv12tonv12 */ if ((srcFormat == PIXFMTYUV420P || srcFormat == PIXFMTYUVA420P) && (dstFormat == PIXFMTNV12 || dstFormat == PIXFMTNV21)) { c->swScale = planarToNv12Wrapper; } /* yuv2bgr */ if ((srcFormat == PIXFMTYUV420P || srcFormat == PIXFMTYUV422P || srcFormat == PIXFMTYUVA420P) && isAnyRGB(dstFormat) && !(flags & SWSACCURATERND) && !(dstH & 1)) { c->swScale = ffyuv2rgbgetfuncptr(c); } if (srcFormat == PIXFMTYUV410P && (dstFormat == PIXFMTYUV420P || dstFormat == PIXFMTYUVA420P) && !(flags & SWSBITEXACT)) { c->swScale = yvu9ToYv12Wrapper; } /* bgr24toYV12 */ if (srcFormat == PIXFMTBGR24 && (dstFormat == PIXFMTYUV420P || dstFormat == PIXFMTYUVA420P) && !(flags & SWSACCURATERND)) c->swScale = bgr24ToYv12Wrapper; /* RGB/BGR -> RGB/BGR (no dither needed forms) */ if ( isAnyRGB(srcFormat) && isAnyRGB(dstFormat) && srcFormat != PIXFMTBGR8 && dstFormat != PIXFMTBGR8 && srcFormat != PIXFMTRGB8 && dstFormat != PIXFMTRGB8 && srcFormat != PIXFMTBGR4 && dstFormat != PIXFMTBGR4 && srcFormat != PIXFMTRGB4 && dstFormat != PIXFMTRGB4 && srcFormat != PIXFMTBGR4BYTE && dstFormat != PIXFMTBGR4BYTE && srcFormat != PIXFMTRGB4BYTE && dstFormat != PIXFMTRGB4BYTE && srcFormat != PIXFMTMONOBLACK && dstFormat != PIXFMTMONOBLACK && srcFormat != PIXFMTMONOWHITE && dstFormat != PIXFMTMONOWHITE && srcFormat != PIXFMTRGB48LE && dstFormat != PIXFMTRGB48LE && srcFormat != PIXFMTRGB48BE && dstFormat != PIXFMTRGB48BE && srcFormat != PIXFMTBGR48LE && dstFormat != PIXFMTBGR48LE && srcFormat != PIXFMTBGR48BE && dstFormat != PIXFMTBGR48BE && (!needsDither || (c->flags&(SWSFASTBILINEAR|SWSPOINT)))) c->swScale= rgbToRgbWrapper; /* bswap 16 bits per pixel/component packed formats */ if (ISDIFFERENTENDIANESS(srcFormat, dstFormat, PIXFMTBGR444) || ISDIFFERENTENDIANESS(srcFormat, dstFormat, PIXFMTBGR48) || ISDIFFERENTENDIANESS(srcFormat, dstFormat, PIXFMTBGR555) || ISDIFFERENTENDIANESS(srcFormat, dstFormat, PIXFMTBGR565) || ISDIFFERENTENDIANESS(srcFormat, dstFormat, PIXFMTGRAY16) || ISDIFFERENTENDIANESS(srcFormat, dstFormat, PIXFMTRGB444) || ISDIFFERENTENDIANESS(srcFormat, dstFormat, PIXFMTRGB48) || ISDIFFERENTENDIANESS(srcFormat, dstFormat, PIXFMTRGB555) || ISDIFFERENTENDIANESS(srcFormat, dstFormat, PIXFMTRGB565)) c->swScale = packed16bpcbswap; if ((usePal(srcFormat) && ( dstFormat == PIXFMTRGB32 || dstFormat == PIXFMTRGB321 || dstFormat == PIXFMTRGB24 || dstFormat == PIXFMTBGR32 || dstFormat == PIXFMTBGR321 || dstFormat == PIXFMTBGR24))) c->swScale = palToRgbWrapper; if (srcFormat == PIXFMTYUV422P) { if (dstFormat == PIXFMTYUYV422) c->swScale = yuv422pToYuy2Wrapper; else if (dstFormat == PIXFMTUYVY422) c->swScale = yuv422pToUyvyWrapper; } /* LQ converters if -sws 0 or -sws 4*/ if (c->flags&(SWSFASTBILINEAR|SWSPOINT)) { /* yv12toyuy2 */ if (srcFormat == PIXFMTYUV420P || srcFormat == PIXFMTYUVA420P) { if (dstFormat == PIXFMTYUYV422) c->swScale = planarToYuy2Wrapper; else if (dstFormat == PIXFMTUYVY422) c->swScale = planarToUyvyWrapper; } } if (srcFormat == PIXFMTYUYV422 && (dstFormat == PIXFMTYUV420P || dstFormat == PIXFMTYUVA420P)) c->swScale = yuyvToYuv420Wrapper; if (srcFormat == PIXFMTUYVY422 && (dstFormat == PIXFMTYUV420P || dstFormat == PIXFMTYUVA420P)) c->swScale = uyvyToYuv420Wrapper; if (srcFormat == PIXFMTYUYV422 && dstFormat == PIXFMTYUV422P) c->swScale = yuyvToYuv422Wrapper; if (srcFormat == PIXFMTUYVY422 && dstFormat == PIXFMTYUV422P) c->swScale = uyvyToYuv422Wrapper; /* simple copy */ if ( srcFormat == dstFormat || (srcFormat == PIXFMTYUVA420P && dstFormat == PIXFMTYUV420P) || (srcFormat == PIXFMTYUV420P && dstFormat == PIXFMTYUVA420P) || (isPlanarYUV(srcFormat) && isGray(dstFormat)) || (isPlanarYUV(dstFormat) && isGray(srcFormat)) || (isGray(dstFormat) && isGray(srcFormat)) || (isPlanarYUV(srcFormat) && isPlanarYUV(dstFormat) && c->chrDstHSubSample == c->chrSrcHSubSample && c->chrDstVSubSample == c->chrSrcVSubSample && dstFormat != PIXFMTNV12 && dstFormat != PIXFMTNV21 && srcFormat != PIXFMTNV12 && srcFormat != PIXFMTNV21)) { if (isPacked(c->srcFormat)) c->swScale = packedCopyWrapper; else /* Planar YUV or gray */ c->swScale = planarCopyWrapper; } if (ARCHBFIN) ffbfingetunscaledswscale(c); if (HAVEALTIVEC) ffswscalegetunscaledaltivec(c); } ", "target": 1}
{"func": "static PCIBridgeWindows *pcibridgeregioninit(PCIBridge *br) { PCIDevice *pd = PCIDEVICE(br); PCIBus *parent = pd->bus; PCIBridgeWindows *w = gnew(PCIBridgeWindows, 1); uint16t cmd = pcigetword(pd->config + PCICOMMAND); pcibridgeinitalias(br, &w->aliasprefmem, PCIBASEADDRESSMEMPREFETCH, \"pcibridgeprefmem\", &br->addressspacemem, parent->addressspacemem, cmd & PCICOMMANDMEMORY); pcibridgeinitalias(br, &w->aliasmem, PCIBASEADDRESSSPACEMEMORY, \"pcibridgemem\", &br->addressspacemem, parent->addressspacemem, cmd & PCICOMMANDMEMORY); pcibridgeinitalias(br, &w->aliasio, PCIBASEADDRESSSPACEIO, \"pcibridgeio\", &br->addressspaceio, parent->addressspaceio, cmd & PCICOMMANDIO); pcibridgeinitvgaaliases(br, parent, w->aliasvga); return w; } ", "target": 0}
{"func": "static void hlstransformtree(HEVCContext *s, int x0, int y0, int xBase, int yBase, int cbxBase, int cbyBase, int log2cbsize, int log2trafosize, int trafodepth, int blkidx) { HEVCLocalContext *lc = &s->HEVClc; uint8t splittransformflag; if (trafodepth > 0 && log2trafosize == 2) { SAMPLECBF(lc->tt.cbfcb[trafodepth], x0, y0) = SAMPLECBF(lc->tt.cbfcb[trafodepth - 1], xBase, yBase); SAMPLECBF(lc->tt.cbfcr[trafodepth], x0, y0) = SAMPLECBF(lc->tt.cbfcr[trafodepth - 1], xBase, yBase); } else { SAMPLECBF(lc->tt.cbfcb[trafodepth], x0, y0) = SAMPLECBF(lc->tt.cbfcr[trafodepth], x0, y0) = 0; } if (lc->cu.intrasplitflag) { if (trafodepth == 1) lc->tu.curintrapredmode = lc->pu.intrapredmode[blkidx]; } else { lc->tu.curintrapredmode = lc->pu.intrapredmode[0]; } lc->tt.cbfluma = 1; lc->tt.intersplitflag = s->sps->maxtransformhierarchydepthinter == 0 && lc->cu.predmode == MODEINTER && lc->cu.partmode != PART2Nx2N && trafodepth == 0; if (log2trafosize <= s->sps->log2maxtrafosize && log2trafosize > s->sps->log2mintbsize && trafodepth < lc->cu.maxtrafodepth && !(lc->cu.intrasplitflag && trafodepth == 0)) { splittransformflag = ffhevcsplittransformflagdecode(s, log2trafosize); } else { splittransformflag = log2trafosize > s->sps->log2maxtrafosize || (lc->cu.intrasplitflag && trafodepth == 0) || lc->tt.intersplitflag; } if (log2trafosize > 2) { if (trafodepth == 0 || SAMPLECBF(lc->tt.cbfcb[trafodepth - 1], xBase, yBase)) { SAMPLECBF(lc->tt.cbfcb[trafodepth], x0, y0) = ffhevccbfcbcrdecode(s, trafodepth); } if (trafodepth == 0 || SAMPLECBF(lc->tt.cbfcr[trafodepth - 1], xBase, yBase)) { SAMPLECBF(lc->tt.cbfcr[trafodepth], x0, y0) = ffhevccbfcbcrdecode(s, trafodepth); } } if (splittransformflag) { int x1 = x0 + ((1 << log2trafosize) >> 1); int y1 = y0 + ((1 << log2trafosize) >> 1); hlstransformtree(s, x0, y0, x0, y0, cbxBase, cbyBase, log2cbsize, log2trafosize - 1, trafodepth + 1, 0); hlstransformtree(s, x1, y0, x0, y0, cbxBase, cbyBase, log2cbsize, log2trafosize - 1, trafodepth + 1, 1); hlstransformtree(s, x0, y1, x0, y0, cbxBase, cbyBase, log2cbsize, log2trafosize - 1, trafodepth + 1, 2); hlstransformtree(s, x1, y1, x0, y0, cbxBase, cbyBase, log2cbsize, log2trafosize - 1, trafodepth + 1, 3); } else { int mintusize = 1 << s->sps->log2mintbsize; int log2mintusize = s->sps->log2mintbsize; int mintuwidth = s->sps->mintbwidth; if (lc->cu.predmode == MODEINTRA || trafodepth != 0 || SAMPLECBF(lc->tt.cbfcb[trafodepth], x0, y0) || SAMPLECBF(lc->tt.cbfcr[trafodepth], x0, y0)) { lc->tt.cbfluma = ffhevccbflumadecode(s, trafodepth); } hlstransformunit(s, x0, y0, xBase, yBase, cbxBase, cbyBase, log2cbsize, log2trafosize, trafodepth, blkidx); // TODO: store cbfluma somewhere else if (lc->tt.cbfluma) { int i, j; for (i = 0; i < (1 << log2trafosize); i += mintusize) for (j = 0; j < (1 << log2trafosize); j += mintusize) { int xtu = (x0 + j) >> log2mintusize; int ytu = (y0 + i) >> log2mintusize; s->cbfluma[ytu * mintuwidth + xtu] = 1; } } if (!s->sh.disabledeblockingfilterflag) { ffhevcdeblockingboundarystrengths(s, x0, y0, log2trafosize, lc->sliceortilesupboundary, lc->sliceortilesleftboundary); if (s->pps->transquantbypassenableflag && lc->cu.cutransquantbypassflag) setdeblockingbypass(s, x0, y0, log2trafosize); } } } ", "target": 0}
{"func": "static void awpulseset2(WMAVoiceContext *s, GetBitContext *gb, int blockidx, AMRFixed *fcb) { uint16t usemaskmem[9]; // only 5 are used, rest is padding uint16t *usemask = usemaskmem + 2; /* in this function, idx is the index in the 80-bit (+ padding) usemask * bit-array. Since usemask consists of 16-bit values, the lower 4 bits * of idx are the position of the bit within a particular item in the * array (0 being the most significant bit, and 15 being the least * significant bit), and the remainder (>> 4) is the index in the * usemask[]-array. This is faster and uses less memory than using a * 80-byte/80-int array. */ int pulseoff = s->awfirstpulseoff[blockidx], pulsestart, n, idx, range, aidx, startoff = 0; /* set offset of first pulse to within this block */ if (s->awnpulses[blockidx] > 0) while (pulseoff + s->awpulserange < 1) pulseoff += fcb->pitchlag; /* find range per pulse */ if (s->awnpulses[0] > 0) { if (blockidx == 0) { range = 32; } else /* blockidx = 1 */ { range = 8; if (s->awnpulses[blockidx] > 0) pulseoff = s->awnextpulseoffcache; } } else range = 16; pulsestart = s->awnpulses[blockidx] > 0 ? pulseoff - range / 2 : 0; /* awpulseset1() already applies pulses around pulseoff (to be exactly, * in the range of [pulseoff, pulseoff + s->awpulserange], and thus * we exclude that range from being pulsed again in this function. */ memset(&usemask[-2], 0, 2 * sizeof(usemask[0])); memset( usemask, -1, 5 * sizeof(usemask[0])); memset(&usemask[5], 0, 2 * sizeof(usemask[0])); if (s->awnpulses[blockidx] > 0) for (idx = pulseoff; idx < MAXFRAMESIZE / 2; idx += fcb->pitchlag) { int exclrange = s->awpulserange; // always 16 or 24 uint16t *usemaskptr = &usemask[idx >> 4]; int firstsh = 16 - (idx & 15); *usemaskptr++ &= 0xFFFF << firstsh; exclrange -= firstsh; if (exclrange >= 16) { *usemaskptr++ = 0; *usemaskptr &= 0xFFFF >> (exclrange - 16); } else *usemaskptr &= 0xFFFF >> exclrange; } /* find the 'aidx'th offset that is not excluded */ aidx = getbits(gb, s->awnpulses[0] > 0 ? 5 - 2 * blockidx : 4); for (n = 0; n <= aidx; pulsestart++) { for (idx = pulsestart; idx < 0; idx += fcb->pitchlag) ; if (idx >= MAXFRAMESIZE / 2) { // find from zero if (usemask[0]) idx = 0x0F; else if (usemask[1]) idx = 0x1F; else if (usemask[2]) idx = 0x2F; else if (usemask[3]) idx = 0x3F; else if (usemask[4]) idx = 0x4F; else return; idx -= avlog216bit(usemask[idx >> 4]); } if (usemask[idx >> 4] & (0x8000 >> (idx & 15))) { usemask[idx >> 4] &= ~(0x8000 >> (idx & 15)); n++; startoff = idx; } } fcb->x[fcb->n] = startoff; fcb->y[fcb->n] = getbits1(gb) ? -1.0 : 1.0; fcb->n++; /* set offset for next block, relative to start of that block */ n = (MAXFRAMESIZE / 2 - startoff) % fcb->pitchlag; s->awnextpulseoffcache = n ? fcb->pitchlag - n : 0; } ", "target": 1}
{"func": "static void asfbuildsimpleindex(AVFormatContext *s, int streamindex) { ffasfguid g; ASFContext *asf = s->privdata; int64t currentpos = aviotell(s->pb); int i; avioseek(s->pb, asf->dataobjectoffset + asf->dataobjectsize, SEEKSET); ffgetguid(s->pb, &g); /* the data object can be followed by other top-level objects, * skip them until the simple index object is reached */ while (ffguidcmp(&g, &indexguid)) { int64t gsize = aviorl64(s->pb); if (gsize < 24 || s->pb->eofreached) { avioseek(s->pb, currentpos, SEEKSET); return; } avioskip(s->pb, gsize - 24); ffgetguid(s->pb, &g); } { int64t itime, lastpos = -1; int pct, ict; int64t avunused gsize = aviorl64(s->pb); ffgetguid(s->pb, &g); itime = aviorl64(s->pb); pct = aviorl32(s->pb); ict = aviorl32(s->pb); avlog(s, AVLOGDEBUG, \"itime:0x%\"PRIx64\", pct:%d, ict:%d\\n\", itime, pct, ict); for (i = 0; i < ict; i++) { int pktnum = aviorl32(s->pb); int pktct = aviorl16(s->pb); int64t pos = s->dataoffset + s->packetsize * (int64t)pktnum; int64t indexpts = FFMAX(avrescale(itime, i, 10000) - asf->hdr.preroll, 0); if (pos != lastpos) { avlog(s, AVLOGDEBUG, \"pktnum:%d, pktct:%d pts: %\"PRId64\"\\n\", pktnum, pktct, indexpts); avaddindexentry(s->streams[streamindex], pos, indexpts, s->packetsize, 0, AVINDEXKEYFRAME); lastpos = pos; } } asf->indexread = ict > 0; } avioseek(s->pb, currentpos, SEEKSET); } ", "target": 1}
{"func": "static void bdrvqeddrain(BlockDriverState *bs) { BDRVQEDState *s = bs->opaque; /* Cancel timer and start doing I/O that were meant to happen as if it * fired, that way we get bdrvdrain() taking care of the ongoing requests * correctly. */ qedcancelneedchecktimer(s); qedplugallocatingwritereqs(s); bdrvaioflush(s->bs, qedclearneedcheck, s); } ", "target": 1}
{"func": "static void testqemustrtolinvalid(void) { const char *str = \" xxxx \\t abc\"; char f = 'X'; const char *endptr = &f; long res = 999; int err; err = qemustrtol(str, &endptr, 0, &res); gassertcmpint(err, ==, 0); gassertcmpint(res, ==, 0); gassert(endptr == str); } ", "target": 1}
{"func": "static int checkbind(const char *hostname, bool *hasproto) { int fd = -1; struct addrinfo ai, *res = NULL; int rc; int ret = -1; memset(&ai, 0, sizeof(ai)); ai.aiflags = AICANONNAME | AIV4MAPPED | AIADDRCONFIG; ai.aifamily = AFUNSPEC; ai.aisocktype = SOCKSTREAM; /* lookup */ rc = getaddrinfo(hostname, NULL, &ai, &res); if (rc != 0) { if (rc == EAIADDRFAMILY || rc == EAIFAMILY) { *hasproto = false; goto done; } goto cleanup; } fd = qemusocket(res->aifamily, res->aisocktype, res->aiprotocol); if (fd < 0) { goto cleanup; } if (bind(fd, res->aiaddr, res->aiaddrlen) < 0) { if (errno == EADDRNOTAVAIL) { *hasproto = false; goto done; } goto cleanup; } *hasproto = true; done: ret = 0; cleanup: if (fd != -1) { close(fd); } if (res) { freeaddrinfo(res); } return ret; } ", "target": 1}
{"func": "static bool runpollhandlers(AioContext *ctx, int64t maxns) { bool progress = false; int64t endtime; assert(ctx->notifyme); assert(ctx->walkinghandlers > 0); assert(ctx->polldisablecnt == 0); tracerunpollhandlersbegin(ctx, maxns); endtime = qemuclockgetns(QEMUCLOCKREALTIME) + maxns; do { AioHandler *node; QLISTFOREACH(node, &ctx->aiohandlers, node) { if (!node->deleted && node->iopoll && node->iopoll(node->opaque)) { progress = true; } /* Caller handles freeing deleted nodes. Don't do it here. */ } } while (!progress && qemuclockgetns(QEMUCLOCKREALTIME) < endtime); tracerunpollhandlersend(ctx, progress); return progress; } ", "target": 1}
{"func": "static int screenpressodecodeframe(AVCodecContext *avctx, void *data, int *gotframe, AVPacket *avpkt) { ScreenpressoContext *ctx = avctx->privdata; AVFrame *frame = data; int keyframe; int ret; /* Size check */ if (avpkt->size < 3) { avlog(avctx, AVLOGERROR, \"Packet too small (%d)\\n\", avpkt->size); return AVERRORINVALIDDATA; } /* Basic sanity check, but not really harmful */ if ((avpkt->data[0] != 0x73 && avpkt->data[0] != 0x72) || avpkt->data[1] != 8) { // bpp probably avlog(avctx, AVLOGWARNING, \"Unknown header 0x%02X%02X\\n\", avpkt->data[0], avpkt->data[1]); } keyframe = (avpkt->data[0] == 0x73); /* Resize deflate buffer and frame on resolution change */ if (ctx->inflatedsize != avctx->width * avctx->height * 3) { avframeunref(ctx->current); ret = ffgetbuffer(avctx, ctx->current, AVGETBUFFERFLAGREF); if (ret < 0) return ret; /* If malloc fails, reset len to avoid preserving an invalid value */ ctx->inflatedsize = avctx->width * avctx->height * 3; ret = avreallocp(&ctx->inflatedbuf, ctx->inflatedsize); if (ret < 0) { ctx->inflatedsize = 0; return ret; } } /* Inflate the frame after the 2 byte header */ ret = uncompress(ctx->inflatedbuf, &ctx->inflatedsize, avpkt->data + 2, avpkt->size - 2); if (ret) { avlog(avctx, AVLOGERROR, \"Deflate error %d.\\n\", ret); return AVERRORUNKNOWN; } /* When a keyframe is found, copy it (flipped) */ if (keyframe) avimagecopyplane(ctx->current->data[0] + ctx->current->linesize[0] * (avctx->height - 1), -1 * ctx->current->linesize[0], ctx->inflatedbuf, avctx->width * 3, avctx->width * 3, avctx->height); /* Otherwise sum the delta on top of the current frame */ else sumdeltaflipped(ctx->current->data[0], ctx->current->linesize[0], ctx->inflatedbuf, avctx->width * 3, avctx->width * 3, avctx->height); /* Frame is ready to be output */ ret = avframeref(frame, ctx->current); if (ret < 0) return ret; /* Usual properties */ if (keyframe) { frame->picttype = AVPICTURETYPEI; frame->keyframe = 1; } else { frame->picttype = AVPICTURETYPEP; } *gotframe = 1; return 0; } ", "target": 0}
{"func": "static inline TCGv iwmmxtloadcreg(int reg) { TCGv var = newtmp(); tcggenldi32(var, cpuenv, offsetof(CPUState, iwmmxt.cregs[reg])); return var; } ", "target": 1}
{"func": "void HELPER(setcpreg64)(CPUARMState *env, void *rip, uint64t value) { const ARMCPRegInfo *ri = rip; ri->writefn(env, ri, value); } ", "target": 1}
{"func": "static void vhostscsistop(VHostSCSI *s) { VirtIODevice *vdev = VIRTIODEVICE(s); BusState *qbus = BUS(qdevgetparentbus(DEVICE(vdev))); VirtioBusClass *k = VIRTIOBUSGETCLASS(qbus); int ret = 0; if (!k->setguestnotifiers) { ret = k->setguestnotifiers(qbus->parent, s->dev.nvqs, false); if (ret < 0) { errorreport(\"vhost guest notifier cleanup failed: %d\\n\", ret); } } assert(ret >= 0); vhostscsiclearendpoint(s); vhostdevstop(&s->dev, vdev); vhostdevdisablenotifiers(&s->dev, vdev); } ", "target": 1}
{"func": "static void starttco(const TestData *d) { uint32t val; val = qpciioreadw(d->dev, d->tcoiobase + TCO1CNT); val &= ~TCOTMRHLT; qpciiowritew(d->dev, d->tcoiobase + TCO1CNT, val); } ", "target": 1}
{"func": "void memoryglobaldirtylogstop(void) { globaldirtylog = false; /* Refresh DIRTYLOGMIGRATION bit. */ memoryregiontransactionbegin(); memoryregionupdatepending = true; memoryregiontransactioncommit(); MEMORYLISTENERCALLGLOBAL(logglobalstop, Reverse); } ", "target": 0}
{"func": "static inline int openbyhandle(int mountfd, const char *fh, int flags) { errno = ENOSYS; return -1; } ", "target": 0}
{"func": "static void cmdgeteventstatusnotification(IDEState *s, uint8t *buf) { const uint8t *packet = buf; struct { uint8t opcode; uint8t polled; /* lsb bit is polled; others are reserved */ uint8t reserved2[2]; uint8t class; uint8t reserved3[2]; uint16t len; uint8t control; } attribute((packed)) *gesncdb; struct { uint16t len; uint8t notificationclass; uint8t supportedevents; } attribute((packed)) *gesneventheader; enum notificationclassrequesttype { NCRRESERVED1 = 1 << 0, NCROPERATIONALCHANGE = 1 << 1, NCRPOWERMANAGEMENT = 1 << 2, NCREXTERNALREQUEST = 1 << 3, NCRMEDIA = 1 << 4, NCRMULTIHOST = 1 << 5, NCRDEVICEBUSY = 1 << 6, NCRRESERVED2 = 1 << 7, }; enum eventnotificationclassfield { ENCNOEVENTS = 0, ENCOPERATIONALCHANGE, ENCPOWERMANAGEMENT, ENCEXTERNALREQUEST, ENCMEDIA, ENCMULTIPLEHOSTS, ENCDEVICEBUSY, ENCRESERVED, }; unsigned int maxlen, usedlen; gesncdb = (void *)packet; gesneventheader = (void *)buf; maxlen = be16tocpu(gesncdb->len); /* It is fine by the MMC spec to not support async mode operations */ if (!(gesncdb->polled & 0x01)) { /* asynchronous mode */ /* Only polling is supported, asynchronous mode is not. */ ideatapicmderror(s, SENSEILLEGALREQUEST, ASCINVFIELDINCMDPACKET); return; } /* polling mode operation */ /* * These are the supported events. * * We currently only support requests of the 'media' type. */ gesneventheader->supportedevents = NCRMEDIA; /* * We use |= below to set the class field; other bits in this byte * are reserved now but this is useful to do if we have to use the * reserved fields later. */ gesneventheader->notificationclass = 0; /* * Responses to requests are to be based on request priority. The * notificationclassrequesttype enum above specifies the * priority: upper elements are higher prio than lower ones. */ if (gesncdb->class & NCRMEDIA) { gesneventheader->notificationclass |= ENCMEDIA; usedlen = eventstatusmedia(s, buf); } else { gesneventheader->notificationclass = 0x80; /* No event available */ usedlen = sizeof(*gesneventheader); } gesneventheader->len = cputobe16(usedlen - sizeof(*gesneventheader)); ideatapicmdreply(s, usedlen, maxlen); } ", "target": 0}
{"func": "static int decodeplane(UtvideoContext *c, int planeno, uint8t *dst, int step, ptrdifft stride, int width, int height, const uint8t *src, int usepred) { int i, j, slice, pix; int sstart, send; VLC vlc; GetBitContext gb; int prev, fsym; const int cmask = c->interlaced ? ~(1 + 2 * (!planeno && c->avctx->pixfmt == AVPIXFMTYUV420P)) : ~(!planeno && c->avctx->pixfmt == AVPIXFMTYUV420P); if (buildhuff(src, &vlc, &fsym)) { avlog(c->avctx, AVLOGERROR, \"Cannot build Huffman codes\\n\"); return AVERRORINVALIDDATA; } if (fsym >= 0) { // buildhuff reported a symbol to fill slices with send = 0; for (slice = 0; slice < c->slices; slice++) { uint8t *dest; sstart = send; send = (height * (slice + 1) / c->slices) & cmask; dest = dst + sstart * stride; prev = 0x80; for (j = sstart; j < send; j++) { for (i = 0; i < width * step; i += step) { pix = fsym; if (usepred) { prev += pix; pix = prev; } dest[i] = pix; } dest += stride; } } return 0; } src += 256; send = 0; for (slice = 0; slice < c->slices; slice++) { uint8t *dest; int slicedatastart, slicedataend, slicesize; sstart = send; send = (height * (slice + 1) / c->slices) & cmask; dest = dst + sstart * stride; // slice offset and size validation was done earlier slicedatastart = slice ? AVRL32(src + slice * 4 - 4) : 0; slicedataend = AVRL32(src + slice * 4); slicesize = slicedataend - slicedatastart; if (!slicesize) { avlog(c->avctx, AVLOGERROR, \"Plane has more than one symbol \" \"yet a slice has a length of zero.\\n\"); goto fail; } memset(c->slicebits + slicesize, 0, AVINPUTBUFFERPADDINGSIZE); c->bdsp.bswapbuf((uint32t *) c->slicebits, (uint32t *)(src + slicedatastart + c->slices * 4), (slicedataend - slicedatastart + 3) >> 2); initgetbits(&gb, c->slicebits, slicesize * 8); prev = 0x80; for (j = sstart; j < send; j++) { for (i = 0; i < width * step; i += step) { pix = getvlc2(&gb, vlc.table, VLCBITS, 3); if (pix < 0) { avlog(c->avctx, AVLOGERROR, \"Decoding error\\n\"); goto fail; } if (usepred) { prev += pix; pix = prev; } dest[i] = pix; } if (getbitsleft(&gb) < 0) { avlog(c->avctx, AVLOGERROR, \"Slice decoding ran out of bits\\n\"); goto fail; } dest += stride; } if (getbitsleft(&gb) > 32) avlog(c->avctx, AVLOGWARNING, \"%d bits left after decoding slice\\n\", getbitsleft(&gb)); } fffreevlc(&vlc); return 0; fail: fffreevlc(&vlc); return AVERRORINVALIDDATA; } ", "target": 0}
{"func": "static int oggbufferdata(AVFormatContext *s, AVStream *st, uint8t *data, unsigned size, int64t granule, int header) { OGGStreamContext *oggstream = st->privdata; OGGContext *ogg = s->privdata; int totalsegments = size / 255 + 1; uint8t *p = data; int i, segments, len, flush = 0; // Handles VFR by flushing page because this frame needs to have a timestamp // For theora, keyframes also need to have a timestamp to correctly mark // them as such, otherwise seeking will not work correctly at the very // least with old libogg versions. // Do not try to flush header packets though, that will create broken files. if (st->codec->codecid == AVCODECIDTHEORA && !header && (ogggranuletotimestamp(oggstream, granule) > ogggranuletotimestamp(oggstream, oggstream->lastgranule) + 1 || oggkeygranule(oggstream, granule))) { if (oggstream->page.granule != -1) oggbufferpage(s, oggstream); flush = 1; } // avoid a continued page if (!header && oggstream->page.size > 0 && MAXPAGESIZE - oggstream->page.size < size) { oggbufferpage(s, oggstream); } for (i = 0; i < totalsegments; ) { OGGPage *page = &oggstream->page; segments = FFMIN(totalsegments - i, 255 - page->segmentscount); if (i && !page->segmentscount) page->flags |= 1; // continued packet memset(page->segments+page->segmentscount, 255, segments - 1); page->segmentscount += segments - 1; len = FFMIN(size, segments*255); page->segments[page->segmentscount++] = len - (segments-1)*255; memcpy(page->data+page->size, p, len); p += len; size -= len; i += segments; page->size += len; if (i == totalsegments) page->granule = granule; if (!header) { AVStream *st = s->streams[page->streamindex]; int64t start = avrescaleq(page->startgranule, st->timebase, AVTIMEBASEQ); int64t next = avrescaleq(page->granule, st->timebase, AVTIMEBASEQ); if (page->segmentscount == 255 || (ogg->prefsize > 0 && page->size >= ogg->prefsize) || (ogg->prefduration > 0 && next - start >= ogg->prefduration)) { oggbufferpage(s, oggstream); } } } if (flush && oggstream->page.granule != -1) oggbufferpage(s, oggstream); return 0; } ", "target": 0}
{"func": "void mpeg4encodepictureheader(MpegEncContext * s, int picturenumber) { int timeincr; int timediv, timemod; if(s->picttype==AVPICTURETYPEI){ if(!(s->flags&CODECFLAGGLOBALHEADER)){ if(s->strictstdcompliance < FFCOMPLIANCEVERYSTRICT) //HACK, the reference sw is buggy mpeg4encodevisualobjectheader(s); if(s->strictstdcompliance < FFCOMPLIANCEVERYSTRICT || picturenumber==0) //HACK, the reference sw is buggy mpeg4encodevolheader(s, 0, 0); } if(!(s->workaroundbugs & FFBUGMS)) mpeg4encodegopheader(s); } s->partitionedframe= s->datapartitioning && s->picttype!=AVPICTURETYPEB; putbits(&s->pb, 16, 0); /* vop header */ putbits(&s->pb, 16, VOPSTARTCODE); /* vop header */ putbits(&s->pb, 2, s->picttype - 1); /* pict type: I = 0 , P = 1 */ assert(s->time>=0); timediv= s->time/s->avctx->timebase.den; timemod= s->time%s->avctx->timebase.den; timeincr= timediv - s->lasttimebase; assert(timeincr >= 0); while(timeincr--) putbits(&s->pb, 1, 1); putbits(&s->pb, 1, 0); putbits(&s->pb, 1, 1); /* marker */ putbits(&s->pb, s->timeincrementbits, timemod); /* time increment */ putbits(&s->pb, 1, 1); /* marker */ putbits(&s->pb, 1, 1); /* vop coded */ if ( s->picttype == AVPICTURETYPEP || (s->picttype == AVPICTURETYPES && s->volspriteusage==GMCSPRITE)) { putbits(&s->pb, 1, s->norounding); /* rounding type */ } putbits(&s->pb, 3, 0); /* intra dc VLC threshold */ if(!s->progressivesequence){ putbits(&s->pb, 1, s->currentpictureptr->topfieldfirst); putbits(&s->pb, 1, s->alternatescan); } //FIXME sprite stuff putbits(&s->pb, 5, s->qscale); if (s->picttype != AVPICTURETYPEI) putbits(&s->pb, 3, s->fcode); /* fcodefor */ if (s->picttype == AVPICTURETYPEB) putbits(&s->pb, 3, s->bcode); /* fcodeback */ } ", "target": 0}
{"func": "static void buildvlc(VLC *vlc, const uint8t *bitstable, const uint8t *valtable, int nbcodes) { uint8t huffsize[256]; uint16t huffcode[256]; memset(huffsize, 0, sizeof(huffsize)); buildhuffmancodes(huffsize, huffcode, bitstable, valtable); initvlc(vlc, 9, nbcodes, huffsize, 1, 1, huffcode, 2, 2); } ", "target": 0}
{"func": "void qemucoroutineadjustpoolsize(int n) { qemumutexlock(&poollock); poolmaxsize += n; /* Callers should never take away more than they added */ assert(poolmaxsize >= POOLDEFAULTSIZE); /* Trim oversized pool down to new max */ while (poolsize > poolmaxsize) { Coroutine *co = QSLISTFIRST(&pool); QSLISTREMOVEHEAD(&pool, poolnext); poolsize--; qemucoroutinedelete(co); } qemumutexunlock(&poollock); } ", "target": 0}
{"func": "static void rndisclearresponsequeue(USBNetState *s) { struct rndisresponse *r; while ((r = s->rndisresp.tqhfirst)) { TAILQREMOVE(&s->rndisresp, r, entries); qemufree(r); } } ", "target": 0}
{"func": "avcold void ffvp56dspinitx86(VP56DSPContext* c, enum AVCodecID codec) { #if HAVEYASM int mmflags = avgetcpuflags(); if (CONFIGVP6DECODER && codec == AVCODECIDVP6) { #if ARCHX8632 if (mmflags & AVCPUFLAGMMX) { c->vp6filterdiag4 = ffvp6filterdiag4mmx; } #endif if (mmflags & AVCPUFLAGSSE2) { c->vp6filterdiag4 = ffvp6filterdiag4sse2; } } #endif } ", "target": 0}
{"func": "int cpuppchandlemmufault (CPUState *env, uint32t address, int rw, int isuser, int issoftmmu) { uint32t physical; int prot; int exception = 0, errorcode = 0; int accesstype; int ret = 0; // printf(\"%s 0\\n\", func); accesstype = env->accesstype; if (env->usermodeonly) { /* user mode only emulation */ ret = -2; goto dofault; } /* NASTY BUG workaround */ if (accesstype == ACCESSCODE && rw) { \tprintf(\"%s: ERROR WRITE CODE ACCESS\\n\", func); \taccesstype = ACCESSINT; } ret = getphysicaladdress(env, &physical, &prot, address, rw, accesstype); if (ret == 0) { \tret = tlbsetpage(env, address & ~0xFFF, physical, prot, \t\t\t isuser, issoftmmu); } else if (ret < 0) { dofault: #if defined (DEBUGMMU) \tif (loglevel > 0) \t cpuppcdumpstate(env, logfile, 0); #endif if (accesstype == ACCESSCODE) { exception = EXCPISI; switch (ret) { case -1: /* No matches in page tables */ errorcode = EXCPISITRANSLATE; break; case -2: /* Access rights violation */ errorcode = EXCPISIPROT; break; case -3: \t\t/* No execute protection violation */ errorcode = EXCPISINOEXEC; break; case -4: /* Direct store exception */ /* No code fetch is allowed in direct-store areas */ errorcode = EXCPISIDIRECT; break; } } else { exception = EXCPDSI; switch (ret) { case -1: /* No matches in page tables */ errorcode = EXCPDSITRANSLATE; break; case -2: /* Access rights violation */ errorcode = EXCPDSIPROT; break; case -4: /* Direct store exception */ switch (accesstype) { case ACCESSFLOAT: /* Floating point load/store */ exception = EXCPALIGN; errorcode = EXCPALIGNFP; break; case ACCESSRES: /* lwarx, ldarx or srwcx. */ exception = EXCPDSI; errorcode = EXCPDSINOTSUP | EXCPDSIDIRECT; break; case ACCESSEXT: /* eciwx or ecowx */ exception = EXCPDSI; errorcode = EXCPDSINOTSUP | EXCPDSIDIRECT | \t\t\tEXCPDSIECXW; break; default: \t\t printf(\"DSI: invalid exception (%d)\\n\", ret); exception = EXCPPROGRAM; errorcode = EXCPINVAL | EXCPINVALINVAL; break; } } if (rw) errorcode |= EXCPDSISTORE; \t /* Store fault address */ \t env->spr[DAR] = address; } #if 0 printf(\"%s: set exception to %d %02x\\n\", func, exception, errorcode); #endif env->exceptionindex = exception; env->errorcode = errorcode; ret = 1; } return ret; } ", "target": 0}
{"func": "static void spatialdecompose53i(DWTELEM *buffer, int width, int height, int stride){ int y; DWTELEM *b0= buffer + mirror(-2-1, height-1)*stride; DWTELEM *b1= buffer + mirror(-2 , height-1)*stride; for(y=-2; y<height; y+=2){ DWTELEM *b2= buffer + mirror(y+1, height-1)*stride; DWTELEM *b3= buffer + mirror(y+2, height-1)*stride; {STARTTIMER if(b1 <= b3) horizontaldecompose53i(b2, width); if(y+2 < height) horizontaldecompose53i(b3, width); STOPTIMER(\"horizontaldecompose53i\")} {STARTTIMER if(b1 <= b3) verticaldecompose53iH0(b1, b2, b3, width); if(b0 <= b2) verticaldecompose53iL0(b0, b1, b2, width); STOPTIMER(\"verticaldecompose53i*\")} b0=b2; b1=b3; } } ", "target": 1}
{"func": "static int sdtruncate(BlockDriverState *bs, int64t offset) { BDRVSheepdogState *s = bs->opaque; int ret, fd; unsigned int datalen; if (offset < s->inode.vdisize) { errorreport(\"shrinking is not supported\"); return -EINVAL; } else if (offset > SDMAXVDISIZE) { errorreport(\"too big image size\"); return -EINVAL; } fd = connecttosdog(s->addr, s->port); if (fd < 0) { return fd; } /* we don't need to update entire object */ datalen = SDINODESIZE - sizeof(s->inode.datavdiid); s->inode.vdisize = offset; ret = writeobject(fd, (char *)&s->inode, vidtovdioid(s->inode.vdiid), s->inode.nrcopies, datalen, 0, false, s->cacheenabled); close(fd); if (ret < 0) { errorreport(\"failed to update an inode.\"); } return ret; } ", "target": 0}
{"func": "static int rndisparse(USBNetState *s, uint8t *data, int length) { uint32t msgtype; le32 *tmp = (le32 *) data; msgtype = le32tocpup(tmp); switch (msgtype) { case RNDISINITIALIZEMSG: s->rndisstate = RNDISINITIALIZED; return rndisinitresponse(s, (rndisinitmsgtype *) data); case RNDISHALTMSG: s->rndisstate = RNDISUNINITIALIZED; return 0; case RNDISQUERYMSG: return rndisqueryresponse(s, (rndisquerymsgtype *) data, length); case RNDISSETMSG: return rndissetresponse(s, (rndissetmsgtype *) data, length); case RNDISRESETMSG: rndisclearresponsequeue(s); s->outptr = s->inptr = s->inlen = 0; return rndisresetresponse(s, (rndisresetmsgtype *) data); case RNDISKEEPALIVEMSG: /* For USB: host does this every 5 seconds */ return rndiskeepaliveresponse(s, (rndiskeepalivemsgtype *) data); } return USBRETSTALL; } ", "target": 0}
{"func": "static int sapwriteheader(AVFormatContext *s) { struct SAPState *sap = s->privdata; char host[1024], path[1024], url[1024], announceaddr[50] = \"\"; char *optionlist; int port = 9875, baseport = 5004, i, pos = 0, sameport = 0, ttl = 255; AVFormatContext **contexts = NULL; int ret = 0; struct sockaddrstorage localaddr; socklent addrlen = sizeof(localaddr); int udpfd; AVDictionaryEntry* title = avdictget(s->metadata, \"title\", NULL, 0); if (!ffnetworkinit()) return AVERROR(EIO); /* extract hostname and port */ avurlsplit(NULL, 0, NULL, 0, host, sizeof(host), &baseport, path, sizeof(path), s->filename); if (baseport < 0) baseport = 5004; /* search for options */ optionlist = strrchr(path, '?'); if (optionlist) { char buf[50]; if (avfindinfotag(buf, sizeof(buf), \"announceport\", optionlist)) { port = strtol(buf, NULL, 10); } if (avfindinfotag(buf, sizeof(buf), \"sameport\", optionlist)) { sameport = strtol(buf, NULL, 10); } if (avfindinfotag(buf, sizeof(buf), \"ttl\", optionlist)) { ttl = strtol(buf, NULL, 10); } if (avfindinfotag(buf, sizeof(buf), \"announceaddr\", optionlist)) { avstrlcpy(announceaddr, buf, sizeof(announceaddr)); } } if (!announceaddr[0]) { struct addrinfo hints = { 0 }, *ai = NULL; hints.aifamily = AFUNSPEC; if (getaddrinfo(host, NULL, &hints, &ai)) { avlog(s, AVLOGERROR, \"Unable to resolve %s\\n\", host); ret = AVERROR(EIO); goto fail; } if (ai->aifamily == AFINET) { /* Also known as sap.mcast.net */ avstrlcpy(announceaddr, \"224.2.127.254\", sizeof(announceaddr)); #if HAVESTRUCTSOCKADDRIN6 } else if (ai->aifamily == AFINET6) { /* With IPv6, you can use the same destination in many different * multicast subnets, to choose how far you want it routed. * This one is intended to be routed globally. */ avstrlcpy(announceaddr, \"ff0e::2:7ffe\", sizeof(announceaddr)); #endif } else { freeaddrinfo(ai); avlog(s, AVLOGERROR, \"Host %s resolved to unsupported \" \"address family\\n\", host); ret = AVERROR(EIO); goto fail; } freeaddrinfo(ai); } sap->protocols = ffurlgetprotocols(NULL, NULL); if (!sap->protocols) { ret = AVERROR(ENOMEM); goto fail; } contexts = avmallocz(sizeof(AVFormatContext*) * s->nbstreams); if (!contexts) { ret = AVERROR(ENOMEM); goto fail; } s->starttimerealtime = avgettime(); for (i = 0; i < s->nbstreams; i++) { URLContext *fd; ffurljoin(url, sizeof(url), \"rtp\", NULL, host, baseport, \"?ttl=%d\", ttl); if (!sameport) baseport += 2; ret = ffurlopen(&fd, url, AVIOFLAGWRITE, &s->interruptcallback, NULL, sap->protocols); if (ret) { ret = AVERROR(EIO); goto fail; } ret = ffrtpchainmuxopen(&contexts[i], s, s->streams[i], fd, 0, i); if (ret < 0) goto fail; s->streams[i]->privdata = contexts[i]; s->streams[i]->timebase = contexts[i]->streams[0]->timebase; avstrlcpy(contexts[i]->filename, url, sizeof(contexts[i]->filename)); } if (s->nbstreams > 0 && title) avdictset(&contexts[0]->metadata, \"title\", title->value, 0); ffurljoin(url, sizeof(url), \"udp\", NULL, announceaddr, port, \"?ttl=%d&connect=1\", ttl); ret = ffurlopen(&sap->annfd, url, AVIOFLAGWRITE, &s->interruptcallback, NULL, sap->protocols); if (ret) { ret = AVERROR(EIO); goto fail; } udpfd = ffurlgetfilehandle(sap->annfd); if (getsockname(udpfd, (struct sockaddr*) &localaddr, &addrlen)) { ret = AVERROR(EIO); goto fail; } if (localaddr.ssfamily != AFINET #if HAVESTRUCTSOCKADDRIN6 && localaddr.ssfamily != AFINET6 #endif ) { avlog(s, AVLOGERROR, \"Unsupported protocol family\\n\"); ret = AVERROR(EIO); goto fail; } sap->annsize = 8192; sap->ann = avmallocz(sap->annsize); if (!sap->ann) { ret = AVERROR(EIO); goto fail; } sap->ann[pos] = (1 << 5); #if HAVESTRUCTSOCKADDRIN6 if (localaddr.ssfamily == AFINET6) sap->ann[pos] |= 0x10; #endif pos++; sap->ann[pos++] = 0; /* Authentication length */ AVWB16(&sap->ann[pos], avgetrandomseed()); pos += 2; if (localaddr.ssfamily == AFINET) { memcpy(&sap->ann[pos], &((struct sockaddrin*)&localaddr)->sinaddr, sizeof(struct inaddr)); pos += sizeof(struct inaddr); #if HAVESTRUCTSOCKADDRIN6 } else { memcpy(&sap->ann[pos], &((struct sockaddrin6*)&localaddr)->sin6addr, sizeof(struct in6addr)); pos += sizeof(struct in6addr); #endif } avstrlcpy(&sap->ann[pos], \"application/sdp\", sap->annsize - pos); pos += strlen(&sap->ann[pos]) + 1; if (avsdpcreate(contexts, s->nbstreams, &sap->ann[pos], sap->annsize - pos)) { ret = AVERRORINVALIDDATA; goto fail; } avfreep(&contexts); avlog(s, AVLOGVERBOSE, \"SDP:\\n%s\\n\", &sap->ann[pos]); pos += strlen(&sap->ann[pos]); sap->annsize = pos; if (sap->annsize > sap->annfd->maxpacketsize) { avlog(s, AVLOGERROR, \"Announcement too large to send in one \" \"packet\\n\"); goto fail; } return 0; fail: avfree(contexts); sapwriteclose(s); return ret; } ", "target": 1}
{"func": "static void hlspredictionunit(HEVCContext *s, int x0, int y0, int nPbW, int nPbH, int log2cbsize, int partIdx, int idx) { #define POS(cidx, x, y) \\ &s->frame->data[cidx][((y) >> s->sps->vshift[cidx]) * s->frame->linesize[cidx] + \\ (((x) >> s->sps->hshift[cidx]) << s->sps->pixelshift)] HEVCLocalContext *lc = s->HEVClc; int mergeidx = 0; struct MvField currentmv = {{{ 0 }}}; int minpuwidth = s->sps->minpuwidth; MvField *tabmvf = s->ref->tabmvf; RefPicList *refPicList = s->ref->refPicList; HEVCFrame *ref0, *ref1; uint8t *dst0 = POS(0, x0, y0); uint8t *dst1 = POS(1, x0, y0); uint8t *dst2 = POS(2, x0, y0); int log2mincbsize = s->sps->log2mincbsize; int mincbwidth = s->sps->mincbwidth; int xcb = x0 >> log2mincbsize; int ycb = y0 >> log2mincbsize; int xpu, ypu; int i, j; int skipflag = SAMPLECTB(s->skipflag, xcb, ycb); if (!skipflag) lc->pu.mergeflag = ffhevcmergeflagdecode(s); if (skipflag || lc->pu.mergeflag) { if (s->sh.maxnummergecand > 1) mergeidx = ffhevcmergeidxdecode(s); else mergeidx = 0; ffhevclumamvmergemode(s, x0, y0, nPbW, nPbH, log2cbsize, partIdx, mergeidx, &currentmv); } else { hevclumamvmpvmode(s, x0, y0, nPbW, nPbH, log2cbsize, partIdx, mergeidx, &currentmv); } xpu = x0 >> s->sps->log2minpusize; ypu = y0 >> s->sps->log2minpusize; for (j = 0; j < nPbH >> s->sps->log2minpusize; j++) for (i = 0; i < nPbW >> s->sps->log2minpusize; i++) tabmvf[(ypu + j) * minpuwidth + xpu + i] = currentmv; if (currentmv.predflag & PFL0) { ref0 = refPicList[0].ref[currentmv.refidx[0]]; if (!ref0) return; hevcawaitprogress(s, ref0, &currentmv.mv[0], y0, nPbH); } if (currentmv.predflag & PFL1) { ref1 = refPicList[1].ref[currentmv.refidx[1]]; if (!ref1) return; hevcawaitprogress(s, ref1, &currentmv.mv[1], y0, nPbH); } if (currentmv.predflag == PFL0) { int x0c = x0 >> s->sps->hshift[1]; int y0c = y0 >> s->sps->vshift[1]; int nPbWc = nPbW >> s->sps->hshift[1]; int nPbHc = nPbH >> s->sps->vshift[1]; lumamcuni(s, dst0, s->frame->linesize[0], ref0->frame, &currentmv.mv[0], x0, y0, nPbW, nPbH, s->sh.lumaweightl0[currentmv.refidx[0]], s->sh.lumaoffsetl0[currentmv.refidx[0]]); chromamcuni(s, dst1, s->frame->linesize[1], ref0->frame->data[1], ref0->frame->linesize[1], 0, x0c, y0c, nPbWc, nPbHc, &currentmv, s->sh.chromaweightl0[currentmv.refidx[0]][0], s->sh.chromaoffsetl0[currentmv.refidx[0]][0]); chromamcuni(s, dst2, s->frame->linesize[2], ref0->frame->data[2], ref0->frame->linesize[2], 0, x0c, y0c, nPbWc, nPbHc, &currentmv, s->sh.chromaweightl0[currentmv.refidx[0]][1], s->sh.chromaoffsetl0[currentmv.refidx[0]][1]); } else if (currentmv.predflag == PFL1) { int x0c = x0 >> s->sps->hshift[1]; int y0c = y0 >> s->sps->vshift[1]; int nPbWc = nPbW >> s->sps->hshift[1]; int nPbHc = nPbH >> s->sps->vshift[1]; lumamcuni(s, dst0, s->frame->linesize[0], ref1->frame, &currentmv.mv[1], x0, y0, nPbW, nPbH, s->sh.lumaweightl1[currentmv.refidx[1]], s->sh.lumaoffsetl1[currentmv.refidx[1]]); chromamcuni(s, dst1, s->frame->linesize[1], ref1->frame->data[1], ref1->frame->linesize[1], 1, x0c, y0c, nPbWc, nPbHc, &currentmv, s->sh.chromaweightl1[currentmv.refidx[1]][0], s->sh.chromaoffsetl1[currentmv.refidx[1]][0]); chromamcuni(s, dst2, s->frame->linesize[2], ref1->frame->data[2], ref1->frame->linesize[2], 1, x0c, y0c, nPbWc, nPbHc, &currentmv, s->sh.chromaweightl1[currentmv.refidx[1]][1], s->sh.chromaoffsetl1[currentmv.refidx[1]][1]); } else if (currentmv.predflag == PFBI) { int x0c = x0 >> s->sps->hshift[1]; int y0c = y0 >> s->sps->vshift[1]; int nPbWc = nPbW >> s->sps->hshift[1]; int nPbHc = nPbH >> s->sps->vshift[1]; lumamcbi(s, dst0, s->frame->linesize[0], ref0->frame, &currentmv.mv[0], x0, y0, nPbW, nPbH, ref1->frame, &currentmv.mv[1], &currentmv); chromamcbi(s, dst1, s->frame->linesize[1], ref0->frame, ref1->frame, x0c, y0c, nPbWc, nPbHc, &currentmv, 0); chromamcbi(s, dst2, s->frame->linesize[2], ref0->frame, ref1->frame, x0c, y0c, nPbWc, nPbHc, &currentmv, 1); } } ", "target": 1}
{"func": "static void virtioblkhandleoutput(VirtIODevice *vdev, VirtQueue *vq) { VirtIOBlock *s = VIRTIOBLK(vdev); VirtIOBlockReq *req; MultiReqBuffer mrb = {}; /* Some guests kick before setting VIRTIOCONFIGSDRIVEROK so start * dataplane here instead of waiting for .setstatus(). */ if (s->dataplane) { virtioblkdataplanestart(s->dataplane); return; } blkioplug(s->blk); while ((req = virtioblkgetrequest(s))) { virtioblkhandlerequest(req, &mrb); } if (mrb.numreqs) { virtioblksubmitmultireq(s->blk, &mrb); } blkiounplug(s->blk); } ", "target": 0}
{"func": "static void avnoinline filtermbedgeh( uint8t *pix, int stride, int16t bS[4], unsigned int qp, H264Context *h ) { const unsigned int indexa = 52 + qp + h->slicealphac0offset; const int alpha = alphatable[indexa]; const int beta = (betatable+52)[qp + h->slicebetaoffset]; if (alpha ==0 || beta == 0) return; if( bS[0] < 4 ) { int8t tc[4]; tc[0] = tc0table[indexa][bS[0]]; tc[1] = tc0table[indexa][bS[1]]; tc[2] = tc0table[indexa][bS[2]]; tc[3] = tc0table[indexa][bS[3]]; h->s.dsp.h264vloopfilterluma(pix, stride, alpha, beta, tc); } else { h->s.dsp.h264vloopfilterlumaintra(pix, stride, alpha, beta); } } ", "target": 0}
{"func": "static void realize(DeviceState *d, Error **errp) { sPAPRDRConnector *drc = SPAPRDRCONNECTOR(d); Object *rootcontainer; char linkname[256]; gchar *childname; Error *err = NULL; tracespaprdrcrealize(spaprdrcindex(drc)); /* NOTE: we do this as part of realize/unrealize due to the fact * that the guest will communicate with the DRC via RTAS calls * referencing the global DRC index. By unlinking the DRC * from DRCCONTAINERPATH/<drcindex> we effectively make it * inaccessible by the guest, since lookups rely on this path * existing in the composition tree */ rootcontainer = containerget(objectgetroot(), DRCCONTAINERPATH); snprintf(linkname, sizeof(linkname), \"%x\", spaprdrcindex(drc)); childname = objectgetcanonicalpathcomponent(OBJECT(drc)); tracespaprdrcrealizechild(spaprdrcindex(drc), childname); objectpropertyaddalias(rootcontainer, linkname, drc->owner, childname, &err); gfree(childname); if (err) { errorpropagate(errp, err); return; } vmstateregister(DEVICE(drc), spaprdrcindex(drc), &vmstatespaprdrc, drc); qemuregisterreset(drcreset, drc); tracespaprdrcrealizecomplete(spaprdrcindex(drc)); } ", "target": 0}
{"func": "static void genldasi(DisasContext *dc, TCGv dst, TCGv addr, int insn, int size, int sign) { TCGvi32 rasi, rsize, rsign; rasi = gengetasi(dc, insn); rsize = tcgconsti32(size); rsign = tcgconsti32(sign); #ifdef TARGETSPARC64 genhelperldasi(dst, cpuenv, addr, rasi, rsize, rsign); #else { TCGvi64 t64 = tcgtempnewi64(); genhelperldasi(t64, cpuenv, addr, rasi, rsize, rsign); tcggentrunci64tl(dst, t64); tcgtempfreei64(t64); } #endif tcgtempfreei32(rsign); tcgtempfreei32(rsize); tcgtempfreei32(rasi); } ", "target": 0}
{"func": "static inline float64 ucf64itod(uint64t i) { union { uint64t i; float64 d; } v; v.i = i; return v.d; } ", "target": 0}
{"func": "int tcggencode(TCGContext *s, tcginsnunit *gencodebuf) { int i, oi, oinext, numinsns; #ifdef CONFIGPROFILER { int n; n = s->genlastopidx + 1; s->opcount += n; if (n > s->opcountmax) { s->opcountmax = n; } n = s->nbtemps; s->tempcount += n; if (n > s->tempcountmax) { s->tempcountmax = n; } } #endif #ifdef DEBUGDISAS if (unlikely(qemuloglevelmask(CPULOGTBOP))) { qemulog(\"OP:\\n\"); tcgdumpops(s); qemulog(\"\\n\"); } #endif #ifdef CONFIGPROFILER s->opttime -= profilegetclock(); #endif #ifdef USETCGOPTIMIZATIONS tcgoptimize(s); #endif #ifdef CONFIGPROFILER s->opttime += profilegetclock(); s->latime -= profilegetclock(); #endif tcglivenessanalysis(s); #ifdef CONFIGPROFILER s->latime += profilegetclock(); #endif #ifdef DEBUGDISAS if (unlikely(qemuloglevelmask(CPULOGTBOPOPT))) { qemulog(\"OP after optimization and liveness analysis:\\n\"); tcgdumpops(s); qemulog(\"\\n\"); } #endif tcgregallocstart(s); s->codebuf = gencodebuf; s->codeptr = gencodebuf; tcgouttbinit(s); numinsns = -1; for (oi = s->genfirstopidx; oi >= 0; oi = oinext) { TCGOp * const op = &s->genopbuf[oi]; TCGArg * const args = &s->genopparambuf[op->args]; TCGOpcode opc = op->opc; const TCGOpDef *def = &tcgopdefs[opc]; uint16t deadargs = s->opdeadargs[oi]; uint8t syncargs = s->opsyncargs[oi]; oinext = op->next; #ifdef CONFIGPROFILER tcgtableopcount[opc]++; #endif switch (opc) { case INDEXopmovi32: case INDEXopmovi64: tcgregallocmov(s, def, args, deadargs, syncargs); break; case INDEXopmovii32: case INDEXopmovii64: tcgregallocmovi(s, args, deadargs, syncargs); break; case INDEXopinsnstart: if (numinsns >= 0) { s->geninsnendoff[numinsns] = tcgcurrentcodesize(s); } numinsns++; for (i = 0; i < TARGETINSNSTARTWORDS; ++i) { targetulong a; #if TARGETLONGBITS > TCGTARGETREGBITS a = ((targetulong)args[i * 2 + 1] << 32) | args[i * 2]; #else a = args[i]; #endif s->geninsndata[numinsns][i] = a; } break; case INDEXopdiscard: tempdead(s, args[0]); break; case INDEXopsetlabel: tcgregallocbbend(s, s->reservedregs); tcgoutlabel(s, arglabel(args[0]), s->codeptr); break; case INDEXopcall: tcgregalloccall(s, op->callo, op->calli, args, deadargs, syncargs); break; default: /* Sanity check that we've not introduced any unhandled opcodes. */ if (def->flags & TCGOPFNOTPRESENT) { tcgabort(); } /* Note: in order to speed up the code, it would be much faster to have specialized register allocator functions for some common argument patterns */ tcgregallocop(s, def, opc, args, deadargs, syncargs); break; } #ifndef NDEBUG checkregs(s); #endif /* Test for (pending) buffer overflow. The assumption is that any one operation beginning below the high water mark cannot overrun the buffer completely. Thus we can test for overflow after generating code without having to check during generation. */ if (unlikely((void *)s->codeptr > s->codegenhighwater)) { return -1; } } tcgdebugassert(numinsns >= 0); s->geninsnendoff[numinsns] = tcgcurrentcodesize(s); /* Generate TB finalization at the end of block */ tcgouttbfinalize(s); /* flush instruction cache */ flushicacherange((uintptrt)s->codebuf, (uintptrt)s->codeptr); return tcgcurrentcodesize(s); } ", "target": 0}
{"func": "static int ehciprocessitd(EHCIState *ehci, EHCIitd *itd) { USBPort *port; USBDevice *dev; int ret; uint32t i, j, len, pid, dir, devaddr, endp; uint32t pg, off, ptr1, ptr2, max, mult; dir =(itd->bufptr[1] & ITDBUFPTRDIRECTION); devaddr = getfield(itd->bufptr[0], ITDBUFPTRDEVADDR); endp = getfield(itd->bufptr[0], ITDBUFPTREP); max = getfield(itd->bufptr[1], ITDBUFPTRMAXPKT); mult = getfield(itd->bufptr[2], ITDBUFPTRMULT); for(i = 0; i < 8; i++) { if (itd->transact[i] & ITDXACTACTIVE) { pg = getfield(itd->transact[i], ITDXACTPGSEL); off = itd->transact[i] & ITDXACTOFFSETMASK; ptr1 = (itd->bufptr[pg] & ITDBUFPTRMASK); ptr2 = (itd->bufptr[pg+1] & ITDBUFPTRMASK); len = getfield(itd->transact[i], ITDXACTLENGTH); if (len > max * mult) { len = max * mult; } if (len > BUFFSIZE) { return USBRETPROCERR; } qemusglistinit(&ehci->isgl, 2); if (off + len > 4096) { /* transfer crosses page border */ uint32t len2 = off + len - 4096; uint32t len1 = len - len2; qemusglistadd(&ehci->isgl, ptr1 + off, len1); qemusglistadd(&ehci->isgl, ptr2, len2); } else { qemusglistadd(&ehci->isgl, ptr1 + off, len); } pid = dir ? USBTOKENIN : USBTOKENOUT; usbpacketsetup(&ehci->ipacket, pid, devaddr, endp); usbpacketmap(&ehci->ipacket, &ehci->isgl); ret = USBRETNODEV; for (j = 0; j < NBPORTS; j++) { port = &ehci->ports[j]; dev = port->dev; if (!(ehci->portsc[j] &(PORTSCCONNECT))) { continue; } ret = usbhandlepacket(dev, &ehci->ipacket); if (ret != USBRETNODEV) { break; } } usbpacketunmap(&ehci->ipacket); qemusglistdestroy(&ehci->isgl); #if 0 /* In isoch, there is no facility to indicate a NAK so let's * instead just complete a zero-byte transaction. Setting * DBERR seems too draconian. */ if (ret == USBRETNAK) { if (ehci->isochpause > 0) { DPRINTF(\"ISOCH: received a NAK but paused so returning\\n\"); ehci->isochpause--; return 0; } else if (ehci->isochpause == -1) { DPRINTF(\"ISOCH: recv NAK & isoch pause inactive, setting\\n\"); // Pause frindex for up to 50 msec waiting for data from // remote ehci->isochpause = 50; return 0; } else { DPRINTF(\"ISOCH: isoch pause timeout! return 0\\n\"); ret = 0; } } else { DPRINTF(\"ISOCH: received ACK, clearing pause\\n\"); ehci->isochpause = -1; } #else if (ret == USBRETNAK) { ret = 0; } #endif if (ret >= 0) { if (!dir) { /* OUT */ setfield(&itd->transact[i], len - ret, ITDXACTLENGTH); } else { /* IN */ setfield(&itd->transact[i], ret, ITDXACTLENGTH); } if (itd->transact[i] & ITDXACTIOC) { ehcirecordinterrupt(ehci, USBSTSINT); } } itd->transact[i] &= ~ITDXACTACTIVE; } } return 0; } ", "target": 0}
{"func": "static void qmpinputpop(Visitor *v, void **obj) { QmpInputVisitor *qiv = toqiv(v); StackObject *tos = QSLISTFIRST(&qiv->stack); assert(tos && tos->qapi == obj); QSLISTREMOVEHEAD(&qiv->stack, node); qmpinputstackobjectfree(tos); } ", "target": 0}
{"func": "static int vmdreadheader(AVFormatContext *s, AVFormatParameters *ap) { VmdDemuxContext *vmd = (VmdDemuxContext *)s->privdata; ByteIOContext *pb = &s->pb; AVStream *st; unsigned int tocoffset; unsigned char *rawframetable; int rawframetablesize; offsett currentoffset; int i, j; unsigned int totalframes; int64t videoptsinc = 0; int64t currentvideopts = 0; unsigned char chunk[BYTESPERFRAMERECORD]; int lastframe = 0; /* fetch the main header, including the 2 header length bytes */ urlfseek(pb, 0, SEEKSET); if (getbuffer(pb, vmd->vmdheader, VMDHEADERSIZE) != VMDHEADERSIZE) return AVERRORIO; vmd->audiosamplecounter = 0; vmd->audioframedivisor = 1; vmd->audioblockalign = 1; /* start up the decoders */ st = avnewstream(s, 0); if (!st) return AVERRORNOMEM; avsetptsinfo(st, 33, 1, 90000); vmd->videostreamindex = st->index; st->codec->codectype = CODECTYPEVIDEO; st->codec->codecid = CODECIDVMDVIDEO; st->codec->codectag = 0; /* no fourcc */ st->codec->width = LE16(&vmd->vmdheader[12]); st->codec->height = LE16(&vmd->vmdheader[14]); st->codec->timebase.num = 1; st->codec->timebase.den = 10; st->codec->extradatasize = VMDHEADERSIZE; st->codec->extradata = avmallocz(VMDHEADERSIZE + FFINPUTBUFFERPADDINGSIZE); memcpy(st->codec->extradata, vmd->vmdheader, VMDHEADERSIZE); /* if sample rate is 0, assume no audio */ vmd->samplerate = LE16(&vmd->vmdheader[804]); if (vmd->samplerate) { st = avnewstream(s, 0); if (!st) return AVERRORNOMEM; avsetptsinfo(st, 33, 1, 90000); vmd->audiostreamindex = st->index; st->codec->codectype = CODECTYPEAUDIO; st->codec->codecid = CODECIDVMDAUDIO; st->codec->codectag = 0; /* no fourcc */ st->codec->channels = vmd->audiochannels = (vmd->vmdheader[811] & 0x80) ? 2 : 1; st->codec->samplerate = vmd->samplerate; st->codec->blockalign = vmd->audioblockalign = LE16(&vmd->vmdheader[806]); if (st->codec->blockalign & 0x8000) { st->codec->bitspersample = 16; st->codec->blockalign = -(st->codec->blockalign - 0x10000); vmd->audioblockalign = -(vmd->audioblockalign - 0x10000); } else { st->codec->bitspersample = 8; st->codec->bitrate = st->codec->samplerate * st->codec->bitspersample * st->codec->channels; /* for calculating pts */ vmd->audioframedivisor = st->codec->channels; videoptsinc = 90000; videoptsinc *= st->codec->blockalign; videoptsinc /= st->codec->samplerate; videoptsinc /= st->codec->channels; } else { /* if no audio, assume 10 frames/second */ videoptsinc = 90000 / 10; tocoffset = LE32(&vmd->vmdheader[812]); vmd->framecount = LE16(&vmd->vmdheader[6]); vmd->framesperblock = LE16(&vmd->vmdheader[18]); urlfseek(pb, tocoffset, SEEKSET); rawframetable = NULL; vmd->frametable = NULL; rawframetablesize = vmd->framecount * 6; rawframetable = avmalloc(rawframetablesize); vmd->frametable = avmalloc(vmd->framecount * vmd->framesperblock * sizeof(vmdframet)); if (!rawframetable || !vmd->frametable) { avfree(rawframetable); avfree(vmd->frametable); return AVERRORNOMEM; if (getbuffer(pb, rawframetable, rawframetablesize) != rawframetablesize) { avfree(rawframetable); avfree(vmd->frametable); return AVERRORIO; totalframes = 0; for (i = 0; i < vmd->framecount; i++) { currentoffset = LE32(&rawframetable[6 * i + 2]); /* handle each entry in index block */ for (j = 0; j < vmd->framesperblock; j++) { int type; uint32t size; getbuffer(pb, chunk, BYTESPERFRAMERECORD); type = chunk[0]; size = LE32(&chunk[2]); if(!size) continue; switch(type) { case 1: /* Audio Chunk */ vmd->frametable[totalframes].frameoffset = currentoffset; vmd->frametable[totalframes].streamindex = vmd->audiostreamindex; vmd->frametable[totalframes].framesize = size; memcpy(vmd->frametable[totalframes].framerecord, chunk, BYTESPERFRAMERECORD); totalframes++; break; case 2: /* Video Chunk */ vmd->frametable[totalframes].frameoffset = currentoffset; vmd->frametable[totalframes].framesize = size; vmd->frametable[totalframes].streamindex = vmd->videostreamindex; memcpy(vmd->frametable[totalframes].framerecord, chunk, BYTESPERFRAMERECORD); vmd->frametable[totalframes].pts = currentvideopts; if (lastframe) { vmd->frametable[lastframe].pts = currentvideopts - videoptsinc; lastframe = totalframes; totalframes++; break; currentoffset += size; currentvideopts += videoptsinc; avfree(rawframetable); vmd->currentframe = 0; vmd->framecount = totalframes; return 0; ", "target": 1}
{"func": "void dsputilinitarm(DSPContext* c, AVCodecContext *avctx) { int idctalgo= avctx->idctalgo; ffputpixelsclamped = c->putpixelsclamped; ffaddpixelsclamped = c->addpixelsclamped; if (avctx->lowres == 0) { if(idctalgo == FFIDCTAUTO){ #if HAVEIPP idctalgo = FFIDCTIPP; #elif HAVENEON idctalgo = FFIDCTSIMPLENEON; #elif HAVEARMV6 idctalgo = FFIDCTSIMPLEARMV6; #elif HAVEARMV5TE idctalgo = FFIDCTSIMPLEARMV5TE; #else idctalgo = FFIDCTARM; #endif } if(idctalgo==FFIDCTARM){ c->idctput= jrevdctARMput; c->idctadd= jrevdctARMadd; c->idct = jrevdctARM; c->idctpermutationtype= FFLIBMPEG2IDCTPERM; } else if (idctalgo==FFIDCTSIMPLEARM){ c->idctput= simpleidctARMput; c->idctadd= simpleidctARMadd; c->idct = simpleidctARM; c->idctpermutationtype= FFNOIDCTPERM; #if HAVEARMV6 } else if (idctalgo==FFIDCTSIMPLEARMV6){ c->idctput= ffsimpleidctputarmv6; c->idctadd= ffsimpleidctaddarmv6; c->idct = ffsimpleidctarmv6; c->idctpermutationtype= FFLIBMPEG2IDCTPERM; #endif #if HAVEARMV5TE } else if (idctalgo==FFIDCTSIMPLEARMV5TE){ c->idctput= simpleidctputarmv5te; c->idctadd= simpleidctaddarmv5te; c->idct = simpleidctarmv5te; c->idctpermutationtype = FFNOIDCTPERM; #endif #if HAVEIPP } else if (idctalgo==FFIDCTIPP){ c->idctput= simpleidctippput; c->idctadd= simpleidctippadd; c->idct = simpleidctipp; c->idctpermutationtype= FFNOIDCTPERM; #endif #if HAVENEON } else if (idctalgo==FFIDCTSIMPLENEON){ c->idctput= ffsimpleidctputneon; c->idctadd= ffsimpleidctaddneon; c->idct = ffsimpleidctneon; c->idctpermutationtype = FFPARTTRANSIDCTPERM; } else if ((CONFIGVP3DECODER || CONFIGVP5DECODER || CONFIGVP6DECODER || CONFIGTHEORADECODER) && idctalgo==FFIDCTVP3){ c->idctput= ffvp3idctputneon; c->idctadd= ffvp3idctaddneon; c->idct = ffvp3idctneon; c->idctpermutationtype = FFTRANSPOSEIDCTPERM; #endif } } c->putpixelstab[0][0] = putpixels16arm; c->putpixelstab[0][1] = putpixels16x2arm; c->putpixelstab[0][2] = putpixels16y2arm; c->putpixelstab[0][3] = putpixels16xy2arm; c->putnorndpixelstab[0][0] = putpixels16arm; c->putnorndpixelstab[0][1] = putnorndpixels16x2arm; c->putnorndpixelstab[0][2] = putnorndpixels16y2arm; c->putnorndpixelstab[0][3] = putnorndpixels16xy2arm; c->putpixelstab[1][0] = putpixels8arm; c->putpixelstab[1][1] = putpixels8x2arm; c->putpixelstab[1][2] = putpixels8y2arm; c->putpixelstab[1][3] = putpixels8xy2arm; c->putnorndpixelstab[1][0] = putpixels8arm; c->putnorndpixelstab[1][1] = putnorndpixels8x2arm; c->putnorndpixelstab[1][2] = putnorndpixels8y2arm; c->putnorndpixelstab[1][3] = putnorndpixels8xy2arm; #if HAVEARMV5TE c->prefetch = ffprefetcharm; #endif #if HAVEIWMMXT dsputilinitiwmmxt(c, avctx); #endif #if HAVEARMVFP fffloatinitarmvfp(c, avctx); #endif #if HAVENEON ffdsputilinitneon(c, avctx); #endif } ", "target": 0}
{"func": "avcold void ffh264freecontext(H264Context *h) { int i; ffh264freetables(h); if (h->DPB) { for (i = 0; i < H264MAXPICTURECOUNT; i++) ffh264unrefpicture(h, &h->DPB[i]); avfreep(&h->DPB); } h->curpicptr = NULL; for (i = 0; i < h->nbslicectx; i++) avfreep(&h->slicectx[i].rbspbuffer); avfreep(&h->slicectx); h->nbslicectx = 0; for (i = 0; i < MAXSPSCOUNT; i++) avfreep(h->spsbuffers + i); for (i = 0; i < MAXPPSCOUNT; i++) avfreep(h->ppsbuffers + i); } ", "target": 0}
{"func": "bool aiopoll(AioContext *ctx, bool blocking) { AioHandler *node; int i, ret; bool progress; int64t timeout; aiocontextacquire(ctx); progress = false; /* aionotify can avoid the expensive eventnotifierset if * everything (file descriptors, bottom halves, timers) will * be re-evaluated before the next blocking poll(). This is * already true when aiopoll is called with blocking == false; * if blocking == true, it is only true after poll() returns, * so disable the optimization now. */ if (blocking) { atomicadd(&ctx->notifyme, 2); } ctx->walkinghandlers++; assert(npfd == 0); /* fill pollfds */ if (!aioepollenabled(ctx)) { QLISTFOREACH(node, &ctx->aiohandlers, node) { if (!node->deleted && node->pfd.events && aionodecheck(ctx, node->isexternal)) { addpollfd(node); } } } timeout = blocking ? aiocomputetimeout(ctx) : 0; /* wait until next event */ if (timeout) { aiocontextrelease(ctx); } if (aioepollcheckpoll(ctx, pollfds, npfd, timeout)) { AioHandler epollhandler; epollhandler.pfd.fd = ctx->epollfd; epollhandler.pfd.events = GIOIN | GIOOUT | GIOHUP | GIOERR; npfd = 0; addpollfd(&epollhandler); ret = aioepoll(ctx, pollfds, npfd, timeout); } else { ret = qemupollns(pollfds, npfd, timeout); } if (blocking) { atomicsub(&ctx->notifyme, 2); } if (timeout) { aiocontextacquire(ctx); } aionotifyaccept(ctx); /* if we have any readable fds, dispatch event */ if (ret > 0) { for (i = 0; i < npfd; i++) { nodes[i]->pfd.revents = pollfds[i].revents; } } npfd = 0; ctx->walkinghandlers--; /* Run dispatch even if there were no readable fds to run timers */ if (aiodispatch(ctx, ret > 0)) { progress = true; } aiocontextrelease(ctx); return progress; } ", "target": 1}
{"func": "int avcodecdefaultregetbuffer(AVCodecContext *s, AVFrame *pic) { avassert0(0); }", "target": 1}
{"func": "static int latmwritepacket(AVFormatContext *s, AVPacket *pkt) { AVIOContext *pb = s->pb; PutBitContext bs; int i, len; uint8t loasheader[] = \"\\x56\\xe0\\x00\"; uint8t *buf = NULL; if (s->streams[0]->codec->codecid == CODECIDAACLATM) return ffrawwritepacket(s, pkt); if (pkt->size > 2 && pkt->data[0] == 0xff && (pkt->data[1] >> 4) == 0xf) { avlog(s, AVLOGERROR, \"ADTS header detected - ADTS will not be incorrectly muxed into LATM\\n\"); return AVERRORINVALIDDATA; } if (pkt->size > 0x1fff) goto toolarge; buf = avmalloc(pkt->size+1024); if (!buf) return AVERROR(ENOMEM); initputbits(&bs, buf, pkt->size+1024); latmwriteframeheader(s, &bs); /* PayloadLengthInfo() */ for (i = 0; i <= pkt->size-255; i+=255) putbits(&bs, 8, 255); putbits(&bs, 8, pkt->size-i); /* The LATM payload is written unaligned */ /* PayloadMux() */ if (pkt->size && (pkt->data[0] & 0xe1) == 0x81) { // Convert byte-aligned DSE to non-aligned. // Due to the input format encoding we know that // it is naturally byte-aligned in the input stream, // so there are no padding bits to account for. // To avoid having to add padding bits and rearrange // the whole stream we just remove the byte-align flag. // This allows us to remux our FATE AAC samples into latm // files that are still playable with minimal effort. putbits(&bs, 8, pkt->data[0] & 0xfe); avprivcopybits(&bs, pkt->data + 1, 8*pkt->size - 8); } else avprivcopybits(&bs, pkt->data, 8*pkt->size); avprivalignputbits(&bs); flushputbits(&bs); len = putbitscount(&bs) >> 3; if (len > 0x1fff) goto toolarge; loasheader[1] |= (len >> 8) & 0x1f; loasheader[2] |= len & 0xff; aviowrite(pb, loasheader, 3); aviowrite(pb, buf, len); avfree(buf); return 0; toolarge: avlog(s, AVLOGERROR, \"LATM packet size larger than maximum size 0x1fff\\n\"); avfree(buf); return AVERRORINVALIDDATA; } ", "target": 1}
{"func": "static void aioreaddone(void *opaque, int ret) { struct aioctx *ctx = opaque; struct timeval t2; gettimeofday(&t2, NULL); if (ret < 0) { printf(\"readv failed: %s\\n\", strerror(-ret)); goto out; } if (ctx->Pflag) { void *cmpbuf = gmalloc(ctx->qiov.size); memset(cmpbuf, ctx->pattern, ctx->qiov.size); if (memcmp(ctx->buf, cmpbuf, ctx->qiov.size)) { printf(\"Pattern verification failed at offset %\" PRId64 \", %zd bytes\\n\", ctx->offset, ctx->qiov.size); } gfree(cmpbuf); } if (ctx->qflag) { goto out; } if (ctx->vflag) { dumpbuffer(ctx->buf, ctx->offset, ctx->qiov.size); } /* Finally, report back -- -C gives a parsable format */ t2 = tsub(t2, ctx->t1); printreport(\"read\", &t2, ctx->offset, ctx->qiov.size, ctx->qiov.size, 1, ctx->Cflag); out: qemuiofree(ctx->buf); gfree(ctx); }", "target": 1}
{"func": "static const char *readts(const char *buf, int *tsstart, int *tsend, int *x1, int *y1, int *x2, int *y2) { int i, hs, ms, ss, he, me, se; for (i=0; i<2; i++) { /* try to read timestamps in either the first or second line */ int c = sscanf(buf, \"%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d\" \"%*[ ]X1:%u X2:%u Y1:%u Y2:%u\", &hs, &ms, &ss, tsstart, &he, &me, &se, tsend, x1, x2, y1, y2); buf += strcspn(buf, \"\\n\") + 1; if (c >= 8) { *tsstart = 100*(ss + 60*(ms + 60*hs)) + *tsstart/10; *tsend = 100*(se + 60*(me + 60*he)) + *tsend /10; return buf; } } return NULL; } ", "target": 1}
{"func": "targetphysaddrt cpugetphyspagedebug(CPUState *env, targetulong addr) { targetulong pdeaddr, pteaddr; uint64t pte; targetphysaddrt paddr; uint32t pageoffset; int pagesize; if (env->cr[4] & CR4PAEMASK) { targetulong pdpeaddr; uint64t pde, pdpe; #ifdef TARGETX8664 if (env->hflags & HFLMAMASK) { uint64t pml4eaddr, pml4e; int32t sext; /* test virtual address sign extension */ sext = (int64t)addr >> 47; if (sext != 0 && sext != -1) return -1; pml4eaddr = ((env->cr[3] & ~0xfff) + (((addr >> 39) & 0x1ff) << 3)) & env->a20mask; pml4e = ldqphys(pml4eaddr); if (!(pml4e & PGPRESENTMASK)) return -1; pdpeaddr = ((pml4e & ~0xfff) + (((addr >> 30) & 0x1ff) << 3)) & env->a20mask; pdpe = ldqphys(pdpeaddr); if (!(pdpe & PGPRESENTMASK)) return -1; } else #endif { pdpeaddr = ((env->cr[3] & ~0x1f) + ((addr >> 27) & 0x18)) & env->a20mask; pdpe = ldqphys(pdpeaddr); if (!(pdpe & PGPRESENTMASK)) return -1; } pdeaddr = ((pdpe & ~0xfff) + (((addr >> 21) & 0x1ff) << 3)) & env->a20mask; pde = ldqphys(pdeaddr); if (!(pde & PGPRESENTMASK)) { return -1; } if (pde & PGPSEMASK) { /* 2 MB page */ pagesize = 2048 * 1024; pte = pde & ~( (pagesize - 1) & ~0xfff); /* align to pagesize */ } else { /* 4 KB page */ pteaddr = ((pde & ~0xfff) + (((addr >> 12) & 0x1ff) << 3)) & env->a20mask; pagesize = 4096; pte = ldqphys(pteaddr); } if (!(pte & PGPRESENTMASK)) return -1; } else { uint32t pde; if (!(env->cr[0] & CR0PGMASK)) { pte = addr; pagesize = 4096; } else { /* page directory entry */ pdeaddr = ((env->cr[3] & ~0xfff) + ((addr >> 20) & 0xffc)) & env->a20mask; pde = ldlphys(pdeaddr); if (!(pde & PGPRESENTMASK)) return -1; if ((pde & PGPSEMASK) && (env->cr[4] & CR4PSEMASK)) { pte = pde & ~0x003ff000; /* align to 4MB */ pagesize = 4096 * 1024; } else { /* page directory entry */ pteaddr = ((pde & ~0xfff) + ((addr >> 10) & 0xffc)) & env->a20mask; pte = ldlphys(pteaddr); if (!(pte & PGPRESENTMASK)) return -1; pagesize = 4096; } } pte = pte & env->a20mask; } pageoffset = (addr & TARGETPAGEMASK) & (pagesize - 1); paddr = (pte & TARGETPAGEMASK) + pageoffset; return paddr; } ", "target": 1}
{"func": "void spaprpcirtasinit(void) { spaprrtasregister(\"read-pci-config\", rtasreadpciconfig); spaprrtasregister(\"write-pci-config\", rtaswritepciconfig); spaprrtasregister(\"ibm,read-pci-config\", rtasibmreadpciconfig); spaprrtasregister(\"ibm,write-pci-config\", rtasibmwritepciconfig); if (msisupported) { spaprrtasregister(\"ibm,query-interrupt-source-number\", rtasibmqueryinterruptsourcenumber); spaprrtasregister(\"ibm,change-msi\", rtasibmchangemsi); } } ", "target": 1}
{"func": "static void comparesecrsfinalize(SocketReadState *secrs) { CompareState *s = containerof(secrs, CompareState, secrs); if (packetenqueue(s, SECONDARYIN)) { tracecolocomparemain(\"secondary: unsupported packet in\"); } else { /* compare connection */ gqueueforeach(&s->connlist, colocompareconnection, s); } } ", "target": 0}
{"func": "FDCtrl *fdctrlinitisa(DriveInfo **fds) { ISADevice *dev; dev = isacreate(\"isa-fdc\"); if (fds[0]) { qdevpropsetdrivenofail(&dev->qdev, \"driveA\", fds[0]->bdrv); } if (fds[1]) { qdevpropsetdrivenofail(&dev->qdev, \"driveB\", fds[1]->bdrv); } if (qdevinit(&dev->qdev) < 0) return NULL; return &(DOUPCAST(FDCtrlISABus, busdev, dev)->state); } ", "target": 1}
{"func": "static int asfreadpicture(AVFormatContext *s, int len) { ASFContext *asf = s->privdata; AVPacket pkt = { 0 }; const CodecMime *mime = ffid3v2mimetags; enum AVCodecID id = AVCODECIDNONE; char mimetype[64]; uint8t *desc = NULL; AVStream *st = NULL; int ret, type, picsize, desclen; ASFStream *asfst; /* type + picsize + mime + desc */ if (len < 1 + 4 + 2 + 2) { avlog(s, AVLOGERROR, \"Invalid attached picture size: %d.\\n\", len); return AVERRORINVALIDDATA; } /* picture type */ type = avior8(s->pb); len--; if (type >= FFARRAYELEMS(ffid3v2picturetypes) || type < 0) { avlog(s, AVLOGWARNING, \"Unknown attached picture type: %d.\\n\", type); type = 0; } /* picture data size */ picsize = aviorl32(s->pb); len -= 4; /* picture MIME type */ len -= aviogetstr16le(s->pb, len, mimetype, sizeof(mimetype)); while (mime->id != AVCODECIDNONE) { if (!strncmp(mime->str, mimetype, sizeof(mimetype))) { id = mime->id; break; } mime++; } if (id == AVCODECIDNONE) { avlog(s, AVLOGERROR, \"Unknown attached picture mimetype: %s.\\n\", mimetype); return 0; } if (picsize >= len) { avlog(s, AVLOGERROR, \"Invalid attached picture data size: %d >= %d.\\n\", picsize, len); return AVERRORINVALIDDATA; } /* picture description */ desclen = (len - picsize) * 2 + 1; desc = avmalloc(desclen); if (!desc) return AVERROR(ENOMEM); len -= aviogetstr16le(s->pb, len - picsize, desc, desclen); ret = avgetpacket(s->pb, &pkt, picsize); if (ret < 0) goto fail; st = avformatnewstream(s, NULL); if (!st) { ret = AVERROR(ENOMEM); goto fail; } asf->asfst[asf->nbstreams] = avmallocz(sizeof(*asfst)); asfst = asf->asfst[asf->nbstreams]; if (!asfst) return AVERROR(ENOMEM); st->disposition |= AVDISPOSITIONATTACHEDPIC; st->codec->codectype = asfst->type = AVMEDIATYPEVIDEO; st->codec->codecid = id; st->attachedpic = pkt; st->attachedpic.streamindex = asfst->index = st->index; st->attachedpic.flags |= AVPKTFLAGKEY; asf->nbstreams++; if (*desc) { if (avdictset(&st->metadata, \"title\", desc, AVDICTDONTSTRDUPVAL) < 0) avlog(s, AVLOGWARNING, \"avdictset failed.\\n\"); } else avfreep(&desc); if (avdictset(&st->metadata, \"comment\", ffid3v2picturetypes[type], 0) < 0) avlog(s, AVLOGWARNING, \"avdictset failed.\\n\"); return 0; fail: avfreep(&desc); avfreepacket(&pkt); return ret; } ", "target": 1}
{"func": "void HELPER(accesscheckcpreg)(CPUARMState *env, void *rip, uint32t syndrome) { const ARMCPRegInfo *ri = rip; switch (ri->accessfn(env, ri)) { case CPACCESSOK: case CPACCESSTRAP: break; case CPACCESSTRAPUNCATEGORIZED: env->exception.syndrome = synuncategorized(); break; default: gassertnotreached();", "target": 1}
{"func": "static char *scsibusgetdevpath(DeviceState *dev) { SCSIDevice *d = DOUPCAST(SCSIDevice, qdev, dev); DeviceState *hba = dev->parentbus->parent; char *id = NULL; if (hba && hba->parentbus && hba->parentbus->info->getdevpath) { id = hba->parentbus->info->getdevpath(hba); } if (id) { return gstrdupprintf(\"%s/%d:%d:%d\", id, d->channel, d->id, d->lun); } else { return gstrdupprintf(\"%d:%d:%d\", d->channel, d->id, d->lun); } } ", "target": 1}
{"func": "static int evallpccoeffs(const float *in, float *tgt, int n) { int x, y; double f0, f1, f2; if (in[n] == 0) return 0; if ((f0 = *in) <= 0) return 0; in--; // To avoid a -1 subtraction in the inner loop for (x=1; x <= n; x++) { f1 = in[x+1]; for (y=0; y < x - 1; y++) f1 += in[x-y]*tgt[y]; tgt[x-1] = f2 = -f1/f0; for (y=0; y < x >> 1; y++) { float temp = tgt[y] + tgt[x-y-2]*f2; tgt[x-y-2] += tgt[y]*f2; tgt[y] = temp; } if ((f0 += f1*f2) < 0) return 0; } return 1; } ", "target": 0}
{"func": "int swrinit(struct SwrContext *s){ s->inbufferindex= 0; s->inbuffercount= 0; s->resampleinconstraint= 0; freetemp(&s->postin); freetemp(&s->midbuf); freetemp(&s->preout); freetemp(&s->inbuffer); freetemp(&s->dither); swriaudioconvertfree(&s-> inconvert); swriaudioconvertfree(&s->outconvert); swriaudioconvertfree(&s->fullconvert); swrirematrixfree(s); s->flushed = 0; if(s-> insamplefmt >= AVSAMPLEFMTNB){ avlog(s, AVLOGERROR, \"Requested input sample format %d is invalid\\n\", s->insamplefmt); return AVERROR(EINVAL); } if(s->outsamplefmt >= AVSAMPLEFMTNB){ avlog(s, AVLOGERROR, \"Requested output sample format %d is invalid\\n\", s->outsamplefmt); return AVERROR(EINVAL); } //FIXME should we allow/support using FLT on material that doesnt need it ? if(avgetplanarsamplefmt(s->insamplefmt) <= AVSAMPLEFMTS16P || s->intsamplefmt==AVSAMPLEFMTS16P){ s->intsamplefmt= AVSAMPLEFMTS16P; }else s->intsamplefmt= AVSAMPLEFMTFLTP; if( s->intsamplefmt != AVSAMPLEFMTS16P &&s->intsamplefmt != AVSAMPLEFMTS32P &&s->intsamplefmt != AVSAMPLEFMTFLTP){ avlog(s, AVLOGERROR, \"Requested sample format %s is not supported internally, S16/S32/FLT is supported\\n\", avgetsamplefmtname(s->intsamplefmt)); return AVERROR(EINVAL); } setaudiodatafmt(&s-> in, s-> insamplefmt); setaudiodatafmt(&s->out, s->outsamplefmt); if (s->outsamplerate!=s->insamplerate || (s->flags & SWRFLAGRESAMPLE)){ s->resample = swriresampleinit(s->resample, s->outsamplerate, s->insamplerate, s->filtersize, s->phaseshift, s->linearinterp, s->cutoff, s->intsamplefmt); }else swriresamplefree(&s->resample); if( s->intsamplefmt != AVSAMPLEFMTS16P && s->intsamplefmt != AVSAMPLEFMTS32P && s->intsamplefmt != AVSAMPLEFMTFLTP && s->resample){ avlog(s, AVLOGERROR, \"Resampling only supported with internal s16/s32/flt\\n\"); return -1; } if(!s->usedchcount) s->usedchcount= s->in.chcount; if(s->usedchcount && s-> inchlayout && s->usedchcount != avgetchannellayoutnbchannels(s-> inchlayout)){ avlog(s, AVLOGWARNING, \"Input channel layout has a different number of channels than the number of used channels, ignoring layout\\n\"); s-> inchlayout= 0; } if(!s-> inchlayout) s-> inchlayout= avgetdefaultchannellayout(s->usedchcount); if(!s->outchlayout) s->outchlayout= avgetdefaultchannellayout(s->out.chcount); s->rematrix= s->outchlayout !=s->inchlayout || s->rematrixvolume!=1.0 || s->rematrixcustom; #define RSC 1 //FIXME finetune if(!s-> in.chcount) s-> in.chcount= avgetchannellayoutnbchannels(s-> inchlayout); if(!s->usedchcount) s->usedchcount= s->in.chcount; if(!s->out.chcount) s->out.chcount= avgetchannellayoutnbchannels(s->outchlayout); if(!s-> in.chcount){ avassert0(!s->inchlayout); avlog(s, AVLOGERROR, \"Input channel count and layout are unset\\n\"); return -1; } if ((!s->outchlayout || !s->inchlayout) && s->usedchcount != s->out.chcount && !s->rematrixcustom) { avlog(s, AVLOGERROR, \"Rematrix is needed but there is not enough information to do it\\n\"); return -1; } avassert0(s->usedchcount); avassert0(s->out.chcount); s->resamplefirst= RSC*s->out.chcount/s->in.chcount - RSC < s->outsamplerate/(float)s-> insamplerate - 1.0; s->inbuffer= s->in; if(!s->resample && !s->rematrix && !s->channelmap && !s->dithermethod){ s->fullconvert = swriaudioconvertalloc(s->outsamplefmt, s-> insamplefmt, s-> in.chcount, NULL, 0); return 0; } s->inconvert = swriaudioconvertalloc(s->intsamplefmt, s-> insamplefmt, s->usedchcount, s->channelmap, 0); s->outconvert= swriaudioconvertalloc(s->outsamplefmt, s->intsamplefmt, s->out.chcount, NULL, 0); s->postin= s->in; s->preout= s->out; s->midbuf= s->in; if(s->channelmap){ s->postin.chcount= s->midbuf.chcount= s->usedchcount; if(s->resample) s->inbuffer.chcount= s->usedchcount; } if(!s->resamplefirst){ s->midbuf.chcount= s->out.chcount; if(s->resample) s->inbuffer.chcount = s->out.chcount; } setaudiodatafmt(&s->postin, s->intsamplefmt); setaudiodatafmt(&s->midbuf, s->intsamplefmt); setaudiodatafmt(&s->preout, s->intsamplefmt); if(s->resample){ setaudiodatafmt(&s->inbuffer, s->intsamplefmt); } s->dither = s->preout; if(s->rematrix || s->dithermethod) return swrirematrixinit(s); return 0; } ", "target": 0}
{"func": "void pchotaddcpu(const int64t id, Error **errp) { DeviceState *iccbridge; int64t apicid = x86cpuapicidfromindex(id); if (cpuexists(apicid)) { errorsetg(errp, \"Unable to add CPU: %\" PRIi64 \", it already exists\", id); if (id >= maxcpus) { errorsetg(errp, \"Unable to add CPU: %\" PRIi64 \", max allowed: %d\", id, maxcpus - 1); iccbridge = DEVICE(objectresolvepathtype(\"icc-bridge\", TYPEICCBRIDGE, NULL)); pcnewcpu(currentcpumodel, apicid, iccbridge, errp);", "target": 1}
{"func": "static void xlnxep108init(MachineState *machine) { XlnxEP108 *s = gnew0(XlnxEP108, 1); Error *err = NULL; objectinitialize(&s->soc, sizeof(s->soc), TYPEXLNXZYNQMP); objectpropertyaddchild(OBJECT(machine), \"soc\", OBJECT(&s->soc), &errorabort); objectpropertysetbool(OBJECT(&s->soc), true, \"realized\", &err); if (err) { errorreport(\"%s\", errorgetpretty(err)); exit(1); } if (machine->ramsize > EP108MAXRAMSIZE) { errorreport(\"WARNING: RAM size \" RAMADDRFMT \" above max supported, \" \"reduced to %llx\", machine->ramsize, EP108MAXRAMSIZE); machine->ramsize = EP108MAXRAMSIZE; } if (machine->ramsize <= 0x08000000) { qemulog(\"WARNING: RAM size \" RAMADDRFMT \" is small for EP108\", machine->ramsize); } memoryregionallocatesystemmemory(&s->ddrram, NULL, \"ddr-ram\", machine->ramsize); memoryregionaddsubregion(getsystemmemory(), 0, &s->ddrram); xlnxep108binfo.ramsize = machine->ramsize; xlnxep108binfo.kernelfilename = machine->kernelfilename; xlnxep108binfo.kernelcmdline = machine->kernelcmdline; xlnxep108binfo.initrdfilename = machine->initrdfilename; xlnxep108binfo.loaderstart = 0; armloadkernel(s->soc.bootcpuptr, &xlnxep108binfo); } ", "target": 1}
{"func": "static int parseinputs(const char **buf, AVFilterInOut **currinputs, AVFilterInOut **openoutputs, AVClass *logctx) { int pad = 0; while (**buf == '[') { char *name = parselinkname(buf, logctx); AVFilterInOut *match; if (!name) return AVERROR(EINVAL); /* First check if the label is not in the openoutputs list */ match = extractinout(name, openoutputs); if (match) { avfree(name); } else { /* Not in the list, so add it as an input */ match = avmallocz(sizeof(AVFilterInOut)); match->name = name; match->padidx = pad; } insertinout(currinputs, match); *buf += strspn(*buf, WHITESPACES); pad++; } return pad; } ", "target": 1}
{"func": "void vp8mcchroma(VP8Context *s, VP8ThreadData *td, uint8t *dst1, uint8t *dst2, ThreadFrame *ref, const VP56mv *mv, int xoff, int yoff, int blockw, int blockh, int width, int height, int linesize, vp8mcfunc mcfunc[3][3]) { uint8t *src1 = ref->f->data[1], *src2 = ref->f->data[2]; if (AVRN32A(mv)) { int mx = mv->x&7, mxidx = subpelidx[0][mx]; int my = mv->y&7, myidx = subpelidx[0][my]; xoff += mv->x >> 3; yoff += mv->y >> 3; // edge emulation src1 += yoff * linesize + xoff; src2 += yoff * linesize + xoff; ffthreadawaitprogress(ref, (3 + yoff + blockh + subpelidx[2][my]) >> 3, 0); if (xoff < mxidx || xoff >= width - blockw - subpelidx[2][mx] || yoff < myidx || yoff >= height - blockh - subpelidx[2][my]) { s->vdsp.emulatededgemc(td->edgeemubuffer, src1 - myidx * linesize - mxidx, linesize, blockw + subpelidx[1][mx], blockh + subpelidx[1][my], xoff - mxidx, yoff - myidx, width, height); src1 = td->edgeemubuffer + mxidx + linesize * myidx; mcfunc[myidx][mxidx](dst1, linesize, src1, linesize, blockh, mx, my); s->vdsp.emulatededgemc(td->edgeemubuffer, src2 - myidx * linesize - mxidx, linesize, blockw + subpelidx[1][mx], blockh + subpelidx[1][my], xoff - mxidx, yoff - myidx, width, height); src2 = td->edgeemubuffer + mxidx + linesize * myidx; mcfunc[myidx][mxidx](dst2, linesize, src2, linesize, blockh, mx, my); } else { mcfunc[myidx][mxidx](dst1, linesize, src1, linesize, blockh, mx, my); mcfunc[myidx][mxidx](dst2, linesize, src2, linesize, blockh, mx, my); } } else { ffthreadawaitprogress(ref, (3 + yoff + blockh) >> 3, 0); mcfunc[0][0](dst1, linesize, src1 + yoff * linesize + xoff, linesize, blockh, 0, 0); mcfunc[0][0](dst2, linesize, src2 + yoff * linesize + xoff, linesize, blockh, 0, 0); } } ", "target": 1}
{"func": "static void rgb24toyuv444p(AVPicture *dst, AVPicture *src, int width, int height) { int srcwrap, x, y; int r, g, b; uint8t *lum, *cb, *cr; const uint8t *p; lum = dst->data[0]; cb = dst->data[1]; cr = dst->data[2]; srcwrap = src->linesize[0] - width * BPP; p = src->data[0]; for(y=0;y<height;y++) { for(x=0;x<width;x++) { RGBIN(r, g, b, p); lum[0] = RGBTOYCCIR(r, g, b); cb[0] = RGBTOUCCIR(r, g, b, 0); cr[0] = RGBTOVCCIR(r, g, b, 0); cb++; cr++; lum++; } p += srcwrap; lum += dst->linesize[0] - width; cb += dst->linesize[1] - width; cr += dst->linesize[2] - width; } } ", "target": 0}
{"func": "static char *pcibusgetfwdevpath(DeviceState *dev) { PCIDevice *d = (PCIDevice *)dev; char path[50], name[33]; int off; off = snprintf(path, sizeof(path), \"%s@%x\", pcidevfwname(dev, name, sizeof name), PCISLOT(d->devfn)); if (PCIFUNC(d->devfn)) snprintf(path + off, sizeof(path) + off, \",%x\", PCIFUNC(d->devfn)); return strdup(path); } ", "target": 0}
{"func": "static int qiochannelwebsockhandshakesendresponse(QIOChannelWebsock *ioc, const char *key, Error **errp) { char combinedkey[QIOCHANNELWEBSOCKCLIENTKEYLEN + QIOCHANNELWEBSOCKGUIDLEN + 1]; char *accept = NULL, *response = NULL; sizet responselen; gstrlcpy(combinedkey, key, QIOCHANNELWEBSOCKCLIENTKEYLEN + 1); gstrlcat(combinedkey, QIOCHANNELWEBSOCKGUID, QIOCHANNELWEBSOCKCLIENTKEYLEN + QIOCHANNELWEBSOCKGUIDLEN + 1); /* hash and encode it */ if (qcryptohashbase64(QCRYPTOHASHALGSHA1, combinedkey, QIOCHANNELWEBSOCKCLIENTKEYLEN + QIOCHANNELWEBSOCKGUIDLEN, &accept, errp) < 0) { return -1; } response = gstrdupprintf(QIOCHANNELWEBSOCKHANDSHAKERESPONSE, accept); responselen = strlen(response); bufferreserve(&ioc->encoutput, responselen); bufferappend(&ioc->encoutput, response, responselen); gfree(accept); gfree(response); return 0; } ", "target": 1}
{"func": "void dpygfxcopy(QemuConsole *con, int srcx, int srcy, int dstx, int dsty, int w, int h) { DisplayState *s = con->ds; DisplayChangeListener *dcl; if (!qemuconsoleisvisible(con)) { return; } QLISTFOREACH(dcl, &s->listeners, next) { if (con != (dcl->con ? dcl->con : activeconsole)) { continue; } if (dcl->ops->dpygfxcopy) { dcl->ops->dpygfxcopy(dcl, srcx, srcy, dstx, dsty, w, h); } else { /* TODO */ dcl->ops->dpygfxupdate(dcl, dstx, dsty, w, h); } } } ", "target": 1}
{"func": "static TCGArg *tcgconstantfolding(TCGContext *s, uint16t *tcgopcptr, TCGArg *args, TCGOpDef *tcgopdefs) { int i, nbops, opindex, nbtemps, nbglobals, nbcallargs; TCGOpcode op; const TCGOpDef *def; TCGArg *genargs; TCGArg tmp; TCGCond cond; /* Array VALS has an element for each temp. If this temp holds a constant then its value is kept in VALS' element. If this temp is a copy of other ones then the other copies are available through the doubly linked circular list. */ nbtemps = s->nbtemps; nbglobals = s->nbglobals; memset(temps, 0, nbtemps * sizeof(struct tcgtempinfo)); nbops = tcgopcptr - genopcbuf; genargs = args; for (opindex = 0; opindex < nbops; opindex++) { op = genopcbuf[opindex]; def = &tcgopdefs[op]; /* Do copy propagation */ if (op == INDEXopcall) { int nboargs = args[0] >> 16; int nbiargs = args[0] & 0xffff; for (i = nboargs + 1; i < nboargs + nbiargs + 1; i++) { if (temps[args[i]].state == TCGTEMPCOPY) { args[i] = findbettercopy(s, args[i]); } else { for (i = def->nboargs; i < def->nboargs + def->nbiargs; i++) { if (temps[args[i]].state == TCGTEMPCOPY) { args[i] = findbettercopy(s, args[i]); /* For commutative operations make constant second argument */ CASEOP3264(add): CASEOP3264(mul): CASEOP3264(and): CASEOP3264(or): CASEOP3264(eqv): CASEOP3264(nand): CASEOP3264(nor): if (temps[args[1]].state == TCGTEMPCONST) { tmp = args[1]; args[1] = args[2]; args[2] = tmp; CASEOP3264(brcond): if (temps[args[0]].state == TCGTEMPCONST && temps[args[1]].state != TCGTEMPCONST) { tmp = args[0]; args[0] = args[1]; args[1] = tmp; args[2] = tcgswapcond(args[2]); CASEOP3264(setcond): if (temps[args[1]].state == TCGTEMPCONST && temps[args[2]].state != TCGTEMPCONST) { tmp = args[1]; args[1] = args[2]; args[2] = tmp; args[3] = tcgswapcond(args[3]); CASEOP3264(movcond): cond = args[5]; if (temps[args[1]].state == TCGTEMPCONST && temps[args[2]].state != TCGTEMPCONST) { tmp = args[1]; args[1] = args[2]; args[2] = tmp; cond = tcgswapcond(cond); /* For movcond, we canonicalize the \"false\" input reg to match the destination reg so that the tcg backend can implement a \"move if true\" operation. */ if (args[0] == args[3]) { tmp = args[3]; args[3] = args[4]; args[4] = tmp; cond = tcginvertcond(cond); args[5] = cond; /* Simplify expressions for \"shift/rot r, 0, a => movi r, 0\" */ CASEOP3264(shl): CASEOP3264(shr): CASEOP3264(sar): CASEOP3264(rotl): CASEOP3264(rotr): if (temps[args[1]].state == TCGTEMPCONST && temps[args[1]].val == 0) { /* Simplify expression for \"op r, a, 0 => mov r, a\" cases */ CASEOP3264(add): CASEOP3264(shl): CASEOP3264(shr): CASEOP3264(sar): CASEOP3264(rotl): CASEOP3264(rotr): CASEOP3264(or): if (temps[args[1]].state == TCGTEMPCONST) { /* Proceed with possible constant folding. */ if (temps[args[2]].state == TCGTEMPCONST && temps[args[2]].val == 0) { if (tempsarecopies(args[0], args[1])) { genopcbuf[opindex] = INDEXopnop; } else { genopcbuf[opindex] = optomov(op); tcgoptgenmov(s, genargs, args[0], args[1]); /* Simplify expression for \"op r, a, 0 => movi r, 0\" cases */ CASEOP3264(and): CASEOP3264(mul): if ((temps[args[2]].state == TCGTEMPCONST && temps[args[2]].val == 0)) { /* Simplify expression for \"op r, a, a => mov r, a\" cases */ CASEOP3264(or): CASEOP3264(and): if (tempsarecopies(args[0], args[1])) { genopcbuf[opindex] = INDEXopnop; } else { genopcbuf[opindex] = optomov(op); tcgoptgenmov(s, genargs, args[0], args[1]); /* Propagate constants through copy operations and do constant folding. Constants will be substituted to arguments by register allocator where needed and possible. Also detect copies. */ CASEOP3264(mov): if (tempsarecopies(args[0], args[1])) { args += 2; genopcbuf[opindex] = INDEXopnop; if (temps[args[1]].state != TCGTEMPCONST) { tcgoptgenmov(s, genargs, args[0], args[1]); args += 2; /* Source argument is constant. Rewrite the operation and let movi case handle it. */ op = optomovi(op); genopcbuf[opindex] = op; args[1] = temps[args[1]].val; /* fallthrough */ CASEOP3264(movi): tcgoptgenmovi(genargs, args[0], args[1]); args += 2; CASEOP3264(not): CASEOP3264(neg): CASEOP3264(ext8s): CASEOP3264(ext8u): CASEOP3264(ext16s): CASEOP3264(ext16u): case INDEXopext32si64: case INDEXopext32ui64: if (temps[args[1]].state == TCGTEMPCONST) { tmp = doconstantfolding(op, temps[args[1]].val, 0); tcgoptgenmovi(genargs, args[0], tmp); } else { resettemp(args[0]); genargs[0] = args[0]; genargs[1] = args[1]; args += 2; CASEOP3264(add): CASEOP3264(mul): CASEOP3264(or): CASEOP3264(and): CASEOP3264(shl): CASEOP3264(shr): CASEOP3264(sar): CASEOP3264(rotl): CASEOP3264(rotr): CASEOP3264(andc): CASEOP3264(orc): CASEOP3264(eqv): CASEOP3264(nand): CASEOP3264(nor): if (temps[args[1]].state == TCGTEMPCONST && temps[args[2]].state == TCGTEMPCONST) { tmp = doconstantfolding(op, temps[args[1]].val, temps[args[2]].val); tcgoptgenmovi(genargs, args[0], tmp); } else { resettemp(args[0]); genargs[0] = args[0]; genargs[1] = args[1]; genargs[2] = args[2]; genargs += 3; CASEOP3264(setcond): if (temps[args[1]].state == TCGTEMPCONST && temps[args[2]].state == TCGTEMPCONST) { tmp = doconstantfoldingcond(op, temps[args[1]].val, temps[args[2]].val, args[3]); tcgoptgenmovi(genargs, args[0], tmp); } else { resettemp(args[0]); genargs[0] = args[0]; genargs[1] = args[1]; genargs[2] = args[2]; genargs[3] = args[3]; genargs += 4; args += 4; CASEOP3264(brcond): if (temps[args[0]].state == TCGTEMPCONST && temps[args[1]].state == TCGTEMPCONST) { if (doconstantfoldingcond(op, temps[args[0]].val, temps[args[1]].val, args[2])) { memset(temps, 0, nbtemps * sizeof(struct tcgtempinfo)); genopcbuf[opindex] = INDEXopbr; genargs[0] = args[3]; genargs += 1; } else { genopcbuf[opindex] = INDEXopnop; } else { memset(temps, 0, nbtemps * sizeof(struct tcgtempinfo)); resettemp(args[0]); genargs[0] = args[0]; genargs[1] = args[1]; genargs[2] = args[2]; genargs[3] = args[3]; genargs += 4; args += 4; CASEOP3264(movcond): if (temps[args[1]].state == TCGTEMPCONST && temps[args[2]].state == TCGTEMPCONST) { tmp = doconstantfoldingcond(op, temps[args[1]].val, temps[args[2]].val, args[5]); if (tempsarecopies(args[0], args[4-tmp])) { genopcbuf[opindex] = INDEXopnop; } else if (temps[args[4-tmp]].state == TCGTEMPCONST) { tcgoptgenmovi(genargs, args[0], temps[args[4-tmp]].val); } else { genopcbuf[opindex] = optomov(op); tcgoptgenmov(s, genargs, args[0], args[4-tmp]); } else { resettemp(args[0]); genargs[0] = args[0]; genargs[1] = args[1]; genargs[2] = args[2]; genargs[3] = args[3]; genargs[4] = args[4]; genargs[5] = args[5]; genargs += 6; args += 6; case INDEXopcall: nbcallargs = (args[0] >> 16) + (args[0] & 0xffff); if (!(args[nbcallargs + 1] & (TCGCALLCONST | TCGCALLPURE))) { for (i = 0; i < nbglobals; i++) { resettemp(i); for (i = 0; i < (args[0] >> 16); i++) { resettemp(args[i + 1]); i = nbcallargs + 3; while (i) { *genargs = *args; args++; genargs++; i--; /* Default case: we do know nothing about operation so no propagation is done. We trash everything if the operation is the end of a basic block, otherwise we only trash the output args. */ if (def->flags & TCGOPFBBEND) { memset(temps, 0, nbtemps * sizeof(struct tcgtempinfo)); } else { for (i = 0; i < def->nboargs; i++) { resettemp(args[i]); for (i = 0; i < def->nbargs; i++) { genargs[i] = args[i]; args += def->nbargs; genargs += def->nbargs; return genargs;", "target": 1}
{"func": "static void vncconnect(VncDisplay *vd, int csock, bool skipauth, bool websocket) { VncState *vs = gmalloc0(sizeof(VncState)); int i; vs->csock = csock; vs->vd = vd; if (skipauth) { \tvs->auth = VNCAUTHNONE; \tvs->subauth = VNCAUTHINVALID; } else { if (websocket) { vs->auth = vd->wsauth; vs->subauth = VNCAUTHINVALID; } else { vs->auth = vd->auth; vs->subauth = vd->subauth; } } VNCDEBUG(\"Client sock=%d ws=%d auth=%d subauth=%d\\n\", csock, websocket, vs->auth, vs->subauth); vs->lossyrect = gmalloc0(VNCSTATROWS * sizeof (*vs->lossyrect)); for (i = 0; i < VNCSTATROWS; ++i) { vs->lossyrect[i] = gmalloc0(VNCSTATCOLS * sizeof (uint8t)); } VNCDEBUG(\"New client on socket %d\\n\", csock); updatedisplaychangelistener(&vd->dcl, VNCREFRESHINTERVALBASE); qemusetnonblock(vs->csock); if (websocket) { vs->websocket = 1; if (vd->wstls) { qemusetfdhandler(vs->csock, vncwstlshandshakeio, NULL, vs); } else { qemusetfdhandler(vs->csock, vncwshandshakeread, NULL, vs); } } else { qemusetfdhandler(vs->csock, vncclientread, NULL, vs); } vncclientcacheaddr(vs); vncqmpevent(vs, QAPIEVENTVNCCONNECTED); vncsetsharemode(vs, VNCSHAREMODECONNECTING); if (!vs->websocket) { vncinitstate(vs); } if (vd->numconnecting > vd->connectionslimit) { QTAILQFOREACH(vs, &vd->clients, next) { if (vs->sharemode == VNCSHAREMODECONNECTING) { vncdisconnectstart(vs); return; } } } } ", "target": 1}
{"func": "static int ftpcurrentdir(FTPContext *s) { char *res = NULL, *start = NULL, *end = NULL; int i; const char *command = \"PWD\\r\\n\"; const int pwdcodes[] = {257, 0}; if (!ftpsendcommand(s, command, pwdcodes, &res)) goto fail; for (i = 0; res[i]; ++i) { if (res[i] == '\"') { if (!start) { start = res + i + 1; continue; } end = res + i; break; } } if (!end) goto fail; if (end > res && end[-1] == '/') { end[-1] = '\\0'; } else *end = '\\0'; avstrlcpy(s->path, start, sizeof(s->path)); avfree(res); return 0; fail: avfree(res); return AVERROR(EIO); } ", "target": 0}
{"func": "int qemuoptsprint(QemuOpts *opts, void *dummy) { QemuOpt *opt; fprintf(stderr, \"%s: %s:\", opts->list->name, opts->id ? opts->id : \"<noid>\"); TAILQFOREACH(opt, &opts->head, next) { fprintf(stderr, \" %s=\\\"%s\\\"\", opt->name, opt->str); } fprintf(stderr, \"\\n\"); return 0; } ", "target": 0}
{"func": "static int jpeg2000decodetile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile, AVFrame *picture) { int compno, reslevelno, bandno; int x, y; uint8t *line; Jpeg2000T1Context t1; /* Loop on tile components */ for (compno = 0; compno < s->ncomponents; compno++) { Jpeg2000Component *comp = tile->comp + compno; Jpeg2000CodingStyle *codsty = tile->codsty + compno; /* Loop on resolution levels */ for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) { Jpeg2000ResLevel *rlevel = comp->reslevel + reslevelno; /* Loop on bands */ for (bandno = 0; bandno < rlevel->nbands; bandno++) { int nbprecincts, precno; Jpeg2000Band *band = rlevel->band + bandno; int cblkno = 0, bandpos; bandpos = bandno + (reslevelno > 0); if (band->coord[0][0] == band->coord[0][1] || band->coord[1][0] == band->coord[1][1]) continue; nbprecincts = rlevel->numprecinctsx * rlevel->numprecinctsy; /* Loop on precincts */ for (precno = 0; precno < nbprecincts; precno++) { Jpeg2000Prec *prec = band->prec + precno; /* Loop on codeblocks */ for (cblkno = 0; cblkno < prec->nbcodeblockswidth * prec->nbcodeblocksheight; cblkno++) { int x, y; Jpeg2000Cblk *cblk = prec->cblk + cblkno; decodecblk(s, codsty, &t1, cblk, cblk->coord[0][1] - cblk->coord[0][0], cblk->coord[1][1] - cblk->coord[1][0], bandpos); x = cblk->coord[0][0]; y = cblk->coord[1][0]; if (codsty->transform == FFDWT97) dequantizationfloat(x, y, cblk, comp, &t1, band); else dequantizationint(x, y, cblk, comp, &t1, band); } /* end cblk */ } /*end prec */ } /* end band */ } /* end reslevel */ /* inverse DWT */ ffdwtdecode(&comp->dwt, codsty->transform == FFDWT97 ? (void*)comp->fdata : (void*)comp->idata); } /*end comp */ /* inverse MCT transformation */ if (tile->codsty[0].mct) mctdecode(s, tile); if (s->cdef[0] < 0) { for (x = 0; x < s->ncomponents; x++) s->cdef[x] = x + 1; if ((s->ncomponents & 1) == 0) s->cdef[s->ncomponents-1] = 0; } if (s->precision <= 8) { for (compno = 0; compno < s->ncomponents; compno++) { Jpeg2000Component *comp = tile->comp + compno; Jpeg2000CodingStyle *codsty = tile->codsty + compno; float *datap = comp->fdata; int32t *idatap = comp->idata; int cbps = s->cbps[compno]; int w = tile->comp[compno].coord[0][1] - s->imageoffsetx; int planar = !!picture->data[2]; int pixelsize = planar ? 1 : s->ncomponents; int plane = 0; if (planar) plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1); y = tile->comp[compno].coord[1][0] - s->imageoffsety; line = picture->data[plane] + y * picture->linesize[plane]; for (; y < tile->comp[compno].coord[1][1] - s->imageoffsety; y += s->cdy[compno]) { uint8t *dst; x = tile->comp[compno].coord[0][0] - s->imageoffsetx; dst = line + x * pixelsize + compno*!planar; if (codsty->transform == FFDWT97) { for (; x < w; x += s->cdx[compno]) { int val = lrintf(*datap) + (1 << (cbps - 1)); /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */ val = avclip(val, 0, (1 << cbps) - 1); *dst = val << (8 - cbps); datap++; dst += pixelsize; } } else { for (; x < w; x += s->cdx[compno]) { int val = *idatap + (1 << (cbps - 1)); /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */ val = avclip(val, 0, (1 << cbps) - 1); *dst = val << (8 - cbps); idatap++; dst += pixelsize; } } line += picture->linesize[plane]; } } } else { for (compno = 0; compno < s->ncomponents; compno++) { Jpeg2000Component *comp = tile->comp + compno; Jpeg2000CodingStyle *codsty = tile->codsty + compno; float *datap = comp->fdata; int32t *idatap = comp->idata; uint16t *linel; int cbps = s->cbps[compno]; int w = tile->comp[compno].coord[0][1] - s->imageoffsetx; int planar = !!picture->data[2]; int pixelsize = planar ? 1 : s->ncomponents; int plane = 0; if (planar) plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1); y = tile->comp[compno].coord[1][0] - s->imageoffsety; linel = (uint16t *)picture->data[plane] + y * (picture->linesize[plane] >> 1); for (; y < tile->comp[compno].coord[1][1] - s->imageoffsety; y += s->cdy[compno]) { uint16t *dst; x = tile->comp[compno].coord[0][0] - s->imageoffsetx; dst = linel + (x * pixelsize + compno*!planar); if (codsty->transform == FFDWT97) { for (; x < w; x += s-> cdx[compno]) { int val = lrintf(*datap) + (1 << (cbps - 1)); /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */ val = avclip(val, 0, (1 << cbps) - 1); /* align 12 bit values in little-endian mode */ *dst = val << (16 - cbps); datap++; dst += pixelsize; } } else { for (; x < w; x += s-> cdx[compno]) { int val = *idatap + (1 << (cbps - 1)); /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */ val = avclip(val, 0, (1 << cbps) - 1); /* align 12 bit values in little-endian mode */ *dst = val << (16 - cbps); idatap++; dst += pixelsize; } } linel += picture->linesize[plane] >> 1; } } } return 0; } ", "target": 0}
{"func": "void qemurunalltimers(void) { alarmtimer->pending = 0; /* rearm timer, if not periodic */ if (alarmtimer->expired) { alarmtimer->expired = 0; qemurearmalarmtimer(alarmtimer); } /* vm time timers */ qemuruntimers(vmclock); qemuruntimers(rtclock); qemuruntimers(hostclock); } ", "target": 0}
{"func": "static struct XenDevice *xenbegetxendev(const char *type, int dom, int dev, struct XenDevOps *ops) { struct XenDevice *xendev; xendev = xenbefindxendev(type, dom, dev); if (xendev) { return xendev; } /* init new xendev */ xendev = gmalloc0(ops->size); xendev->type = type; xendev->dom = dom; xendev->dev = dev; xendev->ops = ops; snprintf(xendev->be, sizeof(xendev->be), \"backend/%s/%d/%d\", xendev->type, xendev->dom, xendev->dev); snprintf(xendev->name, sizeof(xendev->name), \"%s-%d\", xendev->type, xendev->dev); xendev->debug = debug; xendev->localport = -1; xendev->evtchndev = xenxcevtchnopen(NULL, 0); if (xendev->evtchndev == XCHANDLERINITIALVALUE) { xenbeprintf(NULL, 0, \"can't open evtchn device\\n\"); gfree(xendev); return NULL; } fcntl(xcevtchnfd(xendev->evtchndev), FSETFD, FDCLOEXEC); if (ops->flags & DEVOPSFLAGNEEDGNTDEV) { xendev->gnttabdev = xenxcgnttabopen(NULL, 0); if (xendev->gnttabdev == XCHANDLERINITIALVALUE) { xenbeprintf(NULL, 0, \"can't open gnttab device\\n\"); xcevtchnclose(xendev->evtchndev); gfree(xendev); return NULL; } } else { xendev->gnttabdev = XCHANDLERINITIALVALUE; } QTAILQINSERTTAIL(&xendevs, xendev, next); if (xendev->ops->alloc) { xendev->ops->alloc(xendev); } return xendev; } ", "target": 0}
{"func": "static void jsonmessageprocesstoken(JSONLexer *lexer, QString *token, JSONTokenType type, int x, int y) { JSONMessageParser *parser = containerof(lexer, JSONMessageParser, lexer); QDict *dict; if (type == JSONOPERATOR) { switch (qstringgetstr(token)[0]) { case '{': parser->bracecount++; break; case '}': parser->bracecount--; break; case '[': parser->bracketcount++; break; case ']': parser->bracketcount--; break; default: break; } } dict = qdictnew(); qdictput(dict, \"type\", qintfromint(type)); QINCREF(token); qdictput(dict, \"token\", token); qdictput(dict, \"x\", qintfromint(x)); qdictput(dict, \"y\", qintfromint(y)); parser->tokensize += token->length; qlistappend(parser->tokens, dict); if (type == JSONERROR) { goto outemitbad; } else if (parser->bracecount < 0 || parser->bracketcount < 0 || (parser->bracecount == 0 && parser->bracketcount == 0)) { goto outemit; } else if (parser->tokensize > MAXTOKENSIZE || parser->bracketcount + parser->bracecount > MAXNESTING) { /* Security consideration, we limit total memory allocated per object * and the maximum recursion depth that a message can force. */ goto outemitbad; } return; outemitbad: /* * Clear out token list and tell the parser to emit an error * indication by passing it a NULL list */ QDECREF(parser->tokens); parser->tokens = NULL; outemit: /* send current list of tokens to parser and reset tokenizer */ parser->bracecount = 0; parser->bracketcount = 0; parser->emit(parser, parser->tokens); if (parser->tokens) { QDECREF(parser->tokens); } parser->tokens = qlistnew(); parser->tokensize = 0; } ", "target": 0}
{"func": "static void setmemoryoptions(uint64t *ramslots, ramaddrt *maxramsize) { uint64t sz; const char *memstr; const char *maxmemstr, *slotsstr; const ramaddrt defaultramsize = (ramaddrt)DEFAULTRAMSIZE * 1024 * 1024; QemuOpts *opts = qemufindoptssingleton(\"memory\"); sz = 0; memstr = qemuoptget(opts, \"size\"); if (memstr) { if (!*memstr) { errorreport(\"missing 'size' option value\"); exit(EXITFAILURE); } sz = qemuoptgetsize(opts, \"size\", ramsize); /* Fix up legacy suffix-less format */ if (gasciiisdigit(memstr[strlen(memstr) - 1])) { uint64t overflowcheck = sz; sz <<= 20; if ((sz >> 20) != overflowcheck) { errorreport(\"too large 'size' option value\"); exit(EXITFAILURE); } } } /* backward compatibility behaviour for case \"-m 0\" */ if (sz == 0) { sz = defaultramsize; } sz = QEMUALIGNUP(sz, 8192); ramsize = sz; if (ramsize != sz) { errorreport(\"ram size too large\"); exit(EXITFAILURE); } /* store value for the future use */ qemuoptsetnumber(opts, \"size\", ramsize, &errorabort); *maxramsize = ramsize; maxmemstr = qemuoptget(opts, \"maxmem\"); slotsstr = qemuoptget(opts, \"slots\"); if (maxmemstr && slotsstr) { uint64t slots; sz = qemuoptgetsize(opts, \"maxmem\", 0); slots = qemuoptgetnumber(opts, \"slots\", 0); if (sz < ramsize) { errorreport(\"invalid value of -m option maxmem: \" \"maximum memory size (0x%\" PRIx64 \") must be at least \" \"the initial memory size (0x\" RAMADDRFMT \")\", sz, ramsize); exit(EXITFAILURE); } else if (sz > ramsize) { if (!slots) { errorreport(\"invalid value of -m option: maxmem was \" \"specified, but no hotplug slots were specified\"); exit(EXITFAILURE); } } else if (slots) { errorreport(\"invalid value of -m option maxmem: \" \"memory slots were specified but maximum memory size \" \"(0x%\" PRIx64 \") is equal to the initial memory size \" \"(0x\" RAMADDRFMT \")\", sz, ramsize); exit(EXITFAILURE); } *maxramsize = sz; *ramslots = slots; } else if ((!maxmemstr && slotsstr) || (maxmemstr && !slotsstr)) { errorreport(\"invalid -m option value: missing \" \"'%s' option\", slotsstr ? \"maxmem\" : \"slots\"); exit(EXITFAILURE); } } ", "target": 0}
{"func": "static void iscsirefreshlimits(BlockDriverState *bs, Error **errp) { /* We don't actually refresh here, but just return data queried in * iscsiopen(): iscsi targets don't change their limits. */ IscsiLun *iscsilun = bs->opaque; uint64t maxxferlen = iscsilun->use16forrw ? 0xffffffff : 0xffff; bs->requestalignment = iscsilun->blocksize; if (iscsilun->bl.maxxferlen) { maxxferlen = MIN(maxxferlen, iscsilun->bl.maxxferlen); } if (maxxferlen * iscsilun->blocksize < INTMAX) { bs->bl.maxtransfer = maxxferlen * iscsilun->blocksize; } if (iscsilun->lbp.lbpu) { if (iscsilun->bl.maxunmap < 0xffffffff) { bs->bl.maxdiscard = sectorlimitslun2qemu(iscsilun->bl.maxunmap, iscsilun); } bs->bl.discardalignment = sectorlimitslun2qemu(iscsilun->bl.optunmapgran, iscsilun); } else { bs->bl.discardalignment = iscsilun->blocksize >> BDRVSECTORBITS; } if (iscsilun->bl.maxwslen < 0xffffffff / iscsilun->blocksize) { bs->bl.maxpwritezeroes = iscsilun->bl.maxwslen * iscsilun->blocksize; } if (iscsilun->lbp.lbpws) { bs->bl.pwritezeroesalignment = iscsilun->bl.optunmapgran * iscsilun->blocksize; } else { bs->bl.pwritezeroesalignment = iscsilun->blocksize; } if (iscsilun->bl.optxferlen && iscsilun->bl.optxferlen < INTMAX / iscsilun->blocksize) { bs->bl.opttransfer = pow2floor(iscsilun->bl.optxferlen * iscsilun->blocksize); } } ", "target": 0}
{"func": "static int kvmsetmce(CPUState *env, struct kvmx86mce *m) { return kvmvcpuioctl(env, KVMX86SETMCE, m); } ", "target": 0}
{"func": "void ideatapicmd(IDEState *s) { uint8t *buf; buf = s->iobuffer; #ifdef DEBUGIDEATAPI { int i; printf(\"ATAPI limit=0x%x packet:\", s->lcyl | (s->hcyl << 8)); for(i = 0; i < ATAPIPACKETSIZE; i++) { printf(\" %02x\", buf[i]); } printf(\"\\n\"); } #endif /* * If there's a UNITATTENTION condition pending, only command flagged with * ALLOWUA are allowed to complete. with other commands getting a CHECK * condition response unless a higher priority status, defined by the drive * here, is pending. */ if (s->sensekey == UNITATTENTION && !(atapicmdtable[s->iobuffer[0]].flags & ALLOWUA)) { ideatapicmdcheckstatus(s); return; } /* * When a CD gets changed, we have to report an ejected state and * then a loaded state to guests so that they detect tray * open/close and media change events. Guests that do not use * GETEVENTSTATUSNOTIFICATION to detect such tray open/close * states rely on this behavior. */ if (!(atapicmdtable[s->iobuffer[0]].flags & ALLOWUA) && !s->trayopen && bdrvisinserted(s->bs) && s->cdromchanged) { if (s->cdromchanged == 1) { ideatapicmderror(s, NOTREADY, ASCMEDIUMNOTPRESENT); s->cdromchanged = 2; } else { ideatapicmderror(s, UNITATTENTION, ASCMEDIUMMAYHAVECHANGED); s->cdromchanged = 0; } return; } /* Report a Not Ready condition if appropriate for the command */ if ((atapicmdtable[s->iobuffer[0]].flags & CHECKREADY) && (!mediapresent(s) || !bdrvisinserted(s->bs))) { ideatapicmderror(s, NOTREADY, ASCMEDIUMNOTPRESENT); return; } /* Execute the command */ if (atapicmdtable[s->iobuffer[0]].handler) { atapicmdtable[s->iobuffer[0]].handler(s, buf); return; } ideatapicmderror(s, ILLEGALREQUEST, ASCILLEGALOPCODE); } ", "target": 0}
{"func": "void ffhevclumamvmergemode(HEVCContext *s, int x0, int y0, int nPbW, int nPbH, int log2cbsize, int partidx, int mergeidx, MvField *mv) { int singleMCLFlag = 0; int nCS = 1 << log2cbsize; LOCALALIGNED(4, MvField, mergecandlist, [MRGMAXNUMCANDS]); int nPbW2 = nPbW; int nPbH2 = nPbH; HEVCLocalContext *lc = &s->HEVClc; memset(mergecandlist, 0, MRGMAXNUMCANDS * sizeof(*mergecandlist)); if (s->pps->log2parallelmergelevel > 2 && nCS == 8) { singleMCLFlag = 1; x0 = lc->cu.x; y0 = lc->cu.y; nPbW = nCS; nPbH = nCS; partidx = 0; } ffhevcsetneighbouravailable(s, x0, y0, nPbW, nPbH); derivespatialmergecandidates(s, x0, y0, nPbW, nPbH, log2cbsize, singleMCLFlag, partidx, mergeidx, mergecandlist); if (mergecandlist[mergeidx].predflag[0] == 1 && mergecandlist[mergeidx].predflag[1] == 1 && (nPbW2 + nPbH2) == 12) { mergecandlist[mergeidx].refidx[1] = -1; mergecandlist[mergeidx].predflag[1] = 0; } *mv = mergecandlist[mergeidx]; } ", "target": 1}
{"func": "int s390cpuwriteelf64note(WriteCoreDumpFunction f, CPUState *cs, int cpuid, void *opaque) { S390CPU *cpu = S390CPU(cs); return s390xwriteallelf64notes(\"CORE\", f, cpu, cpuid, opaque); } ", "target": 1}
{"func": "static void encodeclnpass(Jpeg2000T1Context *t1, int width, int height, int bandno, int *nmsedec, int bpno) { int y0, x, y, mask = 1 << (bpno + NMSEDECFRACBITS); for (y0 = 0; y0 < height; y0 += 4) for (x = 0; x < width; x++){ if (y0 + 3 < height && !( (t1->flags[y0+1][x+1] & (JPEG2000T1SIGNB | JPEG2000T1VIS | JPEG2000T1SIG)) || (t1->flags[y0+2][x+1] & (JPEG2000T1SIGNB | JPEG2000T1VIS | JPEG2000T1SIG)) || (t1->flags[y0+3][x+1] & (JPEG2000T1SIGNB | JPEG2000T1VIS | JPEG2000T1SIG)) || (t1->flags[y0+4][x+1] & (JPEG2000T1SIGNB | JPEG2000T1VIS | JPEG2000T1SIG)))) { // aggregation mode int rlen; for (rlen = 0; rlen < 4; rlen++) if (t1->data[y0+rlen][x] & mask) break; ffmqcencode(&t1->mqc, t1->mqc.cxstates + MQCCXRL, rlen != 4); if (rlen == 4) continue; ffmqcencode(&t1->mqc, t1->mqc.cxstates + MQCCXUNI, rlen >> 1); ffmqcencode(&t1->mqc, t1->mqc.cxstates + MQCCXUNI, rlen & 1); for (y = y0 + rlen; y < y0 + 4; y++){ if (!(t1->flags[y+1][x+1] & (JPEG2000T1SIG | JPEG2000T1VIS))){ int ctxno = ffjpeg2000getsigctxno(t1->flags[y+1][x+1], bandno); if (y > y0 + rlen) ffmqcencode(&t1->mqc, t1->mqc.cxstates + ctxno, t1->data[y][x] & mask ? 1:0); if (t1->data[y][x] & mask){ // newly significant int xorbit; int ctxno = ffjpeg2000getsgnctxno(t1->flags[y+1][x+1], &xorbit); *nmsedec += getnmsedecsig(t1->data[y][x], bpno + NMSEDECFRACBITS); ffmqcencode(&t1->mqc, t1->mqc.cxstates + ctxno, (t1->flags[y+1][x+1] >> 15) ^ xorbit); ffjpeg2000setsignificance(t1, x, y, t1->flags[y+1][x+1] >> 15); } } t1->flags[y+1][x+1] &= ~JPEG2000T1VIS; } } else{ for (y = y0; y < y0 + 4 && y < height; y++){ if (!(t1->flags[y+1][x+1] & (JPEG2000T1SIG | JPEG2000T1VIS))){ int ctxno = ffjpeg2000getsigctxno(t1->flags[y+1][x+1], bandno); ffmqcencode(&t1->mqc, t1->mqc.cxstates + ctxno, t1->data[y][x] & mask ? 1:0); if (t1->data[y][x] & mask){ // newly significant int xorbit; int ctxno = ffjpeg2000getsgnctxno(t1->flags[y+1][x+1], &xorbit); *nmsedec += getnmsedecsig(t1->data[y][x], bpno + NMSEDECFRACBITS); ffmqcencode(&t1->mqc, t1->mqc.cxstates + ctxno, (t1->flags[y+1][x+1] >> 15) ^ xorbit); ffjpeg2000setsignificance(t1, x, y, t1->flags[y+1][x+1] >> 15); } } t1->flags[y+1][x+1] &= ~JPEG2000T1VIS; } } } } ", "target": 0}
{"func": "static int ppchash64pteupdateflags(struct mmuctxhash64 *ctx, targetulong *pte1p, int ret, int rw) { int store = 0; /* Update page flags */ if (!(*pte1p & HPTE64RR)) { /* Update accessed flag */ *pte1p |= HPTE64RR; store = 1; } if (!(*pte1p & HPTE64RC)) { if (rw == 1 && ret == 0) { /* Update changed flag */ *pte1p |= HPTE64RC; store = 1; } else { /* Force page fault for first write access */ ctx->prot &= ~PAGEWRITE; } } return store; } ", "target": 0}
{"func": "BlockAIOCB *dmabdrvwrite(BlockDriverState *bs, QEMUSGList *sg, uint64t sector, void (*cb)(void *opaque, int ret), void *opaque) { return dmabdrvio(bs, sg, sector, bdrvaiowritev, cb, opaque, DMADIRECTIONTODEVICE); } ", "target": 0}
{"func": "static int discardsinglel2(BlockDriverState *bs, uint64t offset, unsigned int nbclusters, enum qcow2discardtype type, bool fulldiscard) { BDRVQcow2State *s = bs->opaque; uint64t *l2table; int l2index; int ret; int i; ret = getclustertable(bs, offset, &l2table, &l2index); if (ret < 0) { return ret; } /* Limit nbclusters to one L2 table */ nbclusters = MIN(nbclusters, s->l2size - l2index); for (i = 0; i < nbclusters; i++) { uint64t oldl2entry; oldl2entry = be64tocpu(l2table[l2index + i]); /* * If fulldiscard is false, make sure that a discarded area reads back * as zeroes for v3 images (we cannot do it for v2 without actually * writing a zero-filled buffer). We can skip the operation if the * cluster is already marked as zero, or if it's unallocated and we * don't have a backing file. * * TODO We might want to use bdrvgetblockstatus(bs) here, but we're * holding s->lock, so that doesn't work today. * * If fulldiscard is true, the sector should not read back as zeroes, * but rather fall through to the backing file. */ switch (qcow2getclustertype(oldl2entry)) { case QCOW2CLUSTERUNALLOCATED: if (fulldiscard || !bs->backinghd) { continue; } break; case QCOW2CLUSTERZERO: if (!fulldiscard) { continue; } break; case QCOW2CLUSTERNORMAL: case QCOW2CLUSTERCOMPRESSED: break; default: abort(); } /* First remove L2 entries */ qcow2cacheentrymarkdirty(bs, s->l2tablecache, l2table); if (!fulldiscard && s->qcowversion >= 3) { l2table[l2index + i] = cputobe64(QCOWOFLAGZERO); } else { l2table[l2index + i] = cputobe64(0); } /* Then decrease the refcount */ qcow2freeanyclusters(bs, oldl2entry, 1, type); } qcow2cacheput(bs, s->l2tablecache, (void **) &l2table); return nbclusters; } ", "target": 0}
{"func": "static int64t qemuarchipelagogetlength(BlockDriverState *bs) { int64t ret; BDRVArchipelagoState *s = bs->opaque; ret = archipelagovolumeinfo(s); return ret; } ", "target": 0}
{"func": "static void rtasibmseteehoption(PowerPCCPU *cpu, sPAPRMachineState *spapr, uint32t token, uint32t nargs, targetulong args, uint32t nret, targetulong rets) { sPAPRPHBState *sphb; sPAPRPHBClass *spc; PCIDevice *pdev; uint32t addr, option; uint64t buid; int ret; if ((nargs != 4) || (nret != 1)) { goto paramerrorexit; } buid = rtasldq(args, 1); addr = rtasld(args, 0); option = rtasld(args, 3); sphb = spaprpcifindphb(spapr, buid); if (!sphb) { goto paramerrorexit; } pdev = pcifinddevice(PCIHOSTBRIDGE(sphb)->bus, (addr >> 16) & 0xFF, (addr >> 8) & 0xFF); if (!pdev || !objectdynamiccast(OBJECT(pdev), \"vfio-pci\")) { goto paramerrorexit; } spc = SPAPRPCIHOSTBRIDGEGETCLASS(sphb); if (!spc->eehsetoption) { goto paramerrorexit; } ret = spc->eehsetoption(sphb, addr, option); rtasst(rets, 0, ret); return; paramerrorexit: rtasst(rets, 0, RTASOUTPARAMERROR); } ", "target": 0}
{"func": "int qemuaclremove(qemuacl *acl, const char *match) { qemuaclentry *entry; int i = 0; TAILQFOREACH(entry, &acl->entries, next) { i++; if (strcmp(entry->match, match) == 0) { TAILQREMOVE(&acl->entries, entry, next); return i; } } return -1; } ", "target": 0}
{"func": "static void ac97initfn (PCIDevice *dev) { PCIAC97LinkState *d = DOUPCAST (PCIAC97LinkState, dev, dev); AC97LinkState *s = &d->ac97; uint8t *c = d->dev.config; s->pcidev = &d->dev; pciconfigsetvendorid (c, PCIVENDORIDINTEL); /* ro */ pciconfigsetdeviceid (c, PCIDEVICEIDINTEL82801AA5); /* ro */ c[0x04] = 0x00; /* pcicmd pci command rw, ro */ c[0x05] = 0x00; c[0x06] = 0x80; /* pcists pci status rwc, ro */ c[0x07] = 0x02; c[0x08] = 0x01; /* rid revision ro */ c[0x09] = 0x00; /* pi programming interface ro */ pciconfigsetclass (c, PCICLASSMULTIMEDIAAUDIO); /* ro */ c[PCIHEADERTYPE] = PCIHEADERTYPENORMAL; /* headtyp header type ro */ c[0x10] = 0x01; /* nabmar native audio mixer base address rw */ c[0x11] = 0x00; c[0x12] = 0x00; c[0x13] = 0x00; c[0x14] = 0x01; /* nabmbar native audio bus mastering base address rw */ c[0x15] = 0x00; c[0x16] = 0x00; c[0x17] = 0x00; c[0x2c] = 0x86; /* svid subsystem vendor id rwo */ c[0x2d] = 0x80; c[0x2e] = 0x00; /* sid subsystem id rwo */ c[0x2f] = 0x00; c[0x3c] = 0x00; /* intrln interrupt line rw */ c[0x3d] = 0x01; /* intrpn interrupt pin ro */ pciregisterbar (&d->dev, 0, 256 * 4, PCIADDRESSSPACEIO, ac97map); pciregisterbar (&d->dev, 1, 64 * 4, PCIADDRESSSPACEIO, ac97map); registersavevm (\"ac97\", 0, 2, ac97save, ac97load, s); qemuregisterreset (ac97onreset, s); AUDregistercard (\"ac97\", &s->card); ac97onreset (s); } ", "target": 0}
{"func": "static int cookparse(AVCodecParserContext *s1, AVCodecContext *avctx, const uint8t **poutbuf, int *poutbufsize, const uint8t *buf, int bufsize) { CookParseContext *s = s1->privdata; if (s->duration) s1->duration = s->duration; else if (avctx->extradata && avctx->extradatasize >= 8 && avctx->channels) s->duration = AVRB16(avctx->extradata + 4) / avctx->channels; /* always return the full packet. this parser isn't doing any splitting or combining, only setting packet duration */ *poutbuf = buf; *poutbufsize = bufsize; return bufsize; } ", "target": 0}
{"func": "static void addcodec(FFServerStream *stream, AVCodecContext *av, FFServerConfig *config) { AVStream *st; AVDictionary **opts, *recommended = NULL; char *encconfig; if(stream->nbstreams >= FFARRAYELEMS(stream->streams)) return; opts = av->codectype == AVMEDIATYPEAUDIO ? &config->audioopts : &config->videoopts; avdictcopy(&recommended, *opts, 0); avoptsetdict2(av->privdata, opts, AVOPTSEARCHCHILDREN); avoptsetdict2(av, opts, AVOPTSEARCHCHILDREN); if (avdictcount(*opts)) avlog(NULL, AVLOGWARNING, \"Something is wrong, %d options are not set!\\n\", avdictcount(*opts)); if (config->streamusedefaults) { //TODO: reident /* compute default parameters */ switch(av->codectype) { case AVMEDIATYPEAUDIO: if (av->bitrate == 0) { av->bitrate = 64000; avdictsetint(&recommended, \"ab\", av->bitrate, 0); } if (av->samplerate == 0) { av->samplerate = 22050; avdictsetint(&recommended, \"ar\", av->samplerate, 0); } if (av->channels == 0) { av->channels = 1; avdictsetint(&recommended, \"ac\", av->channels, 0); } break; case AVMEDIATYPEVIDEO: if (av->bitrate == 0) { av->bitrate = 64000; avdictsetint(&recommended, \"b\", av->bitrate, 0); } if (av->timebase.num == 0){ av->timebase.den = 5; av->timebase.num = 1; avdictset(&recommended, \"timebase\", \"1/5\", 0); } if (av->width == 0 || av->height == 0) { av->width = 160; av->height = 128; avdictset(&recommended, \"videosize\", \"160x128\", 0); } /* Bitrate tolerance is less for streaming */ if (av->bitratetolerance == 0) { av->bitratetolerance = FFMAX(av->bitrate / 4, (int64t)av->bitrate*av->timebase.num/av->timebase.den); avdictsetint(&recommended, \"bt\", av->bitratetolerance, 0); } if (!av->rceq) { av->rceq = avstrdup(\"tex^qComp\"); avdictset(&recommended, \"rceq\", \"tex^qComp\", 0); } if (!av->rcmaxrate) { av->rcmaxrate = av->bitrate * 2; avdictsetint(&recommended, \"maxrate\", av->rcmaxrate, 0); } if (av->rcmaxrate && !av->rcbuffersize) { av->rcbuffersize = av->rcmaxrate; avdictsetint(&recommended, \"bufsize\", av->rcbuffersize, 0); } break; default: abort(); } } else { switch(av->codectype) { case AVMEDIATYPEAUDIO: if (av->bitrate == 0) reportconfigerror(config->filename, config->linenum, AVLOGERROR, &config->errors, \"audio bit rate is not set\\n\"); if (av->samplerate == 0) reportconfigerror(config->filename, config->linenum, AVLOGERROR, &config->errors, \"audio sample rate is not set\\n\"); break; case AVMEDIATYPEVIDEO: if (av->width == 0 || av->height == 0) reportconfigerror(config->filename, config->linenum, AVLOGERROR, &config->errors, \"video size is not set\\n\"); break; default: avassert0(0); } } st = avmallocz(sizeof(AVStream)); if (!st) return; avdictgetstring(recommended, &encconfig, '=', ','); avdictfree(&recommended); avstreamsetrecommendedencoderconfiguration(st, encconfig); st->codec = av; stream->streams[stream->nbstreams++] = st; } ", "target": 0}
{"func": "static void qmpoutputendstruct(Visitor *v, Error **errp) { QmpOutputVisitor *qov = toqov(v); QObject *value = qmpoutputpop(qov); assert(qobjecttype(value) == QTYPEQDICT); } ", "target": 1}
{"func": "void computeimagesmse16bit(PSNRContext *s, const uint8t *maindata[4], const int mainlinesizes[4], const uint8t *refdata[4], const int reflinesizes[4], int w, int h, double mse[4]) { int i, c, j; for (c = 0; c < s->nbcomponents; c++) { const int outw = s->planewidth[c]; const int outh = s->planeheight[c]; const uint16t *mainline = (uint16t *)maindata[c]; const uint16t *refline = (uint16t *)refdata[c]; const int reflinesize = reflinesizes[c] / 2; const int mainlinesize = mainlinesizes[c] / 2; uint64t m = 0; for (i = 0; i < outh; i++) { for (j = 0; j < outw; j++) m += pow2(mainline[j] - refline[j]); refline += reflinesize; mainline += mainlinesize; } mse[c] = m / (double)(outw * outh); } } ", "target": 1}
{"func": "putsum(uint8t *data, uint32t n, uint32t sloc, uint32t css, uint32t cse) { uint32t sum; if (cse && cse < n) n = cse + 1; if (sloc < n-1) { sum = netchecksumadd(n-css, data+css); stwbep(data + sloc, netchecksumfinish(sum)); } } ", "target": 1}
{"func": "uint32t HELPER(clcle)(CPUS390XState *env, uint32t r1, uint64t a2, uint32t r3) { uintptrt ra = GETPC(); uint64t destlen = getlength(env, r1 + 1); uint64t dest = getaddress(env, r1); uint64t srclen = getlength(env, r3 + 1); uint64t src = getaddress(env, r3); uint8t pad = a2 & 0xff; uint32t cc = 0; if (!(destlen || srclen)) { return cc; } if (srclen > destlen) { srclen = destlen; } for (; destlen || srclen; src++, dest++, destlen--, srclen--) { uint8t v1 = srclen ? cpuldubdatara(env, src, ra) : pad; uint8t v2 = destlen ? cpuldubdatara(env, dest, ra) : pad; if (v1 != v2) { cc = (v1 < v2) ? 1 : 2; break; } } setlength(env, r1 + 1, destlen); /* can't use srclen here, we trunc'ed it */ setlength(env, r3 + 1, env->regs[r3 + 1] - src - env->regs[r3]); setaddress(env, r1, dest); setaddress(env, r3, src); return cc; } ", "target": 0}
{"func": "void *bioslinkerloadercleanup(GArray *linker) { return garrayfree(linker, false); } ", "target": 0}
{"func": "const ppchashpte64t *ppchash64maphptes(PowerPCCPU *cpu, hwaddr ptex, int n) { ppchashpte64t *hptes = NULL; hwaddr pteoffset = ptex * HASHPTESIZE64; if (cpu->env.externalhtab == MMUHASH64KVMMANAGEDHPT) { /* * HTAB is controlled by KVM. Fetch into temporary buffer */ hptes = gmalloc(HASHPTEGSIZE64); kvmppcreadhptes(hptes, ptex, n); } else if (cpu->env.externalhtab) { /* * HTAB is controlled by QEMU. Just point to the internally * accessible PTEG. */ hptes = (ppchashpte64t *)(cpu->env.externalhtab + pteoffset); } else if (cpu->env.htabbase) { hwaddr plen = n * HASHPTESIZE64; hptes = addressspacemap(CPU(cpu)->as, cpu->env.htabbase + pteoffset, &plen, false); if (plen < (n * HASHPTESIZE64)) { hwerror(\"%s: Unable to map all requested HPTEs\\n\", func); } } return hptes; } ", "target": 0}
{"func": "static inline bool regimetranslationdisabled(CPUARMState *env, ARMMMUIdx mmuidx) { if (armfeature(env, ARMFEATUREM)) { switch (env->v7m.mpuctrl & (RV7MMPUCTRLENABLEMASK | RV7MMPUCTRLHFNMIENAMASK)) { case RV7MMPUCTRLENABLEMASK: /* Enabled, but not for HardFault and NMI */ return mmuidx == ARMMMUIdxMNegPri || mmuidx == ARMMMUIdxMSNegPri; case RV7MMPUCTRLENABLEMASK | RV7MMPUCTRLHFNMIENAMASK: /* Enabled for all cases */ return false; case 0: default: /* HFNMIENA set and ENABLE clear is UNPREDICTABLE, but * we warned about that in armv7mnvic.c when the guest set it. */ return true; } } if (mmuidx == ARMMMUIdxS2NS) { return (env->cp15.hcrel2 & HCRVM) == 0; } return (regimesctlr(env, mmuidx) & SCTLRM) == 0; } ", "target": 0}
{"func": "static void buildprocessordevices(Aml *sbscope, unsigned acpicpus, AcpiCpuInfo *cpu, AcpiPmInfo *pm) { int i; Aml *dev; Aml *crs; Aml *pkg; Aml *field; Aml *ifctx; Aml *method; /* The current AML generator can cover the APIC ID range [0..255], * inclusive, for VCPU hotplug. */ QEMUBUILDBUGON(ACPICPUHOTPLUGIDLIMIT > 256); gassert(acpicpus <= ACPICPUHOTPLUGIDLIMIT); /* create PCI0.PRES device and its CRS to reserve CPU hotplug MMIO */ dev = amldevice(\"PCI0.\" stringify(CPUHOTPLUGRESOURCEDEVICE)); amlappend(dev, amlnamedecl(\"HID\", amleisaid(\"PNP0A06\"))); amlappend(dev, amlnamedecl(\"UID\", amlstring(\"CPU Hotplug resources\")) ); /* device present, functioning, decoding, not shown in UI */ amlappend(dev, amlnamedecl(\"STA\", amlint(0xB))); crs = amlresourcetemplate(); amlappend(crs, amlio(AMLDECODE16, pm->cpuhpiobase, pm->cpuhpiobase, 1, pm->cpuhpiolen) ); amlappend(dev, amlnamedecl(\"CRS\", crs)); amlappend(sbscope, dev); /* declare CPU hotplug MMIO region and PRS field to access it */ amlappend(sbscope, amloperationregion( \"PRST\", AMLSYSTEMIO, amlint(pm->cpuhpiobase), pm->cpuhpiolen)); field = amlfield(\"PRST\", AMLBYTEACC, AMLNOLOCK, AMLPRESERVE); amlappend(field, amlnamedfield(\"PRS\", 256)); amlappend(sbscope, field); /* build Processor object for each processor */ for (i = 0; i < acpicpus; i++) { dev = amlprocessor(i, 0, 0, \"CP%.02X\", i); method = amlmethod(\"MAT\", 0, AMLNOTSERIALIZED); amlappend(method, amlreturn(amlcall1(CPUMATMETHOD, amlint(i)))); amlappend(dev, method); method = amlmethod(\"STA\", 0, AMLNOTSERIALIZED); amlappend(method, amlreturn(amlcall1(CPUSTATUSMETHOD, amlint(i)))); amlappend(dev, method); method = amlmethod(\"EJ0\", 1, AMLNOTSERIALIZED); amlappend(method, amlreturn(amlcall2(CPUEJECTMETHOD, amlint(i), amlarg(0))) ); amlappend(dev, method); amlappend(sbscope, dev); } /* build this code: * Method(NTFY, 2) {If (LEqual(Arg0, 0x00)) {Notify(CP00, Arg1)} ...} */ /* Arg0 = Processor ID = APIC ID */ method = amlmethod(AMLNOTIFYMETHOD, 2, AMLNOTSERIALIZED); for (i = 0; i < acpicpus; i++) { ifctx = amlif(amlequal(amlarg(0), amlint(i))); amlappend(ifctx, amlnotify(amlname(\"CP%.02X\", i), amlarg(1)) ); amlappend(method, ifctx); } amlappend(sbscope, method); /* build \"Name(CPON, Package() { One, One, ..., Zero, Zero, ... })\" * * Note: The ability to create variable-sized packages was first * introduced in ACPI 2.0. ACPI 1.0 only allowed fixed-size packages * ith up to 255 elements. Windows guests up to win2k8 fail when * VarPackageOp is used. */ pkg = acpicpus <= 255 ? amlpackage(acpicpus) : amlvarpackage(acpicpus); for (i = 0; i < acpicpus; i++) { uint8t b = testbit(i, cpu->foundcpus) ? 0x01 : 0x00; amlappend(pkg, amlint(b)); } amlappend(sbscope, amlnamedecl(CPUONBITMAP, pkg)); } ", "target": 0}
{"func": "e1000mmioread(void *opaque, targetphysaddrt addr, unsigned size) { E1000State *s = opaque; unsigned int index = (addr & 0x1ffff) >> 2; if (index < NREADOPS && macregreadops[index]) { return macregreadops[index](s, index); } DBGOUT(UNKNOWN, \"MMIO unknown read addr=0x%08x\\n\", index<<2); return 0; } ", "target": 0}
{"func": "static void ccidonapdufromguest(USBCCIDState *s, CCIDXferBlock *recv) { uint32t len; if (ccidcardstatus(s) != ICCSTATUSPRESENTACTIVE) { DPRINTF(s, 1, \"usb-ccid: not sending apdu to client, no card connected\\n\"); ccidwritedatablockerror(s, recv->hdr.bSlot, recv->hdr.bSeq); return; } len = le32tocpu(recv->hdr.dwLength); DPRINTF(s, 1, \"%s: seq %d, len %d\\n\", func, recv->hdr.bSeq, len); ccidaddpendinganswer(s, (CCIDHeader *)recv); if (s->card) { ccidcardapdufromguest(s->card, recv->abData, len); } else { DPRINTF(s, DWARN, \"warning: discarded apdu\\n\"); } } ", "target": 1}
{"func": "void ffh264predinitx86(H264PredContext *h, int codecid) { mmflags = mmsupport(); #if HAVEYASM if (mmflags & FFMMMMX) { h->pred16x16[VERTPRED8x8] = ffpred16x16verticalmmx; h->pred16x16[HORPRED8x8 ] = ffpred16x16horizontalmmx; h->pred8x8 [VERTPRED8x8] = ffpred8x8verticalmmx; h->pred8x8 [HORPRED8x8 ] = ffpred8x8horizontalmmx; if (codecid == CODECIDVP8) { h->pred16x16[PLANEPRED8x8] = ffpred16x16tmvp8mmx; h->pred8x8 [PLANEPRED8x8] = ffpred8x8tmvp8mmx; h->pred4x4 [TMVP8PRED ] = ffpred4x4tmvp8mmx; } } if (mmflags & FFMMMMX2) { h->pred16x16[HORPRED8x8 ] = ffpred16x16horizontalmmxext; h->pred16x16[DCPRED8x8 ] = ffpred16x16dcmmxext; h->pred8x8 [HORPRED8x8 ] = ffpred8x8horizontalmmxext; h->pred4x4 [DCPRED ] = ffpred4x4dcmmxext; if (codecid == CODECIDVP8) { h->pred16x16[PLANEPRED8x8] = ffpred16x16tmvp8mmxext; h->pred8x8 [DCPRED8x8 ] = ffpred8x8dcrv40mmxext; h->pred8x8 [PLANEPRED8x8] = ffpred8x8tmvp8mmxext; h->pred4x4 [TMVP8PRED ] = ffpred4x4tmvp8mmxext; h->pred4x4 [VERTPRED ] = ffpred4x4verticalvp8mmxext; } } if (mmflags & FFMMSSE) { h->pred16x16[VERTPRED8x8] = ffpred16x16verticalsse; h->pred16x16[DCPRED8x8 ] = ffpred16x16dcsse; } if (mmflags & FFMMSSE2) { h->pred16x16[DCPRED8x8 ] = ffpred16x16dcsse2; if (codecid == CODECIDVP8) { h->pred16x16[PLANEPRED8x8] = ffpred16x16tmvp8sse2; h->pred8x8 [PLANEPRED8x8] = ffpred8x8tmvp8sse2; } } if (mmflags & FFMMSSSE3) { h->pred16x16[HORPRED8x8 ] = ffpred16x16horizontalssse3; h->pred16x16[DCPRED8x8 ] = ffpred16x16dcssse3; h->pred8x8 [HORPRED8x8 ] = ffpred8x8horizontalssse3; if (codecid == CODECIDVP8) { h->pred8x8 [PLANEPRED8x8] = ffpred8x8tmvp8ssse3; h->pred4x4 [TMVP8PRED ] = ffpred4x4tmvp8ssse3; } } #endif } ", "target": 0}
{"func": "static inline abilong targettohosttimespec(struct timespec *hostts, abiulong targetaddr) { struct targettimespec *targetts; if (!lockuserstruct(VERIFYREAD, targetts, targetaddr, 1)) return -TARGETEFAULT; hostts->tvsec = tswapal(targetts->tvsec); hostts->tvnsec = tswapal(targetts->tvnsec); unlockuserstruct(targetts, targetaddr, 0); return 0; } ", "target": 1}
{"func": "void DMAinit(int highpageenable, qemuirq *cpurequestexit) { } ", "target": 0}
{"func": "static void decodedeltal(uint8t *dst, const uint8t *buf, const uint8t *bufend, int w, int flag, int bpp, int dstsize) { GetByteContext off0, off1, dgb, ogb; PutByteContext pb; unsigned poff0, poff1; int i, k, dstpitch; int planepitchbyte = (w + 7) / 8; int planepitch = ((w + 15) / 16) * 2; int pitch = planepitch * bpp; if (bufend - buf <= 64) return; bytestream2init(&off0, buf, bufend - buf); bytestream2init(&off1, buf + 32, bufend - (buf + 32)); bytestream2initwriter(&pb, dst, dstsize); dstpitch = flag ? (((w + 7) / 8) * bpp): 2; for (k = 0; k < bpp; k++) { poff0 = bytestream2getbe32(&off0); poff1 = bytestream2getbe32(&off1); if (!poff0) continue; if (2LL * poff0 >= bufend - buf) return; if (2LL * poff1 >= bufend - buf) return; bytestream2init(&dgb, buf + 2 * poff0, bufend - (buf + 2 * poff0)); bytestream2init(&ogb, buf + 2 * poff1, bufend - (buf + 2 * poff1)); while ((bytestream2peekbe16(&ogb)) != 0xFFFF) { uint32t offset = bytestream2getbe16(&ogb); int16t cnt = bytestream2getbe16(&ogb); uint16t data; offset = ((2 * offset) / planepitchbyte) * pitch + ((2 * offset) % planepitchbyte) + k * planepitch; if (cnt < 0) { bytestream2seekp(&pb, offset, SEEKSET); cnt = -cnt; data = bytestream2getbe16(&dgb); for (i = 0; i < cnt; i++) { bytestream2putbe16(&pb, data); bytestream2skipp(&pb, dstpitch - 2); } } else { bytestream2seekp(&pb, offset, SEEKSET); for (i = 0; i < cnt; i++) { data = bytestream2getbe16(&dgb); bytestream2putbe16(&pb, data); bytestream2skipp(&pb, dstpitch - 2); } } } } } ", "target": 0}
{"func": "static void intelhdammiowriteb(void *opaque, targetphysaddrt addr, uint32t val) { IntelHDAState *d = opaque; const IntelHDAReg *reg = intelhdaregfind(d, addr); intelhdaregwrite(d, reg, val, 0xff); } ", "target": 0}
{"func": "void serialrealizecore(SerialState *s, Error **errp) { if (!qemuchrfebackendconnected(&s->chr)) { errorsetg(errp, \"Can't create serial device, empty char device\"); return; } s->modemstatuspoll = timernewns(QEMUCLOCKVIRTUAL, (QEMUTimerCB *) serialupdatemsl, s); s->fifotimeouttimer = timernewns(QEMUCLOCKVIRTUAL, (QEMUTimerCB *) fifotimeoutint, s); qemuregisterreset(serialreset, s); qemuchrfesethandlers(&s->chr, serialcanreceive1, serialreceive1, serialevent, NULL, s, NULL, true); fifo8create(&s->recvfifo, UARTFIFOLENGTH); fifo8create(&s->xmitfifo, UARTFIFOLENGTH); serialreset(s); } ", "target": 0}
{"func": "static int getphysicaladdress(CPUPPCState *env, mmuctxt *ctx, targetulong eaddr, int rw, int accesstype) { int ret; #if 0 qemulog(\"%s\\n\", func); #endif if ((accesstype == ACCESSCODE && msrir == 0) || (accesstype != ACCESSCODE && msrdr == 0)) { if (env->mmumodel == POWERPCMMUBOOKE) { /* The BookE MMU always performs address translation. The IS and DS bits only affect the address space. */ ret = mmubookegetphysicaladdress(env, ctx, eaddr, rw, accesstype); } else if (env->mmumodel == POWERPCMMUBOOKE206) { ret = mmubooke206getphysicaladdress(env, ctx, eaddr, rw, accesstype); } else { /* No address translation. */ ret = checkphysical(env, ctx, eaddr, rw); } } else { ret = -1; switch (env->mmumodel) { case POWERPCMMU32B: case POWERPCMMU601: /* Try to find a BAT */ if (env->nbBATs != 0) { ret = getbat(env, ctx, eaddr, rw, accesstype); } if (ret < 0) { /* We didn't match any BAT entry or don't have BATs */ ret = getsegment32(env, ctx, eaddr, rw, accesstype); } break; case POWERPCMMUSOFT6xx: case POWERPCMMUSOFT74xx: /* Try to find a BAT */ if (env->nbBATs != 0) { ret = getbat(env, ctx, eaddr, rw, accesstype); } if (ret < 0) { /* We didn't match any BAT entry or don't have BATs */ ret = getsegment6xxtlb(env, ctx, eaddr, rw, accesstype); } break; #if defined(TARGETPPC64) case POWERPCMMU64B: case POWERPCMMU206: case POWERPCMMU206d: ret = getsegment64(env, ctx, eaddr, rw, accesstype); break; #endif case POWERPCMMUSOFT4xx: case POWERPCMMUSOFT4xxZ: ret = mmu40xgetphysicaladdress(env, ctx, eaddr, rw, accesstype); break; case POWERPCMMUBOOKE: ret = mmubookegetphysicaladdress(env, ctx, eaddr, rw, accesstype); break; case POWERPCMMUBOOKE206: ret = mmubooke206getphysicaladdress(env, ctx, eaddr, rw, accesstype); break; case POWERPCMMUMPC8xx: /* XXX: TODO */ cpuabort(env, \"MPC8xx MMU model is not implemented\\n\"); break; case POWERPCMMUREAL: cpuabort(env, \"PowerPC in real mode do not do any translation\\n\"); return -1; default: cpuabort(env, \"Unknown or invalid MMU model\\n\"); return -1; } } #if 0 qemulog(\"%s address \" TARGETFMTlx \" => %d \" TARGETFMTplx \"\\n\", func, eaddr, ret, ctx->raddr); #endif return ret; } ", "target": 0}
{"func": "static uint8t eeprom24c0xread(void) { logout(\"%u: scl = %u, sda = %u, data = 0x%02x\\n\", eeprom.tick, eeprom.scl, eeprom.sda, eeprom.data); return eeprom.sda; } ", "target": 0}
{"func": "static void blockdevdoaction(int kind, void *data, Error **errp) { TransactionAction action; TransactionActionList list; action.kind = kind; action.data = data; list.value = &action; list.next = NULL; qmptransaction(&list, errp); } ", "target": 0}
{"func": "static void h263hloopfiltermmx(uint8t *src, int stride, int qscale) { if (CONFIGH263DECODER || CONFIGH263ENCODER) { const int strength = ffh263loopfilterstrength[qscale]; DECLAREALIGNED(8, uint64t, temp)[4]; uint8t *btemp = (uint8t*)temp; src -= 2; transpose4x4(btemp, src, 8, stride); transpose4x4(btemp + 4, src + 4 * stride, 8, stride); asm volatile ( H263LOOPFILTER // 5 3 4 6 : \"+m\"(temp[0]), \"+m\"(temp[1]), \"+m\"(temp[2]), \"+m\"(temp[3]) : \"g\"(2 * strength), \"m\"(ffpbFC) ); asm volatile ( \"movq %%mm5, %%mm1 \\n\\t\" \"movq %%mm4, %%mm0 \\n\\t\" \"punpcklbw %%mm3, %%mm5 \\n\\t\" \"punpcklbw %%mm6, %%mm4 \\n\\t\" \"punpckhbw %%mm3, %%mm1 \\n\\t\" \"punpckhbw %%mm6, %%mm0 \\n\\t\" \"movq %%mm5, %%mm3 \\n\\t\" \"movq %%mm1, %%mm6 \\n\\t\" \"punpcklwd %%mm4, %%mm5 \\n\\t\" \"punpcklwd %%mm0, %%mm1 \\n\\t\" \"punpckhwd %%mm4, %%mm3 \\n\\t\" \"punpckhwd %%mm0, %%mm6 \\n\\t\" \"movd %%mm5, (%0) \\n\\t\" \"punpckhdq %%mm5, %%mm5 \\n\\t\" \"movd %%mm5, (%0, %2) \\n\\t\" \"movd %%mm3, (%0, %2, 2) \\n\\t\" \"punpckhdq %%mm3, %%mm3 \\n\\t\" \"movd %%mm3, (%0, %3) \\n\\t\" \"movd %%mm1, (%1) \\n\\t\" \"punpckhdq %%mm1, %%mm1 \\n\\t\" \"movd %%mm1, (%1, %2) \\n\\t\" \"movd %%mm6, (%1, %2, 2) \\n\\t\" \"punpckhdq %%mm6, %%mm6 \\n\\t\" \"movd %%mm6, (%1, %3) \\n\\t\" :: \"r\"(src), \"r\"(src + 4 * stride), \"r\"((x86reg)stride), \"r\"((x86reg)(3 * stride)) ); } } ", "target": 0}
{"func": "static void bootpreply(struct bootpt *bp) { BOOTPClient *bc; struct mbuf *m; struct bootpt *rbp; struct sockaddrin saddr, daddr; struct inaddr dnsaddr; int dhcpmsgtype, val; uint8t *q; /* extract exact DHCP msg type */ dhcpdecode(bp->bpvend, DHCPOPTLEN, &dhcpmsgtype); dprintf(\"bootp packet op=%d msgtype=%d\\n\", bp->bpop, dhcpmsgtype); if (dhcpmsgtype == 0) dhcpmsgtype = DHCPREQUEST; /* Force reply for old BOOTP clients */ if (dhcpmsgtype != DHCPDISCOVER && dhcpmsgtype != DHCPREQUEST) return; /* XXX: this is a hack to get the client mac address */ memcpy(clientethaddr, bp->bphwaddr, 6); if ((m = mget()) == NULL) return; m->mdata += IFMAXLINKHDR; rbp = (struct bootpt *)m->mdata; m->mdata += sizeof(struct udpiphdr); memset(rbp, 0, sizeof(struct bootpt)); if (dhcpmsgtype == DHCPDISCOVER) { newaddr: bc = getnewaddr(&daddr.sinaddr); if (!bc) { dprintf(\"no address left\\n\"); return; } memcpy(bc->macaddr, clientethaddr, 6); } else { bc = findaddr(&daddr.sinaddr, bp->bphwaddr); if (!bc) { /* if never assigned, behaves as if it was already assigned (windows fix because it remembers its address) */ goto newaddr; } } if (bootpfilename) snprintf((char *)rbp->bpfile, sizeof(rbp->bpfile), \"%s\", bootpfilename); dprintf(\"offered addr=%08x\\n\", ntohl(daddr.sinaddr.saddr)); saddr.sinaddr.saddr = htonl(ntohl(specialaddr.saddr) | CTLALIAS); saddr.sinport = htons(BOOTPSERVER); daddr.sinport = htons(BOOTPCLIENT); rbp->bpop = BOOTPREPLY; rbp->bpxid = bp->bpxid; rbp->bphtype = 1; rbp->bphlen = 6; memcpy(rbp->bphwaddr, bp->bphwaddr, 6); rbp->bpyiaddr = daddr.sinaddr; /* Client IP address */ rbp->bpsiaddr = saddr.sinaddr; /* Server IP address */ daddr.sinaddr.saddr = 0xffffffffu; q = rbp->bpvend; memcpy(q, rfc1533cookie, 4); q += 4; if (dhcpmsgtype == DHCPDISCOVER) { *q++ = RFC2132MSGTYPE; *q++ = 1; *q++ = DHCPOFFER; } else if (dhcpmsgtype == DHCPREQUEST) { *q++ = RFC2132MSGTYPE; *q++ = 1; *q++ = DHCPACK; } if (dhcpmsgtype == DHCPDISCOVER || dhcpmsgtype == DHCPREQUEST) { *q++ = RFC2132SRVID; *q++ = 4; memcpy(q, &saddr.sinaddr, 4); q += 4; *q++ = RFC1533NETMASK; *q++ = 4; *q++ = 0xff; *q++ = 0xff; *q++ = 0xff; *q++ = 0x00; if (!slirprestrict) { *q++ = RFC1533GATEWAY; *q++ = 4; memcpy(q, &saddr.sinaddr, 4); q += 4; *q++ = RFC1533DNS; *q++ = 4; dnsaddr.saddr = htonl(ntohl(specialaddr.saddr) | CTLDNS); memcpy(q, &dnsaddr, 4); q += 4; } *q++ = RFC2132LEASETIME; *q++ = 4; val = htonl(LEASETIME); memcpy(q, &val, 4); q += 4; if (*slirphostname) { val = strlen(slirphostname); *q++ = RFC1533HOSTNAME; *q++ = val; memcpy(q, slirphostname, val); q += val; } } *q++ = RFC1533END; m->mlen = sizeof(struct bootpt) - sizeof(struct ip) - sizeof(struct udphdr); udpoutput2(NULL, m, &saddr, &daddr, IPTOSLOWDELAY); } ", "target": 0}
{"func": "static uint32t drcisolatephysical(sPAPRDRConnector *drc) { switch (drc->state) { case SPAPRDRCSTATEPHYSICALPOWERON: return RTASOUTSUCCESS; /* Nothing to do */ case SPAPRDRCSTATEPHYSICALCONFIGURED: break; /* see below */ case SPAPRDRCSTATEPHYSICALUNISOLATE: return RTASOUTPARAMERROR; /* not allowed */ default: gassertnotreached(); } /* if the guest is configuring a device attached to this DRC, we * should reset the configuration state at this point since it may * no longer be reliable (guest released device and needs to start * over, or unplug occurred so the FDT is no longer valid) */ gfree(drc->ccs); drc->ccs = NULL; drc->state = SPAPRDRCSTATEPHYSICALPOWERON; if (drc->unplugrequested) { uint32t drcindex = spaprdrcindex(drc); tracespaprdrcsetisolationstatefinalizing(drcindex); spaprdrcdetach(drc); } return RTASOUTSUCCESS; } ", "target": 0}
{"func": "static void inputlinuxeventmouse(void *opaque) { InputLinux *il = opaque; struct inputevent event; int rc; for (;;) { rc = read(il->fd, &event, sizeof(event)); if (rc != sizeof(event)) { if (rc < 0 && errno != EAGAIN) { fprintf(stderr, \"%s: read: %s\\n\", func, strerror(errno)); qemusetfdhandler(il->fd, NULL, NULL, NULL); close(il->fd); } break; } inputlinuxhandlemouse(il, &event); } } ", "target": 0}
{"func": "int float64eq( float64 a, float64 b STATUSPARAM ) { if ( ( ( extractFloat64Exp( a ) == 0x7FF ) && extractFloat64Frac( a ) ) || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) ) ) { if ( float64issignalingnan( a ) || float64issignalingnan( b ) ) { floatraise( floatflaginvalid STATUSVAR); } return 0; } return ( a == b ) || ( (bits64) ( ( a | b )<<1 ) == 0 ); } ", "target": 0}
{"func": "static alwaysinline void gencmp(TCGCond cond, int ra, int rb, int rc, int islit, uint8t lit) { int l1, l2; TCGv tmp; if (unlikely(rc == 31)) return; l1 = gennewlabel(); l2 = gennewlabel(); if (ra != 31) { tmp = tcgtempnew(TCGTYPEI64); tcggenmovi64(tmp, cpuir[ra]); } else tmp = tcgconsti64(0); if (islit) tcggenbrcondii64(cond, tmp, lit, l1); else tcggenbrcondi64(cond, tmp, cpuir[rb], l1); tcggenmovii64(cpuir[rc], 0); tcggenbr(l2); gensetlabel(l1); tcggenmovii64(cpuir[rc], 1); gensetlabel(l2); } ", "target": 0}
{"func": "static int virtioscsideviceexit(DeviceState *qdev) { VirtIOSCSI *s = VIRTIOSCSI(qdev); VirtIOSCSICommon *vs = VIRTIOSCSICOMMON(qdev); unregistersavevm(qdev, \"virtio-scsi\", s); return virtioscsicommonexit(vs); } ", "target": 1}
{"func": "static int pcivpbinit(SysBusDevice *dev) { PCIVPBState *s = FROMSYSBUS(PCIVPBState, dev); PCIBus *bus; int i; for (i = 0; i < 4; i++) { sysbusinitirq(dev, &s->irq[i]); } bus = pciregisterbus(&dev->qdev, \"pci\", pcivpbsetirq, pcivpbmapirq, s->irq, getsystemmemory(), getsystemio(), PCIDEVFN(11, 0), 4); /* ??? Register memory space. */ memoryregioninitio(&s->memconfig, &pcivpbconfigops, bus, \"pci-vpb-selfconfig\", 0x1000000); memoryregioninitio(&s->memconfig2, &pcivpbconfigops, bus, \"pci-vpb-config\", 0x1000000); if (s->realview) { isammiosetup(&s->isa, 0x0100000); } sysbusinitmmiocb2(dev, pcivpbmap, pcivpbunmap); pcicreatesimple(bus, -1, \"versatilepcihost\"); return 0; } ", "target": 0}
{"func": "static void rngrandomsetfilename(Object *obj, const char *filename, Error **errp) { RngBackend *b = RNGBACKEND(obj); RndRandom *s = RNGRANDOM(obj); if (b->opened) { errorset(errp, QERRPERMISSIONDENIED); return; } if (s->filename) { gfree(s->filename); } s->filename = gstrdup(filename); } ", "target": 0}
{"func": "static void rtasibmgetconfigaddrinfo2(PowerPCCPU *cpu, sPAPRMachineState *spapr, uint32t token, uint32t nargs, targetulong args, uint32t nret, targetulong rets) { sPAPRPHBState *sphb; PCIDevice *pdev; uint32t addr, option; uint64t buid; if ((nargs != 4) || (nret != 2)) { goto paramerrorexit; } buid = rtasldq(args, 1); sphb = spaprpcifindphb(spapr, buid); if (!sphb) { goto paramerrorexit; } if (!spaprphbeehavailable(sphb)) { goto paramerrorexit; } /* * We always have PE address of form \"00BB0001\". \"BB\" * represents the bus number of PE's primary bus. */ option = rtasld(args, 3); switch (option) { case RTASGETPEADDR: addr = rtasld(args, 0); pdev = spaprpcifinddev(spapr, buid, addr); if (!pdev) { goto paramerrorexit; } rtasst(rets, 1, (pcibusnum(pdev->bus) << 16) + 1); break; case RTASGETPEMODE: rtasst(rets, 1, RTASPEMODESHARED); break; default: goto paramerrorexit; } rtasst(rets, 0, RTASOUTSUCCESS); return; paramerrorexit: rtasst(rets, 0, RTASOUTPARAMERROR); } ", "target": 0}
{"func": "static void migratefdcompleted(MigrationState *s) { DPRINTF(\"setting completed state\\n\"); migratefdcleanup(s); if (s->state == MIGSTATEACTIVE) { s->state = MIGSTATECOMPLETED; runstateset(RUNSTATEPOSTMIGRATE); } notifierlistnotify(&migrationstatenotifiers, s); } ", "target": 0}
{"func": "static unsigned int decaddsr(DisasContext *dc) { \tTCGv t0; \tint size = memsizez(dc); \tDIS(fprintf (logfile, \"adds.%c $r%u, $r%u\\n\", \t\t memsizechar(size), \t\t dc->op1, dc->op2)); \tcrisccmask(dc, CCMASKNZVC); \tt0 = tcgtempnew(TCGTYPETL); \t/* Size can only be qi or hi. */ \ttgensext(t0, cpuR[dc->op1], size); \tcrisalu(dc, CCOPADD, \t\t cpuR[dc->op2], cpuR[dc->op2], t0, 4); \ttcgtempfree(t0); \treturn 2; } ", "target": 0}
{"func": "static void createmap(vorbiscontext *vc, unsigned floornumber) { vorbisfloor *floors = vc->floors; vorbisfloor0 *vf; int idx; int blockflag, n; int32t *map; for (blockflag = 0; blockflag < 2; ++blockflag) { n = vc->blocksize[blockflag] / 2; floors[floornumber].data.t0.map[blockflag] = avmalloc((n + 1) * sizeof(int32t)); // n + sentinel map = floors[floornumber].data.t0.map[blockflag]; vf = &floors[floornumber].data.t0; for (idx = 0; idx < n; ++idx) { map[idx] = floor(BARK((vf->rate * idx) / (2.0f * n)) * (vf->barkmapsize / BARK(vf->rate / 2.0f))); if (vf->barkmapsize-1 < map[idx]) map[idx] = vf->barkmapsize - 1; } map[n] = -1; vf->mapsize[blockflag] = n; } for (idx = 0; idx <= n; ++idx) { avdlog(NULL, \"floor0 map: map at pos %d is %d\\n\", idx, map[idx]); } } ", "target": 0}
{"func": "static void virtioscsiparsereq(VirtIOSCSI *s, VirtQueue *vq, VirtIOSCSIReq *req) { assert(req->elem.outnum && req->elem.innum); req->vq = vq; req->dev = s; req->sreq = NULL; req->req.buf = req->elem.outsg[0].iovbase; req->resp.buf = req->elem.insg[0].iovbase; if (req->elem.outnum > 1) { qemusglinitexternal(&req->qsgl, &req->elem.outsg[1], &req->elem.outaddr[1], req->elem.outnum - 1); } else { qemusglinitexternal(&req->qsgl, &req->elem.insg[1], &req->elem.inaddr[1], req->elem.innum - 1); } } ", "target": 0}
{"func": "static void usbuastask(UASDevice *uas, uasui *ui) { uint16t tag = be16tocpu(ui->hdr.tag); uint64t lun64 = be64tocpu(ui->task.lun); SCSIDevice *dev = usbuasgetdev(uas, lun64); int lun = usbuasgetlun(lun64); UASRequest *req; uint16t tasktag; req = usbuasfindrequest(uas, be16tocpu(ui->hdr.tag)); if (req) { goto overlappedtag; } switch (ui->task.function) { case UASTMFABORTTASK: tasktag = be16tocpu(ui->task.tasktag); traceusbuastmfaborttask(uas->dev.addr, tag, tasktag); if (dev == NULL) { goto badtarget; } if (dev->lun != lun) { goto incorrectlun; } req = usbuasfindrequest(uas, tasktag); if (req && req->dev == dev) { scsireqcancel(req->req); } usbuasqueueresponse(uas, tag, UASRCTMFCOMPLETE, 0); break; case UASTMFLOGICALUNITRESET: traceusbuastmflogicalunitreset(uas->dev.addr, tag, lun); if (dev == NULL) { goto badtarget; } if (dev->lun != lun) { goto incorrectlun; } qdevresetall(&dev->qdev); usbuasqueueresponse(uas, tag, UASRCTMFCOMPLETE, 0); break; default: traceusbuastmfunsupported(uas->dev.addr, tag, ui->task.function); usbuasqueueresponse(uas, tag, UASRCTMFNOTSUPPORTED, 0); break; } return; overlappedtag: usbuasqueueresponse(uas, req->tag, UASRCOVERLAPPEDTAG, 0); return; badtarget: /* FIXME: correct? [see long comment in usbuascommand()] */ usbuasqueueresponse(uas, tag, UASRCINVALIDINFOUNIT, 0); return; incorrectlun: usbuasqueueresponse(uas, tag, UASRCINCORRECTLUN, 0); } ", "target": 0}
{"func": "static int ideqdevinit(DeviceState *qdev, DeviceInfo *base) { IDEDevice *dev = DOUPCAST(IDEDevice, qdev, qdev); IDEDeviceInfo *info = DOUPCAST(IDEDeviceInfo, qdev, base); IDEBus *bus = DOUPCAST(IDEBus, qbus, qdev->parentbus); if (!dev->conf.dinfo) { fprintf(stderr, \"%s: no drive specified\\n\", qdev->info->name); goto err; } if (dev->unit == -1) { dev->unit = bus->master ? 1 : 0; } switch (dev->unit) { case 0: if (bus->master) { fprintf(stderr, \"ide: tried to assign master twice\\n\"); goto err; } bus->master = dev; break; case 1: if (bus->slave) { fprintf(stderr, \"ide: tried to assign slave twice\\n\"); goto err; } bus->slave = dev; break; default: goto err; } return info->init(dev); err: return -1; } ", "target": 0}
{"func": "static int tcgmatchori(TCGType type, tcgtargetlong val) { if (facilities & FACILITYEXTIMM) { if (type == TCGTYPEI32) { /* All 32-bit ORs can be performed with 1 48-bit insn. */ return 1; } } /* Look for negative values. These are best to load with LGHI. */ if (val < 0) { if (val == (int16t)val) { return 0; } if (facilities & FACILITYEXTIMM) { if (val == (int32t)val) { return 0; } } } return 1; } ", "target": 0}
{"func": "void OPPROTO opaddqEDIT0(void) { EDI = (EDI + T0); } ", "target": 0}
{"func": "static void hypercallregistertypes(void) { /* hcall-pft */ spaprregisterhypercall(HENTER, henter); spaprregisterhypercall(HREMOVE, hremove); spaprregisterhypercall(HPROTECT, hprotect); spaprregisterhypercall(HREAD, hread); /* hcall-bulk */ spaprregisterhypercall(HBULKREMOVE, hbulkremove); /* hcall-dabr */ spaprregisterhypercall(HSETDABR, hsetdabr); /* hcall-splpar */ spaprregisterhypercall(HREGISTERVPA, hregistervpa); spaprregisterhypercall(HCEDE, hcede); /* processor register resource access h-calls */ spaprregisterhypercall(HSETSPRG0, hsetsprg0); spaprregisterhypercall(HSETMODE, hsetmode); /* \"debugger\" hcalls (also used by SLOF). Note: We do -not- differenciate * here between the \"CI\" and the \"CACHE\" variants, they will use whatever * mapping attributes qemu is using. When using KVM, the kernel will * enforce the attributes more strongly */ spaprregisterhypercall(HLOGICALCILOAD, hlogicalload); spaprregisterhypercall(HLOGICALCISTORE, hlogicalstore); spaprregisterhypercall(HLOGICALCACHELOAD, hlogicalload); spaprregisterhypercall(HLOGICALCACHESTORE, hlogicalstore); spaprregisterhypercall(HLOGICALICBI, hlogicalicbi); spaprregisterhypercall(HLOGICALDCBF, hlogicaldcbf); spaprregisterhypercall(KVMPPCHLOGICALMEMOP, hlogicalmemop); /* qemu/KVM-PPC specific hcalls */ spaprregisterhypercall(KVMPPCHRTAS, hrtas); /* ibm,client-architecture-support support */ spaprregisterhypercall(KVMPPCHCAS, hclientarchitecturesupport); } ", "target": 0}
{"func": "static void virtioblkupdateconfig(VirtIODevice *vdev, uint8t *config) { VirtIOBlock *s = VIRTIOBLK(vdev); BlockConf *conf = &s->conf.conf; struct virtioblkconfig blkcfg; uint64t capacity; int blksize = conf->logicalblocksize; bdrvgetgeometry(s->bs, &capacity); memset(&blkcfg, 0, sizeof(blkcfg)); virtiostqp(vdev, &blkcfg.capacity, capacity); virtiostlp(vdev, &blkcfg.segmax, 128 - 2); virtiostwp(vdev, &blkcfg.cylinders, conf->cyls); virtiostlp(vdev, &blkcfg.blksize, blksize); virtiostwp(vdev, &blkcfg.miniosize, conf->miniosize / blksize); virtiostwp(vdev, &blkcfg.optiosize, conf->optiosize / blksize); blkcfg.heads = conf->heads; /* * We must ensure that the block device capacity is a multiple of * the logical block size. If that is not the case, let's use * sectormask to adopt the geometry to have a correct picture. * For those devices where the capacity is ok for the given geometry * we don't touch the sector value of the geometry, since some devices * (like s390 dasd) need a specific value. Here the capacity is already * cyls*heads*secs*blksize and the sector value is not block size * divided by 512 - instead it is the amount of blksize blocks * per track (cylinder). */ if (bdrvgetlength(s->bs) / conf->heads / conf->secs % blksize) { blkcfg.sectors = conf->secs & ~s->sectormask; } else { blkcfg.sectors = conf->secs; } blkcfg.sizemax = 0; blkcfg.physicalblockexp = getphysicalblockexp(conf); blkcfg.alignmentoffset = 0; blkcfg.wce = bdrvenablewritecache(s->bs); memcpy(config, &blkcfg, sizeof(struct virtioblkconfig)); } ", "target": 0}
{"func": "static void decodeopc (CPUMIPSState *env, DisasContext *ctx) { int32t offset; int rs, rt, rd, sa; uint32t op, op1; int16t imm; /* make sure instructions are on a word boundary */ if (ctx->pc & 0x3) { env->CP0BadVAddr = ctx->pc; generateexception(ctx, EXCPAdEL); return; } /* Handle blikely not taken case */ if ((ctx->hflags & MIPSHFLAGBMASKBASE) == MIPSHFLAGBL) { int l1 = gennewlabel(); MIPSDEBUG(\"blikely condition (\" TARGETFMTlx \")\", ctx->pc + 4); tcggenbrconditl(TCGCONDNE, bcond, 0, l1); tcggenmovii32(hflags, ctx->hflags & ~MIPSHFLAGBMASK); gengototb(ctx, 1, ctx->pc + 4); gensetlabel(l1); } if (unlikely(qemuloglevelmask(CPULOGTBOP | CPULOGTBOPOPT))) { tcggendebuginsnstart(ctx->pc); } op = MASKOPMAJOR(ctx->opcode); rs = (ctx->opcode >> 21) & 0x1f; rt = (ctx->opcode >> 16) & 0x1f; rd = (ctx->opcode >> 11) & 0x1f; sa = (ctx->opcode >> 6) & 0x1f; imm = (int16t)ctx->opcode; switch (op) { case OPCSPECIAL: decodeopcspecial(env, ctx); break; case OPCSPECIAL2: decodeopcspecial2legacy(env, ctx); break; case OPCSPECIAL3: decodeopcspecial3(env, ctx); break; case OPCREGIMM: op1 = MASKREGIMM(ctx->opcode); switch (op1) { case OPCBLTZL: /* REGIMM branches */ case OPCBGEZL: case OPCBLTZALL: case OPCBGEZALL: checkinsnopcremoved(ctx, ISAMIPS32R6); case OPCBLTZ: case OPCBGEZ: gencomputebranch(ctx, op1, 4, rs, -1, imm << 2, 4); break; case OPCBLTZAL: case OPCBGEZAL: if (ctx->insnflags & ISAMIPS32R6) { if (rs == 0) { /* OPCNAL, OPCBAL */ gencomputebranch(ctx, op1, 4, 0, -1, imm << 2, 4); } else { generateexception(ctx, EXCPRI); } } else { gencomputebranch(ctx, op1, 4, rs, -1, imm << 2, 4); } break; case OPCTGEI ... OPCTEQI: /* REGIMM traps */ case OPCTNEI: checkinsnopcremoved(ctx, ISAMIPS32R6); gentrap(ctx, op1, rs, -1, imm); break; case OPCSYNCI: checkinsn(ctx, ISAMIPS32R2); /* Break the TB to be able to sync copied instructions immediately */ ctx->bstate = BSSTOP; break; case OPCBPOSGE32: /* MIPS DSP branch */ #if defined(TARGETMIPS64) case OPCBPOSGE64: #endif checkdsp(ctx); gencomputebranch(ctx, op1, 4, -1, -2, (int32t)imm << 2, 4); break; #if defined(TARGETMIPS64) case OPCDAHI: checkinsn(ctx, ISAMIPS32R6); checkmips64(ctx); if (rs != 0) { tcggenadditl(cpugpr[rs], cpugpr[rs], (int64t)imm << 32); } MIPSDEBUG(\"dahi %s, %04x\", regnames[rs], imm); break; case OPCDATI: checkinsn(ctx, ISAMIPS32R6); checkmips64(ctx); if (rs != 0) { tcggenadditl(cpugpr[rs], cpugpr[rs], (int64t)imm << 48); } MIPSDEBUG(\"dati %s, %04x\", regnames[rs], imm); break; #endif default: /* Invalid */ MIPSINVAL(\"regimm\"); generateexception(ctx, EXCPRI); break; } break; case OPCCP0: checkcp0enabled(ctx); op1 = MASKCP0(ctx->opcode); switch (op1) { case OPCMFC0: case OPCMTC0: case OPCMFTR: case OPCMTTR: #if defined(TARGETMIPS64) case OPCDMFC0: case OPCDMTC0: #endif #ifndef CONFIGUSERONLY gencp0(env, ctx, op1, rt, rd); #endif /* !CONFIGUSERONLY */ break; case OPCC0FIRST ... OPCC0LAST: #ifndef CONFIGUSERONLY gencp0(env, ctx, MASKC0(ctx->opcode), rt, rd); #endif /* !CONFIGUSERONLY */ break; case OPCMFMC0: #ifndef CONFIGUSERONLY { uint32t op2; TCGv t0 = tcgtempnew(); op2 = MASKMFMC0(ctx->opcode); switch (op2) { case OPCDMT: checkinsn(ctx, ASEMT); genhelperdmt(t0); genstoregpr(t0, rt); break; case OPCEMT: checkinsn(ctx, ASEMT); genhelperemt(t0); genstoregpr(t0, rt); break; case OPCDVPE: checkinsn(ctx, ASEMT); genhelperdvpe(t0, cpuenv); genstoregpr(t0, rt); break; case OPCEVPE: checkinsn(ctx, ASEMT); genhelperevpe(t0, cpuenv); genstoregpr(t0, rt); break; case OPCDI: checkinsn(ctx, ISAMIPS32R2); savecpustate(ctx, 1); genhelperdi(t0, cpuenv); genstoregpr(t0, rt); /* Stop translation as we may have switched the execution mode */ ctx->bstate = BSSTOP; break; case OPCEI: checkinsn(ctx, ISAMIPS32R2); savecpustate(ctx, 1); genhelperei(t0, cpuenv); genstoregpr(t0, rt); /* Stop translation as we may have switched the execution mode */ ctx->bstate = BSSTOP; break; default: /* Invalid */ MIPSINVAL(\"mfmc0\"); generateexception(ctx, EXCPRI); break; } tcgtempfree(t0); } #endif /* !CONFIGUSERONLY */ break; case OPCRDPGPR: checkinsn(ctx, ISAMIPS32R2); genloadsrsgpr(rt, rd); break; case OPCWRPGPR: checkinsn(ctx, ISAMIPS32R2); genstoresrsgpr(rt, rd); break; default: MIPSINVAL(\"cp0\"); generateexception(ctx, EXCPRI); break; } break; case OPCBOVC: /* OPCBEQZALC, OPCBEQC, OPCADDI */ if (ctx->insnflags & ISAMIPS32R6) { /* OPCBOVC, OPCBEQZALC, OPCBEQC */ gencomputecompactbranch(ctx, op, rs, rt, imm << 2); } else { /* OPCADDI */ /* Arithmetic with immediate opcode */ genarithimm(ctx, op, rt, rs, imm); } break; case OPCADDIU: genarithimm(ctx, op, rt, rs, imm); break; case OPCSLTI: /* Set on less than with immediate opcode */ case OPCSLTIU: gensltimm(ctx, op, rt, rs, imm); break; case OPCANDI: /* Arithmetic with immediate opcode */ case OPCLUI: /* OPCAUI */ case OPCORI: case OPCXORI: genlogicimm(ctx, op, rt, rs, imm); break; case OPCJ ... OPCJAL: /* Jump */ offset = (int32t)(ctx->opcode & 0x3FFFFFF) << 2; gencomputebranch(ctx, op, 4, rs, rt, offset, 4); break; /* Branch */ case OPCBLEZC: /* OPCBGEZC, OPCBGEC, OPCBLEZL */ if (ctx->insnflags & ISAMIPS32R6) { if (rt == 0) { generateexception(ctx, EXCPRI); break; } /* OPCBLEZC, OPCBGEZC, OPCBGEC */ gencomputecompactbranch(ctx, op, rs, rt, imm << 2); } else { /* OPCBLEZL */ gencomputebranch(ctx, op, 4, rs, rt, imm << 2, 4); } break; case OPCBGTZC: /* OPCBLTZC, OPCBLTC, OPCBGTZL */ if (ctx->insnflags & ISAMIPS32R6) { if (rt == 0) { generateexception(ctx, EXCPRI); break; } /* OPCBGTZC, OPCBLTZC, OPCBLTC */ gencomputecompactbranch(ctx, op, rs, rt, imm << 2); } else { /* OPCBGTZL */ gencomputebranch(ctx, op, 4, rs, rt, imm << 2, 4); } break; case OPCBLEZALC: /* OPCBGEZALC, OPCBGEUC, OPCBLEZ */ if (rt == 0) { /* OPCBLEZ */ gencomputebranch(ctx, op, 4, rs, rt, imm << 2, 4); } else { checkinsn(ctx, ISAMIPS32R6); /* OPCBLEZALC, OPCBGEZALC, OPCBGEUC */ gencomputecompactbranch(ctx, op, rs, rt, imm << 2); } break; case OPCBGTZALC: /* OPCBLTZALC, OPCBLTUC, OPCBGTZ */ if (rt == 0) { /* OPCBGTZ */ gencomputebranch(ctx, op, 4, rs, rt, imm << 2, 4); } else { checkinsn(ctx, ISAMIPS32R6); /* OPCBGTZALC, OPCBLTZALC, OPCBLTUC */ gencomputecompactbranch(ctx, op, rs, rt, imm << 2); } break; case OPCBEQL: case OPCBNEL: checkinsnopcremoved(ctx, ISAMIPS32R6); case OPCBEQ: case OPCBNE: gencomputebranch(ctx, op, 4, rs, rt, imm << 2, 4); break; case OPCLWL: /* Load and stores */ case OPCLWR: case OPCLL: checkinsnopcremoved(ctx, ISAMIPS32R6); case OPCLB ... OPCLH: case OPCLW ... OPCLHU: genld(ctx, op, rt, rs, imm); break; case OPCSWL: case OPCSWR: checkinsnopcremoved(ctx, ISAMIPS32R6); case OPCSB ... OPCSH: case OPCSW: genst(ctx, op, rt, rs, imm); break; case OPCSC: checkinsnopcremoved(ctx, ISAMIPS32R6); genstcond(ctx, op, rt, rs, imm); break; case OPCCACHE: checkinsnopcremoved(ctx, ISAMIPS32R6); checkcp0enabled(ctx); checkinsn(ctx, ISAMIPS3 | ISAMIPS32); /* Treat as NOP. */ break; case OPCPREF: checkinsnopcremoved(ctx, ISAMIPS32R6); checkinsn(ctx, ISAMIPS4 | ISAMIPS32); /* Treat as NOP. */ break; /* Floating point (COP1). */ case OPCLWC1: case OPCLDC1: case OPCSWC1: case OPCSDC1: gencop1ldst(ctx, op, rt, rs, imm); break; case OPCCP1: if (ctx->CP0Config1 & (1 << CP0C1FP)) { checkcp1enabled(ctx); op1 = MASKCP1(ctx->opcode); switch (op1) { case OPCMFHC1: case OPCMTHC1: checkinsn(ctx, ISAMIPS32R2); case OPCMFC1: case OPCCFC1: case OPCMTC1: case OPCCTC1: gencp1(ctx, op1, rt, rd); break; #if defined(TARGETMIPS64) case OPCDMFC1: case OPCDMTC1: checkinsn(ctx, ISAMIPS3); gencp1(ctx, op1, rt, rd); break; #endif case OPCBC1EQZ: /* OPCBC1ANY2 */ if (ctx->insnflags & ISAMIPS32R6) { /* OPCBC1EQZ */ gencomputebranch1r6(ctx, MASKCP1(ctx->opcode), rt, imm << 2); } else { /* OPCBC1ANY2 */ checkcop1x(ctx); checkinsn(ctx, ASEMIPS3D); gencomputebranch1(ctx, MASKBC1(ctx->opcode), (rt >> 2) & 0x7, imm << 2); } break; case OPCBC1NEZ: checkinsn(ctx, ISAMIPS32R6); gencomputebranch1r6(ctx, MASKCP1(ctx->opcode), rt, imm << 2); break; case OPCBC1ANY4: checkinsnopcremoved(ctx, ISAMIPS32R6); checkcop1x(ctx); checkinsn(ctx, ASEMIPS3D); /* fall through */ case OPCBC1: checkinsnopcremoved(ctx, ISAMIPS32R6); gencomputebranch1(ctx, MASKBC1(ctx->opcode), (rt >> 2) & 0x7, imm << 2); break; case OPCPSFMT: checkinsnopcremoved(ctx, ISAMIPS32R6); case OPCSFMT: case OPCDFMT: genfarith(ctx, ctx->opcode & FOP(0x3f, 0x1f), rt, rd, sa, (imm >> 8) & 0x7); break; case OPCWFMT: case OPCLFMT: { int r6op = ctx->opcode & FOP(0x3f, 0x1f); if (ctx->insnflags & ISAMIPS32R6) { switch (r6op) { case R6OPCCMPAFS: case R6OPCCMPUNS: case R6OPCCMPEQS: case R6OPCCMPUEQS: case R6OPCCMPLTS: case R6OPCCMPULTS: case R6OPCCMPLES: case R6OPCCMPULES: case R6OPCCMPSAFS: case R6OPCCMPSUNS: case R6OPCCMPSEQS: case R6OPCCMPSEUQS: case R6OPCCMPSLTS: case R6OPCCMPSULTS: case R6OPCCMPSLES: case R6OPCCMPSULES: case R6OPCCMPORS: case R6OPCCMPUNES: case R6OPCCMPNES: case R6OPCCMPSORS: case R6OPCCMPSUNES: case R6OPCCMPSNES: genr6cmps(ctx, ctx->opcode & 0x1f, rt, rd, sa); break; case R6OPCCMPAFD: case R6OPCCMPUND: case R6OPCCMPEQD: case R6OPCCMPUEQD: case R6OPCCMPLTD: case R6OPCCMPULTD: case R6OPCCMPLED: case R6OPCCMPULED: case R6OPCCMPSAFD: case R6OPCCMPSUND: case R6OPCCMPSEQD: case R6OPCCMPSEUQD: case R6OPCCMPSLTD: case R6OPCCMPSULTD: case R6OPCCMPSLED: case R6OPCCMPSULED: case R6OPCCMPORD: case R6OPCCMPUNED: case R6OPCCMPNED: case R6OPCCMPSORD: case R6OPCCMPSUNED: case R6OPCCMPSNED: genr6cmpd(ctx, ctx->opcode & 0x1f, rt, rd, sa); break; default: genfarith(ctx, ctx->opcode & FOP(0x3f, 0x1f), rt, rd, sa, (imm >> 8) & 0x7); break; } } else { genfarith(ctx, ctx->opcode & FOP(0x3f, 0x1f), rt, rd, sa, (imm >> 8) & 0x7); } break; } default: MIPSINVAL(\"cp1\"); generateexception (ctx, EXCPRI); break; } } else { generateexceptionerr(ctx, EXCPCpU, 1); } break; /* Compact branches [R6] and COP2 [non-R6] */ case OPCBC: /* OPCLWC2 */ case OPCBALC: /* OPCSWC2 */ if (ctx->insnflags & ISAMIPS32R6) { /* OPCBC, OPCBALC */ gencomputecompactbranch(ctx, op, 0, 0, sextract32(ctx->opcode << 2, 0, 28)); } else { /* OPCLWC2, OPCSWC2 */ /* COP2: Not implemented. */ generateexceptionerr(ctx, EXCPCpU, 2); } break; case OPCBEQZC: /* OPCJIC, OPCLDC2 */ case OPCBNEZC: /* OPCJIALC, OPCSDC2 */ if (ctx->insnflags & ISAMIPS32R6) { if (rs != 0) { /* OPCBEQZC, OPCBNEZC */ gencomputecompactbranch(ctx, op, rs, 0, sextract32(ctx->opcode << 2, 0, 23)); } else { /* OPCJIC, OPCJIALC */ gencomputecompactbranch(ctx, op, 0, rt, imm); } } else { /* OPCLWC2, OPCSWC2 */ /* COP2: Not implemented. */ generateexceptionerr(ctx, EXCPCpU, 2); } break; case OPCCP2: checkinsn(ctx, INSNLOONGSON2F); /* Note that these instructions use different fields. */ genloongsonmultimedia(ctx, sa, rd, rt); break; case OPCCP3: checkinsnopcremoved(ctx, ISAMIPS32R6); if (ctx->CP0Config1 & (1 << CP0C1FP)) { checkcp1enabled(ctx); op1 = MASKCP3(ctx->opcode); switch (op1) { case OPCLWXC1: case OPCLDXC1: case OPCLUXC1: case OPCSWXC1: case OPCSDXC1: case OPCSUXC1: genflt3ldst(ctx, op1, sa, rd, rs, rt); break; case OPCPREFX: /* Treat as NOP. */ break; case OPCALNVPS: case OPCMADDS: case OPCMADDD: case OPCMADDPS: case OPCMSUBS: case OPCMSUBD: case OPCMSUBPS: case OPCNMADDS: case OPCNMADDD: case OPCNMADDPS: case OPCNMSUBS: case OPCNMSUBD: case OPCNMSUBPS: genflt3arith(ctx, op1, sa, rs, rd, rt); break; default: MIPSINVAL(\"cp3\"); generateexception (ctx, EXCPRI); break; } } else { generateexceptionerr(ctx, EXCPCpU, 1); } break; #if defined(TARGETMIPS64) /* MIPS64 opcodes */ case OPCLDL ... OPCLDR: case OPCLLD: checkinsnopcremoved(ctx, ISAMIPS32R6); case OPCLWU: case OPCLD: checkinsn(ctx, ISAMIPS3); checkmips64(ctx); genld(ctx, op, rt, rs, imm); break; case OPCSDL ... OPCSDR: checkinsnopcremoved(ctx, ISAMIPS32R6); case OPCSD: checkinsn(ctx, ISAMIPS3); checkmips64(ctx); genst(ctx, op, rt, rs, imm); break; case OPCSCD: checkinsnopcremoved(ctx, ISAMIPS32R6); checkinsn(ctx, ISAMIPS3); checkmips64(ctx); genstcond(ctx, op, rt, rs, imm); break; case OPCBNVC: /* OPCBNEZALC, OPCBNEC, OPCDADDI */ if (ctx->insnflags & ISAMIPS32R6) { /* OPCBNVC, OPCBNEZALC, OPCBNEC */ gencomputecompactbranch(ctx, op, rs, rt, imm << 2); } else { /* OPCDADDI */ checkinsn(ctx, ISAMIPS3); checkmips64(ctx); genarithimm(ctx, op, rt, rs, imm); } break; case OPCDADDIU: checkinsn(ctx, ISAMIPS3); checkmips64(ctx); genarithimm(ctx, op, rt, rs, imm); break; #else case OPCBNVC: /* OPCBNEZALC, OPCBNEC */ if (ctx->insnflags & ISAMIPS32R6) { gencomputecompactbranch(ctx, op, rs, rt, imm << 2); } else { MIPSINVAL(\"major opcode\"); generateexception(ctx, EXCPRI); } break; #endif case OPCDAUI: /* OPCJALX */ if (ctx->insnflags & ISAMIPS32R6) { #if defined(TARGETMIPS64) /* OPCDAUI */ checkmips64(ctx); if (rt != 0) { TCGv t0 = tcgtempnew(); genloadgpr(t0, rs); tcggenadditl(cpugpr[rt], t0, imm << 16); tcgtempfree(t0); } MIPSDEBUG(\"daui %s, %s, %04x\", regnames[rt], regnames[rs], imm); #else generateexception(ctx, EXCPRI); MIPSINVAL(\"major opcode\"); #endif } else { /* OPCJALX */ checkinsn(ctx, ASEMIPS16 | ASEMICROMIPS); offset = (int32t)(ctx->opcode & 0x3FFFFFF) << 2; gencomputebranch(ctx, op, 4, rs, rt, offset, 4); } break; case OPCMDMX: checkinsn(ctx, ASEMDMX); /* MDMX: Not implemented. */ break; case OPCPCREL: checkinsn(ctx, ISAMIPS32R6); genpcrel(ctx, rs, imm); break; default: /* Invalid */ MIPSINVAL(\"major opcode\"); generateexception(ctx, EXCPRI); break; } } ", "target": 0}
{"func": "bool blkdevistrayopen(BlockBackend *blk) { if (blk->devops && blk->devops->istrayopen) { return blk->devops->istrayopen(blk->devopaque); } return false; } ", "target": 0}
{"func": "static avcold int tdscinit(AVCodecContext *avctx) { TDSCContext *ctx = avctx->privdata; const AVCodec *codec; int ret; avctx->pixfmt = AVPIXFMTBGR24; /* These needs to be set to estimate buffer and frame size */ if (!(avctx->width && avctx->height)) { avlog(avctx, AVLOGERROR, \"Video size not set.\\n\"); return AVERRORINVALIDDATA; } /* This value should be large enough for a RAW-only frame plus headers */ ctx->deflatelen = avctx->width * avctx->height * (3 + 1); ret = avreallocp(&ctx->deflatebuffer, ctx->deflatelen); if (ret < 0) return ret; /* Allocate reference and JPEG frame */ ctx->refframe = avframealloc(); ctx->jpgframe = avframealloc(); if (!ctx->refframe || !ctx->jpgframe) return AVERROR(ENOMEM); /* Prepare everything needed for JPEG decoding */ codec = avcodecfinddecoder(AVCODECIDMJPEG); if (!codec) return AVERRORBUG; ctx->jpegavctx = avcodecalloccontext3(codec); if (!ctx->jpegavctx) return AVERROR(ENOMEM); ctx->jpegavctx->flags = avctx->flags; ctx->jpegavctx->flags2 = avctx->flags2; ctx->jpegavctx->dctalgo = avctx->dctalgo; ctx->jpegavctx->idctalgo = avctx->idctalgo;; ret = avcodecopen2(ctx->jpegavctx, codec, NULL); if (ret < 0) return ret; /* Set the output pixel format on the reference frame */ ctx->refframe->format = avctx->pixfmt; return 0; } ", "target": 1}
{"func": "int hvfvcpuexec(CPUState *cpu) { X86CPU *x86cpu = X86CPU(cpu); CPUX86State *env = &x86cpu->env; int ret = 0; uint64t rip = 0; cpu->halted = 0; if (hvfprocessevents(cpu)) { return EXCPHLT; } do { if (cpu->vcpudirty) { hvfputregisters(cpu); cpu->vcpudirty = false; } if (hvfinjectinterrupts(cpu)) { return EXCPINTERRUPT; } vmxupdatetpr(cpu); qemumutexunlockiothread(); if (!cpuisbsp(X86CPU(cpu)) && cpu->halted) { qemumutexlockiothread(); return EXCPHLT; } hvreturnt r = hvvcpurun(cpu->hvffd); asserthvfok(r); /* handle VMEXIT */ uint64t exitreason = rvmcs(cpu->hvffd, VMCSEXITREASON); uint64t exitqual = rvmcs(cpu->hvffd, VMCSEXITQUALIFICATION); uint32t inslen = (uint32t)rvmcs(cpu->hvffd, VMCSEXITINSTRUCTIONLENGTH); uint64t idtvecinfo = rvmcs(cpu->hvffd, VMCSIDTVECTORINGINFO); hvfstoreevents(cpu, inslen, idtvecinfo); rip = rreg(cpu->hvffd, HVX86RIP); RFLAGS(env) = rreg(cpu->hvffd, HVX86RFLAGS); env->eflags = RFLAGS(env); qemumutexlockiothread(); updateapictpr(cpu); currentcpu = cpu; ret = 0; switch (exitreason) { case EXITREASONHLT: { macvmsetrip(cpu, rip + inslen); if (!((cpu->interruptrequest & CPUINTERRUPTHARD) && (EFLAGS(env) & IFMASK)) && !(cpu->interruptrequest & CPUINTERRUPTNMI) && !(idtvecinfo & VMCSIDTVECVALID)) { cpu->halted = 1; ret = EXCPHLT; } ret = EXCPINTERRUPT; break; } case EXITREASONMWAIT: { ret = EXCPINTERRUPT; break; } /* Need to check if MMIO or unmmaped fault */ case EXITREASONEPTFAULT: { hvfslot *slot; addrt gpa = rvmcs(cpu->hvffd, VMCSGUESTPHYSICALADDRESS); if (((idtvecinfo & VMCSIDTVECVALID) == 0) && ((exitqual & EXITQUALNMIUDTI) != 0)) { vmxsetnmiblocking(cpu); } slot = hvffindoverlapslot(gpa, gpa); /* mmio */ if (eptemulationfault(slot, gpa, exitqual)) { struct x86decode decode; loadregs(cpu); env->hvfemul->fetchrip = rip; decodeinstruction(env, &decode); execinstruction(env, &decode); storeregs(cpu); break; } break; } case EXITREASONINOUT: { uint32t in = (exitqual & 8) != 0; uint32t size = (exitqual & 7) + 1; uint32t string = (exitqual & 16) != 0; uint32t port = exitqual >> 16; /*uint32t rep = (exitqual & 0x20) != 0;*/ #if 1 if (!string && in) { uint64t val = 0; loadregs(cpu); hvfhandleio(env, port, &val, 0, size, 1); if (size == 1) { AL(env) = val; } else if (size == 2) { AX(env) = val; } else if (size == 4) { RAX(env) = (uint32t)val; } else { VMPANIC(\"size\"); } RIP(env) += inslen; storeregs(cpu); break; } else if (!string && !in) { RAX(env) = rreg(cpu->hvffd, HVX86RAX); hvfhandleio(env, port, &RAX(env), 1, size, 1); macvmsetrip(cpu, rip + inslen); break; } #endif struct x86decode decode; loadregs(cpu); env->hvfemul->fetchrip = rip; decodeinstruction(env, &decode); VMPANICON(inslen != decode.len); execinstruction(env, &decode); storeregs(cpu); break; } case EXITREASONCPUID: { uint32t rax = (uint32t)rreg(cpu->hvffd, HVX86RAX); uint32t rbx = (uint32t)rreg(cpu->hvffd, HVX86RBX); uint32t rcx = (uint32t)rreg(cpu->hvffd, HVX86RCX); uint32t rdx = (uint32t)rreg(cpu->hvffd, HVX86RDX); cpux86cpuid(env, rax, rcx, &rax, &rbx, &rcx, &rdx); wreg(cpu->hvffd, HVX86RAX, rax); wreg(cpu->hvffd, HVX86RBX, rbx); wreg(cpu->hvffd, HVX86RCX, rcx); wreg(cpu->hvffd, HVX86RDX, rdx); macvmsetrip(cpu, rip + inslen); break; } case EXITREASONXSETBV: { X86CPU *x86cpu = X86CPU(cpu); CPUX86State *env = &x86cpu->env; uint32t eax = (uint32t)rreg(cpu->hvffd, HVX86RAX); uint32t ecx = (uint32t)rreg(cpu->hvffd, HVX86RCX); uint32t edx = (uint32t)rreg(cpu->hvffd, HVX86RDX); if (ecx) { macvmsetrip(cpu, rip + inslen); break; } env->xcr0 = ((uint64t)edx << 32) | eax; wreg(cpu->hvffd, HVX86XCR0, env->xcr0 | 1); macvmsetrip(cpu, rip + inslen); break; } case EXITREASONINTRWINDOW: vmxclearintwindowexiting(cpu); ret = EXCPINTERRUPT; break; case EXITREASONNMIWINDOW: vmxclearnmiwindowexiting(cpu); ret = EXCPINTERRUPT; break; case EXITREASONEXTINTR: /* force exit and allow io handling */ ret = EXCPINTERRUPT; break; case EXITREASONRDMSR: case EXITREASONWRMSR: { loadregs(cpu); if (exitreason == EXITREASONRDMSR) { simulaterdmsr(cpu); } else { simulatewrmsr(cpu); } RIP(env) += rvmcs(cpu->hvffd, VMCSEXITINSTRUCTIONLENGTH); storeregs(cpu); break; } case EXITREASONCRACCESS: { int cr; int reg; loadregs(cpu); cr = exitqual & 15; reg = (exitqual >> 8) & 15; switch (cr) { case 0x0: { macvmsetcr0(cpu->hvffd, RRX(env, reg)); break; } case 4: { macvmsetcr4(cpu->hvffd, RRX(env, reg)); break; } case 8: { X86CPU *x86cpu = X86CPU(cpu); if (exitqual & 0x10) { RRX(env, reg) = cpugetapictpr(x86cpu->apicstate); } else { int tpr = RRX(env, reg); cpusetapictpr(x86cpu->apicstate, tpr); ret = EXCPINTERRUPT; } break; } default: errorreport(\"Unrecognized CR %d\\n\", cr); abort(); } RIP(env) += inslen; storeregs(cpu); break; } case EXITREASONAPICACCESS: { /* TODO */ struct x86decode decode; loadregs(cpu); env->hvfemul->fetchrip = rip; decodeinstruction(env, &decode); execinstruction(env, &decode); storeregs(cpu); break; } case EXITREASONTPR: { ret = 1; break; } case EXITREASONTASKSWITCH: { uint64t vinfo = rvmcs(cpu->hvffd, VMCSIDTVECTORINGINFO); x68segmentselector sel = {.sel = exitqual & 0xffff}; vmxhandletaskswitch(cpu, sel, (exitqual >> 30) & 0x3, vinfo & VMCSINTRVALID, vinfo & VECTORINGINFOVECTORMASK, vinfo & VMCSINTRTMASK); break; } case EXITREASONTRIPLEFAULT: { qemusystemresetrequest(SHUTDOWNCAUSEGUESTRESET); ret = EXCPINTERRUPT; break; } case EXITREASONRDPMC: wreg(cpu->hvffd, HVX86RAX, 0); wreg(cpu->hvffd, HVX86RDX, 0); macvmsetrip(cpu, rip + inslen); break; case VMXREASONVMCALL: /* TODO: inject #GP fault */ break; default: errorreport(\"%llx: unhandled exit %llx\\n\", rip, exitreason); } } while (ret == 0); return ret; } ", "target": 1}
{"func": "int intelh263decodepictureheader(MpegEncContext *s) { int format; /* picture header */ if (getbitslong(&s->gb, 22) != 0x20) { avlog(s->avctx, AVLOGERROR, \"Bad picture start code\\n\"); return -1; } s->picturenumber = getbits(&s->gb, 8); /* picture timestamp */ if (getbits1(&s->gb) != 1) { avlog(s->avctx, AVLOGERROR, \"Bad marker\\n\"); return -1;\t/* marker */ } if (getbits1(&s->gb) != 0) { avlog(s->avctx, AVLOGERROR, \"Bad H263 id\\n\"); return -1;\t/* h263 id */ } skipbits1(&s->gb);\t/* split screen off */ skipbits1(&s->gb);\t/* camera off */ skipbits1(&s->gb);\t/* freeze picture release off */ format = getbits(&s->gb, 3); if (format != 7) { avlog(s->avctx, AVLOGERROR, \"Intel H263 free format not supported\\n\"); return -1; } s->h263plus = 0; s->picttype = ITYPE + getbits1(&s->gb); s->unrestrictedmv = getbits1(&s->gb); s->h263longvectors = s->unrestrictedmv; if (getbits1(&s->gb) != 0) { avlog(s->avctx, AVLOGERROR, \"SAC not supported\\n\"); return -1;\t/* SAC: off */ } if (getbits1(&s->gb) != 0) { s->obmc= 1; avlog(s->avctx, AVLOGERROR, \"Advanced Prediction Mode not supported\\n\"); // return -1;\t/* advanced prediction mode: off */ } if (getbits1(&s->gb) != 0) { avlog(s->avctx, AVLOGERROR, \"PB frame mode no supported\\n\"); return -1;\t/* PB frame mode */ } /* skip unknown header garbage */ skipbits(&s->gb, 41); s->qscale = getbits(&s->gb, 5); skipbits1(&s->gb);\t/* Continuous Presence Multipoint mode: off */ /* PEI */ while (getbits1(&s->gb) != 0) { skipbits(&s->gb, 8); } s->fcode = 1; s->ydcscaletable= s->cdcscaletable= ffmpeg1dcscaletable; return 0; } ", "target": 0}
{"func": "int bdrvpwrite(BlockDriverState *bs, int64t offset, const void *buf1, int count1) { BlockDriver *drv = bs->drv; if (!drv) return -ENOMEDIUM; if (!drv->bdrvpwrite) return bdrvpwriteem(bs, offset, buf1, count1); if (bdrvwrbadreqbytes(bs, offset, count1)) return -EDOM; return drv->bdrvpwrite(bs, offset, buf1, count1); } ", "target": 1}
{"func": "static int localtruncate(FsContext *ctx, V9fsPath *fspath, offt size) { char *buffer; int ret; char *path = fspath->data; buffer = rpath(ctx, path); ret = truncate(buffer, size); gfree(buffer); return ret; } ", "target": 1}
{"func": "void uuidunparse(const uuidt uu, char *out) { snprintf(out, 37, UUIDFMT, uu[0], uu[1], uu[2], uu[3], uu[4], uu[5], uu[6], uu[7], uu[8], uu[9], uu[10], uu[11], uu[12], uu[13], uu[14], uu[15]); } ", "target": 0}
{"func": "static int stellarisenetcanreceive(void *opaque) { stellarisenetstate *s = (stellarisenetstate *)opaque; if ((s->rctl & SERCTLRXEN) == 0) return 1; return (s->np < 31); } ", "target": 0}
{"func": "void acpimemoryunplugcb(MemHotplugState *memst, DeviceState *dev, Error **errp) { MemStatus *mdev; mdev = acpimemoryslotstatus(memst, dev, errp); if (!mdev) { return; } /* nvdimm device hot unplug is not supported yet. */ assert(!objectdynamiccast(OBJECT(dev), TYPENVDIMM)); mdev->isenabled = false; mdev->dimm = NULL; } ", "target": 0}
{"func": "allocf(int argc, char **argv) { \tint64t offset; \tint nbsectors; \tchar s1[64]; \tint num; \tint ret; \tconst char *retstr; \toffset = cvtnum(argv[1]); \tif (offset & 0x1ff) { \t\tprintf(\"offset %lld is not sector aligned\\n\", \t\t\t(long long)offset); \t\treturn 0; \t} \tif (argc == 3) \t\tnbsectors = cvtnum(argv[2]); \telse \t\tnbsectors = 1; \tret = bdrvisallocated(bs, offset >> 9, nbsectors, &num); \tcvtstr(offset, s1, sizeof(s1)); \tretstr = ret ? \"allocated\" : \"not allocated\"; \tif (nbsectors == 1) \t\tprintf(\"sector %s at offset %s\\n\", retstr, s1); \telse \t\tprintf(\"%d/%d sectors %s at offset %s\\n\", \t\t\tnum, nbsectors, retstr, s1); \treturn 0; } ", "target": 0}
{"func": "static void hmpcontcb(void *opaque, int err) { if (!err) { qmpcont(NULL); } } ", "target": 1}
{"func": "static int megasasctrlgetinfo(MegasasState *s, MegasasCmd *cmd) { PCIDevice *pcidev = PCIDEVICE(s); PCIDeviceClass *pciclass = PCIDEVICEGETCLASS(pcidev); MegasasBaseClass *baseclass = MEGASASDEVICEGETCLASS(s); struct mfictrlinfo info; sizet dcmdsize = sizeof(info); BusChild *kid; int numpddisks = 0; memset(&info, 0x0, cmd->iovsize); if (cmd->iovsize < dcmdsize) { tracemegasasdcmdinvalidxferlen(cmd->index, cmd->iovsize, dcmdsize); return MFISTATINVALIDPARAMETER; } info.pci.vendor = cputole16(pciclass->vendorid); info.pci.device = cputole16(pciclass->deviceid); info.pci.subvendor = cputole16(pciclass->subsystemvendorid); info.pci.subdevice = cputole16(pciclass->subsystemid); /* * For some reason the firmware supports * only up to 8 device ports. * Despite supporting a far larger number * of devices for the physical devices. * So just display the first 8 devices * in the device port list, independent * of how many logical devices are actually * present. */ info.host.type = MFIINFOHOSTPCIE; info.device.type = MFIINFODEVSAS3G; info.device.portcount = 8; QTAILQFOREACH(kid, &s->bus.qbus.children, sibling) { SCSIDevice *sdev = DOUPCAST(SCSIDevice, qdev, kid->child); uint16t pdid; if (numpddisks < 8) { pdid = ((sdev->id & 0xFF) << 8) | (sdev->lun & 0xFF); info.device.portaddr[numpddisks] = cputole64(megasasgetsataaddr(pdid)); } numpddisks++; } memcpy(info.productname, baseclass->productname, 24); snprintf(info.serialnumber, 32, \"%s\", s->hbaserial); snprintf(info.packageversion, 0x60, \"%s-QEMU\", qemuhwversion()); memcpy(info.imagecomponent[0].name, \"APP\", 3); snprintf(info.imagecomponent[0].version, 10, \"%s-QEMU\", baseclass->productversion); memcpy(info.imagecomponent[0].builddate, \"Apr 1 2014\", 11); memcpy(info.imagecomponent[0].buildtime, \"12:34:56\", 8); info.imagecomponentcount = 1; if (pcidev->hasrom) { uint8t biosver[32]; uint8t *ptr; ptr = memoryregiongetramptr(&pcidev->rom); memcpy(biosver, ptr + 0x41, 31); memcpy(info.imagecomponent[1].name, \"BIOS\", 4); memcpy(info.imagecomponent[1].version, biosver, strlen((const char *)biosver)); info.imagecomponentcount++; } info.currentfwtime = cputole32(megasasfwtime()); info.maxarms = 32; info.maxspans = 8; info.maxarrays = MEGASASMAXARRAYS; info.maxlds = MFIMAXLD; info.maxcmds = cputole16(s->fwcmds); info.maxsgelements = cputole16(s->fwsge); info.maxrequestsize = cputole32(MEGASASMAXSECTORS); if (!megasasisjbod(s)) info.ldspresent = cputole16(numpddisks); info.pdpresent = cputole16(numpddisks); info.pddiskspresent = cputole16(numpddisks); info.hwpresent = cputole32(MFIINFOHWNVRAM | MFIINFOHWMEM | MFIINFOHWFLASH); info.memorysize = cputole16(512); info.nvramsize = cputole16(32); info.flashsize = cputole16(16); info.raidlevels = cputole32(MFIINFORAID0); info.adapterops = cputole32(MFIINFOAOPSRBLDRATE | MFIINFOAOPSSELFDIAGNOSTIC | MFIINFOAOPSMIXEDARRAY); info.ldops = cputole32(MFIINFOLDOPSDISKCACHEPOLICY | MFIINFOLDOPSACCESSPOLICY | MFIINFOLDOPSIOPOLICY | MFIINFOLDOPSWRITEPOLICY | MFIINFOLDOPSREADPOLICY); info.maxstripsperio = cputole16(s->fwsge); info.stripeszops.min = 3; info.stripeszops.max = ctz32(MEGASASMAXSECTORS + 1); info.properties.predfailpollinterval = cputole16(300); info.properties.intrthrottlecnt = cputole16(16); info.properties.intrthrottletimeout = cputole16(50); info.properties.rebuildrate = 30; info.properties.patrolreadrate = 30; info.properties.bgirate = 30; info.properties.ccrate = 30; info.properties.reconrate = 30; info.properties.cacheflushinterval = 4; info.properties.spinupdrvcnt = 2; info.properties.spinupdelay = 6; info.properties.eccbucketsize = 15; info.properties.eccbucketleakrate = cputole16(1440); info.properties.exposeencldevices = 1; info.properties.OnOffProperties = cputole32(MFICTRLPROPEnableJBOD); info.pdops = cputole32(MFIINFOPDOPSFORCEONLINE | MFIINFOPDOPSFORCEOFFLINE); info.pdmixsupport = cputole32(MFIINFOPDMIXSAS | MFIINFOPDMIXSATA | MFIINFOPDMIXLD); cmd->iovsize -= dmabufread((uint8t *)&info, dcmdsize, &cmd->qsg); return MFISTATOK; } ", "target": 1}
{"func": "int ffthreadvideoencodeframe(AVCodecContext *avctx, AVPacket *pkt, const AVFrame *frame, int *gotpacketptr){ ThreadContext *c = avctx->internal->framethreadencoder; Task task; int ret; avassert1(!*gotpacketptr); if(frame){ if(!(avctx->flags & CODECFLAGINPUTPRESERVED)){ AVFrame *new = avcodecallocframe(); if(!new) return AVERROR(ENOMEM); pthreadmutexlock(&c->buffermutex); ret = c->parentavctx->getbuffer(c->parentavctx, new); pthreadmutexunlock(&c->buffermutex); if(ret<0) return ret; new->pts = frame->pts; new->quality = frame->quality; new->picttype = frame->picttype; avimagecopy(new->data, new->linesize, (const uint8t **)frame->data, frame->linesize, avctx->pixfmt, avctx->width, avctx->height); frame = new; } task.index = c->taskindex; task.indata = (void*)frame; pthreadmutexlock(&c->taskfifomutex); avfifogenericwrite(c->taskfifo, &task, sizeof(task), NULL); pthreadcondsignal(&c->taskfifocond); pthreadmutexunlock(&c->taskfifomutex); c->taskindex = (c->taskindex+1) % BUFFERSIZE; if(!c->finishedtasks[c->finishedtaskindex].outdata && (c->taskindex - c->finishedtaskindex) % BUFFERSIZE <= avctx->threadcount) return 0; } if(c->taskindex == c->finishedtaskindex) return 0; pthreadmutexlock(&c->finishedtaskmutex); while (!c->finishedtasks[c->finishedtaskindex].outdata) { pthreadcondwait(&c->finishedtaskcond, &c->finishedtaskmutex); } task = c->finishedtasks[c->finishedtaskindex]; *pkt = *(AVPacket*)(task.outdata); avfreep(&c->finishedtasks[c->finishedtaskindex].outdata); c->finishedtaskindex = (c->finishedtaskindex+1) % BUFFERSIZE; pthreadmutexunlock(&c->finishedtaskmutex); *gotpacketptr = 1; return task.returncode; } ", "target": 1}
{"func": "int vmstateloadstate(QEMUFile *f, const VMStateDescription *vmsd, void *opaque, int versionid) { VMStateField *field = vmsd->fields; if (versionid > vmsd->versionid) { return -EINVAL; } if (versionid < vmsd->minimumversionidold) { return -EINVAL; } if (versionid < vmsd->minimumversionid) { return vmsd->loadstateold(f, opaque, versionid); } while(field->name) { if (field->versionid <= versionid) { void *baseaddr = opaque + field->offset; int ret, i, nelems = 1; if (field->flags & VMSARRAY) { nelems = field->num; } else if (field->flags & VMSVARRAY) { nelems = *(sizet *)(opaque+field->numoffset); } if (field->flags & VMSPOINTER) { baseaddr = *(void **)baseaddr; } for (i = 0; i < nelems; i++) { void *addr = baseaddr + field->size * i; if (field->flags & VMSSTRUCT) { ret = vmstateloadstate(f, field->vmsd, addr, versionid); } else { ret = field->info->get(f, addr, field->size); } if (ret < 0) { return ret; } } } field++; } if (vmsd->runafterload) return vmsd->runafterload(opaque); return 0; } ", "target": 0}
{"func": "static void tcgoutsetcond2(TCGContext *s, TCGCond cond, TCGReg ret, TCGReg al, TCGReg ah, TCGReg bl, TCGReg bh) { TCGReg tmp0 = TCGTMP0; TCGReg tmp1 = ret; assert(ret != TCGTMP0); if (ret == ah || ret == bh) { assert(ret != TCGTMP1); tmp1 = TCGTMP1; } switch (cond) { case TCGCONDEQ: case TCGCONDNE: tmp1 = tcgoutreduceeq2(s, tmp0, tmp1, al, ah, bl, bh); tcgoutsetcond(s, cond, ret, tmp1, TCGREGZERO); break; default: tcgoutsetcond(s, TCGCONDEQ, tmp0, ah, bh); tcgoutsetcond(s, tcgunsignedcond(cond), tmp1, al, bl); tcgoutopcreg(s, OPCAND, tmp1, tmp1, tmp0); tcgoutsetcond(s, tcghighcond(cond), tmp0, ah, bh); tcgoutopcreg(s, OPCOR, ret, tmp1, tmp0); break; } } ", "target": 0}
{"func": "static void displaymousedefine(DisplayChangeListener *dcl, QEMUCursor *c) { SimpleSpiceDisplay *ssd = containerof(dcl, SimpleSpiceDisplay, dcl); qemumutexlock(&ssd->lock); if (c) { cursorget(c); } cursorput(ssd->cursor); ssd->cursor = c; ssd->hotx = c->hotx; ssd->hoty = c->hoty; gfree(ssd->ptrmove); ssd->ptrmove = NULL; gfree(ssd->ptrdefine); ssd->ptrdefine = qemuspicecreatecursorupdate(ssd, c, 0); qemumutexunlock(&ssd->lock); } ", "target": 0}
{"func": "static inline void stwphysinternal(hwaddr addr, uint32t val, enum deviceendian endian) { uint8t *ptr; MemoryRegionSection *section; section = physpagefind(addressspacememory.dispatch, addr >> TARGETPAGEBITS); if (!memoryregionisram(section->mr) || section->readonly) { addr = memoryregionsectionaddr(section, addr); if (memoryregionisram(section->mr)) { section = &physsections[physsectionrom]; } #if defined(TARGETWORDSBIGENDIAN) if (endian == DEVICELITTLEENDIAN) { val = bswap16(val); } #else if (endian == DEVICEBIGENDIAN) { val = bswap16(val); } #endif iomemwrite(section->mr, addr, val, 2); } else { unsigned long addr1; addr1 = (memoryregiongetramaddr(section->mr) & TARGETPAGEMASK) + memoryregionsectionaddr(section, addr); /* RAM case */ ptr = qemugetramptr(addr1); switch (endian) { case DEVICELITTLEENDIAN: stwlep(ptr, val); break; case DEVICEBIGENDIAN: stwbep(ptr, val); break; default: stwp(ptr, val); break; } invalidateandsetdirty(addr1, 2); } } ", "target": 0}
{"func": "static void computescalefactors(unsigned char scalecode[SBLIMIT], unsigned char scalefactors[SBLIMIT][3], int sbsamples[3][12][SBLIMIT], int sblimit) { int *p, vmax, v, n, i, j, k, code; int index, d1, d2; unsigned char *sf = &scalefactors[0][0]; for(j=0;j<sblimit;j++) { for(i=0;i<3;i++) { /* find the max absolute value */ p = &sbsamples[i][0][j]; vmax = abs(*p); for(k=1;k<12;k++) { p += SBLIMIT; v = abs(*p); if (v > vmax) vmax = v; } /* compute the scale factor index using log 2 computations */ if (vmax > 0) { n = avlog2(vmax); /* n is the position of the MSB of vmax. now use at most 2 compares to find the index */ index = (21 - n) * 3 - 3; if (index >= 0) { while (vmax <= scalefactortable[index+1]) index++; } else { index = 0; /* very unlikely case of overflow */ } } else { index = 63; } #if 0 printf(\"%2d:%d in=%x %x %d\\n\", j, i, vmax, scalefactortable[index], index); #endif /* store the scale factor */ assert(index >=0 && index <= 63); sf[i] = index; } /* compute the transmission factor : look if the scale factors are close enough to each other */ d1 = scaledifftable[sf[0] - sf[1] + 64]; d2 = scaledifftable[sf[1] - sf[2] + 64]; /* handle the 25 cases */ switch(d1 * 5 + d2) { case 0*5+0: case 0*5+4: case 3*5+4: case 4*5+0: case 4*5+4: code = 0; break; case 0*5+1: case 0*5+2: case 4*5+1: case 4*5+2: code = 3; sf[2] = sf[1]; break; case 0*5+3: case 4*5+3: code = 3; sf[1] = sf[2]; break; case 1*5+0: case 1*5+4: case 2*5+4: code = 1; sf[1] = sf[0]; break; case 1*5+1: case 1*5+2: case 2*5+0: case 2*5+1: case 2*5+2: code = 2; sf[1] = sf[2] = sf[0]; break; case 2*5+3: case 3*5+3: code = 2; sf[0] = sf[1] = sf[2]; break; case 3*5+0: case 3*5+1: case 3*5+2: code = 2; sf[0] = sf[2] = sf[1]; break; case 1*5+3: code = 2; if (sf[0] > sf[2]) sf[0] = sf[2]; sf[1] = sf[2] = sf[0]; break; default: abort(); } #if 0 printf(\"%d: %2d %2d %2d %d %d -> %d\\n\", j, sf[0], sf[1], sf[2], d1, d2, code); #endif scalecode[j] = code; sf += 3; } } ", "target": 1}
{"func": "static void optnewstream(const char *opt, const char *arg) { AVFormatContext *oc; if (nboutputfiles <= 0) { fprintf(stderr, \"At least one output file must be specified\\n\"); ffmpegexit(1); } oc = outputfiles[nboutputfiles - 1]; if (!strcmp(opt, \"newvideo\" )) newvideostream (oc); else if (!strcmp(opt, \"newaudio\" )) newaudiostream (oc); else if (!strcmp(opt, \"newsubtitle\")) newsubtitlestream(oc); else assert(0); } ", "target": 0}
{"func": "static inline void RENAME(yuy2toyv12)(const uint8t *src, uint8t *ydst, uint8t *udst, uint8t *vdst, \tunsigned int width, unsigned int height, \tint lumStride, int chromStride, int srcStride) { \tunsigned y; \tconst unsigned chromWidth= width>>1; \tfor(y=0; y<height; y+=2) \t{ #ifdef HAVEMMX \t\tasm volatile( \t\t\t\"xor %%\"REGa\", %%\"REGa\"\t\\n\\t\" \t\t\t\"pcmpeqw %%mm7, %%mm7\t\t\\n\\t\" \t\t\t\"psrlw $8, %%mm7\t\t\\n\\t\" // FF,00,FF,00... \t\t\t\".balign 16\t\t\t\\n\\t\" \t\t\t\"1:\t\t\t\t\\n\\t\" \t\t\tPREFETCH\" 64(%0, %%\"REGa\", 4)\t\\n\\t\" \t\t\t\"movq (%0, %%\"REGa\", 4), %%mm0\t\\n\\t\" // YUYV YUYV(0) \t\t\t\"movq 8(%0, %%\"REGa\", 4), %%mm1\\n\\t\" // YUYV YUYV(4) \t\t\t\"movq %%mm0, %%mm2\t\t\\n\\t\" // YUYV YUYV(0) \t\t\t\"movq %%mm1, %%mm3\t\t\\n\\t\" // YUYV YUYV(4) \t\t\t\"psrlw $8, %%mm0\t\t\\n\\t\" // U0V0 U0V0(0) \t\t\t\"psrlw $8, %%mm1\t\t\\n\\t\" // U0V0 U0V0(4) \t\t\t\"pand %%mm7, %%mm2\t\t\\n\\t\" // Y0Y0 Y0Y0(0) \t\t\t\"pand %%mm7, %%mm3\t\t\\n\\t\" // Y0Y0 Y0Y0(4) \t\t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\" // UVUV UVUV(0) \t\t\t\"packuswb %%mm3, %%mm2\t\t\\n\\t\" // YYYY YYYY(0) \t\t\tMOVNTQ\" %%mm2, (%1, %%\"REGa\", 2)\\n\\t\" \t\t\t\"movq 16(%0, %%\"REGa\", 4), %%mm1\\n\\t\" // YUYV YUYV(8) \t\t\t\"movq 24(%0, %%\"REGa\", 4), %%mm2\\n\\t\" // YUYV YUYV(12) \t\t\t\"movq %%mm1, %%mm3\t\t\\n\\t\" // YUYV YUYV(8) \t\t\t\"movq %%mm2, %%mm4\t\t\\n\\t\" // YUYV YUYV(12) \t\t\t\"psrlw $8, %%mm1\t\t\\n\\t\" // U0V0 U0V0(8) \t\t\t\"psrlw $8, %%mm2\t\t\\n\\t\" // U0V0 U0V0(12) \t\t\t\"pand %%mm7, %%mm3\t\t\\n\\t\" // Y0Y0 Y0Y0(8) \t\t\t\"pand %%mm7, %%mm4\t\t\\n\\t\" // Y0Y0 Y0Y0(12) \t\t\t\"packuswb %%mm2, %%mm1\t\t\\n\\t\" // UVUV UVUV(8) \t\t\t\"packuswb %%mm4, %%mm3\t\t\\n\\t\" // YYYY YYYY(8) \t\t\tMOVNTQ\" %%mm3, 8(%1, %%\"REGa\", 2)\\n\\t\" \t\t\t\"movq %%mm0, %%mm2\t\t\\n\\t\" // UVUV UVUV(0) \t\t\t\"movq %%mm1, %%mm3\t\t\\n\\t\" // UVUV UVUV(8) \t\t\t\"psrlw $8, %%mm0\t\t\\n\\t\" // V0V0 V0V0(0) \t\t\t\"psrlw $8, %%mm1\t\t\\n\\t\" // V0V0 V0V0(8) \t\t\t\"pand %%mm7, %%mm2\t\t\\n\\t\" // U0U0 U0U0(0) \t\t\t\"pand %%mm7, %%mm3\t\t\\n\\t\" // U0U0 U0U0(8) \t\t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\" // VVVV VVVV(0) \t\t\t\"packuswb %%mm3, %%mm2\t\t\\n\\t\" // UUUU UUUU(0) \t\t\tMOVNTQ\" %%mm0, (%3, %%\"REGa\")\t\\n\\t\" \t\t\tMOVNTQ\" %%mm2, (%2, %%\"REGa\")\t\\n\\t\" \t\t\t\"add $8, %%\"REGa\"\t\t\\n\\t\" \t\t\t\"cmp %4, %%\"REGa\"\t\t\\n\\t\" \t\t\t\" jb 1b\t\t\t\t\\n\\t\" \t\t\t::\"r\"(src), \"r\"(ydst), \"r\"(udst), \"r\"(vdst), \"g\" ((long)chromWidth) \t\t\t: \"memory\", \"%\"REGa \t\t); \t\tydst += lumStride; \t\tsrc += srcStride; \t\tasm volatile( \t\t\t\"xor %%\"REGa\", %%\"REGa\"\t\\n\\t\" \t\t\t\".balign 16\t\t\t\\n\\t\" \t\t\t\"1:\t\t\t\t\\n\\t\" \t\t\tPREFETCH\" 64(%0, %%\"REGa\", 4)\t\\n\\t\" \t\t\t\"movq (%0, %%\"REGa\", 4), %%mm0\t\\n\\t\" // YUYV YUYV(0) \t\t\t\"movq 8(%0, %%\"REGa\", 4), %%mm1\\n\\t\" // YUYV YUYV(4) \t\t\t\"movq 16(%0, %%\"REGa\", 4), %%mm2\\n\\t\" // YUYV YUYV(8) \t\t\t\"movq 24(%0, %%\"REGa\", 4), %%mm3\\n\\t\" // YUYV YUYV(12) \t\t\t\"pand %%mm7, %%mm0\t\t\\n\\t\" // Y0Y0 Y0Y0(0) \t\t\t\"pand %%mm7, %%mm1\t\t\\n\\t\" // Y0Y0 Y0Y0(4) \t\t\t\"pand %%mm7, %%mm2\t\t\\n\\t\" // Y0Y0 Y0Y0(8) \t\t\t\"pand %%mm7, %%mm3\t\t\\n\\t\" // Y0Y0 Y0Y0(12) \t\t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\" // YYYY YYYY(0) \t\t\t\"packuswb %%mm3, %%mm2\t\t\\n\\t\" // YYYY YYYY(8) \t\t\tMOVNTQ\" %%mm0, (%1, %%\"REGa\", 2)\\n\\t\" \t\t\tMOVNTQ\" %%mm2, 8(%1, %%\"REGa\", 2)\\n\\t\" \t\t\t\"add $8, %%\"REGa\"\t\t\\n\\t\" \t\t\t\"cmp %4, %%\"REGa\"\t\t\\n\\t\" \t\t\t\" jb 1b\t\t\t\t\\n\\t\" \t\t\t::\"r\"(src), \"r\"(ydst), \"r\"(udst), \"r\"(vdst), \"g\" ((long)chromWidth) \t\t\t: \"memory\", \"%\"REGa \t\t); #else \t\tunsigned i; \t\tfor(i=0; i<chromWidth; i++) \t\t{ \t\t\tydst[2*i+0] \t= src[4*i+0]; \t\t\tudst[i] \t= src[4*i+1]; \t\t\tydst[2*i+1] \t= src[4*i+2]; \t\t\tvdst[i] \t= src[4*i+3]; \t\t} \t\tydst += lumStride; \t\tsrc += srcStride; \t\tfor(i=0; i<chromWidth; i++) \t\t{ \t\t\tydst[2*i+0] \t= src[4*i+0]; \t\t\tydst[2*i+1] \t= src[4*i+2]; \t\t} #endif \t\tudst += chromStride; \t\tvdst += chromStride; \t\tydst += lumStride; \t\tsrc += srcStride; \t} #ifdef HAVEMMX asm volatile( EMMS\" \\n\\t\" \tSFENCE\" \\n\\t\" \t:::\"memory\"); #endif } ", "target": 1}
{"func": "static int hufuncompress(GetByteContext *gb, uint16t *dst, int dstsize) { int32t srcsize, im, iM; uint32t nBits; uint64t *freq; HufDec *hdec; int ret, i; srcsize = bytestream2getle32(gb); im = bytestream2getle32(gb); iM = bytestream2getle32(gb); bytestream2skip(gb, 4); nBits = bytestream2getle32(gb); if (im < 0 || im >= HUFENCSIZE || iM < 0 || iM >= HUFENCSIZE || srcsize < 0) return AVERRORINVALIDDATA; bytestream2skip(gb, 4); freq = avcalloc(HUFENCSIZE, sizeof(*freq)); hdec = avcalloc(HUFDECSIZE, sizeof(*hdec)); if (!freq || !hdec) { ret = AVERROR(ENOMEM); goto fail; } if ((ret = hufunpackenctable(gb, im, iM, freq)) < 0) goto fail; if (nBits > 8 * bytestream2getbytesleft(gb)) { ret = AVERRORINVALIDDATA; goto fail; } if ((ret = hufbuilddectable(freq, im, iM, hdec)) < 0) goto fail; ret = hufdecode(freq, hdec, gb, nBits, iM, dstsize, dst); fail: for (i = 0; i < HUFDECSIZE; i++) { if (hdec[i].p) avfreep(&hdec[i].p); } avfree(freq); avfree(hdec); return ret; } ", "target": 1}
{"func": "static int hevcframestart(HEVCContext *s) { HEVCLocalContext *lc = &s->HEVClc; int ret; memset(s->horizontalbs, 0, 2 * s->bswidth * (s->bsheight + 1)); memset(s->verticalbs, 0, 2 * s->bswidth * (s->bsheight + 1)); memset(s->cbfluma, 0, s->sps->mintbwidth * s->sps->mintbheight); memset(s->ispcm, 0, s->sps->minpuwidth * s->sps->minpuheight); lc->startoftilesx = 0; s->isdecoded = 0; if (s->pps->tilesenabledflag) lc->endoftilesx = s->pps->columnwidth[0] << s->sps->log2ctbsize; ret = ffhevcsetnewref(s, s->sps->saoenabled ? &s->saoframe : &s->frame, s->poc); if (ret < 0) goto fail; ret = ffhevcframerps(s); if (ret < 0) { avlog(s->avctx, AVLOGERROR, \"Error constructing the frame RPS.\\n\"); goto fail; } ret = setsidedata(s); if (ret < 0) goto fail; avframeunref(s->outputframe); ret = ffhevcoutputframe(s, s->outputframe, 0); if (ret < 0) goto fail; ffthreadfinishsetup(s->avctx); return 0; fail: if (s->ref) ffthreadreportprogress(&s->ref->tf, INTMAX, 0); s->ref = NULL; return ret; }", "target": 1}
{"func": "static int localopen2(FsContext *fsctx, V9fsPath *dirpath, const char *name, int flags, FsCred *credp, V9fsFidOpenState *fs) { char *path; int fd = -1; int err = -1; int serrno = 0; V9fsString fullname; char *buffer; /* * Mark all the open to not follow symlinks */ flags |= ONOFOLLOW; v9fsstringinit(&fullname); v9fsstringsprintf(&fullname, \"%s/%s\", dirpath->data, name); path = fullname.data; /* Determine the security model */ if (fsctx->exportflags & V9FSSMMAPPED) { buffer = rpath(fsctx, path); fd = open(buffer, flags, SMLOCALMODEBITS); if (fd == -1) { gfree(buffer); err = fd; goto out; } credp->fcmode = credp->fcmode|SIFREG; /* Set cleint credentials in xattr */ err = localsetxattr(buffer, credp); if (err == -1) { serrno = errno; goto errend; } } else if (fsctx->exportflags & V9FSSMMAPPEDFILE) { buffer = rpath(fsctx, path); fd = open(buffer, flags, SMLOCALMODEBITS); if (fd == -1) { gfree(buffer); err = fd; goto out; } credp->fcmode = credp->fcmode|SIFREG; /* Set client credentials in .virtfsmetadata directory files */ err = localsetmappedfileattr(fsctx, path, credp); if (err == -1) { serrno = errno; goto errend; } } else if ((fsctx->exportflags & V9FSSMPASSTHROUGH) || (fsctx->exportflags & V9FSSMNONE)) { buffer = rpath(fsctx, path); fd = open(buffer, flags, credp->fcmode); if (fd == -1) { gfree(buffer); err = fd; goto out; } err = localpostcreatepassthrough(fsctx, path, credp); if (err == -1) { serrno = errno; goto errend; } } err = fd; fs->fd = fd; goto out; errend: close(fd); remove(buffer); errno = serrno; gfree(buffer); out: v9fsstringfree(&fullname); return err; } ", "target": 1}
{"func": "static void fixcodingmethodarray (int sb, int channels, sbint8array codingmethod) { int j,k; int ch; int run, caseval; int switchtable[23] = {0,5,1,5,5,5,5,5,2,5,5,5,5,5,5,5,3,5,5,5,5,5,4}; for (ch = 0; ch < channels; ch++) { for (j = 0; j < 64; ) { if((codingmethod[ch][sb][j] - 8) > 22) { run = 1; caseval = 8; } else { switch (switchtable[codingmethod[ch][sb][j]]) { case 0: run = 10; caseval = 10; break; case 1: run = 1; caseval = 16; break; case 2: run = 5; caseval = 24; break; case 3: run = 3; caseval = 30; break; case 4: run = 1; caseval = 30; break; case 5: run = 1; caseval = 8; break; default: run = 1; caseval = 8; break; } } for (k = 0; k < run; k++) if (j + k < 128) if (codingmethod[ch][sb + (j + k) / 64][(j + k) % 64] > codingmethod[ch][sb][j]) if (k > 0) { SAMPLESNEEDED //not debugged, almost never used memset(&codingmethod[ch][sb][j + k], caseval, k * sizeof(int8t)); memset(&codingmethod[ch][sb][j + k], caseval, 3 * sizeof(int8t)); } j += run; } } } ", "target": 1}
{"func": "static void genmtdcrx(DisasContext *ctx) { #if defined(CONFIGUSERONLY) geninvalexception(ctx, POWERPCEXCPPRIVREG); #else if (unlikely(ctx->pr)) { geninvalexception(ctx, POWERPCEXCPPRIVREG); return; } /* NIP cannot be restored if the memory exception comes from an helper */ genupdatenip(ctx, ctx->nip - 4); genhelperstoredcr(cpuenv, cpugpr[rA(ctx->opcode)], cpugpr[rS(ctx->opcode)]); /* Note: Rc update flag set leads to undefined state of Rc0 */ #endif } ", "target": 1}
{"func": "int usbpacketmap(USBPacket *p, QEMUSGList *sgl) { int iswrite = (p->pid == USBTOKENIN); targetphysaddrt len; void *mem; int i; for (i = 0; i < sgl->nsg; i++) { len = sgl->sg[i].len; mem = cpuphysicalmemorymap(sgl->sg[i].base, &len, iswrite); if (!mem) { goto err; } qemuiovecadd(&p->iov, mem, len); if (len != sgl->sg[i].len) { goto err; } } return 0; err: usbpacketunmap(p); return -1; } ", "target": 1}
{"func": "static void getsensorevtstatus(IPMIBmcSim *ibs, uint8t *cmd, unsigned int cmdlen, uint8t *rsp, unsigned int *rsplen, unsigned int maxrsplen) { IPMISensor *sens; IPMICHECKCMDLEN(3); if ((cmd[2] > MAXSENSORS) || !IPMISENSORGETPRESENT(ibs->sensors + cmd[2])) { rsp[2] = IPMICCREQENTRYNOTPRESENT; return; } sens = ibs->sensors + cmd[2]; IPMIADDRSPDATA(sens->reading); IPMIADDRSPDATA(IPMISENSORGETRETSTATUS(sens)); IPMIADDRSPDATA(sens->assertstates & 0xff); IPMIADDRSPDATA((sens->assertstates >> 8) & 0xff); IPMIADDRSPDATA(sens->deassertstates & 0xff); IPMIADDRSPDATA((sens->deassertstates >> 8) & 0xff); } ", "target": 1}
{"func": "void ffmjpegencodemb(MpegEncContext *s, int16t block[12][64]) { int i; if (s->chromaformat == CHROMA444) { encodeblock(s, block[0], 0); encodeblock(s, block[2], 2); encodeblock(s, block[4], 4); encodeblock(s, block[8], 8); encodeblock(s, block[5], 5); encodeblock(s, block[9], 9); if (16*s->mbx+8 < s->width) { encodeblock(s, block[1], 1); encodeblock(s, block[3], 3); encodeblock(s, block[6], 6); encodeblock(s, block[10], 10); encodeblock(s, block[7], 7); encodeblock(s, block[11], 11); } } else { for(i=0;i<5;i++) { encodeblock(s, block[i], i); } if (s->chromaformat == CHROMA420) { encodeblock(s, block[5], 5); } else { encodeblock(s, block[6], 6); encodeblock(s, block[5], 5); encodeblock(s, block[7], 7); } } } ", "target": 0}
{"func": "int pteupdateflags(mmuctxt *ctx, targetulong *pte1p, int ret, int rw) { int store = 0; /* Update page flags */ if (!(*pte1p & 0x00000100)) { /* Update accessed flag */ *pte1p |= 0x00000100; store = 1; } if (!(*pte1p & 0x00000080)) { if (rw == 1 && ret == 0) { /* Update changed flag */ *pte1p |= 0x00000080; store = 1; } else { /* Force page fault for first write access */ ctx->prot &= ~PAGEWRITE; } } return store; } ", "target": 0}
{"func": "static void enabledevice(AcpiPciHpState *s, unsigned bsel, int slot) { s->acpipcihppcistatus[bsel].devicepresent |= (1U << slot); } ", "target": 0}
{"func": "void ffavgh264qpel16mc12msa(uint8t *dst, const uint8t *src, ptrdifft stride) { avclumamidhqrtandaverdst16wmsa(src - (2 * stride) - 2, stride, dst, stride, 16, 0); } ", "target": 0}
{"func": "int avparsecolor(uint8t *rgbacolor, const char *colorstring, int slen, void *logctx) { char *tail, colorstring2[128]; const ColorEntry *entry; int len, hexoffset = 0; if (colorstring[0] == '#') { hexoffset = 1; } else if (!strncmp(colorstring, \"0x\", 2)) hexoffset = 2; if (slen < 0) slen = strlen(colorstring); avstrlcpy(colorstring2, colorstring + hexoffset, FFMIN(slen-hexoffset+1, sizeof(colorstring2))); if ((tail = strchr(colorstring2, ALPHASEP))) *tail++ = 0; len = strlen(colorstring2); rgbacolor[3] = 255; if (!avstrcasecmp(colorstring2, \"random\") || !avstrcasecmp(colorstring2, \"bikeshed\")) { int rgba = avgetrandomseed(); rgbacolor[0] = rgba >> 24; rgbacolor[1] = rgba >> 16; rgbacolor[2] = rgba >> 8; rgbacolor[3] = rgba; } else if (hexoffset || strspn(colorstring2, \"0123456789ABCDEFabcdef\") == len) { char *tail; unsigned int rgba = strtoul(colorstring2, &tail, 16); if (*tail || (len != 6 && len != 8)) { avlog(logctx, AVLOGERROR, \"Invalid 0xRRGGBB[AA] color string: '%s'\\n\", colorstring2); return AVERROR(EINVAL); } if (len == 8) { rgbacolor[3] = rgba; rgba >>= 8; } rgbacolor[0] = rgba >> 16; rgbacolor[1] = rgba >> 8; rgbacolor[2] = rgba; } else { entry = bsearch(colorstring2, colortable, FFARRAYELEMS(colortable), sizeof(ColorEntry), colortablecompare); if (!entry) { avlog(logctx, AVLOGERROR, \"Cannot find color '%s'\\n\", colorstring2); return AVERROR(EINVAL); } memcpy(rgbacolor, entry->rgbcolor, 3); } if (tail) { unsigned long int alpha; const char *alphastring = tail; if (!strncmp(alphastring, \"0x\", 2)) { alpha = strtoul(alphastring, &tail, 16); } else { alpha = 255 * strtod(alphastring, &tail); } if (tail == alphastring || *tail || alpha > 255) { avlog(logctx, AVLOGERROR, \"Invalid alpha value specifier '%s' in '%s'\\n\", alphastring, colorstring); return AVERROR(EINVAL); } rgbacolor[3] = alpha; } return 0; } ", "target": 0}
{"func": "static int rawinactivate(BlockDriverState *bs) { int ret; uint64t perm = 0; uint64t shared = BLKPERMALL; ret = rawhandlepermlock(bs, RAWPLPREPARE, perm, shared, NULL); if (ret) { return ret; } rawhandlepermlock(bs, RAWPLCOMMIT, perm, shared, NULL); return 0; } ", "target": 0}
{"func": "static void qmpoutputtypeany(Visitor *v, const char *name, QObject **obj, Error **errp) { QmpOutputVisitor *qov = toqov(v); qobjectincref(*obj); qmpoutputaddobj(qov, name, *obj); } ", "target": 0}
{"func": "static int setupsigcontext(struct targetsigcontext *sc, CPUSH4State *regs, unsigned long mask) { int err = 0; int i; #define COPY(x) putuser(regs->x, &sc->sc##x) COPY(gregs[0]); COPY(gregs[1]); COPY(gregs[2]); COPY(gregs[3]); COPY(gregs[4]); COPY(gregs[5]); COPY(gregs[6]); COPY(gregs[7]); COPY(gregs[8]); COPY(gregs[9]); COPY(gregs[10]); COPY(gregs[11]); COPY(gregs[12]); COPY(gregs[13]); COPY(gregs[14]); COPY(gregs[15]); COPY(gbr); COPY(mach); COPY(macl); COPY(pr); COPY(sr); COPY(pc); #undef COPY for (i=0; i<16; i++) { putuser(regs->fregs[i], &sc->scfpregs[i]); } putuser(regs->fpscr, &sc->scfpscr); putuser(regs->fpul, &sc->scfpul); /* non-iBCS2 extensions.. */ putuser(mask, &sc->oldmask); return err; } ", "target": 0}
{"func": "static void vfiounmapbar(VFIODevice *vdev, int nr) { VFIOBAR *bar = &vdev->bars[nr]; if (!bar->size) { return; } vfiobarquirkteardown(vdev, nr); memoryregiondelsubregion(&bar->mem, &bar->mmapmem); munmap(bar->mmap, memoryregionsize(&bar->mmapmem)); if (vdev->msix && vdev->msix->tablebar == nr) { memoryregiondelsubregion(&bar->mem, &vdev->msix->mmapmem); munmap(vdev->msix->mmap, memoryregionsize(&vdev->msix->mmapmem)); } memoryregiondestroy(&bar->mem); }", "target": 1}
{"func": "static bool eptemulationfault(uint64t eptqual) { int read, write; /* EPT fault on an instruction fetch doesn't make sense here */ if (eptqual & EPTVIOLATIONINSTFETCH) { return false; } /* EPT fault must be a read fault or a write fault */ read = eptqual & EPTVIOLATIONDATAREAD ? 1 : 0; write = eptqual & EPTVIOLATIONDATAWRITE ? 1 : 0; if ((read | write) == 0) { return false; } /* * The EPT violation must have been caused by accessing a * guest-physical address that is a translation of a guest-linear * address. */ if ((eptqual & EPTVIOLATIONGLAVALID) == 0 || (eptqual & EPTVIOLATIONXLATVALID) == 0) { return false; } return true; } ", "target": 0}
{"func": "yuv2rgba64fullXctemplate(SwsContext *c, const int16t *lumFilter, const int32t **lumSrc, int lumFilterSize, const int16t *chrFilter, const int32t **chrUSrc, const int32t **chrVSrc, int chrFilterSize, const int32t **alpSrc, uint16t *dest, int dstW, int y, enum AVPixelFormat target, int hasAlpha, int eightbytes) { int i; int A = 0xffff<<14; for (i = 0; i < dstW; i++) { int j; int Y = -0x40000000; int U = -128 << 23; // 19 int V = -128 << 23; int R, G, B; for (j = 0; j < lumFilterSize; j++) { Y += lumSrc[j][i] * (unsigned)lumFilter[j]; } for (j = 0; j < chrFilterSize; j++) {; U += chrUSrc[j][i] * (unsigned)chrFilter[j]; V += chrVSrc[j][i] * (unsigned)chrFilter[j]; } if (hasAlpha) { A = -0x40000000; for (j = 0; j < lumFilterSize; j++) { A += alpSrc[j][i] * (unsigned)lumFilter[j]; } A >>= 1; A += 0x20002000; } // 8bit: 12+15=27; 16-bit: 12+19=31 Y >>= 14; // 10 Y += 0x10000; U >>= 14; V >>= 14; // 8bit: 27 -> 17bit, 16bit: 31 - 14 = 17bit Y -= c->yuv2rgbyoffset; Y *= c->yuv2rgbycoeff; Y += 1 << 13; // 21 // 8bit: 17 + 13bit = 30bit, 16bit: 17 + 13bit = 30bit R = V * c->yuv2rgbv2rcoeff; G = V * c->yuv2rgbv2gcoeff + U * c->yuv2rgbu2gcoeff; B = U * c->yuv2rgbu2bcoeff; // 8bit: 30 - 22 = 8bit, 16bit: 30bit - 14 = 16bit outputpixel(&dest[0], avclipuintp2(RB + Y, 30) >> 14); outputpixel(&dest[1], avclipuintp2( G + Y, 30) >> 14); outputpixel(&dest[2], avclipuintp2(BR + Y, 30) >> 14); if (eightbytes) { outputpixel(&dest[3], avclipuintp2(A, 30) >> 14); dest += 4; } else { dest += 3; } } } ", "target": 0}
{"func": "static void tcgoutqemuld(TCGContext *s, const TCGArg *args, int opc) { int addrregl, addrreg1, addrmeml; int dataregl, dataregh, datareg1, datareg2; int memindex, sbits; #if defined(CONFIGSOFTMMU) void *label1ptr, *label2ptr; int spargs; #endif #if TARGETLONGBITS == 64 # if defined(CONFIGSOFTMMU) uint8t *label3ptr; # endif int addrregh, addrreg2, addrmemh; #endif dataregl = *args++; if (opc == 3) dataregh = *args++; else dataregh = 0; addrregl = *args++; #if TARGETLONGBITS == 64 addrregh = *args++; #endif memindex = *args; sbits = opc & 3; if (opc == 3) { #if defined(TCGTARGETWORDSBIGENDIAN) datareg1 = dataregh; datareg2 = dataregl; #else datareg1 = dataregl; datareg2 = dataregh; #endif } else { datareg1 = dataregl; datareg2 = 0; } #if TARGETLONGBITS == 64 # if defined(TCGTARGETWORDSBIGENDIAN) addrreg1 = addrregh; addrreg2 = addrregl; addrmemh = 0; addrmeml = 4; # else addrreg1 = addrregl; addrreg2 = addrregh; addrmemh = 4; addrmeml = 0; # endif #else addrreg1 = addrregl; addrmeml = 0; #endif #if defined(CONFIGSOFTMMU) tcgoutopcsa(s, OPCSRL, TCGREGA0, addrregl, TARGETPAGEBITS - CPUTLBENTRYBITS); tcgoutopcimm(s, OPCANDI, TCGREGA0, TCGREGA0, (CPUTLBSIZE - 1) << CPUTLBENTRYBITS); tcgoutopcreg(s, OPCADDU, TCGREGA0, TCGREGA0, TCGAREG0); tcgoutopcimm(s, OPCLW, TCGREGAT, TCGREGA0, offsetof(CPUState, tlbtable[memindex][0].addrread) + addrmeml); tcgoutmovi(s, TCGTYPEI32, TCGREGT0, TARGETPAGEMASK | ((1 << sbits) - 1)); tcgoutopcreg(s, OPCAND, TCGREGT0, TCGREGT0, addrregl); # if TARGETLONGBITS == 64 label3ptr = s->codeptr; tcgoutopcimm(s, OPCBNE, TCGREGT0, TCGREGAT, 0); tcgoutnop(s); tcgoutopcimm(s, OPCLW, TCGREGAT, TCGREGA0, offsetof(CPUState, tlbtable[memindex][0].addrread) + addrmemh); label1ptr = s->codeptr; tcgoutopcimm(s, OPCBEQ, addrregh, TCGREGAT, 0); tcgoutnop(s); relocpc16(label3ptr, (tcgtargetlong) s->codeptr); # else label1ptr = s->codeptr; tcgoutopcimm(s, OPCBEQ, TCGREGT0, TCGREGAT, 0); tcgoutnop(s); # endif /* slow path */ spargs = TCGREGA0; tcgoutmov(s, spargs++, addrreg1); # if TARGETLONGBITS == 64 tcgoutmov(s, spargs++, addrreg2); # endif tcgoutmovi(s, TCGTYPEI32, spargs++, memindex); tcgoutmovi(s, TCGTYPEI32, TCGREGT9, (tcgtargetlong)qemuldhelpers[sbits]); tcgoutopcreg(s, OPCJALR, TCGREGRA, TCGREGT9, 0); tcgoutnop(s); switch(opc) { case 0: tcgoutopcimm(s, OPCANDI, datareg1, TCGREGV0, 0xff); break; case 0 | 4: tcgoutopcsa(s, OPCSLL, TCGREGV0, TCGREGV0, 24); tcgoutopcsa(s, OPCSRA, datareg1, TCGREGV0, 24); break; case 1: tcgoutopcimm(s, OPCANDI, datareg1, TCGREGV0, 0xffff); break; case 1 | 4: tcgoutopcsa(s, OPCSLL, TCGREGV0, TCGREGV0, 16); tcgoutopcsa(s, OPCSRA, datareg1, TCGREGV0, 16); break; case 2: tcgoutmov(s, datareg1, TCGREGV0); break; case 3: tcgoutmov(s, datareg2, TCGREGV1); tcgoutmov(s, datareg1, TCGREGV0); break; default: tcgabort(); } label2ptr = s->codeptr; tcgoutopcimm(s, OPCBEQ, TCGREGZERO, TCGREGZERO, 0); tcgoutnop(s); /* label1: fast path */ relocpc16(label1ptr, (tcgtargetlong) s->codeptr); tcgoutopcimm(s, OPCLW, TCGREGV0, TCGREGA0, offsetof(CPUState, tlbtable[memindex][0].addend) + addrmeml); tcgoutopcreg(s, OPCADDU, TCGREGV0, TCGREGV0, addrregl); addrreg1 = TCGREGV0; #endif switch(opc) { case 0: tcgoutopcimm(s, OPCLBU, datareg1, addrreg1, 0); break; case 0 | 4: tcgoutopcimm(s, OPCLB, datareg1, addrreg1, 0); break; case 1: if (TCGNEEDBSWAP) { tcgoutopcimm(s, OPCLHU, TCGREGT0, addrreg1, 0); tcgoutbswap16(s, datareg1, TCGREGT0); } else { tcgoutopcimm(s, OPCLHU, datareg1, addrreg1, 0); } break; case 1 | 4: if (TCGNEEDBSWAP) { tcgoutopcimm(s, OPCLHU, TCGREGT0, addrreg1, 0); tcgoutbswap16s(s, datareg1, TCGREGT0); } else { tcgoutopcimm(s, OPCLH, datareg1, addrreg1, 0); } break; case 2: if (TCGNEEDBSWAP) { tcgoutopcimm(s, OPCLW, TCGREGT0, addrreg1, 0); tcgoutbswap32(s, datareg1, TCGREGT0); } else { tcgoutopcimm(s, OPCLW, datareg1, addrreg1, 0); } break; case 3: #if !defined(CONFIGSOFTMMU) tcgoutmov(s, TCGREGV0, addrreg1); addrreg1 = TCGREGV0; #endif if (TCGNEEDBSWAP) { tcgoutopcimm(s, OPCLW, TCGREGT0, addrreg1, 4); tcgoutbswap32(s, datareg1, TCGREGT0); tcgoutopcimm(s, OPCLW, TCGREGT0, addrreg1, 0); tcgoutbswap32(s, datareg2, TCGREGT0); } else { tcgoutopcimm(s, OPCLW, datareg1, addrreg1, 0); tcgoutopcimm(s, OPCLW, datareg2, addrreg1, 4); } break; default: tcgabort(); } #if defined(CONFIGSOFTMMU) relocpc16(label2ptr, (tcgtargetlong) s->codeptr); #endif } ", "target": 1}
{"func": "static void deccalc(DisasContext *dc, uint32t insn) { uint32t op0, op1, op2; uint32t ra, rb, rd; op0 = extract32(insn, 0, 4); op1 = extract32(insn, 8, 2); op2 = extract32(insn, 6, 2); ra = extract32(insn, 16, 5); rb = extract32(insn, 11, 5); rd = extract32(insn, 21, 5); switch (op0) { case 0x0000: switch (op1) { case 0x00: /* l.add */ LOGDIS(\"l.add r%d, r%d, r%d\\n\", rd, ra, rb); { TCGLabel *lab = gennewlabel(); TCGvi64 ta = tcgtempnewi64(); TCGvi64 tb = tcgtempnewi64(); TCGvi64 td = tcgtemplocalnewi64(); TCGvi32 res = tcgtemplocalnewi32(); TCGvi32 srove = tcgtemplocalnewi32(); tcggenextui32i64(ta, cpuR[ra]); tcggenextui32i64(tb, cpuR[rb]); tcggenaddi64(td, ta, tb); tcggenextrli64i32(res, td); tcggenshrii64(td, td, 31); tcggenandii64(td, td, 0x3); /* Jump to lab when no overflow. */ tcggenbrcondii64(TCGCONDEQ, td, 0x0, lab); tcggenbrcondii64(TCGCONDEQ, td, 0x3, lab); tcggenorii32(cpusr, cpusr, (SROV | SRCY)); tcggenandii32(srove, cpusr, SROVE); tcggenbrcondii32(TCGCONDNE, srove, SROVE, lab); genexception(dc, EXCPRANGE); gensetlabel(lab); tcggenmovi32(cpuR[rd], res); tcgtempfreei64(ta); tcgtempfreei64(tb); tcgtempfreei64(td); tcgtempfreei32(res); tcgtempfreei32(srove); } break; default: genillegalexception(dc); break; } break; case 0x0001: /* l.addc */ switch (op1) { case 0x00: LOGDIS(\"l.addc r%d, r%d, r%d\\n\", rd, ra, rb); { TCGLabel *lab = gennewlabel(); TCGvi64 ta = tcgtempnewi64(); TCGvi64 tb = tcgtempnewi64(); TCGvi64 tcy = tcgtemplocalnewi64(); TCGvi64 td = tcgtemplocalnewi64(); TCGvi32 res = tcgtemplocalnewi32(); TCGvi32 srcy = tcgtemplocalnewi32(); TCGvi32 srove = tcgtemplocalnewi32(); tcggenextui32i64(ta, cpuR[ra]); tcggenextui32i64(tb, cpuR[rb]); tcggenandii32(srcy, cpusr, SRCY); tcggenextui32i64(tcy, srcy); tcggenshrii64(tcy, tcy, 10); tcggenaddi64(td, ta, tb); tcggenaddi64(td, td, tcy); tcggenextrli64i32(res, td); tcggenshrii64(td, td, 32); tcggenandii64(td, td, 0x3); /* Jump to lab when no overflow. */ tcggenbrcondii64(TCGCONDEQ, td, 0x0, lab); tcggenbrcondii64(TCGCONDEQ, td, 0x3, lab); tcggenorii32(cpusr, cpusr, (SROV | SRCY)); tcggenandii32(srove, cpusr, SROVE); tcggenbrcondii32(TCGCONDNE, srove, SROVE, lab); genexception(dc, EXCPRANGE); gensetlabel(lab); tcggenmovi32(cpuR[rd], res); tcgtempfreei64(ta); tcgtempfreei64(tb); tcgtempfreei64(tcy); tcgtempfreei64(td); tcgtempfreei32(res); tcgtempfreei32(srcy); tcgtempfreei32(srove); } break; default: genillegalexception(dc); break; } break; case 0x0002: /* l.sub */ switch (op1) { case 0x00: LOGDIS(\"l.sub r%d, r%d, r%d\\n\", rd, ra, rb); { TCGLabel *lab = gennewlabel(); TCGvi64 ta = tcgtempnewi64(); TCGvi64 tb = tcgtempnewi64(); TCGvi64 td = tcgtemplocalnewi64(); TCGvi32 res = tcgtemplocalnewi32(); TCGvi32 srove = tcgtemplocalnewi32(); tcggenextui32i64(ta, cpuR[ra]); tcggenextui32i64(tb, cpuR[rb]); tcggensubi64(td, ta, tb); tcggenextrli64i32(res, td); tcggenshrii64(td, td, 31); tcggenandii64(td, td, 0x3); /* Jump to lab when no overflow. */ tcggenbrcondii64(TCGCONDEQ, td, 0x0, lab); tcggenbrcondii64(TCGCONDEQ, td, 0x3, lab); tcggenorii32(cpusr, cpusr, (SROV | SRCY)); tcggenandii32(srove, cpusr, SROVE); tcggenbrcondii32(TCGCONDNE, srove, SROVE, lab); genexception(dc, EXCPRANGE); gensetlabel(lab); tcggenmovi32(cpuR[rd], res); tcgtempfreei64(ta); tcgtempfreei64(tb); tcgtempfreei64(td); tcgtempfreei32(res); tcgtempfreei32(srove); } break; default: genillegalexception(dc); break; } break; case 0x0003: /* l.and */ switch (op1) { case 0x00: LOGDIS(\"l.and r%d, r%d, r%d\\n\", rd, ra, rb); tcggenandtl(cpuR[rd], cpuR[ra], cpuR[rb]); break; default: genillegalexception(dc); break; } break; case 0x0004: /* l.or */ switch (op1) { case 0x00: LOGDIS(\"l.or r%d, r%d, r%d\\n\", rd, ra, rb); tcggenortl(cpuR[rd], cpuR[ra], cpuR[rb]); break; default: genillegalexception(dc); break; } break; case 0x0005: switch (op1) { case 0x00: /* l.xor */ LOGDIS(\"l.xor r%d, r%d, r%d\\n\", rd, ra, rb); tcggenxortl(cpuR[rd], cpuR[ra], cpuR[rb]); break; default: genillegalexception(dc); break; } break; case 0x0006: switch (op1) { case 0x03: /* l.mul */ LOGDIS(\"l.mul r%d, r%d, r%d\\n\", rd, ra, rb); if (ra != 0 && rb != 0) { genhelpermul32(cpuR[rd], cpuenv, cpuR[ra], cpuR[rb]); } else { tcggenmovitl(cpuR[rd], 0x0); } break; default: genillegalexception(dc); break; } break; case 0x0009: switch (op1) { case 0x03: /* l.div */ LOGDIS(\"l.div r%d, r%d, r%d\\n\", rd, ra, rb); { TCGLabel *lab0 = gennewlabel(); TCGLabel *lab1 = gennewlabel(); TCGLabel *lab2 = gennewlabel(); TCGLabel *lab3 = gennewlabel(); TCGvi32 srove = tcgtemplocalnewi32(); if (rb == 0) { tcggenoritl(cpusr, cpusr, (SROV | SRCY)); tcggenanditl(srove, cpusr, SROVE); tcggenbrconditl(TCGCONDNE, srove, SROVE, lab0); genexception(dc, EXCPRANGE); gensetlabel(lab0); } else { tcggenbrconditl(TCGCONDEQ, cpuR[rb], 0x00000000, lab1); tcggenbrconditl(TCGCONDNE, cpuR[ra], 0x80000000, lab2); tcggenbrconditl(TCGCONDNE, cpuR[rb], 0xffffffff, lab2); gensetlabel(lab1); tcggenoritl(cpusr, cpusr, (SROV | SRCY)); tcggenanditl(srove, cpusr, SROVE); tcggenbrconditl(TCGCONDNE, srove, SROVE, lab3); genexception(dc, EXCPRANGE); gensetlabel(lab2); tcggendivtl(cpuR[rd], cpuR[ra], cpuR[rb]); gensetlabel(lab3); } tcgtempfreei32(srove); } break; default: genillegalexception(dc); break; } break; case 0x000a: switch (op1) { case 0x03: /* l.divu */ LOGDIS(\"l.divu r%d, r%d, r%d\\n\", rd, ra, rb); { TCGLabel *lab0 = gennewlabel(); TCGLabel *lab1 = gennewlabel(); TCGLabel *lab2 = gennewlabel(); TCGvi32 srove = tcgtemplocalnewi32(); if (rb == 0) { tcggenoritl(cpusr, cpusr, (SROV | SRCY)); tcggenanditl(srove, cpusr, SROVE); tcggenbrconditl(TCGCONDNE, srove, SROVE, lab0); genexception(dc, EXCPRANGE); gensetlabel(lab0); } else { tcggenbrconditl(TCGCONDNE, cpuR[rb], 0x00000000, lab1); tcggenoritl(cpusr, cpusr, (SROV | SRCY)); tcggenanditl(srove, cpusr, SROVE); tcggenbrconditl(TCGCONDNE, srove, SROVE, lab2); genexception(dc, EXCPRANGE); gensetlabel(lab1); tcggendivutl(cpuR[rd], cpuR[ra], cpuR[rb]); gensetlabel(lab2); } tcgtempfreei32(srove); } break; default: genillegalexception(dc); break; } break; case 0x000b: switch (op1) { case 0x03: /* l.mulu */ LOGDIS(\"l.mulu r%d, r%d, r%d\\n\", rd, ra, rb); if (rb != 0 && ra != 0) { TCGvi64 result = tcgtemplocalnewi64(); TCGvi64 tra = tcgtemplocalnewi64(); TCGvi64 trb = tcgtemplocalnewi64(); TCGvi64 high = tcgtempnewi64(); TCGvi32 srove = tcgtemplocalnewi32(); TCGLabel *lab = gennewlabel(); /* Calculate each result. */ tcggenextui32i64(tra, cpuR[ra]); tcggenextui32i64(trb, cpuR[rb]); tcggenmuli64(result, tra, trb); tcgtempfreei64(tra); tcgtempfreei64(trb); tcggenshrii64(high, result, TARGETLONGBITS); /* Overflow or not. */ tcggenbrcondii64(TCGCONDEQ, high, 0x00000000, lab); tcggenoritl(cpusr, cpusr, (SROV | SRCY)); tcggenanditl(srove, cpusr, SROVE); tcggenbrconditl(TCGCONDNE, srove, SROVE, lab); genexception(dc, EXCPRANGE); gensetlabel(lab); tcgtempfreei64(high); tcggentrunci64tl(cpuR[rd], result); tcgtempfreei64(result); tcgtempfreei32(srove); } else { tcggenmovitl(cpuR[rd], 0); } break; default: genillegalexception(dc); break; } break; case 0x000e: switch (op1) { case 0x00: /* l.cmov */ LOGDIS(\"l.cmov r%d, r%d, r%d\\n\", rd, ra, rb); { TCGLabel *lab = gennewlabel(); TCGv res = tcgtemplocalnew(); TCGv srf = tcgtempnew(); tcggenanditl(srf, cpusr, SRF); tcggenmovtl(res, cpuR[rb]); tcggenbrconditl(TCGCONDNE, srf, SRF, lab); tcggenmovtl(res, cpuR[ra]); gensetlabel(lab); tcggenmovtl(cpuR[rd], res); tcgtempfree(srf); tcgtempfree(res); } break; default: genillegalexception(dc); break; } break; case 0x000f: switch (op1) { case 0x00: /* l.ff1 */ LOGDIS(\"l.ff1 r%d, r%d, r%d\\n\", rd, ra, rb); tcggenctzitl(cpuR[rd], cpuR[ra], -1); tcggenadditl(cpuR[rd], cpuR[rd], 1); break; case 0x01: /* l.fl1 */ LOGDIS(\"l.fl1 r%d, r%d, r%d\\n\", rd, ra, rb); tcggenclzitl(cpuR[rd], cpuR[ra], TARGETLONGBITS); tcggensubfitl(cpuR[rd], TARGETLONGBITS, cpuR[rd]); break; default: genillegalexception(dc); break; } break; case 0x0008: switch (op1) { case 0x00: switch (op2) { case 0x00: /* l.sll */ LOGDIS(\"l.sll r%d, r%d, r%d\\n\", rd, ra, rb); tcggenshltl(cpuR[rd], cpuR[ra], cpuR[rb]); break; case 0x01: /* l.srl */ LOGDIS(\"l.srl r%d, r%d, r%d\\n\", rd, ra, rb); tcggenshrtl(cpuR[rd], cpuR[ra], cpuR[rb]); break; case 0x02: /* l.sra */ LOGDIS(\"l.sra r%d, r%d, r%d\\n\", rd, ra, rb); tcggensartl(cpuR[rd], cpuR[ra], cpuR[rb]); break; case 0x03: /* l.ror */ LOGDIS(\"l.ror r%d, r%d, r%d\\n\", rd, ra, rb); tcggenrotrtl(cpuR[rd], cpuR[ra], cpuR[rb]); break; default: genillegalexception(dc); break; } break; default: genillegalexception(dc); break; } break; case 0x000c: switch (op1) { case 0x00: switch (op2) { case 0x00: /* l.exths */ LOGDIS(\"l.exths r%d, r%d\\n\", rd, ra); tcggenext16stl(cpuR[rd], cpuR[ra]); break; case 0x01: /* l.extbs */ LOGDIS(\"l.extbs r%d, r%d\\n\", rd, ra); tcggenext8stl(cpuR[rd], cpuR[ra]); break; case 0x02: /* l.exthz */ LOGDIS(\"l.exthz r%d, r%d\\n\", rd, ra); tcggenext16utl(cpuR[rd], cpuR[ra]); break; case 0x03: /* l.extbz */ LOGDIS(\"l.extbz r%d, r%d\\n\", rd, ra); tcggenext8utl(cpuR[rd], cpuR[ra]); break; default: genillegalexception(dc); break; } break; default: genillegalexception(dc); break; } break; case 0x000d: switch (op1) { case 0x00: switch (op2) { case 0x00: /* l.extws */ LOGDIS(\"l.extws r%d, r%d\\n\", rd, ra); tcggenext32stl(cpuR[rd], cpuR[ra]); break; case 0x01: /* l.extwz */ LOGDIS(\"l.extwz r%d, r%d\\n\", rd, ra); tcggenext32utl(cpuR[rd], cpuR[ra]); break; default: genillegalexception(dc); break; } break; default: genillegalexception(dc); break; } break; default: genillegalexception(dc); break; } } ", "target": 1}
{"func": "int qemucalculatetimeout(void) { #ifndef CONFIGIOTHREAD int timeout; if (!vmrunning) timeout = 5000; else { /* XXX: use timeout computed from timers */ int64t add; int64t delta; /* Advance virtual time to the next event. */ \tdelta = qemuicountdelta(); if (delta > 0) { /* If virtual time is ahead of real time then just wait for IO. */ timeout = (delta + 999999) / 1000000; } else { /* Wait for either IO to occur or the next timer event. */ add = qemunextdeadline(); /* We advance the timer before checking for IO. Limit the amount we advance so that early IO activity won't get the guest too far ahead. */ if (add > 10000000) add = 10000000; delta += add; qemuicount += qemuicountround (add); timeout = delta / 1000000; if (timeout < 0) timeout = 0; } } return timeout; #else /* CONFIGIOTHREAD */ return 1000; #endif } ", "target": 1}
{"func": "static int ftpabort(URLContext *h) { static const char *command = \"ABOR\\r\\n\"; int err; static const int aborcodes[] = {225, 226, 0}; FTPContext *s = h->privdata; /* According to RCF 959: \"ABOR command tells the server to abort the previous FTP service command and any associated transfer of data.\" There are FTP server implementations that don't response to any commands during data transfer in passive mode (including ABOR). This implementation closes data connection by force. */ if (ftpsendcommand(s, command, NULL, NULL) < 0) { ftpclosebothconnections(s); if ((err = ftpconnectcontrolconnection(h)) < 0) { avlog(h, AVLOGERROR, \"Reconnect failed.\\n\"); return err; } } else { ftpclosedataconnection(s); } if (ftpstatus(s, NULL, aborcodes) < 225) { /* wu-ftpd also closes control connection after data connection closing */ ffurlclosep(&s->conncontrol); if ((err = ftpconnectcontrolconnection(h)) < 0) { avlog(h, AVLOGERROR, \"Reconnect failed.\\n\"); return err; } } return 0; } ", "target": 1}
{"func": "static int rtmppacketreadonechunk(URLContext *h, RTMPPacket *p, int chunksize, RTMPPacket **prevpktptr, int *nbprevpkt, uint8t hdr) { uint8t buf[16]; int channelid, timestamp, size; uint32t tsfield; // non-extended timestamp or delta field uint32t extra = 0; enum RTMPPacketType type; int written = 0; int ret, toread; RTMPPacket *prevpkt; written++; channelid = hdr & 0x3F; if (channelid < 2) { //special case for channel number >= 64 buf[1] = 0; if (ffurlreadcomplete(h, buf, channelid + 1) != channelid + 1) return AVERROR(EIO); written += channelid + 1; channelid = AVRL16(buf) + 64; if ((ret = ffrtmpcheckallocarray(prevpktptr, nbprevpkt, channelid)) < 0) return ret; prevpkt = *prevpktptr; size = prevpkt[channelid].size; type = prevpkt[channelid].type; extra = prevpkt[channelid].extra; hdr >>= 6; // header size indicator if (hdr == RTMPPSONEBYTE) { tsfield = prevpkt[channelid].tsfield; } else { if (ffurlreadcomplete(h, buf, 3) != 3) return AVERROR(EIO); written += 3; tsfield = AVRB24(buf); if (hdr != RTMPPSFOURBYTES) { if (ffurlreadcomplete(h, buf, 3) != 3) return AVERROR(EIO); written += 3; size = AVRB24(buf); if (ffurlreadcomplete(h, buf, 1) != 1) return AVERROR(EIO); written++; type = buf[0]; if (hdr == RTMPPSTWELVEBYTES) { if (ffurlreadcomplete(h, buf, 4) != 4) return AVERROR(EIO); written += 4; extra = AVRL32(buf); if (tsfield == 0xFFFFFF) { if (ffurlreadcomplete(h, buf, 4) != 4) return AVERROR(EIO); timestamp = AVRB32(buf); } else { timestamp = tsfield; if (hdr != RTMPPSTWELVEBYTES) timestamp += prevpkt[channelid].timestamp; if (!prevpkt[channelid].read) { if ((ret = ffrtmppacketcreate(p, channelid, type, timestamp, size)) < 0) return ret; p->read = written; p->offset = 0; prevpkt[channelid].tsfield = tsfield; prevpkt[channelid].timestamp = timestamp; } else { // previous packet in this channel hasn't completed reading RTMPPacket *prev = &prevpkt[channelid]; p->data = prev->data; p->size = prev->size; p->channelid = prev->channelid; p->type = prev->type; p->tsfield = prev->tsfield; p->extra = prev->extra; p->offset = prev->offset; p->read = prev->read + written; p->timestamp = prev->timestamp; prev->data = NULL; p->extra = extra; // save history prevpkt[channelid].channelid = channelid; prevpkt[channelid].type = type; prevpkt[channelid].size = size; prevpkt[channelid].extra = extra; size = size - p->offset; toread = FFMIN(size, chunksize); if (ffurlreadcomplete(h, p->data + p->offset, toread) != toread) { ffrtmppacketdestroy(p); return AVERROR(EIO); size -= toread; p->read += toread; p->offset += toread; if (size > 0) { RTMPPacket *prev = &prevpkt[channelid]; prev->data = p->data; prev->read = p->read; prev->offset = p->offset; return AVERROR(EAGAIN); prevpkt[channelid].read = 0; // read complete; reset if needed return p->read;", "target": 1}
{"func": "void eeprom93xxwrite(eepromt *eeprom, int eecs, int eesk, int eedi) { uint8t tick = eeprom->tick; uint8t eedo = eeprom->eedo; uint16t address = eeprom->address; uint8t command = eeprom->command; logout(\"CS=%u SK=%u DI=%u DO=%u, tick = %u\\n\", eecs, eesk, eedi, eedo, tick); if (! eeprom->eecs && eecs) { /* Start chip select cycle. */ logout(\"Cycle start, waiting for 1st start bit (0)\\n\"); tick = 0; command = 0x0; address = 0x0; } else if (eeprom->eecs && ! eecs) { /* End chip select cycle. This triggers write / erase. */ if (eeprom->writable) { uint8t subcommand = address >> (eeprom->addrbits - 2); if (command == 0 && subcommand == 2) { /* Erase all. */ for (address = 0; address < eeprom->size; address++) { eeprom->contents[address] = 0xffff; } } else if (command == 3) { /* Erase word. */ eeprom->contents[address] = 0xffff; } else if (tick >= 2 + 2 + eeprom->addrbits + 16) { if (command == 1) { /* Write word. */ eeprom->contents[address] &= eeprom->data; } else if (command == 0 && subcommand == 1) { /* Write all. */ for (address = 0; address < eeprom->size; address++) { eeprom->contents[address] &= eeprom->data; } } } } /* Output DO is tristate, read results in 1. */ eedo = 1; } else if (eecs && ! eeprom->eesk && eesk) { /* Raising edge of clock shifts data in. */ if (tick == 0) { /* Wait for 1st start bit. */ if (eedi == 0) { logout(\"Got correct 1st start bit, waiting for 2nd start bit (1)\\n\"); tick++; } else { logout(\"wrong 1st start bit (is 1, should be 0)\\n\"); tick = 2; //~ assert(!\"wrong start bit\"); } } else if (tick == 1) { /* Wait for 2nd start bit. */ if (eedi != 0) { logout(\"Got correct 2nd start bit, getting command + address\\n\"); tick++; } else { logout(\"1st start bit is longer than needed\\n\"); } } else if (tick < 2 + 2) { /* Got 2 start bits, transfer 2 opcode bits. */ tick++; command <<= 1; if (eedi) { command += 1; } } else if (tick < 2 + 2 + eeprom->addrbits) { /* Got 2 start bits and 2 opcode bits, transfer all address bits. */ tick++; address = ((address << 1) | eedi); if (tick == 2 + 2 + eeprom->addrbits) { logout(\"%s command, address = 0x%02x (value 0x%04x)\\n\", opstring[command], address, eeprom->contents[address]); if (command == 2) { eedo = 0; } address = address % eeprom->size; if (command == 0) { /* Command code in upper 2 bits of address. */ switch (address >> (eeprom->addrbits - 2)) { case 0: logout(\"write disable command\\n\"); eeprom->writable = 0; break; case 1: logout(\"write all command\\n\"); break; case 2: logout(\"erase all command\\n\"); break; case 3: logout(\"write enable command\\n\"); eeprom->writable = 1; break; } } else { /* Read, write or erase word. */ eeprom->data = eeprom->contents[address]; } } } else if (tick < 2 + 2 + eeprom->addrbits + 16) { /* Transfer 16 data bits. */ tick++; if (command == 2) { /* Read word. */ eedo = ((eeprom->data & 0x8000) != 0); } eeprom->data <<= 1; eeprom->data += eedi; } else { logout(\"additional unneeded tick, not processed\\n\"); } } /* Save status of EEPROM. */ eeprom->tick = tick; eeprom->eecs = eecs; eeprom->eesk = eesk; eeprom->eedo = eedo; eeprom->address = address; eeprom->command = command; } ", "target": 0}
{"func": "static void *iothreadrun(void *opaque) { IOThread *iothread = opaque; qemumutexlock(&iothread->initdonelock); iothread->threadid = qemugetthreadid(); qemucondsignal(&iothread->initdonecond); qemumutexunlock(&iothread->initdonelock); while (!iothread->stopping) { aiocontextacquire(iothread->ctx); while (!iothread->stopping && aiopoll(iothread->ctx, true)) { /* Progress was made, keep going */ } aiocontextrelease(iothread->ctx); } return NULL; } ", "target": 0}
{"func": "static avcold int encodeclose(AVCodecContext *avctx) { avframefree(&avctx->codedframe); return 0; } ", "target": 0}
{"func": "static void pcdimmgetsize(Object *obj, Visitor *v, const char *name, void *opaque, Error **errp) { int64t value; MemoryRegion *mr; PCDIMMDevice *dimm = PCDIMM(obj); mr = hostmemorybackendgetmemory(dimm->hostmem, errp); value = memoryregionsize(mr); visittypeint(v, name, &value, errp); } ", "target": 0}
{"func": "pflasht *pflashcfi02register(targetphysaddrt base, ramaddrt off, BlockDriverState *bs, uint32t sectorlen, int nbblocs, int nbmappings, int width, uint16t id0, uint16t id1, uint16t id2, uint16t id3, uint16t unlockaddr0, uint16t unlockaddr1) { pflasht *pfl; int32t chiplen; chiplen = sectorlen * nbblocs; /* XXX: to be fixed */ #if 0 if (totallen != (8 * 1024 * 1024) && totallen != (16 * 1024 * 1024) && totallen != (32 * 1024 * 1024) && totallen != (64 * 1024 * 1024)) return NULL; #endif pfl = qemumallocz(sizeof(pflasht)); /* FIXME: Allocate ram ourselves. */ pfl->storage = qemugetramptr(off); pfl->flmem = cpuregisteriomemory(pflashreadops, pflashwriteops, pfl); pfl->off = off; pfl->base = base; pfl->chiplen = chiplen; pfl->mappings = nbmappings; pflashregistermemory(pfl, 1); pfl->bs = bs; if (pfl->bs) { /* read the initial flash content */ bdrvread(pfl->bs, 0, pfl->storage, chiplen >> 9); } #if 0 /* XXX: there should be a bit to set up read-only, * the same way the hardware does (with WP pin). */ pfl->ro = 1; #else pfl->ro = 0; #endif pfl->timer = qemunewtimer(vmclock, pflashtimer, pfl); pfl->sectorlen = sectorlen; pfl->width = width; pfl->wcycle = 0; pfl->cmd = 0; pfl->status = 0; pfl->ident[0] = id0; pfl->ident[1] = id1; pfl->ident[2] = id2; pfl->ident[3] = id3; pfl->unlockaddr[0] = unlockaddr0; pfl->unlockaddr[1] = unlockaddr1; /* Hardcoded CFI table (mostly from SG29 Spansion flash) */ pfl->cfilen = 0x52; /* Standard \"QRY\" string */ pfl->cfitable[0x10] = 'Q'; pfl->cfitable[0x11] = 'R'; pfl->cfitable[0x12] = 'Y'; /* Command set (AMD/Fujitsu) */ pfl->cfitable[0x13] = 0x02; pfl->cfitable[0x14] = 0x00; /* Primary extended table address */ pfl->cfitable[0x15] = 0x31; pfl->cfitable[0x16] = 0x00; /* Alternate command set (none) */ pfl->cfitable[0x17] = 0x00; pfl->cfitable[0x18] = 0x00; /* Alternate extended table (none) */ pfl->cfitable[0x19] = 0x00; pfl->cfitable[0x1A] = 0x00; /* Vcc min */ pfl->cfitable[0x1B] = 0x27; /* Vcc max */ pfl->cfitable[0x1C] = 0x36; /* Vpp min (no Vpp pin) */ pfl->cfitable[0x1D] = 0x00; /* Vpp max (no Vpp pin) */ pfl->cfitable[0x1E] = 0x00; /* Reserved */ pfl->cfitable[0x1F] = 0x07; /* Timeout for min size buffer write (NA) */ pfl->cfitable[0x20] = 0x00; /* Typical timeout for block erase (512 ms) */ pfl->cfitable[0x21] = 0x09; /* Typical timeout for full chip erase (4096 ms) */ pfl->cfitable[0x22] = 0x0C; /* Reserved */ pfl->cfitable[0x23] = 0x01; /* Max timeout for buffer write (NA) */ pfl->cfitable[0x24] = 0x00; /* Max timeout for block erase */ pfl->cfitable[0x25] = 0x0A; /* Max timeout for chip erase */ pfl->cfitable[0x26] = 0x0D; /* Device size */ pfl->cfitable[0x27] = ctz32(chiplen); /* Flash device interface (8 & 16 bits) */ pfl->cfitable[0x28] = 0x02; pfl->cfitable[0x29] = 0x00; /* Max number of bytes in multi-bytes write */ /* XXX: disable buffered write as it's not supported */ // pfl->cfitable[0x2A] = 0x05; pfl->cfitable[0x2A] = 0x00; pfl->cfitable[0x2B] = 0x00; /* Number of erase block regions (uniform) */ pfl->cfitable[0x2C] = 0x01; /* Erase block region 1 */ pfl->cfitable[0x2D] = nbblocs - 1; pfl->cfitable[0x2E] = (nbblocs - 1) >> 8; pfl->cfitable[0x2F] = sectorlen >> 8; pfl->cfitable[0x30] = sectorlen >> 16; /* Extended */ pfl->cfitable[0x31] = 'P'; pfl->cfitable[0x32] = 'R'; pfl->cfitable[0x33] = 'I'; pfl->cfitable[0x34] = '1'; pfl->cfitable[0x35] = '0'; pfl->cfitable[0x36] = 0x00; pfl->cfitable[0x37] = 0x00; pfl->cfitable[0x38] = 0x00; pfl->cfitable[0x39] = 0x00; pfl->cfitable[0x3a] = 0x00; pfl->cfitable[0x3b] = 0x00; pfl->cfitable[0x3c] = 0x00; return pfl; } ", "target": 0}
{"func": "static int v9fsdochmod(V9fsState *s, V9fsString *path, modet mode) { return s->ops->chmod(&s->ctx, path->data, mode); } ", "target": 0}
{"func": "static int checkphysical (CPUState *env, mmuctxt *ctx, targetulong eaddr, int rw) { int inplb, ret; ctx->raddr = eaddr; ctx->prot = PAGEREAD; ret = 0; switch (env->mmumodel) { case POWERPCMMU32B: case POWERPCMMUSOFT6xx: case POWERPCMMUSOFT74xx: case POWERPCMMU601: case POWERPCMMUSOFT4xx: case POWERPCMMUREAL4xx: case POWERPCMMUBOOKE: ctx->prot |= PAGEWRITE; break; #if defined(TARGETPPC64) case POWERPCMMU64B: case POWERPCMMU64BRIDGE: /* Real address are 60 bits long */ ctx->raddr &= 0x0FFFFFFFFFFFFFFFULL; ctx->prot |= PAGEWRITE; break; #endif case POWERPCMMUSOFT4xxZ: if (unlikely(msrpe != 0)) { /* 403 family add some particular protections, * using PBL/PBU registers for accesses with no translation. */ inplb = /* Check PLB validity */ (env->pb[0] < env->pb[1] && /* and address in plb area */ eaddr >= env->pb[0] && eaddr < env->pb[1]) || (env->pb[2] < env->pb[3] && eaddr >= env->pb[2] && eaddr < env->pb[3]) ? 1 : 0; if (inplb ^ msrpx) { /* Access in protected area */ if (rw == 1) { /* Access is not allowed */ ret = -2; } } else { /* Read-write access is allowed */ ctx->prot |= PAGEWRITE; } } break; case POWERPCMMUBOOKEFSL: /* XXX: TODO */ cpuabort(env, \"BookE FSL MMU model not implemented\\n\"); break; default: cpuabort(env, \"Unknown or invalid MMU model\\n\"); return -1; } return ret; } ", "target": 1}
{"func": "void ffxvmcfieldend(MpegEncContext *s) { struct xvmcpixfmt *render = (struct xvmcpixfmt*)s->currentpicture.f.data[2]; assert(render); if (render->filledmvblocksnum > 0) ffmpegdrawhorizband(s, 0, 0); } ", "target": 1}
{"func": "void setsystemmemorymap(MemoryRegion *mr) { memoryregiontransactionbegin(); addressspacememory.root = mr; memoryregiontransactioncommit(); } ", "target": 1}
{"func": "ppmode *ppgetmodebynameandquality(const char *name, int quality) { char temp[GETMODEBUFFERSIZE]; char *p= temp; static const char filterDelimiters[] = \",/\"; static const char optionDelimiters[] = \":\"; struct PPMode *ppMode; char *filterToken; ppMode= avmalloc(sizeof(PPMode)); ppMode->lumMode= 0; ppMode->chromMode= 0; ppMode->maxTmpNoise[0]= 700; ppMode->maxTmpNoise[1]= 1500; ppMode->maxTmpNoise[2]= 3000; ppMode->maxAllowedY= 234; ppMode->minAllowedY= 16; ppMode->baseDcDiff= 256/8; ppMode->flatnessThreshold= 56-16-1; ppMode->maxClippedThreshold= 0.01; ppMode->error=0; memset(temp, 0, GETMODEBUFFERSIZE); avstrlcpy(temp, name, GETMODEBUFFERSIZE - 1); avlog(NULL, AVLOGDEBUG, \"pp: %s\\n\", name); for(;;){ char *filterName; int q= 1000000; //PPQUALITYMAX; int chrom=-1; int luma=-1; char *option; char *options[OPTIONSARRAYSIZE]; int i; int filterNameOk=0; int numOfUnknownOptions=0; int enable=1; //does the user want us to enabled or disabled the filter filterToken= strtok(p, filterDelimiters); if(filterToken == NULL) break; p+= strlen(filterToken) + 1; // p points to next filterToken filterName= strtok(filterToken, optionDelimiters); avlog(NULL, AVLOGDEBUG, \"pp: %s::%s\\n\", filterToken, filterName); if(*filterName == '-'){ enable=0; filterName++; } for(;;){ //for all options option= strtok(NULL, optionDelimiters); if(option == NULL) break; avlog(NULL, AVLOGDEBUG, \"pp: option: %s\\n\", option); if(!strcmp(\"autoq\", option) || !strcmp(\"a\", option)) q= quality; else if(!strcmp(\"nochrom\", option) || !strcmp(\"y\", option)) chrom=0; else if(!strcmp(\"chrom\", option) || !strcmp(\"c\", option)) chrom=1; else if(!strcmp(\"noluma\", option) || !strcmp(\"n\", option)) luma=0; else{ options[numOfUnknownOptions] = option; numOfUnknownOptions++; } if(numOfUnknownOptions >= OPTIONSARRAYSIZE-1) break; } options[numOfUnknownOptions] = NULL; /* replace stuff from the replace Table */ for(i=0; replaceTable[2*i]!=NULL; i++){ if(!strcmp(replaceTable[2*i], filterName)){ int newlen= strlen(replaceTable[2*i + 1]); int plen; int spaceLeft; if(p==NULL) p= temp, *p=0; //last filter else p--, *p=','; //not last filter plen= strlen(p); spaceLeft= p - temp + plen; if(spaceLeft + newlen >= GETMODEBUFFERSIZE - 1){ ppMode->error++; break; } memmove(p + newlen, p, plen+1); memcpy(p, replaceTable[2*i + 1], newlen); filterNameOk=1; } } for(i=0; filters[i].shortName!=NULL; i++){ if( !strcmp(filters[i].longName, filterName) || !strcmp(filters[i].shortName, filterName)){ ppMode->lumMode &= ~filters[i].mask; ppMode->chromMode &= ~filters[i].mask; filterNameOk=1; if(!enable) break; // user wants to disable it if(q >= filters[i].minLumQuality && luma) ppMode->lumMode|= filters[i].mask; if(chrom==1 || (chrom==-1 && filters[i].chromDefault)) if(q >= filters[i].minChromQuality) ppMode->chromMode|= filters[i].mask; if(filters[i].mask == LEVELFIX){ int o; ppMode->minAllowedY= 16; ppMode->maxAllowedY= 234; for(o=0; options[o]!=NULL; o++){ if( !strcmp(options[o],\"fullyrange\") ||!strcmp(options[o],\"f\")){ ppMode->minAllowedY= 0; ppMode->maxAllowedY= 255; numOfUnknownOptions--; } } } else if(filters[i].mask == TEMPNOISEFILTER) { int o; int numOfNoises=0; for(o=0; options[o]!=NULL; o++){ char *tail; ppMode->maxTmpNoise[numOfNoises]= strtol(options[o], &tail, 0); if(tail!=options[o]){ numOfNoises++; numOfUnknownOptions--; if(numOfNoises >= 3) break; } } } else if(filters[i].mask == VDEBLOCK || filters[i].mask == HDEBLOCK || filters[i].mask == VADEBLOCK || filters[i].mask == HADEBLOCK){ int o; for(o=0; options[o]!=NULL && o<2; o++){ char *tail; int val= strtol(options[o], &tail, 0); if(tail==options[o]) break; numOfUnknownOptions--; if(o==0) ppMode->baseDcDiff= val; else ppMode->flatnessThreshold= val; } } else if(filters[i].mask == FORCEQUANT){ int o; ppMode->forcedQuant= 15; for(o=0; options[o]!=NULL && o<1; o++){ char *tail; int val= strtol(options[o], &tail, 0); if(tail==options[o]) break; numOfUnknownOptions--; ppMode->forcedQuant= val; } } } } if(!filterNameOk) ppMode->error++; ppMode->error += numOfUnknownOptions; } avlog(NULL, AVLOGDEBUG, \"pp: lumMode=%X, chromMode=%X\\n\", ppMode->lumMode, ppMode->chromMode); if(ppMode->error){ avlog(NULL, AVLOGERROR, \"%d errors in postprocess string \\\"%s\\\"\\n\", ppMode->error, name); avfree(ppMode); return NULL; } return ppMode; } ", "target": 0}
{"func": "int qcow2writel1entry(BlockDriverState *bs, int l1index) { BDRVQcowState *s = bs->opaque; uint64t buf[L1ENTRIESPERSECTOR]; int l1startindex; int i, ret; l1startindex = l1index & ~(L1ENTRIESPERSECTOR - 1); for (i = 0; i < L1ENTRIESPERSECTOR; i++) { buf[i] = cputobe64(s->l1table[l1startindex + i]); } ret = qcow2prewriteoverlapcheck(bs, QCOW2OLDEFAULT & ~QCOW2OLACTIVEL1, s->l1tableoffset + 8 * l1startindex, sizeof(buf)); if (ret < 0) { return ret; } BLKDBGEVENT(bs->file, BLKDBGL1UPDATE); ret = bdrvpwritesync(bs->file, s->l1tableoffset + 8 * l1startindex, buf, sizeof(buf)); if (ret < 0) { return ret; } return 0; } ", "target": 1}
{"func": "static void zerobss(abiulong elfbss, abiulong lastbss, int prot) { uintptrt hoststart, hostmapstart, hostend; lastbss = TARGETPAGEALIGN(lastbss); /* ??? There is confusion between qemurealhostpagesize and qemuhostpagesize here and elsewhere in targetmmap, which may lead to the end of the data section mapping from the file not being mapped. At least there was an explicit test and comment for that here, suggesting that \"the file size must be known\". The comment probably pre-dates the introduction of the fstat system call in targetmmap which does in fact find out the size. What isn't clear is if the workaround here is still actually needed. For now, continue with it, but merge it with the \"normal\" mmap that would allocate the bss. */ hoststart = (uintptrt) g2h(elfbss); hostend = (uintptrt) g2h(lastbss); hostmapstart = (hoststart + qemurealhostpagesize - 1); hostmapstart &= -qemurealhostpagesize; if (hostmapstart < hostend) { void *p = mmap((void *)hostmapstart, hostend - hostmapstart, prot, MAPFIXED | MAPPRIVATE | MAPANONYMOUS, -1, 0); if (p == MAPFAILED) { perror(\"cannot mmap brk\"); exit(-1); } /* Since we didn't use targetmmap, make sure to record the validity of the pages with qemu. */ pagesetflags(elfbss & TARGETPAGEMASK, lastbss, prot|PAGEVALID); } if (hoststart < hostmapstart) { memset((void *)hoststart, 0, hostmapstart - hoststart); } } ", "target": 0}
{"func": "static void avcbiwgt4x4multiplemsa(uint8t *src, int32t srcstride, uint8t *dst, int32t dststride, int32t height, int32t log2denom, int32t srcweight, int32t dstweight, int32t offsetin) { uint8t cnt; uint32t load0, load1, load2, load3; v16i8 srcwgt, dstwgt, wgt; v16i8 src0, src1, src2, src3; v16i8 dst0, dst1, dst2, dst3; v8i16 temp0, temp1, temp2, temp3; v8i16 denom, offset, addval; int32t val = 128 * (srcweight + dstweight); offsetin = ((offsetin + 1) | 1) << log2denom; srcwgt = msafillb(srcweight); dstwgt = msafillb(dstweight); offset = msafillh(offsetin); denom = msafillh(log2denom + 1); addval = msafillh(val); offset += addval; wgt = msailvevb(dstwgt, srcwgt); for (cnt = height / 4; cnt--;) { LOAD4WORDSWITHSTRIDE(src, srcstride, load0, load1, load2, load3); src += (4 * srcstride); src0 = (v16i8) msafillw(load0); src1 = (v16i8) msafillw(load1); src2 = (v16i8) msafillw(load2); src3 = (v16i8) msafillw(load3); LOAD4WORDSWITHSTRIDE(dst, dststride, load0, load1, load2, load3); dst0 = (v16i8) msafillw(load0); dst1 = (v16i8) msafillw(load1); dst2 = (v16i8) msafillw(load2); dst3 = (v16i8) msafillw(load3); XORIB4VECSSB(src0, src1, src2, src3, src0, src1, src2, src3, 128); XORIB4VECSSB(dst0, dst1, dst2, dst3, dst0, dst1, dst2, dst3, 128); ILVRB4VECSSH(src0, src1, src2, src3, dst0, dst1, dst2, dst3, temp0, temp1, temp2, temp3); temp0 = msadpaddsh(offset, wgt, (v16i8) temp0); temp1 = msadpaddsh(offset, wgt, (v16i8) temp1); temp2 = msadpaddsh(offset, wgt, (v16i8) temp2); temp3 = msadpaddsh(offset, wgt, (v16i8) temp3); SRA4VECS(temp0, temp1, temp2, temp3, temp0, temp1, temp2, temp3, denom); temp0 = CLIPUNSIGNEDCHARH(temp0); temp1 = CLIPUNSIGNEDCHARH(temp1); temp2 = CLIPUNSIGNEDCHARH(temp2); temp3 = CLIPUNSIGNEDCHARH(temp3); PCKEVBSTORE4BYTES4(temp0, temp1, temp2, temp3, dst, dststride); dst += (4 * dststride); } } ", "target": 0}
{"func": "static inline void tcgoutld(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg1, intptrt arg2) { int opi, opx; assert(TCGTARGETREGBITS == 64 || type == TCGTYPEI32); if (type == TCGTYPEI32) { opi = LWZ, opx = LWZX; } else { opi = LD, opx = LDX; } tcgoutmemlong(s, opi, opx, ret, arg1, arg2); } ", "target": 0}
{"func": "void dodelvm(Monitor *mon, const QDict *qdict) { BlockDriverState *bs, *bs1; Error *err = NULL; const char *name = qdictgetstr(qdict, \"name\"); bs = findvmstatebs(); if (!bs) { monitorprintf(mon, \"No block device supports snapshots\\n\"); return; } bs1 = NULL; while ((bs1 = bdrvnext(bs1))) { if (bdrvcansnapshot(bs1)) { bdrvsnapshotdeletebyidorname(bs, name, &err); if (err) { monitorprintf(mon, \"Error while deleting snapshot on device '%s':\" \" %s\\n\", bdrvgetdevicename(bs), errorgetpretty(err)); errorfree(err); } } } } ", "target": 0}
{"func": "void objectpropertyadd(Object *obj, const char *name, const char *type, ObjectPropertyAccessor *get, ObjectPropertyAccessor *set, ObjectPropertyRelease *release, void *opaque, Error **errp) { ObjectProperty *prop; QTAILQFOREACH(prop, &obj->properties, node) { if (strcmp(prop->name, name) == 0) { errorsetg(errp, \"attempt to add duplicate property '%s'\" \" to object (type '%s')\", name, objectgettypename(obj)); return; } } prop = gmalloc0(sizeof(*prop)); prop->name = gstrdup(name); prop->type = gstrdup(type); prop->get = get; prop->set = set; prop->release = release; prop->opaque = opaque; QTAILQINSERTTAIL(&obj->properties, prop, node); } ", "target": 0}
{"func": "static void collieinit(MachineState *machine) { const char *cpumodel = machine->cpumodel; const char *kernelfilename = machine->kernelfilename; const char *kernelcmdline = machine->kernelcmdline; const char *initrdfilename = machine->initrdfilename; StrongARMState *s; DriveInfo *dinfo; MemoryRegion *sysmem = getsystemmemory(); if (!cpumodel) { cpumodel = \"sa1110\"; } s = sa1110init(sysmem, colliebinfo.ramsize, cpumodel); dinfo = driveget(IFPFLASH, 0, 0); pflashcfi01register(SACS0, NULL, \"collie.fl1\", 0x02000000, dinfo ? blkbs(blkbylegacydinfo(dinfo)) : NULL, (64 * 1024), 512, 4, 0x00, 0x00, 0x00, 0x00, 0); dinfo = driveget(IFPFLASH, 0, 1); pflashcfi01register(SACS1, NULL, \"collie.fl2\", 0x02000000, dinfo ? blkbs(blkbylegacydinfo(dinfo)) : NULL, (64 * 1024), 512, 4, 0x00, 0x00, 0x00, 0x00, 0); sysbuscreatesimple(\"scoop\", 0x40800000, NULL); colliebinfo.kernelfilename = kernelfilename; colliebinfo.kernelcmdline = kernelcmdline; colliebinfo.initrdfilename = initrdfilename; colliebinfo.boardid = 0x208; armloadkernel(s->cpu, &colliebinfo); } ", "target": 0}
{"func": "void avgpixels16altivec(uint8t *block, const uint8t *pixels, int linesize, int h) { POWERPCTBLDECLARE(altivecavgpixels16num, 1); #ifdef ALTIVECUSEREFERENCECCODE int i; POWERPCTBLSTARTCOUNT(altivecavgpixels16num, 1); for(i=0; i<h; i++) { opavg(*((uint32t*)(block)),(((const struct unaligned32 *)(pixels))->l)); opavg(*((uint32t*)(block+4)),(((const struct unaligned32 *)(pixels+4))->l)); opavg(*((uint32t*)(block+8)),(((const struct unaligned32 *)(pixels+8))->l)); opavg(*((uint32t*)(block+12)),(((const struct unaligned32 *)(pixels+12))->l)); pixels+=linesize; block +=linesize; } POWERPCTBLSTOPCOUNT(altivecavgpixels16num, 1); #else /* ALTIVECUSEREFERENCECCODE */ register vector unsigned char pixelsv1, pixelsv2, pixelsv, blockv; register vector unsigned char perm = veclvsl(0, pixels); int i; POWERPCTBLSTARTCOUNT(altivecavgpixels16num, 1); for(i=0; i<h; i++) { pixelsv1 = vecld(0, (unsigned char*)pixels); pixelsv2 = vecld(16, (unsigned char*)pixels); blockv = vecld(0, block); pixelsv = vecperm(pixelsv1, pixelsv2, perm); blockv = vecavg(blockv,pixelsv); vecst(blockv, 0, (unsigned char*)block); pixels+=linesize; block +=linesize; } POWERPCTBLSTOPCOUNT(altivecavgpixels16num, 1); #endif /* ALTIVECUSEREFERENCECCODE */ } ", "target": 0}
{"func": "static void blksendresponseall(struct XenBlkDev *blkdev) { struct ioreq *ioreq; int sendnotify = 0; while (!LISTEMPTY(&blkdev->finished)) { ioreq = LISTFIRST(&blkdev->finished); \tsendnotify += blksendresponseone(ioreq); \tioreqrelease(ioreq); } if (sendnotify) \txenbesendnotify(&blkdev->xendev); } ", "target": 0}
{"func": "static int interfaceclientmonitorsconfig(QXLInstance *sin, VDAgentMonitorsConfig *monitorsconfig) { PCIQXLDevice *qxl = containerof(sin, PCIQXLDevice, ssd.qxl); QXLRom *rom = memoryregiongetramptr(&qxl->rombar); int i; unsigned maxoutputs = ARRAYSIZE(rom->clientmonitorsconfig.heads); if (qxl->revision < 4) { traceqxlclientmonitorsconfigunsupportedbydevice(qxl->id, qxl->revision); return 0; } /* * Older windows drivers set intmask to 0 when their ISR is called, * then later set it to ~0. So it doesn't relate to the actual interrupts * handled. However, they are old, so clearly they don't support this * interrupt */ if (qxl->ram->intmask == 0 || qxl->ram->intmask == ~0 || !(qxl->ram->intmask & QXLINTERRUPTCLIENTMONITORSCONFIG)) { traceqxlclientmonitorsconfigunsupportedbyguest(qxl->id, qxl->ram->intmask, monitorsconfig); return 0; } if (!monitorsconfig) { return 1; } #if SPICESERVERVERSION >= 0x000c06 /* release 0.12.6 */ /* limit number of outputs based on setting limit */ if (qxl->maxoutputs && qxl->maxoutputs <= maxoutputs) { maxoutputs = qxl->maxoutputs; } #endif memset(&rom->clientmonitorsconfig, 0, sizeof(rom->clientmonitorsconfig)); rom->clientmonitorsconfig.count = monitorsconfig->numofmonitors; /* monitorsconfig->flags ignored */ if (rom->clientmonitorsconfig.count >= maxoutputs) { traceqxlclientmonitorsconfigcapped(qxl->id, monitorsconfig->numofmonitors, maxoutputs); rom->clientmonitorsconfig.count = maxoutputs; } for (i = 0 ; i < rom->clientmonitorsconfig.count ; ++i) { VDAgentMonConfig *monitor = &monitorsconfig->monitors[i]; QXLURect *rect = &rom->clientmonitorsconfig.heads[i]; /* monitor->depth ignored */ rect->left = monitor->x; rect->top = monitor->y; rect->right = monitor->x + monitor->width; rect->bottom = monitor->y + monitor->height; } rom->clientmonitorsconfigcrc = qxlcrc32( (const uint8t *)&rom->clientmonitorsconfig, sizeof(rom->clientmonitorsconfig)); traceqxlclientmonitorsconfigcrc(qxl->id, sizeof(rom->clientmonitorsconfig), rom->clientmonitorsconfigcrc); traceqxlinterruptclientmonitorsconfig(qxl->id, rom->clientmonitorsconfig.count, rom->clientmonitorsconfig.heads); qxlsendevents(qxl, QXLINTERRUPTCLIENTMONITORSCONFIG); return 1; } ", "target": 0}
{"func": "static void virtiopcirealize(PCIDevice *pcidev, Error **errp) { VirtIOPCIProxy *proxy = VIRTIOPCI(pcidev); VirtioPCIClass *k = VIRTIOPCIGETCLASS(pcidev); /* * virtio pci bar layout used by default. * subclasses can re-arrange things if needed. * * region 0 -- virtio legacy io bar * region 1 -- msi-x bar * region 4+5 -- virtio modern memory (64bit) bar * */ proxy->legacyiobar = 0; proxy->msixbar = 1; proxy->moderniobar = 2; proxy->modernmembar = 4; proxy->common.offset = 0x0; proxy->common.size = 0x1000; proxy->common.type = VIRTIOPCICAPCOMMONCFG; proxy->isr.offset = 0x1000; proxy->isr.size = 0x1000; proxy->isr.type = VIRTIOPCICAPISRCFG; proxy->device.offset = 0x2000; proxy->device.size = 0x1000; proxy->device.type = VIRTIOPCICAPDEVICECFG; proxy->notify.offset = 0x3000; proxy->notify.size = QEMUVIRTIOPCIQUEUEMEMMULT * VIRTIOQUEUEMAX; proxy->notify.type = VIRTIOPCICAPNOTIFYCFG; proxy->notifypio.offset = 0x0; proxy->notifypio.size = 0x4; proxy->notifypio.type = VIRTIOPCICAPNOTIFYCFG; /* subclasses can enforce modern, so do this unconditionally */ memoryregioninit(&proxy->modernbar, OBJECT(proxy), \"virtio-pci\", 2 * QEMUVIRTIOPCIQUEUEMEMMULT * VIRTIOQUEUEMAX); memoryregioninitalias(&proxy->moderncfg, OBJECT(proxy), \"virtio-pci-cfg\", &proxy->modernbar, 0, memoryregionsize(&proxy->modernbar)); addressspaceinit(&proxy->modernas, &proxy->moderncfg, \"virtio-pci-cfg-as\"); if (pciisexpress(pcidev) && pcibusisexpress(pcidev->bus) && !pcibusisroot(pcidev->bus)) { int pos; pos = pcieendpointcapinit(pcidev, 0); assert(pos > 0); pos = pciaddcapability(pcidev, PCICAPIDPM, 0, PCIPMSIZEOF); assert(pos > 0); /* * Indicates that this function complies with revision 1.2 of the * PCI Power Management Interface Specification. */ pcisetword(pcidev->config + pos + PCIPMPMC, 0x3); } else { /* * make future invocations of pciisexpress() return false * and pciconfigsize() return PCICONFIGSPACESIZE. */ pcidev->cappresent &= ~QEMUPCICAPEXPRESS; } virtiopcibusnew(&proxy->bus, sizeof(proxy->bus), proxy); if (k->realize) { k->realize(proxy, errp); } } ", "target": 0}
{"func": "static int cdxldecodeframe(AVCodecContext *avctx, void *data, int *datasize, AVPacket *pkt) { CDXLVideoContext *c = avctx->privdata; AVFrame * const p = &c->frame; int ret, w, h, encoding, format, bufsize = pkt->size; const uint8t *buf = pkt->data; if (bufsize < 32) return AVERRORINVALIDDATA; encoding = buf[1] & 7; format = buf[1] & 0xE0; w = AVRB16(&buf[14]); h = AVRB16(&buf[16]); c->bpp = buf[19]; c->palettesize = AVRB16(&buf[20]); c->palette = buf + 32; c->video = c->palette + c->palettesize; c->videosize = bufsize - c->palettesize - 32; if (c->palettesize > 512) return AVERRORINVALIDDATA; if (bufsize < c->palettesize + 32) return AVERRORINVALIDDATA; if (c->bpp < 1) return AVERRORINVALIDDATA; if (c->bpp > 8) { avlogaskforsample(avctx, \"unsupported pixel size: %d\\n\", c->bpp); return AVERRORPATCHWELCOME; } if (format) { avlogaskforsample(avctx, \"unsupported pixel format: %d\\n\", format); return AVERRORPATCHWELCOME; } if ((ret = avimagechecksize(w, h, 0, avctx)) < 0) return ret; if (w != avctx->width || h != avctx->height) avcodecsetdimensions(avctx, w, h); if (c->videosize < FFALIGN(avctx->width, 16) * avctx->height * c->bpp / 8) return AVERRORINVALIDDATA; if (!encoding && c->palettesize && c->bpp <= 8) { avctx->pixfmt = PIXFMTPAL8; } else if (encoding == 1 && (c->bpp == 6 || c->bpp == 8)) { if (c->palettesize != (1 << (c->bpp - 1))) return AVERRORINVALIDDATA; avctx->pixfmt = PIXFMTBGR24; } else { avlogaskforsample(avctx, \"unsupported encoding %d and bpp %d\\n\", encoding, c->bpp); return AVERRORPATCHWELCOME; } if (p->data[0]) avctx->releasebuffer(avctx, p); p->reference = 0; if ((ret = avctx->getbuffer(avctx, p)) < 0) { avlog(avctx, AVLOGERROR, \"getbuffer() failed\\n\"); return ret; } p->picttype = AVPICTURETYPEI; if (encoding) { avfastpaddedmalloc(&c->newvideo, &c->newvideosize, h * w + FFINPUTBUFFERPADDINGSIZE); if (!c->newvideo) return AVERROR(ENOMEM); if (c->bpp == 8) cdxldecodeham8(c); else cdxldecodeham6(c); } else { cdxldecodergb(c); } *datasize = sizeof(AVFrame); *(AVFrame*)data = c->frame; return bufsize; } ", "target": 0}
{"func": "static int decode0(PAFVideoDecContext *c, uint8t *pkt, uint8t code) { uint32t opcodesize, offset; uint8t *dst, *dend, mask = 0, color = 0; const uint8t *src, *send, *opcodes; int i, j, op = 0; i = bytestream2getbyte(&c->gb); if (i) { if (code & 0x10) { int align; align = bytestream2tell(&c->gb) & 3; if (align) bytestream2skip(&c->gb, 4 - align); } do { int page, val, x, y; val = bytestream2getbe16(&c->gb); page = val >> 14; x = (val & 0x7F) * 2; y = ((val >> 7) & 0x7F) * 2; dst = c->frame[page] + x + y * c->width; dend = c->frame[page] + c->framesize; offset = (x & 0x7F) * 2; j = bytestream2getle16(&c->gb) + offset; do { offset++; if (dst + 3 * c->width + 4 > dend) return AVERRORINVALIDDATA; read4x4block(c, dst, c->width); if ((offset & 0x3F) == 0) dst += c->width * 3; dst += 4; } while (offset < j); } while (--i); } dst = c->frame[c->currentframe]; dend = c->frame[c->currentframe] + c->framesize; do { setsrcposition(c, &src, &send); if ((src + 3 * c->width + 4 > send) || (dst + 3 * c->width + 4 > dend)) return AVERRORINVALIDDATA; copyblock4(dst, src, c->width, c->width, 4); i++; if ((i & 0x3F) == 0) dst += c->width * 3; dst += 4; } while (i < c->videosize / 16); opcodesize = bytestream2getle16(&c->gb); bytestream2skip(&c->gb, 2); if (bytestream2getbytesleft(&c->gb) < opcodesize) return AVERRORINVALIDDATA; opcodes = pkt + bytestream2tell(&c->gb); bytestream2skipu(&c->gb, opcodesize); dst = c->frame[c->currentframe]; for (i = 0; i < c->height; i += 4, dst += c->width * 3) for (j = 0; j < c->width; j += 4, dst += 4) { int opcode, k = 0; if (op > opcodesize) return AVERRORINVALIDDATA; if (j & 4) { opcode = opcodes[op] & 15; op++; } else { opcode = opcodes[op] >> 4; } while (blocksequences[opcode][k]) { offset = c->width * 2; code = blocksequences[opcode][k++]; switch (code) { case 2: offset = 0; case 3: color = bytestream2getbyte(&c->gb); case 4: mask = bytestream2getbyte(&c->gb); copycolormask(dst + offset, c->width, mask, color); break; case 5: offset = 0; case 6: setsrcposition(c, &src, &send); case 7: if (src + offset + c->width + 4 > send) return AVERRORINVALIDDATA; mask = bytestream2getbyte(&c->gb); copysrcmask(dst + offset, c->width, mask, src + offset); break; } } } return 0; } ", "target": 1}
{"func": "static void savenativefpfsave(CPUState *env) { int fptag, i, j; uint16t fpuc; struct fpstate fp1, *fp = &fp1; asm volatile (\"fsave %0\" : : \"m\" (*fp)); env->fpuc = fp->fpuc; env->fpstt = (fp->fpus >> 11) & 7; env->fpus = fp->fpus & ~0x3800; fptag = fp->fptag; for(i = 0;i < 8; i++) { env->fptags[i] = ((fptag & 3) == 3); fptag >>= 2; } j = env->fpstt; for(i = 0;i < 8; i++) { memcpy(&env->fpregs[j].d, &fp->fpregs1[i * 10], 10); j = (j + 1) & 7; } /* we must restore the default rounding state */ fpuc = 0x037f | (env->fpuc & (3 << 10)); asm volatile(\"fldcw %0\" : : \"m\" (fpuc)); } ", "target": 0}
{"func": "static int decodethread(void *arg) { VideoState *is = arg; AVFormatContext *ic; int err, i, ret, videoindex, audioindex, subtitleindex; AVPacket pkt1, *pkt = &pkt1; AVFormatParameters params, *ap = &params; videoindex = -1; audioindex = -1; subtitleindex = -1; is->videostream = -1; is->audiostream = -1; is->subtitlestream = -1; globalvideostate = is; urlsetinterruptcb(decodeinterruptcb); memset(ap, 0, sizeof(*ap)); ap->width = framewidth; ap->height= frameheight; ap->timebase= (AVRational){1, 25}; ap->pixfmt = framepixfmt; err = avopeninputfile(&ic, is->filename, is->iformat, 0, ap); if (err < 0) { printerror(is->filename, err); ret = -1; goto fail; } is->ic = ic; if(genpts) ic->flags |= AVFMTFLAGGENPTS; err = avfindstreaminfo(ic); if (err < 0) { fprintf(stderr, \"%s: could not find codec parameters\\n\", is->filename); ret = -1; goto fail; } if(ic->pb) ic->pb->eofreached= 0; //FIXME hack, ffplay maybe should not use urlfeof() to test for the end /* if seeking requested, we execute it */ if (starttime != AVNOPTSVALUE) { int64t timestamp; timestamp = starttime; /* add the stream start time */ if (ic->starttime != AVNOPTSVALUE) timestamp += ic->starttime; ret = avseekframe(ic, -1, timestamp, AVSEEKFLAGBACKWARD); if (ret < 0) { fprintf(stderr, \"%s: could not seek to position %0.3f\\n\", is->filename, (double)timestamp / AVTIMEBASE); } } for(i = 0; i < ic->nbstreams; i++) { AVCodecContext *enc = ic->streams[i]->codec; ic->streams[i]->discard = AVDISCARDALL; switch(enc->codectype) { case CODECTYPEAUDIO: if ((audioindex < 0 || wantedaudiostream-- > 0) && !audiodisable) audioindex = i; break; case CODECTYPEVIDEO: if ((videoindex < 0 || wantedvideostream-- > 0) && !videodisable) videoindex = i; break; case CODECTYPESUBTITLE: if (wantedsubtitlestream-- >= 0 && !videodisable) subtitleindex = i; break; default: break; } } if (showstatus) { dumpformat(ic, 0, is->filename, 0); dumpstreaminfo(ic); } /* open the streams */ if (audioindex >= 0) { streamcomponentopen(is, audioindex); } if (videoindex >= 0) { streamcomponentopen(is, videoindex); } else { if (!displaydisable) is->showaudio = 1; } if (subtitleindex >= 0) { streamcomponentopen(is, subtitleindex); } if (is->videostream < 0 && is->audiostream < 0) { fprintf(stderr, \"%s: could not open codecs\\n\", is->filename); ret = -1; goto fail; } for(;;) { if (is->abortrequest) break; if (is->paused != is->lastpaused) { is->lastpaused = is->paused; if (is->paused) avreadpause(ic); else avreadplay(ic); } #if CONFIGRTSPDEMUXER if (is->paused && !strcmp(ic->iformat->name, \"rtsp\")) { /* wait 10 ms to avoid trying to get another packet */ /* XXX: horrible */ SDLDelay(10); continue; } #endif if (is->seekreq) { int streamindex= -1; int64t seektarget= is->seekpos; if (is-> videostream >= 0) streamindex= is-> videostream; else if(is-> audiostream >= 0) streamindex= is-> audiostream; else if(is->subtitlestream >= 0) streamindex= is->subtitlestream; if(streamindex>=0){ seektarget= avrescaleq(seektarget, AVTIMEBASEQ, ic->streams[streamindex]->timebase); } ret = avseekframe(is->ic, streamindex, seektarget, is->seekflags); if (ret < 0) { fprintf(stderr, \"%s: error while seeking\\n\", is->ic->filename); }else{ if (is->audiostream >= 0) { packetqueueflush(&is->audioq); packetqueueput(&is->audioq, &flushpkt); } if (is->subtitlestream >= 0) { packetqueueflush(&is->subtitleq); packetqueueput(&is->subtitleq, &flushpkt); } if (is->videostream >= 0) { packetqueueflush(&is->videoq); packetqueueput(&is->videoq, &flushpkt); } } is->seekreq = 0; } /* if the queue are full, no need to read more */ if (is->audioq.size > MAXAUDIOQSIZE || is->videoq.size > MAXVIDEOQSIZE || is->subtitleq.size > MAXSUBTITLEQSIZE) { /* wait 10 ms */ SDLDelay(10); continue; } if(urlfeof(ic->pb)) { avinitpacket(pkt); pkt->data=NULL; pkt->size=0; pkt->streamindex= is->videostream; packetqueueput(&is->videoq, pkt); continue; } ret = avreadframe(ic, pkt); if (ret < 0) { if (ret != AVERROREOF && urlferror(ic->pb) == 0) { SDLDelay(100); /* wait for user event */ continue; } else break; } if (pkt->streamindex == is->audiostream) { packetqueueput(&is->audioq, pkt); } else if (pkt->streamindex == is->videostream) { packetqueueput(&is->videoq, pkt); } else if (pkt->streamindex == is->subtitlestream) { packetqueueput(&is->subtitleq, pkt); } else { avfreepacket(pkt); } } /* wait until the end */ while (!is->abortrequest) { SDLDelay(100); } ret = 0; fail: /* disable interrupting */ globalvideostate = NULL; /* close each stream */ if (is->audiostream >= 0) streamcomponentclose(is, is->audiostream); if (is->videostream >= 0) streamcomponentclose(is, is->videostream); if (is->subtitlestream >= 0) streamcomponentclose(is, is->subtitlestream); if (is->ic) { avcloseinputfile(is->ic); is->ic = NULL; /* safety */ } urlsetinterruptcb(NULL); if (ret != 0) { SDLEvent event; event.type = FFQUITEVENT; event.user.data1 = is; SDLPushEvent(&event); } return 0; } ", "target": 0}
{"func": "static int adpcmdecodeframe(AVCodecContext *avctx, void *data, int *gotframeptr, AVPacket *avpkt) { const uint8t *buf = avpkt->data; int bufsize = avpkt->size; ADPCMDecodeContext *c = avctx->privdata; ADPCMChannelStatus *cs; int n, m, channel, i; short *samples; const uint8t *src; int st; /* stereo */ int count1, count2; int nbsamples, codedsamples, ret; nbsamples = getnbsamples(avctx, buf, bufsize, &codedsamples); if (nbsamples <= 0) { avlog(avctx, AVLOGERROR, \"invalid number of samples in packet\\n\"); } /* get output buffer */ c->frame.nbsamples = nbsamples; if ((ret = avctx->getbuffer(avctx, &c->frame)) < 0) { avlog(avctx, AVLOGERROR, \"getbuffer() failed\\n\"); return ret; } samples = (short *)c->frame.data[0]; /* use codedsamples when applicable */ /* it is always <= nbsamples, so the output buffer will be large enough */ if (codedsamples) { if (codedsamples != nbsamples) avlog(avctx, AVLOGWARNING, \"mismatch in coded sample count\\n\"); c->frame.nbsamples = nbsamples = codedsamples; } src = buf; st = avctx->channels == 2 ? 1 : 0; switch(avctx->codec->id) { case CODECIDADPCMIMAQT: /* In QuickTime, IMA is encoded by chunks of 34 bytes (=64 samples). Channel data is interleaved per-chunk. */ for (channel = 0; channel < avctx->channels; channel++) { int16t predictor; int stepindex; cs = &(c->status[channel]); /* (pppppp) (piiiiiii) */ /* Bits 15-7 are the top 9 bits of the 16-bit initial predictor value */ predictor = AVRB16(src); stepindex = predictor & 0x7F; predictor &= 0xFF80; src += 2; if (cs->stepindex == stepindex) { int diff = (int)predictor - cs->predictor; if (diff < 0) diff = - diff; if (diff > 0x7f) goto update; } else { update: cs->stepindex = stepindex; cs->predictor = predictor; } if (cs->stepindex > 88){ avlog(avctx, AVLOGERROR, \"ERROR: stepindex = %i\\n\", cs->stepindex); cs->stepindex = 88; } samples = (short *)c->frame.data[0] + channel; for (m = 0; m < 32; m++) { *samples = adpcmimaqtexpandnibble(cs, src[0] & 0x0F, 3); samples += avctx->channels; *samples = adpcmimaqtexpandnibble(cs, src[0] >> 4 , 3); samples += avctx->channels; src ++; } } break; case CODECIDADPCMIMAWAV: if (avctx->blockalign != 0 && bufsize > avctx->blockalign) bufsize = avctx->blockalign; for(i=0; i<avctx->channels; i++){ cs = &(c->status[i]); cs->predictor = *samples++ = (int16t)bytestreamgetle16(&src); cs->stepindex = *src++; if (cs->stepindex > 88){ avlog(avctx, AVLOGERROR, \"ERROR: stepindex = %i\\n\", cs->stepindex); cs->stepindex = 88; } if (*src++) avlog(avctx, AVLOGERROR, \"unused byte should be null but is %d!!\\n\", src[-1]); /* unused */ } for (n = (nbsamples - 1) / 8; n > 0; n--) { for (i = 0; i < avctx->channels; i++) { cs = &c->status[i]; for (m = 0; m < 4; m++) { uint8t v = *src++; *samples = adpcmimaexpandnibble(cs, v & 0x0F, 3); samples += avctx->channels; *samples = adpcmimaexpandnibble(cs, v >> 4 , 3); samples += avctx->channels; } samples -= 8 * avctx->channels - 1; } samples += 7 * avctx->channels; } break; case CODECIDADPCM4XM: for (i = 0; i < avctx->channels; i++) c->status[i].predictor= (int16t)bytestreamgetle16(&src); for (i = 0; i < avctx->channels; i++) { c->status[i].stepindex= (int16t)bytestreamgetle16(&src); c->status[i].stepindex = avclip(c->status[i].stepindex, 0, 88); } for (i = 0; i < avctx->channels; i++) { samples = (short *)c->frame.data[0] + i; cs = &c->status[i]; for (n = nbsamples >> 1; n > 0; n--, src++) { uint8t v = *src; *samples = adpcmimaexpandnibble(cs, v & 0x0F, 4); samples += avctx->channels; *samples = adpcmimaexpandnibble(cs, v >> 4 , 4); samples += avctx->channels; } } break; case CODECIDADPCMMS: { int blockpredictor; if (avctx->blockalign != 0 && bufsize > avctx->blockalign) bufsize = avctx->blockalign; blockpredictor = avclip(*src++, 0, 6); c->status[0].coeff1 = ffadpcmAdaptCoeff1[blockpredictor]; c->status[0].coeff2 = ffadpcmAdaptCoeff2[blockpredictor]; if (st) { blockpredictor = avclip(*src++, 0, 6); c->status[1].coeff1 = ffadpcmAdaptCoeff1[blockpredictor]; c->status[1].coeff2 = ffadpcmAdaptCoeff2[blockpredictor]; } c->status[0].idelta = (int16t)bytestreamgetle16(&src); if (st){ c->status[1].idelta = (int16t)bytestreamgetle16(&src); } c->status[0].sample1 = bytestreamgetle16(&src); if (st) c->status[1].sample1 = bytestreamgetle16(&src); c->status[0].sample2 = bytestreamgetle16(&src); if (st) c->status[1].sample2 = bytestreamgetle16(&src); *samples++ = c->status[0].sample2; if (st) *samples++ = c->status[1].sample2; *samples++ = c->status[0].sample1; if (st) *samples++ = c->status[1].sample1; for(n = (nbsamples - 2) >> (1 - st); n > 0; n--, src++) { *samples++ = adpcmmsexpandnibble(&c->status[0 ], src[0] >> 4 ); *samples++ = adpcmmsexpandnibble(&c->status[st], src[0] & 0x0F); } break; } case CODECIDADPCMIMADK4: if (avctx->blockalign != 0 && bufsize > avctx->blockalign) bufsize = avctx->blockalign; for (channel = 0; channel < avctx->channels; channel++) { cs = &c->status[channel]; cs->predictor = (int16t)bytestreamgetle16(&src); cs->stepindex = *src++; src++; *samples++ = cs->predictor; } for (n = nbsamples >> (1 - st); n > 0; n--, src++) { uint8t v = *src; *samples++ = adpcmimaexpandnibble(&c->status[0 ], v >> 4 , 3); *samples++ = adpcmimaexpandnibble(&c->status[st], v & 0x0F, 3); } break; case CODECIDADPCMIMADK3: { unsigned char lastbyte = 0; unsigned char nibble; int decodetopnibblenext = 0; int endofpacket = 0; int diffchannel; if (avctx->blockalign != 0 && bufsize > avctx->blockalign) bufsize = avctx->blockalign; c->status[0].predictor = (int16t)AVRL16(src + 10); c->status[1].predictor = (int16t)AVRL16(src + 12); c->status[0].stepindex = src[14]; c->status[1].stepindex = src[15]; /* sign extend the predictors */ src += 16; diffchannel = c->status[1].predictor; /* the DK3GETNEXTNIBBLE macro issues the break statement when * the buffer is consumed */ while (1) { /* for this algorithm, c->status[0] is the sum channel and * c->status[1] is the diff channel */ /* process the first predictor of the sum channel */ DK3GETNEXTNIBBLE(); adpcmimaexpandnibble(&c->status[0], nibble, 3); /* process the diff channel predictor */ DK3GETNEXTNIBBLE(); adpcmimaexpandnibble(&c->status[1], nibble, 3); /* process the first pair of stereo PCM samples */ diffchannel = (diffchannel + c->status[1].predictor) / 2; *samples++ = c->status[0].predictor + c->status[1].predictor; *samples++ = c->status[0].predictor - c->status[1].predictor; /* process the second predictor of the sum channel */ DK3GETNEXTNIBBLE(); adpcmimaexpandnibble(&c->status[0], nibble, 3); /* process the second pair of stereo PCM samples */ diffchannel = (diffchannel + c->status[1].predictor) / 2; *samples++ = c->status[0].predictor + c->status[1].predictor; *samples++ = c->status[0].predictor - c->status[1].predictor; } break; } case CODECIDADPCMIMAISS: for (channel = 0; channel < avctx->channels; channel++) { cs = &c->status[channel]; cs->predictor = (int16t)bytestreamgetle16(&src); cs->stepindex = *src++; src++; } for (n = nbsamples >> (1 - st); n > 0; n--, src++) { uint8t v1, v2; uint8t v = *src; /* nibbles are swapped for mono */ if (st) { v1 = v >> 4; v2 = v & 0x0F; } else { v2 = v >> 4; v1 = v & 0x0F; } *samples++ = adpcmimaexpandnibble(&c->status[0 ], v1, 3); *samples++ = adpcmimaexpandnibble(&c->status[st], v2, 3); } break; case CODECIDADPCMIMAWS: while (src < buf + bufsize) { uint8t v = *src++; *samples++ = adpcmimaexpandnibble(&c->status[0], v >> 4 , 3); *samples++ = adpcmimaexpandnibble(&c->status[st], v & 0x0F, 3); } break; case CODECIDADPCMXA: while (bufsize >= 128) { xadecode(samples, src, &c->status[0], &c->status[1], avctx->channels); src += 128; samples += 28 * 8; bufsize -= 128; } break; case CODECIDADPCMIMAEAEACS: src += 4; // skip sample count (already read) for (i=0; i<=st; i++) c->status[i].stepindex = bytestreamgetle32(&src); for (i=0; i<=st; i++) c->status[i].predictor = bytestreamgetle32(&src); for (n = nbsamples >> (1 - st); n > 0; n--, src++) { *samples++ = adpcmimaexpandnibble(&c->status[0], *src>>4, 3); *samples++ = adpcmimaexpandnibble(&c->status[st], *src&0x0F, 3); } break; case CODECIDADPCMIMAEASEAD: for (n = nbsamples >> (1 - st); n > 0; n--, src++) { *samples++ = adpcmimaexpandnibble(&c->status[0], src[0] >> 4, 6); *samples++ = adpcmimaexpandnibble(&c->status[st],src[0]&0x0F, 6); } break; case CODECIDADPCMEA: { int32t previousleftsample, previousrightsample; int32t currentleftsample, currentrightsample; int32t nextleftsample, nextrightsample; int32t coeff1l, coeff2l, coeff1r, coeff2r; uint8t shiftleft, shiftright; /* Each EA ADPCM frame has a 12-byte header followed by 30-byte pieces, each coding 28 stereo samples. */ src += 4; // skip sample count (already read) currentleftsample = (int16t)bytestreamgetle16(&src); previousleftsample = (int16t)bytestreamgetle16(&src); currentrightsample = (int16t)bytestreamgetle16(&src); previousrightsample = (int16t)bytestreamgetle16(&src); for (count1 = 0; count1 < nbsamples / 28; count1++) { coeff1l = eaadpcmtable[ *src >> 4 ]; coeff2l = eaadpcmtable[(*src >> 4 ) + 4]; coeff1r = eaadpcmtable[*src & 0x0F]; coeff2r = eaadpcmtable[(*src & 0x0F) + 4]; src++; shiftleft = 20 - (*src >> 4); shiftright = 20 - (*src & 0x0F); src++; for (count2 = 0; count2 < 28; count2++) { nextleftsample = signextend(*src >> 4, 4) << shiftleft; nextrightsample = signextend(*src, 4) << shiftright; src++; nextleftsample = (nextleftsample + (currentleftsample * coeff1l) + (previousleftsample * coeff2l) + 0x80) >> 8; nextrightsample = (nextrightsample + (currentrightsample * coeff1r) + (previousrightsample * coeff2r) + 0x80) >> 8; previousleftsample = currentleftsample; currentleftsample = avclipint16(nextleftsample); previousrightsample = currentrightsample; currentrightsample = avclipint16(nextrightsample); *samples++ = (unsigned short)currentleftsample; *samples++ = (unsigned short)currentrightsample; } } if (src - buf == bufsize - 2) src += 2; // Skip terminating 0x0000 break; } case CODECIDADPCMEAMAXISXA: { int coeff[2][2], shift[2]; for(channel = 0; channel < avctx->channels; channel++) { for (i=0; i<2; i++) coeff[channel][i] = eaadpcmtable[(*src >> 4) + 4*i]; shift[channel] = 20 - (*src & 0x0F); src++; } for (count1 = 0; count1 < nbsamples / 2; count1++) { for(i = 4; i >= 0; i-=4) { /* Pairwise samples LL RR (st) or LL LL (mono) */ for(channel = 0; channel < avctx->channels; channel++) { int32t sample = signextend(src[channel] >> i, 4) << shift[channel]; sample = (sample + c->status[channel].sample1 * coeff[channel][0] + c->status[channel].sample2 * coeff[channel][1] + 0x80) >> 8; c->status[channel].sample2 = c->status[channel].sample1; c->status[channel].sample1 = avclipint16(sample); *samples++ = c->status[channel].sample1; } } src+=avctx->channels; } /* consume whole packet */ src = buf + bufsize; break; } case CODECIDADPCMEAR1: case CODECIDADPCMEAR2: case CODECIDADPCMEAR3: { /* channel numbering 2chan: 0=fl, 1=fr 4chan: 0=fl, 1=rl, 2=fr, 3=rr 6chan: 0=fl, 1=c, 2=fr, 3=rl, 4=rr, 5=sub */ const int bigendian = avctx->codec->id == CODECIDADPCMEAR3; int32t previoussample, currentsample, nextsample; int32t coeff1, coeff2; uint8t shift; unsigned int channel; uint16t *samplesC; const uint8t *srcC; const uint8t *srcend = buf + bufsize; int count = 0; src += 4; // skip sample count (already read) for (channel=0; channel<avctx->channels; channel++) { int32t offset = (bigendian ? bytestreamgetbe32(&src) : bytestreamgetle32(&src)) + (avctx->channels-channel-1) * 4; if ((offset < 0) || (offset >= srcend - src - 4)) break; srcC = src + offset; samplesC = samples + channel; if (avctx->codec->id == CODECIDADPCMEAR1) { currentsample = (int16t)bytestreamgetle16(&srcC); previoussample = (int16t)bytestreamgetle16(&srcC); } else { currentsample = c->status[channel].predictor; previoussample = c->status[channel].prevsample; } for (count1 = 0; count1 < nbsamples / 28; count1++) { if (*srcC == 0xEE) { /* only seen in R2 and R3 */ srcC++; if (srcC > srcend - 30*2) break; currentsample = (int16t)bytestreamgetbe16(&srcC); previoussample = (int16t)bytestreamgetbe16(&srcC); for (count2=0; count2<28; count2++) { *samplesC = (int16t)bytestreamgetbe16(&srcC); samplesC += avctx->channels; } } else { coeff1 = eaadpcmtable[ *srcC>>4 ]; coeff2 = eaadpcmtable[(*srcC>>4) + 4]; shift = 20 - (*srcC++ & 0x0F); if (srcC > srcend - 14) break; for (count2=0; count2<28; count2++) { if (count2 & 1) nextsample = signextend(*srcC++, 4) << shift; else nextsample = signextend(*srcC >> 4, 4) << shift; nextsample += (currentsample * coeff1) + (previoussample * coeff2); nextsample = avclipint16(nextsample >> 8); previoussample = currentsample; currentsample = nextsample; *samplesC = currentsample; samplesC += avctx->channels; } } } if (!count) { count = count1; } else if (count != count1) { avlog(avctx, AVLOGWARNING, \"per-channel sample count mismatch\\n\"); count = FFMAX(count, count1); } if (avctx->codec->id != CODECIDADPCMEAR1) { c->status[channel].predictor = currentsample; c->status[channel].prevsample = previoussample; } } c->frame.nbsamples = count * 28; src = srcend; break; } case CODECIDADPCMEAXAS: for (channel=0; channel<avctx->channels; channel++) { int coeff[2][4], shift[4]; short *s2, *s = &samples[channel]; for (n=0; n<4; n++, s+=32*avctx->channels) { for (i=0; i<2; i++) coeff[i][n] = eaadpcmtable[(src[0]&0x0F)+4*i]; shift[n] = 20 - (src[2] & 0x0F); for (s2=s, i=0; i<2; i++, src+=2, s2+=avctx->channels) s2[0] = (src[0]&0xF0) + (src[1]<<8); } for (m=2; m<32; m+=2) { s = &samples[m*avctx->channels + channel]; for (n=0; n<4; n++, src++, s+=32*avctx->channels) { for (s2=s, i=0; i<8; i+=4, s2+=avctx->channels) { int level = signextend(*src >> (4 - i), 4) << shift[n]; int pred = s2[-1*avctx->channels] * coeff[0][n] + s2[-2*avctx->channels] * coeff[1][n]; s2[0] = avclipint16((level + pred + 0x80) >> 8); } } } } break; case CODECIDADPCMIMAAMV: case CODECIDADPCMIMASMJPEG: c->status[0].predictor = (int16t)bytestreamgetle16(&src); c->status[0].stepindex = bytestreamgetle16(&src); if (avctx->codec->id == CODECIDADPCMIMAAMV) src+=4; for (n = nbsamples >> (1 - st); n > 0; n--, src++) { char hi, lo; lo = *src & 0x0F; hi = *src >> 4; if (avctx->codec->id == CODECIDADPCMIMAAMV) FFSWAP(char, hi, lo); *samples++ = adpcmimaexpandnibble(&c->status[0], lo, 3); *samples++ = adpcmimaexpandnibble(&c->status[0], hi, 3); } break; case CODECIDADPCMCT: for (n = nbsamples >> (1 - st); n > 0; n--, src++) { uint8t v = *src; *samples++ = adpcmctexpandnibble(&c->status[0 ], v >> 4 ); *samples++ = adpcmctexpandnibble(&c->status[st], v & 0x0F); } break; case CODECIDADPCMSBPRO4: case CODECIDADPCMSBPRO3: case CODECIDADPCMSBPRO2: if (!c->status[0].stepindex) { /* the first byte is a raw sample */ *samples++ = 128 * (*src++ - 0x80); if (st) *samples++ = 128 * (*src++ - 0x80); c->status[0].stepindex = 1; nbsamples--; } if (avctx->codec->id == CODECIDADPCMSBPRO4) { for (n = nbsamples >> (1 - st); n > 0; n--, src++) { *samples++ = adpcmsbproexpandnibble(&c->status[0], src[0] >> 4, 4, 0); *samples++ = adpcmsbproexpandnibble(&c->status[st], src[0] & 0x0F, 4, 0); } } else if (avctx->codec->id == CODECIDADPCMSBPRO3) { for (n = nbsamples / 3; n > 0; n--, src++) { *samples++ = adpcmsbproexpandnibble(&c->status[0], src[0] >> 5 , 3, 0); *samples++ = adpcmsbproexpandnibble(&c->status[0], (src[0] >> 2) & 0x07, 3, 0); *samples++ = adpcmsbproexpandnibble(&c->status[0], src[0] & 0x03, 2, 0); } } else { for (n = nbsamples >> (2 - st); n > 0; n--, src++) { *samples++ = adpcmsbproexpandnibble(&c->status[0], src[0] >> 6 , 2, 2); *samples++ = adpcmsbproexpandnibble(&c->status[st], (src[0] >> 4) & 0x03, 2, 2); *samples++ = adpcmsbproexpandnibble(&c->status[0], (src[0] >> 2) & 0x03, 2, 2); *samples++ = adpcmsbproexpandnibble(&c->status[st], src[0] & 0x03, 2, 2); } } break; case CODECIDADPCMSWF: { GetBitContext gb; const int *table; int k0, signmask, nbbits, count; int size = bufsize*8; initgetbits(&gb, buf, size); //read bits & initial values nbbits = getbits(&gb, 2)+2; //avlog(NULL,AVLOGINFO,\"nbbits: %d\\n\", nbbits); table = swfindextables[nbbits-2]; k0 = 1 << (nbbits-2); signmask = 1 << (nbbits-1); while (getbitscount(&gb) <= size - 22*avctx->channels) { for (i = 0; i < avctx->channels; i++) { *samples++ = c->status[i].predictor = getsbits(&gb, 16); c->status[i].stepindex = getbits(&gb, 6); } for (count = 0; getbitscount(&gb) <= size - nbbits*avctx->channels && count < 4095; count++) { int i; for (i = 0; i < avctx->channels; i++) { // similar to IMA adpcm int delta = getbits(&gb, nbbits); int step = ffadpcmsteptable[c->status[i].stepindex]; long vpdiff = 0; // vpdiff = (delta+0.5)*step/4 int k = k0; do { if (delta & k) vpdiff += step; step >>= 1; k >>= 1; } while(k); vpdiff += step; if (delta & signmask) c->status[i].predictor -= vpdiff; else c->status[i].predictor += vpdiff; c->status[i].stepindex += table[delta & (~signmask)]; c->status[i].stepindex = avclip(c->status[i].stepindex, 0, 88); c->status[i].predictor = avclipint16(c->status[i].predictor); *samples++ = c->status[i].predictor; } } } src += bufsize; break; } case CODECIDADPCMYAMAHA: for (n = nbsamples >> (1 - st); n > 0; n--, src++) { uint8t v = *src; *samples++ = adpcmyamahaexpandnibble(&c->status[0 ], v & 0x0F); *samples++ = adpcmyamahaexpandnibble(&c->status[st], v >> 4 ); } break; case CODECIDADPCMTHP: { int table[2][16]; int prev[2][2]; int ch; src += 4; // skip channel size src += 4; // skip number of samples (already read) for (i = 0; i < 32; i++) table[0][i] = (int16t)bytestreamgetbe16(&src); /* Initialize the previous sample. */ for (i = 0; i < 4; i++) prev[0][i] = (int16t)bytestreamgetbe16(&src); for (ch = 0; ch <= st; ch++) { samples = (short *)c->frame.data[0] + ch; /* Read in every sample for this channel. */ for (i = 0; i < nbsamples / 14; i++) { int index = (*src >> 4) & 7; unsigned int exp = *src++ & 15; int factor1 = table[ch][index * 2]; int factor2 = table[ch][index * 2 + 1]; /* Decode 14 samples. */ for (n = 0; n < 14; n++) { int32t sampledat; if(n&1) sampledat = signextend(*src++, 4); else sampledat = signextend(*src >> 4, 4); sampledat = ((prev[ch][0]*factor1 + prev[ch][1]*factor2) >> 11) + (sampledat << exp); *samples = avclipint16(sampledat); prev[ch][1] = prev[ch][0]; prev[ch][0] = *samples++; /* In case of stereo, skip one sample, this sample is for the other channel. */ samples += st; } } } break; } default: return -1; } *gotframeptr = 1; *(AVFrame *)data = c->frame; return src - buf; }", "target": 1}
{"func": "static void cpuioreqpio(ioreqt *req) { int i, sign; sign = req->df ? -1 : 1; if (req->dir == IOREQREAD) { if (!req->dataisptr) { req->data = doinp(req->addr, req->size); } else { uint32t tmp; for (i = 0; i < req->count; i++) { tmp = doinp(req->addr, req->size); cpuphysicalmemorywrite( req->data + (sign * i * (int64t)req->size), (uint8t *) &tmp, req->size); } } } else if (req->dir == IOREQWRITE) { if (!req->dataisptr) { dooutp(req->addr, req->size, req->data); } else { for (i = 0; i < req->count; i++) { uint32t tmp = 0; cpuphysicalmemoryread( req->data + (sign * i * (int64t)req->size), (uint8t*) &tmp, req->size); dooutp(req->addr, req->size, tmp); } } } } ", "target": 1}
{"func": "static char *choosepixelfmts(OutputStream *ost) { if (ost->keeppixfmt) { if (ost->filter) avfiltergraphsetautoconvert(ost->filter->graph->graph, AVFILTERAUTOCONVERTNONE); if (ost->st->codec->pixfmt == PIXFMTNONE) return NULL; ost->pixfmts[0] = ost->st->codec->pixfmt; return ost->pixfmts; } if (ost->st->codec->pixfmt != PIXFMTNONE) { return avstrdup(avgetpixfmtname(choosepixelfmt(ost->st, ost->enc, ost->st->codec->pixfmt))); } else if (ost->enc->pixfmts) { const enum PixelFormat *p; AVIOContext *s = NULL; uint8t *ret; int len; if (avioopendynbuf(&s) < 0) exitprogram(1); p = ost->enc->pixfmts; if (ost->st->codec->strictstdcompliance <= FFCOMPLIANCEUNOFFICIAL) { if (ost->st->codec->codecid == CODECIDMJPEG) { p = (const enum PixelFormat[]) { PIXFMTYUVJ420P, PIXFMTYUVJ422P, PIXFMTYUV420P, PIXFMTYUV422P, PIXFMTNONE }; } else if (ost->st->codec->codecid == CODECIDLJPEG) { p = (const enum PixelFormat[]) { PIXFMTYUVJ420P, PIXFMTYUVJ422P, PIXFMTYUVJ444P, PIXFMTYUV420P, PIXFMTYUV422P, PIXFMTYUV444P, PIXFMTBGRA, PIXFMTNONE }; } } for (; *p != PIXFMTNONE; p++) avioprintf(s, \"%s:\", avgetpixfmtname(*p)); len = avioclosedynbuf(s, &ret); ret[len - 1] = 0; return ret; } else return NULL; } ", "target": 1}
{"func": "static void movmetadatacreationtime(AVMetadata **metadata, timet time) { char buffer[32]; if (time) { time -= 2082844800; /* seconds between 1904-01-01 and Epoch */ strftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M:%S\", gmtime(&time)); avmetadataset2(metadata, \"creationtime\", buffer, 0); } } ", "target": 1}
{"func": "static uint32t hpetramreadl(void *opaque, targetphysaddrt addr) { HPETState *s = (HPETState *)opaque; uint64t curtick, index; DPRINTF(\"qemu: Enter hpetramreadl at %\" PRIx64 \"\\n\", addr); index = addr; /*address range of all TN regs*/ if (index >= 0x100 && index <= 0x3ff) { uint8t timerid = (addr - 0x100) / 0x20; if (timerid > HPETNUMTIMERS - 1) { printf(\"qemu: timer id out of range\\n\"); return 0; } HPETTimer *timer = &s->timer[timerid]; switch ((addr - 0x100) % 0x20) { case HPETTNCFG: return timer->config; case HPETTNCFG + 4: // Interrupt capabilities return timer->config >> 32; case HPETTNCMP: // comparator register return timer->cmp; case HPETTNCMP + 4: return timer->cmp >> 32; case HPETTNROUTE: return timer->fsb >> 32; default: DPRINTF(\"qemu: invalid hpetramreadl\\n\"); break; } } else { switch (index) { case HPETID: return s->capability; case HPETPERIOD: return s->capability >> 32; case HPETCFG: return s->config; case HPETCFG + 4: DPRINTF(\"qemu: invalid HPETCFG + 4 hpetramreadl \\n\"); return 0; case HPETCOUNTER: if (hpetenabled()) curtick = hpetgetticks(); else curtick = s->hpetcounter; DPRINTF(\"qemu: reading counter = %\" PRIx64 \"\\n\", curtick); return curtick; case HPETCOUNTER + 4: if (hpetenabled()) curtick = hpetgetticks(); else curtick = s->hpetcounter; DPRINTF(\"qemu: reading counter + 4 = %\" PRIx64 \"\\n\", curtick); return curtick >> 32; case HPETSTATUS: return s->isr; default: DPRINTF(\"qemu: invalid hpetramreadl\\n\"); break; } } return 0; } ", "target": 1}
{"func": "void usbclaimport(USBDevice *dev, Error **errp) { USBBus *bus = usbbusfromdevice(dev); USBPort *port; assert(dev->port == NULL); if (dev->portpath) { QTAILQFOREACH(port, &bus->free, next) { if (strcmp(port->path, dev->portpath) == 0) { break; } } if (port == NULL) { errorsetg(errp, \"usb port %s (bus %s) not found (in use?)\", dev->portpath, bus->qbus.name); return; } } else { if (bus->nfree == 1 && strcmp(objectgettypename(OBJECT(dev)), \"usb-hub\") != 0) { /* Create a new hub and chain it on */ usbcreatesimple(bus, \"usb-hub\"); } if (bus->nfree == 0) { errorsetg(errp, \"tried to attach usb device %s to a bus \" \"with no free ports\", dev->productdesc); return; } port = QTAILQFIRST(&bus->free); } traceusbportclaim(bus->busnr, port->path); QTAILQREMOVE(&bus->free, port, next); bus->nfree--; dev->port = port; port->dev = dev; QTAILQINSERTTAIL(&bus->used, port, next); bus->nused++; } ", "target": 1}
{"func": "static void vmxnet3updatefeatures(VMXNET3State *s) { uint32t guestfeatures; int rxcsosupported; guestfeatures = VMXNET3READDRVSHARED32(s->drvshmem, devRead.misc.uptFeatures); rxcsosupported = VMXNETFLAGISSET(guestfeatures, UPT1FRXCSUM); s->rxvlanstripping = VMXNETFLAGISSET(guestfeatures, UPT1FRXVLAN); s->lrosupported = VMXNETFLAGISSET(guestfeatures, UPT1FLRO); VMWCFPRN(\"Features configuration: LRO: %d, RXCSUM: %d, VLANSTRIP: %d\", s->lrosupported, rxcsosupported, s->rxvlanstripping); if (s->peerhasvhdr) { qemupeersetoffload(qemugetqueue(s->nic), rxcsosupported, s->lrosupported, s->lrosupported, 0, 0); } } ", "target": 0}
{"func": "static int virtioblkexitpci(PCIDevice *pcidev) { VirtIOPCIProxy *proxy = DOUPCAST(VirtIOPCIProxy, pcidev, pcidev); blockdevmarkautodel(proxy->block.dinfo->bdrv); return virtioexitpci(pcidev); } ", "target": 0}
{"func": "yuv2rgba64full1ctemplate(SwsContext *c, const int32t *buf0, const int32t *ubuf[2], const int32t *vbuf[2], const int32t *abuf0, uint16t *dest, int dstW, int uvalpha, int y, enum AVPixelFormat target, int hasAlpha, int eightbytes) { const int32t *ubuf0 = ubuf[0], *vbuf0 = vbuf[0]; int i; int A = 0xffff<<14; if (uvalpha < 2048) { for (i = 0; i < dstW; i++) { int Y = (buf0[i]) >> 2; int U = (ubuf0[i] + (-128 << 11)) >> 2; int V = (vbuf0[i] + (-128 << 11)) >> 2; int R, G, B; Y -= c->yuv2rgbyoffset; Y *= c->yuv2rgbycoeff; Y += 1 << 13; if (hasAlpha) { A = abuf0[i] << 11; A += 1 << 13; } R = V * c->yuv2rgbv2rcoeff; G = V * c->yuv2rgbv2gcoeff + U * c->yuv2rgbu2gcoeff; B = U * c->yuv2rgbu2bcoeff; outputpixel(&dest[0], avclipuintp2(RB + Y, 30) >> 14); outputpixel(&dest[1], avclipuintp2( G + Y, 30) >> 14); outputpixel(&dest[2], avclipuintp2(BR + Y, 30) >> 14); if (eightbytes) { outputpixel(&dest[3], avclipuintp2(A, 30) >> 14); dest += 4; } else { dest += 3; } } } else { const int32t *ubuf1 = ubuf[1], *vbuf1 = vbuf[1]; int A = 0xffff<<14; for (i = 0; i < dstW; i++) { int Y = (buf0[i] ) >> 2; int U = (ubuf0[i] + ubuf1[i] + (-128 << 12)) >> 3; int V = (vbuf0[i] + vbuf1[i] + (-128 << 12)) >> 3; int R, G, B; Y -= c->yuv2rgbyoffset; Y *= c->yuv2rgbycoeff; Y += 1 << 13; if (hasAlpha) { A = abuf0[i] << 11; A += 1 << 13; } R = V * c->yuv2rgbv2rcoeff; G = V * c->yuv2rgbv2gcoeff + U * c->yuv2rgbu2gcoeff; B = U * c->yuv2rgbu2bcoeff; outputpixel(&dest[0], avclipuintp2(RB + Y, 30) >> 14); outputpixel(&dest[1], avclipuintp2( G + Y, 30) >> 14); outputpixel(&dest[2], avclipuintp2(BR + Y, 30) >> 14); if (eightbytes) { outputpixel(&dest[3], avclipuintp2(A, 30) >> 14); dest += 4; } else { dest += 3; } } } } ", "target": 0}
{"func": "static void uhciasynccomplete(USBPacket *packet, void *opaque) { UHCIState *s = opaque; UHCIAsync *async = (UHCIAsync *) packet; DPRINTF(\"uhci: async complete. td 0x%x token 0x%x\\n\", async->td, async->token); async->done = 1; uhciprocessframe(s); } ", "target": 0}
{"func": "static void genneonunzip(int reg, int q, int tmp, int size) { int n; TCGv t0, t1; for (n = 0; n < q + 1; n += 2) { t0 = neonloadreg(reg, n); t1 = neonloadreg(reg, n + 1); switch (size) { case 0: genneonunzipu8(t0, t1); break; case 1: genneonzipu16(t0, t1); break; /* zip and unzip are the same. */ case 2: /* no-op */; break; default: abort(); } neonstorescratch(tmp + n, t0); neonstorescratch(tmp + n + 1, t1); } } ", "target": 0}
{"func": "static void parsenumadistance(NumaDistOptions *dist, Error **errp) { uint16t src = dist->src; uint16t dst = dist->dst; uint8t val = dist->val; if (src >= MAXNODES || dst >= MAXNODES) { errorsetg(errp, \"Invalid node %\" PRIu16 \", max possible could be %\" PRIu16, MAX(src, dst), MAXNODES); return; } if (!numainfo[src].present || !numainfo[dst].present) { errorsetg(errp, \"Source/Destination NUMA node is missing. \" \"Please use '-numa node' option to declare it first.\"); return; } if (val < NUMADISTANCEMIN) { errorsetg(errp, \"NUMA distance (%\" PRIu8 \") is invalid, \" \"it shouldn't be less than %d.\", val, NUMADISTANCEMIN); return; } if (src == dst && val != NUMADISTANCEMIN) { errorsetg(errp, \"Local distance of node %d should be %d.\", src, NUMADISTANCEMIN); return; } numainfo[src].distance[dst] = val; havenumadistance = true; } ", "target": 0}
{"func": "static int parsepalette(AVCodecContext *avctx, GetByteContext *gbc, uint32t *pal, int colors) { int i; for (i = 0; i <= colors; i++) { uint8t r, g, b; unsigned int idx = bytestream2getbe16(gbc); /* color index */ if (idx > 255) { avlog(avctx, AVLOGWARNING, \"Palette index out of range: %u\\n\", idx); bytestream2skip(gbc, 6); continue; } r = bytestream2getbyte(gbc); bytestream2skip(gbc, 1); g = bytestream2getbyte(gbc); bytestream2skip(gbc, 1); b = bytestream2getbyte(gbc); bytestream2skip(gbc, 1); pal[idx] = (r << 16) | (g << 8) | b; } return 0; } ", "target": 1}
{"func": "static int compareint64(const void *a, const void *b) { int64t va = *(int64t *)a, vb = *(int64t *)b; return va < vb ? -1 : va > vb ? +1 : 0; } ", "target": 1}
{"func": "uint32t kvmarchgetsupportedcpuid(CPUState *env, uint32t function, uint32t index, int reg) { struct kvmcpuid2 *cpuid; int i, max; uint32t ret = 0; uint32t cpuid1edx; if (!kvmcheckextension(env->kvmstate, KVMCAPEXTCPUID)) { return -1U; } max = 1; while ((cpuid = trygetcpuid(env->kvmstate, max)) == NULL) { max *= 2; } for (i = 0; i < cpuid->nent; ++i) { if (cpuid->entries[i].function == function && cpuid->entries[i].index == index) { switch (reg) { case REAX: ret = cpuid->entries[i].eax; break; case REBX: ret = cpuid->entries[i].ebx; break; case RECX: ret = cpuid->entries[i].ecx; break; case REDX: ret = cpuid->entries[i].edx; switch (function) { case 1: /* KVM before 2.6.30 misreports the following features */ ret |= CPUIDMTRR | CPUIDPAT | CPUIDMCE | CPUIDMCA; break; case 0x80000001: /* On Intel, kvm returns cpuid according to the Intel spec, * so add missing bits according to the AMD spec: */ cpuid1edx = kvmarchgetsupportedcpuid(env, 1, 0, REDX); ret |= cpuid1edx & 0x183f7ff; break; } break; } } } qemufree(cpuid); return ret; } ", "target": 1}
{"func": "static bool getnextpage(GuestPhysBlock **blockptr, uint64t *pfnptr, uint8t **bufptr, DumpState *s) { GuestPhysBlock *block = *blockptr; hwaddr addr; uint8t *buf; /* block == NULL means the start of the iteration */ if (!block) { block = QTAILQFIRST(&s->guestphysblocks.head); *blockptr = block; assert(block->targetstart % s->pagesize == 0); assert(block->targetend % s->pagesize == 0); *pfnptr = paddrtopfn(block->targetstart); if (bufptr) { *bufptr = block->hostaddr; } return true; } *pfnptr = *pfnptr + 1; addr = pfntopaddr(*pfnptr); if ((addr >= block->targetstart) && (addr + s->pagesize <= block->targetend)) { buf = block->hostaddr + (addr - block->targetstart); } else { /* the next page is in the next block */ block = QTAILQNEXT(block, next); *blockptr = block; if (!block) { return false; } assert(block->targetstart % s->pagesize == 0); assert(block->targetend % s->pagesize == 0); *pfnptr = paddrtopfn(block->targetstart); buf = block->hostaddr; } if (bufptr) { *bufptr = buf; } return true; } ", "target": 0}
{"func": "static coroutinefn int qcow2cowritev(BlockDriverState *bs, int64t sectornum, int remainingsectors, QEMUIOVector *qiov) { BDRVQcowState *s = bs->opaque; int indexincluster; int nend; int ret; int curnrsectors; /* number of sectors in current iteration */ uint64t clusteroffset; QEMUIOVector hdqiov; uint64t bytesdone = 0; uint8t *clusterdata = NULL; QCowL2Meta *l2meta; traceqcow2writevstartreq(qemucoroutineself(), sectornum, remainingsectors); qemuiovecinit(&hdqiov, qiov->niov); s->clustercacheoffset = -1; /* disable compressed cache */ qemucomutexlock(&s->lock); while (remainingsectors != 0) { l2meta = NULL; traceqcow2writevstartpart(qemucoroutineself()); indexincluster = sectornum & (s->clustersectors - 1); nend = indexincluster + remainingsectors; if (s->cryptmethod && nend > QCOWMAXCRYPTCLUSTERS * s->clustersectors) { nend = QCOWMAXCRYPTCLUSTERS * s->clustersectors; } ret = qcow2allocclusteroffset(bs, sectornum << 9, indexincluster, nend, &curnrsectors, &clusteroffset, &l2meta); if (ret < 0) { goto fail; } if (l2meta->nbclusters > 0 && (s->compatiblefeatures & QCOW2COMPATLAZYREFCOUNTS)) { qcow2markdirty(bs); } assert((clusteroffset & 511) == 0); qemuiovecreset(&hdqiov); qemuiovecconcat(&hdqiov, qiov, bytesdone, curnrsectors * 512); if (s->cryptmethod) { if (!clusterdata) { clusterdata = qemublockalign(bs, QCOWMAXCRYPTCLUSTERS * s->clustersize); } assert(hdqiov.size <= QCOWMAXCRYPTCLUSTERS * s->clustersize); qemuiovectobuf(&hdqiov, 0, clusterdata, hdqiov.size); qcow2encryptsectors(s, sectornum, clusterdata, clusterdata, curnrsectors, 1, &s->aesencryptkey); qemuiovecreset(&hdqiov); qemuiovecadd(&hdqiov, clusterdata, curnrsectors * 512); } qemucomutexunlock(&s->lock); BLKDBGEVENT(bs->file, BLKDBGWRITEAIO); traceqcow2writevdata(qemucoroutineself(), (clusteroffset >> 9) + indexincluster); ret = bdrvcowritev(bs->file, (clusteroffset >> 9) + indexincluster, curnrsectors, &hdqiov); qemucomutexlock(&s->lock); if (ret < 0) { goto fail; } if (l2meta != NULL) { ret = qcow2allocclusterlinkl2(bs, l2meta); if (ret < 0) { goto fail; } rundependentrequests(s, l2meta); gfree(l2meta); l2meta = NULL; } remainingsectors -= curnrsectors; sectornum += curnrsectors; bytesdone += curnrsectors * 512; traceqcow2writevdonepart(qemucoroutineself(), curnrsectors); } ret = 0; fail: if (l2meta != NULL) { rundependentrequests(s, l2meta); gfree(l2meta); } qemucomutexunlock(&s->lock); qemuiovecdestroy(&hdqiov); qemuvfree(clusterdata); traceqcow2writevdonereq(qemucoroutineself(), ret); return ret; } ", "target": 0}
{"func": "int usbdescgetdescriptor(USBDevice *dev, int value, uint8t *dest, sizet len) { const USBDesc *desc = dev->info->usbdesc; uint8t buf[256]; uint8t type = value >> 8; uint8t index = value & 0xff; int ret = -1; switch(type) { case USBDTDEVICE: ret = usbdescdevice(&desc->id, desc->full, buf, sizeof(buf)); traceusbdescdevice(dev->addr, len, ret); break; case USBDTCONFIG: if (index < desc->full->bNumConfigurations) { ret = usbdescconfig(desc->full->confs + index, buf, sizeof(buf)); } traceusbdescconfig(dev->addr, index, len, ret); break; case USBDTSTRING: ret = usbdescstring(dev, index, buf, sizeof(buf)); traceusbdescstring(dev->addr, index, len, ret); break; default: fprintf(stderr, \"%s: %d unknown type %d (len %zd)\\n\", FUNCTION, dev->addr, type, len); break; } if (ret > 0) { if (ret > len) { ret = len; } memcpy(dest, buf, ret); } return ret; } ", "target": 0}
{"func": "static void connexinit(MachineState *machine) { PXA2xxState *cpu; DriveInfo *dinfo; int be; MemoryRegion *addressspacemem = getsystemmemory(); uint32t connexrom = 0x01000000; uint32t connexram = 0x04000000; cpu = pxa255init(addressspacemem, connexram); dinfo = driveget(IFPFLASH, 0, 0); if (!dinfo && !qtestenabled()) { fprintf(stderr, \"A flash image must be given with the \" \"'pflash' parameter\\n\"); exit(1); } #ifdef TARGETWORDSBIGENDIAN be = 1; #else be = 0; #endif if (!pflashcfi01register(0x00000000, NULL, \"connext.rom\", connexrom, dinfo ? blkbs(blkbylegacydinfo(dinfo)) : NULL, sectorlen, connexrom / sectorlen, 2, 0, 0, 0, 0, be)) { fprintf(stderr, \"qemu: Error registering flash memory.\\n\"); exit(1); } /* Interrupt line of NIC is connected to GPIO line 36 */ smc91c111init(&ndtable[0], 0x04000300, qdevgetgpioin(cpu->gpio, 36)); } ", "target": 0}
{"func": "void aioseteventnotifier(AioContext *ctx, EventNotifier *notifier, bool isexternal, EventNotifierHandler *ioread, AioPollFn *iopoll) { aiosetfdhandler(ctx, eventnotifiergetfd(notifier), isexternal, (IOHandler *)ioread, NULL, iopoll, notifier); } ", "target": 0}
{"func": "void avxteacrypt(AVXTEA *ctx, uint8t *dst, const uint8t *src, int count, uint8t *iv, int decrypt) { int i; while (count > 0) { if (decrypt) { xteacryptecb(ctx, dst, src, decrypt); if (iv) { for (i = 0; i < 8; i++) dst[i] = dst[i] ^ iv[i]; memcpy(iv, src, 8); } } else { if (iv) { for (i = 0; i < 8; i++) dst[i] = src[i] ^ iv[i]; xteacryptecb(ctx, dst, dst, decrypt); memcpy(iv, dst, 8); } else { xteacryptecb(ctx, dst, src, decrypt); } } src += 8; dst += 8; count -= 8; } } ", "target": 0}
{"func": "static void readchapter(AVFormatContext *s, AVIOContext *pb, int len, char *ttag, ID3v2ExtraMeta **extrameta) { AVRational timebase = {1, 1000}; uint32t start, end; AVChapter *chapter; uint8t *dst = NULL; int taglen; char tag[5]; decodestr(s, pb, 0, &dst, &len); if (len < 16) return; start = aviorb32(pb); end = aviorb32(pb); avioskip(pb, 8); chapter = avprivnewchapter(s, s->nbchapters + 1, timebase, start, end, dst); if (!chapter) { avfree(dst); return; } len -= 16; while (len > 10) { avioread(pb, tag, 4); tag[4] = 0; taglen = aviorb32(pb); avioskip(pb, 2); len -= 10; if (taglen < 0 || taglen > len) { avfree(dst); return; } if (tag[0] == 'T') readttag(s, pb, taglen, &chapter->metadata, tag); else avioskip(pb, taglen); len -= taglen; } ffmetadataconv(&chapter->metadata, NULL, ffid3v234metadataconv); ffmetadataconv(&chapter->metadata, NULL, ffid3v24metadataconv); avfree(dst); } ", "target": 0}
{"func": "void kqemumodifypage(CPUState *env, ramaddrt ramaddr) { unsigned long pageindex; int ret; #ifdef WIN32 DWORD temp; #endif pageindex = ramaddr >> TARGETPAGEBITS; if (!modifiedrampagestable[pageindex]) { #if 0 printf(\"%d: modifypage=%08lx\\n\", nbmodifiedrampages, ramaddr); #endif modifiedrampagestable[pageindex] = 1; modifiedrampages[nbmodifiedrampages++] = ramaddr; if (nbmodifiedrampages >= KQEMUMAXMODIFIEDRAMPAGES) { /* flush */ #ifdef WIN32 ret = DeviceIoControl(kqemufd, KQEMUMODIFYRAMPAGES, &nbmodifiedrampages, sizeof(nbmodifiedrampages), NULL, 0, &temp, NULL); #else ret = ioctl(kqemufd, KQEMUMODIFYRAMPAGES, &nbmodifiedrampages); #endif kqemuresetmodifiedrampages(); } } } ", "target": 0}
{"func": "static bool aioepollcheckpoll(AioContext *ctx, GPollFD *pfds, unsigned npfd, int64t timeout) { if (!ctx->epollavailable) { return false; } if (aioepollenabled(ctx)) { return true; } if (npfd >= EPOLLENABLETHRESHOLD) { if (aioepolltryenable(ctx)) { return true; } else { aioepolldisable(ctx); } } return false; } ", "target": 0}
{"func": "static void aarch64cpuregistertypes(void) { int i; typeregisterstatic(&aarch64cputypeinfo); for (i = 0; i < ARRAYSIZE(aarch64cpus); i++) { aarch64cpuregister(&aarch64cpus[i]); } } ", "target": 0}
{"func": "static void musicpallcdwrite(void *opaque, targetphysaddrt offset, uint64t value, unsigned size) { musicpallcdstate *s = opaque; switch (offset) { case MPLCDIRQCTRL: s->irqctrl = value; break; case MPLCDSPICTRL: if (value == MPLCDSPIDATA || value == MPLCDSPICMD) { s->mode = value; } else { s->mode = MPLCDSPIINVALID; } break; case MPLCDINST: if (value >= MPLCDINSTSETPAGE0 && value <= MPLCDINSTSETPAGE7) { s->page = value - MPLCDINSTSETPAGE0; s->pageoff = 0; } break; case MPLCDDATA: if (s->mode == MPLCDSPICMD) { if (value >= MPLCDINSTSETPAGE0 && value <= MPLCDINSTSETPAGE7) { s->page = value - MPLCDINSTSETPAGE0; s->pageoff = 0; } } else if (s->mode == MPLCDSPIDATA) { s->videoram[s->page*128 + s->pageoff] = value; s->pageoff = (s->pageoff + 1) & 127; } break; } } ", "target": 0}
{"func": "static inline uint32t nvicgpriomask(NVICState *s) { return ~0U << (s->prigroup + 1); } ", "target": 0}
{"func": "int qemueventfd(int fds[2]) { #ifdef CONFIGEVENTFD int ret; ret = eventfd(0, 0); if (ret >= 0) { fds[0] = ret; qemusetcloexec(ret); if ((fds[1] = dup(ret)) == -1) { close(ret); return -1; } qemusetcloexec(fds[1]); return 0; } if (errno != ENOSYS) { return -1; } #endif return qemupipe(fds); } ", "target": 0}
{"func": "static int bdrvqedtruncate(BlockDriverState *bs, int64t offset) { return -ENOTSUP; } ", "target": 0}
{"func": "void HELPER(wsribreakenable)(uint32t v) { uint32t change = v ^ env->sregs[IBREAKENABLE]; unsigned i; for (i = 0; i < env->config->nibreak; ++i) { if (change & (1 << i)) { tbinvalidatephyspagerange( env->sregs[IBREAKA + i], env->sregs[IBREAKA + i] + 1, 0); } } env->sregs[IBREAKENABLE] = v & ((1 << env->config->nibreak) - 1); } ", "target": 0}
{"func": "static void openrisccpuclassinit(ObjectClass *oc, void *data) { OpenRISCCPUClass *occ = OPENRISCCPUCLASS(oc); CPUClass *cc = CPUCLASS(occ); DeviceClass *dc = DEVICECLASS(oc); occ->parentrealize = dc->realize; dc->realize = openrisccpurealizefn; occ->parentreset = cc->reset; cc->reset = openrisccpureset; cc->classbyname = openrisccpuclassbyname; cc->haswork = openrisccpuhaswork; cc->dointerrupt = openrisccpudointerrupt; cc->cpuexecinterrupt = openrisccpuexecinterrupt; cc->dumpstate = openrisccpudumpstate; cc->setpc = openrisccpusetpc; cc->gdbreadregister = openrisccpugdbreadregister; cc->gdbwriteregister = openrisccpugdbwriteregister; #ifdef CONFIGUSERONLY cc->handlemmufault = openrisccpuhandlemmufault; #else cc->getphyspagedebug = openrisccpugetphyspagedebug; dc->vmsd = &vmstateopenrisccpu; #endif cc->gdbnumcoreregs = 32 + 3; /* * Reason: openrisccpuinitfn() calls cpuexecinit(), which saves * the object in cpus -> dangling pointer after final * objectunref(). */ dc->cannotdestroywithobjectfinalizeyet = true; } ", "target": 1}
{"func": "static void tcpacceptincomingmigration(void *opaque) { struct sockaddrin addr; socklent addrlen = sizeof(addr); int s = (intptrt)opaque; QEMUFile *f; int c; do { c = qemuaccept(s, (struct sockaddr *)&addr, &addrlen); } while (c == -1 && socketerror() == EINTR); qemusetfdhandler2(s, NULL, NULL, NULL, NULL); closesocket(s); DPRINTF(\"accepted migration\\n\"); if (c == -1) { fprintf(stderr, \"could not accept migration connection\\n\"); goto out; } f = qemufopensocket(c, \"rb\"); if (f == NULL) { fprintf(stderr, \"could not qemufopen socket\\n\"); goto out; } processincomingmigration(f); return; out: closesocket(c); } ", "target": 1}
{"func": "static void quorumcopyqiov(QEMUIOVector *dest, QEMUIOVector *source) { int i; assert(dest->niov == source->niov); assert(dest->size == source->size); for (i = 0; i < source->niov; i++) { assert(dest->iov[i].iovlen == source->iov[i].iovlen); memcpy(dest->iov[i].iovbase, source->iov[i].iovbase, source->iov[i].iovlen); } } ", "target": 1}
{"func": "static int decodesgirle8(AVCodecContext *avctx, uint8t *dst, const uint8t *src, int srcsize, int width, int height, int linesize) { const uint8t *srcend = src + srcsize; int x = 0, y = 0; #define INCXY(n) \\ x += n; \\ if (x >= width) { \\ y++; \\ if (y >= height) \\ return 0; \\ x = 0; \\ } while (srcend - src >= 2) { uint8t v = *src++; if (v > 0 && v < 0xC0) { do { int length = FFMIN(v, width - x); memset(dst + y*linesize + x, RGB332TOBGR8(*src), length); INCXY(length); v -= length; } while (v > 0); src++; } else if (v >= 0xC1) { v -= 0xC0; do { int length = FFMIN3(v, width - x, srcend - src); if (srcend - src < length) break; memcpyrgb332tobgr8(dst + y*linesize + x, src, length); INCXY(length); src += length; v -= length; } while (v > 0); } else { avprivrequestsample(avctx, \"opcode %d\", v); return AVERRORPATCHWELCOME; } } return 0; } ", "target": 0}
{"func": "static int hlsreadseek(AVFormatContext *s, int streamindex, int64t timestamp, int flags) { HLSContext *c = s->privdata; int i; int64t seektimestamp; int validfor = -1; if ((flags & AVSEEKFLAGBYTE) || !c->variants[0]->playlists[0]->finished) return AVERROR(ENOSYS); seektimestamp = streamindex < 0 ? timestamp : avrescalernd(timestamp, AVTIMEBASE, s->streams[streamindex]->timebase.den, flags & AVSEEKFLAGBACKWARD ? AVROUNDDOWN : AVROUNDUP); if (s->duration < seektimestamp) return AVERROR(EIO); for (i = 0; i < c->nplaylists; i++) { /* check first that the timestamp is valid for some playlist */ struct playlist *pls = c->playlists[i]; int seqno; if (findtimestampinplaylist(c, pls, seektimestamp, &seqno)) { /* set segment now so we do not need to search again below */ pls->curseqno = seqno; validfor = i; break; } } if (validfor < 0) return AVERROR(EIO); for (i = 0; i < c->nplaylists; i++) { /* Reset reading */ struct playlist *pls = c->playlists[i]; if (pls->input) { ffurlclose(pls->input); pls->input = NULL; } avfreepacket(&pls->pkt); resetpacket(&pls->pkt); pls->pb.eofreached = 0; /* Clear any buffered data */ pls->pb.bufend = pls->pb.bufptr = pls->pb.buffer; /* Reset the pos, to let the mpegts demuxer know we've seeked. */ pls->pb.pos = 0; pls->seektimestamp = seektimestamp; pls->seekflags = flags; /* set closest segment seqno for playlists not handled above */ if (validfor != i) findtimestampinplaylist(c, pls, seektimestamp, &pls->curseqno); } c->curtimestamp = seektimestamp; return 0; } ", "target": 0}
{"func": "static int assignedinitfn(struct PCIDevice *pcidev) { AssignedDevice *dev = DOUPCAST(AssignedDevice, dev, pcidev); uint8t eintx; int r; Error *localerr = NULL; if (!kvmenabled()) { errorreport(\"pci-assign: error: requires KVM support\"); return -1; } if (!dev->host.domain && !dev->host.bus && !dev->host.slot && !dev->host.function) { errorreport(\"pci-assign: error: no host device specified\"); return -1; } /* * Set up basic config space access control. Will be further refined during * device initialization. */ assigneddevemulateconfigread(dev, 0, PCICONFIGSPACESIZE); assigneddevdirectconfigread(dev, PCISTATUS, 2); assigneddevdirectconfigread(dev, PCIREVISIONID, 1); assigneddevdirectconfigread(dev, PCICLASSPROG, 3); assigneddevdirectconfigread(dev, PCICACHELINESIZE, 1); assigneddevdirectconfigread(dev, PCILATENCYTIMER, 1); assigneddevdirectconfigread(dev, PCIBIST, 1); assigneddevdirectconfigread(dev, PCICARDBUSCIS, 4); assigneddevdirectconfigread(dev, PCISUBSYSTEMVENDORID, 2); assigneddevdirectconfigread(dev, PCISUBSYSTEMID, 2); assigneddevdirectconfigread(dev, PCICAPABILITYLIST + 1, 7); assigneddevdirectconfigread(dev, PCIMINGNT, 1); assigneddevdirectconfigread(dev, PCIMAXLAT, 1); memcpy(dev->emulateconfigwrite, dev->emulateconfigread, sizeof(dev->emulateconfigread)); getrealdevice(dev, &localerr); if (localerr) { qerrorreporterr(localerr); errorfree(localerr); goto out; } if (assigneddevicepcicapinit(pcidev, &localerr) < 0) { qerrorreporterr(localerr); errorfree(localerr); goto out; } /* intercept MSI-X entry page in the MMIO */ if (dev->cap.available & ASSIGNEDDEVICECAPMSIX) { assigneddevregistermsixmmio(dev, &localerr); if (localerr) { qerrorreporterr(localerr); errorfree(localerr); goto out; } } /* handle real device's MMIO/PIO BARs */ assigneddevregisterregions(dev->realdevice.regions, dev->realdevice.regionnumber, dev, &localerr); if (localerr) { qerrorreporterr(localerr); errorfree(localerr); goto out; } /* handle interrupt routing */ eintx = dev->dev.config[PCIINTERRUPTPIN] - 1; dev->intpin = eintx; dev->intxroute.mode = PCIINTXDISABLED; dev->intxroute.irq = -1; /* assign device to guest */ r = assigndevice(dev); if (r < 0) { goto out; } /* assign legacy INTx to the device */ r = assignintx(dev); if (r < 0) { goto assignedout; } assigneddevloadoptionrom(dev); addbootdevicepath(dev->bootindex, &pcidev->qdev, NULL); return 0; assignedout: deassigndevice(dev); out: freeassigneddevice(dev); return -1; } ", "target": 0}
{"func": "int xenbesendnotify(struct XenDevice *xendev) { return xcevtchnnotify(xendev->evtchndev, xendev->localport); } ", "target": 0}
{"func": "static int64t wraptimestamp(AVStream *st, int64t timestamp) { if (st->ptswrapbehavior != AVPTSWRAPIGNORE && st->ptswrapbits < 64 && st->ptswrapreference != AVNOPTSVALUE && timestamp != AVNOPTSVALUE) { if (st->ptswrapbehavior == AVPTSWRAPADDOFFSET && timestamp < st->ptswrapreference) return timestamp + (1ULL<<st->ptswrapbits); else if (st->ptswrapbehavior == AVPTSWRAPSUBOFFSET && timestamp >= st->ptswrapreference) return timestamp - (1ULL<<st->ptswrapbits); } return timestamp; } ", "target": 0}
{"func": "static void ideatapicmdreplyend(IDEState *s) { int bytecountlimit, size, ret; #ifdef DEBUGIDEATAPI printf(\"reply: txsize=%d elemtxsize=%d index=%d\\n\", s->packettransfersize, s->elementarytransfersize, s->iobufferindex); #endif if (s->packettransfersize <= 0) { /* end of transfer */ idetransferstop(s); s->status = READYSTAT; s->nsector = (s->nsector & ~7) | ATAPIINTREASONIO | ATAPIINTREASONCD; idesetirq(s); #ifdef DEBUGIDEATAPI printf(\"status=0x%x\\n\", s->status); #endif } else { /* see if a new sector must be read */ if (s->lba != -1 && s->iobufferindex >= s->cdsectorsize) { ret = cdreadsector(s->bs, s->lba, s->iobuffer, s->cdsectorsize); if (ret < 0) { idetransferstop(s); ideatapiioerror(s, ret); return; } s->lba++; s->iobufferindex = 0; } if (s->elementarytransfersize > 0) { /* there are some data left to transmit in this elementary transfer */ size = s->cdsectorsize - s->iobufferindex; if (size > s->elementarytransfersize) size = s->elementarytransfersize; idetransferstart(s, s->iobuffer + s->iobufferindex, size, ideatapicmdreplyend); s->packettransfersize -= size; s->elementarytransfersize -= size; s->iobufferindex += size; } else { /* a new transfer is needed */ s->nsector = (s->nsector & ~7) | ATAPIINTREASONIO; bytecountlimit = s->lcyl | (s->hcyl << 8); #ifdef DEBUGIDEATAPI printf(\"bytecountlimit=%d\\n\", bytecountlimit); #endif if (bytecountlimit == 0xffff) bytecountlimit--; size = s->packettransfersize; if (size > bytecountlimit) { /* byte count limit must be even if this case */ if (bytecountlimit & 1) bytecountlimit--; size = bytecountlimit; } s->lcyl = size; s->hcyl = size >> 8; s->elementarytransfersize = size; /* we cannot transmit more than one sector at a time */ if (s->lba != -1) { if (size > (s->cdsectorsize - s->iobufferindex)) size = (s->cdsectorsize - s->iobufferindex); } idetransferstart(s, s->iobuffer + s->iobufferindex, size, ideatapicmdreplyend); s->packettransfersize -= size; s->elementarytransfersize -= size; s->iobufferindex += size; idesetirq(s); #ifdef DEBUGIDEATAPI printf(\"status=0x%x\\n\", s->status); #endif } } } ", "target": 0}
{"func": "static void slavioledmemwrites(void *opaque, targetphysaddrt addr, uint32t val) { MiscState *s = opaque; uint32t saddr; saddr = addr & LEDMAXADDR; MISCDPRINTF(\"Write diagnostic LED reg 0x\" TARGETFMTplx \" = %x\\n\", addr, val); switch (saddr) { case 0: s->leds = val; break; default: break; } } ", "target": 0}
{"func": "int coroutinefn bdrvcodiscard(BlockDriverState *bs, int64t sectornum, int nbsectors) { int maxdiscard; if (!bs->drv) { return -ENOMEDIUM; } else if (bdrvcheckrequest(bs, sectornum, nbsectors)) { return -EIO; } else if (bs->readonly) { return -EROFS; } bdrvresetdirty(bs, sectornum, nbsectors); /* Do nothing if disabled. */ if (!(bs->openflags & BDRVOUNMAP)) { return 0; } if (!bs->drv->bdrvcodiscard && !bs->drv->bdrvaiodiscard) { return 0; } maxdiscard = bs->bl.maxdiscard ? bs->bl.maxdiscard : MAXDISCARDDEFAULT; while (nbsectors > 0) { int ret; int num = nbsectors; /* align request */ if (bs->bl.discardalignment && num >= bs->bl.discardalignment && sectornum % bs->bl.discardalignment) { if (num > bs->bl.discardalignment) { num = bs->bl.discardalignment; } num -= sectornum % bs->bl.discardalignment; } /* limit request size */ if (num > maxdiscard) { num = maxdiscard; } if (bs->drv->bdrvcodiscard) { ret = bs->drv->bdrvcodiscard(bs, sectornum, num); } else { BlockDriverAIOCB *acb; CoroutineIOCompletion co = { .coroutine = qemucoroutineself(), }; acb = bs->drv->bdrvaiodiscard(bs, sectornum, nbsectors, bdrvcoioemcomplete, &co); if (acb == NULL) { return -EIO; } else { qemucoroutineyield(); ret = co.ret; } } if (ret) { return ret; } sectornum += num; nbsectors -= num; } return 0; } ", "target": 0}
{"func": "static void xlnxep108machineinit(MachineClass *mc) { mc->desc = \"Xilinx ZynqMP EP108 board\"; mc->init = xlnxep108init; mc->blockdefaulttype = IFIDE; mc->unitsperdefaultbus = 1; mc->ignorememorytransactionfailures = true; } ", "target": 0}
{"func": "static void tcgoutlogicali(TCGContext *s, AArch64Insn insn, TCGType ext, TCGReg rd, TCGReg rn, uint64t limm) { unsigned h, l, r, c; assert(islimm(limm)); h = clz64(limm); l = ctz64(limm); if (l == 0) { r = 0; /* form 0....01....1 */ c = ctz64(~limm) - 1; if (h == 0) { r = clz64(~limm); /* form 1..10..01..1 */ c += r; } } else { r = 64 - l; /* form 1....10....0 or 0..01..10..0 */ c = r - h - 1; } if (ext == TCGTYPEI32) { r &= 31; c &= 31; } tcgoutinsn3404(s, insn, ext, rd, rn, ext, r, c); } ", "target": 0}
{"func": "void ich9pminit(PCIDevice *lpcpci, ICH9LPCPMRegs *pm, bool smmenabled, qemuirq sciirq) { memoryregioninit(&pm->io, OBJECT(lpcpci), \"ich9-pm\", ICH9PMIOSIZE); memoryregionsetenabled(&pm->io, false); memoryregionaddsubregion(pciaddressspaceio(lpcpci), 0, &pm->io); acpipmtmrinit(&pm->acpiregs, ich9pmupdatescifn, &pm->io); acpipm1evtinit(&pm->acpiregs, ich9pmupdatescifn, &pm->io); acpipm1cntinit(&pm->acpiregs, &pm->io, pm->disables3, pm->disables4, pm->s4val); acpigpeinit(&pm->acpiregs, ICH9PMIOGPE0LEN); memoryregioninitio(&pm->iogpe, OBJECT(lpcpci), &ich9gpeops, pm, \"acpi-gpe0\", ICH9PMIOGPE0LEN); memoryregionaddsubregion(&pm->io, ICH9PMIOGPE0STS, &pm->iogpe); memoryregioninitio(&pm->iosmi, OBJECT(lpcpci), &ich9smiops, pm, \"acpi-smi\", 8); memoryregionaddsubregion(&pm->io, ICH9PMIOSMIEN, &pm->iosmi); pm->smmenabled = smmenabled; pm->enabletco = true; acpipmtcoinit(&pm->tcoregs, &pm->io); pm->irq = sciirq; qemuregisterreset(pmreset, pm); pm->powerdownnotifier.notify = pmpowerdownreq; qemuregisterpowerdownnotifier(&pm->powerdownnotifier); legacyacpicpuhotpluginit(pciaddressspaceio(lpcpci), OBJECT(lpcpci), &pm->gpecpu, ICH9CPUHOTPLUGIOBASE); if (pm->acpimemoryhotplug.isenabled) { acpimemoryhotpluginit(pciaddressspaceio(lpcpci), OBJECT(lpcpci), &pm->acpimemoryhotplug); } } ", "target": 0}
{"func": "static void handlesys(DisasContext *s, uint32t insn, bool isread, unsigned int op0, unsigned int op1, unsigned int op2, unsigned int crn, unsigned int crm, unsigned int rt) { const ARMCPRegInfo *ri; TCGvi64 tcgrt; ri = getarmcpreginfo(s->cpregs, ENCODEAA64CPREG(CPREGARM64SYSREGCP, crn, crm, op0, op1, op2)); if (!ri) { /* Unknown register; this might be a guest error or a QEMU * unimplemented feature. */ qemulogmask(LOGUNIMP, \"%s access to unsupported AArch64 \" \"system register op0:%d op1:%d crn:%d crm:%d op2:%d\\n\", isread ? \"read\" : \"write\", op0, op1, crn, crm, op2); unallocatedencoding(s); return; } /* Check access permissions */ if (!cpaccessok(s->currentel, ri, isread)) { unallocatedencoding(s); return; } if (ri->accessfn) { /* Emit code to perform further access permissions checks at * runtime; this may result in an exception. */ TCGvptr tmpptr; TCGvi32 tcgsyn; uint32t syndrome; gena64setpcim(s->pc - 4); tmpptr = tcgconstptr(ri); syndrome = synaa64sysregtrap(op0, op1, op2, crn, crm, rt, isread); tcgsyn = tcgconsti32(syndrome); genhelperaccesscheckcpreg(cpuenv, tmpptr, tcgsyn); tcgtempfreeptr(tmpptr); tcgtempfreei32(tcgsyn); } /* Handle special cases first */ switch (ri->type & ~(ARMCPFLAGMASK & ~ARMCPSPECIAL)) { case ARMCPNOP: return; case ARMCPNZCV: tcgrt = cpureg(s, rt); if (isread) { gengetnzcv(tcgrt); } else { gensetnzcv(tcgrt); } return; case ARMCPCURRENTEL: /* Reads as current EL value from pstate, which is * guaranteed to be constant by the tb flags. */ tcgrt = cpureg(s, rt); tcggenmovii64(tcgrt, s->currentel << 2); return; case ARMCPDCZVA: /* Writes clear the aligned block of memory which rt points into. */ tcgrt = cpureg(s, rt); genhelperdczva(cpuenv, tcgrt); return; default: break; } if (useicount && (ri->type & ARMCPIO)) { geniostart(); } tcgrt = cpureg(s, rt); if (isread) { if (ri->type & ARMCPCONST) { tcggenmovii64(tcgrt, ri->resetvalue); } else if (ri->readfn) { TCGvptr tmpptr; tmpptr = tcgconstptr(ri); genhelpergetcpreg64(tcgrt, cpuenv, tmpptr); tcgtempfreeptr(tmpptr); } else { tcggenldi64(tcgrt, cpuenv, ri->fieldoffset); } } else { if (ri->type & ARMCPCONST) { /* If not forbidden by access permissions, treat as WI */ return; } else if (ri->writefn) { TCGvptr tmpptr; tmpptr = tcgconstptr(ri); genhelpersetcpreg64(cpuenv, tmpptr, tcgrt); tcgtempfreeptr(tmpptr); } else { tcggensti64(tcgrt, cpuenv, ri->fieldoffset); } } if (useicount && (ri->type & ARMCPIO)) { /* I/O operations must end the TB here (whether read or write) */ genioend(); s->isjmp = DISASUPDATE; } else if (!isread && !(ri->type & ARMCPSUPPRESSTBEND)) { /* We default to ending the TB on a coprocessor register write, * but allow this to be suppressed by the register definition * (usually only necessary to work around guest bugs). */ s->isjmp = DISASUPDATE; } } ", "target": 0}
{"func": "static Visitor *visitorinputtestinitraw(TestInputVisitorData *data, const char *jsonstring) { return visitorinputtestinitinternal(data, jsonstring, NULL); } ", "target": 0}
{"func": "static void doinfoversion(Monitor *mon) { monitorprintf(mon, \"%s\\n\", QEMUVERSION); } ", "target": 0}
{"func": "static int qcryptoivgenessivinit(QCryptoIVGen *ivgen, const uint8t *key, sizet nkey, Error **errp) { uint8t *salt; sizet nhash; sizet nsalt; QCryptoIVGenESSIV *essiv = gnew0(QCryptoIVGenESSIV, 1); /* Not necessarily the same as nkey */ nsalt = qcryptociphergetkeylen(ivgen->cipher); nhash = qcryptohashdigestlen(ivgen->hash); /* Salt must be larger of hash size or key size */ salt = gnew0(uint8t, MAX(nhash, nsalt)); if (qcryptohashbytes(ivgen->hash, (const gchar *)key, nkey, &salt, &nhash, errp) < 0) { gfree(essiv); return -1; } /* Now potentially truncate salt to match cipher key len */ essiv->cipher = qcryptociphernew(ivgen->cipher, QCRYPTOCIPHERMODEECB, salt, MIN(nhash, nsalt), errp); if (!essiv->cipher) { gfree(essiv); return -1; } ivgen->private = essiv; return 0; }", "target": 1}
{"func": "static void mpeg1encodesequenceheader(MpegEncContext *s) { unsigned int vbvbuffersize; unsigned int fps, v; int n; UINT64 timecode; if ((s->picturenumber % s->gopsize) == 0) { /* mpeg1 header repeated every gop */ putheader(s, SEQSTARTCODE); /* search closest frame rate */ { int i, dmin, d; s->framerateindex = 0; dmin = 0x7fffffff; for(i=1;i<9;i++) { d = abs(s->framerate - frameratetab[i]); if (d < dmin) { dmin = d; s->framerateindex = i; } } } putbits(&s->pb, 12, s->width); putbits(&s->pb, 12, s->height); putbits(&s->pb, 4, 1); /* 1/1 aspect ratio */ putbits(&s->pb, 4, s->framerateindex); v = s->bitrate / 400; if (v > 0x3ffff) v = 0x3ffff; putbits(&s->pb, 18, v); putbits(&s->pb, 1, 1); /* marker */ /* vbv buffer size: slightly greater than an I frame. We add some margin just in case */ vbvbuffersize = (3 * s->Iframebits) / (2 * 8); putbits(&s->pb, 10, (vbvbuffersize + 16383) / 16384); putbits(&s->pb, 1, 1); /* constrained parameter flag */ putbits(&s->pb, 1, 0); /* no custom intra matrix */ putbits(&s->pb, 1, 0); /* no custom non intra matrix */ putheader(s, GOPSTARTCODE); putbits(&s->pb, 1, 0); /* do drop frame */ /* time code : we must convert from the real frame rate to a fake mpeg frame rate in case of low frame rate */ fps = frameratetab[s->framerateindex]; timecode = s->fakepicturenumber * FRAMERATEBASE; s->goppicturenumber = s->fakepicturenumber; putbits(&s->pb, 5, (UINT32)((timecode / (fps * 3600)) % 24)); putbits(&s->pb, 6, (UINT32)((timecode / (fps * 60)) % 60)); putbits(&s->pb, 1, 1); putbits(&s->pb, 6, (UINT32)((timecode / fps) % 60)); putbits(&s->pb, 6, (UINT32)((timecode % fps) / FRAMERATEBASE)); putbits(&s->pb, 1, 1); /* closed gop */ putbits(&s->pb, 1, 0); /* broken link */ } if (s->framerate < (24 * FRAMERATEBASE) && s->picturenumber > 0) { /* insert empty P pictures to slow down to the desired frame rate. Each fake pictures takes about 20 bytes */ fps = frameratetab[s->framerateindex]; n = ((s->picturenumber * fps) / s->framerate) - 1; while (s->fakepicturenumber < n) { mpeg1skippicture(s, s->fakepicturenumber - s->goppicturenumber); s->fakepicturenumber++; } } s->fakepicturenumber++; } ", "target": 1}
{"func": "void ffputh264qpel4mc33msa(uint8t *dst, const uint8t *src, ptrdifft stride) { avclumahvqrt4wmsa(src + stride - 2, src - (stride * 2) + sizeof(uint8t), stride, dst, stride, 4); } ", "target": 0}
{"func": "static avcold int mpegmuxinit(AVFormatContext *ctx) { MpegMuxContext *s = ctx->privdata; int bitrate, i, mpaid, mpvid, h264id, mpsid, ac3id, dtsid, lpcmid, j; AVStream *st; StreamInfo *stream; int audiobitrate; int videobitrate; s->packetnumber = 0; s->isvcd = (CONFIGMPEG1VCDMUXER && ctx->oformat == &ffmpeg1vcdmuxer); s->issvcd = (CONFIGMPEG2SVCDMUXER && ctx->oformat == &ffmpeg2svcdmuxer); s->ismpeg2 = ((CONFIGMPEG2VOBMUXER && ctx->oformat == &ffmpeg2vobmuxer) || (CONFIGMPEG2DVDMUXER && ctx->oformat == &ffmpeg2dvdmuxer) || (CONFIGMPEG2SVCDMUXER && ctx->oformat == &ffmpeg2svcdmuxer)); s->isdvd = (CONFIGMPEG2DVDMUXER && ctx->oformat == &ffmpeg2dvdmuxer); if (ctx->packetsize) { if (ctx->packetsize < 20 || ctx->packetsize > (1 << 23) + 10) { avlog(ctx, AVLOGERROR, \"Invalid packet size %d\\n\", ctx->packetsize); goto fail; } s->packetsize = ctx->packetsize; } else s->packetsize = 2048; if (ctx->maxdelay < 0) /* Not set by the caller */ ctx->maxdelay = AVTIMEBASE*7/10; s->vcdpaddingbyteswritten = 0; s->vcdpaddingbitratenum = 0; s->audiobound = 0; s->videobound = 0; mpaid = AUDIOID; ac3id = AC3ID; dtsid = DTSID; mpvid = VIDEOID; h264id = H264ID; mpsid = SUBID; lpcmid = LPCMID; for (i = 0; i < ctx->nbstreams; i++) { st = ctx->streams[i]; stream = avmallocz(sizeof(StreamInfo)); if (!stream) goto fail; st->privdata = stream; avprivsetptsinfo(st, 64, 1, 90000); switch (st->codec->codectype) { case AVMEDIATYPEAUDIO: if (!s->ismpeg2 && (st->codec->codecid == AVCODECIDAC3 || st->codec->codecid == AVCODECIDDTS || st->codec->codecid == AVCODECIDPCMS16BE)) avlog(ctx, AVLOGWARNING, \"%s in MPEG-1 system streams is not widely supported, \" \"consider using the vob or the dvd muxer \" \"to force a MPEG-2 program stream.\\n\", avcodecgetname(st->codec->codecid)); if (st->codec->codecid == AVCODECIDAC3) { stream->id = ac3id++; } else if (st->codec->codecid == AVCODECIDDTS) { stream->id = dtsid++; } else if (st->codec->codecid == AVCODECIDPCMS16BE) { stream->id = lpcmid++; for (j = 0; j < 4; j++) { if (lpcmfreqtab[j] == st->codec->samplerate) break; } if (j == 4) goto fail; if (st->codec->channels > 8) return -1; stream->lpcmheader[0] = 0x0c; stream->lpcmheader[1] = (st->codec->channels - 1) | (j << 4); stream->lpcmheader[2] = 0x80; stream->lpcmalign = st->codec->channels * 2; } else { stream->id = mpaid++; } /* This value HAS to be used for VCD (see VCD standard, p. IV-7). * Right now it is also used for everything else. */ stream->maxbuffersize = 4 * 1024; s->audiobound++; break; case AVMEDIATYPEVIDEO: if (st->codec->codecid == AVCODECIDH264) stream->id = h264id++; else stream->id = mpvid++; if (st->codec->rcbuffersize) stream->maxbuffersize = 6 * 1024 + st->codec->rcbuffersize / 8; else { avlog(ctx, AVLOGWARNING, \"VBV buffer size not set, using default size of 130KB\\n\" \"If you want the mpeg file to be compliant to some specification\\n\" \"Like DVD, VCD or others, make sure you set the correct buffer size\\n\"); // FIXME: this is probably too small as default stream->maxbuffersize = 230 * 1024; } if (stream->maxbuffersize > 1024 * 8191) { avlog(ctx, AVLOGWARNING, \"buffer size %d, too large\\n\", stream->maxbuffersize); stream->maxbuffersize = 1024 * 8191; } s->videobound++; break; case AVMEDIATYPESUBTITLE: stream->id = mpsid++; stream->maxbuffersize = 16 * 1024; break; default: return -1; } stream->fifo = avfifoalloc(16); if (!stream->fifo) goto fail; } bitrate = 0; audiobitrate = 0; videobitrate = 0; for (i = 0; i < ctx->nbstreams; i++) { int codecrate; st = ctx->streams[i]; stream = (StreamInfo *)st->privdata; if (st->codec->rcmaxrate || st->codec->codectype == AVMEDIATYPEVIDEO) codecrate = st->codec->rcmaxrate; else codecrate = st->codec->bitrate; if (!codecrate) codecrate = (1 << 21) * 8 * 50 / ctx->nbstreams; bitrate += codecrate; if ((stream->id & 0xe0) == AUDIOID) audiobitrate += codecrate; else if (st->codec->codectype == AVMEDIATYPEVIDEO) videobitrate += codecrate; } if (s->usermuxrate) { s->muxrate = (s->usermuxrate + (8 * 50) - 1) / (8 * 50); } else { /* we increase slightly the bitrate to take into account the * headers. XXX: compute it exactly */ bitrate += bitrate / 20; bitrate += 10000; s->muxrate = (bitrate + (8 * 50) - 1) / (8 * 50); if (s->muxrate >= (1<<22)) { avlog(ctx, AVLOGWARNING, \"mux rate %d is too large\\n\", s->muxrate); s->muxrate = (1<<22) - 1; } } if (s->isvcd) { int64t overheadrate; /* The VCD standard mandates that the muxrate field is 3528 * (see standard p. IV-6). * The value is actually \"wrong\", i.e. if you calculate * it using the normal formula and the 75 sectors per second transfer * rate you get a different value because the real pack size is 2324, * not 2352. But the standard explicitly specifies that the muxrate * field in the header must have this value. */ // s->muxrate = 2352 * 75 / 50; /* = 3528 */ /* The VCD standard states that the muxed stream must be * exactly 75 packs / second (the data rate of a single speed cdrom). * Since the video bitrate (probably 1150000 bits/sec) will be below * the theoretical maximum we have to add some padding packets * to make up for the lower data rate. * (cf. VCD standard p. IV-6 ) */ /* Add the header overhead to the data rate. * 2279 data bytes per audio pack, 2294 data bytes per video pack */ overheadrate = audiobitrate * 2294LL * (2324 - 2279); overheadrate += videobitrate * 2279LL * (2324 - 2294); /* Add padding so that the full bitrate is 2324*75 bytes/sec */ s->vcdpaddingbitratenum = (2324LL * 75 * 8 - bitrate) * 2279 * 2294 - overheadrate; #define VCDPADDINGBITRATEDEN (2279 * 2294) } if (s->isvcd || s->ismpeg2) /* every packet */ s->packheaderfreq = 1; else /* every 2 seconds */ s->packheaderfreq = 2 * bitrate / s->packetsize / 8; /* the above seems to make packheaderfreq zero sometimes */ if (s->packheaderfreq == 0) s->packheaderfreq = 1; if (s->ismpeg2) /* every 200 packets. Need to look at the spec. */ s->systemheaderfreq = s->packheaderfreq * 40; else if (s->isvcd) /* the standard mandates that there are only two system headers * in the whole file: one in the first packet of each stream. * (see standard p. IV-7 and IV-8) */ s->systemheaderfreq = 0x7fffffff; else s->systemheaderfreq = s->packheaderfreq * 5; for (i = 0; i < ctx->nbstreams; i++) { stream = ctx->streams[i]->privdata; stream->packetnumber = 0; } s->systemheadersize = getsystemheadersize(ctx); s->lastscr = AVNOPTSVALUE; return 0; fail: for (i = 0; i < ctx->nbstreams; i++) avfreep(&ctx->streams[i]->privdata); return AVERROR(ENOMEM); } ", "target": 0}
{"func": "static void dsputilinitmmx2(DSPContext *c, AVCodecContext *avctx, int mmflags) { const int bitdepth = avctx->bitsperrawsample; const int highbitdepth = bitdepth > 8; c->prefetch = prefetchmmx2; if (!highbitdepth) { c->putpixelstab[0][1] = putpixels16x2mmx2; c->putpixelstab[0][2] = putpixels16y2mmx2; c->avgpixelstab[0][0] = avgpixels16mmx2; c->avgpixelstab[0][1] = avgpixels16x2mmx2; c->avgpixelstab[0][2] = avgpixels16y2mmx2; c->putpixelstab[1][1] = putpixels8x2mmx2; c->putpixelstab[1][2] = putpixels8y2mmx2; c->avgpixelstab[1][0] = avgpixels8mmx2; c->avgpixelstab[1][1] = avgpixels8x2mmx2; c->avgpixelstab[1][2] = avgpixels8y2mmx2; } if (!(avctx->flags & CODECFLAGBITEXACT)) { if (!highbitdepth) { c->putnorndpixelstab[0][1] = putnorndpixels16x2mmx2; c->putnorndpixelstab[0][2] = putnorndpixels16y2mmx2; c->putnorndpixelstab[1][1] = putnorndpixels8x2mmx2; c->putnorndpixelstab[1][2] = putnorndpixels8y2mmx2; c->avgpixelstab[0][3] = avgpixels16xy2mmx2; c->avgpixelstab[1][3] = avgpixels8xy2mmx2; } if (CONFIGVP3DECODER && HAVEYASM) { c->vp3vloopfilter = ffvp3vloopfiltermmx2; c->vp3hloopfilter = ffvp3hloopfiltermmx2; } } if (CONFIGVP3DECODER && HAVEYASM) c->vp3idctdcadd = ffvp3idctdcaddmmx2; if (CONFIGVP3DECODER && (avctx->codecid == CODECIDVP3 || avctx->codecid == CODECIDTHEORA)) { c->putnorndpixelstab[1][1] = putnorndpixels8x2exactmmx2; c->putnorndpixelstab[1][2] = putnorndpixels8y2exactmmx2; } if (CONFIGH264QPEL) { SETQPELFUNCS(putqpel, 0, 16, mmx2, ); SETQPELFUNCS(putqpel, 1, 8, mmx2, ); SETQPELFUNCS(putnorndqpel, 0, 16, mmx2, ); SETQPELFUNCS(putnorndqpel, 1, 8, mmx2, ); SETQPELFUNCS(avgqpel, 0, 16, mmx2, ); SETQPELFUNCS(avgqpel, 1, 8, mmx2, ); if (!highbitdepth) { SETQPELFUNCS(puth264qpel, 0, 16, mmx2, ); SETQPELFUNCS(puth264qpel, 1, 8, mmx2, ); SETQPELFUNCS(puth264qpel, 2, 4, mmx2, ); SETQPELFUNCS(avgh264qpel, 0, 16, mmx2, ); SETQPELFUNCS(avgh264qpel, 1, 8, mmx2, ); SETQPELFUNCS(avgh264qpel, 2, 4, mmx2, ); } else if (bitdepth == 10) { #if HAVEYASM #if !ARCHX8664 SETQPELFUNCS(avgh264qpel, 0, 16, 10mmxext, ff); SETQPELFUNCS(puth264qpel, 0, 16, 10mmxext, ff); SETQPELFUNCS(puth264qpel, 1, 8, 10mmxext, ff); SETQPELFUNCS(avgh264qpel, 1, 8, 10mmxext, ff); #endif SETQPELFUNCS(puth264qpel, 2, 4, 10mmxext, ff); SETQPELFUNCS(avgh264qpel, 2, 4, 10mmxext, ff); #endif } SETQPELFUNCS(put2tapqpel, 0, 16, mmx2, ); SETQPELFUNCS(put2tapqpel, 1, 8, mmx2, ); SETQPELFUNCS(avg2tapqpel, 0, 16, mmx2, ); SETQPELFUNCS(avg2tapqpel, 1, 8, mmx2, ); } #if HAVEYASM if (!highbitdepth && CONFIGH264CHROMA) { c->avgh264chromapixelstab[0] = ffavgh264chromamc8mmx2rnd; c->avgh264chromapixelstab[1] = ffavgh264chromamc4mmx2; c->avgh264chromapixelstab[2] = ffavgh264chromamc2mmx2; c->puth264chromapixelstab[2] = ffputh264chromamc2mmx2; } if (bitdepth == 10 && CONFIGH264CHROMA) { c->puth264chromapixelstab[2] = ffputh264chromamc210mmxext; c->avgh264chromapixelstab[2] = ffavgh264chromamc210mmxext; c->puth264chromapixelstab[1] = ffputh264chromamc410mmxext; c->avgh264chromapixelstab[1] = ffavgh264chromamc410mmxext; } c->addhfyumedianprediction = ffaddhfyumedianpredictionmmx2; c->scalarproductint16 = ffscalarproductint16mmx2; c->scalarproductandmaddint16 = ffscalarproductandmaddint16mmx2; if (avctx->flags & CODECFLAGBITEXACT) { c->applywindowint16 = ffapplywindowint16mmxextba; } else { c->applywindowint16 = ffapplywindowint16mmxext; } #endif } ", "target": 0}
{"func": "static int vaapiencodeh264initsequenceparams(AVCodecContext *avctx) { VAAPIEncodeContext *ctx = avctx->privdata; VAEncSequenceParameterBufferH264 *vseq = ctx->codecsequenceparams; VAEncPictureParameterBufferH264 *vpic = ctx->codecpictureparams; VAAPIEncodeH264Context *priv = ctx->privdata; VAAPIEncodeH264MiscSequenceParams *mseq = &priv->miscsequenceparams; int i; { vseq->seqparametersetid = 0; vseq->levelidc = avctx->level; vseq->maxnumrefframes = 2; vseq->picturewidthinmbs = priv->mbwidth; vseq->pictureheightinmbs = priv->mbheight; vseq->seqfields.bits.chromaformatidc = 1; vseq->seqfields.bits.framembsonlyflag = 1; vseq->seqfields.bits.direct8x8inferenceflag = 1; vseq->seqfields.bits.log2maxframenumminus4 = 4; vseq->seqfields.bits.picordercnttype = 0; if (ctx->inputwidth != ctx->alignedwidth || ctx->inputheight != ctx->alignedheight) { vseq->framecroppingflag = 1; vseq->framecropleftoffset = 0; vseq->framecroprightoffset = (ctx->alignedwidth - ctx->inputwidth) / 2; vseq->framecroptopoffset = 0; vseq->framecropbottomoffset = (ctx->alignedheight - ctx->inputheight) / 2; } else { vseq->framecroppingflag = 0; } vseq->vuiparameterspresentflag = 1; if (avctx->sampleaspectratio.num != 0) { vseq->vuifields.bits.aspectratioinfopresentflag = 1; // There is a large enum of these which we could support // individually rather than using the generic X/Y form? if (avctx->sampleaspectratio.num == avctx->sampleaspectratio.den) { vseq->aspectratioidc = 1; } else { vseq->aspectratioidc = 255; // Extended SAR. vseq->sarwidth = avctx->sampleaspectratio.num; vseq->sarheight = avctx->sampleaspectratio.den; } } if (avctx->colorprimaries != AVCOLPRIUNSPECIFIED || avctx->colortrc != AVCOLTRCUNSPECIFIED || avctx->colorspace != AVCOLSPCUNSPECIFIED) { mseq->videosignaltypepresentflag = 1; mseq->videoformat = 5; // Unspecified. mseq->videofullrangeflag = 0; mseq->colourdescriptionpresentflag = 1; // These enums are derived from the standard and hence // we can just use the values directly. mseq->colourprimaries = avctx->colorprimaries; mseq->transfercharacteristics = avctx->colortrc; mseq->matrixcoefficients = avctx->colorspace; } vseq->bitspersecond = avctx->bitrate; vseq->vuifields.bits.timinginfopresentflag = 1; if (avctx->framerate.num > 0 && avctx->framerate.den > 0) { vseq->numunitsintick = avctx->framerate.num; vseq->timescale = 2 * avctx->framerate.den; mseq->fixedframerateflag = 1; } else { vseq->numunitsintick = avctx->timebase.num; vseq->timescale = 2 * avctx->timebase.den; mseq->fixedframerateflag = 0; } if (ctx->varcmode == VARCCBR) { priv->sendtimingsei = 1; mseq->nalhrdparameterspresentflag = 1; mseq->cpbcntminus1 = 0; // Try to scale these to a sensible range so that the // golomb encode of the value is not overlong. mseq->bitratescale = avclipuintp2(avlog2(avctx->bitrate) - 15 - 6, 4); mseq->bitratevalueminus1[0] = (avctx->bitrate >> mseq->bitratescale + 6) - 1; mseq->cpbsizescale = avclipuintp2(avlog2(priv->hrdparams.hrd.buffersize) - 15 - 4, 4); mseq->cpbsizevalueminus1[0] = (priv->hrdparams.hrd.buffersize >> mseq->cpbsizescale + 4) - 1; // CBR mode isn't actually available here, despite naming. mseq->cbrflag[0] = 0; mseq->initialcpbremovaldelaylengthminus1 = 23; mseq->cpbremovaldelaylengthminus1 = 23; mseq->dpboutputdelaylengthminus1 = 7; mseq->timeoffsetlength = 0; // This calculation can easily overflow 32 bits. mseq->initialcpbremovaldelay = 90000 * (uint64t)priv->hrdparams.hrd.initialbufferfullness / priv->hrdparams.hrd.buffersize; mseq->initialcpbremovaldelayoffset = 0; } else { priv->sendtimingsei = 0; mseq->nalhrdparameterspresentflag = 0; } vseq->intraperiod = ctx->pperi * (ctx->bperp + 1); vseq->intraidrperiod = vseq->intraperiod; vseq->ipperiod = ctx->bperp + 1; } { vpic->CurrPic.pictureid = VAINVALIDID; vpic->CurrPic.flags = VAPICTUREH264INVALID; for (i = 0; i < FFARRAYELEMS(vpic->ReferenceFrames); i++) { vpic->ReferenceFrames[i].pictureid = VAINVALIDID; vpic->ReferenceFrames[i].flags = VAPICTUREH264INVALID; } vpic->codedbuf = VAINVALIDID; vpic->picparametersetid = 0; vpic->seqparametersetid = 0; vpic->numrefidxl0activeminus1 = 0; vpic->numrefidxl1activeminus1 = 0; vpic->picfields.bits.entropycodingmodeflag = ((avctx->profile & 0xff) != 66); vpic->picfields.bits.weightedpredflag = 0; vpic->picfields.bits.weightedbipredidc = 0; vpic->picfields.bits.transform8x8modeflag = ((avctx->profile & 0xff) >= 100); vpic->picinitqp = priv->fixedqpidr; } { mseq->profileidc = avctx->profile & 0xff; if (avctx->profile & FFPROFILEH264CONSTRAINED) mseq->constraintset1flag = 1; if (avctx->profile & FFPROFILEH264INTRA) mseq->constraintset3flag = 1; } return 0; } ", "target": 0}
{"func": "void ifstart(Slirp *slirp) { uint64t now = qemuclockgetns(QEMUCLOCKREALTIME); bool frombatchq, nextfrombatchq; struct mbuf *ifm, *ifmnext, *ifqt; DEBUGCALL(\"ifstart\"); if (slirp->ifstartbusy) { return; } slirp->ifstartbusy = true; if (slirp->iffastq.ifqnext != &slirp->iffastq) { ifmnext = slirp->iffastq.ifqnext; nextfrombatchq = false; } else if (slirp->nextm != &slirp->ifbatchq) { /* Nothing on fastq, pick up from batchq via nextm */ ifmnext = slirp->nextm; nextfrombatchq = true; } else { ifmnext = NULL; } while (ifmnext) { ifm = ifmnext; frombatchq = nextfrombatchq; ifmnext = ifm->ifqnext; if (ifmnext == &slirp->iffastq) { /* No more packets in fastq, switch to batchq */ ifmnext = slirp->nextm; nextfrombatchq = true; } if (ifmnext == &slirp->ifbatchq) { /* end of batchq */ ifmnext = NULL; } /* Try to send packet unless it already expired */ if (ifm->expirationdate >= now && !ifencap(slirp, ifm)) { /* Packet is delayed due to pending ARP resolution */ continue; } if (ifm == slirp->nextm) { /* Set which packet to send on next iteration */ slirp->nextm = ifm->ifqnext; } /* Remove it from the queue */ ifqt = ifm->ifqprev; remque(ifm); /* If there are more packets for this session, re-queue them */ if (ifm->ifsnext != ifm) { struct mbuf *next = ifm->ifsnext; insque(next, ifqt); ifsremque(ifm); if (!frombatchq) { /* Next packet in fastq is from the same session */ ifmnext = next; nextfrombatchq = false; } else if (slirp->nextm == &slirp->ifbatchq) { /* Set nextm and ifmnext if the session packet is now the * only one on batchq */ slirp->nextm = ifmnext = next; } } /* Update soqueued */ if (ifm->ifqso && --ifm->ifqso->soqueued == 0) { /* If there's no more queued, reset nqueued */ ifm->ifqso->sonqueued = 0; } mfree(ifm); } slirp->ifstartbusy = false; } ", "target": 0}
{"func": "static void handleti(ESPState *s) { uint32t dmalen, minlen; if (s->dma && !s->dmaenabled) { s->dmacb = handleti; return; } dmalen = s->rregs[ESPTCLO]; dmalen |= s->rregs[ESPTCMID] << 8; dmalen |= s->rregs[ESPTCHI] << 16; if (dmalen==0) { dmalen=0x10000; } s->dmacounter = dmalen; if (s->docmd) minlen = (dmalen < 32) ? dmalen : 32; else if (s->tisize < 0) minlen = (dmalen < -s->tisize) ? dmalen : -s->tisize; else minlen = (dmalen < s->tisize) ? dmalen : s->tisize; traceesphandleti(minlen); if (s->dma) { s->dmaleft = minlen; s->rregs[ESPRSTAT] &= ~STATTC; espdodma(s); } if (s->docmd) { traceesphandleticmd(s->cmdlen); s->tisize = 0; s->cmdlen = 0; s->docmd = 0; docmd(s, s->cmdbuf); } } ", "target": 0}
{"func": "static void lsi53c895aregisterdevices(void) { typeregisterstatic(&lsiinfo); typeregisterstaticalias(&lsiinfo, \"lsi\"); } ", "target": 0}
{"func": "static void receivefromchrlayer(SCLPConsole *scon, const uint8t *buf, int size) { /* read data must fit into current buffer */ assert(size <= SIZEBUFFERVT220 - scon->iovdatalen); /* put byte-stream from character layer into buffer */ memcpy(&scon->iov[scon->iovbs], buf, size); scon->iovdatalen += size; scon->iovsclprest += size; scon->iovbs += size; scon->event.eventpending = true; } ", "target": 1}
{"func": "static void usbredirdoattach(void *opaque) { USBRedirDevice *dev = opaque; /* In order to work properly with XHCI controllers we need these caps */ if ((dev->dev.port->speedmask & USBSPEEDMASKSUPER) && !( usbredircapepinfomaxpacketsize) && usbredircap64bitsids))) { ERROR(\"usb-redir-host lacks capabilities needed for use with XHCI\\n\"); usbredirrejectdevice(dev); return; } if (usbdeviceattach(&dev->dev) != 0) { WARNING(\"rejecting device due to speed mismatch\\n\"); usbredirrejectdevice(dev); } }", "target": 1}
{"func": "static avcold void setbandwidth(AC3EncodeContext *s, int cutoff) { int ch, bwcode; if (cutoff) { /* calculate bandwidth based on user-specified cutoff frequency */ int fbwcoeffs; cutoff = avclip(cutoff, 1, s->samplerate >> 1); fbwcoeffs = cutoff * 2 * AC3MAXCOEFS / s->samplerate; bwcode = avclip((fbwcoeffs - 73) / 3, 0, 60); } else { /* use default bandwidth setting */ /* XXX: should compute the bandwidth according to the frame size, so that we avoid annoying high frequency artifacts */ bwcode = 50; } /* set number of coefficients for each channel */ for (ch = 0; ch < s->fbwchannels; ch++) { s->bandwidthcode[ch] = bwcode; s->nbcoefs[ch] = bwcode * 3 + 73; } if (s->lfeon) s->nbcoefs[s->lfechannel] = 7; /* LFE channel always has 7 coefs */ } ", "target": 0}
{"func": "static inline void RENAME(yuy2ToUV)(uint8t *dstU, uint8t *dstV, const uint8t *src1, const uint8t *src2, long width, uint32t *unused) { #if COMPILETEMPLATEMMX asm volatile( \"movq \"MANGLE(bm01010101)\", %%mm4 \\n\\t\" \"mov %0, %%\"REGa\" \\n\\t\" \"1: \\n\\t\" \"movq (%1, %%\"REGa\",4), %%mm0 \\n\\t\" \"movq 8(%1, %%\"REGa\",4), %%mm1 \\n\\t\" \"psrlw $8, %%mm0 \\n\\t\" \"psrlw $8, %%mm1 \\n\\t\" \"packuswb %%mm1, %%mm0 \\n\\t\" \"movq %%mm0, %%mm1 \\n\\t\" \"psrlw $8, %%mm0 \\n\\t\" \"pand %%mm4, %%mm1 \\n\\t\" \"packuswb %%mm0, %%mm0 \\n\\t\" \"packuswb %%mm1, %%mm1 \\n\\t\" \"movd %%mm0, (%3, %%\"REGa\") \\n\\t\" \"movd %%mm1, (%2, %%\"REGa\") \\n\\t\" \"add $4, %%\"REGa\" \\n\\t\" \" js 1b \\n\\t\" : : \"g\" ((x86reg)-width), \"r\" (src1+width*4), \"r\" (dstU+width), \"r\" (dstV+width) : \"%\"REGa ); #else int i; for (i=0; i<width; i++) { dstU[i]= src1[4*i + 1]; dstV[i]= src1[4*i + 3]; } #endif assert(src1 == src2); } ", "target": 0}
{"func": "static void xtensakc705init(MachineState *machine) { static const LxBoardDesc kc705board = { .flashbase = 0xf0000000, .flashsize = 0x08000000, .flashbootbase = 0x06000000, .flashsectorsize = 0x20000, .sramsize = 0x2000000, }; lxinit(&kc705board, machine); } ", "target": 0}
{"func": "static void virtqueueunmapsg(VirtQueue *vq, const VirtQueueElement *elem, unsigned int len) { unsigned int offset; int i; offset = 0; for (i = 0; i < elem->innum; i++) { sizet size = MIN(len - offset, elem->insg[i].iovlen); cpuphysicalmemoryunmap(elem->insg[i].iovbase, elem->insg[i].iovlen, 1, size); offset += size; } for (i = 0; i < elem->outnum; i++) cpuphysicalmemoryunmap(elem->outsg[i].iovbase, elem->outsg[i].iovlen, 0, elem->outsg[i].iovlen); } ", "target": 0}
{"func": "static int vmdkreopenprepare(BDRVReopenState *state, BlockReopenQueue *queue, Error **errp) { BDRVVmdkState *s; int ret = -1; int i; VmdkExtent *e; assert(state != NULL); assert(state->bs != NULL); if (queue == NULL) { errorsetg(errp, \"No reopen queue for VMDK extents\"); goto exit; } s = state->bs->opaque; assert(s != NULL); for (i = 0; i < s->numextents; i++) { e = &s->extents[i]; if (e->file != state->bs->file) { bdrvreopenqueue(queue, e->file, state->flags); } } ret = 0; exit: return ret; } ", "target": 0}
{"func": "static inline void tcgoutgotolabel(TCGContext *s, int labelindex) { TCGLabel *l = &s->labels[labelindex]; if (!l->hasvalue) { tcgoutreloc(s, s->codeptr, RAARCH64JUMP26, labelindex, 0); tcgoutgotonoaddr(s); } else { tcgoutgoto(s, l->u.valueptr); } } ", "target": 0}
{"func": "static void ac97map (PCIDevice *pcidev, int regionnum, uint32t addr, uint32t size, int type) { PCIAC97LinkState *d = (PCIAC97LinkState *) pcidev; AC97LinkState *s = &d->ac97; if (!regionnum) { s->base[0] = addr; registerioportread (addr, 256 * 1, 1, namreadb, d); registerioportread (addr, 256 * 2, 2, namreadw, d); registerioportread (addr, 256 * 4, 4, namreadl, d); registerioportwrite (addr, 256 * 1, 1, namwriteb, d); registerioportwrite (addr, 256 * 2, 2, namwritew, d); registerioportwrite (addr, 256 * 4, 4, namwritel, d); } else { s->base[1] = addr; registerioportread (addr, 64 * 1, 1, nabmreadb, d); registerioportread (addr, 64 * 2, 2, nabmreadw, d); registerioportread (addr, 64 * 4, 4, nabmreadl, d); registerioportwrite (addr, 64 * 1, 1, nabmwriteb, d); registerioportwrite (addr, 64 * 2, 2, nabmwritew, d); registerioportwrite (addr, 64 * 4, 4, nabmwritel, d); } } ", "target": 0}
{"func": "void vmstateunregister(DeviceState *dev, const VMStateDescription *vmsd, void *opaque) { SaveStateEntry *se, *newse; QTAILQFOREACHSAFE(se, &savevmstate.handlers, entry, newse) { if (se->vmsd == vmsd && se->opaque == opaque) { QTAILQREMOVE(&savevmstate.handlers, se, entry); if (se->compat) { gfree(se->compat); } gfree(se); } } } ", "target": 0}
{"func": "static int xenfbsendmotion(struct XenInput *xenfb, \t\t\t int relx, int rely, int relz) { union xenkbdinevent event; memset(&event, 0, XENKBDINEVENTSIZE); event.type = XENKBDTYPEMOTION; event.motion.relx = relx; event.motion.rely = rely; #if XENLATESTINTERFACEVERSION >= 0x00030207 event.motion.relz = relz; #endif return xenfbkbdevent(xenfb, &event); } ", "target": 0}
{"func": "static int readheader(AVFormatContext *s, AVFormatParameters *ap) { JVDemuxContext *jv = s->privdata; AVIOContext *pb = s->pb; AVStream *vst, *ast; int64t audiopts = 0; int64t offset; int i; avioskip(pb, 80); ast = avnewstream(s, 0); vst = avnewstream(s, 1); if (!ast || !vst) return AVERROR(ENOMEM); vst->codec->codectype = CODECTYPEVIDEO; vst->codec->codecid = CODECIDJV; vst->codec->codectag = 0; /* no fourcc */ vst->codec->width = aviorl16(pb); vst->codec->height = aviorl16(pb); vst->nbframes = ast->nbindexentries = aviorl16(pb); avsetptsinfo(vst, 64, aviorl16(pb), 1000); avioskip(pb, 4); ast->codec->codectype = CODECTYPEAUDIO; ast->codec->codecid = CODECIDPCMU8; ast->codec->codectag = 0; /* no fourcc */ ast->codec->samplerate = aviorl16(pb); ast->codec->channels = 1; avsetptsinfo(ast, 64, 1, ast->codec->samplerate); avioskip(pb, 10); ast->indexentries = avmalloc(ast->nbindexentries * sizeof(*ast->indexentries)); if (!ast->indexentries) return AVERROR(ENOMEM); jv->frames = avmalloc(ast->nbindexentries * sizeof(JVFrame)); if (!jv->frames) return AVERROR(ENOMEM); offset = 0x68 + ast->nbindexentries * 16; for(i = 0; i < ast->nbindexentries; i++) { AVIndexEntry *e = ast->indexentries + i; JVFrame *jvf = jv->frames + i; /* total frame size including audio, video, palette data and padding */ e->size = aviorl32(pb); e->timestamp = i; e->pos = offset; offset += e->size; jvf->audiosize = aviorl32(pb); jvf->videosize = aviorl32(pb); jvf->palettesize = avior8(pb) ? 768 : 0; if (avior8(pb)) avlog(s, AVLOGWARNING, \"unsupported audio codec\\n\"); jvf->videotype = avior8(pb); avioskip(pb, 1); e->timestamp = jvf->audiosize ? audiopts : AVNOPTSVALUE; audiopts += jvf->audiosize; e->flags = jvf->videotype != 1 ? AVINDEXKEYFRAME : 0; } jv->state = JVAUDIO; return 0; }", "target": 1}
{"func": "static int movwritecolrtag(AVIOContext *pb, MOVTrack *track) { // Ref (MOV): https://developer.apple.com/library/mac/technotes/tn2162/index.html#//appleref/doc/uid/DTS40013070-CH1-TNTAG9 // Ref (MP4): ISO/IEC 14496-12:2012 if (track->enc->colorprimaries == AVCOLPRIUNSPECIFIED && track->enc->colortrc == AVCOLTRCUNSPECIFIED && track->enc->colorspace == AVCOLSPCUNSPECIFIED) { if ((track->enc->width >= 1920 && track->enc->height >= 1080) || (track->enc->width == 1280 && track->enc->height == 720)) { avlog(NULL, AVLOGWARNING, \"color primaries unspecified, assuming bt709\\n\"); track->enc->colorprimaries = AVCOLPRIBT709; } else if (track->enc->width == 720 && track->height == 576) { avlog(NULL, AVLOGWARNING, \"color primaries unspecified, assuming bt470bg\\n\"); track->enc->colorprimaries = AVCOLPRIBT470BG; } else if (track->enc->width == 720 && (track->height == 486 || track->height == 480)) { avlog(NULL, AVLOGWARNING, \"color primaries unspecified, assuming smpte170\\n\"); track->enc->colorprimaries = AVCOLPRISMPTE170M; } else { avlog(NULL, AVLOGWARNING, \"color primaries unspecified, unable to assume anything\\n\"); } switch (track->enc->colorprimaries) { case AVCOLPRIBT709: track->enc->colortrc = AVCOLTRCBT709; track->enc->colorspace = AVCOLSPCBT709; break; case AVCOLPRISMPTE170M: case AVCOLPRIBT470BG: track->enc->colortrc = AVCOLTRCBT709; track->enc->colorspace = AVCOLSPCSMPTE170M; break; } } /* We should only ever be called by MOV or MP4. */ avassert0(track->mode == MODEMOV || track->mode == MODEMP4); aviowb32(pb, 18 + (track->mode == MODEMP4)); ffiowfourcc(pb, \"colr\"); if (track->mode == MODEMP4) ffiowfourcc(pb, \"nclx\"); else ffiowfourcc(pb, \"nclc\"); switch (track->enc->colorprimaries) { case AVCOLPRIBT709: aviowb16(pb, 1); break; case AVCOLPRISMPTE170M: case AVCOLPRISMPTE240M: aviowb16(pb, 6); break; case AVCOLPRIBT470BG: aviowb16(pb, 5); break; default: aviowb16(pb, 2); } switch (track->enc->colortrc) { case AVCOLTRCBT709: aviowb16(pb, 1); break; case AVCOLTRCSMPTE170M: aviowb16(pb, 1); break; // remapped case AVCOLTRCSMPTE240M: aviowb16(pb, 7); break; default: aviowb16(pb, 2); } switch (track->enc->colorspace) { case AVCOLTRCBT709: aviowb16(pb, 1); break; case AVCOLSPCBT470BG: case AVCOLPRISMPTE170M: aviowb16(pb, 6); break; case AVCOLPRISMPTE240M: aviowb16(pb, 7); break; default: aviowb16(pb, 2); } if (track->mode == MODEMP4) { int fullrange = track->enc->colorrange == AVCOLRANGEJPEG; aviow8(pb, fullrange << 7); return 19; } else { return 18; } } ", "target": 0}
{"func": "static int slirpsocketload(QEMUFile *f, struct socket *so) { if (tcpattach(so) < 0) return -ENOMEM; so->sourgc = qemugetbe32(f); so->soffamily = qemugetbe16(f); switch (so->soffamily) { case AFINET: so->sofaddr.saddr = qemugetbe32(f); so->sofport = qemugetbe16(f); break; default: errorreport( \"soffamily unknown, unable to restore sofaddr and solport\\n\"); } so->solfamily = qemugetbe16(f); switch (so->solfamily) { case AFINET: so->soladdr.saddr = qemugetbe32(f); so->solport = qemugetbe16(f); break; default: errorreport( \"soffamily unknown, unable to restore soladdr and solport\\n\"); } so->soiptos = qemugetbyte(f); so->soemu = qemugetbyte(f); so->sotype = qemugetbyte(f); so->sostate = qemugetbe32(f); if (slirpsbufload(f, &so->sorcv) < 0) return -ENOMEM; if (slirpsbufload(f, &so->sosnd) < 0) return -ENOMEM; slirptcpload(f, so->sotcpcb); return 0; } ", "target": 0}
{"func": "static int qdevprintdevinfo(DeviceInfo *info, char *dest, int len) { int pos = 0; pos += snprintf(dest+pos, len-pos, \"name \\\"%s\\\", bus %s\", info->name, info->businfo->name); if (info->alias) pos += snprintf(dest+pos, len-pos, \", alias \\\"%s\\\"\", info->alias); if (info->desc) pos += snprintf(dest+pos, len-pos, \", desc \\\"%s\\\"\", info->desc); if (info->nouser) pos += snprintf(dest+pos, len-pos, \", no-user\"); return pos; } ", "target": 0}
{"func": "static int getlastneedednal(H264Context *h, const uint8t *buf, int bufsize) { int nextavc = h->isavc ? 0 : bufsize; int nalindex = 0; int bufindex = 0; int nalsneeded = 0; while(1) { int nalsize = 0; int dstlength, bitlength, consumed; const uint8t *ptr; if (bufindex >= nextavc) { nalsize = getavcnalsize(h, buf, bufsize, &bufindex); if (nalsize < 0) break; nextavc = bufindex + nalsize; } else { bufindex = findstartcode(buf, bufsize, bufindex, nextavc); if (bufindex >= bufsize) break; } ptr = ffh264decodenal(h, buf + bufindex, &dstlength, &consumed, nextavc - bufindex); if (ptr == NULL || dstlength < 0) return AVERRORINVALIDDATA; bufindex += consumed; bitlength = getbitlength(h, buf, ptr, dstlength, bufindex, nextavc); nalindex++; /* packets can sometimes contain multiple PPS/SPS, * e.g. two PAFF field pictures in one packet, or a demuxer * which splits NALs strangely if so, when frame threading we * can't start the next thread until we've read all of them */ switch (h->nalunittype) { case NALSPS: case NALPPS: nalsneeded = nalindex; break; case NALDPA: case NALIDRSLICE: case NALSLICE: initgetbits(&h->gb, ptr, bitlength); if (!getuegolomb(&h->gb)) nalsneeded = nalindex; } } return nalsneeded; } ", "target": 0}
{"func": "e1000ewritepackettoguest(E1000ECore *core, struct NetRxPkt *pkt, const E1000ERxRing *rxr, const E1000ERSSInfo *rssinfo) { PCIDevice *d = core->owner; dmaaddrt base; uint8t desc[E1000MAXRXDESCLEN]; sizet descsize; sizet descoffset = 0; sizet iovofs = 0; struct iovec *iov = netrxpktgetiovec(pkt); sizet size = netrxpktgettotallen(pkt); sizet totalsize = size + e1000xfcslen(core->mac); const E1000ERingInfo *rxi; sizet pshdrlen = 0; bool dops = e1000edops(core, pkt, &pshdrlen); rxi = rxr->i; do { hwaddr ba[MAXPSBUFFERS]; e1000ebastate bastate = { { 0 } }; bool islast = false; bool isfirst = true; descsize = totalsize - descoffset; if (descsize > core->rxdescbufsize) { descsize = core->rxdescbufsize; } base = e1000eringheaddescr(core, rxi); pcidmaread(d, base, &desc, core->rxdesclen); tracee1000erxdescr(rxi->idx, base, core->rxdesclen); e1000ereadrxdescr(core, desc, &ba); if (ba[0]) { if (descoffset < size) { static const uint32t fcspad; sizet iovcopy; sizet copysize = size - descoffset; if (copysize > core->rxdescbufsize) { copysize = core->rxdescbufsize; } /* For PS mode copy the packet header first */ if (dops) { if (isfirst) { sizet pshdrcopied = 0; do { iovcopy = MIN(pshdrlen - pshdrcopied, iov->iovlen - iovofs); e1000ewritehdrtorxbuffers(core, &ba, &bastate, iov->iovbase, iovcopy); copysize -= iovcopy; pshdrcopied += iovcopy; iovofs += iovcopy; if (iovofs == iov->iovlen) { iov++; iovofs = 0; } } while (pshdrcopied < pshdrlen); isfirst = false; } else { /* Leave buffer 0 of each descriptor except first */ /* empty as per spec 7.1.5.1 */ e1000ewritehdrtorxbuffers(core, &ba, &bastate, NULL, 0); } } /* Copy packet payload */ while (copysize) { iovcopy = MIN(copysize, iov->iovlen - iovofs); e1000ewritetorxbuffers(core, &ba, &bastate, iov->iovbase + iovofs, iovcopy); copysize -= iovcopy; iovofs += iovcopy; if (iovofs == iov->iovlen) { iov++; iovofs = 0; } } if (descoffset + descsize >= totalsize) { /* Simulate FCS checksum presence in the last descriptor */ e1000ewritetorxbuffers(core, &ba, &bastate, (const char *) &fcspad, e1000xfcslen(core->mac)); } } descoffset += descsize; if (descoffset >= totalsize) { islast = true; } } else { /* as per intel docs; skip descriptors with null buf addr */ tracee1000erxnulldescriptor(); } e1000ewriterxdescr(core, desc, islast ? core->rxpkt : NULL, rssinfo, dops ? pshdrlen : 0, &bastate.written); pcidmawrite(d, base, &desc, core->rxdesclen); e1000eringadvance(core, rxi, core->rxdesclen / E1000MINRXDESCLEN); } while (descoffset < totalsize); e1000eupdaterxstats(core, size, totalsize); } ", "target": 0}
{"func": "static int cirrusdocopy(CirrusVGAState *s, int dst, int src, int w, int h) { int sx = 0, sy = 0; int dx = 0, dy = 0; int depth = 0; int notify = 0; /* make sure to only copy if it's a plain copy ROP */ if (*s->cirrusrop == cirrusbitbltropfwdsrc || *s->cirrusrop == cirrusbitbltropbkwdsrc) { int width, height; depth = s->vga.getbpp(&s->vga) / 8; if (!depth) { return 0; } s->vga.getresolution(&s->vga, &width, &height); /* extra x, y */ sx = (src % ABS(s->cirrusbltsrcpitch)) / depth; sy = (src / ABS(s->cirrusbltsrcpitch)); dx = (dst % ABS(s->cirrusbltdstpitch)) / depth; dy = (dst / ABS(s->cirrusbltdstpitch)); /* normalize width */ w /= depth; /* if we're doing a backward copy, we have to adjust our x/y to be the upper left corner (instead of the lower right corner) */ if (s->cirrusbltdstpitch < 0) { sx -= (s->cirrusbltwidth / depth) - 1; dx -= (s->cirrusbltwidth / depth) - 1; sy -= s->cirrusbltheight - 1; dy -= s->cirrusbltheight - 1; } /* are we in the visible portion of memory? */ if (sx >= 0 && sy >= 0 && dx >= 0 && dy >= 0 && (sx + w) <= width && (sy + h) <= height && (dx + w) <= width && (dy + h) <= height) { notify = 1; } } (*s->cirrusrop) (s, s->vga.vramptr + s->cirrusbltdstaddr, s->vga.vramptr + s->cirrusbltsrcaddr, \t\t s->cirrusbltdstpitch, s->cirrusbltsrcpitch, \t\t s->cirrusbltwidth, s->cirrusbltheight); if (notify) { dpygfxupdate(s->vga.con, dx, dy, s->cirrusbltwidth / depth, s->cirrusbltheight); } /* we don't have to notify the display that this portion has changed since qemuconsolecopy implies this */ cirrusinvalidateregion(s, s->cirrusbltdstaddr, \t\t\t\ts->cirrusbltdstpitch, s->cirrusbltwidth, \t\t\t\ts->cirrusbltheight); return 1; } ", "target": 0}
{"func": "static int writel1entry(BlockDriverState *bs, int l1index) { BDRVQcowState *s = bs->opaque; uint64t buf[L1ENTRIESPERSECTOR]; int l1startindex; int i, ret; l1startindex = l1index & ~(L1ENTRIESPERSECTOR - 1); for (i = 0; i < L1ENTRIESPERSECTOR; i++) { buf[i] = cputobe64(s->l1table[l1startindex + i]); } BLKDBGEVENT(bs->file, BLKDBGL1UPDATE); ret = bdrvpwrite(bs->file, s->l1tableoffset + 8 * l1startindex, buf, sizeof(buf)); if (ret < 0) { return ret; } return 0; } ", "target": 1}
{"func": "int vhostdevinit(struct vhostdev *hdev, void *opaque, VhostBackendType backendtype) { uint64t features; int i, r; if (vhostsetbackendtype(hdev, backendtype) < 0) { close((uintptrt)opaque); return -1; } if (hdev->vhostops->vhostbackendinit(hdev, opaque) < 0) { close((uintptrt)opaque); return -errno; } r = hdev->vhostops->vhostcall(hdev, VHOSTSETOWNER, NULL); if (r < 0) { goto fail; } r = hdev->vhostops->vhostcall(hdev, VHOSTGETFEATURES, &features); if (r < 0) { goto fail; } for (i = 0; i < hdev->nvqs; ++i) { r = vhostvirtqueueinit(hdev, hdev->vqs + i, hdev->vqindex + i); if (r < 0) { goto failvq; } } hdev->features = features; hdev->memorylistener = (MemoryListener) { .begin = vhostbegin, .commit = vhostcommit, .regionadd = vhostregionadd, .regiondel = vhostregiondel, .regionnop = vhostregionnop, .logstart = vhostlogstart, .logstop = vhostlogstop, .logsync = vhostlogsync, .logglobalstart = vhostlogglobalstart, .logglobalstop = vhostlogglobalstop, .eventfdadd = vhosteventfdadd, .eventfddel = vhosteventfddel, .priority = 10 }; hdev->migrationblocker = NULL; if (!(hdev->features & (0x1ULL << VHOSTFLOGALL))) { errorsetg(&hdev->migrationblocker, \"Migration disabled: vhost lacks VHOSTFLOGALL feature.\"); migrateaddblocker(hdev->migrationblocker); } hdev->mem = gmalloc0(offsetof(struct vhostmemory, regions)); hdev->nmemsections = 0; hdev->memsections = NULL; hdev->log = NULL; hdev->logsize = 0; hdev->logenabled = false; hdev->started = false; hdev->memorychanged = false; memorylistenerregister(&hdev->memorylistener, &addressspacememory); return 0; failvq: while (--i >= 0) { vhostvirtqueuecleanup(hdev->vqs + i); } fail: r = -errno; hdev->vhostops->vhostbackendcleanup(hdev); QLISTREMOVE(hdev, entry); return r; }", "target": 1}
{"func": "int bdrvread(BlockDriverState *bs, int64t sectornum, uint8t *buf, int nbsectors) { BlockDriver *drv = bs->drv; if (!drv) return -ENOMEDIUM; if (drv->bdrvpread) { int ret, len; len = nbsectors * 512; ret = drv->bdrvpread(bs, sectornum * 512, buf, len); if (ret < 0) return ret; else if (ret != len) return -EINVAL; else { \t bs->rdbytes += (unsigned) len; \t bs->rdops ++; return 0; \t} } else { return drv->bdrvread(bs, sectornum, buf, nbsectors); } }", "target": 1}
{"func": "static int makecdt24entry(int p1, int p2, int16t *cdt) { int r, b; b = cdt[p2]; r = cdt[p1]<<16; return (b+r) << 1; } ", "target": 1}
{"func": "static AVFrame *dopsnr(AVFilterContext *ctx, AVFrame *main, const AVFrame *ref) { PSNRContext *s = ctx->priv; double compmse[4], mse = 0; int j, c; AVDictionary **metadata = avprivframegetmetadatap(main); s->computemse(s, (const uint8t **)main->data, main->linesize, (const uint8t **)ref->data, ref->linesize, main->width, main->height, compmse); for (j = 0; j < s->nbcomponents; j++) mse += compmse[j] * s->planeweight[j]; s->minmse = FFMIN(s->minmse, mse); s->maxmse = FFMAX(s->maxmse, mse); s->mse += mse; for (j = 0; j < s->nbcomponents; j++) s->msecomp[j] += compmse[j]; s->nbframes++; for (j = 0; j < s->nbcomponents; j++) { c = s->isrgb ? s->rgbamap[j] : j; setmeta(metadata, \"lavfi.psnr.mse.\", s->comps[j], compmse[c]); setmeta(metadata, \"lavfi.psnr.psnr.\", s->comps[j], getpsnr(compmse[c], 1, s->max[c])); } setmeta(metadata, \"lavfi.psnr.mseavg\", 0, mse); setmeta(metadata, \"lavfi.psnr.psnravg\", 0, getpsnr(mse, 1, s->averagemax)); if (s->statsfile) { fprintf(s->statsfile, \"n:%\"PRId64\" mseavg:%0.2f \", s->nbframes, mse); for (j = 0; j < s->nbcomponents; j++) { c = s->isrgb ? s->rgbamap[j] : j; fprintf(s->statsfile, \"mse%c:%0.2f \", s->comps[j], compmse[c]); } for (j = 0; j < s->nbcomponents; j++) { c = s->isrgb ? s->rgbamap[j] : j; fprintf(s->statsfile, \"psnr%c:%0.2f \", s->comps[j], getpsnr(compmse[c], 1, s->max[c])); } fprintf(s->statsfile, \"\\n\"); } return main; } ", "target": 1}
{"func": "static void matroskaaddindexentries(MatroskaDemuxContext *matroska) { EbmlList *indexlist; MatroskaIndex *index; int indexscale = 1; int i, j; if (matroska->ctx->flags & AVFMTFLAGIGNIDX) return; indexlist = &matroska->index; index = indexlist->elem; if (indexlist->nbelem && index[0].time > 1E14 / matroska->timescale) { avlog(matroska->ctx, AVLOGWARNING, \"Working around broken index.\\n\"); indexscale = matroska->timescale; } for (i = 0; i < indexlist->nbelem; i++) { EbmlList *poslist = &index[i].pos; MatroskaIndexPos *pos = poslist->elem; for (j = 0; j < poslist->nbelem; j++) { MatroskaTrack *track = matroskafindtrackbynum(matroska, pos[j].track); if (track && track->stream) avaddindexentry(track->stream, pos[j].pos + matroska->segmentstart, index[i].time / indexscale, 0, 0, AVINDEXKEYFRAME); } } } ", "target": 1}
{"func": "static inline void downmix3f2rtomono(float *samples) { int i; for (i = 0; i < 256; i++) { samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768] + samples[i + 1024]); samples[i + 256] = samples[i + 512] = samples[i + 768] = samples[i + 1024] = 0; } } ", "target": 0}
{"func": "static bool vtddecideconfig(IntelIOMMUState *s, Error **errp) { X86IOMMUState *x86iommu = X86IOMMUDEVICE(s); /* Currently Intel IOMMU IR only support \"kernel-irqchip={off|split}\" */ if (x86iommu->intrsupported && kvmirqchipinkernel() && !kvmirqchipissplit()) { errorsetg(errp, \"Intel Interrupt Remapping cannot work with \" \"kernel-irqchip=on, please use 'split|off'.\"); return false; } if (s->intreim == ONOFFAUTOON && !x86iommu->intrsupported) { errorsetg(errp, \"eim=on cannot be selected without intremap=on\"); return false; } if (s->intreim == ONOFFAUTOAUTO) { s->intreim = x86iommu->intrsupported ? ONOFFAUTOON : ONOFFAUTOOFF; } return true; } ", "target": 1}
{"func": "static int noinitin (HWVoiceIn *hw, struct audsettings *as) { audiopcminitinfo (&hw->info, as); hw->samples = 1024; return 0; } ", "target": 1}
{"func": "static int nsvreadchunk(AVFormatContext *s, int fillheader) { NSVContext *nsv = s->privdata; AVIOContext *pb = s->pb; AVStream *st[2] = {NULL, NULL}; NSVStream *nst; AVPacket *pkt; int i, err = 0; uint8t auxcount; /* number of aux metadata, also 4 bits of vsize */ uint32t vsize; uint16t asize; uint16t auxsize; if (nsv->ahead[0].data || nsv->ahead[1].data) return 0; //-1; /* hey! eat what you've in your plate first! */ nullchunkretry: if (pb->eofreached) return -1; for (i = 0; i < NSVMAXRESYNCTRIES && nsv->state < NSVFOUNDNSVS && !err; i++) err = nsvresync(s); if (err < 0) return err; if (nsv->state == NSVFOUNDNSVS) err = nsvparseNSVsheader(s); if (err < 0) return err; if (nsv->state != NSVHASREADNSVS && nsv->state != NSVFOUNDBEEF) return -1; auxcount = avior8(pb); vsize = aviorl16(pb); asize = aviorl16(pb); vsize = (vsize << 4) | (auxcount >> 4); auxcount &= 0x0f; avlog(s, AVLOGTRACE, \"NSV CHUNK %\"PRIu8\" aux, %\"PRIu32\" bytes video, %\"PRIu16\" bytes audio\\n\", auxcount, vsize, asize); /* skip aux stuff */ for (i = 0; i < auxcount; i++) { uint32t avunused auxtag; auxsize = aviorl16(pb); auxtag = aviorl32(pb); avioskip(pb, auxsize); vsize -= auxsize + sizeof(uint16t) + sizeof(uint32t); /* that's becoming brain-dead */ } if (pb->eofreached) return -1; if (!vsize && !asize) { nsv->state = NSVUNSYNC; goto nullchunkretry; } /* map back streams to v,a */ if (s->nbstreams > 0) st[s->streams[0]->id] = s->streams[0]; if (s->nbstreams > 1) st[s->streams[1]->id] = s->streams[1]; if (vsize && st[NSVSTVIDEO]) { nst = st[NSVSTVIDEO]->privdata; pkt = &nsv->ahead[NSVSTVIDEO]; avgetpacket(pb, pkt, vsize); pkt->streamindex = st[NSVSTVIDEO]->index;//NSVSTVIDEO; pkt->dts = nst->frameoffset; pkt->flags |= nsv->state == NSVHASREADNSVS ? AVPKTFLAGKEY : 0; /* keyframe only likely on a sync frame */ for (i = 0; i < FFMIN(8, vsize); i++) avlog(s, AVLOGTRACE, \"NSV video: [%d] = %02\"PRIx8\"\\n\", i, pkt->data[i]); } if(st[NSVSTVIDEO]) ((NSVStream*)st[NSVSTVIDEO]->privdata)->frameoffset++; if (asize && st[NSVSTAUDIO]) { nst = st[NSVSTAUDIO]->privdata; pkt = &nsv->ahead[NSVSTAUDIO]; /* read raw audio specific header on the first audio chunk... */ /* on ALL audio chunks ?? seems so! */ if (asize && st[NSVSTAUDIO]->codecpar->codectag == MKTAG('P', 'C', 'M', ' ')/* && fillheader*/) { uint8t bps; uint8t channels; uint16t samplerate; bps = avior8(pb); channels = avior8(pb); samplerate = aviorl16(pb); if (!channels || !samplerate) return AVERRORINVALIDDATA; asize-=4; avlog(s, AVLOGTRACE, \"NSV RAWAUDIO: bps %\"PRIu8\", nchan %\"PRIu8\", srate %\"PRIu16\"\\n\", bps, channels, samplerate); if (fillheader) { st[NSVSTAUDIO]->needparsing = AVSTREAMPARSENONE; /* we know everything */ if (bps != 16) { avlog(s, AVLOGTRACE, \"NSV AUDIO bit/sample != 16 (%\"PRIu8\")!!!\\n\", bps); } bps /= channels; // ??? if (bps == 8) st[NSVSTAUDIO]->codecpar->codecid = AVCODECIDPCMU8; samplerate /= 4;/* UGH ??? XXX */ channels = 1; st[NSVSTAUDIO]->codecpar->channels = channels; st[NSVSTAUDIO]->codecpar->samplerate = samplerate; avlog(s, AVLOGTRACE, \"NSV RAWAUDIO: bps %\"PRIu8\", nchan %\"PRIu8\", srate %\"PRIu16\"\\n\", bps, channels, samplerate); } } avgetpacket(pb, pkt, asize); pkt->streamindex = st[NSVSTAUDIO]->index;//NSVSTAUDIO; pkt->flags |= nsv->state == NSVHASREADNSVS ? AVPKTFLAGKEY : 0; /* keyframe only likely on a sync frame */ if( nsv->state == NSVHASREADNSVS && st[NSVSTVIDEO] ) { /* on a nsvs frame we have new information on a/v sync */ pkt->dts = (((NSVStream*)st[NSVSTVIDEO]->privdata)->frameoffset-1); pkt->dts *= (int64t)1000 * nsv->framerate.den; pkt->dts += (int64t)nsv->avsync * nsv->framerate.num; avlog(s, AVLOGTRACE, \"NSV AUDIO: sync:%\"PRId16\", dts:%\"PRId64, nsv->avsync, pkt->dts); } nst->frameoffset++; } nsv->state = NSVUNSYNC; return 0; } ", "target": 1}
{"func": "static int blocksavecomplete(QEMUFile *f, void *opaque) { int ret; DPRINTF(\"Enter save live complete submitted %d transferred %d\\n\", blockmigstate.submitted, blockmigstate.transferred); ret = flushblks(f); if (ret) { return ret; } blkmigresetdirtycursor(); /* we know for sure that save bulk is completed and all async read completed */ blkmiglock(); assert(blockmigstate.submitted == 0); blkmigunlock(); do { ret = blkmigsavedirtyblock(f, 0); if (ret < 0) { return ret; } } while (ret == 0); /* report completion */ qemuputbe64(f, (100 << BDRVSECTORBITS) | BLKMIGFLAGPROGRESS); DPRINTF(\"Block migration completed\\n\"); qemuputbe64(f, BLKMIGFLAGEOS); blkmigcleanup(); return 0; } ", "target": 1}
{"func": "matroskaparseblock(MatroskaDemuxContext *matroska, uint8t *data, int size, int64t pos, uint64t clustertime, uint64t duration, int iskeyframe, int isbframe) { int res = 0; int track; AVStream *st; AVPacket *pkt; uint8t *origdata = data; int16t blocktime; uint32t *lacesize = NULL; int n, flags, laces = 0; uint64t num; int streamindex; /* first byte(s): tracknum */ if ((n = matroskaebmlnumuint(data, size, &num)) < 0) { avlog(matroska->ctx, AVLOGERROR, \"EBML block data error\\n\"); avfree(origdata); return res; } data += n; size -= n; /* fetch track from num */ track = matroskafindtrackbynum(matroska, num); if (size <= 3 || track < 0 || track >= matroska->numtracks) { avlog(matroska->ctx, AVLOGINFO, \"Invalid stream %d or size %u\\n\", track, size); avfree(origdata); return res; } streamindex = matroska->tracks[track]->streamindex; if (streamindex < 0 || streamindex >= matroska->ctx->nbstreams) { avfree(origdata); return res; } st = matroska->ctx->streams[streamindex]; if (st->discard >= AVDISCARDALL) { avfree(origdata); return res; } if (duration == AVNOPTSVALUE) duration = matroska->tracks[track]->defaultduration / matroska->timescale; /* blocktime (relative to cluster time) */ blocktime = AVRB16(data); data += 2; flags = *data++; size -= 3; if (iskeyframe == -1) iskeyframe = flags & 0x80 ? PKTFLAGKEY : 0; if (matroska->skiptokeyframe) { if (!iskeyframe || st != matroska->skiptostream) { avfree(origdata); return res; } matroska->skiptokeyframe = 0; } switch ((flags & 0x06) >> 1) { case 0x0: /* no lacing */ laces = 1; lacesize = avmallocz(sizeof(int)); lacesize[0] = size; break; case 0x1: /* xiph lacing */ case 0x2: /* fixed-size lacing */ case 0x3: /* EBML lacing */ assert(size>0); // size <=3 is checked before size-=3 above laces = (*data) + 1; data += 1; size -= 1; lacesize = avmallocz(laces * sizeof(int)); switch ((flags & 0x06) >> 1) { case 0x1: /* xiph lacing */ { uint8t temp; uint32t total = 0; for (n = 0; res == 0 && n < laces - 1; n++) { while (1) { if (size == 0) { res = -1; break; } temp = *data; lacesize[n] += temp; data += 1; size -= 1; if (temp != 0xff) break; } total += lacesize[n]; } lacesize[n] = size - total; break; } case 0x2: /* fixed-size lacing */ for (n = 0; n < laces; n++) lacesize[n] = size / laces; break; case 0x3: /* EBML lacing */ { uint32t total; n = matroskaebmlnumuint(data, size, &num); if (n < 0) { avlog(matroska->ctx, AVLOGINFO, \"EBML block data error\\n\"); break; } data += n; size -= n; total = lacesize[0] = num; for (n = 1; res == 0 && n < laces - 1; n++) { int64t snum; int r; r = matroskaebmlnumsint (data, size, &snum); if (r < 0) { avlog(matroska->ctx, AVLOGINFO, \"EBML block data error\\n\"); break; } data += r; size -= r; lacesize[n] = lacesize[n - 1] + snum; total += lacesize[n]; } lacesize[n] = size - total; break; } } break; } if (res == 0) { uint64t timecode = AVNOPTSVALUE; if (clustertime != (uint64t)-1 && (blocktime >= 0 || clustertime >= -blocktime)) timecode = clustertime + blocktime; for (n = 0; n < laces; n++) { if (st->codec->codecid == CODECIDRA288 || st->codec->codecid == CODECIDCOOK || st->codec->codecid == CODECIDATRAC3) { MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *)matroska->tracks[track]; int a = st->codec->blockalign; int sps = audiotrack->subpacketsize; int cfs = audiotrack->codedframesize; int h = audiotrack->subpacketh; int y = audiotrack->subpacketcnt; int w = audiotrack->framesize; int x; if (!audiotrack->pktcnt) { if (st->codec->codecid == CODECIDRA288) for (x=0; x<h/2; x++) memcpy(audiotrack->buf+x*2*w+y*cfs, data+x*cfs, cfs); else for (x=0; x<w/sps; x++) memcpy(audiotrack->buf+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), data+x*sps, sps); if (++audiotrack->subpacketcnt >= h) { audiotrack->subpacketcnt = 0; audiotrack->pktcnt = h*w / a; } } while (audiotrack->pktcnt) { pkt = avmallocz(sizeof(AVPacket)); avnewpacket(pkt, a); memcpy(pkt->data, audiotrack->buf + a * (h*w / a - audiotrack->pktcnt--), a); pkt->pos = pos; pkt->streamindex = streamindex; matroskaqueuepacket(matroska, pkt); } } else { int result, offset = 0, ilen, olen, pktsize = lacesize[n]; uint8t *pktdata = data; if (matroska->tracks[track]->encodingscope & 1) { switch (matroska->tracks[track]->encodingalgo) { case MATROSKATRACKENCODINGCOMPHEADERSTRIP: offset = matroska->tracks[track]->encodingsettingslen; break; case MATROSKATRACKENCODINGCOMPLZO: pktdata = NULL; do { ilen = lacesize[n]; olen = pktsize *= 3; pktdata = avrealloc(pktdata, pktsize+LZOOUTPUTPADDING); result = lzo1xdecode(pktdata, &olen, data, &ilen); } while (result==LZOOUTPUTFULL && pktsize<10000000); if (result) { continue; } pktsize -= olen; break; #ifdef CONFIGZLIB case MATROSKATRACKENCODINGCOMPZLIB: { zstream zstream = {0}; pktdata = NULL; if (inflateInit(&zstream) != ZOK) continue; zstream.nextin = data; zstream.availin = lacesize[n]; do { pktsize *= 3; pktdata = avrealloc(pktdata, pktsize); zstream.availout = pktsize - zstream.totalout; zstream.nextout = pktdata + zstream.totalout; result = inflate(&zstream, ZNOFLUSH); } while (result==ZOK && pktsize<10000000); pktsize = zstream.totalout; inflateEnd(&zstream); if (result != ZSTREAMEND) { continue; } break; } #endif #ifdef CONFIGBZLIB case MATROSKATRACKENCODINGCOMPBZLIB: { bzstream bzstream = {0}; pktdata = NULL; if (BZ2bzDecompressInit(&bzstream, 0, 0) != BZOK) continue; bzstream.nextin = data; bzstream.availin = lacesize[n]; do { pktsize *= 3; pktdata = avrealloc(pktdata, pktsize); bzstream.availout = pktsize - bzstream.totaloutlo32; bzstream.nextout = pktdata + bzstream.totaloutlo32; result = BZ2bzDecompress(&bzstream); } while (result==BZOK && pktsize<10000000); pktsize = bzstream.totaloutlo32; BZ2bzDecompressEnd(&bzstream); if (result != BZSTREAMEND) { continue; } break; } #endif } } pkt = avmallocz(sizeof(AVPacket)); /* XXX: prevent data copy... */ if (avnewpacket(pkt, pktsize+offset) < 0) { avfree(pkt); res = AVERROR(ENOMEM); n = laces-1; break; } if (offset) memcpy (pkt->data, matroska->tracks[track]->encodingsettings, offset); memcpy (pkt->data+offset, pktdata, pktsize); if (n == 0) pkt->flags = iskeyframe; pkt->streamindex = streamindex; pkt->pts = timecode; pkt->pos = pos; pkt->duration = duration; matroskaqueuepacket(matroska, pkt); } if (timecode != AVNOPTSVALUE) timecode = duration ? timecode + duration : AVNOPTSVALUE; data += lacesize[n]; } } avfree(lacesize); avfree(origdata); return res; }", "target": 1}
{"func": "void ffvp56initrangedecoder(VP56RangeCoder *c, const uint8t *buf, int bufsize) { c->high = 255; c->bits = -16; c->buffer = buf; c->end = buf + bufsize; c->codeword = bytestreamgetbe24(&c->buffer); } ", "target": 1}
{"func": "int vringpop(VirtIODevice *vdev, Vring *vring, VirtQueueElement **pelem) { struct vringdesc desc; unsigned int i, head, found = 0, num = vring->vr.num; uint16t availidx, lastavailidx; VirtQueueElement *elem = NULL; int ret; /* If there was a fatal error then refuse operation */ if (vring->broken) { ret = -EFAULT; goto out; } /* Check it isn't doing very strange things with descriptor numbers. */ lastavailidx = vring->lastavailidx; availidx = vring->vr.avail->idx; barrier(); /* load indices now and not again later */ if (unlikely((uint16t)(availidx - lastavailidx) > num)) { errorreport(\"Guest moved used index from %u to %u\", lastavailidx, availidx); ret = -EFAULT; goto out; } /* If there's nothing new since last we looked. */ if (availidx == lastavailidx) { ret = -EAGAIN; goto out; } /* Only get avail ring entries after they have been exposed by guest. */ smprmb(); /* Grab the next descriptor number they're advertising, and increment * the index we've seen. */ head = vring->vr.avail->ring[lastavailidx % num]; elem = gslicenew(VirtQueueElement); elem->index = head; elem->innum = elem->outnum = 0; /* If their number is silly, that's an error. */ if (unlikely(head >= num)) { errorreport(\"Guest says index %u > %u is available\", head, num); ret = -EFAULT; goto out; } if (vdev->guestfeatures & (1 << VIRTIORINGFEVENTIDX)) { vringavailevent(&vring->vr) = vring->vr.avail->idx; } i = head; do { if (unlikely(i >= num)) { errorreport(\"Desc index is %u > %u, head = %u\", i, num, head); ret = -EFAULT; goto out; } if (unlikely(++found > num)) { errorreport(\"Loop detected: last one at %u vq size %u head %u\", i, num, head); ret = -EFAULT; goto out; } desc = vring->vr.desc[i]; /* Ensure descriptor is loaded before accessing fields */ barrier(); if (desc.flags & VRINGDESCFINDIRECT) { ret = getindirect(vring, elem, &desc); if (ret < 0) { goto out; } continue; } ret = getdesc(vring, elem, &desc); if (ret < 0) { goto out; } i = desc.next; } while (desc.flags & VRINGDESCFNEXT); /* On success, increment avail index. */ vring->lastavailidx++; *pelem = elem; return head; out: assert(ret < 0); if (ret == -EFAULT) { vring->broken = true; } if (elem) { vringunmapelement(elem); gslicefree(VirtQueueElement, elem); } *pelem = NULL; return ret; } ", "target": 1}
{"func": "static int ftpconnectcontrolconnection(URLContext *h) { char buf[CONTROLBUFFERSIZE], optsformat[20]; int err; AVDictionary *opts = NULL; FTPContext *s = h->privdata; const int connectcodes[] = {220, 0}; s->conncontrolblockflag = 0; if (!s->conncontrol) { ffurljoin(buf, sizeof(buf), \"tcp\", NULL, s->hostname, s->servercontrolport, NULL); if (s->rwtimeout != -1) { snprintf(optsformat, sizeof(optsformat), \"%d\", s->rwtimeout); avdictset(&opts, \"timeout\", optsformat, 0); } /* if option is not given, don't pass it and let tcp use its own default */ err = ffurlopen(&s->conncontrol, buf, AVIOFLAGREADWRITE, &s->conncontrolinterruptcb, &opts); avdictfree(&opts); if (err < 0) { avlog(h, AVLOGERROR, \"Cannot open control connection\\n\"); return err; } /* consume all messages from server */ if (!ftpstatus(s, NULL, connectcodes)) { avlog(h, AVLOGERROR, \"FTP server not ready for new users\\n\"); err = AVERROR(EACCES); return err; } if ((err = ftpauth(s)) < 0) { avlog(h, AVLOGERROR, \"FTP authentication failed\\n\"); return err; } if ((err = ftptype(s)) < 0) { avdlog(h, \"Set content type failed\\n\"); return err; } } return 0; } ", "target": 0}
{"func": "void qpcimemread(QPCIDevice *dev, void *data, void *buf, sizet len) { uintptrt addr = (uintptrt)data; gassert(addr >= QPCIPIOLIMIT); dev->bus->memread(dev->bus, addr, buf, len); } ", "target": 1}
{"func": "static int isintramorelikely(ERContext *s) { int isintralikely, i, j, undamagedcount, skipamount, mbx, mby; if (!s->lastpic.f || !s->lastpic.f->data[0]) return 1; // no previous frame available -> use spatial prediction undamagedcount = 0; for (i = 0; i < s->mbnum; i++) { const int mbxy = s->mbindex2xy[i]; const int error = s->errorstatustable[mbxy]; if (!((error & ERDCERROR) && (error & ERMVERROR))) undamagedcount++; } if (s->avctx->codecid == AVCODECIDH264 && s->refcount <= 0) return 1; if (undamagedcount < 5) return 0; // almost all MBs damaged -> use temporal prediction #if FFAPIXVMC FFDISABLEDEPRECATIONWARNINGS // prevent dsp.sad() check, that requires access to the image if (CONFIGMPEGXVMCDECODER && s->avctx->xvmcacceleration && s->curpic.f->picttype == AVPICTURETYPEI) return 1; FFENABLEDEPRECATIONWARNINGS #endif /* FFAPIXVMC */ skipamount = FFMAX(undamagedcount / 50, 1); // check only up to 50 MBs isintralikely = 0; j = 0; for (mby = 0; mby < s->mbheight - 1; mby++) { for (mbx = 0; mbx < s->mbwidth; mbx++) { int error; const int mbxy = mbx + mby * s->mbstride; error = s->errorstatustable[mbxy]; if ((error & ERDCERROR) && (error & ERMVERROR)) continue; // skip damaged j++; // skip a few to speed things up if ((j % skipamount) != 0) continue; if (s->curpic.f->picttype == AVPICTURETYPEI) { int *linesize = s->curpic.f->linesize; uint8t *mbptr = s->curpic.f->data[0] + mbx * 16 + mby * 16 * linesize[0]; uint8t *lastmbptr = s->lastpic.f->data[0] + mbx * 16 + mby * 16 * linesize[0]; if (s->avctx->codecid == AVCODECIDH264) { // FIXME } else { ffthreadawaitprogress(s->lastpic.tf, mby, 0); } isintralikely += s->mecc->sad[0](NULL, lastmbptr, mbptr, linesize[0], 16); isintralikely -= s->mecc->sad[0](NULL, lastmbptr, lastmbptr + linesize[0] * 16, linesize[0], 16); } else { if (ISINTRA(s->curpic.mbtype[mbxy])) isintralikely++; else isintralikely--; } } } return isintralikely > 0; } ", "target": 0}
{"func": "void Release(void *ctx) { ContextInfo *ci; ci = (ContextInfo *) ctx; if (ci->cache) { imlibcontextsetimage(ci->cache->image); imlibfreeimage(); avfree(ci->cache); } if (ctx) { if (ci->imageOverlaid) { imlibcontextsetimage(ci->imageOverlaid); imlibfreeimage(); } ffevalfree(ci->exprx); ffevalfree(ci->expry); ffevalfree(ci->exprR); ffevalfree(ci->exprG); ffevalfree(ci->exprB); swsfreeContext(ci->toRGBconvertctx); swsfreeContext(ci->fromRGBconvertctx); avfree(ctx); } } ", "target": 1}
{"func": "void qemuaioflush(void) { AioHandler *node; int ret; do { ret = 0; \t/* \t * If there are pending emulated aio start them now so flush \t * will be able to return 1. \t */ qemuaiowait(); LISTFOREACH(node, &aiohandlers, node) { ret |= node->ioflush(node->opaque); } } while (ret > 0); } ", "target": 1}
{"func": "static void quantizeandencodebandcostZEROmips(struct AACEncContext *s, PutBitContext *pb, const float *in, float *out, const float *scaled, int size, int scaleidx, int cb, const float lambda, const float uplim, int *bits, const float ROUNDING) { int i; if (bits) *bits = 0; if (out) { for (i = 0; i < size; i += 4) { out[i ] = 0.0f; out[i+1] = 0.0f; out[i+2] = 0.0f; out[i+3] = 0.0f; } } } ", "target": 1}
{"func": "static int xenplatforminitfn(PCIDevice *dev) { PCIXenPlatformState *d = XENPLATFORM(dev); uint8t *pciconf; pciconf = dev->config; pcisetword(pciconf + PCICOMMAND, PCICOMMANDIO | PCICOMMANDMEMORY); pciconfigsetproginterface(pciconf, 0); pciconf[PCIINTERRUPTPIN] = 1; platformioportbarsetup(d); pciregisterbar(dev, 0, PCIBASEADDRESSSPACEIO, &d->bar); /* reserve 16MB mmio address for share memory*/ platformmmiosetup(d); pciregisterbar(dev, 1, PCIBASEADDRESSMEMPREFETCH, &d->mmiobar); platformfixedioportinit(d); return 0; }", "target": 1}
{"func": "static void mmapreleasebuffer(AVPacket *pkt) { struct v4l2buffer buf; int res, fd; struct buffdata *bufdescriptor = pkt->priv; if (pkt->data == NULL) return; memset(&buf, 0, sizeof(struct v4l2buffer)); buf.type = V4L2BUFTYPEVIDEOCAPTURE; buf.memory = V4L2MEMORYMMAP; buf.index = bufdescriptor->index; fd = bufdescriptor->fd; avfree(bufdescriptor); res = ioctl(fd, VIDIOCQBUF, &buf); if (res < 0) avlog(NULL, AVLOGERROR, \"ioctl(VIDIOCQBUF): %s\\n\", strerror(errno)); pkt->data = NULL; pkt->size = 0; } ", "target": 0}
{"func": "static void coroutinefn c1fn(void *opaque) { Coroutine *c2 = opaque; qemucoroutineenter(c2, NULL); } ", "target": 1}
{"func": "static int writetargetcommit(BlockDriverState *bs, int64t sectornum, \tconst uint8t* buffer, int nbsectors) { BDRVVVFATState* s = bs->opaque; return trycommit(s); } ", "target": 1}
{"func": "static void showpackets(AVFormatContext *fmtctx) { AVPacket pkt; avinitpacket(&pkt); probearrayheader(\"packets\", 0); while (!avreadframe(fmtctx, &pkt)) showpacket(fmtctx, &pkt); probearrayfooter(\"packets\", 0); } ", "target": 1}
{"func": "static void sdhciwritedataport(SDHCIState *s, uint32t value, unsigned size) { unsigned i; /* Check that there is free space left in a buffer */ if (!(s->prnsts & SDHCSPACEAVAILABLE)) { ERRPRINT(\"Can't write to data buffer: buffer full\\n\"); return; } for (i = 0; i < size; i++) { s->fifobuffer[s->datacount] = value & 0xFF; s->datacount++; value >>= 8; if (s->datacount >= (s->blksize & 0x0fff)) { DPRINTL2(\"write buffer filled with %u bytes of data\\n\", s->datacount); s->datacount = 0; s->prnsts &= ~SDHCSPACEAVAILABLE; if (s->prnsts & SDHCDOINGWRITE) { SDHCIGETCLASS(s)->writeblocktocard(s); } } } } ", "target": 0}
{"func": "static uint64t omapulpdpmread(void *opaque, targetphysaddrt addr, unsigned size) { struct omapmpustates *s = (struct omapmpustates *) opaque; uint16t ret; if (size != 2) { return omapbadwidthread16(opaque, addr); } switch (addr) { case 0x14:\t/* ITSTATUS */ ret = s->ulpdpmregs[addr >> 2]; s->ulpdpmregs[addr >> 2] = 0; qemuirqlower(s->irq[1][OMAPINTGAUGE32K]); return ret; case 0x18:\t/* Reserved */ case 0x1c:\t/* Reserved */ case 0x20:\t/* Reserved */ case 0x28:\t/* Reserved */ case 0x2c:\t/* Reserved */ OMAPBADREG(addr); case 0x00:\t/* COUNTER32LSB */ case 0x04:\t/* COUNTER32MSB */ case 0x08:\t/* COUNTERHIGHFREQLSB */ case 0x0c:\t/* COUNTERHIGHFREQMSB */ case 0x10:\t/* GAUGINGCTRL */ case 0x24:\t/* SETUPANALOGCELL3ULPD1 */ case 0x30:\t/* CLOCKCTRL */ case 0x34:\t/* SOFTREQ */ case 0x38:\t/* COUNTER32FIQ */ case 0x3c:\t/* DPLLCTRL */ case 0x40:\t/* STATUSREQ */ /* XXX: check clk::usecount state for every clock */ case 0x48:\t/* LOCLTIME */ case 0x4c:\t/* APLLCTRL */ case 0x50:\t/* POWERCTRL */ return s->ulpdpmregs[addr >> 2]; } OMAPBADREG(addr); return 0; } ", "target": 0}
{"func": "static int milkymistmemcardinit(SysBusDevice *dev) { MilkymistMemcardState *s = MILKYMISTMEMCARD(dev); DriveInfo *dinfo; BlockDriverState *bs; dinfo = drivegetnext(IFSD); bs = dinfo ? blkbs(blkbylegacydinfo(dinfo)) : NULL; s->card = sdinit(bs, false); if (s->card == NULL) { return -1; } s->enabled = bs && bdrvisinserted(bs); memoryregioninitio(&s->regsregion, OBJECT(s), &memcardmmioops, s, \"milkymist-memcard\", RMAX * 4); sysbusinitmmio(dev, &s->regsregion); return 0; } ", "target": 0}
{"func": "static void visitoroutputsetupinternal(TestOutputVisitorData *data, bool human) { data->human = human; data->sov = stringoutputvisitornew(human); gassert(data->sov); data->ov = stringoutputgetvisitor(data->sov); gassert(data->ov); } ", "target": 0}
{"func": "static int getriff(AVFormatContext *s, AVIOContext *pb) { AVIContext *avi = s->privdata; char header[8]; int i; /* check RIFF header */ avioread(pb, header, 4); avi->riffend = aviorl32(pb); /* RIFF chunk size */ avi->riffend += aviotell(pb); /* RIFF chunk end */ avioread(pb, header+4, 4); for(i=0; aviheaders[i][0]; i++) if(!memcmp(header, aviheaders[i], 8)) break; if(!aviheaders[i][0]) return -1; if(header[7] == 0x19) avlog(s, AVLOGINFO, \"This file has been generated by a totally broken muxer.\\n\"); return 0; } ", "target": 0}
{"func": "ethgetrssexsrcaddr(const struct iovec *pkt, int pktfrags, sizet dsthdroffset, struct ip6exthdr *exthdr, struct in6address *srcaddr) { sizet bytesleft = (exthdr->ip6rlen + 1) * 8 - sizeof(*exthdr); struct ip6optionhdr opthdr; sizet optoffset = dsthdroffset + sizeof(*exthdr); while (bytesleft > sizeof(opthdr)) { sizet inputsize = iovsize(pkt, pktfrags); sizet bytesread, optlen; if (inputsize < optoffset) { return false; } bytesread = iovtobuf(pkt, pktfrags, optoffset, &opthdr, sizeof(opthdr)); if (bytesread != sizeof(opthdr)) { return false; } optlen = (opthdr.type == IP6OPTPAD1) ? 1 : (opthdr.len + sizeof(opthdr)); if (optlen > bytesleft) { return false; } if (opthdr.type == IP6OPTHOME) { sizet inputsize = iovsize(pkt, pktfrags); if (inputsize < optoffset + sizeof(opthdr)) { return false; } bytesread = iovtobuf(pkt, pktfrags, optoffset + sizeof(opthdr), srcaddr, sizeof(*srcaddr)); return bytesread == sizeof(srcaddr); } optoffset += optlen; bytesleft -= optlen; } return false; } ", "target": 1}
{"func": "static int altivecuyvyrgb32 (SwsContext *c, \t\t\t unsigned char **in, int *instrides, \t\t\t int srcSliceY,\tint srcSliceH, \t\t\t unsigned char **oplanes, int *outstrides) { int w = c->srcW; int h = srcSliceH; int i,j; vector unsigned char uyvy; vector signed short Y,U,V; vector signed short vx,ux,uvx; vector signed short R0,G0,B0,R1,G1,B1; vector unsigned char R,G,B; vector unsigned char *out; ubyte *img; img = in[0]; out = (vector unsigned char *)(oplanes[0]+srcSliceY*outstrides[0]); for (i=0;i<h;i++) { for (j=0;j<w/16;j++) { uyvy = vecld (0, img); U = (vector signed short) \tvecperm (uyvy, (vector unsigned char)(0), demuxu); V = (vector signed short) \tvecperm (uyvy, (vector unsigned char)(0), demuxv); Y = (vector signed short) \tvecperm (uyvy, (vector unsigned char)(0), demuxy); cvtyuvtoRGB (c, Y,U,V,&R0,&G0,&B0); uyvy = vecld (16, img); U = (vector signed short) \tvecperm (uyvy, (vector unsigned char)(0), demuxu); V = (vector signed short) \tvecperm (uyvy, (vector unsigned char)(0), demuxv); Y = (vector signed short) \tvecperm (uyvy, (vector unsigned char)(0), demuxy); cvtyuvtoRGB (c, Y,U,V,&R1,&G1,&B1); R = vecpackclp (R0,R1); G = vecpackclp (G0,G1); B = vecpackclp (B0,B1); // vecmstbgr24 (R,G,B, out); outrgba (R,G,B,out); img += 32; } } return srcSliceH; } ", "target": 0}
{"func": "static void increfcounts(BlockDriverState *bs, BdrvCheckResult *res, uint16t *refcounttable, int refcounttablesize, int64t offset, int64t size) { BDRVQcowState *s = bs->opaque; uint64t start, last, clusteroffset, k; if (size <= 0) return; start = startofcluster(s, offset); last = startofcluster(s, offset + size - 1); for(clusteroffset = start; clusteroffset <= last; clusteroffset += s->clustersize) { k = clusteroffset >> s->clusterbits; if (k >= refcounttablesize) { fprintf(stderr, \"Warning: cluster offset=0x%\" PRIx64 \" is after \" \"the end of the image file, can't properly check refcounts.\\n\", clusteroffset); res->checkerrors++; } else { if (++refcounttable[k] == 0) { fprintf(stderr, \"ERROR: overflow cluster offset=0x%\" PRIx64 \"\\n\", clusteroffset); res->corruptions++; } } } } ", "target": 0}
{"func": "void stwphys(targetphysaddrt addr, uint32t val) { uint16t v = tswap16(val); cpuphysicalmemorywrite(addr, (const uint8t *)&v, 2); } ", "target": 0}
{"func": "static void genbranch(DisasContext *ctx, int insnbytes) { if (ctx->hflags & MIPSHFLAGBMASK) { int prochflags = ctx->hflags & MIPSHFLAGBMASK; /* Branches completion */ ctx->hflags &= ~MIPSHFLAGBMASK; ctx->bstate = BSBRANCH; savecpustate(ctx, 0); /* FIXME: Need to clear candoio. */ switch (prochflags & MIPSHFLAGBMASKBASE) { case MIPSHFLAGFBNSLOT: MIPSDEBUG(\"forbidden slot\"); gengototb(ctx, 0, ctx->pc + insnbytes); break; case MIPSHFLAGB: /* unconditional branch */ MIPSDEBUG(\"unconditional branch\"); if (prochflags & MIPSHFLAGBX) { tcggenxorii32(hflags, hflags, MIPSHFLAGM16); } gengototb(ctx, 0, ctx->btarget); break; case MIPSHFLAGBL: /* blikely taken case */ MIPSDEBUG(\"blikely branch taken\"); gengototb(ctx, 0, ctx->btarget); break; case MIPSHFLAGBC: /* Conditional branch */ MIPSDEBUG(\"conditional branch\"); { int l1 = gennewlabel(); tcggenbrconditl(TCGCONDNE, bcond, 0, l1); gengototb(ctx, 1, ctx->pc + insnbytes); gensetlabel(l1); gengototb(ctx, 0, ctx->btarget); } break; case MIPSHFLAGBR: /* unconditional branch to register */ MIPSDEBUG(\"branch to register\"); if (ctx->insnflags & (ASEMIPS16 | ASEMICROMIPS)) { TCGv t0 = tcgtempnew(); TCGvi32 t1 = tcgtempnewi32(); tcggenanditl(t0, btarget, 0x1); tcggentrunctli32(t1, t0); tcgtempfree(t0); tcggenandii32(hflags, hflags, ~(uint32t)MIPSHFLAGM16); tcggenshlii32(t1, t1, MIPSHFLAGM16SHIFT); tcggenori32(hflags, hflags, t1); tcgtempfreei32(t1); tcggenanditl(cpuPC, btarget, ~(targetulong)0x1); } else { tcggenmovtl(cpuPC, btarget); } if (ctx->singlestepenabled) { savecpustate(ctx, 0); genhelper0e0i(raiseexception, EXCPDEBUG); } tcggenexittb(0); break; default: MIPSDEBUG(\"unknown branch\"); break; } } } ", "target": 0}
{"func": "void slirpcleanup(Slirp *slirp) { TAILQREMOVE(&slirpinstances, slirp, entry); unregistersavevm(\"slirp\", slirp); qemufree(slirp->tftpprefix); qemufree(slirp->bootpfilename); qemufree(slirp); } ", "target": 0}
{"func": "void scsireqabort(SCSIRequest *req, int status) { if (!req->enqueued) { return; } scsireqref(req); scsireqdequeue(req); req->iocanceled = true; if (req->ops->cancelio) { req->ops->cancelio(req); } scsireqcomplete(req, status); scsirequnref(req); } ", "target": 0}
{"func": "rdtfreeextradata (PayloadContext *rdt) { int i; for (i = 0; i < MAXSTREAMS; i++) if (rdt->rmst[i]) { ffrmfreermstream(rdt->rmst[i]); avfreep(&rdt->rmst[i]); } if (rdt->rmctx) avcloseinputstream(rdt->rmctx); avfreep(&rdt->mltidata); avfree(rdt); } ", "target": 0}
{"func": "builddsdt(GArray *tabledata, GArray *linker, AcpiPmInfo *pm, AcpiMiscInfo *misc, PcPciInfo *pci, MachineState *machine) { CrsRangeEntry *entry; Aml *dsdt, *sbscope, *scope, *dev, *method, *field, *pkg, *crs; GPtrArray *memranges = gptrarraynewwithfreefunc(crsrangefree); GPtrArray *ioranges = gptrarraynewwithfreefunc(crsrangefree); PCMachineState *pcms = PCMACHINE(machine); uint32t nrmem = machine->ramslots; int rootbuslimit = 0xFF; PCIBus *bus = NULL; int i; dsdt = initamlallocator(); /* Reserve space for header */ acpidatapush(dsdt->buf, sizeof(AcpiTableHeader)); builddbgaml(dsdt); if (misc->ispiix4) { sbscope = amlscope(\"SB\"); dev = amldevice(\"PCI0\"); amlappend(dev, amlnamedecl(\"HID\", amleisaid(\"PNP0A03\"))); amlappend(dev, amlnamedecl(\"ADR\", amlint(0))); amlappend(dev, amlnamedecl(\"UID\", amlint(1))); amlappend(sbscope, dev); amlappend(dsdt, sbscope); buildhpetaml(dsdt); buildpiix4pm(dsdt); buildpiix4isabridge(dsdt); buildisadevicesaml(dsdt); buildpiix4pcihotplug(dsdt); buildpiix4pci0int(dsdt); } else { sbscope = amlscope(\"SB\"); amlappend(sbscope, amloperationregion(\"PCST\", AMLSYSTEMIO, amlint(0xae00), 0x0c)); amlappend(sbscope, amloperationregion(\"PCSB\", AMLSYSTEMIO, amlint(0xae0c), 0x01)); field = amlfield(\"PCSB\", AMLANYACC, AMLNOLOCK, AMLWRITEASZEROS); amlappend(field, amlnamedfield(\"PCIB\", 8)); amlappend(sbscope, field); amlappend(dsdt, sbscope); sbscope = amlscope(\"SB\"); dev = amldevice(\"PCI0\"); amlappend(dev, amlnamedecl(\"HID\", amleisaid(\"PNP0A08\"))); amlappend(dev, amlnamedecl(\"CID\", amleisaid(\"PNP0A03\"))); amlappend(dev, amlnamedecl(\"ADR\", amlint(0))); amlappend(dev, amlnamedecl(\"UID\", amlint(1))); amlappend(dev, amlnamedecl(\"SUPP\", amlint(0))); amlappend(dev, amlnamedecl(\"CTRL\", amlint(0))); amlappend(dev, buildq35oscmethod()); amlappend(sbscope, dev); amlappend(dsdt, sbscope); buildhpetaml(dsdt); buildq35isabridge(dsdt); buildisadevicesaml(dsdt); buildq35pci0int(dsdt); } buildlegacycpuhotplugaml(dsdt, machine, pm->cpuhpiobase); buildmemoryhotplugaml(dsdt, nrmem, pm->memhpiobase, pm->memhpiolen); scope = amlscope(\"GPE\"); { amlappend(scope, amlnamedecl(\"HID\", amlstring(\"ACPI0006\"))); if (misc->ispiix4) { method = amlmethod(\"E01\", 0, AMLNOTSERIALIZED); amlappend(method, amlacquire(amlname(\"\\\\SB.PCI0.BLCK\"), 0xFFFF)); amlappend(method, amlcall0(\"\\\\SB.PCI0.PCNT\")); amlappend(method, amlrelease(amlname(\"\\\\SB.PCI0.BLCK\"))); amlappend(scope, method); } method = amlmethod(\"E03\", 0, AMLNOTSERIALIZED); amlappend(method, amlcall0(MEMORYHOTPLUGHANDLERPATH)); amlappend(scope, method); } amlappend(dsdt, scope); bus = PCMACHINE(machine)->bus; if (bus) { QLISTFOREACH(bus, &bus->child, sibling) { uint8t busnum = pcibusnum(bus); uint8t numanode = pcibusnumanode(bus); /* look only for expander root buses */ if (!pcibusisroot(bus)) { continue; } if (busnum < rootbuslimit) { rootbuslimit = busnum - 1; } scope = amlscope(\"\\\\SB\"); dev = amldevice(\"PC%.02X\", busnum); amlappend(dev, amlnamedecl(\"UID\", amlint(busnum))); amlappend(dev, amlnamedecl(\"HID\", amleisaid(\"PNP0A03\"))); amlappend(dev, amlnamedecl(\"BBN\", amlint(busnum))); if (numanode != NUMANODEUNASSIGNED) { amlappend(dev, amlnamedecl(\"PXM\", amlint(numanode))); } amlappend(dev, buildprt(false)); crs = buildcrs(PCIHOSTBRIDGE(BUS(bus)->parent), ioranges, memranges); amlappend(dev, amlnamedecl(\"CRS\", crs)); amlappend(scope, dev); amlappend(dsdt, scope); } } scope = amlscope(\"\\\\SB.PCI0\"); /* build PCI0.CRS */ crs = amlresourcetemplate(); amlappend(crs, amlwordbusnumber(AMLMINFIXED, AMLMAXFIXED, AMLPOSDECODE, 0x0000, 0x0, rootbuslimit, 0x0000, rootbuslimit + 1)); amlappend(crs, amlio(AMLDECODE16, 0x0CF8, 0x0CF8, 0x01, 0x08)); amlappend(crs, amlwordio(AMLMINFIXED, AMLMAXFIXED, AMLPOSDECODE, AMLENTIRERANGE, 0x0000, 0x0000, 0x0CF7, 0x0000, 0x0CF8)); crsreplacewithfreeranges(ioranges, 0x0D00, 0xFFFF); for (i = 0; i < ioranges->len; i++) { entry = gptrarrayindex(ioranges, i); amlappend(crs, amlwordio(AMLMINFIXED, AMLMAXFIXED, AMLPOSDECODE, AMLENTIRERANGE, 0x0000, entry->base, entry->limit, 0x0000, entry->limit - entry->base + 1)); } amlappend(crs, amldwordmemory(AMLPOSDECODE, AMLMINFIXED, AMLMAXFIXED, AMLCACHEABLE, AMLREADWRITE, 0, 0x000A0000, 0x000BFFFF, 0, 0x00020000)); crsreplacewithfreeranges(memranges, pci->w32.begin, pci->w32.end - 1); for (i = 0; i < memranges->len; i++) { entry = gptrarrayindex(memranges, i); amlappend(crs, amldwordmemory(AMLPOSDECODE, AMLMINFIXED, AMLMAXFIXED, AMLNONCACHEABLE, AMLREADWRITE, 0, entry->base, entry->limit, 0, entry->limit - entry->base + 1)); } if (pci->w64.begin) { amlappend(crs, amlqwordmemory(AMLPOSDECODE, AMLMINFIXED, AMLMAXFIXED, AMLCACHEABLE, AMLREADWRITE, 0, pci->w64.begin, pci->w64.end - 1, 0, pci->w64.end - pci->w64.begin)); } if (misc->tpmversion != TPMVERSIONUNSPEC) { amlappend(crs, amlmemory32fixed(TPMTISADDRBASE, TPMTISADDRSIZE, AMLREADWRITE)); } amlappend(scope, amlnamedecl(\"CRS\", crs)); /* reserve GPE0 block resources */ dev = amldevice(\"GPE0\"); amlappend(dev, amlnamedecl(\"HID\", amlstring(\"PNP0A06\"))); amlappend(dev, amlnamedecl(\"UID\", amlstring(\"GPE0 resources\"))); /* device present, functioning, decoding, not shown in UI */ amlappend(dev, amlnamedecl(\"STA\", amlint(0xB))); crs = amlresourcetemplate(); amlappend(crs, amlio(AMLDECODE16, pm->gpe0blk, pm->gpe0blk, 1, pm->gpe0blklen) ); amlappend(dev, amlnamedecl(\"CRS\", crs)); amlappend(scope, dev); gptrarrayfree(ioranges, true); gptrarrayfree(memranges, true); /* reserve PCIHP resources */ if (pm->pcihpiolen) { dev = amldevice(\"PHPR\"); amlappend(dev, amlnamedecl(\"HID\", amlstring(\"PNP0A06\"))); amlappend(dev, amlnamedecl(\"UID\", amlstring(\"PCI Hotplug resources\"))); /* device present, functioning, decoding, not shown in UI */ amlappend(dev, amlnamedecl(\"STA\", amlint(0xB))); crs = amlresourcetemplate(); amlappend(crs, amlio(AMLDECODE16, pm->pcihpiobase, pm->pcihpiobase, 1, pm->pcihpiolen) ); amlappend(dev, amlnamedecl(\"CRS\", crs)); amlappend(scope, dev); } amlappend(dsdt, scope); /* create S3 / S4 / S5 packages if necessary */ scope = amlscope(\"\\\\\"); if (!pm->s3disabled) { pkg = amlpackage(4); amlappend(pkg, amlint(1)); /* PM1aCNT.SLPTYP */ amlappend(pkg, amlint(1)); /* PM1bCNT.SLPTYP, FIXME: not impl. */ amlappend(pkg, amlint(0)); /* reserved */ amlappend(pkg, amlint(0)); /* reserved */ amlappend(scope, amlnamedecl(\"S3\", pkg)); } if (!pm->s4disabled) { pkg = amlpackage(4); amlappend(pkg, amlint(pm->s4val)); /* PM1aCNT.SLPTYP */ /* PM1bCNT.SLPTYP, FIXME: not impl. */ amlappend(pkg, amlint(pm->s4val)); amlappend(pkg, amlint(0)); /* reserved */ amlappend(pkg, amlint(0)); /* reserved */ amlappend(scope, amlnamedecl(\"S4\", pkg)); } pkg = amlpackage(4); amlappend(pkg, amlint(0)); /* PM1aCNT.SLPTYP */ amlappend(pkg, amlint(0)); /* PM1bCNT.SLPTYP not impl. */ amlappend(pkg, amlint(0)); /* reserved */ amlappend(pkg, amlint(0)); /* reserved */ amlappend(scope, amlnamedecl(\"S5\", pkg)); amlappend(dsdt, scope); /* create fwcfg node, unconditionally */ { /* when using port i/o, the 8-bit data register *always* overlaps * with half of the 16-bit control register. Hence, the total size * of the i/o region used is FWCFGCTLSIZE; when using DMA, the * DMA control register is located at FWCFGDMAIOBASE + 4 */ uint8t iosize = objectpropertygetbool(OBJECT(pcms->fwcfg), \"dmaenabled\", NULL) ? ROUNDUP(FWCFGCTLSIZE, 4) + sizeof(dmaaddrt) : FWCFGCTLSIZE; scope = amlscope(\"\\\\SB.PCI0\"); dev = amldevice(\"FWCF\"); amlappend(dev, amlnamedecl(\"HID\", amlstring(\"QEMU0002\"))); /* device present, functioning, decoding, not shown in UI */ amlappend(dev, amlnamedecl(\"STA\", amlint(0xB))); crs = amlresourcetemplate(); amlappend(crs, amlio(AMLDECODE16, FWCFGIOBASE, FWCFGIOBASE, 0x01, iosize) ); amlappend(dev, amlnamedecl(\"CRS\", crs)); amlappend(scope, dev); amlappend(dsdt, scope); } if (misc->applesmciobase) { scope = amlscope(\"\\\\SB.PCI0.ISA\"); dev = amldevice(\"SMC\"); amlappend(dev, amlnamedecl(\"HID\", amleisaid(\"APP0001\"))); /* device present, functioning, decoding, not shown in UI */ amlappend(dev, amlnamedecl(\"STA\", amlint(0xB))); crs = amlresourcetemplate(); amlappend(crs, amlio(AMLDECODE16, misc->applesmciobase, misc->applesmciobase, 0x01, APPLESMCMAXDATALENGTH) ); amlappend(crs, amlirqnoflags(6)); amlappend(dev, amlnamedecl(\"CRS\", crs)); amlappend(scope, dev); amlappend(dsdt, scope); } if (misc->pvpanicport) { scope = amlscope(\"\\\\SB.PCI0.ISA\"); dev = amldevice(\"PEVT\"); amlappend(dev, amlnamedecl(\"HID\", amlstring(\"QEMU0001\"))); crs = amlresourcetemplate(); amlappend(crs, amlio(AMLDECODE16, misc->pvpanicport, misc->pvpanicport, 1, 1) ); amlappend(dev, amlnamedecl(\"CRS\", crs)); amlappend(dev, amloperationregion(\"PEOR\", AMLSYSTEMIO, amlint(misc->pvpanicport), 1)); field = amlfield(\"PEOR\", AMLBYTEACC, AMLNOLOCK, AMLPRESERVE); amlappend(field, amlnamedfield(\"PEPT\", 8)); amlappend(dev, field); /* device present, functioning, decoding, shown in UI */ amlappend(dev, amlnamedecl(\"STA\", amlint(0xF))); method = amlmethod(\"RDPT\", 0, AMLNOTSERIALIZED); amlappend(method, amlstore(amlname(\"PEPT\"), amllocal(0))); amlappend(method, amlreturn(amllocal(0))); amlappend(dev, method); method = amlmethod(\"WRPT\", 1, AMLNOTSERIALIZED); amlappend(method, amlstore(amlarg(0), amlname(\"PEPT\"))); amlappend(dev, method); amlappend(scope, dev); amlappend(dsdt, scope); } sbscope = amlscope(\"\\\\SB\"); { buildmemorydevices(sbscope, nrmem, pm->memhpiobase, pm->memhpiolen); { Object *pcihost; PCIBus *bus = NULL; pcihost = acpigeti386pcihost(); if (pcihost) { bus = PCIHOSTBRIDGE(pcihost)->bus; } if (bus) { Aml *scope = amlscope(\"PCI0\"); /* Scan all PCI buses. Generate tables to support hotplug. */ buildappendpcibusdevices(scope, bus, pm->pcihpbridgeen); if (misc->tpmversion != TPMVERSIONUNSPEC) { dev = amldevice(\"ISA.TPM\"); amlappend(dev, amlnamedecl(\"HID\", amleisaid(\"PNP0C31\"))); amlappend(dev, amlnamedecl(\"STA\", amlint(0xF))); crs = amlresourcetemplate(); amlappend(crs, amlmemory32fixed(TPMTISADDRBASE, TPMTISADDRSIZE, AMLREADWRITE)); /* FIXME: TPMTISIRQ=5 conflicts with PNP0C0F irqs, Rewrite to take IRQ from TPM device model and fix default IRQ value there to use some unused IRQ */ /* amlappend(crs, amlirqnoflags(TPMTISIRQ)); */ amlappend(dev, amlnamedecl(\"CRS\", crs)); amlappend(scope, dev); } amlappend(sbscope, scope); } } amlappend(dsdt, sbscope); } /* copy AML table into ACPI tables blob and patch header there */ garrayappendvals(tabledata, dsdt->buf->data, dsdt->buf->len); buildheader(linker, tabledata, (void *)(tabledata->data + tabledata->len - dsdt->buf->len), \"DSDT\", dsdt->buf->len, 1, NULL, NULL); freeamlallocator(); } ", "target": 0}
{"func": "static void armcpudointerruptaarch64(CPUState *cs) { ARMCPU *cpu = ARMCPU(cs); CPUARMState *env = &cpu->env; unsigned int newel = env->exception.targetel; targetulong addr = env->cp15.vbarel[newel]; unsigned int newmode = aarch64pstatemode(newel, true); if (armcurrentel(env) < newel) { if (env->aarch64) { addr += 0x400; } else { addr += 0x600; } } else if (pstateread(env) & PSTATESP) { addr += 0x200; } switch (cs->exceptionindex) { case EXCPPREFETCHABORT: case EXCPDATAABORT: env->cp15.farel[newel] = env->exception.vaddress; qemulogmask(CPULOGINT, \"...with FAR 0x%\" PRIx64 \"\\n\", env->cp15.farel[newel]); /* fall through */ case EXCPBKPT: case EXCPUDEF: case EXCPSWI: case EXCPHVC: case EXCPHYPTRAP: case EXCPSMC: env->cp15.esrel[newel] = env->exception.syndrome; break; case EXCPIRQ: case EXCPVIRQ: addr += 0x80; break; case EXCPFIQ: case EXCPVFIQ: addr += 0x100; break; case EXCPSEMIHOST: qemulogmask(CPULOGINT, \"...handling as semihosting call 0x%\" PRIx64 \"\\n\", env->xregs[0]); env->xregs[0] = doarmsemihosting(env); return; default: cpuabort(cs, \"Unhandled exception 0x%x\\n\", cs->exceptionindex); } if (isa64(env)) { env->bankedspsr[aarch64bankedspsrindex(newel)] = pstateread(env); aarch64savesp(env, armcurrentel(env)); env->elrel[newel] = env->pc; } else { env->bankedspsr[aarch64bankedspsrindex(newel)] = cpsrread(env); if (!env->thumb) { env->cp15.esrel[newel] |= 1 << 25; } env->elrel[newel] = env->regs[15]; aarch64sync32to64(env); env->condexecbits = 0; } qemulogmask(CPULOGINT, \"...with ELR 0x%\" PRIx64 \"\\n\", env->elrel[newel]); pstatewrite(env, PSTATEDAIF | newmode); env->aarch64 = 1; aarch64restoresp(env, newel); env->pc = addr; qemulogmask(CPULOGINT, \"...to EL%d PC 0x%\" PRIx64 \" PSTATE 0x%x\\n\", newel, env->pc, pstateread(env)); } ", "target": 0}
{"func": "static bool pcmachinegetnvdimm(Object *obj, Error **errp) { PCMachineState *pcms = PCMACHINE(obj); return pcms->nvdimm; } ", "target": 0}
{"func": "buildheader(GArray *linker, GArray *tabledata, AcpiTableHeader *h, const char *sig, int len, uint8t rev, const char *oemtableid) { memcpy(&h->signature, sig, 4); h->length = cputole32(len); h->revision = rev; memcpy(h->oemid, ACPIBUILDAPPNAME6, 6); if (oemtableid) { strncpy((char *)h->oemtableid, oemtableid, sizeof(h->oemtableid)); } else { memcpy(h->oemtableid, ACPIBUILDAPPNAME4, 4); memcpy(h->oemtableid + 4, sig, 4); } h->oemrevision = cputole32(1); memcpy(h->aslcompilerid, ACPIBUILDAPPNAME4, 4); h->aslcompilerrevision = cputole32(1); h->checksum = 0; /* Checksum to be filled in by Guest linker */ bioslinkerloaderaddchecksum(linker, ACPIBUILDTABLEFILE, tabledata->data, h, len, &h->checksum); } ", "target": 0}
{"func": "static int readquanttable(RangeCoder *c, int16t *quanttable, int scale) { int v; int i = 0; uint8t state[CONTEXTSIZE]; memset(state, 128, sizeof(state)); for (v = 0; i < 128; v++) { unsigned len = getsymbol(c, state, 0) + 1; if (len > 128 - i) return AVERRORINVALIDDATA; while (len--) { quanttable[i] = scale * v; i++; } } for (i = 1; i < 128; i++) quanttable[256 - i] = -quanttable[i]; quanttable[128] = -quanttable[127]; return 2 * v - 1; } ", "target": 0}
{"func": "static int tbunreliable(AVCodecContext *c) { if (c->timebase.den >= 101L * c->timebase.num || c->timebase.den < 5L * c->timebase.num || // c->codectag == AVRL32(\"DIVX\") || // c->codectag == AVRL32(\"XVID\") || c->codecid == AVCODECIDMPEG2VIDEO || c->codecid == AVCODECIDH264) return 1; return 0; } ", "target": 0}
{"func": "int swrinit(struct SwrContext *s){ s->inbufferindex= 0; s->inbuffercount= 0; s->resampleinconstraint= 0; freetemp(&s->postin); freetemp(&s->midbuf); freetemp(&s->preout); freetemp(&s->inbuffer); swriaudioconvertfree(&s-> inconvert); swriaudioconvertfree(&s->outconvert); swriaudioconvertfree(&s->fullconvert); s-> in.planar= avsamplefmtisplanar(s-> insamplefmt); s->out.planar= avsamplefmtisplanar(s->outsamplefmt); s-> insamplefmt= avgetaltsamplefmt(s-> insamplefmt, 0); s->outsamplefmt= avgetaltsamplefmt(s->outsamplefmt, 0); if(s-> insamplefmt >= AVSAMPLEFMTNB){ avlog(s, AVLOGERROR, \"Requested sample format %s is invalid\\n\", avgetsamplefmtname(s->insamplefmt)); return AVERROR(EINVAL); } if(s->outsamplefmt >= AVSAMPLEFMTNB){ avlog(s, AVLOGERROR, \"Requested sample format %s is invalid\\n\", avgetsamplefmtname(s->outsamplefmt)); return AVERROR(EINVAL); } if( s->intsamplefmt != AVSAMPLEFMTS16 &&s->intsamplefmt != AVSAMPLEFMTFLT){ avlog(s, AVLOGERROR, \"Requested sample format %s is not supported internally, only float & S16 is supported\\n\", avgetsamplefmtname(s->intsamplefmt)); return AVERROR(EINVAL); } //FIXME should we allow/support using FLT on material that doesnt need it ? if(s->insamplefmt <= AVSAMPLEFMTS16 || s->intsamplefmt==AVSAMPLEFMTS16){ s->intsamplefmt= AVSAMPLEFMTS16; }else s->intsamplefmt= AVSAMPLEFMTFLT; if (s->outsamplerate!=s->insamplerate || (s->flags & SWRFLAGRESAMPLE)){ s->resample = swriresampleinit(s->resample, s->outsamplerate, s->insamplerate, 16, 10, 0, 0.8); }else swriresamplefree(&s->resample); if(s->intsamplefmt != AVSAMPLEFMTS16 && s->resample){ avlog(s, AVLOGERROR, \"Resampling only supported with internal s16 currently\\n\"); //FIXME return -1; } if(!s->usedchcount) s->usedchcount= s->in.chcount; if(s->usedchcount && s-> inchlayout && s->usedchcount != avgetchannellayoutnbchannels(s-> inchlayout)){ avlog(s, AVLOGWARNING, \"Input channel layout has a different number of channels than the number of used channels, ignoring layout\\n\"); s-> inchlayout= 0; } if(!s-> inchlayout) s-> inchlayout= avgetdefaultchannellayout(s->usedchcount); if(!s->outchlayout) s->outchlayout= avgetdefaultchannellayout(s->out.chcount); s->rematrix= s->outchlayout !=s->inchlayout || s->rematrixvolume!=1.0; #define RSC 1 //FIXME finetune if(!s-> in.chcount) s-> in.chcount= avgetchannellayoutnbchannels(s-> inchlayout); if(!s->usedchcount) s->usedchcount= s->in.chcount; if(!s->out.chcount) s->out.chcount= avgetchannellayoutnbchannels(s->outchlayout); avassert0(s-> in.chcount); avassert0(s->usedchcount); avassert0(s->out.chcount); s->resamplefirst= RSC*s->out.chcount/s->in.chcount - RSC < s->outsamplerate/(float)s-> insamplerate - 1.0; s-> in.bps= avgetbytespersample(s-> insamplefmt); s->intbps= avgetbytespersample(s->intsamplefmt); s->out.bps= avgetbytespersample(s->outsamplefmt); if(!s->resample && !s->rematrix && !s->channelmap){ s->fullconvert = swriaudioconvertalloc(s->outsamplefmt, s-> insamplefmt, s-> in.chcount, NULL, 0); return 0; } s->inconvert = swriaudioconvertalloc(s->intsamplefmt, s-> insamplefmt, s->usedchcount, s->channelmap, 0); s->outconvert= swriaudioconvertalloc(s->outsamplefmt, s->intsamplefmt, s->out.chcount, NULL, 0); s->postin= s->in; s->preout= s->out; s->midbuf= s->in; s->inbuffer= s->in; if(s->channelmap){ s->postin.chcount= s->midbuf.chcount= s->inbuffer.chcount= s->usedchcount; } if(!s->resamplefirst){ s->midbuf.chcount= s->out.chcount; s->inbuffer.chcount = s->out.chcount; } s->inbuffer.bps = s->postin.bps = s->midbuf.bps = s->preout.bps = s->intbps; s->inbuffer.planar = s->postin.planar = s->midbuf.planar = s->preout.planar = 1; if(s->rematrix) return swrirematrixinit(s); return 0; } ", "target": 1}
{"func": "static int svq1decodeinit(AVCodecContext *avctx) { MpegEncContext *s = avctx->privdata; int i; MPVdecodedefaults(s); s->avctx = avctx; s->width = (avctx->width+3)&~3; s->height = (avctx->height+3)&~3; s->codecid= avctx->codec->id; avctx->pixfmt = PIXFMTYUV410P; avctx->hasbframes= 1; // not true, but DP frames and these behave like unidirectional b frames s->flags= avctx->flags; if (MPVcommoninit(s) < 0) return -1; initvlc(&svq1blocktype, 2, 4, &svq1blocktypevlc[0][1], 2, 1, &svq1blocktypevlc[0][0], 2, 1); initvlc(&svq1motioncomponent, 7, 33, &mvtab[0][1], 2, 1, &mvtab[0][0], 2, 1); for (i = 0; i < 6; i++) { initvlc(&svq1intramultistage[i], 3, 8, &svq1intramultistagevlc[i][0][1], 2, 1, &svq1intramultistagevlc[i][0][0], 2, 1); initvlc(&svq1intermultistage[i], 3, 8, &svq1intermultistagevlc[i][0][1], 2, 1, &svq1intermultistagevlc[i][0][0], 2, 1); } initvlc(&svq1intramean, 8, 256, &svq1intrameanvlc[0][1], 4, 2, &svq1intrameanvlc[0][0], 4, 2); initvlc(&svq1intermean, 9, 512, &svq1intermeanvlc[0][1], 4, 2, &svq1intermeanvlc[0][0], 4, 2); return 0; } ", "target": 1}
{"func": "static int rmreadaudiostreaminfo(AVFormatContext *s, AVIOContext *pb, AVStream *st, RMStream *ast, int readall) { char buf[256]; uint32t version; int ret; /* ra type header */ version = aviorb16(pb); /* version */ if (version == 3) { unsigned bytesperminute; int headersize = aviorb16(pb); int64t startpos = aviotell(pb); avioskip(pb, 8); bytesperminute = aviorb16(pb); avioskip(pb, 4); rmreadmetadata(s, 0); if ((startpos + headersize) >= aviotell(pb) + 2) { // fourcc (should always be \"lpcJ\") avior8(pb); getstr8(pb, buf, sizeof(buf)); } // Skip extra header crap (this should never happen) if ((startpos + headersize) > aviotell(pb)) avioskip(pb, headersize + startpos - aviotell(pb)); if (bytesperminute) st->codec->bitrate = 8LL * bytesperminute / 60; st->codec->samplerate = 8000; st->codec->channels = 1; st->codec->channellayout = AVCHLAYOUTMONO; st->codec->codectype = AVMEDIATYPEAUDIO; st->codec->codecid = AVCODECIDRA144; ast->deintid = DEINTIDINT0; } else { int flavor, subpacketh, codedframesize, subpacketsize; int codecdatalength; unsigned bytesperminute; /* old version (4) */ avioskip(pb, 2); /* unused */ aviorb32(pb); /* .ra4 */ aviorb32(pb); /* data size */ aviorb16(pb); /* version2 */ aviorb32(pb); /* header size */ flavor= aviorb16(pb); /* add codec info / flavor */ ast->codedframesize = codedframesize = aviorb32(pb); /* coded frame size */ aviorb32(pb); /* ??? */ bytesperminute = aviorb32(pb); if (version == 4) { if (bytesperminute) st->codec->bitrate = 8LL * bytesperminute / 60; } aviorb32(pb); /* ??? */ ast->subpacketh = subpacketh = aviorb16(pb); /* 1 */ st->codec->blockalign= aviorb16(pb); /* frame size */ ast->subpacketsize = subpacketsize = aviorb16(pb); /* sub packet size */ aviorb16(pb); /* ??? */ if (version == 5) { aviorb16(pb); aviorb16(pb); aviorb16(pb); } st->codec->samplerate = aviorb16(pb); aviorb32(pb); st->codec->channels = aviorb16(pb); if (version == 5) { ast->deintid = aviorl32(pb); avioread(pb, buf, 4); buf[4] = 0; } else { getstr8(pb, buf, sizeof(buf)); /* desc */ ast->deintid = AVRL32(buf); getstr8(pb, buf, sizeof(buf)); /* desc */ } st->codec->codectype = AVMEDIATYPEAUDIO; st->codec->codectag = AVRL32(buf); st->codec->codecid = ffcodecgetid(ffrmcodectags, st->codec->codectag); switch (st->codec->codecid) { case AVCODECIDAC3: st->needparsing = AVSTREAMPARSEFULL; break; case AVCODECIDRA288: st->codec->extradatasize= 0; ast->audioframesize = st->codec->blockalign; st->codec->blockalign = codedframesize; break; case AVCODECIDCOOK: st->needparsing = AVSTREAMPARSEHEADERS; case AVCODECIDATRAC3: case AVCODECIDSIPR: if (readall) { codecdatalength = 0; } else { aviorb16(pb); avior8(pb); if (version == 5) avior8(pb); codecdatalength = aviorb32(pb); if(codecdatalength + FFINPUTBUFFERPADDINGSIZE <= (unsigned)codecdatalength){ avlog(s, AVLOGERROR, \"codecdatalength too large\\n\"); return -1; } } ast->audioframesize = st->codec->blockalign; if (st->codec->codecid == AVCODECIDSIPR) { if (flavor > 3) { avlog(s, AVLOGERROR, \"bad SIPR file flavor %d\\n\", flavor); return -1; } st->codec->blockalign = ffsiprsubpksize[flavor]; } else { if(subpacketsize <= 0){ avlog(s, AVLOGERROR, \"subpacketsize is invalid\\n\"); return -1; } st->codec->blockalign = ast->subpacketsize; } if ((ret = rmreadextradata(pb, st->codec, codecdatalength)) < 0) return ret; break; case AVCODECIDAAC: aviorb16(pb); avior8(pb); if (version == 5) avior8(pb); codecdatalength = aviorb32(pb); if(codecdatalength + FFINPUTBUFFERPADDINGSIZE <= (unsigned)codecdatalength){ avlog(s, AVLOGERROR, \"codecdatalength too large\\n\"); return -1; } if (codecdatalength >= 1) { avior8(pb); if ((ret = rmreadextradata(pb, st->codec, codecdatalength - 1)) < 0) return ret; } break; default: avstrlcpy(st->codec->codecname, buf, sizeof(st->codec->codecname)); } if (ast->deintid == DEINTIDINT4 || ast->deintid == DEINTIDGENR || ast->deintid == DEINTIDSIPR) { if (st->codec->blockalign <= 0 || ast->audioframesize * subpacketh > (unsigned)INTMAX || ast->audioframesize * subpacketh < st->codec->blockalign) return AVERRORINVALIDDATA; if (avnewpacket(&ast->pkt, ast->audioframesize * subpacketh) < 0) return AVERROR(ENOMEM); } switch (ast->deintid) { case DEINTIDINT4: if (ast->codedframesize > ast->audioframesize || subpacketh <= 1 || ast->codedframesize * subpacketh > (2 + (subpacketh & 1)) * ast->audioframesize) return AVERRORINVALIDDATA; break; case DEINTIDGENR: if (ast->subpacketsize <= 0 || ast->subpacketsize > ast->audioframesize) return AVERRORINVALIDDATA; break; case DEINTIDSIPR: case DEINTIDINT0: case DEINTIDVBRS: case DEINTIDVBRF: break; default: avlog(s, AVLOGERROR, \"Unknown interleaver %X\\n\", ast->deintid); return AVERRORINVALIDDATA; } if (readall) { avior8(pb); avior8(pb); avior8(pb); rmreadmetadata(s, 0); } } return 0; } ", "target": 1}
{"func": "int showlicense(void *optctx, const char *opt, const char *arg) { printf( #if CONFIGNONFREE \"This version of %s has nonfree parts compiled in.\\n\" \"Therefore it is not legally redistributable.\\n\", programname #elif CONFIGGPLV3 \"%s is free software; you can redistribute it and/or modify\\n\" \"it under the terms of the GNU General Public License as published by\\n\" \"the Free Software Foundation; either version 3 of the License, or\\n\" \"(at your option) any later version.\\n\" \"\\n\" \"%s is distributed in the hope that it will be useful,\\n\" \"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\" \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n\" \"GNU General Public License for more details.\\n\" \"\\n\" \"You should have received a copy of the GNU General Public License\\n\" \"along with %s. If not, see <http://www.gnu.org/licenses/>.\\n\", programname, programname, programname #elif CONFIGGPL \"%s is free software; you can redistribute it and/or modify\\n\" \"it under the terms of the GNU General Public License as published by\\n\" \"the Free Software Foundation; either version 2 of the License, or\\n\" \"(at your option) any later version.\\n\" \"\\n\" \"%s is distributed in the hope that it will be useful,\\n\" \"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\" \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n\" \"GNU General Public License for more details.\\n\" \"\\n\" \"You should have received a copy of the GNU General Public License\\n\" \"along with %s; if not, write to the Free Software\\n\" \"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\\n\", programname, programname, programname #elif CONFIGLGPLV3 \"%s is free software; you can redistribute it and/or modify\\n\" \"it under the terms of the GNU Lesser General Public License as published by\\n\" \"the Free Software Foundation; either version 3 of the License, or\\n\" \"(at your option) any later version.\\n\" \"\\n\" \"%s is distributed in the hope that it will be useful,\\n\" \"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\" \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\\n\" \"GNU Lesser General Public License for more details.\\n\" \"\\n\" \"You should have received a copy of the GNU Lesser General Public License\\n\" \"along with %s. If not, see <http://www.gnu.org/licenses/>.\\n\", programname, programname, programname #else \"%s is free software; you can redistribute it and/or\\n\" \"modify it under the terms of the GNU Lesser General Public\\n\" \"License as published by the Free Software Foundation; either\\n\" \"version 2.1 of the License, or (at your option) any later version.\\n\" \"\\n\" \"%s is distributed in the hope that it will be useful,\\n\" \"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\" \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\\n\" \"Lesser General Public License for more details.\\n\" \"\\n\" \"You should have received a copy of the GNU Lesser General Public\\n\" \"License along with %s; if not, write to the Free Software\\n\" \"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\\n\", programname, programname, programname #endif ); return 0; } ", "target": 1}
{"func": "int ffrtspmakesetuprequest(AVFormatContext *s, const char *host, int port, int lowertransport, const char *realchallenge) { RTSPState *rt = s->privdata; int rtx = 0, j, i, err, interleave = 0, portoff; RTSPStream *rtspst; RTSPMessageHeader reply1, *reply = &reply1; char cmd[2048]; const char *transpref; if (rt->transport == RTSPTRANSPORTRDT) transpref = \"x-pn-tng\"; else transpref = \"RTP/AVP\"; /* default timeout: 1 minute */ rt->timeout = 60; /* for each stream, make the setup request */ /* XXX: we assume the same server is used for the control of each * RTSP stream */ /* Choose a random starting offset within the first half of the * port range, to allow for a number of ports to try even if the offset * happens to be at the end of the random range. */ portoff = avgetrandomseed() % ((rt->rtpportmax - rt->rtpportmin)/2); /* even random offset */ portoff -= portoff & 0x01; for (j = rt->rtpportmin + portoff, i = 0; i < rt->nbrtspstreams; ++i) { char transport[2048]; /* * WMS serves all UDP data over a single connection, the RTX, which * isn't necessarily the first in the SDP but has to be the first * to be set up, else the second/third SETUP will fail with a 461. */ if (lowertransport == RTSPLOWERTRANSPORTUDP && rt->servertype == RTSPSERVERWMS) { if (i == 0) { /* rtx first */ for (rtx = 0; rtx < rt->nbrtspstreams; rtx++) { int len = strlen(rt->rtspstreams[rtx]->controlurl); if (len >= 4 && !strcmp(rt->rtspstreams[rtx]->controlurl + len - 4, \"/rtx\")) break; } if (rtx == rt->nbrtspstreams) return -1; /* no RTX found */ rtspst = rt->rtspstreams[rtx]; } else rtspst = rt->rtspstreams[i > rtx ? i : i - 1]; } else rtspst = rt->rtspstreams[i]; /* RTP/UDP */ if (lowertransport == RTSPLOWERTRANSPORTUDP) { char buf[256]; if (rt->servertype == RTSPSERVERWMS && i > 1) { port = reply->transports[0].clientportmin; goto haveport; } /* first try in specified port range */ while (j <= rt->rtpportmax) { ffurljoin(buf, sizeof(buf), \"rtp\", NULL, host, -1, \"?localport=%d\", j); /* we will use two ports per rtp stream (rtp and rtcp) */ j += 2; if (!ffurlopen(&rtspst->rtphandle, buf, AVIOFLAGREADWRITE, &s->interruptcallback, NULL)) goto rtpopened; } avlog(s, AVLOGERROR, \"Unable to open an input RTP port\\n\"); err = AVERROR(EIO); goto fail; rtpopened: port = ffrtpgetlocalrtpport(rtspst->rtphandle); haveport: snprintf(transport, sizeof(transport) - 1, \"%s/UDP;\", transpref); if (rt->servertype != RTSPSERVERREAL) avstrlcat(transport, \"unicast;\", sizeof(transport)); avstrlcatf(transport, sizeof(transport), \"clientport=%d\", port); if (rt->transport == RTSPTRANSPORTRTP && !(rt->servertype == RTSPSERVERWMS && i > 0)) avstrlcatf(transport, sizeof(transport), \"-%d\", port + 1); } /* RTP/TCP */ else if (lowertransport == RTSPLOWERTRANSPORTTCP) { /* For WMS streams, the application streams are only used for * UDP. When trying to set it up for TCP streams, the server * will return an error. Therefore, we skip those streams. */ if (rt->servertype == RTSPSERVERWMS && (rtspst->streamindex < 0 || s->streams[rtspst->streamindex]->codec->codectype == AVMEDIATYPEDATA)) continue; snprintf(transport, sizeof(transport) - 1, \"%s/TCP;\", transpref); if (rt->transport != RTSPTRANSPORTRDT) avstrlcat(transport, \"unicast;\", sizeof(transport)); avstrlcatf(transport, sizeof(transport), \"interleaved=%d-%d\", interleave, interleave + 1); interleave += 2; } else if (lowertransport == RTSPLOWERTRANSPORTUDPMULTICAST) { snprintf(transport, sizeof(transport) - 1, \"%s/UDP;multicast\", transpref); } if (s->oformat) { avstrlcat(transport, \";mode=receive\", sizeof(transport)); } else if (rt->servertype == RTSPSERVERREAL || rt->servertype == RTSPSERVERWMS) avstrlcat(transport, \";mode=play\", sizeof(transport)); snprintf(cmd, sizeof(cmd), \"Transport: %s\\r\\n\", transport); if (rt->acceptdynamicrate) avstrlcat(cmd, \"x-Dynamic-Rate: 0\\r\\n\", sizeof(cmd)); if (i == 0 && rt->servertype == RTSPSERVERREAL && CONFIGRTPDEC) { char realres[41], realcsum[9]; ffrdtcalcresponseandchecksum(realres, realcsum, realchallenge); avstrlcatf(cmd, sizeof(cmd), \"If-Match: %s\\r\\n\" \"RealChallenge2: %s, sd=%s\\r\\n\", rt->sessionid, realres, realcsum); } ffrtspsendcmd(s, \"SETUP\", rtspst->controlurl, cmd, reply, NULL); if (reply->statuscode == 461 /* Unsupported protocol */ && i == 0) { err = 1; goto fail; } else if (reply->statuscode != RTSPSTATUSOK || reply->nbtransports != 1) { err = AVERRORINVALIDDATA; goto fail; } /* XXX: same protocol for all streams is required */ if (i > 0) { if (reply->transports[0].lowertransport != rt->lowertransport || reply->transports[0].transport != rt->transport) { err = AVERRORINVALIDDATA; goto fail; } } else { rt->lowertransport = reply->transports[0].lowertransport; rt->transport = reply->transports[0].transport; } /* Fail if the server responded with another lower transport mode * than what we requested. */ if (reply->transports[0].lowertransport != lowertransport) { avlog(s, AVLOGERROR, \"Nonmatching transport in server reply\\n\"); err = AVERRORINVALIDDATA; goto fail; } switch(reply->transports[0].lowertransport) { case RTSPLOWERTRANSPORTTCP: rtspst->interleavedmin = reply->transports[0].interleavedmin; rtspst->interleavedmax = reply->transports[0].interleavedmax; break; case RTSPLOWERTRANSPORTUDP: { char url[1024], options[30] = \"\"; if (rt->rtspflags & RTSPFLAGFILTERSRC) avstrlcpy(options, \"?connect=1\", sizeof(options)); /* Use source address if specified */ if (reply->transports[0].source[0]) { ffurljoin(url, sizeof(url), \"rtp\", NULL, reply->transports[0].source, reply->transports[0].serverportmin, \"%s\", options); } else { ffurljoin(url, sizeof(url), \"rtp\", NULL, host, reply->transports[0].serverportmin, \"%s\", options); } if (!(rt->servertype == RTSPSERVERWMS && i > 1) && ffrtpsetremoteurl(rtspst->rtphandle, url) < 0) { err = AVERRORINVALIDDATA; goto fail; } /* Try to initialize the connection state in a * potential NAT router by sending dummy packets. * RTP/RTCP dummy packets are used for RDT, too. */ if (!(rt->servertype == RTSPSERVERWMS && i > 1) && s->iformat && CONFIGRTPDEC) ffrtpsendpunchpackets(rtspst->rtphandle); break; } case RTSPLOWERTRANSPORTUDPMULTICAST: { char url[1024], namebuf[50], optbuf[20] = \"\"; struct sockaddrstorage addr; int port, ttl; if (reply->transports[0].destination.ssfamily) { addr = reply->transports[0].destination; port = reply->transports[0].portmin; ttl = reply->transports[0].ttl; } else { addr = rtspst->sdpip; port = rtspst->sdpport; ttl = rtspst->sdpttl; } if (ttl > 0) snprintf(optbuf, sizeof(optbuf), \"?ttl=%d\", ttl); getnameinfo((struct sockaddr*) &addr, sizeof(addr), namebuf, sizeof(namebuf), NULL, 0, NINUMERICHOST); ffurljoin(url, sizeof(url), \"rtp\", NULL, namebuf, port, \"%s\", optbuf); if (ffurlopen(&rtspst->rtphandle, url, AVIOFLAGREADWRITE, &s->interruptcallback, NULL) < 0) { err = AVERRORINVALIDDATA; goto fail; } break; } } if ((err = rtspopentransportctx(s, rtspst))) goto fail; } if (reply->timeout > 0) rt->timeout = reply->timeout; if (rt->servertype == RTSPSERVERREAL) rt->needsubscription = 1; return 0; fail: ffrtspundosetup(s); return err; } ", "target": 1}
{"func": "static int parsefmtp(AVFormatContext *s, AVStream *stream, PayloadContext *data, const char *attr, const char *value) { AVCodecParameters *par = stream->codecpar; int res, i; if (!strcmp(attr, \"config\")) { res = parsefmtpconfig(par, value); if (res < 0) return res; } if (par->codecid == AVCODECIDAAC) { /* Looking for a known attribute */ for (i = 0; attrnames[i].str; ++i) { if (!avstrcasecmp(attr, attrnames[i].str)) { if (attrnames[i].type == ATTRNAMETYPEINT) { *(int *)((char *)data+ attrnames[i].offset) = atoi(value); } else if (attrnames[i].type == ATTRNAMETYPESTR) *(char **)((char *)data+ attrnames[i].offset) = avstrdup(value); } } } return 0; } ", "target": 0}
{"func": "static int ffserversetintparam(int *dest, const char *value, int factor, int min, int max, FFServerConfig *config, const char *errormsg, ...) { int tmp; char *tailp; if (!value || !value[0]) goto error; errno = 0; tmp = strtol(value, &tailp, 0); if (tmp < min || tmp > max) goto error; if (factor) { if (FFABS(tmp) > INTMAX / FFABS(factor)) goto error; tmp *= factor; } if (tailp[0] || errno) goto error; if (dest) *dest = tmp; return 0; error: if (config) { valist vl; vastart(vl, errormsg); vreportconfigerror(config->filename, config->linenum, AVLOGERROR, &config->errors, errormsg, vl); vaend(vl); } return AVERROR(EINVAL); } ", "target": 0}
{"func": "static int64t findtag(AVIOContext *pb, uint32t tag1) { unsigned int tag; int64t size; for (;;) { if (urlfeof(pb)) return AVERROREOF; size = nexttag(pb, &tag); if (tag == tag1) break; wavseektag(pb, size, SEEKCUR); } return size; } ", "target": 0}
{"func": "avcold void fffloatdspinitx86(AVFloatDSPContext *fdsp) { int cpuflags = avgetcpuflags(); #if HAVE6REGS && HAVEINLINEASM if (INLINEAMD3DNOWEXT(cpuflags)) { fdsp->vectorfmulwindow = vectorfmulwindow3dnowext; } if (INLINESSE(cpuflags)) { fdsp->vectorfmulwindow = vectorfmulwindowsse; } #endif if (EXTERNALSSE(cpuflags)) { fdsp->vectorfmul = ffvectorfmulsse; fdsp->vectorfmacscalar = ffvectorfmacscalarsse; fdsp->vectorfmulscalar = ffvectorfmulscalarsse; fdsp->vectorfmuladd = ffvectorfmuladdsse; fdsp->vectorfmulreverse = ffvectorfmulreversesse; fdsp->scalarproductfloat = ffscalarproductfloatsse; fdsp->butterfliesfloat = ffbutterfliesfloatsse; } if (EXTERNALSSE2(cpuflags)) { fdsp->vectordmulscalar = ffvectordmulscalarsse2; } if (EXTERNALAVX(cpuflags)) { fdsp->vectorfmul = ffvectorfmulavx; fdsp->vectorfmacscalar = ffvectorfmacscalaravx; fdsp->vectordmulscalar = ffvectordmulscalaravx; fdsp->vectorfmuladd = ffvectorfmuladdavx; fdsp->vectorfmulreverse = ffvectorfmulreverseavx; } } ", "target": 0}
{"func": "static uint64t omap2inthread(void *opaque, targetphysaddrt addr, unsigned size) { struct omapintrhandlers *s = (struct omapintrhandlers *) opaque; int offset = addr; int bankno, lineno; struct omapintrhandlerbanks *bank = NULL; if ((offset & 0xf80) == 0x80) { bankno = (offset & 0x60) >> 5; if (bankno < s->nbanks) { offset &= ~0x60; bank = &s->bank[bankno]; } } switch (offset) { case 0x00:\t/* INTCREVISION */ return s->revision; case 0x10:\t/* INTCSYSCONFIG */ return (s->autoidle >> 2) & 1; case 0x14:\t/* INTCSYSSTATUS */ return 1;\t\t\t\t\t\t/* RESETDONE */ case 0x40:\t/* INTCSIRIRQ */ return s->sirintr[0]; case 0x44:\t/* INTCSIRFIQ */ return s->sirintr[1]; case 0x48:\t/* INTCCONTROL */ return (!s->mask) << 2;\t\t\t\t\t/* GLOBALMASK */ case 0x4c:\t/* INTCPROTECTION */ case 0x50:\t/* INTCIDLE */ return s->autoidle & 3; /* Per-bank registers */ case 0x80:\t/* INTCITR */ return bank->inputs; case 0x84:\t/* INTCMIR */ return bank->mask; case 0x88:\t/* INTCMIRCLEAR */ case 0x8c:\t/* INTCMIRSET */ case 0x90:\t/* INTCISRSET */ return bank->swi; case 0x94:\t/* INTCISRCLEAR */ case 0x98:\t/* INTCPENDINGIRQ */ return bank->irqs & ~bank->mask & ~bank->fiq; case 0x9c:\t/* INTCPENDINGFIQ */ return bank->irqs & ~bank->mask & bank->fiq; /* Per-line registers */ case 0x100 ... 0x300:\t/* INTCILR */ bankno = (offset - 0x100) >> 7; if (bankno > s->nbanks) break; bank = &s->bank[bankno]; lineno = (offset & 0x7f) >> 2; return (bank->priority[lineno] << 2) | ((bank->fiq >> lineno) & 1); } }", "target": 1}
{"func": "static inline void getlimits(MpegEncContext *s, int *range, int *xmin, int *ymin, int *xmax, int *ymax, int fcode) { *range = 8 * (1 << (fcode - 1)); /* XXX: temporary kludge to avoid overflow for msmpeg4 */ if (s->outformat == FMTH263 && !s->h263msmpeg4) \t*range *= 2; if (s->unrestrictedmv) { *xmin = -16; *ymin = -16; if (s->h263plus) *range *= 2; if(s->avctx->codec->id!=CODECIDMPEG4){ *xmax = s->mbwidth*16; *ymax = s->mbheight*16; }else { *xmax = s->width; *ymax = s->height; } } else { *xmin = 0; *ymin = 0; *xmax = s->mbwidth*16 - 16; *ymax = s->mbheight*16 - 16; } } ", "target": 0}
{"func": "static int devicetryinit(AVFormatContext *ctx, enum AVPixelFormat pixfmt, int *width, int *height, uint32t *desiredformat, enum AVCodecID *codecid) { int ret, i; *desiredformat = avprivfmtff2v4l(pixfmt, ctx->videocodecid); if (*desiredformat) { ret = deviceinit(ctx, width, height, *desiredformat); if (ret < 0) { *desiredformat = 0; if (ret != AVERROR(EINVAL)) return ret; } } if (!*desiredformat) { for (i = 0; avprivfmtconversiontable[i].codecid != AVCODECIDNONE; i++) { if (ctx->videocodecid == AVCODECIDNONE || avprivfmtconversiontable[i].codecid == ctx->videocodecid) { avlog(ctx, AVLOGDEBUG, \"Trying to set codec:%s pixfmt:%s\\n\", avcodecgetname(avprivfmtconversiontable[i].codecid), (char *)avxifnull(avgetpixfmtname(avprivfmtconversiontable[i].fffmt), \"none\")); *desiredformat = avprivfmtconversiontable[i].v4l2fmt; ret = deviceinit(ctx, width, height, *desiredformat); if (ret >= 0) break; else if (ret != AVERROR(EINVAL)) return ret; *desiredformat = 0; } } if (*desiredformat == 0) { avlog(ctx, AVLOGERROR, \"Cannot find a proper format for \" \"codec '%s' (id %d), pixel format '%s' (id %d)\\n\", avcodecgetname(ctx->videocodecid), ctx->videocodecid, (char *)avxifnull(avgetpixfmtname(pixfmt), \"none\"), pixfmt); ret = AVERROR(EINVAL); } } *codecid = avprivfmtv4l2codec(*desiredformat); avassert0(*codecid != AVCODECIDNONE); return ret; } ", "target": 0}
{"func": "static void lsisoftreset(LSIState *s) { lsirequest *p; DPRINTF(\"Reset\\n\"); s->carry = 0; s->msgaction = 0; s->msglen = 0; s->waiting = 0; s->dsa = 0; s->dnad = 0; s->dbc = 0; s->temp = 0; memset(s->scratch, 0, sizeof(s->scratch)); s->istat0 = 0; s->istat1 = 0; s->dcmd = 0x40; s->dstat = LSIDSTATDFE; s->dien = 0; s->sist0 = 0; s->sist1 = 0; s->sien0 = 0; s->sien1 = 0; s->mbox0 = 0; s->mbox1 = 0; s->dfifo = 0; s->ctest2 = LSICTEST2DACK; s->ctest3 = 0; s->ctest4 = 0; s->ctest5 = 0; s->ccntl0 = 0; s->ccntl1 = 0; s->dsp = 0; s->dsps = 0; s->dmode = 0; s->dcntl = 0; s->scntl0 = 0xc0; s->scntl1 = 0; s->scntl2 = 0; s->scntl3 = 0; s->sstat0 = 0; s->sstat1 = 0; s->scid = 7; s->sxfer = 0; s->socl = 0; s->sdid = 0; s->ssid = 0; s->stest1 = 0; s->stest2 = 0; s->stest3 = 0; s->sidl = 0; s->stime0 = 0; s->respid0 = 0x80; s->respid1 = 0; s->mmrs = 0; s->mmws = 0; s->sfs = 0; s->drs = 0; s->sbms = 0; s->dbms = 0; s->dnad64 = 0; s->pmjad1 = 0; s->pmjad2 = 0; s->rbc = 0; s->ua = 0; s->ia = 0; s->sbc = 0; s->csbc = 0; s->sbr = 0; while (!QTAILQEMPTY(&s->queue)) { p = QTAILQFIRST(&s->queue); QTAILQREMOVE(&s->queue, p, next); gfree(p); } if (s->current) { gfree(s->current); s->current = NULL; } } ", "target": 1}
{"func": "static void mclmspredict(WmallDecodeCtx *s, int icoef, int *pred) { int ich, i; int order = s->mclmsorder; int numchannels = s->numchannels; for (ich = 0; ich < numchannels; ich++) { pred[ich] = 0; if (!s->ischannelcoded[ich]) continue; for (i = 0; i < order * numchannels; i++) pred[ich] += s->mclmsprevvalues[i + s->mclmsrecent] * s->mclmscoeffs[i + order * numchannels * ich]; for (i = 0; i < ich; i++) pred[ich] += s->channelresidues[i][icoef] * s->mclmscoeffscur[i + numchannels * ich]; pred[ich] += 1 << s->mclmsscaling - 1; pred[ich] >>= s->mclmsscaling; s->channelresidues[ich][icoef] += pred[ich]; } } ", "target": 1}
{"func": "static void vncdpycopy(DisplayState *ds, int srcx, int srcy, int dstx, int dsty, int w, int h) { VncDisplay *vd = ds->opaque; VncState *vs = vd->clients; while (vs != NULL) { if (vnchasfeature(vs, VNCFEATURECOPYRECT)) vnccopy(vs, srcx, srcy, dstx, dsty, w, h); else /* TODO */ vncupdate(vs, dstx, dsty, w, h); vs = vs->next; } } ", "target": 1}
{"func": "static int emulatedexitfn(CCIDCardState *base) { EmulatedState *card = DOUPCAST(EmulatedState, base, base); VEvent *vevent = veventnew(VEVENTLAST, NULL, NULL); veventqueuevevent(vevent); /* stop vevent thread */ qemumutexlock(&card->apduthreadquitmutex); card->quitapduthread = 1; /* stop handleapdu thread */ qemucondsignal(&card->handleapducond); qemucondwait(&card->apduthreadquitcond, &card->apduthreadquitmutex); /* handleapdu thread stopped, can destroy all of it's mutexes */ qemuconddestroy(&card->handleapducond); qemuconddestroy(&card->apduthreadquitcond); qemumutexdestroy(&card->apduthreadquitmutex); qemumutexdestroy(&card->handleapdumutex); qemumutexdestroy(&card->vreadermutex); qemumutexdestroy(&card->eventlistmutex); return 0; } ", "target": 1}
{"func": "static inline int getchromaqp(H264Context *h, int qscale){ return h->pps.chromaqptable[qscale & 0xff]; } ", "target": 1}
{"func": "int AACRENAME(ffpsreaddata)(AVCodecContext *avctx, GetBitContext *gbhost, PSContext *ps, int bitsleft) { int e; int bitcountstart = getbitscount(gbhost); int header; int bitsconsumed; GetBitContext gbc = *gbhost, *gb = &gbc; header = getbits1(gb); if (header) { //enablepsheader ps->enableiid = getbits1(gb); if (ps->enableiid) { int iidmode = getbits(gb, 3); if (iidmode > 5) { avlog(avctx, AVLOGERROR, \"iidmode %d is reserved.\\n\", iidmode); goto err; } ps->nriidpar = nriidiccpartab[iidmode]; ps->iidquant = iidmode > 2; ps->nripdopdpar = nriidopdpartab[iidmode]; } ps->enableicc = getbits1(gb); if (ps->enableicc) { ps->iccmode = getbits(gb, 3); if (ps->iccmode > 5) { avlog(avctx, AVLOGERROR, \"iccmode %d is reserved.\\n\", ps->iccmode); goto err; } ps->nriccpar = nriidiccpartab[ps->iccmode]; } ps->enableext = getbits1(gb); } ps->frameclass = getbits1(gb); ps->numenvold = ps->numenv; ps->numenv = numenvtab[ps->frameclass][getbits(gb, 2)]; ps->borderposition[0] = -1; if (ps->frameclass) { for (e = 1; e <= ps->numenv; e++) ps->borderposition[e] = getbits(gb, 5); } else for (e = 1; e <= ps->numenv; e++) ps->borderposition[e] = (e * numQMFSlots >> fflog2tab[ps->numenv]) - 1; if (ps->enableiid) { for (e = 0; e < ps->numenv; e++) { int dt = getbits1(gb); if (readiiddata(avctx, gb, ps, ps->iidpar, huffiid[2*dt+ps->iidquant], e, dt)) goto err; } } else memset(ps->iidpar, 0, sizeof(ps->iidpar)); if (ps->enableicc) for (e = 0; e < ps->numenv; e++) { int dt = getbits1(gb); if (readiccdata(avctx, gb, ps, ps->iccpar, dt ? hufficcdt : hufficcdf, e, dt)) goto err; } else memset(ps->iccpar, 0, sizeof(ps->iccpar)); if (ps->enableext) { int cnt = getbits(gb, 4); if (cnt == 15) { cnt += getbits(gb, 8); } cnt *= 8; while (cnt > 7) { int psextensionid = getbits(gb, 2); cnt -= 2 + psreadextensiondata(gb, ps, psextensionid); } if (cnt < 0) { avlog(avctx, AVLOGERROR, \"ps extension overflow %d\\n\", cnt); goto err; } skipbits(gb, cnt); } ps->enableipdopd &= !PSBASELINE; //Fix up envelopes if (!ps->numenv || ps->borderposition[ps->numenv] < numQMFSlots - 1) { //Create a fake envelope int source = ps->numenv ? ps->numenv - 1 : ps->numenvold - 1; int b; if (source >= 0 && source != ps->numenv) { if (ps->enableiid) { memcpy(ps->iidpar+ps->numenv, ps->iidpar+source, sizeof(ps->iidpar[0])); } if (ps->enableicc) { memcpy(ps->iccpar+ps->numenv, ps->iccpar+source, sizeof(ps->iccpar[0])); } if (ps->enableipdopd) { memcpy(ps->ipdpar+ps->numenv, ps->ipdpar+source, sizeof(ps->ipdpar[0])); memcpy(ps->opdpar+ps->numenv, ps->opdpar+source, sizeof(ps->opdpar[0])); } } if (ps->enableiid){ for (b = 0; b < ps->nriidpar; b++) { if (FFABS(ps->iidpar[ps->numenv][b]) > 7 + 8 * ps->iidquant) { avlog(avctx, AVLOGERROR, \"iidpar invalid\\n\"); goto err; } } } if (ps->enableicc){ for (b = 0; b < ps->nriidpar; b++) { if (ps->iccpar[ps->numenv][b] > 7U) { avlog(avctx, AVLOGERROR, \"iccpar invalid\\n\"); goto err; } } } ps->numenv++; ps->borderposition[ps->numenv] = numQMFSlots - 1; } ps->is34bandsold = ps->is34bands; if (!PSBASELINE && (ps->enableiid || ps->enableicc)) ps->is34bands = (ps->enableiid && ps->nriidpar == 34) || (ps->enableicc && ps->nriccpar == 34); //Baseline if (!ps->enableipdopd) { memset(ps->ipdpar, 0, sizeof(ps->ipdpar)); memset(ps->opdpar, 0, sizeof(ps->opdpar)); } if (header) ps->start = 1; bitsconsumed = getbitscount(gb) - bitcountstart; if (bitsconsumed <= bitsleft) { skipbitslong(gbhost, bitsconsumed); return bitsconsumed; } avlog(avctx, AVLOGERROR, \"Expected to read %d PS bits actually read %d.\\n\", bitsleft, bitsconsumed); err: ps->start = 0; skipbitslong(gbhost, bitsleft); memset(ps->iidpar, 0, sizeof(ps->iidpar)); memset(ps->iccpar, 0, sizeof(ps->iccpar)); memset(ps->ipdpar, 0, sizeof(ps->ipdpar)); memset(ps->opdpar, 0, sizeof(ps->opdpar)); return bitsleft; } ", "target": 1}
{"func": "static int readgab2sub(AVFormatContext *s, AVStream *st, AVPacket *pkt) { if (pkt->size >= 7 && pkt->size < INTMAX - AVPROBEPADDINGSIZE && !strcmp(pkt->data, \"GAB2\") && AVRL16(pkt->data + 5) == 2) { uint8t desc[256]; int score = AVPROBESCOREEXTENSION, ret; AVIStream *ast = st->privdata; AVInputFormat *subdemuxer; AVRational timebase; int size; AVIOContext *pb = avioalloccontext(pkt->data + 7, pkt->size - 7, 0, NULL, NULL, NULL, NULL); AVProbeData pd; unsigned int desclen = aviorl32(pb); if (desclen > pb->bufend - pb->bufptr) goto error; ret = aviogetstr16le(pb, desclen, desc, sizeof(desc)); avioskip(pb, desclen - ret); if (*desc) avdictset(&st->metadata, \"title\", desc, 0); aviorl16(pb); /* flags? */ aviorl32(pb); /* data size */ size = pb->bufend - pb->bufptr; pd = (AVProbeData) { .buf = avmallocz(size + AVPROBEPADDINGSIZE), .bufsize = size }; if (!pd.buf) goto error; memcpy(pd.buf, pb->bufptr, size); subdemuxer = avprobeinputformat2(&pd, 1, &score); avfreep(&pd.buf); if (!subdemuxer) goto error; if (!(ast->subctx = avformatalloccontext())) goto error; ast->subctx->pb = pb; avassert0(!ast->subctx->codecwhitelist && !ast->subctx->formatwhitelist); ast->subctx-> codecwhitelist = avstrdup(s->codecwhitelist); ast->subctx->formatwhitelist = avstrdup(s->formatwhitelist); if (!avformatopeninput(&ast->subctx, \"\", subdemuxer, NULL)) { ffreadpacket(ast->subctx, &ast->subpkt); *st->codec = *ast->subctx->streams[0]->codec; ast->subctx->streams[0]->codec->extradata = NULL; timebase = ast->subctx->streams[0]->timebase; avprivsetptsinfo(st, 64, timebase.num, timebase.den); } ast->subbuffer = pkt->data; memset(pkt, 0, sizeof(*pkt)); return 1; error: avfreep(&pb); } return 0; } ", "target": 1}
{"func": "void qvirtiopcideviceenable(QVirtioPCIDevice *d) { qpcideviceenable(d->pdev); d->addr = qpciiomap(d->pdev, 0, NULL); gassert(d->addr != NULL); } ", "target": 1}
{"func": "static int movierequestframe(AVFilterLink *outlink) { AVFilterBufferRef *outpicref; MovieContext *movie = outlink->src->priv; int ret; if (movie->isdone) return AVERROREOF; if ((ret = moviegetframe(outlink)) < 0) return ret; outpicref = avfilterrefbuffer(movie->picref, ~0); ffstartframe(outlink, outpicref); ffdrawslice(outlink, 0, outlink->h, 1); ffendframe(outlink); avfilterunrefbuffer(movie->picref); movie->picref = NULL; return 0; } ", "target": 0}
{"func": "static void processclient(AVIOContext *client, const char *inuri) { AVIOContext *input = NULL; uint8t buf[1024]; int ret, n, replycode; uint8t *resource = NULL; while ((ret = aviohandshake(client)) > 0) { avoptget(client, \"resource\", AVOPTSEARCHCHILDREN, &resource); // check for strlen(resource) is necessary, because avoptget() // may return empty string. if (resource && strlen(resource)) break; } if (ret < 0) goto end; avlog(client, AVLOGTRACE, \"resource=%p\\n\", resource); if (resource && resource[0] == '/' && !strcmp((resource + 1), inuri)) { replycode = 200; } else { replycode = AVERRORHTTPNOTFOUND; } if ((ret = avoptsetint(client, \"replycode\", replycode, AVOPTSEARCHCHILDREN)) < 0) { avlog(client, AVLOGERROR, \"Failed to set replycode: %s.\\n\", averr2str(ret)); goto end; } avlog(client, AVLOGTRACE, \"Set reply code to %d\\n\", replycode); while ((ret = aviohandshake(client)) > 0); if (ret < 0) goto end; fprintf(stderr, \"Handshake performed.\\n\"); if (replycode != 200) goto end; fprintf(stderr, \"Opening input file.\\n\"); if ((ret = avioopen2(&input, inuri, AVIOFLAGREAD, NULL, NULL)) < 0) { avlog(input, AVLOGERROR, \"Failed to open input: %s: %s.\\n\", inuri, averr2str(ret)); goto end; } for(;;) { n = avioread(input, buf, sizeof(buf)); if (n < 0) { if (n == AVERROREOF) break; avlog(input, AVLOGERROR, \"Error reading from input: %s.\\n\", averr2str(n)); break; } aviowrite(client, buf, n); avioflush(client); } end: fprintf(stderr, \"Flushing client\\n\"); avioflush(client); fprintf(stderr, \"Closing client\\n\"); avioclose(client); fprintf(stderr, \"Closing input\\n\"); avioclose(input); }", "target": 1}
{"func": "static inline void preddirectmotion(H264Context * const h, int *mbtype){ MpegEncContext * const s = &h->s; const int mbxy = s->mbx + s->mby*s->mbstride; const int b8xy = 2*s->mbx + 2*s->mby*h->b8stride; const int b4xy = 4*s->mbx + 4*s->mby*h->bstride; const int mbtypecol = h->reflist[1][0].mbtype[mbxy]; const int16t (*l1mv0)[2] = (const int16t (*)[2]) &h->reflist[1][0].motionval[0][b4xy]; const int16t (*l1mv1)[2] = (const int16t (*)[2]) &h->reflist[1][0].motionval[1][b4xy]; const int8t *l1ref0 = &h->reflist[1][0].refindex[0][b8xy]; const int8t *l1ref1 = &h->reflist[1][0].refindex[1][b8xy]; const int isb8x8 = IS8X8(*mbtype); int submbtype; int i8, i4; if(IS8X8(mbtypecol) && !h->sps.direct8x8inferenceflag){ /* FIXME save sub mb types from previous frames (or derive from MVs) * so we know exactly what block size to use */ submbtype = MBTYPE8x8|MBTYPEP0L0|MBTYPEP0L1|MBTYPEDIRECT2; /* BSUB4x4 */ *mbtype = MBTYPE8x8|MBTYPEL0L1; }else if(!isb8x8 && (IS16X16(mbtypecol) || ISINTRA(mbtypecol))){ submbtype = MBTYPE16x16|MBTYPEP0L0|MBTYPEP0L1|MBTYPEDIRECT2; /* BSUB8x8 */ *mbtype = MBTYPE16x16|MBTYPEP0L0|MBTYPEP0L1|MBTYPEDIRECT2; /* B16x16 */ }else{ submbtype = MBTYPE16x16|MBTYPEP0L0|MBTYPEP0L1|MBTYPEDIRECT2; /* BSUB8x8 */ *mbtype = MBTYPE8x8|MBTYPEL0L1; } if(!isb8x8) *mbtype |= MBTYPEDIRECT2; tprintf(\"mbtype = %08x, submbtype = %08x, isb8x8 = %d, mbtypecol = %08x\\n\", *mbtype, submbtype, isb8x8, mbtypecol); if(h->directspatialmvpred){ int ref[2]; int mv[2][2]; int list; /* ref = min(neighbors) */ for(list=0; list<2; list++){ int refa = h->refcache[list][scan8[0] - 1]; int refb = h->refcache[list][scan8[0] - 8]; int refc = h->refcache[list][scan8[0] - 8 + 4]; if(refc == -2) refc = h->refcache[list][scan8[0] - 8 - 1]; ref[list] = refa; if(ref[list] < 0 || (refb < ref[list] && refb >= 0)) ref[list] = refb; if(ref[list] < 0 || (refc < ref[list] && refc >= 0)) ref[list] = refc; if(ref[list] < 0) ref[list] = -1; } if(ref[0] < 0 && ref[1] < 0){ ref[0] = ref[1] = 0; mv[0][0] = mv[0][1] = mv[1][0] = mv[1][1] = 0; }else{ for(list=0; list<2; list++){ if(ref[list] >= 0) predmotion(h, 0, 4, list, ref[list], &mv[list][0], &mv[list][1]); else mv[list][0] = mv[list][1] = 0; } } if(ref[1] < 0){ *mbtype &= ~MBTYPEP0L1; submbtype &= ~MBTYPEP0L1; }else if(ref[0] < 0){ *mbtype &= ~MBTYPEP0L0; submbtype &= ~MBTYPEP0L0; } if(IS16X16(*mbtype)){ fillrectangle(&h->refcache[0][scan8[0]], 4, 4, 8, ref[0], 1); fillrectangle(&h->refcache[1][scan8[0]], 4, 4, 8, ref[1], 1); if(!ISINTRA(mbtypecol) && ( (l1ref0[0] == 0 && ABS(l1mv0[0][0]) <= 1 && ABS(l1mv0[0][1]) <= 1) || (l1ref0[0] < 0 && l1ref1[0] == 0 && ABS(l1mv1[0][0]) <= 1 && ABS(l1mv1[0][1]) <= 1 && (h->x264build>33 || !h->x264build)))){ if(ref[0] > 0) fillrectangle(&h->mvcache[0][scan8[0]], 4, 4, 8, pack16to32(mv[0][0],mv[0][1]), 4); else fillrectangle(&h->mvcache[0][scan8[0]], 4, 4, 8, 0, 4); if(ref[1] > 0) fillrectangle(&h->mvcache[1][scan8[0]], 4, 4, 8, pack16to32(mv[1][0],mv[1][1]), 4); else fillrectangle(&h->mvcache[1][scan8[0]], 4, 4, 8, 0, 4); }else{ fillrectangle(&h->mvcache[0][scan8[0]], 4, 4, 8, pack16to32(mv[0][0],mv[0][1]), 4); fillrectangle(&h->mvcache[1][scan8[0]], 4, 4, 8, pack16to32(mv[1][0],mv[1][1]), 4); } }else{ for(i8=0; i8<4; i8++){ const int x8 = i8&1; const int y8 = i8>>1; if(isb8x8 && !ISDIRECT(h->submbtype[i8])) continue; h->submbtype[i8] = submbtype; fillrectangle(&h->mvcache[0][scan8[i8*4]], 2, 2, 8, pack16to32(mv[0][0],mv[0][1]), 4); fillrectangle(&h->mvcache[1][scan8[i8*4]], 2, 2, 8, pack16to32(mv[1][0],mv[1][1]), 4); fillrectangle(&h->refcache[0][scan8[i8*4]], 2, 2, 8, ref[0], 1); fillrectangle(&h->refcache[1][scan8[i8*4]], 2, 2, 8, ref[1], 1); /* colzeroflag */ if(!ISINTRA(mbtypecol) && ( l1ref0[x8 + y8*h->b8stride] == 0 || (l1ref0[x8 + y8*h->b8stride] < 0 && l1ref1[x8 + y8*h->b8stride] == 0 && (h->x264build>33 || !h->x264build)))){ const int16t (*l1mv)[2]= l1ref0[x8 + y8*h->b8stride] == 0 ? l1mv0 : l1mv1; for(i4=0; i4<4; i4++){ const int16t *mvcol = l1mv[x8*2 + (i4&1) + (y8*2 + (i4>>1))*h->bstride]; if(ABS(mvcol[0]) <= 1 && ABS(mvcol[1]) <= 1){ if(ref[0] == 0) *(uint32t*)h->mvcache[0][scan8[i8*4+i4]] = 0; if(ref[1] == 0) *(uint32t*)h->mvcache[1][scan8[i8*4+i4]] = 0; } } } } } }else{ /* direct temporal mv pred */ if(IS16X16(*mbtype)){ fillrectangle(&h->refcache[1][scan8[0]], 4, 4, 8, 0, 1); if(ISINTRA(mbtypecol)){ fillrectangle(&h->refcache[0][scan8[0]], 4, 4, 8, 0, 1); fillrectangle(&h-> mvcache[0][scan8[0]], 4, 4, 8, 0, 4); fillrectangle(&h-> mvcache[1][scan8[0]], 4, 4, 8, 0, 4); }else{ const int ref0 = l1ref0[0] >= 0 ? h->mapcoltolist0[0][l1ref0[0]] : h->mapcoltolist0[1][l1ref1[0]]; const int distscalefactor = h->distscalefactor[ref0]; const int16t *mvcol = l1ref0[0] >= 0 ? l1mv0[0] : l1mv1[0]; int mvl0[2]; mvl0[0] = (distscalefactor * mvcol[0] + 128) >> 8; mvl0[1] = (distscalefactor * mvcol[1] + 128) >> 8; fillrectangle(&h->refcache[0][scan8[0]], 4, 4, 8, ref0, 1); fillrectangle(&h-> mvcache[0][scan8[0]], 4, 4, 8, pack16to32(mvl0[0],mvl0[1]), 4); fillrectangle(&h-> mvcache[1][scan8[0]], 4, 4, 8, pack16to32(mvl0[0]-mvcol[0],mvl0[1]-mvcol[1]), 4); } }else{ for(i8=0; i8<4; i8++){ const int x8 = i8&1; const int y8 = i8>>1; int ref0, distscalefactor; const int16t (*l1mv)[2]= l1mv0; if(isb8x8 && !ISDIRECT(h->submbtype[i8])) continue; h->submbtype[i8] = submbtype; if(ISINTRA(mbtypecol)){ fillrectangle(&h->refcache[0][scan8[i8*4]], 2, 2, 8, 0, 1); fillrectangle(&h->refcache[1][scan8[i8*4]], 2, 2, 8, 0, 1); fillrectangle(&h-> mvcache[0][scan8[i8*4]], 2, 2, 8, 0, 4); fillrectangle(&h-> mvcache[1][scan8[i8*4]], 2, 2, 8, 0, 4); continue; } ref0 = l1ref0[x8 + y8*h->b8stride]; if(ref0 >= 0) ref0 = h->mapcoltolist0[0][ref0]; else{ ref0 = h->mapcoltolist0[1][l1ref1[x8 + y8*h->b8stride]]; l1mv= l1mv1; } distscalefactor = h->distscalefactor[ref0]; fillrectangle(&h->refcache[0][scan8[i8*4]], 2, 2, 8, ref0, 1); fillrectangle(&h->refcache[1][scan8[i8*4]], 2, 2, 8, 0, 1); for(i4=0; i4<4; i4++){ const int16t *mvcol = l1mv[x8*2 + (i4&1) + (y8*2 + (i4>>1))*h->bstride]; int16t *mvl0 = h->mvcache[0][scan8[i8*4+i4]]; mvl0[0] = (distscalefactor * mvcol[0] + 128) >> 8; mvl0[1] = (distscalefactor * mvcol[1] + 128) >> 8; *(uint32t*)h->mvcache[1][scan8[i8*4+i4]] = pack16to32(mvl0[0]-mvcol[0],mvl0[1]-mvcol[1]); } } } } } ", "target": 1}
{"func": "static int bdrvqedopen(BlockDriverState *bs, QDict *options, int flags, Error **errp) { BDRVQEDState *s = bs->opaque; QEDHeader leheader; int64t filesize; int ret; s->bs = bs; QSIMPLEQINIT(&s->allocatingwritereqs); ret = bdrvpread(bs->file, 0, &leheader, sizeof(leheader)); if (ret < 0) { return ret; } qedheaderletocpu(&leheader, &s->header); if (s->header.magic != QEDMAGIC) { errorsetg(errp, \"Image not in QED format\"); return -EINVAL; } if (s->header.features & ~QEDFEATUREMASK) { /* image uses unsupported feature bits */ char buf[64]; snprintf(buf, sizeof(buf), \"%\" PRIx64, s->header.features & ~QEDFEATUREMASK); errorset(errp, QERRUNKNOWNBLOCKFORMATFEATURE, bdrvgetdevicename(bs), \"QED\", buf); return -ENOTSUP; } if (!qedisclustersizevalid(s->header.clustersize)) { return -EINVAL; } /* Round down file size to the last cluster */ filesize = bdrvgetlength(bs->file); if (filesize < 0) { return filesize; } s->filesize = qedstartofcluster(s, filesize); if (!qedistablesizevalid(s->header.tablesize)) { return -EINVAL; } if (!qedisimagesizevalid(s->header.imagesize, s->header.clustersize, s->header.tablesize)) { return -EINVAL; } if (!qedchecktableoffset(s, s->header.l1tableoffset)) { return -EINVAL; } s->tablenelems = (s->header.clustersize * s->header.tablesize) / sizeof(uint64t); s->l2shift = ffs(s->header.clustersize) - 1; s->l2mask = s->tablenelems - 1; s->l1shift = s->l2shift + ffs(s->tablenelems) - 1; /* Header size calculation must not overflow uint32t */ if (s->header.headersize > UINT32MAX / s->header.clustersize) { return -EINVAL; } if ((s->header.features & QEDFBACKINGFILE)) { if ((uint64t)s->header.backingfilenameoffset + s->header.backingfilenamesize > s->header.clustersize * s->header.headersize) { return -EINVAL; } ret = qedreadstring(bs->file, s->header.backingfilenameoffset, s->header.backingfilenamesize, bs->backingfile, sizeof(bs->backingfile)); if (ret < 0) { return ret; } if (s->header.features & QEDFBACKINGFORMATNOPROBE) { pstrcpy(bs->backingformat, sizeof(bs->backingformat), \"raw\"); } } /* Reset unknown autoclear feature bits. This is a backwards * compatibility mechanism that allows images to be opened by older * programs, which \"knock out\" unknown feature bits. When an image is * opened by a newer program again it can detect that the autoclear * feature is no longer valid. */ if ((s->header.autoclearfeatures & ~QEDAUTOCLEARFEATUREMASK) != 0 && !bdrvisreadonly(bs->file) && !(flags & BDRVOINCOMING)) { s->header.autoclearfeatures &= QEDAUTOCLEARFEATUREMASK; ret = qedwriteheadersync(s); if (ret) { return ret; } /* From here on only known autoclear feature bits are valid */ bdrvflush(bs->file); } s->l1table = qedalloctable(s); qedinitl2cache(&s->l2cache); ret = qedreadl1tablesync(s); if (ret) { goto out; } /* If image was not closed cleanly, check consistency */ if (!(flags & BDRVOCHECK) && (s->header.features & QEDFNEEDCHECK)) { /* Read-only images cannot be fixed. There is no risk of corruption * since write operations are not possible. Therefore, allow * potentially inconsistent images to be opened read-only. This can * aid data recovery from an otherwise inconsistent image. */ if (!bdrvisreadonly(bs->file) && !(flags & BDRVOINCOMING)) { BdrvCheckResult result = {0}; ret = qedcheck(s, &result, true); if (ret) { goto out; } } } bdrvqedattachaiocontext(bs, bdrvgetaiocontext(bs)); out: if (ret) { qedfreel2cache(&s->l2cache); qemuvfree(s->l1table); } return ret; } ", "target": 0}
{"func": "void ffputh264qpel8mc31msa(uint8t *dst, const uint8t *src, ptrdifft stride) { avclumahvqrt8wmsa(src - 2, src - (stride * 2) + sizeof(uint8t), stride, dst, stride, 8); } ", "target": 0}
{"func": "static CharDriverState *qemuchropenpipe(const char *id, ChardevBackend *backend, ChardevReturn *ret, Error **errp) { ChardevHostdev *opts = backend->u.pipe; const char *filename = opts->device; CharDriverState *chr; WinCharState *s; chr = qemuchralloc(); s = gnew0(WinCharState, 1); chr->opaque = s; chr->chrwrite = winchrwrite; chr->chrclose = winchrclose; if (winchrpipeinit(chr, filename, errp) < 0) { gfree(s); gfree(chr); return NULL; } return chr; } ", "target": 0}
{"func": "uint32t HELPER(clz)(uint32t x) { int count; for (count = 32; x; count--) x >>= 1; return count; } ", "target": 0}
{"func": "static void kvmgetfallbacksmmuinfo(PowerPCCPU *cpu, struct kvmppcsmmuinfo *info) { CPUPPCState *env = &cpu->env; CPUState *cs = CPU(cpu); memset(info, 0, sizeof(*info)); /* We don't have the new KVMPPCGETSMMUINFO ioctl, so * need to \"guess\" what the supported page sizes are. * * For that to work we make a few assumptions: * * - If KVMCAPPPCGETPVINFO is supported we are running \"PR\" * KVM which only supports 4K and 16M pages, but supports them * regardless of the backing store characteritics. We also don't * support 1T segments. * * This is safe as if HV KVM ever supports that capability or PR * KVM grows supports for more page/segment sizes, those versions * will have implemented KVMCAPPPCGETSMMUINFO and thus we * will not hit this fallback * * - Else we are running HV KVM. This means we only support page * sizes that fit in the backing store. Additionally we only * advertize 64K pages if the processor is ARCH 2.06 and we assume * P7 encodings for the SLB and hash table. Here too, we assume * support for any newer processor will mean a kernel that * implements KVMCAPPPCGETSMMUINFO and thus doesn't hit * this fallback. */ if (kvmcheckextension(cs->kvmstate, KVMCAPPPCGETPVINFO)) { /* No flags */ info->flags = 0; info->slbsize = 64; /* Standard 4k base page size segment */ info->sps[0].pageshift = 12; info->sps[0].slbenc = 0; info->sps[0].enc[0].pageshift = 12; info->sps[0].enc[0].pteenc = 0; /* Standard 16M large page size segment */ info->sps[1].pageshift = 24; info->sps[1].slbenc = SLBVSIDL; info->sps[1].enc[0].pageshift = 24; info->sps[1].enc[0].pteenc = 0; } else { int i = 0; /* HV KVM has backing store size restrictions */ info->flags = KVMPPCPAGESIZESREAL; if (env->mmumodel & POWERPCMMU1TSEG) { info->flags |= KVMPPC1TSEGMENTS; } if (env->mmumodel == POWERPCMMU206 || env->mmumodel == POWERPCMMU207) { info->slbsize = 32; } else { info->slbsize = 64; } /* Standard 4k base page size segment */ info->sps[i].pageshift = 12; info->sps[i].slbenc = 0; info->sps[i].enc[0].pageshift = 12; info->sps[i].enc[0].pteenc = 0; i++; /* 64K on MMU 2.06 and later */ if (env->mmumodel == POWERPCMMU206 || env->mmumodel == POWERPCMMU207) { info->sps[i].pageshift = 16; info->sps[i].slbenc = 0x110; info->sps[i].enc[0].pageshift = 16; info->sps[i].enc[0].pteenc = 1; i++; } /* Standard 16M large page size segment */ info->sps[i].pageshift = 24; info->sps[i].slbenc = SLBVSIDL; info->sps[i].enc[0].pageshift = 24; info->sps[i].enc[0].pteenc = 0; } } ", "target": 0}
{"func": "void helperiretprotected(int shift) { helperretprotected(shift, 1, 0); } ", "target": 0}
{"func": "void qemubhschedule(QEMUBH *bh) { AioContext *ctx; ctx = bh->ctx; bh->idle = 0; /* The memory barrier implicit in atomicxchg makes sure that: * 1. idle & any writes needed by the callback are done before the * locations are read in the aiobhpoll. * 2. ctx is loaded before scheduled is set and the callback has a chance * to execute. */ if (atomicxchg(&bh->scheduled, 1) == 0) { aionotify(ctx); } } ", "target": 0}
{"func": "static SpiceTimer *timeradd(SpiceTimerFunc func, void *opaque) { SpiceTimer *timer; timer = qemumallocz(sizeof(*timer)); timer->timer = qemunewtimer(rtclock, func, opaque); QTAILQINSERTTAIL(&timers, timer, next); return timer; } ", "target": 0}
{"func": "static int kvmvirtiopcivqvectoruse(VirtIOPCIProxy *proxy, unsigned int queueno, unsigned int vector, MSIMessage msg) { VirtQueue *vq = virtiogetqueue(proxy->vdev, queueno); EventNotifier *n = virtioqueuegetguestnotifier(vq); VirtIOIRQFD *irqfd = &proxy->vectorirqfd[vector]; int ret; if (irqfd->users == 0) { ret = kvmirqchipaddmsiroute(kvmstate, msg); if (ret < 0) { return ret; } irqfd->virq = ret; } irqfd->users++; ret = kvmirqchipaddirqnotifier(kvmstate, n, irqfd->virq); if (ret < 0) { if (--irqfd->users == 0) { kvmirqchipreleasevirq(kvmstate, irqfd->virq); } return ret; } virtioqueuesetguestnotifierfdhandler(vq, true, true); return 0; } ", "target": 0}
{"func": "static int outputpacket(InputStream *ist, OutputStream *osttable, int nbostreams, const AVPacket *pkt) { int ret = 0, i; int gotoutput; int64t pktpts = AVNOPTSVALUE; AVPacket avpkt; if (ist->nextdts == AVNOPTSVALUE) ist->nextdts = ist->dts; if (ist->nextpts == AVNOPTSVALUE) ist->nextpts = ist->pts; if (pkt == NULL) { /* EOF handling */ avinitpacket(&avpkt); avpkt.data = NULL; avpkt.size = 0; goto handleeof; } else { avpkt = *pkt; } if (pkt->dts != AVNOPTSVALUE) { ist->nextdts = ist->dts = avrescaleq(pkt->dts, ist->st->timebase, AVTIMEBASEQ); if (ist->st->codec->codectype != AVMEDIATYPEVIDEO || !ist->decodingneeded) ist->nextpts = ist->pts = avrescaleq(pkt->dts, ist->st->timebase, AVTIMEBASEQ); } if(pkt->pts != AVNOPTSVALUE) pktpts = avrescaleq(pkt->pts, ist->st->timebase, AVTIMEBASEQ); // while we have more to decode or while the decoder did output something on EOF while (ist->decodingneeded && (avpkt.size > 0 || (!pkt && gotoutput))) { int duration; handleeof: ist->pts = ist->nextpts; ist->dts = ist->nextdts; if (avpkt.size && avpkt.size != pkt->size) { avlog(NULL, ist->showedmultipacketwarning ? AVLOGVERBOSE : AVLOGWARNING, \"Multiple frames in a packet from stream %d\\n\", pkt->streamindex); ist->showedmultipacketwarning = 1; } switch (ist->st->codec->codectype) { case AVMEDIATYPEAUDIO: ret = transcodeaudio (ist, &avpkt, &gotoutput); break; case AVMEDIATYPEVIDEO: ret = transcodevideo (ist, &avpkt, &gotoutput, &pktpts); if (avpkt.duration) { duration = avrescaleq(avpkt.duration, ist->st->timebase, AVTIMEBASEQ); } else if(ist->st->codec->timebase.num != 0) { int ticks= ist->st->parser ? ist->st->parser->repeatpict+1 : ist->st->codec->ticksperframe; duration = ((int64t)AVTIMEBASE * ist->st->codec->timebase.num * ticks) / ist->st->codec->timebase.den; } else duration = 0; if(ist->dts != AVNOPTSVALUE && duration) { ist->nextdts += duration; }else ist->nextdts = AVNOPTSVALUE; if (gotoutput) ist->nextpts += duration; //FIXME the duration is not correct in some cases break; case AVMEDIATYPESUBTITLE: ret = transcodesubtitles(ist, &avpkt, &gotoutput); break; default: return -1; } if (ret < 0) return ret; avpkt.dts= avpkt.pts= AVNOPTSVALUE; // touch data and size only if not EOF if (pkt) { if(ist->st->codec->codectype != AVMEDIATYPEAUDIO) ret = avpkt.size; avpkt.data += ret; avpkt.size -= ret; } if (!gotoutput) { continue; } } /* handle stream copy */ if (!ist->decodingneeded) { rateemusleep(ist); ist->dts = ist->nextdts; switch (ist->st->codec->codectype) { case AVMEDIATYPEAUDIO: ist->nextdts += ((int64t)AVTIMEBASE * ist->st->codec->framesize) / ist->st->codec->samplerate; break; case AVMEDIATYPEVIDEO: if (pkt->duration) { ist->nextdts += avrescaleq(pkt->duration, ist->st->timebase, AVTIMEBASEQ); } else if(ist->st->codec->timebase.num != 0) { int ticks= ist->st->parser ? ist->st->parser->repeatpict + 1 : ist->st->codec->ticksperframe; ist->nextdts += ((int64t)AVTIMEBASE * ist->st->codec->timebase.num * ticks) / ist->st->codec->timebase.den; } break; } ist->pts = ist->dts; ist->nextpts = ist->nextdts; } for (i = 0; pkt && i < nbostreams; i++) { OutputStream *ost = &osttable[i]; if (!checkoutputconstraints(ist, ost) || ost->encodingneeded) continue; dostreamcopy(ist, ost, pkt); } return 0; } ", "target": 1}
{"func": "static void searchforquantizersanmr(AVCodecContext *avctx, AACEncContext *s, SingleChannelElement *sce, const float lambda) { int q, w, w2, g, start = 0; int i, j; int idx; TrellisPath paths[TRELLISSTAGES][TRELLISSTATES]; int bandaddr[TRELLISSTAGES]; int minq; float mincost; float q0f = FLTMAX, q1f = 0.0f, qnrgf = 0.0f; int q0, q1, qcnt = 0; for (i = 0; i < 1024; i++) { float t = fabsf(sce->coeffs[i]); if (t > 0.0f) { q0f = FFMIN(q0f, t); q1f = FFMAX(q1f, t); qnrgf += t*t; qcnt++; } } if (!qcnt) { memset(sce->sfidx, 0, sizeof(sce->sfidx)); memset(sce->zeroes, 1, sizeof(sce->zeroes)); return; } //minimum scalefactor index is when minimum nonzero coefficient after quantizing is not clipped q0 = avclipuint8(log2(q0f)*4 - 69 + SCALEONEPOS - SCALEDIV512); //maximum scalefactor index is when maximum coefficient after quantizing is still not zero q1 = avclipuint8(log2(q1f)*4 + 6 + SCALEONEPOS - SCALEDIV512); //avlog(NULL, AVLOGERROR, \"q0 %d, q1 %d\\n\", q0, q1); if (q1 - q0 > 60) { int q0low = q0; int q1high = q1; //minimum scalefactor index is when maximum nonzero coefficient after quantizing is not clipped int qnrg = avclipuint8(log2(sqrt(qnrgf/qcnt))*4 - 31 + SCALEONEPOS - SCALEDIV512); q1 = qnrg + 30; q0 = qnrg - 30; //avlog(NULL, AVLOGERROR, \"q0 %d, q1 %d\\n\", q0, q1); if (q0 < q0low) { q1 += q0low - q0; q0 = q0low; } else if (q1 > q1high) { q0 -= q1 - q1high; q1 = q1high; } } //avlog(NULL, AVLOGERROR, \"q0 %d, q1 %d\\n\", q0, q1); for (i = 0; i < TRELLISSTATES; i++) { paths[0][i].cost = 0.0f; paths[0][i].prev = -1; } for (j = 1; j < TRELLISSTAGES; j++) { for (i = 0; i < TRELLISSTATES; i++) { paths[j][i].cost = INFINITY; paths[j][i].prev = -2; } } idx = 1; abspow34v(s->scoefs, sce->coeffs, 1024); for (w = 0; w < sce->ics.numwindows; w += sce->ics.grouplen[w]) { start = w*128; for (g = 0; g < sce->ics.numswb; g++) { const float *coefs = sce->coeffs + start; float qmin, qmax; int nz = 0; bandaddr[idx] = w * 16 + g; qmin = INTMAX; qmax = 0.0f; for (w2 = 0; w2 < sce->ics.grouplen[w]; w2++) { FFPsyBand *band = &s->psy.psybands[s->curchannel*PSYMAXBANDS+(w+w2)*16+g]; if (band->energy <= band->threshold || band->threshold == 0.0f) { sce->zeroes[(w+w2)*16+g] = 1; continue; } sce->zeroes[(w+w2)*16+g] = 0; nz = 1; for (i = 0; i < sce->ics.swbsizes[g]; i++) { float t = fabsf(coefs[w2*128+i]); if (t > 0.0f) qmin = FFMIN(qmin, t); qmax = FFMAX(qmax, t); } } if (nz) { int minscale, maxscale; float minrd = INFINITY; //minimum scalefactor index is when minimum nonzero coefficient after quantizing is not clipped minscale = avclipuint8(log2(qmin)*4 - 69 + SCALEONEPOS - SCALEDIV512); //maximum scalefactor index is when maximum coefficient after quantizing is still not zero maxscale = avclipuint8(log2(qmax)*4 + 6 + SCALEONEPOS - SCALEDIV512); minscale = avclip(minscale - q0, 0, TRELLISSTATES - 1); maxscale = avclip(maxscale - q0, 0, TRELLISSTATES); for (q = minscale; q < maxscale; q++) { float dist = 0; int cb = findminbook(sce->sfidx[w*16+g], sce->ics.grouplen[w], sce->ics.swbsizes[g], s->scoefs+start); for (w2 = 0; w2 < sce->ics.grouplen[w]; w2++) { FFPsyBand *band = &s->psy.psybands[s->curchannel*PSYMAXBANDS+(w+w2)*16+g]; dist += quantizebandcost(s, coefs + w2*128, s->scoefs + start + w2*128, sce->ics.swbsizes[g], q + q0, cb, lambda / band->threshold, INFINITY, NULL); } minrd = FFMIN(minrd, dist); for (i = 0; i < q1 - q0; i++) { float cost; if (isinf(paths[idx - 1][i].cost)) continue; cost = paths[idx - 1][i].cost + dist + ffaacscalefactorbits[q - i + SCALEDIFFZERO]; if (cost < paths[idx][q].cost) { paths[idx][q].cost = cost; paths[idx][q].prev = i; } } } } else { for (q = 0; q < q1 - q0; q++) { if (!isinf(paths[idx - 1][q].cost)) { paths[idx][q].cost = paths[idx - 1][q].cost + 1; paths[idx][q].prev = q; continue; } for (i = 0; i < q1 - q0; i++) { float cost; if (isinf(paths[idx - 1][i].cost)) continue; cost = paths[idx - 1][i].cost + ffaacscalefactorbits[q - i + SCALEDIFFZERO]; if (cost < paths[idx][q].cost) { paths[idx][q].cost = cost; paths[idx][q].prev = i; } } } } sce->zeroes[w*16+g] = !nz; start += sce->ics.swbsizes[g]; idx++; } } idx--; mincost = paths[idx][0].cost; minq = 0; for (i = 1; i < TRELLISSTATES; i++) { if (paths[idx][i].cost < mincost) { mincost = paths[idx][i].cost; minq = i; } } while (idx) { sce->sfidx[bandaddr[idx]] = minq + q0; minq = paths[idx][minq].prev; idx--; } //set the same quantizers inside window groups for (w = 0; w < sce->ics.numwindows; w += sce->ics.grouplen[w]) for (g = 0; g < sce->ics.numswb; g++) for (w2 = 1; w2 < sce->ics.grouplen[w]; w2++) sce->sfidx[(w+w2)*16+g] = sce->sfidx[w*16+g]; } ", "target": 0}
{"func": "static int createfixeddisk(int fd, uint8t *buf, int64t totalsize) { int ret = -EIO; /* Add footer to total size */ totalsize += 512; if (ftruncate(fd, totalsize) != 0) { ret = -errno; goto fail; } if (lseek(fd, -512, SEEKEND) < 0) { goto fail; } if (write(fd, buf, HEADERSIZE) != HEADERSIZE) { goto fail; } ret = 0; fail: return ret; } ", "target": 0}
{"func": "static int localreaddirr(FsContext *ctx, V9fsFidOpenState *fs, struct dirent *entry, struct dirent **result) { return readdirr(fs->dir, entry, result); } ", "target": 0}
{"func": "static int zrlesendframebufferupdate(VncState *vs, int x, int y, int w, int h) { bool be = !!(vs->clientds.flags & QEMUBIGENDIANFLAG); sizet bytes; int zywrlelevel; if (vs->zrle.type == VNCENCODINGZYWRLE) { if (!vs->vd->lossy || vs->tight.quality < 0 || vs->tight.quality == 9) { zywrlelevel = 0; vs->zrle.type = VNCENCODINGZRLE; } else if (vs->tight.quality < 3) { zywrlelevel = 3; } else if (vs->tight.quality < 6) { zywrlelevel = 2; } else { zywrlelevel = 1; } } else { zywrlelevel = 0; } vnczrlestart(vs); switch(vs->clientds.pf.bytesperpixel) { case 1: zrleencode8ne(vs, x, y, w, h, zywrlelevel); break; case 2: if (vs->clientds.pf.gmax > 0x1F) { if (be) { zrleencode16be(vs, x, y, w, h, zywrlelevel); } else { zrleencode16le(vs, x, y, w, h, zywrlelevel); } } else { if (be) { zrleencode15be(vs, x, y, w, h, zywrlelevel); } else { zrleencode15le(vs, x, y, w, h, zywrlelevel); } } break; case 4: { bool fitsinls3bytes; bool fitsinms3bytes; fitsinls3bytes = ((vs->clientds.pf.rmax << vs->clientds.pf.rshift) < (1 << 24) && (vs->clientds.pf.gmax << vs->clientds.pf.gshift) < (1 << 24) && (vs->clientds.pf.bmax << vs->clientds.pf.bshift) < (1 << 24)); fitsinms3bytes = (vs->clientds.pf.rshift > 7 && vs->clientds.pf.gshift > 7 && vs->clientds.pf.bshift > 7); if ((fitsinls3bytes && !be) || (fitsinms3bytes && be)) { if (be) { zrleencode24abe(vs, x, y, w, h, zywrlelevel); } else { zrleencode24ale(vs, x, y, w, h, zywrlelevel); } } else if ((fitsinls3bytes && be) || (fitsinms3bytes && !be)) { if (be) { zrleencode24bbe(vs, x, y, w, h, zywrlelevel); } else { zrleencode24ble(vs, x, y, w, h, zywrlelevel); } } else { if (be) { zrleencode32be(vs, x, y, w, h, zywrlelevel); } else { zrleencode32le(vs, x, y, w, h, zywrlelevel); } } } break; } vnczrlestop(vs); bytes = zrlecompressdata(vs, ZDEFAULTCOMPRESSION); vncframebufferupdate(vs, x, y, w, h, vs->zrle.type); vncwriteu32(vs, bytes); vncwrite(vs, vs->zrle.zlib.buffer, vs->zrle.zlib.offset); return 1; } ", "target": 0}
{"func": "static uint64t mmioidestatusread(void *opaque, targetphysaddrt addr, unsigned size) { MMIOState *s= opaque; return idestatusread(&s->bus, 0); } ", "target": 0}
{"func": "void tlbflushpage(CPUState *env, targetulong addr) { int i; #if defined(DEBUGTLB) printf(\"tlbflushpage: \" TARGETFMTlx \"\\n\", addr); #endif /* must reset current TB so that interrupts cannot modify the links while we are modifying them */ env->currenttb = NULL; addr &= TARGETPAGEMASK; i = (addr >> TARGETPAGEBITS) & (CPUTLBSIZE - 1); tlbflushentry(&env->tlbtable[0][i], addr); tlbflushentry(&env->tlbtable[1][i], addr); #if (NBMMUMODES >= 3) tlbflushentry(&env->tlbtable[2][i], addr); #if (NBMMUMODES == 4) tlbflushentry(&env->tlbtable[3][i], addr); #endif #endif tlbflushjmpcache(env, addr); #ifdef USEKQEMU if (env->kqemuenabled) { kqemuflushpage(env, addr); } #endif } ", "target": 0}
{"func": "void ffslicethreadfree(AVCodecContext *avctx) { ThreadContext *c = avctx->threadopaque; int i; pthreadmutexlock(&c->currentjoblock); c->done = 1; pthreadcondbroadcast(&c->currentjobcond); pthreadmutexunlock(&c->currentjoblock); for (i=0; i<avctx->threadcount; i++) pthreadjoin(c->workers[i], NULL); pthreadmutexdestroy(&c->currentjoblock); pthreadconddestroy(&c->currentjobcond); pthreadconddestroy(&c->lastjobcond); avfree(c->workers); avfreep(&avctx->threadopaque); } ", "target": 0}
{"func": "static int assdecodeframe(AVCodecContext *avctx, void *data, int *gotsubptr, AVPacket *avpkt) { const char *ptr = avpkt->data; int len, size = avpkt->size; while (size > 0) { ASSDialog *dialog = ffasssplitdialog(avctx->privdata, ptr, 0, NULL); int duration = dialog->end - dialog->start; len = ffassaddrect(data, ptr, 0, duration, 1); if (len < 0) return len; ptr += len; size -= len; } *gotsubptr = avpkt->size > 0; return avpkt->size; } ", "target": 1}
{"func": "static int initblkmigration(QEMUFile *f) { BlockDriverState *bs; BlkMigDevState *bmds; int64t sectors; BdrvNextIterator it; int i, numbs = 0; struct { BlkMigDevState *bmds; BlockDriverState *bs; } *bmdsbs; Error *localerr = NULL; int ret; blockmigstate.submitted = 0; blockmigstate.readdone = 0; blockmigstate.transferred = 0; blockmigstate.totalsectorsum = 0; blockmigstate.prevprogress = -1; blockmigstate.bulkcompleted = 0; blockmigstate.zeroblocks = migratezeroblocks(); for (bs = bdrvfirst(&it); bs; bs = bdrvnext(&it)) { numbs++; } bmdsbs = gmalloc0(numbs * sizeof(*bmdsbs)); for (i = 0, bs = bdrvfirst(&it); bs; bs = bdrvnext(&it), i++) { if (bdrvisreadonly(bs)) { continue; } sectors = bdrvnbsectors(bs); if (sectors <= 0) { ret = sectors; goto out; } bmds = gnew0(BlkMigDevState, 1); bmds->blk = blknew(BLKPERMCONSISTENTREAD, BLKPERMALL); bmds->blkname = gstrdup(bdrvgetdevicename(bs)); bmds->bulkcompleted = 0; bmds->totalsectors = sectors; bmds->completedsectors = 0; bmds->sharedbase = migrateuseblockincremental(); assert(i < numbs); bmdsbs[i].bmds = bmds; bmdsbs[i].bs = bs; blockmigstate.totalsectorsum += sectors; if (bmds->sharedbase) { DPRINTF(\"Start migration for %s with shared base image\\n\", bdrvgetdevicename(bs)); } else { DPRINTF(\"Start full migration for %s\\n\", bdrvgetdevicename(bs)); } QSIMPLEQINSERTTAIL(&blockmigstate.bmdslist, bmds, entry); } /* Can only insert new BDSes now because doing so while iterating block * devices may end up in a deadlock (iterating the new BDSes, too). */ for (i = 0; i < numbs; i++) { BlkMigDevState *bmds = bmdsbs[i].bmds; BlockDriverState *bs = bmdsbs[i].bs; if (bmds) { ret = blkinsertbs(bmds->blk, bs, &localerr); if (ret < 0) { errorreporterr(localerr); goto out; } allocaiobitmap(bmds); errorsetg(&bmds->blocker, \"block device is in use by migration\"); bdrvopblockall(bs, bmds->blocker); } } ret = 0; out: gfree(bmdsbs); return ret; }", "target": 1}
{"func": "static int finddirtyheight(VncState *vs, int y, int lastx, int x) { int h; for (h = 1; h < (vs->serverds.height - y); h++) { int tmpx; if (!vncgetbit(vs->dirtyrow[y + h], lastx)) break; for (tmpx = lastx; tmpx < x; tmpx++) vncclearbit(vs->dirtyrow[y + h], tmpx); } return h; } ", "target": 1}
{"func": "static void testdispatchcmdfailure(void) { QDict *req = qdictnew(); QObject *resp; qdictputobj(req, \"execute\", QOBJECT(qstringfromstr(\"userdefcmd2\"))); resp = qmpdispatch(QOBJECT(req)); assert(resp != NULL); assert(qdicthaskey(qobjecttoqdict(resp), \"error\")); qobjectdecref(resp); QDECREF(req); /* check that with extra arguments it throws an error */ req = qdictnew(); qdictput(args, \"a\", qintfromint(66)); qdictput(req, \"arguments\", args); qdictputobj(req, \"execute\", QOBJECT(qstringfromstr(\"userdefcmd\"))); resp = qmpdispatch(QOBJECT(req)); assert(resp != NULL); assert(qdicthaskey(qobjecttoqdict(resp), \"error\")); qobjectdecref(resp); QDECREF(req); }", "target": 1}
{"func": "static void addindexentry(AVStream *st, int64t pos, int64t timestamp, int flags) { AVIndexEntry *entries, *ie; entries = avfastrealloc(st->indexentries, &st->indexentriesallocatedsize, (st->nbindexentries + 1) * sizeof(AVIndexEntry)); if (entries) { st->indexentries = entries; ie = &entries[st->nbindexentries++]; ie->pos = pos; ie->timestamp = timestamp; ie->flags = flags; } } ", "target": 0}
{"func": "static int rv10decodeframe(AVCodecContext *avctx, void *data, int *gotframe, AVPacket *avpkt) { const uint8t *buf = avpkt->data; int bufsize = avpkt->size; MpegEncContext *s = avctx->privdata; AVFrame *pict = data; int i, ret; int slicecount; const uint8t *sliceshdr = NULL; avdlog(avctx, \"*****frame %d size=%d\\n\", avctx->framenumber, bufsize); /* no supplementary picture */ if (bufsize == 0) { return 0; } if (!avctx->slicecount) { slicecount = (*buf++) + 1; bufsize--; if (!slicecount || bufsize <= 8 * slicecount) { avlog(avctx, AVLOGERROR, \"Invalid slice count: %d.\\n\", slicecount); return AVERRORINVALIDDATA; } sliceshdr = buf + 4; buf += 8 * slicecount; bufsize -= 8 * slicecount; } else slicecount = avctx->slicecount; for (i = 0; i < slicecount; i++) { unsigned offset = getsliceoffset(avctx, sliceshdr, i); int size, size2; if (offset >= bufsize) return AVERRORINVALIDDATA; if (i + 1 == slicecount) size = bufsize - offset; else size = getsliceoffset(avctx, sliceshdr, i + 1) - offset; if (i + 2 >= slicecount) size2 = bufsize - offset; else size2 = getsliceoffset(avctx, sliceshdr, i + 2) - offset; if (size <= 0 || size2 <= 0 || offset + FFMAX(size, size2) > bufsize) return AVERRORINVALIDDATA; if ((ret = rv10decodepacket(avctx, buf + offset, size, size2)) < 0) return ret; if (ret > 8 * size) i++; } if (s->currentpictureptr != NULL && s->mby >= s->mbheight) { fferframeend(&s->er); ffMPVframeend(s); if (s->picttype == AVPICTURETYPEB || s->lowdelay) { if ((ret = avframeref(pict, &s->currentpictureptr->f)) < 0) return ret; ffprintdebuginfo(s, s->currentpictureptr); } else if (s->lastpictureptr != NULL) { if ((ret = avframeref(pict, &s->lastpictureptr->f)) < 0) return ret; ffprintdebuginfo(s, s->lastpictureptr); } if (s->lastpictureptr || s->lowdelay) { *gotframe = 1; } // so we can detect if frameend was not called (find some nicer solution...) s->currentpictureptr = NULL; } return avpkt->size; } ", "target": 1}
{"func": "ffrmreadmdprcodecdata (AVFormatContext *s, AVIOContext *pb, AVStream *st, RMStream *rst, int codecdatasize) { unsigned int v; int size; int64t codecpos; int ret; avprivsetptsinfo(st, 64, 1, 1000); codecpos = aviotell(pb); v = aviorb32(pb); if (v == MKTAG(0xfd, 'a', 'r', '.')) { /* ra type header */ if (rmreadaudiostreaminfo(s, pb, st, rst, 0)) return -1; } else if (v == MKBETAG('L', 'S', 'D', ':')) { avioseek(pb, -4, SEEKCUR); if ((ret = rmreadextradata(pb, st->codec, codecdatasize)) < 0) return ret; st->codec->codectype = AVMEDIATYPEAUDIO; st->codec->codectag = AVRL32(st->codec->extradata); st->codec->codecid = ffcodecgetid(ffrmcodectags, st->codec->codectag); } else { int fps; if (aviorl32(pb) != MKTAG('V', 'I', 'D', 'O')) { fail1: avlog(st->codec, AVLOGERROR, \"Unsupported video codec\\n\"); goto skip; } st->codec->codectag = aviorl32(pb); st->codec->codecid = ffcodecgetid(ffrmcodectags, st->codec->codectag); // avlog(s, AVLOGDEBUG, \"%X %X\\n\", st->codec->codectag, MKTAG('R', 'V', '2', '0')); if (st->codec->codecid == CODECIDNONE) goto fail1; st->codec->width = aviorb16(pb); st->codec->height = aviorb16(pb); avioskip(pb, 2); // looks like bits per sample avioskip(pb, 4); // always zero? st->codec->codectype = AVMEDIATYPEVIDEO; st->needparsing = AVSTREAMPARSETIMESTAMPS; fps = aviorb32(pb); if ((ret = rmreadextradata(pb, st->codec, codecdatasize - (aviotell(pb) - codecpos))) < 0) return ret; avreduce(&st->rframerate.den, &st->rframerate.num, 0x10000, fps, (1 << 30) - 1); st->avgframerate = st->rframerate; } skip: /* skip codec info */ size = aviotell(pb) - codecpos; avioskip(pb, codecdatasize - size); return 0; } ", "target": 1}
{"func": "static void putuint64(QEMUFile *f, void *pv, sizet size) { uint64t *v = pv; qemuputbe64s(f, v); } ", "target": 1}
{"func": "QJSON *qjsonnew(void) { QJSON *json = QJSON(objectnew(TYPEQJSON)); return json; } ", "target": 0}
{"func": "void kqemurecorddump(void) { PCRecord **pr, *r; int i, h; FILE *f; int64t total, sum; pr = malloc(sizeof(PCRecord *) * nbpcrecords); i = 0; total = 0; for(h = 0; h < PCRECHASHSIZE; h++) { for(r = pcrechash[h]; r != NULL; r = r->next) { pr[i++] = r; total += r->count; } } qsort(pr, nbpcrecords, sizeof(PCRecord *), pcreccmp); f = fopen(\"/tmp/kqemu.stats\", \"w\"); if (!f) { perror(\"/tmp/kqemu.stats\"); exit(1); } fprintf(f, \"total: %\" PRId64 \"\\n\", total); sum = 0; for(i = 0; i < nbpcrecords; i++) { r = pr[i]; sum += r->count; fprintf(f, \"%08lx: %\" PRId64 \" %0.2f%% %0.2f%%\\n\", r->pc, r->count, (double)r->count / (double)total * 100.0, (double)sum / (double)total * 100.0); } fclose(f); free(pr); kqemurecordflush(); } ", "target": 0}
{"func": "static void pcnetreceive(void *opaque, const uint8t *buf, sizet size) { PCNetState *s = opaque; int ispadr = 0, isbcast = 0, isladr = 0; uint8t buf1[60]; int remaining; int crcerr = 0; if (CSRDRX(s) || CSRSTOP(s) || CSRSPND(s) || !size) return; #ifdef PCNETDEBUG printf(\"pcnetreceive size=%d\\n\", size); #endif /* if too small buffer, then expand it */ if (size < MINBUFSIZE) { memcpy(buf1, buf, size); memset(buf1 + size, 0, MINBUFSIZE - size); buf = buf1; size = MINBUFSIZE; } if (CSRPROM(s) || (ispadr=padrmatch(s, buf, size)) || (isbcast=padrbcast(s, buf, size)) || (isladr=ladrmatch(s, buf, size))) { pcnetrdtepoll(s); if (!(CSRCRST(s) & 0x8000) && s->rdra) { struct pcnetRMD rmd; int rcvrc = CSRRCVRC(s)-1,i; targetphysaddrt nrda; for (i = CSRRCVRL(s)-1; i > 0; i--, rcvrc--) { if (rcvrc <= 1) rcvrc = CSRRCVRL(s); nrda = s->rdra + (CSRRCVRL(s) - rcvrc) * (BCRSWSTYLE(s) ? 16 : 8 ); RMDLOAD(&rmd, nrda); if (GETFIELD(rmd.status, RMDS, OWN)) { #ifdef PCNETDEBUGRMD printf(\"pcnet - scan buffer: RCVRC=%d PREVRCVRC=%d\\n\", rcvrc, CSRRCVRC(s)); #endif CSRRCVRC(s) = rcvrc; pcnetrdtepoll(s); break; } } } if (!(CSRCRST(s) & 0x8000)) { #ifdef PCNETDEBUGRMD printf(\"pcnet - no buffer: RCVRC=%d\\n\", CSRRCVRC(s)); #endif s->csr[0] |= 0x1000; /* Set MISS flag */ CSRMISSC(s)++; } else { uint8t *src = s->buffer; targetphysaddrt crda = CSRCRDA(s); struct pcnetRMD rmd; int pktcount = 0; if (!s->looptest) { memcpy(src, buf, size); /* no need to compute the CRC */ src[size] = 0; src[size + 1] = 0; src[size + 2] = 0; src[size + 3] = 0; size += 4; } else if (s->looptest == PCNETLOOPTESTCRC || !CSRDXMTFCS(s) || size < MINBUFSIZE+4) { uint32t fcs = ~0; uint8t *p = src; while (p != &src[size]) CRC(fcs, *p++); *(uint32t *)p = htonl(fcs); size += 4; } else { uint32t fcs = ~0; uint8t *p = src; while (p != &src[size-4]) CRC(fcs, *p++); crcerr = (*(uint32t *)p != htonl(fcs)); } #ifdef PCNETDEBUGMATCH PRINTPKTHDR(buf); #endif RMDLOAD(&rmd, PHYSADDR(s,crda)); /*if (!CSRLAPPEN(s))*/ SETFIELD(&rmd.status, RMDS, STP, 1); #define PCNETRECVSTORE() do { \\ int count = MIN(4096 - GETFIELD(rmd.buflength, RMDL, BCNT),remaining); \\ targetphysaddrt rbadr = PHYSADDR(s, rmd.rbadr); \\ s->physmemwrite(s->dmaopaque, rbadr, src, count, CSRBSWP(s)); \\ src += count; remaining -= count; \\ SETFIELD(&rmd.status, RMDS, OWN, 0); \\ RMDSTORE(&rmd, PHYSADDR(s,crda)); \\ pktcount++; \\ } while (0) remaining = size; PCNETRECVSTORE(); if ((remaining > 0) && CSRNRDA(s)) { targetphysaddrt nrda = CSRNRDA(s); #ifdef PCNETDEBUGRMD PRINTRMD(&rmd); #endif RMDLOAD(&rmd, PHYSADDR(s,nrda)); if (GETFIELD(rmd.status, RMDS, OWN)) { crda = nrda; PCNETRECVSTORE(); #ifdef PCNETDEBUGRMD PRINTRMD(&rmd); #endif if ((remaining > 0) && (nrda=CSRNNRD(s))) { RMDLOAD(&rmd, PHYSADDR(s,nrda)); if (GETFIELD(rmd.status, RMDS, OWN)) { crda = nrda; PCNETRECVSTORE(); } } } } #undef PCNETRECVSTORE RMDLOAD(&rmd, PHYSADDR(s,crda)); if (remaining == 0) { SETFIELD(&rmd.msglength, RMDM, MCNT, size); SETFIELD(&rmd.status, RMDS, ENP, 1); SETFIELD(&rmd.status, RMDS, PAM, !CSRPROM(s) && ispadr); SETFIELD(&rmd.status, RMDS, LFAM, !CSRPROM(s) && isladr); SETFIELD(&rmd.status, RMDS, BAM, !CSRPROM(s) && isbcast); if (crcerr) { SETFIELD(&rmd.status, RMDS, CRC, 1); SETFIELD(&rmd.status, RMDS, ERR, 1); } } else { SETFIELD(&rmd.status, RMDS, OFLO, 1); SETFIELD(&rmd.status, RMDS, BUFF, 1); SETFIELD(&rmd.status, RMDS, ERR, 1); } RMDSTORE(&rmd, PHYSADDR(s,crda)); s->csr[0] |= 0x0400; #ifdef PCNETDEBUG printf(\"RCVRC=%d CRDA=0x%08x BLKS=%d\\n\", CSRRCVRC(s), PHYSADDR(s,CSRCRDA(s)), pktcount); #endif #ifdef PCNETDEBUGRMD PRINTRMD(&rmd); #endif while (pktcount--) { if (CSRRCVRC(s) <= 1) CSRRCVRC(s) = CSRRCVRL(s); else CSRRCVRC(s)--; } pcnetrdtepoll(s); } } pcnetpoll(s); pcnetupdateirq(s); } ", "target": 0}
{"func": "static void nbdreplyready(void *opaque) { NbdClientSession *s = opaque; uint64t i; int ret; if (s->reply.handle == 0) { /* No reply already in flight. Fetch a header. It is possible * that another thread has done the same thing in parallel, so * the socket is not readable anymore. */ ret = nbdreceivereply(s->sock, &s->reply); if (ret == -EAGAIN) { return; } if (ret < 0) { s->reply.handle = 0; goto fail; } } /* There's no need for a mutex on the receive side, because the * handler acts as a synchronization point and ensures that only * one coroutine is called until the reply finishes. */ i = HANDLETOINDEX(s, s->reply.handle); if (i >= MAXNBDREQUESTS) { goto fail; } if (s->recvcoroutine[i]) { qemucoroutineenter(s->recvcoroutine[i], NULL); return; } fail: nbdteardownconnection(s); } ", "target": 0}
{"func": "static void ffmwritedata(AVFormatContext *s, const uint8t *buf, int size, int64t pts, int header) { FFMContext *ffm = s->privdata; int len; if (header && ffm->frameoffset == 0) { ffm->frameoffset = ffm->packetptr - ffm->packet + FFMHEADERSIZE; ffm->pts = pts; } /* write as many packets as needed */ while (size > 0) { len = ffm->packetend - ffm->packetptr; if (len > size) len = size; memcpy(ffm->packetptr, buf, len); ffm->packetptr += len; buf += len; size -= len; if (ffm->packetptr >= ffm->packetend) { /* special case : no pts in packet : we leave the current one */ if (ffm->pts == 0) ffm->pts = pts; flushpacket(s); } } } ", "target": 0}
{"func": "static inline void vmsvgacursordefine(struct vmsvgastates *s, struct vmsvgacursordefinitions *c) { QEMUCursor *qc; int i, pixels; qc = cursoralloc(c->width, c->height); qc->hotx = c->hotx; qc->hoty = c->hoty; switch (c->bpp) { case 1: cursorsetmono(qc, 0xffffff, 0x000000, (void*)c->image, 1, (void*)c->mask); #ifdef DEBUG cursorprintasciiart(qc, \"vmware/mono\"); #endif break; case 32: /* fill alpha channel from mask, set color to zero */ cursorsetmono(qc, 0x000000, 0x000000, (void*)c->mask, 1, (void*)c->mask); /* add in rgb values */ pixels = c->width * c->height; for (i = 0; i < pixels; i++) { qc->data[i] |= c->image[i] & 0xffffff; } #ifdef DEBUG cursorprintasciiart(qc, \"vmware/32bit\"); #endif break; default: fprintf(stderr, \"%s: unhandled bpp %d, using fallback cursor\\n\", FUNCTION, c->bpp); cursorput(qc); qc = cursorbuiltinleftptr(); } dpycursordefine(s->vga.ds, qc); cursorput(qc); } ", "target": 0}
{"func": "static void FUNCC(pred4x4horizontaladd)(uint8t *pix, const int16t *block, ptrdifft stride) { int i; pixel *pix = (pixel*)pix; const dctcoef *block = (const dctcoef*)block; stride >>= sizeof(pixel)-1; for(i=0; i<4; i++){ pixel v = pix[-1]; pix[0]= v += block[0]; pix[1]= v += block[1]; pix[2]= v += block[2]; pix[3]= v + block[3]; pix+= stride; block+= 4; } } ", "target": 0}
{"func": "static void setprocname(const char *s) { #ifdef linux char name[16]; if (!s) return; name[sizeof(name) - 1] = 0; strncpy(name, s, sizeof(name)); /* Could rewrite argv[0] too, but that's a bit more complicated. This simple way is enough for `top'. */ prctl(PRSETNAME, name); #endif \t } ", "target": 0}
{"func": "int nbdclientsessioncoflush(NbdClientSession *client) { struct nbdrequest request; struct nbdreply reply; ssizet ret; if (!(client->nbdflags & NBDFLAGSENDFLUSH)) { return 0; } request.type = NBDCMDFLUSH; if (client->nbdflags & NBDFLAGSENDFUA) { request.type |= NBDCMDFLAGFUA; } request.from = 0; request.len = 0; nbdcoroutinestart(client, &request); ret = nbdcosendrequest(client, &request, NULL, 0); if (ret < 0) { reply.error = -ret; } else { nbdcoreceivereply(client, &request, &reply, NULL, 0); } nbdcoroutineend(client, &request); return -reply.error; } ", "target": 1}
{"func": "int avopenclbufferread(uint8t *dstbuf, clmem srcclbuf, sizet bufsize) { clint status; void *mapped = clEnqueueMapBuffer(gpuenv.commandqueue, srcclbuf, CLTRUE,CLMAPREAD, 0, bufsize, 0, NULL, NULL, &status); if (status != CLSUCCESS) { avlog(&openclutils, AVLOGERROR, \"Could not map OpenCL buffer: %s\\n\", openclerrstr(status)); return AVERROREXTERNAL; } memcpy(dstbuf, mapped, bufsize); status = clEnqueueUnmapMemObject(gpuenv.commandqueue, srcclbuf, mapped, 0, NULL, NULL); if (status != CLSUCCESS) { avlog(&openclutils, AVLOGERROR, \"Could not unmap OpenCL buffer: %s\\n\", openclerrstr(status)); return AVERROREXTERNAL; } return 0; } ", "target": 0}
{"func": "static int movreadstsc(MOVContext *c, AVIOContext *pb, MOVAtom atom) { AVStream *st; MOVStreamContext *sc; unsigned int i, entries; if (c->fc->nbstreams < 1) return 0; st = c->fc->streams[c->fc->nbstreams-1]; sc = st->privdata; avior8(pb); /* version */ aviorb24(pb); /* flags */ entries = aviorb32(pb); avlog(c->fc, AVLOGTRACE, \"track[%i].stsc.entries = %i\\n\", c->fc->nbstreams-1, entries); if (!entries) return 0; if (entries >= UINTMAX / sizeof(*sc->stscdata)) return AVERRORINVALIDDATA; sc->stscdata = avmalloc(entries * sizeof(*sc->stscdata)); if (!sc->stscdata) return AVERROR(ENOMEM); for (i = 0; i < entries && !pb->eofreached; i++) { sc->stscdata[i].first = aviorb32(pb); sc->stscdata[i].count = aviorb32(pb); sc->stscdata[i].id = aviorb32(pb); if (sc->stscdata[i].id > sc->stsdcount) return AVERRORINVALIDDATA; } sc->stsccount = i; if (pb->eofreached) return AVERROREOF; return 0; } ", "target": 1}
{"func": "static int avireadtag(AVFormatContext *s, AVStream *st, uint32t tag, uint32t size) { AVIOContext *pb = s->pb; char key[5] = { 0 }; char *value; size += (size & 1); if (size == UINTMAX) return AVERROR(EINVAL); value = avmalloc(size + 1); if (!value) return AVERROR(ENOMEM); avioread(pb, value, size); value[size] = 0; AVWL32(key, tag); return avdictset(st ? &st->metadata : &s->metadata, key, value, AVDICTDONTSTRDUPVAL); } ", "target": 0}
{"func": "static void hybridanalysis(float out[91][32][2], float in[5][44][2], float L[2][38][64], int is34, int len) { int i, j; for (i = 0; i < 5; i++) { for (j = 0; j < 38; j++) { in[i][j+6][0] = L[0][j][i]; in[i][j+6][1] = L[1][j][i]; } } if (is34) { hybrid4812cx(in[0], out, f34012, 12, len); hybrid4812cx(in[1], out+12, f3418, 8, len); hybrid4812cx(in[2], out+20, f3424, 4, len); hybrid4812cx(in[3], out+24, f3424, 4, len); hybrid4812cx(in[4], out+28, f3424, 4, len); for (i = 0; i < 59; i++) { for (j = 0; j < len; j++) { out[i+32][j][0] = L[0][j][i+5]; out[i+32][j][1] = L[1][j][i+5]; } } } else { hybrid6cx(in[0], out, f2008, len); hybrid2re(in[1], out+6, g1Q2, len, 1); hybrid2re(in[2], out+8, g1Q2, len, 0); for (i = 0; i < 61; i++) { for (j = 0; j < len; j++) { out[i+10][j][0] = L[0][j][i+3]; out[i+10][j][1] = L[1][j][i+3]; } } } //update inbuf for (i = 0; i < 5; i++) { memcpy(in[i], in[i]+32, 6 * sizeof(in[i][0])); } } ", "target": 0}
{"func": "void qemufilesetratelimit(QEMUFile *f, int64t limit) { f->xferlimit = limit; } ", "target": 1}
{"func": "static void qobjectinputtypebool(Visitor *v, const char *name, bool *obj, Error **errp) { QObjectInputVisitor *qiv = toqiv(v); QObject *qobj = qobjectinputgetobject(qiv, name, true, errp); QBool *qbool; if (!qobj) { return; } qbool = qobjecttoqbool(qobj); if (!qbool) { errorsetg(errp, QERRINVALIDPARAMETERTYPE, name ? name : \"null\", \"boolean\"); return; } *obj = qboolgetbool(qbool); } ", "target": 1}
{"func": "int kvmarchgetregisters(CPUState *cs) { S390CPU *cpu = S390CPU(cs); CPUS390XState *env = &cpu->env; struct kvmonereg reg; struct kvmsregs sregs; struct kvmregs regs; int i, r; /* get the PSW */ env->psw.addr = cs->kvmrun->pswaddr; env->psw.mask = cs->kvmrun->pswmask; /* the GPRS */ if (capsyncregs && cs->kvmrun->kvmvalidregs & KVMSYNCGPRS) { for (i = 0; i < 16; i++) { env->regs[i] = cs->kvmrun->s.regs.gprs[i]; } } else { r = kvmvcpuioctl(cs, KVMGETREGS, &regs); if (r < 0) { return r; } for (i = 0; i < 16; i++) { env->regs[i] = regs.gprs[i]; } } /* The ACRS and CRS */ if (capsyncregs && cs->kvmrun->kvmvalidregs & KVMSYNCACRS && cs->kvmrun->kvmvalidregs & KVMSYNCCRS) { for (i = 0; i < 16; i++) { env->aregs[i] = cs->kvmrun->s.regs.acrs[i]; env->cregs[i] = cs->kvmrun->s.regs.crs[i]; } } else { r = kvmvcpuioctl(cs, KVMGETSREGS, &sregs); if (r < 0) { return r; } for (i = 0; i < 16; i++) { env->aregs[i] = sregs.acrs[i]; env->cregs[i] = sregs.crs[i]; } } /* The prefix */ if (capsyncregs && cs->kvmrun->kvmvalidregs & KVMSYNCPREFIX) { env->psa = cs->kvmrun->s.regs.prefix; } /* One Regs */ reg.id = KVMREGS390CPUTIMER; reg.addr = (u64)&(env->cputm); r = kvmvcpuioctl(cs, KVMGETONEREG, &reg); if (r < 0) { return r; } reg.id = KVMREGS390CLOCKCOMP; reg.addr = (u64)&(env->ckc); r = kvmvcpuioctl(cs, KVMGETONEREG, &reg); if (r < 0) { return r; } reg.id = KVMREGS390TODPR; reg.addr = (u64)&(env->todpr); r = kvmvcpuioctl(cs, KVMGETONEREG, &reg); if (r < 0) { return r; } if (capasyncpf) { reg.id = KVMREGS390PFTOKEN; reg.addr = (u64)&(env->pfaulttoken); r = kvmvcpuioctl(cs, KVMGETONEREG, &reg); if (r < 0) { return r; } reg.id = KVMREGS390PFCOMPARE; reg.addr = (u64)&(env->pfaultcompare); r = kvmvcpuioctl(cs, KVMGETONEREG, &reg); if (r < 0) { return r; } reg.id = KVMREGS390PFSELECT; reg.addr = (u64)&(env->pfaultselect); r = kvmvcpuioctl(cs, KVMGETONEREG, &reg); if (r < 0) { return r; } } return 0; } ", "target": 0}
{"func": "int selectwatchdog(const char *p) { WatchdogTimerModel *model; QemuOpts *opts; /* -watchdog ? lists available devices and exits cleanly. */ if (strcmp(p, \"?\") == 0) { LISTFOREACH(model, &watchdoglist, entry) { fprintf(stderr, \"\\t%s\\t%s\\n\", model->wdtname, model->wdtdescription); } return 2; } LISTFOREACH(model, &watchdoglist, entry) { if (strcasecmp(model->wdtname, p) == 0) { /* add the device */ opts = qemuoptscreate(&qemudeviceopts, NULL, 0); qemuoptset(opts, \"driver\", p); return 0; } } fprintf(stderr, \"Unknown -watchdog device. Supported devices are:\\n\"); LISTFOREACH(model, &watchdoglist, entry) { fprintf(stderr, \"\\t%s\\t%s\\n\", model->wdtname, model->wdtdescription); } return 1; } ", "target": 0}
{"func": "static void virtioballoonhandleoutput(VirtIODevice *vdev, VirtQueue *vq) { VirtIOBalloon *s = VIRTIOBALLOON(vdev); VirtQueueElement elem; MemoryRegionSection section; while (virtqueuepop(vq, &elem)) { sizet offset = 0; uint32t pfn; while (iovtobuf(elem.outsg, elem.outnum, offset, &pfn, 4) == 4) { ramaddrt pa; ramaddrt addr; int p = virtioldlp(vdev, &pfn); pa = (ramaddrt) p << VIRTIOBALLOONPFNSHIFT; offset += 4; /* FIXME: remove getsystemmemory(), but how? */ section = memoryregionfind(getsystemmemory(), pa, 1); if (!int128nz(section.size) || !memoryregionisram(section.mr)) continue; tracevirtioballoonhandleoutput(memoryregionname(section.mr), pa); /* Using memoryregiongetramptr is bending the rules a bit, but should be OK because we only want a single page. */ addr = section.offsetwithinregion; balloonpage(memoryregiongetramptr(section.mr) + addr, !!(vq == s->dvq)); memoryregionunref(section.mr); } virtqueuepush(vq, &elem, offset); virtionotify(vdev, vq); } } ", "target": 0}
{"func": "static avcold int vorbisdecodeinit(AVCodecContext *avccontext) { vorbiscontext *vc = avccontext->privdata; uint8t *headers = avccontext->extradata; int headerslen = avccontext->extradatasize; uint8t *headerstart[3]; int headerlen[3]; GetBitContext *gb = &vc->gb; int hdrtype, ret; vc->avccontext = avccontext; ffdsputilinit(&vc->dsp, avccontext); fffmtconvertinit(&vc->fmtconv, avccontext); if (avccontext->requestsamplefmt == AVSAMPLEFMTFLT) { avccontext->samplefmt = AVSAMPLEFMTFLT; vc->scalebias = 1.0f; } else { avccontext->samplefmt = AVSAMPLEFMTS16; vc->scalebias = 32768.0f; } if (!headerslen) { avlog(avccontext, AVLOGERROR, \"Extradata missing.\\n\"); return AVERRORINVALIDDATA; } if ((ret = avprivsplitxiphheaders(headers, headerslen, 30, headerstart, headerlen)) < 0) { avlog(avccontext, AVLOGERROR, \"Extradata corrupt.\\n\"); return ret; } initgetbits(gb, headerstart[0], headerlen[0]*8); hdrtype = getbits(gb, 8); if (hdrtype != 1) { avlog(avccontext, AVLOGERROR, \"First header is not the id header.\\n\"); return AVERRORINVALIDDATA; } if ((ret = vorbisparseidhdr(vc))) { avlog(avccontext, AVLOGERROR, \"Id header corrupt.\\n\"); vorbisfree(vc); return ret; } initgetbits(gb, headerstart[2], headerlen[2]*8); hdrtype = getbits(gb, 8); if (hdrtype != 5) { avlog(avccontext, AVLOGERROR, \"Third header is not the setup header.\\n\"); vorbisfree(vc); return AVERRORINVALIDDATA; } if ((ret = vorbisparsesetuphdr(vc))) { avlog(avccontext, AVLOGERROR, \"Setup header corrupt.\\n\"); vorbisfree(vc); return ret; } if (vc->audiochannels > 8) avccontext->channellayout = 0; else avccontext->channellayout = ffvorbischannellayouts[vc->audiochannels - 1]; avccontext->channels = vc->audiochannels; avccontext->samplerate = vc->audiosamplerate; avccontext->framesize = FFMIN(vc->blocksize[0], vc->blocksize[1]) >> 2; avcodecgetframedefaults(&vc->frame); avccontext->codedframe = &vc->frame; return 0; } ", "target": 0}
{"func": "static void blksend(QEMUFile *f, BlkMigBlock * blk) { int len; uint64t flags = BLKMIGFLAGDEVICEBLOCK; if (blockmigstate.zeroblocks && bufferiszero(blk->buf, BLOCKSIZE)) { flags |= BLKMIGFLAGZEROBLOCK; } /* sector number and flags */ qemuputbe64(f, (blk->sector << BDRVSECTORBITS) | flags); /* device name */ len = strlen(bdrvgetdevicename(blk->bmds->bs)); qemuputbyte(f, len); qemuputbuffer(f, (uint8t *)bdrvgetdevicename(blk->bmds->bs), len); /* if a block is zero we need to flush here since the network * bandwidth is now a lot higher than the storage device bandwidth. * thus if we queue zero blocks we slow down the migration */ if (flags & BLKMIGFLAGZEROBLOCK) { qemufflush(f); return; } qemuputbuffer(f, blk->buf, BLOCKSIZE); } ", "target": 1}
{"func": "int64t qmpguestfsfreezefreeze(Error **err) { int ret = 0, i = 0; FsMountList mounts; struct FsMount *mount; Error *localerr = NULL; int fd; slog(\"guest-fsfreeze called\"); executefsfreezehook(FSFREEZEHOOKFREEZE, &localerr); if (errorisset(&localerr)) { errorpropagate(err, localerr); return -1; } QTAILQINIT(&mounts); buildfsmountlist(&mounts, &localerr); if (errorisset(&localerr)) { errorpropagate(err, localerr); return -1; } /* cannot risk guest agent blocking itself on a write in this state */ gasetfrozen(gastate); QTAILQFOREACH(mount, &mounts, next) { fd = qemuopen(mount->dirname, ORDONLY); if (fd == -1) { errorsetgerrno(err, errno, \"failed to open %s\", mount->dirname); goto error; } /* we try to cull filesytems we know won't work in advance, but other * filesytems may not implement fsfreeze for less obvious reasons. * these will report EOPNOTSUPP. we simply ignore these when tallying * the number of frozen filesystems. * * any other error means a failure to freeze a filesystem we * expect to be freezable, so return an error in those cases * and return system to thawed state. */ ret = ioctl(fd, FIFREEZE); if (ret == -1) { if (errno != EOPNOTSUPP) { errorsetgerrno(err, errno, \"failed to freeze %s\", mount->dirname); close(fd); goto error; } } else { i++; } close(fd); } freefsmountlist(&mounts); return i; error: freefsmountlist(&mounts); qmpguestfsfreezethaw(NULL); return 0; } ", "target": 1}
{"func": "int qemudevtreesetpropstring(void *fdt, const char *nodepath, const char *property, const char *string) { int offset; offset = fdtpathoffset(fdt, nodepath); if (offset < 0) return offset; return fdtsetpropstring(fdt, offset, property, string); } ", "target": 1}
{"func": "static uint32t calcoptimalriceparams(RiceContext *rc, int porder, uint32t *sums, int n, int predorder) { int i; int k, cnt, part; uint32t allbits; part = (1 << porder); allbits = 4 * part; cnt = (n >> porder) - predorder; for (i = 0; i < part; i++) { k = findoptimalparam(sums[i], cnt); rc->params[i] = k; allbits += riceencodecount(sums[i], cnt, k); cnt = n >> porder; } rc->porder = porder; return allbits; } ", "target": 1}
{"func": "static void externalsnapshotcommit(BlkActionState *common) { ExternalSnapshotState *state = DOUPCAST(ExternalSnapshotState, common, common); bdrvsetaiocontext(state->newbs, state->aiocontext); /* This removes our old bs and adds the new bs */ bdrvappend(state->newbs, state->oldbs); /* We don't need (or want) to use the transactional * bdrvreopenmultiple() across all the entries at once, because we * don't want to abort all of them if one of them fails the reopen */ bdrvreopen(state->oldbs, state->oldbs->openflags & ~BDRVORDWR, NULL); } ", "target": 1}
{"func": "int avimagealloc(uint8t *pointers[4], int linesizes[4], int w, int h, enum PixelFormat pixfmt, int align) { int i, ret; uint8t *buf; if ((ret = avimagechecksize(w, h, 0, NULL)) < 0) return ret; if ((ret = avimagefilllinesizes(linesizes, pixfmt, w)) < 0) return ret; for (i = 0; i < 4; i++) linesizes[i] = FFALIGN(linesizes[i], align); if ((ret = avimagefillpointers(pointers, pixfmt, h, NULL, linesizes)) < 0) return ret; buf = avmalloc(ret + align); if (!buf) return AVERROR(ENOMEM); if ((ret = avimagefillpointers(pointers, pixfmt, h, buf, linesizes)) < 0) { avfree(buf); return ret; } if (avpixfmtdescriptors[pixfmt].flags & PIXFMTPAL) ffsetsystematicpal2((uint32t*)pointers[1], pixfmt); return ret; } ", "target": 1}
{"func": "static void rc4030dmaasupdateone(rc4030State *s, int index, uint32t frame) { if (index < MAXTLENTRIES) { memoryregionsetenabled(&s->dmamrs[index], false); } if (!frame) { return; } if (index >= MAXTLENTRIES) { qemulogmask(LOGUNIMP, \"rc4030: trying to use too high \" \"translation table entry %d (max allowed=%d)\", index, MAXTLENTRIES); return; } memoryregionsetaliasoffset(&s->dmamrs[index], frame); memoryregionsetenabled(&s->dmamrs[index], true); } ", "target": 1}
{"func": "static bool virtioscsidataplanehandlecmd(VirtIODevice *vdev, VirtQueue *vq) { VirtIOSCSI *s = (VirtIOSCSI *)vdev; assert(s->ctx && s->dataplanestarted); return virtioscsihandlecmdvq(s, vq); } ", "target": 1}
{"func": "USBDevice *usbhostdeviceopen(const char *devname) { struct usbdeviceinfo businfo, devinfo; USBDevice *d = NULL; USBHostDevice *dev; char ctlpath[PATHMAX + 1]; char buspath[PATHMAX + 1]; int bfd, dfd, bus, address, i; int ugendebug = UGENDEBUGLEVEL; if (usbhostfinddevice(&bus, &address, devname) < 0) return NULL; snprintf(buspath, PATHMAX, \"/dev/usb%d\", bus); bfd = open(buspath, ORDWR); if (bfd < 0) { #ifdef DEBUG printf(\"usbhostdeviceopen: failed to open usb bus - %s\\n\", strerror(errno)); #endif return NULL; } businfo.udiaddr = address; if (ioctl(bfd, USBDEVICEINFO, &businfo) < 0) { #ifdef DEBUG printf(\"usbhostdeviceopen: failed to grab bus information - %s\\n\", strerror(errno)); #endif return NULL; } #if defined(FreeBSD) || defined(FreeBSDkernel) || defined(DragonFly) snprintf(ctlpath, PATHMAX, \"/dev/%s\", businfo.udidevnames[0]); #else snprintf(ctlpath, PATHMAX, \"/dev/%s.00\", businfo.udidevnames[0]); #endif dfd = open(ctlpath, ORDWR); if (dfd < 0) { dfd = open(ctlpath, ORDONLY); if (dfd < 0) { #ifdef DEBUG printf(\"usbhostdeviceopen: failed to open usb device %s - %s\\n\", ctlpath, strerror(errno)); #endif } } if (dfd >= 0) { if (ioctl(dfd, USBGETDEVICEINFO, &devinfo) < 0) { #ifdef DEBUG printf(\"usbhostdeviceopen: failed to grab device info - %s\\n\", strerror(errno)); #endif goto fail; } d = usbcreate(NULL /* FIXME */, \"usb-host\"); dev = DOUPCAST(USBHostDevice, dev, d); if (devinfo.udispeed == 1) dev->dev.speed = USBSPEEDLOW - 1; else dev->dev.speed = USBSPEEDFULL - 1; if (strncmp(devinfo.udiproduct, \"product\", 7) != 0) pstrcpy(dev->dev.productdesc, sizeof(dev->dev.productdesc), devinfo.udiproduct); else snprintf(dev->dev.productdesc, sizeof(dev->dev.productdesc), \"host:%s\", devname); pstrcpy(dev->devpath, sizeof(dev->devpath), \"/dev/\"); pstrcat(dev->devpath, sizeof(dev->devpath), devinfo.udidevnames[0]); /* Mark the endpoints as not yet open */ for (i = 0; i < USBMAXENDPOINTS; i++) dev->epfd[i] = -1; ioctl(dfd, USBSETDEBUG, &ugendebug); return (USBDevice *)dev; } fail: return NULL; } ", "target": 1}
{"func": "static avcold int twindecodeinit(AVCodecContext *avctx) { int ret; TwinContext *tctx = avctx->privdata; int isampf, ibps; tctx->avctx = avctx; avctx->samplefmt = AVSAMPLEFMTFLTP; if (!avctx->extradata || avctx->extradatasize < 12) { avlog(avctx, AVLOGERROR, \"Missing or incomplete extradata\\n\"); return AVERRORINVALIDDATA; } avctx->channels = AVRB32(avctx->extradata ) + 1; avctx->bitrate = AVRB32(avctx->extradata + 4) * 1000; isampf = AVRB32(avctx->extradata + 8); if (isampf < 8 || isampf > 44) { avlog(avctx, AVLOGERROR, \"Unsupported sample rate\\n\"); return AVERRORINVALIDDATA; } switch (isampf) { case 44: avctx->samplerate = 44100; break; case 22: avctx->samplerate = 22050; break; case 11: avctx->samplerate = 11025; break; default: avctx->samplerate = isampf * 1000; break; } if (avctx->channels <= 0 || avctx->channels > CHANNELSMAX) { avlog(avctx, AVLOGERROR, \"Unsupported number of channels: %i\\n\", avctx->channels); return -1; } avctx->channellayout = avctx->channels == 1 ? AVCHLAYOUTMONO : AVCHLAYOUTSTEREO; ibps = avctx->bitrate / (1000 * avctx->channels); if (ibps > 255) { avlog(avctx, AVLOGERROR, \"unsupported per channel bitrate %dkbps\\n\", ibps); return AVERRORINVALIDDATA; } switch ((isampf << 8) + ibps) { case (8 <<8) + 8: tctx->mtab = &mode0808; break; case (11<<8) + 8: tctx->mtab = &mode1108; break; case (11<<8) + 10: tctx->mtab = &mode1110; break; case (16<<8) + 16: tctx->mtab = &mode1616; break; case (22<<8) + 20: tctx->mtab = &mode2220; break; case (22<<8) + 24: tctx->mtab = &mode2224; break; case (22<<8) + 32: tctx->mtab = &mode2232; break; case (44<<8) + 40: tctx->mtab = &mode4440; break; case (44<<8) + 48: tctx->mtab = &mode4448; break; default: avlog(avctx, AVLOGERROR, \"This version does not support %d kHz - %d kbit/s/ch mode.\\n\", isampf, isampf); return -1; } ffdsputilinit(&tctx->dsp, avctx); avprivfloatdspinit(&tctx->fdsp, avctx->flags & CODECFLAGBITEXACT); if ((ret = initmdctwin(tctx))) { avlog(avctx, AVLOGERROR, \"Error initializing MDCT\\n\"); twindecodeclose(avctx); return ret; } initbitstreamparams(tctx); memsetfloat(tctx->barkhist[0][0], 0.1, FFARRAYELEMS(tctx->barkhist)); avcodecgetframedefaults(&tctx->frame); avctx->codedframe = &tctx->frame; return 0; } ", "target": 0}
{"func": "static int copychapters(InputFile *ifile, OutputFile *ofile, int copymetadata) { AVFormatContext *is = ifile->ctx; AVFormatContext *os = ofile->ctx; int i; for (i = 0; i < is->nbchapters; i++) { AVChapter *inch = is->chapters[i], *outch; int64t tsoff = avrescaleq(ofile->starttime - ifile->tsoffset, AVTIMEBASEQ, inch->timebase); int64t rt = (ofile->recordingtime == INT64MAX) ? INT64MAX : avrescaleq(ofile->recordingtime, AVTIMEBASEQ, inch->timebase); if (inch->end < tsoff) continue; if (rt != INT64MAX && inch->start > rt + tsoff) break; outch = avmallocz(sizeof(AVChapter)); if (!outch) return AVERROR(ENOMEM); outch->id = inch->id; outch->timebase = inch->timebase; outch->start = FFMAX(0, inch->start - tsoff); outch->end = FFMIN(rt, inch->end - tsoff); if (copymetadata) avdictcopy(&outch->metadata, inch->metadata, 0); os->nbchapters++; os->chapters = avrealloc(os->chapters, sizeof(AVChapter) * os->nbchapters); if (!os->chapters) return AVERROR(ENOMEM); os->chapters[os->nbchapters - 1] = outch; } return 0; } ", "target": 1}
{"func": "int tracerecordstart(TraceBufferRecord *rec, TraceEventID event, sizet datasize) { unsigned int idx, recoff, oldidx, newidx; uint32t reclen = sizeof(TraceRecord) + datasize; uint64t eventu64 = event; uint64t timestampns = getclock(); do { oldidx = gatomicintget(&traceidx); smprmb(); newidx = oldidx + reclen; if (newidx - writeoutidx > TRACEBUFLEN) { /* Trace Buffer Full, Event dropped ! */ gatomicintinc(&droppedevents); return -ENOSPC; } } while (!gatomicintcompareandexchange(&traceidx, oldidx, newidx)); idx = oldidx % TRACEBUFLEN; recoff = idx; recoff = writetobuffer(recoff, &eventu64, sizeof(eventu64)); recoff = writetobuffer(recoff, &timestampns, sizeof(timestampns)); recoff = writetobuffer(recoff, &reclen, sizeof(reclen)); recoff = writetobuffer(recoff, &tracepid, sizeof(tracepid)); rec->tbufidx = idx; rec->recoff = (idx + sizeof(TraceRecord)) % TRACEBUFLEN; return 0; } ", "target": 1}
{"func": "static float64 roundAndPackFloat64( flag zSign, int16 zExp, uint64t zSig STATUSPARAM) { int8 roundingMode; flag roundNearestEven; int16 roundIncrement, roundBits; flag isTiny; roundingMode = STATUS(floatroundingmode); roundNearestEven = ( roundingMode == floatroundnearesteven ); roundIncrement = 0x200; if ( ! roundNearestEven ) { if ( roundingMode == floatroundtozero ) { roundIncrement = 0; } else { roundIncrement = 0x3FF; if ( zSign ) { if ( roundingMode == floatroundup ) roundIncrement = 0; } else { if ( roundingMode == floatrounddown ) roundIncrement = 0; } } } roundBits = zSig & 0x3FF; if ( 0x7FD <= (uint16t) zExp ) { if ( ( 0x7FD < zExp ) || ( ( zExp == 0x7FD ) && ( (int64t) ( zSig + roundIncrement ) < 0 ) ) ) { floatraise( floatflagoverflow | floatflaginexact STATUSVAR); return packFloat64( zSign, 0x7FF, - ( roundIncrement == 0 )); } if ( zExp < 0 ) { if ( STATUS(flushtozero) ) return packFloat64( zSign, 0, 0 ); isTiny = ( STATUS(floatdetecttininess) == floattininessbeforerounding ) || ( zExp < -1 ) || ( zSig + roundIncrement < LIT64( 0x8000000000000000 ) ); shift64RightJamming( zSig, - zExp, &zSig ); zExp = 0; roundBits = zSig & 0x3FF; if ( isTiny && roundBits ) floatraise( floatflagunderflow STATUSVAR); } } if ( roundBits ) STATUS(floatexceptionflags) |= floatflaginexact; zSig = ( zSig + roundIncrement )>>10; zSig &= ~ ( ( ( roundBits ^ 0x200 ) == 0 ) & roundNearestEven ); if ( zSig == 0 ) zExp = 0; return packFloat64( zSign, zExp, zSig ); } ", "target": 1}
{"func": "static void xenremapbucket(MapCacheEntry *entry, hwaddr size, hwaddr addressindex) { uint8t *vaddrbase; xenpfnt *pfns; int *err; unsigned int i; hwaddr nbpfn = size >> XCPAGESHIFT; tracexenremapbucket(addressindex); pfns = gmalloc0(nbpfn * sizeof (xenpfnt)); err = gmalloc0(nbpfn * sizeof (int)); if (entry->vaddrbase != NULL) { if (munmap(entry->vaddrbase, entry->size) != 0) { perror(\"unmap fails\"); exit(-1); } } gfree(entry->validmapping); entry->validmapping = NULL; for (i = 0; i < nbpfn; i++) { pfns[i] = (addressindex << (MCACHEBUCKETSHIFT-XCPAGESHIFT)) + i; } vaddrbase = xcmapforeignbulk(xenxc, xendomid, PROTREAD|PROTWRITE, pfns, err, nbpfn); if (vaddrbase == NULL) { perror(\"xcmapforeignbulk\"); exit(-1); } entry->vaddrbase = vaddrbase; entry->paddrindex = addressindex; entry->size = size; entry->validmapping = (unsigned long *) gmalloc0(sizeof(unsigned long) * BITSTOLONGS(size >> XCPAGESHIFT)); bitmapzero(entry->validmapping, nbpfn); for (i = 0; i < nbpfn; i++) { if (!err[i]) { bitmapset(entry->validmapping, i, 1); } } gfree(pfns); gfree(err); } ", "target": 1}
{"func": "void usbpacketcomplete(USBDevice *dev, USBPacket *p) { USBEndpoint *ep = p->ep; int ret; assert(p->state == USBPACKETASYNC); assert(QTAILQFIRST(&ep->queue) == p); usbpacketsetstate(p, USBPACKETCOMPLETE); QTAILQREMOVE(&ep->queue, p, queue); dev->port->ops->complete(dev->port, p); while (!QTAILQEMPTY(&ep->queue)) { p = QTAILQFIRST(&ep->queue); if (p->state == USBPACKETASYNC) { break; } assert(p->state == USBPACKETQUEUED); ret = usbprocessone(p); if (ret == USBRETASYNC) { usbpacketsetstate(p, USBPACKETASYNC); break; } p->result = ret; usbpacketsetstate(p, USBPACKETCOMPLETE); QTAILQREMOVE(&ep->queue, p, queue); dev->port->ops->complete(dev->port, p); } } ", "target": 1}
{"func": "static void dynbufwrite(void *opaque, UINT8 *buf, int bufsize) { DynBuffer *d = opaque; int newsize, newallocatedsize; UINT8 *newbuffer; /* reallocate buffer if needed */ newsize = d->pos + bufsize; newallocatedsize = d->allocatedsize; while (newsize > newallocatedsize) { if (!newallocatedsize) newallocatedsize = newsize; else newallocatedsize = (newallocatedsize * 3) / 2; } if (newallocatedsize > d->allocatedsize) { newbuffer = avmalloc(newallocatedsize); if (!newbuffer) return; memcpy(newbuffer, d->buffer, d->size); avfree(d->buffer); d->buffer = newbuffer; d->allocatedsize = newallocatedsize; } memcpy(d->buffer + d->pos, buf, bufsize); d->pos = newsize; if (d->pos > d->size) d->size = d->pos; } ", "target": 0}
{"func": "static inline int RENAME(yuv420rgb24)(SwsContext *c, uint8t* src[], int srcStride[], int srcSliceY, int srcSliceH, uint8t* dst[], int dstStride[]){ int y, hsize; if(c->srcFormat == PIXFMTYUV422P){ \tsrcStride[1] *= 2; \tsrcStride[2] *= 2; } hsize= (c->dstW+7)&~7; if(hsize*3 > dstStride[0]) hsize-=8; asm volatile (\"pxor %mm4, %mm4;\" /* zero mm4 */ ); for (y= 0; y<srcSliceH; y++ ) { \tuint8t *image = dst[0] + (y+srcSliceY)*dstStride[0]; \tuint8t *py = src[0] + y*srcStride[0]; \tuint8t *pu = src[1] + (y>>1)*srcStride[1]; \tuint8t *pv = src[2] + (y>>1)*srcStride[2]; \tlong index= -hsize/2; \t /* this mmx assembly code deals with SINGLE scan line at a time, it convert 8 \t pixels in each iteration */ \t asm volatile ( \t/* load data for start of next scan line */ \t\t \"movd (%2, %0), %%mm0;\" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */ \t\t \"movd (%3, %0), %%mm1;\" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */ \t\t \"movq (%5, %0, 2), %%mm6;\" /* Load 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */ //\t\t \".balign 16\t\t\t\\n\\t\" \t\t \"1:\t\t\t\t\\n\\t\" YUV2RGB \t/* mm0=B, %%mm2=G, %%mm1=R */ #ifdef HAVEMMX2 \t\t\t\"movq \"MANGLE(M24A)\", %%mm4\t\\n\\t\" \t\t\t\"movq \"MANGLE(M24C)\", %%mm7\t\\n\\t\" \t\t\t\"pshufw $0x50, %%mm0, %%mm5\t\\n\\t\" /* B3 B2 B3 B2 B1 B0 B1 B0 */ \t\t\t\"pshufw $0x50, %%mm2, %%mm3\t\\n\\t\" /* G3 G2 G3 G2 G1 G0 G1 G0 */ \t\t\t\"pshufw $0x00, %%mm1, %%mm6\t\\n\\t\" /* R1 R0 R1 R0 R1 R0 R1 R0 */ \t\t\t\"pand %%mm4, %%mm5\t\t\\n\\t\" /* B2 B1 B0 */ \t\t\t\"pand %%mm4, %%mm3\t\t\\n\\t\" /* G2 G1 G0 */ \t\t\t\"pand %%mm7, %%mm6\t\t\\n\\t\" /* R1 R0 */ \t\t\t\"psllq $8, %%mm3\t\t\\n\\t\" /* G2 G1 G0 */ \t\t\t\"por %%mm5, %%mm6\t\t\\n\\t\" \t\t\t\"por %%mm3, %%mm6\t\t\\n\\t\" \t\t\tMOVNTQ\" %%mm6, (%1)\t\t\\n\\t\" \t\t\t\"psrlq $8, %%mm2\t\t\\n\\t\" /* 00 G7 G6 G5 G4 G3 G2 G1 */ \t\t\t\"pshufw $0xA5, %%mm0, %%mm5\t\\n\\t\" /* B5 B4 B5 B4 B3 B2 B3 B2 */ \t\t\t\"pshufw $0x55, %%mm2, %%mm3\t\\n\\t\" /* G4 G3 G4 G3 G4 G3 G4 G3 */ \t\t\t\"pshufw $0xA5, %%mm1, %%mm6\t\\n\\t\" /* R5 R4 R5 R4 R3 R2 R3 R2 */ \t\t\t\"pand \"MANGLE(M24B)\", %%mm5\t\\n\\t\" /* B5 B4 B3 */ \t\t\t\"pand %%mm7, %%mm3\t\t\\n\\t\" /* G4 G3 */ \t\t\t\"pand %%mm4, %%mm6\t\t\\n\\t\" /* R4 R3 R2 */ \t\t\t\"por %%mm5, %%mm3\t\t\\n\\t\" /* B5 G4 B4 G3 B3 */ \t\t\t\"por %%mm3, %%mm6\t\t\\n\\t\" \t\t\tMOVNTQ\" %%mm6, 8(%1)\t\t\\n\\t\" \t\t\t\"pshufw $0xFF, %%mm0, %%mm5\t\\n\\t\" /* B7 B6 B7 B6 B7 B6 B6 B7 */ \t\t\t\"pshufw $0xFA, %%mm2, %%mm3\t\\n\\t\" /* 00 G7 00 G7 G6 G5 G6 G5 */ \t\t\t\"pshufw $0xFA, %%mm1, %%mm6\t\\n\\t\" /* R7 R6 R7 R6 R5 R4 R5 R4 */ \t\t\t\"movd 4 (%2, %0), %%mm0;\" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */ \t\t\t\"pand %%mm7, %%mm5\t\t\\n\\t\" /* B7 B6 */ \t\t\t\"pand %%mm4, %%mm3\t\t\\n\\t\" /* G7 G6 G5 */ \t\t\t\"pand \"MANGLE(M24B)\", %%mm6\t\\n\\t\" /* R7 R6 R5 */ \t\t\t\"movd 4 (%3, %0), %%mm1;\" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */ \\ \t\t\t\"por %%mm5, %%mm3\t\t\\n\\t\" \t\t\t\"por %%mm3, %%mm6\t\t\\n\\t\" \t\t\tMOVNTQ\" %%mm6, 16(%1)\t\t\\n\\t\" \t\t\t\"movq 8 (%5, %0, 2), %%mm6;\" /* Load 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */ \t\t\t\"pxor %%mm4, %%mm4\t\t\\n\\t\" #else \t\t\t\"pxor %%mm4, %%mm4\t\t\\n\\t\" \t\t\t\"movq %%mm0, %%mm5\t\t\\n\\t\" /* B */ \t\t\t\"movq %%mm1, %%mm6\t\t\\n\\t\" /* R */ \t\t\t\"punpcklbw %%mm2, %%mm0\t\t\\n\\t\" /* GBGBGBGB 0 */ \t\t\t\"punpcklbw %%mm4, %%mm1\t\t\\n\\t\" /* 0R0R0R0R 0 */ \t\t\t\"punpckhbw %%mm2, %%mm5\t\t\\n\\t\" /* GBGBGBGB 2 */ \t\t\t\"punpckhbw %%mm4, %%mm6\t\t\\n\\t\" /* 0R0R0R0R 2 */ \t\t\t\"movq %%mm0, %%mm7\t\t\\n\\t\" /* GBGBGBGB 0 */ \t\t\t\"movq %%mm5, %%mm3\t\t\\n\\t\" /* GBGBGBGB 2 */ \t\t\t\"punpcklwd %%mm1, %%mm7\t\t\\n\\t\" /* 0RGB0RGB 0 */ \t\t\t\"punpckhwd %%mm1, %%mm0\t\t\\n\\t\" /* 0RGB0RGB 1 */ \t\t\t\"punpcklwd %%mm6, %%mm5\t\t\\n\\t\" /* 0RGB0RGB 2 */ \t\t\t\"punpckhwd %%mm6, %%mm3\t\t\\n\\t\" /* 0RGB0RGB 3 */ \t\t\t\"movq %%mm7, %%mm2\t\t\\n\\t\" /* 0RGB0RGB 0 */ \t\t\t\"movq %%mm0, %%mm6\t\t\\n\\t\" /* 0RGB0RGB 1 */ \t\t\t\"movq %%mm5, %%mm1\t\t\\n\\t\" /* 0RGB0RGB 2 */ \t\t\t\"movq %%mm3, %%mm4\t\t\\n\\t\" /* 0RGB0RGB 3 */ \t\t\t\"psllq $40, %%mm7\t\t\\n\\t\" /* RGB00000 0 */ \t\t\t\"psllq $40, %%mm0\t\t\\n\\t\" /* RGB00000 1 */ \t\t\t\"psllq $40, %%mm5\t\t\\n\\t\" /* RGB00000 2 */ \t\t\t\"psllq $40, %%mm3\t\t\\n\\t\" /* RGB00000 3 */ \t\t\t\"punpckhdq %%mm2, %%mm7\t\t\\n\\t\" /* 0RGBRGB0 0 */ \t\t\t\"punpckhdq %%mm6, %%mm0\t\t\\n\\t\" /* 0RGBRGB0 1 */ \t\t\t\"punpckhdq %%mm1, %%mm5\t\t\\n\\t\" /* 0RGBRGB0 2 */ \t\t\t\"punpckhdq %%mm4, %%mm3\t\t\\n\\t\" /* 0RGBRGB0 3 */ \t\t\t\"psrlq $8, %%mm7\t\t\\n\\t\" /* 00RGBRGB 0 */ \t\t\t\"movq %%mm0, %%mm6\t\t\\n\\t\" /* 0RGBRGB0 1 */ \t\t\t\"psllq $40, %%mm0\t\t\\n\\t\" /* GB000000 1 */ \t\t\t\"por %%mm0, %%mm7\t\t\\n\\t\" /* GBRGBRGB 0 */ \t\t\tMOVNTQ\" %%mm7, (%1)\t\t\\n\\t\" \t\t\t\"movd 4 (%2, %0), %%mm0;\" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */ \t\t\t\"psrlq $24, %%mm6\t\t\\n\\t\" /* 0000RGBR 1 */ \t\t\t\"movq %%mm5, %%mm1\t\t\\n\\t\" /* 0RGBRGB0 2 */ \t\t\t\"psllq $24, %%mm5\t\t\\n\\t\" /* BRGB0000 2 */ \t\t\t\"por %%mm5, %%mm6\t\t\\n\\t\" /* BRGBRGBR 1 */ \t\t\tMOVNTQ\" %%mm6, 8(%1)\t\t\\n\\t\" \t\t\t\"movq 8 (%5, %0, 2), %%mm6;\" /* Load 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */ \t\t\t\"psrlq $40, %%mm1\t\t\\n\\t\" /* 000000RG 2 */ \t\t\t\"psllq $8, %%mm3\t\t\\n\\t\" /* RGBRGB00 3 */ \t\t\t\"por %%mm3, %%mm1\t\t\\n\\t\" /* RGBRGBRG 2 */ \t\t\tMOVNTQ\" %%mm1, 16(%1)\t\t\\n\\t\" \t\t\t\"movd 4 (%3, %0), %%mm1;\" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */ \t\t\t\"pxor %%mm4, %%mm4\t\t\\n\\t\" #endif \t\t \t\t \"add $24, %1\t\t\t\\n\\t\" \t\t \"add $4, %0\t\t\t\\n\\t\" \t\t \" js 1b\t\t\t\t\\n\\t\" \t\t \t\t : \"+r\" (index), \"+r\" (image) \t\t : \"r\" (pu - index), \"r\" (pv - index), \"r\"(&c->redDither), \"r\" (py - 2*index) \t\t ); } asm volatile (EMMS); return srcSliceH; } ", "target": 0}
{"func": "static int hextodata(uint8t *data, const char *p) { int c, len, v; len = 0; v = 1; for(;;) { skipspaces(&p); if (*p == '\\0') break; c = toupper((unsigned char)*p++); if (c >= '0' && c <= '9') c = c - '0'; else if (c >= 'A' && c <= 'F') c = c - 'A' + 10; else break; v = (v << 4) | c; if (v & 0x100) { if (data) data[len] = v; len++; v = 1; } } return len; } ", "target": 0}
{"func": "static int RENAME(dctquantize)(MpegEncContext *s, int16t *block, int n, int qscale, int *overflow) { x86reg lastnonzerop1; int level=0, q; //=0 is because gcc says uninitialized ... const uint16t *qmat, *bias; LOCALALIGNED16(int16t, tempblock, [64]); avassert2((7&(int)(&tempblock[0])) == 0); //did gcc align it correctly? //s->fdct (block); RENAMEFDCT(fffdct)(block); // cannot be anything else ... if(s->dcterrorsum) s->denoisedct(s, block); if (s->mbintra) { int dummy; if (n < 4){ q = s->ydcscale; bias = s->qintramatrix16[qscale][1]; qmat = s->qintramatrix16[qscale][0]; }else{ q = s->cdcscale; bias = s->qchromaintramatrix16[qscale][1]; qmat = s->qchromaintramatrix16[qscale][0]; } /* note: block[0] is assumed to be positive */ if (!s->h263aic) { asm volatile ( \"mul %%ecx \\n\\t\" : \"=d\" (level), \"=a\"(dummy) : \"a\" ((block[0]>>2) + q), \"c\" (ffinverse[q<<1]) ); } else /* For AIC we skip quant/dequant of INTRADC */ level = (block[0] + 4)>>3; block[0]=0; //avoid fake overflow // tempblock[0] = (block[0] + (q >> 1)) / q; lastnonzerop1 = 1; } else { lastnonzerop1 = 0; bias = s->qintermatrix16[qscale][1]; qmat = s->qintermatrix16[qscale][0]; } if((s->outformat == FMTH263 || s->outformat == FMTH261) && s->mpegquant==0){ asm volatile( \"movd %%\"FFREGa\", \"MM\"3 \\n\\t\" // lastnonzerop1 SPREADW(MM\"3\") \"pxor \"MM\"7, \"MM\"7 \\n\\t\" // 0 \"pxor \"MM\"4, \"MM\"4 \\n\\t\" // 0 MOVQ\" (%2), \"MM\"5 \\n\\t\" // qmat[0] \"pxor \"MM\"6, \"MM\"6 \\n\\t\" \"psubw (%3), \"MM\"6 \\n\\t\" // -bias[0] \"mov $-128, %%\"FFREGa\" \\n\\t\" \".p2align 4 \\n\\t\" \"1: \\n\\t\" MOVQ\" (%1, %%\"FFREGa\"), \"MM\"0 \\n\\t\" // block[i] SAVESIGN(MM\"1\", MM\"0\") // ABS(block[i]) \"psubusw \"MM\"6, \"MM\"0 \\n\\t\" // ABS(block[i]) + bias[0] \"pmulhw \"MM\"5, \"MM\"0 \\n\\t\" // (ABS(block[i])*qmat[0] - bias[0]*qmat[0])>>16 \"por \"MM\"0, \"MM\"4 \\n\\t\" RESTORESIGN(MM\"1\", MM\"0\") // out=((ABS(block[i])*qmat[0] - bias[0]*qmat[0])>>16)*sign(block[i]) MOVQ\" \"MM\"0, (%5, %%\"FFREGa\") \\n\\t\" \"pcmpeqw \"MM\"7, \"MM\"0 \\n\\t\" // out==0 ? 0xFF : 0x00 MOVQ\" (%4, %%\"FFREGa\"), \"MM\"1 \\n\\t\" MOVQ\" \"MM\"7, (%1, %%\"FFREGa\") \\n\\t\" // 0 \"pandn \"MM\"1, \"MM\"0 \\n\\t\" PMAXW(MM\"0\", MM\"3\") \"add $\"MMREGWIDTH\", %%\"FFREGa\" \\n\\t\" \" js 1b \\n\\t\" PMAX(MM\"3\", MM\"0\") \"movd \"MM\"3, %%\"FFREGa\" \\n\\t\" \"movzbl %%al, %%eax \\n\\t\" // lastnonzerop1 : \"+a\" (lastnonzerop1) : \"r\" (block+64), \"r\" (qmat), \"r\" (bias), \"r\" (invzigzagdirect16 + 64), \"r\" (tempblock + 64) XMMCLOBBERSONLY(\"%xmm0\", \"%xmm1\", \"%xmm2\", \"%xmm3\", \"%xmm4\", \"%xmm5\", \"%xmm6\", \"%xmm7\") ); }else{ // FMTH263 asm volatile( \"movd %%\"FFREGa\", \"MM\"3 \\n\\t\" // lastnonzerop1 SPREADW(MM\"3\") \"pxor \"MM\"7, \"MM\"7 \\n\\t\" // 0 \"pxor \"MM\"4, \"MM\"4 \\n\\t\" // 0 \"mov $-128, %%\"FFREGa\" \\n\\t\" \".p2align 4 \\n\\t\" \"1: \\n\\t\" MOVQ\" (%1, %%\"FFREGa\"), \"MM\"0 \\n\\t\" // block[i] SAVESIGN(MM\"1\", MM\"0\") // ABS(block[i]) MOVQ\" (%3, %%\"FFREGa\"), \"MM\"6 \\n\\t\" // bias[0] \"paddusw \"MM\"6, \"MM\"0 \\n\\t\" // ABS(block[i]) + bias[0] MOVQ\" (%2, %%\"FFREGa\"), \"MM\"5 \\n\\t\" // qmat[i] \"pmulhw \"MM\"5, \"MM\"0 \\n\\t\" // (ABS(block[i])*qmat[0] + bias[0]*qmat[0])>>16 \"por \"MM\"0, \"MM\"4 \\n\\t\" RESTORESIGN(MM\"1\", MM\"0\") // out=((ABS(block[i])*qmat[0] - bias[0]*qmat[0])>>16)*sign(block[i]) MOVQ\" \"MM\"0, (%5, %%\"FFREGa\") \\n\\t\" \"pcmpeqw \"MM\"7, \"MM\"0 \\n\\t\" // out==0 ? 0xFF : 0x00 MOVQ\" (%4, %%\"FFREGa\"), \"MM\"1 \\n\\t\" MOVQ\" \"MM\"7, (%1, %%\"FFREGa\") \\n\\t\" // 0 \"pandn \"MM\"1, \"MM\"0 \\n\\t\" PMAXW(MM\"0\", MM\"3\") \"add $\"MMREGWIDTH\", %%\"FFREGa\" \\n\\t\" \" js 1b \\n\\t\" PMAX(MM\"3\", MM\"0\") \"movd \"MM\"3, %%\"FFREGa\" \\n\\t\" \"movzbl %%al, %%eax \\n\\t\" // lastnonzerop1 : \"+a\" (lastnonzerop1) : \"r\" (block+64), \"r\" (qmat+64), \"r\" (bias+64), \"r\" (invzigzagdirect16 + 64), \"r\" (tempblock + 64) XMMCLOBBERSONLY(\"%xmm0\", \"%xmm1\", \"%xmm2\", \"%xmm3\", \"%xmm4\", \"%xmm5\", \"%xmm6\", \"%xmm7\") ); } asm volatile( \"movd %1, \"MM\"1 \\n\\t\" // maxqcoeff SPREADW(MM\"1\") \"psubusw \"MM\"1, \"MM\"4 \\n\\t\" \"packuswb \"MM\"4, \"MM\"4 \\n\\t\" #if COMPILETEMPLATESSE2 \"packsswb \"MM\"4, \"MM\"4 \\n\\t\" #endif \"movd \"MM\"4, %0 \\n\\t\" // *overflow : \"=g\" (*overflow) : \"g\" (s->maxqcoeff) ); if(s->mbintra) block[0]= level; else block[0]= tempblock[0]; if (s->idsp.permtype == FFIDCTPERMSIMPLE) { if(lastnonzerop1 <= 1) goto end; block[0x08] = tempblock[0x01]; block[0x10] = tempblock[0x08]; block[0x20] = tempblock[0x10]; if(lastnonzerop1 <= 4) goto end; block[0x18] = tempblock[0x09]; block[0x04] = tempblock[0x02]; block[0x09] = tempblock[0x03]; if(lastnonzerop1 <= 7) goto end; block[0x14] = tempblock[0x0A]; block[0x28] = tempblock[0x11]; block[0x12] = tempblock[0x18]; block[0x02] = tempblock[0x20]; if(lastnonzerop1 <= 11) goto end; block[0x1A] = tempblock[0x19]; block[0x24] = tempblock[0x12]; block[0x19] = tempblock[0x0B]; block[0x01] = tempblock[0x04]; block[0x0C] = tempblock[0x05]; if(lastnonzerop1 <= 16) goto end; block[0x11] = tempblock[0x0C]; block[0x29] = tempblock[0x13]; block[0x16] = tempblock[0x1A]; block[0x0A] = tempblock[0x21]; block[0x30] = tempblock[0x28]; block[0x22] = tempblock[0x30]; block[0x38] = tempblock[0x29]; block[0x06] = tempblock[0x22]; if(lastnonzerop1 <= 24) goto end; block[0x1B] = tempblock[0x1B]; block[0x21] = tempblock[0x14]; block[0x1C] = tempblock[0x0D]; block[0x05] = tempblock[0x06]; block[0x0D] = tempblock[0x07]; block[0x15] = tempblock[0x0E]; block[0x2C] = tempblock[0x15]; block[0x13] = tempblock[0x1C]; if(lastnonzerop1 <= 32) goto end; block[0x0B] = tempblock[0x23]; block[0x34] = tempblock[0x2A]; block[0x2A] = tempblock[0x31]; block[0x32] = tempblock[0x38]; block[0x3A] = tempblock[0x39]; block[0x26] = tempblock[0x32]; block[0x39] = tempblock[0x2B]; block[0x03] = tempblock[0x24]; if(lastnonzerop1 <= 40) goto end; block[0x1E] = tempblock[0x1D]; block[0x25] = tempblock[0x16]; block[0x1D] = tempblock[0x0F]; block[0x2D] = tempblock[0x17]; block[0x17] = tempblock[0x1E]; block[0x0E] = tempblock[0x25]; block[0x31] = tempblock[0x2C]; block[0x2B] = tempblock[0x33]; if(lastnonzerop1 <= 48) goto end; block[0x36] = tempblock[0x3A]; block[0x3B] = tempblock[0x3B]; block[0x23] = tempblock[0x34]; block[0x3C] = tempblock[0x2D]; block[0x07] = tempblock[0x26]; block[0x1F] = tempblock[0x1F]; block[0x0F] = tempblock[0x27]; block[0x35] = tempblock[0x2E]; if(lastnonzerop1 <= 56) goto end; block[0x2E] = tempblock[0x35]; block[0x33] = tempblock[0x3C]; block[0x3E] = tempblock[0x3D]; block[0x27] = tempblock[0x36]; block[0x3D] = tempblock[0x2F]; block[0x2F] = tempblock[0x37]; block[0x37] = tempblock[0x3E]; block[0x3F] = tempblock[0x3F]; }else if(s->idsp.permtype == FFIDCTPERMLIBMPEG2){ if(lastnonzerop1 <= 1) goto end; block[0x04] = tempblock[0x01]; block[0x08] = tempblock[0x08]; block[0x10] = tempblock[0x10]; if(lastnonzerop1 <= 4) goto end; block[0x0C] = tempblock[0x09]; block[0x01] = tempblock[0x02]; block[0x05] = tempblock[0x03]; if(lastnonzerop1 <= 7) goto end; block[0x09] = tempblock[0x0A]; block[0x14] = tempblock[0x11]; block[0x18] = tempblock[0x18]; block[0x20] = tempblock[0x20]; if(lastnonzerop1 <= 11) goto end; block[0x1C] = tempblock[0x19]; block[0x11] = tempblock[0x12]; block[0x0D] = tempblock[0x0B]; block[0x02] = tempblock[0x04]; block[0x06] = tempblock[0x05]; if(lastnonzerop1 <= 16) goto end; block[0x0A] = tempblock[0x0C]; block[0x15] = tempblock[0x13]; block[0x19] = tempblock[0x1A]; block[0x24] = tempblock[0x21]; block[0x28] = tempblock[0x28]; block[0x30] = tempblock[0x30]; block[0x2C] = tempblock[0x29]; block[0x21] = tempblock[0x22]; if(lastnonzerop1 <= 24) goto end; block[0x1D] = tempblock[0x1B]; block[0x12] = tempblock[0x14]; block[0x0E] = tempblock[0x0D]; block[0x03] = tempblock[0x06]; block[0x07] = tempblock[0x07]; block[0x0B] = tempblock[0x0E]; block[0x16] = tempblock[0x15]; block[0x1A] = tempblock[0x1C]; if(lastnonzerop1 <= 32) goto end; block[0x25] = tempblock[0x23]; block[0x29] = tempblock[0x2A]; block[0x34] = tempblock[0x31]; block[0x38] = tempblock[0x38]; block[0x3C] = tempblock[0x39]; block[0x31] = tempblock[0x32]; block[0x2D] = tempblock[0x2B]; block[0x22] = tempblock[0x24]; if(lastnonzerop1 <= 40) goto end; block[0x1E] = tempblock[0x1D]; block[0x13] = tempblock[0x16]; block[0x0F] = tempblock[0x0F]; block[0x17] = tempblock[0x17]; block[0x1B] = tempblock[0x1E]; block[0x26] = tempblock[0x25]; block[0x2A] = tempblock[0x2C]; block[0x35] = tempblock[0x33]; if(lastnonzerop1 <= 48) goto end; block[0x39] = tempblock[0x3A]; block[0x3D] = tempblock[0x3B]; block[0x32] = tempblock[0x34]; block[0x2E] = tempblock[0x2D]; block[0x23] = tempblock[0x26]; block[0x1F] = tempblock[0x1F]; block[0x27] = tempblock[0x27]; block[0x2B] = tempblock[0x2E]; if(lastnonzerop1 <= 56) goto end; block[0x36] = tempblock[0x35]; block[0x3A] = tempblock[0x3C]; block[0x3E] = tempblock[0x3D]; block[0x33] = tempblock[0x36]; block[0x2F] = tempblock[0x2F]; block[0x37] = tempblock[0x37]; block[0x3B] = tempblock[0x3E]; block[0x3F] = tempblock[0x3F]; }else{ if(lastnonzerop1 <= 1) goto end; block[0x01] = tempblock[0x01]; block[0x08] = tempblock[0x08]; block[0x10] = tempblock[0x10]; if(lastnonzerop1 <= 4) goto end; block[0x09] = tempblock[0x09]; block[0x02] = tempblock[0x02]; block[0x03] = tempblock[0x03]; if(lastnonzerop1 <= 7) goto end; block[0x0A] = tempblock[0x0A]; block[0x11] = tempblock[0x11]; block[0x18] = tempblock[0x18]; block[0x20] = tempblock[0x20]; if(lastnonzerop1 <= 11) goto end; block[0x19] = tempblock[0x19]; block[0x12] = tempblock[0x12]; block[0x0B] = tempblock[0x0B]; block[0x04] = tempblock[0x04]; block[0x05] = tempblock[0x05]; if(lastnonzerop1 <= 16) goto end; block[0x0C] = tempblock[0x0C]; block[0x13] = tempblock[0x13]; block[0x1A] = tempblock[0x1A]; block[0x21] = tempblock[0x21]; block[0x28] = tempblock[0x28]; block[0x30] = tempblock[0x30]; block[0x29] = tempblock[0x29]; block[0x22] = tempblock[0x22]; if(lastnonzerop1 <= 24) goto end; block[0x1B] = tempblock[0x1B]; block[0x14] = tempblock[0x14]; block[0x0D] = tempblock[0x0D]; block[0x06] = tempblock[0x06]; block[0x07] = tempblock[0x07]; block[0x0E] = tempblock[0x0E]; block[0x15] = tempblock[0x15]; block[0x1C] = tempblock[0x1C]; if(lastnonzerop1 <= 32) goto end; block[0x23] = tempblock[0x23]; block[0x2A] = tempblock[0x2A]; block[0x31] = tempblock[0x31]; block[0x38] = tempblock[0x38]; block[0x39] = tempblock[0x39]; block[0x32] = tempblock[0x32]; block[0x2B] = tempblock[0x2B]; block[0x24] = tempblock[0x24]; if(lastnonzerop1 <= 40) goto end; block[0x1D] = tempblock[0x1D]; block[0x16] = tempblock[0x16]; block[0x0F] = tempblock[0x0F]; block[0x17] = tempblock[0x17]; block[0x1E] = tempblock[0x1E]; block[0x25] = tempblock[0x25]; block[0x2C] = tempblock[0x2C]; block[0x33] = tempblock[0x33]; if(lastnonzerop1 <= 48) goto end; block[0x3A] = tempblock[0x3A]; block[0x3B] = tempblock[0x3B]; block[0x34] = tempblock[0x34]; block[0x2D] = tempblock[0x2D]; block[0x26] = tempblock[0x26]; block[0x1F] = tempblock[0x1F]; block[0x27] = tempblock[0x27]; block[0x2E] = tempblock[0x2E]; if(lastnonzerop1 <= 56) goto end; block[0x35] = tempblock[0x35]; block[0x3C] = tempblock[0x3C]; block[0x3D] = tempblock[0x3D]; block[0x36] = tempblock[0x36]; block[0x2F] = tempblock[0x2F]; block[0x37] = tempblock[0x37]; block[0x3E] = tempblock[0x3E]; block[0x3F] = tempblock[0x3F]; } end: return lastnonzerop1 - 1; } ", "target": 0}
{"func": "static void qdm2fftdecodetones (QDM2Context *q, int duration, GetBitContext *gb, int b) { int channel, stereo, phase, exp; int localint4, localint8, stereophase, localint10; int localint14, stereoexp, localint20, localint28; int n, offset; localint4 = 0; localint28 = 0; localint20 = 2; localint8 = (4 - duration); localint10 = 1 << (q->grouporder - duration - 1); offset = 1; while (1) { if (q->superblocktype23) { while ((n = qdm2getvlc(gb, &vlctabffttoneoffset[localint8], 1, 2)) < 2) { offset = 1; if (n == 0) { localint4 += localint10; localint28 += (1 << localint8); } else { localint4 += 8*localint10; localint28 += (8 << localint8); } } offset += (n - 2); } else { offset += qdm2getvlc(gb, &vlctabffttoneoffset[localint8], 1, 2); while (offset >= (localint10 - 1)) { offset += (1 - (localint10 - 1)); localint4 += localint10; localint28 += (1 << localint8); } } if (localint4 >= q->groupsize) localint14 = (offset >> localint8); if (q->nbchannels > 1) { channel = getbits1(gb); stereo = getbits1(gb); } else { channel = 0; stereo = 0; } exp = qdm2getvlc(gb, (b ? &fftlevelexpvlc : &fftlevelexpaltvlc), 0, 2); exp += q->fftlevelexp[fftlevelindextable[localint14]]; exp = (exp < 0) ? 0 : exp; phase = getbits(gb, 3); stereoexp = 0; stereophase = 0; if (stereo) { stereoexp = (exp - qdm2getvlc(gb, &fftstereoexpvlc, 0, 1)); stereophase = (phase - qdm2getvlc(gb, &fftstereophasevlc, 0, 1)); if (stereophase < 0) stereophase += 8; } if (q->frequencyrange > (localint14 + 1)) { int subpacket = (localint20 + localint28); qdm2fftinitcoefficient(q, subpacket, offset, duration, channel, exp, phase); if (stereo) qdm2fftinitcoefficient(q, subpacket, offset, duration, (1 - channel), stereoexp, stereophase); } offset++; } }", "target": 1}
{"func": "static void cudareceivepacket(CUDAState *s, const uint8t *data, int len) { uint8t obuf[16] = { CUDAPACKET, 0, data[0] }; int autopoll; uint32t ti; switch(data[0]) { case CUDAAUTOPOLL: autopoll = (data[1] != 0); if (autopoll != s->autopoll) { s->autopoll = autopoll; if (autopoll) { timermod(s->adbpolltimer, qemuclockgetns(QEMUCLOCKVIRTUAL) + (gettickspersec() / CUDAADBPOLLFREQ)); } else { timerdel(s->adbpolltimer); } } cudasendpackettohost(s, obuf, 3); break; case CUDAGET6805ADDR: cudasendpackettohost(s, obuf, 3); break; case CUDASETTIME: ti = (((uint32t)data[1]) << 24) + (((uint32t)data[2]) << 16) + (((uint32t)data[3]) << 8) + data[4]; s->tickoffset = ti - (qemuclockgetns(QEMUCLOCKVIRTUAL) / gettickspersec()); cudasendpackettohost(s, obuf, 3); break; case CUDAGETTIME: ti = s->tickoffset + (qemuclockgetns(QEMUCLOCKVIRTUAL) / gettickspersec()); obuf[3] = ti >> 24; obuf[4] = ti >> 16; obuf[5] = ti >> 8; obuf[6] = ti; cudasendpackettohost(s, obuf, 7); break; case CUDAFILESERVERFLAG: case CUDASETDEVICELIST: case CUDASETAUTORATE: case CUDASETPOWERMESSAGES: cudasendpackettohost(s, obuf, 3); break; case CUDAPOWERDOWN: cudasendpackettohost(s, obuf, 3); qemusystemshutdownrequest(); break; case CUDARESETSYSTEM: cudasendpackettohost(s, obuf, 3); qemusystemresetrequest(); break; case CUDACOMBINEDFORMATIIC: obuf[1] = 0x5; break; case CUDAGETSETIIC: if (len == 4) { cudasendpackettohost(s, obuf, 3); } else { } break; default: break; } }", "target": 1}
{"func": "static void bitmapfree(Qcow2Bitmap *bm) { gfree(bm->name); gfree(bm);", "target": 1}
{"func": "static int vp6parsecoeff(VP56Context *s) { VP56RangeCoder *c = s->ccp; VP56Model *model = s->modelp; uint8t *permute = s->idctscantable; uint8t *model1, *model2, *model3; int coeff, sign, coeffidx; int b, i, cg, idx, ctx; int pt = 0; /* plane type (0 for Y, 1 for U or V) */ if (c->end >= c->buffer && c->bits >= 0) { avlog(s->avctx, AVLOGERROR, \"End of AC stream reached in vp6parsecoeff\\n\"); return AVERRORINVALIDDATA; } for (b=0; b<6; b++) { int ct = 1; /* code type */ int run = 1; if (b > 3) pt = 1; ctx = s->leftblock[ffvp56b6to4[b]].notnulldc + s->aboveblocks[s->aboveblockidx[b]].notnulldc; model1 = model->coeffdccv[pt]; model2 = model->coeffdcct[pt][ctx]; coeffidx = 0; for (;;) { if ((coeffidx>1 && ct==0) || vp56racgetprobbranchy(c, model2[0])) { /* parse a coeff */ if (vp56racgetprobbranchy(c, model2[2])) { if (vp56racgetprobbranchy(c, model2[3])) { idx = vp56racgettree(c, ffvp56pctree, model1); coeff = ffvp56coeffbias[idx+5]; for (i=ffvp56coeffbitlength[idx]; i>=0; i--) coeff += vp56racgetprob(c, ffvp56coeffparsetable[idx][i]) << i; } else { if (vp56racgetprobbranchy(c, model2[4])) coeff = 3 + vp56racgetprob(c, model1[5]); else coeff = 2; } ct = 2; } else { ct = 1; coeff = 1; } sign = vp56racget(c); coeff = (coeff ^ -sign) + sign; if (coeffidx) coeff *= s->dequantac; idx = model->coeffindextopos[coeffidx]; s->blockcoeff[b][permute[idx]] = coeff; run = 1; } else { /* parse a run */ ct = 0; if (coeffidx > 0) { if (!vp56racgetprobbranchy(c, model2[1])) break; model3 = model->coeffrunv[coeffidx >= 6]; run = vp56racgettree(c, vp6pcrtree, model3); if (!run) for (run=9, i=0; i<6; i++) run += vp56racgetprob(c, model3[i+8]) << i; } } coeffidx += run; if (coeffidx >= 64) break; cg = vp6coeffgroups[coeffidx]; model1 = model2 = model->coeffract[pt][ct][cg]; } s->leftblock[ffvp56b6to4[b]].notnulldc = s->aboveblocks[s->aboveblockidx[b]].notnulldc = !!s->blockcoeff[b][0]; } return 0; } ", "target": 1}
{"func": "static int ftppassivemodeepsv(FTPContext *s) { char *res = NULL, *start = NULL, *end = NULL; int i; static const char d = '|'; static const char *command = \"EPSV\\r\\n\"; static const int epsvcodes[] = {229, 0}; if (ftpsendcommand(s, command, epsvcodes, &res) != 229 || !res) goto fail; for (i = 0; res[i]; ++i) { if (res[i] == '(') { start = res + i + 1; } else if (res[i] == ')') { end = res + i; break; } } if (!start || !end) goto fail; *end = '\\0'; if (strlen(start) < 5) goto fail; if (start[0] != d || start[1] != d || start[2] != d || end[-1] != d) goto fail; start += 3; end[-1] = '\\0'; s->serverdataport = atoi(start); avdlog(s, \"Server data port: %d\\n\", s->serverdataport); avfree(res); return 0; fail: avfree(res); s->serverdataport = -1; return AVERROR(ENOSYS); } ", "target": 0}
{"func": "static void qemuenqueuepacket(VLANClientState *sender, const uint8t *buf, int size, NetPacketSent *sentcb) { VLANPacket *packet; packet = qemumalloc(sizeof(VLANPacket) + size); packet->sender = sender; packet->size = size; packet->sentcb = sentcb; memcpy(packet->data, buf, size); TAILQINSERTTAIL(&sender->vlan->sendqueue, packet, entry); } ", "target": 0}
{"func": "static inline uint64t cpuppcgettb(CPUPPCState *env) { /* TO FIX */ return 0; } ", "target": 0}
{"func": "uint16t netchecksumtcpudp(uint16t length, uint16t proto, uint8t *addrs, uint8t *buf) { uint32t sum = 0; sum += netchecksumadd(length, buf); // payload sum += netchecksumadd(8, addrs); // src + dst address sum += proto + length; // protocol & length return netchecksumfinish(sum); } ", "target": 0}
{"func": "void cpuloopexit(CPUState *env1) { env1->currenttb = NULL; longjmp(env1->jmpenv, 1); } ", "target": 0}
{"func": "void ppchwinterrupt (CPUPPCState *env) { int raised = 0; #if 1 if (loglevel & CPULOGINT) { fprintf(logfile, \"%s: %p pending %08x req %08x me %d ee %d\\n\", func, env, env->pendinginterrupts, env->interruptrequest, msrme, msree); } #endif /* Raise it */ if (env->pendinginterrupts & (1 << PPCINTERRUPTRESET)) { /* External reset / critical input */ /* XXX: critical input should be handled another way. * This code is not correct ! */ env->exceptionindex = EXCPRESET; env->pendinginterrupts &= ~(1 << PPCINTERRUPTRESET); raised = 1; } if (raised == 0 && msrme != 0) { /* Machine check exception */ if (env->pendinginterrupts & (1 << PPCINTERRUPTMCK)) { env->exceptionindex = EXCPMACHINECHECK; env->pendinginterrupts &= ~(1 << PPCINTERRUPTMCK); raised = 1; } } if (raised == 0 && msree != 0) { #if defined(TARGETPPC64H) /* PowerPC 64 with hypervisor mode support */ /* Hypervisor decrementer exception */ if (env->pendinginterrupts & (1 << PPCINTERRUPTHDECR)) { env->exceptionindex = EXCPHDECR; env->pendinginterrupts &= ~(1 << PPCINTERRUPTHDECR); raised = 1; } else #endif /* Decrementer exception */ if (env->pendinginterrupts & (1 << PPCINTERRUPTDECR)) { env->exceptionindex = EXCPDECR; env->pendinginterrupts &= ~(1 << PPCINTERRUPTDECR); raised = 1; /* Programmable interval timer on embedded PowerPC */ } else if (env->pendinginterrupts & (1 << PPCINTERRUPTPIT)) { env->exceptionindex = EXCP40xPIT; env->pendinginterrupts &= ~(1 << PPCINTERRUPTPIT); raised = 1; /* Fixed interval timer on embedded PowerPC */ } else if (env->pendinginterrupts & (1 << PPCINTERRUPTFIT)) { env->exceptionindex = EXCP40xFIT; env->pendinginterrupts &= ~(1 << PPCINTERRUPTFIT); raised = 1; /* Watchdog timer on embedded PowerPC */ } else if (env->pendinginterrupts & (1 << PPCINTERRUPTWDT)) { env->exceptionindex = EXCP40xWATCHDOG; env->pendinginterrupts &= ~(1 << PPCINTERRUPTWDT); raised = 1; /* External interrupt */ } else if (env->pendinginterrupts & (1 << PPCINTERRUPTEXT)) { env->exceptionindex = EXCPEXTERNAL; /* Taking an external interrupt does not clear the external * interrupt status */ #if 0 env->pendinginterrupts &= ~(1 << PPCINTERRUPTEXT); #endif raised = 1; #if 0 // TODO /* Thermal interrupt */ } else if (env->pendinginterrupts & (1 << PPCINTERRUPTTHERM)) { env->exceptionindex = EXCP970THRM; env->pendinginterrupts &= ~(1 << PPCINTERRUPTTHERM); raised = 1; #endif } #if 0 // TODO /* External debug exception */ } else if (env->pendinginterrupts & (1 << PPCINTERRUPTDEBUG)) { env->exceptionindex = EXCPxxx; env->pendinginterrupts &= ~(1 << PPCINTERRUPTDEBUG); raised = 1; #endif } if (raised != 0) { env->errorcode = 0; dointerrupt(env); } } ", "target": 0}
{"func": "genintermediatecodeinternal(CPUState *env, TranslationBlock *tb, int searchpc) { uint16t *genopcend; uint32t pcstart; int j, lj; struct DisasContext ctx; struct DisasContext *dc = &ctx; uint32t nextpagestart, orgflags; targetulong npc; int numinsns; int maxinsns; qemulogtrysetfile(stderr); pcstart = tb->pc; dc->env = env; dc->tb = tb; orgflags = dc->syncedflags = dc->tbflags = tb->flags; genopcend = genopcbuf + OPCMAXSIZE; dc->isjmp = DISASNEXT; dc->jmp = 0; dc->delayedbranch = !!(dc->tbflags & DFLAG); dc->pc = pcstart; dc->singlestepenabled = env->singlestepenabled; dc->cpustatechanged = 0; dc->abortatnextinsn = 0; dc->nrnops = 0; if (pcstart & 3) cpuabort(env, \"Microblaze: unaligned PC=%x\\n\", pcstart); if (qemuloglevelmask(CPULOGTBINASM)) { #if !SIMCOMPAT qemulog(\"--------------\\n\"); logcpustate(env, 0); #endif } nextpagestart = (pcstart & TARGETPAGEMASK) + TARGETPAGESIZE; lj = -1; numinsns = 0; maxinsns = tb->cflags & CFCOUNTMASK; if (maxinsns == 0) maxinsns = CFCOUNTMASK; genicountstart(); do { #if SIMCOMPAT if (qemuloglevelmask(CPULOGTBINASM)) { tcggenmovitl(cpuSR[SRPC], dc->pc); genhelperdebug(); } #endif checkbreakpoint(env, dc); if (searchpc) { j = genopcptr - genopcbuf; if (lj < j) { lj++; while (lj < j) genopcinstrstart[lj++] = 0; } genopcpc[lj] = dc->pc; genopcinstrstart[lj] = 1; genopcicount[lj] = numinsns; } /* Pretty disas. */ LOGDIS(\"%8.8x:\\t\", dc->pc); if (numinsns + 1 == maxinsns && (tb->cflags & CFLASTIO)) geniostart(); dc->clearimm = 1; \tdecode(dc); if (dc->clearimm) dc->tbflags &= ~IMMFLAG; dc->pc += 4; numinsns++; if (dc->delayedbranch) { dc->delayedbranch--; if (!dc->delayedbranch) { if (dc->tbflags & DRTIFLAG) dorti(dc); if (dc->tbflags & DRTBFLAG) dortb(dc); if (dc->tbflags & DRTEFLAG) dorte(dc); /* Clear the delay slot flag. */ dc->tbflags &= ~DFLAG; /* If it is a direct jump, try direct chaining. */ if (dc->jmp != JMPDIRECT) { evalcondjmp(dc, envbtarget, tcgconsttl(dc->pc)); dc->isjmp = DISASJUMP; } break; } } if (env->singlestepenabled) break; } while (!dc->isjmp && !dc->cpustatechanged && genopcptr < genopcend && !singlestep && (dc->pc < nextpagestart) && numinsns < maxinsns); npc = dc->pc; if (dc->jmp == JMPDIRECT) { if (dc->tbflags & DFLAG) { dc->isjmp = DISASUPDATE; tcggenmovitl(cpuSR[SRPC], npc); syncjmpstate(dc); } else npc = dc->jmppc; } if (tb->cflags & CFLASTIO) genioend(); /* Force an update if the per-tb cpu state has changed. */ if (dc->isjmp == DISASNEXT && (dc->cpustatechanged || orgflags != dc->tbflags)) { dc->isjmp = DISASUPDATE; tcggenmovitl(cpuSR[SRPC], npc); } tsyncflags(dc); if (unlikely(env->singlestepenabled)) { tgenraiseexception(dc, EXCPDEBUG); if (dc->isjmp == DISASNEXT) tcggenmovitl(cpuSR[SRPC], npc); } else { switch(dc->isjmp) { case DISASNEXT: gengototb(dc, 1, npc); break; default: case DISASJUMP: case DISASUPDATE: /* indicate that the hash table must be used to find the next TB */ tcggenexittb(0); break; case DISASTBJUMP: /* nothing more to generate */ break; } } genicountend(tb, numinsns); *genopcptr = INDEXopend; if (searchpc) { j = genopcptr - genopcbuf; lj++; while (lj <= j) genopcinstrstart[lj++] = 0; } else { tb->size = dc->pc - pcstart; tb->icount = numinsns; } #ifdef DEBUGDISAS #if !SIMCOMPAT if (qemuloglevelmask(CPULOGTBINASM)) { qemulog(\"\\n\"); #if DISASGNU logtargetdisas(pcstart, dc->pc - pcstart, 0); #endif qemulog(\"\\nisize=%d osize=%td\\n\", dc->pc - pcstart, genopcptr - genopcbuf); } #endif #endif assert(!dc->abortatnextinsn); } ", "target": 0}
{"func": "static void addbytesl2c(uint8t *dst, uint8t *src1, uint8t *src2, int w) { long i; for (i = 0; i <= w - sizeof(long); i += sizeof(long)) { long a = *(long *)(src1 + i); long b = *(long *)(src2 + i); *(long *)(dst + i) = ((a & pb7f) + (b & pb7f)) ^ ((a ^ b) & pb80); } for (; i < w; i++) dst[i] = src1[i] + src2[i]; } ", "target": 1}
{"func": "static int calculaterefcounts(BlockDriverState *bs, BdrvCheckResult *res, BdrvCheckMode fix, bool *rebuild, uint16t **refcounttable, int64t *nbclusters) { BDRVQcowState *s = bs->opaque; int64t i; QCowSnapshot *sn; int ret; if (!*refcounttable) { int64t oldsize = 0; ret = reallocrefcountarray(s, refcounttable, &oldsize, *nbclusters); if (ret < 0) { res->checkerrors++; return ret; } } /* header */ ret = increfcounts(bs, res, refcounttable, nbclusters, 0, s->clustersize); if (ret < 0) { return ret; } /* current L1 table */ ret = checkrefcountsl1(bs, res, refcounttable, nbclusters, s->l1tableoffset, s->l1size, CHECKFRAGINFO); if (ret < 0) { return ret; } /* snapshots */ for (i = 0; i < s->nbsnapshots; i++) { sn = s->snapshots + i; ret = checkrefcountsl1(bs, res, refcounttable, nbclusters, sn->l1tableoffset, sn->l1size, 0); if (ret < 0) { return ret; } } ret = increfcounts(bs, res, refcounttable, nbclusters, s->snapshotsoffset, s->snapshotssize); if (ret < 0) { return ret; } /* refcount data */ ret = increfcounts(bs, res, refcounttable, nbclusters, s->refcounttableoffset, s->refcounttablesize * sizeof(uint64t)); if (ret < 0) { return ret; } return checkrefblocks(bs, res, fix, rebuild, refcounttable, nbclusters); } ", "target": 1}
{"func": "static void ne2000ioportwrite(void *opaque, uint32t addr, uint32t val) { NE2000State *s = opaque; int offset, page; addr &= 0xf; #ifdef DEBUGNE2000 printf(\"NE2000: write addr=0x%x val=0x%02x\\n\", addr, val); #endif if (addr == E8390CMD) { /* control register */ s->cmd = val; if (val & E8390START) { s->isr &= ~ENISRRESET; /* test specific case: zero length transfert */ if ((val & (E8390RREAD | E8390RWRITE)) && s->rcnt == 0) { s->isr |= ENISRRDC; ne2000updateirq(s); } if (val & E8390TRANS) { qemusendpacket(s->nd, s->mem + (s->tpsr << 8), s->tcnt); /* signal end of transfert */ s->tsr = ENTSRPTX; s->isr |= ENISRTX; ne2000updateirq(s); } } } else { page = s->cmd >> 6; offset = addr | (page << 4); switch(offset) { case EN0STARTPG: s->start = val << 8; break; case EN0STOPPG: s->stop = val << 8; break; case EN0BOUNDARY: s->boundary = val; break; case EN0IMR: s->imr = val; ne2000updateirq(s); break; case EN0TPSR: s->tpsr = val; break; case EN0TCNTLO: s->tcnt = (s->tcnt & 0xff00) | val; break; case EN0TCNTHI: s->tcnt = (s->tcnt & 0x00ff) | (val << 8); break; case EN0RSARLO: s->rsar = (s->rsar & 0xff00) | val; break; case EN0RSARHI: s->rsar = (s->rsar & 0x00ff) | (val << 8); break; case EN0RCNTLO: s->rcnt = (s->rcnt & 0xff00) | val; break; case EN0RCNTHI: s->rcnt = (s->rcnt & 0x00ff) | (val << 8); break; case EN0DCFG: s->dcfg = val; break; case EN0ISR: s->isr &= ~(val & 0x7f); ne2000updateirq(s); break; case EN1PHYS ... EN1PHYS + 5: s->phys[offset - EN1PHYS] = val; break; case EN1CURPAG: s->curpag = val; break; case EN1MULT ... EN1MULT + 7: s->mult[offset - EN1MULT] = val; break; } } } ", "target": 1}
{"func": "static int vc1filterline(uint8t* src, int stride, int pq){ int a0, a1, a2, a3, d, clip, filt3 = 0; uint8t *cm = ffcropTbl + MAXNEGCROP; a0 = (2*(src[-2*stride] - src[ 1*stride]) - 5*(src[-1*stride] - src[ 0*stride]) + 4) >> 3; if(FFABS(a0) < pq){ a1 = (2*(src[-4*stride] - src[-1*stride]) - 5*(src[-3*stride] - src[-2*stride]) + 4) >> 3; a2 = (2*(src[ 0*stride] - src[ 3*stride]) - 5*(src[ 1*stride] - src[ 2*stride]) + 4) >> 3; a3 = FFMIN(FFABS(a1), FFABS(a2)); if(a3 < FFABS(a0)){ d = 5 * ((a0 >=0 ? a3 : -a3) - a0) / 8; clip = (src[-1*stride] - src[ 0*stride])/2; if(clip){ filt3 = 1; if(clip > 0) d = avclip(d, 0, clip); else d = avclip(d, clip, 0); src[-1*stride] = cm[src[-1*stride] - d]; src[ 0*stride] = cm[src[ 0*stride] + d]; } } } return filt3; } ", "target": 0}
{"func": "static int rleunpack(const unsigned char *src, unsigned char *dest, int srccount, int srcsize, int destlen) { unsigned char *pd; int i, l; unsigned char *destend = dest + destlen; GetByteContext gb; bytestream2init(&gb, src, srcsize); pd = dest; if (srccount & 1) { if (bytestream2getbytesleft(&gb) < 1) return 0; *pd++ = bytestream2getbyteu(&gb); } srccount >>= 1; i = 0; do { if (bytestream2getbytesleft(&gb) < 1) break; l = bytestream2getbyteu(&gb); if (l & 0x80) { l = (l & 0x7F) * 2; if (destend - pd < l || bytestream2getbytesleft(&gb) < l) return bytestream2tell(&gb); bytestream2getbufferu(&gb, pd, l); pd += l; } else { if (destend - pd < i || bytestream2getbytesleft(&gb) < 2) return bytestream2tell(&gb); for (i = 0; i < l; i++) { *pd++ = bytestream2getbyteu(&gb); *pd++ = bytestream2getbyteu(&gb); } bytestream2skip(&gb, 2); } i += l; } while (i < srccount); return bytestream2tell(&gb); } ", "target": 0}
{"func": "static int recheckdiscardflags(AVFormatContext *s, int first) { HLSContext *c = s->privdata; int i, changed = 0; /* Check if any new streams are needed */ for (i = 0; i < c->nplaylists; i++) c->playlists[i]->curneeded = 0; for (i = 0; i < s->nbstreams; i++) { AVStream *st = s->streams[i]; struct playlist *pls = c->playlists[s->streams[i]->id]; if (st->discard < AVDISCARDALL) pls->curneeded = 1; } for (i = 0; i < c->nplaylists; i++) { struct playlist *pls = c->playlists[i]; if (pls->curneeded && !pls->needed) { pls->needed = 1; changed = 1; pls->curseqno = selectcurseqno(c, pls); pls->pb.eofreached = 0; if (c->curtimestamp != AVNOPTSVALUE) { /* catch up */ pls->seektimestamp = c->curtimestamp; pls->seekflags = AVSEEKFLAGANY; pls->seekstreamindex = -1; } avlog(s, AVLOGINFO, \"Now receiving playlist %d, segment %d\\n\", i, pls->curseqno); } else if (first && !pls->curneeded && pls->needed) { if (pls->input) ffformatioclose(pls->parent, &pls->input); pls->needed = 0; changed = 1; avlog(s, AVLOGINFO, \"No longer receiving playlist %d\\n\", i); } } return changed; } ", "target": 0}
{"func": "static int tpmpassthroughunixtransfer(int tpmfd, const TPMLocality *loctydata) { return tpmpassthroughunixtxbufs(tpmfd, loctydata->wbuffer.buffer, loctydata->woffset, loctydata->rbuffer.buffer, loctydata->rbuffer.size); } ", "target": 0}
{"func": "void dotw (int flags) { if (!likely(!(((int32t)T0 < (int32t)T1 && (flags & 0x10)) || ((int32t)T0 > (int32t)T1 && (flags & 0x08)) || ((int32t)T0 == (int32t)T1 && (flags & 0x04)) || ((uint32t)T0 < (uint32t)T1 && (flags & 0x02)) || ((uint32t)T0 > (uint32t)T1 && (flags & 0x01))))) { doraiseexceptionerr(EXCPPROGRAM, EXCPTRAP); } } ", "target": 0}
{"func": "void sh4translateinit(void) { int i; static const char * const gregnames[24] = { \"R0BANK0\", \"R1BANK0\", \"R2BANK0\", \"R3BANK0\", \"R4BANK0\", \"R5BANK0\", \"R6BANK0\", \"R7BANK0\", \"R8\", \"R9\", \"R10\", \"R11\", \"R12\", \"R13\", \"R14\", \"R15\", \"R0BANK1\", \"R1BANK1\", \"R2BANK1\", \"R3BANK1\", \"R4BANK1\", \"R5BANK1\", \"R6BANK1\", \"R7BANK1\" }; static const char * const fregnames[32] = { \"FPR0BANK0\", \"FPR1BANK0\", \"FPR2BANK0\", \"FPR3BANK0\", \"FPR4BANK0\", \"FPR5BANK0\", \"FPR6BANK0\", \"FPR7BANK0\", \"FPR8BANK0\", \"FPR9BANK0\", \"FPR10BANK0\", \"FPR11BANK0\", \"FPR12BANK0\", \"FPR13BANK0\", \"FPR14BANK0\", \"FPR15BANK0\", \"FPR0BANK1\", \"FPR1BANK1\", \"FPR2BANK1\", \"FPR3BANK1\", \"FPR4BANK1\", \"FPR5BANK1\", \"FPR6BANK1\", \"FPR7BANK1\", \"FPR8BANK1\", \"FPR9BANK1\", \"FPR10BANK1\", \"FPR11BANK1\", \"FPR12BANK1\", \"FPR13BANK1\", \"FPR14BANK1\", \"FPR15BANK1\", }; for (i = 0; i < 24; i++) { cpugregs[i] = tcgglobalmemnewi32(cpuenv, offsetof(CPUSH4State, gregs[i]), gregnames[i]); } memcpy(cpugregs + 24, cpugregs + 8, 8 * sizeof(TCGv)); cpupc = tcgglobalmemnewi32(cpuenv, offsetof(CPUSH4State, pc), \"PC\"); cpusr = tcgglobalmemnewi32(cpuenv, offsetof(CPUSH4State, sr), \"SR\"); cpusrm = tcgglobalmemnewi32(cpuenv, offsetof(CPUSH4State, srm), \"SRM\"); cpusrq = tcgglobalmemnewi32(cpuenv, offsetof(CPUSH4State, srq), \"SRQ\"); cpusrt = tcgglobalmemnewi32(cpuenv, offsetof(CPUSH4State, srt), \"SRT\"); cpussr = tcgglobalmemnewi32(cpuenv, offsetof(CPUSH4State, ssr), \"SSR\"); cpuspc = tcgglobalmemnewi32(cpuenv, offsetof(CPUSH4State, spc), \"SPC\"); cpugbr = tcgglobalmemnewi32(cpuenv, offsetof(CPUSH4State, gbr), \"GBR\"); cpuvbr = tcgglobalmemnewi32(cpuenv, offsetof(CPUSH4State, vbr), \"VBR\"); cpusgr = tcgglobalmemnewi32(cpuenv, offsetof(CPUSH4State, sgr), \"SGR\"); cpudbr = tcgglobalmemnewi32(cpuenv, offsetof(CPUSH4State, dbr), \"DBR\"); cpumach = tcgglobalmemnewi32(cpuenv, offsetof(CPUSH4State, mach), \"MACH\"); cpumacl = tcgglobalmemnewi32(cpuenv, offsetof(CPUSH4State, macl), \"MACL\"); cpupr = tcgglobalmemnewi32(cpuenv, offsetof(CPUSH4State, pr), \"PR\"); cpufpscr = tcgglobalmemnewi32(cpuenv, offsetof(CPUSH4State, fpscr), \"FPSCR\"); cpufpul = tcgglobalmemnewi32(cpuenv, offsetof(CPUSH4State, fpul), \"FPUL\"); cpuflags = tcgglobalmemnewi32(cpuenv, \t\t\t\t offsetof(CPUSH4State, flags), \"flags\"); cpudelayedpc = tcgglobalmemnewi32(cpuenv, \t\t\t\t\t offsetof(CPUSH4State, delayedpc), \t\t\t\t\t \"delayedpc\"); cpudelayedcond = tcgglobalmemnewi32(cpuenv, offsetof(CPUSH4State, delayedcond), \"delayedcond\"); cpuldst = tcgglobalmemnewi32(cpuenv, \t\t\t\t offsetof(CPUSH4State, ldst), \"ldst\"); for (i = 0; i < 32; i++) cpufregs[i] = tcgglobalmemnewi32(cpuenv, offsetof(CPUSH4State, fregs[i]), fregnames[i]); } ", "target": 1}
{"func": "AVStream *addaudiostream(AVFormatContext *oc, int codecid) { AVCodec *codec; AVCodecContext *c; AVStream *st; st = avnewstream(oc, 1); if (!st) { fprintf(stderr, \"Could not alloc stream\\n\"); exit(1); } /* find the MP2 encoder */ codec = avcodecfindencoder(codecid); if (!codec) { fprintf(stderr, \"codec not found\\n\"); exit(1); } c = &st->codec; c->codectype = CODECTYPEAUDIO; /* put sample parameters */ c->bitrate = 64000; c->samplerate = 44100; c->channels = 2; /* open it */ if (avcodecopen(c, codec) < 0) { fprintf(stderr, \"could not open codec\\n\"); exit(1); } /* init signal generator */ t = 0; tincr = 2 * MPI * 440.0 / c->samplerate; audiooutbufsize = 10000; audiooutbuf = malloc(audiooutbufsize); /* ugly hack for PCM codecs (will be removed ASAP with new PCM support to compute the input frame size in samples */ if (c->framesize <= 1) { audioinputframesize = audiooutbufsize / c->channels; switch(st->codec.codecid) { case CODECIDPCMS16LE: case CODECIDPCMS16BE: case CODECIDPCMU16LE: case CODECIDPCMU16BE: audioinputframesize >>= 1; break; default: break; } } else { audioinputframesize = c->framesize; } samples = malloc(audioinputframesize * 2 * c->channels); return st; } ", "target": 1}
{"func": "static avcold int libopenjpegencodeinit(AVCodecContext *avctx) { LibOpenJPEGContext *ctx = avctx->privdata; int err = AVERROR(ENOMEM); opjsetdefaultencoderparameters(&ctx->encparams); ctx->encparams.cprsiz = ctx->profile; ctx->encparams.mode = !!avctx->globalquality; ctx->encparams.cpcinema = ctx->cinemamode; ctx->encparams.progorder = ctx->progorder; ctx->encparams.numresolution = ctx->numresolution; ctx->encparams.cpdistoalloc = ctx->distoalloc; ctx->encparams.cpfixedalloc = ctx->fixedalloc; ctx->encparams.cpfixedquality = ctx->fixedquality; ctx->encparams.tcpnumlayers = ctx->numlayers; ctx->encparams.tcprates[0] = FFMAX(avctx->compressionlevel, 0) * 2; if (ctx->cinemamode > 0) { cinemaparameters(&ctx->encparams); } ctx->compress = opjcreatecompress(ctx->format); if (!ctx->compress) { avlog(avctx, AVLOGERROR, \"Error creating the compressor\\n\"); return AVERROR(ENOMEM); } ctx->image = mj2createimage(avctx, &ctx->encparams); if (!ctx->image) { avlog(avctx, AVLOGERROR, \"Error creating the mj2 image\\n\"); err = AVERROR(EINVAL); goto fail; } avctx->codedframe = avframealloc(); if (!avctx->codedframe) { avlog(avctx, AVLOGERROR, \"Error allocating coded frame\\n\"); goto fail; } memset(&ctx->eventmgr, 0, sizeof(opjeventmgrt)); ctx->eventmgr.infohandler = infocallback; ctx->eventmgr.errorhandler = errorcallback; ctx->eventmgr.warninghandler = warningcallback; opjseteventmgr((opjcommonptr) ctx->compress, &ctx->eventmgr, avctx); return 0; fail: opjdestroycompress(ctx->compress); ctx->compress = NULL; opjimagedestroy(ctx->image); ctx->image = NULL; avfreep(&avctx->codedframe); return err; } ", "target": 1}
{"func": "static inline unsigned int msinrvectors(uint16t flags) { return 1U << ((flags & PCIMSIFLAGSQSIZE) >> (ffs(PCIMSIFLAGSQSIZE) - 1)); } ", "target": 0}
{"func": "static void openriscsiminit(MachineState *machine) { ramaddrt ramsize = machine->ramsize; const char *cpumodel = machine->cpumodel; const char *kernelfilename = machine->kernelfilename; OpenRISCCPU *cpu = NULL; MemoryRegion *ram; int n; if (!cpumodel) { cpumodel = \"or1200\"; } for (n = 0; n < smpcpus; n++) { cpu = OPENRISCCPU(cpugenericinit(TYPEOPENRISCCPU, cpumodel)); qemuregisterreset(maincpureset, cpu); maincpureset(cpu); } ram = gmalloc(sizeof(*ram)); memoryregioninitram(ram, NULL, \"openrisc.ram\", ramsize, &errorfatal); memoryregionaddsubregion(getsystemmemory(), 0, ram); cpuopenriscpicinit(cpu); cpuopenriscclockinit(cpu); serialmminit(getsystemmemory(), 0x90000000, 0, cpu->env.irq[2], 115200, serialhds[0], DEVICENATIVEENDIAN); if (ndtable[0].used) { openriscsimnetinit(getsystemmemory(), 0x92000000, 0x92000400, cpu->env.irq[4], ndtable); } cpuopenriscloadkernel(ramsize, kernelfilename, cpu); } ", "target": 0}
{"func": "static void ohcireset(void *opaque) { OHCIState *ohci = opaque; OHCIPort *port; int i; ohcibusstop(ohci); ohci->ctl = 0; ohci->oldctl = 0; ohci->status = 0; ohci->intrstatus = 0; ohci->intr = OHCIINTRMIE; ohci->hcca = 0; ohci->ctrlhead = ohci->ctrlcur = 0; ohci->bulkhead = ohci->bulkcur = 0; ohci->percur = 0; ohci->done = 0; ohci->donecount = 7; /* FSMPS is marked TBD in OCHI 1.0, what gives ffs? * I took the value linux sets ... */ ohci->fsmps = 0x2778; ohci->fi = 0x2edf; ohci->fit = 0; ohci->frt = 0; ohci->framenumber = 0; ohci->pstart = 0; ohci->lst = OHCILSTHRESH; ohci->rhdesca = OHCIRHANPS | ohci->numports; ohci->rhdescb = 0x0; /* Impl. specific */ ohci->rhstatus = 0; for (i = 0; i < ohci->numports; i++) { port = &ohci->rhport[i]; port->ctrl = 0; if (port->port.dev) { usbattach(&port->port, port->port.dev); } } if (ohci->asynctd) { usbcancelpacket(&ohci->usbpacket); ohci->asynctd = 0; } DPRINTF(\"usb-ohci: Reset %s\\n\", ohci->name); } ", "target": 0}
{"func": "uint64t helperfsub(CPUPPCState *env, uint64t arg1, uint64t arg2) { CPUDoubleU farg1, farg2; farg1.ll = arg1; farg2.ll = arg2; if (unlikely(float64isinfinity(farg1.d) && float64isinfinity(farg2.d) && float64isneg(farg1.d) == float64isneg(farg2.d))) { /* Magnitude subtraction of infinities */ farg1.ll = floadinvalidopexcp(env, POWERPCEXCPFPVXISI); } else { if (unlikely(float64issignalingnan(farg1.d) || float64issignalingnan(farg2.d))) { /* sNaN subtraction */ floadinvalidopexcp(env, POWERPCEXCPFPVXSNAN); } farg1.d = float64sub(farg1.d, farg2.d, &env->fpstatus); } return farg1.ll; } ", "target": 0}
{"func": "static int netsocketconnectinit(NetClientState *peer, const char *model, const char *name, const char *hoststr) { NetSocketState *s; int fd, connected, ret; struct sockaddrin saddr; if (parsehostport(&saddr, hoststr) < 0) return -1; fd = qemusocket(PFINET, SOCKSTREAM, 0); if (fd < 0) { perror(\"socket\"); return -1; } qemusetnonblock(fd); connected = 0; for(;;) { ret = connect(fd, (struct sockaddr *)&saddr, sizeof(saddr)); if (ret < 0) { if (errno == EINTR || errno == EWOULDBLOCK) { /* continue */ } else if (errno == EINPROGRESS || errno == EALREADY || errno == EINVAL) { break; } else { perror(\"connect\"); closesocket(fd); return -1; } } else { connected = 1; break; } } s = netsocketfdinit(peer, model, name, fd, connected); if (!s) return -1; snprintf(s->nc.infostr, sizeof(s->nc.infostr), \"socket: connect to %s:%d\", inetntoa(saddr.sinaddr), ntohs(saddr.sinport)); return 0; } ", "target": 1}
{"func": "static int64t loadkernel (void) { int64t kernelentry, kernelhigh; long initrdsize; ramaddrt initrdoffset; int bigendian; uint32t *prombuf; long promsize; int promindex = 0; uint64t (*xlatetokseg0) (void *opaque, uint64t addr); #ifdef TARGETWORDSBIGENDIAN bigendian = 1; #else bigendian = 0; #endif if (loadelf(loaderparams.kernelfilename, cpumipskseg0tophys, NULL, (uint64t *)&kernelentry, NULL, (uint64t *)&kernelhigh, bigendian, ELFMACHINE, 1) < 0) { fprintf(stderr, \"qemu: could not load kernel '%s'\\n\", loaderparams.kernelfilename); exit(1); } /* Sanity check where the kernel has been linked */ if (kvmenabled()) { if (kernelentry & 0x80000000ll) { errorreport(\"KVM guest kernels must be linked in useg. \" \"Did you forget to enable CONFIGKVMGUEST?\"); exit(1); } xlatetokseg0 = cpumipskvmumphystokseg0; } else { if (!(kernelentry & 0x80000000ll)) { errorreport(\"KVM guest kernels aren't supported with TCG. \" \"Did you unintentionally enable CONFIGKVMGUEST?\"); exit(1); } xlatetokseg0 = cpumipsphystokseg0; } /* load initrd */ initrdsize = 0; initrdoffset = 0; if (loaderparams.initrdfilename) { initrdsize = getimagesize (loaderparams.initrdfilename); if (initrdsize > 0) { initrdoffset = (kernelhigh + ~INITRDPAGEMASK) & INITRDPAGEMASK; if (initrdoffset + initrdsize > ramsize) { fprintf(stderr, \"qemu: memory too small for initial ram disk '%s'\\n\", loaderparams.initrdfilename); exit(1); } initrdsize = loadimagetargphys(loaderparams.initrdfilename, initrdoffset, ramsize - initrdoffset); } if (initrdsize == (targetulong) -1) { fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\", loaderparams.initrdfilename); exit(1); } } /* Setup prom parameters. */ promsize = ENVPNBENTRIES * (sizeof(int32t) + ENVPENTRYSIZE); prombuf = gmalloc(promsize); promset(prombuf, promindex++, \"%s\", loaderparams.kernelfilename); if (initrdsize > 0) { promset(prombuf, promindex++, \"rdstart=0x%\" PRIx64 \" rdsize=%li %s\", xlatetokseg0(NULL, initrdoffset), initrdsize, loaderparams.kernelcmdline); } else { promset(prombuf, promindex++, \"%s\", loaderparams.kernelcmdline); } promset(prombuf, promindex++, \"memsize\"); promset(prombuf, promindex++, \"%i\", MIN(loaderparams.ramsize, 256 << 20)); promset(prombuf, promindex++, \"modetty0\"); promset(prombuf, promindex++, \"38400n8r\"); promset(prombuf, promindex++, NULL); romaddblobfixed(\"prom\", prombuf, promsize, cpumipskseg0tophys(NULL, ENVPADDR)); return kernelentry; }", "target": 1}
{"func": "static void testvalidatefailunionanon(TestInputVisitorData *data, const void *unused) { UserDefAnonUnion *tmp = NULL; Visitor *v; Error *errp = NULL; v = validatetestinit(data, \"3.14\"); visittypeUserDefAnonUnion(v, &tmp, NULL, &errp); gassert(errorisset(&errp)); qapifreeUserDefAnonUnion(tmp); } ", "target": 0}
{"func": "static int vhostvirtqueueinit(struct vhostdev *dev, struct vhostvirtqueue *vq, int n) { struct vhostvringfile file = { .index = n, }; int r = eventnotifierinit(&vq->maskednotifier, 0); if (r < 0) { return r; } file.fd = eventnotifiergetfd(&vq->maskednotifier); r = dev->vhostops->vhostcall(dev, VHOSTSETVRINGCALL, &file); if (r) { r = -errno; goto failcall; } return 0; failcall: eventnotifiercleanup(&vq->maskednotifier); return r; } ", "target": 0}
{"func": "static int filterframe(AVFilterLink *inlink, AVFrame *srcbuffer) { AVFilterContext *ctx = inlink->dst; ATempoContext *atempo = ctx->priv; AVFilterLink *outlink = ctx->outputs[0]; int ret = 0; int nin = srcbuffer->nbsamples; int nout = (int)(0.5 + ((double)nin) / atempo->tempo); const uint8t *src = srcbuffer->data[0]; const uint8t *srcend = src + nin * atempo->stride; while (src < srcend) { if (!atempo->dstbuffer) { atempo->dstbuffer = ffgetaudiobuffer(outlink, nout); if (!atempo->dstbuffer) return AVERROR(ENOMEM); avframecopyprops(atempo->dstbuffer, srcbuffer); atempo->dst = atempo->dstbuffer->data[0]; atempo->dstend = atempo->dst + nout * atempo->stride; } yaeapply(atempo, &src, srcend, &atempo->dst, atempo->dstend); if (atempo->dst == atempo->dstend) { int nsamples = ((atempo->dst - atempo->dstbuffer->data[0]) / atempo->stride); ret = pushsamples(atempo, outlink, nsamples); if (ret < 0) goto end; } } atempo->nsamplesin += nin; end: avframefree(&srcbuffer); return ret; } ", "target": 1}
{"func": "struct vhostnet *vhostnetinit(VhostNetOptions *options) { int r; bool backendkernel = options->backendtype == VHOSTBACKENDTYPEKERNEL; struct vhostnet *net = gmalloc(sizeof *net); if (!options->netbackend) { fprintf(stderr, \"vhost-net requires net backend to be setup\\n\"); goto fail; } if (backendkernel) { r = vhostnetgetfd(options->netbackend); if (r < 0) { goto fail; } net->dev.backendfeatures = qemuhasvnethdr(options->netbackend) ? 0 : (1ULL << VHOSTNETFVIRTIONETHDR); net->backend = r; } else { net->dev.backendfeatures = 0; net->backend = -1; } net->nc = options->netbackend; net->dev.nvqs = 2; net->dev.vqs = net->vqs; net->dev.vqindex = net->nc->queueindex; r = vhostdevinit(&net->dev, options->opaque, options->backendtype, options->force); if (r < 0) { goto fail; } if (backendkernel) { if (!qemuhasvnethdrlen(options->netbackend, sizeof(struct virtionethdrmrgrxbuf))) { net->dev.features &= ~(1ULL << VIRTIONETFMRGRXBUF); } if (~net->dev.features & net->dev.backendfeatures) { fprintf(stderr, \"vhost lacks feature mask %\" PRIu64 \" for backend\\n\", (uint64t)(~net->dev.features & net->dev.backendfeatures)); vhostdevcleanup(&net->dev); goto fail; } } /* Set sane init value. Override when guest acks. */ vhostnetackfeatures(net, 0); return net; fail: gfree(net); return NULL; } ", "target": 1}
{"func": "static USBDevice *usbmsdinit(const char *filename) { static int nr=0; char id[8]; QemuOpts *opts; DriveInfo *dinfo; USBDevice *dev; int fatalerror; const char *p1; char fmt[32]; /* parse -usbdevice disk: syntax into drive opts */ snprintf(id, sizeof(id), \"usb%d\", nr++); opts = qemuoptscreate(&qemudriveopts, id, 0); p1 = strchr(filename, ':'); if (p1++) { const char *p2; if (strstart(filename, \"format=\", &p2)) { int len = MIN(p1 - p2, sizeof(fmt)); pstrcpy(fmt, len, p2); qemuoptset(opts, \"format\", fmt); } else if (*filename != ':') { printf(\"unrecognized USB mass-storage option %s\\n\", filename); filename = p1; if (!*filename) { printf(\"block device specification needed\\n\"); qemuoptset(opts, \"file\", filename); qemuoptset(opts, \"if\", \"none\"); /* create host drive */ dinfo = driveinit(opts, NULL, &fatalerror); if (!dinfo) { qemuoptsdel(opts); /* create guest device */ dev = usbcreate(NULL /* FIXME */, \"usb-storage\"); qdevpropsetdrive(&dev->qdev, \"drive\", dinfo); if (qdevinit(&dev->qdev) < 0) return dev; ", "target": 1}
{"func": "static inline void rv34mc(RV34DecContext *r, const int blocktype, const int xoff, const int yoff, int mvoff, const int width, const int height, int dir, const int thirdpel, int weighted, qpelmcfunc (*qpelmc)[16], h264chromamcfunc (*chromamc)) { MpegEncContext *s = &r->s; uint8t *Y, *U, *V, *srcY, *srcU, *srcV; int dxy, mx, my, umx, umy, lx, ly, uvmx, uvmy, srcx, srcy, uvsrcx, uvsrcy; int mvpos = s->mbx * 2 + s->mby * 2 * s->b8stride + mvoff; int is16x16 = 1; if(thirdpel){ int chromamx, chromamy; mx = (s->currentpictureptr->f.motionval[dir][mvpos][0] + (3 << 24)) / 3 - (1 << 24); my = (s->currentpictureptr->f.motionval[dir][mvpos][1] + (3 << 24)) / 3 - (1 << 24); lx = (s->currentpictureptr->f.motionval[dir][mvpos][0] + (3 << 24)) % 3; ly = (s->currentpictureptr->f.motionval[dir][mvpos][1] + (3 << 24)) % 3; chromamx = s->currentpictureptr->f.motionval[dir][mvpos][0] / 2; chromamy = s->currentpictureptr->f.motionval[dir][mvpos][1] / 2; umx = (chromamx + (3 << 24)) / 3 - (1 << 24); umy = (chromamy + (3 << 24)) / 3 - (1 << 24); uvmx = chromacoeffs[(chromamx + (3 << 24)) % 3]; uvmy = chromacoeffs[(chromamy + (3 << 24)) % 3]; }else{ int cx, cy; mx = s->currentpictureptr->f.motionval[dir][mvpos][0] >> 2; my = s->currentpictureptr->f.motionval[dir][mvpos][1] >> 2; lx = s->currentpictureptr->f.motionval[dir][mvpos][0] & 3; ly = s->currentpictureptr->f.motionval[dir][mvpos][1] & 3; cx = s->currentpictureptr->f.motionval[dir][mvpos][0] / 2; cy = s->currentpictureptr->f.motionval[dir][mvpos][1] / 2; umx = cx >> 2; umy = cy >> 2; uvmx = (cx & 3) << 1; uvmy = (cy & 3) << 1; //due to some flaw RV40 uses the same MC compensation routine for H2V2 and H3V3 if(uvmx == 6 && uvmy == 6) uvmx = uvmy = 4; } dxy = ly*4 + lx; srcY = dir ? s->nextpictureptr->f.data[0] : s->lastpictureptr->f.data[0]; srcU = dir ? s->nextpictureptr->f.data[1] : s->lastpictureptr->f.data[1]; srcV = dir ? s->nextpictureptr->f.data[2] : s->lastpictureptr->f.data[2]; srcx = s->mbx * 16 + xoff + mx; srcy = s->mby * 16 + yoff + my; uvsrcx = s->mbx * 8 + (xoff >> 1) + umx; uvsrcy = s->mby * 8 + (yoff >> 1) + umy; srcY += srcy * s->linesize + srcx; srcU += uvsrcy * s->uvlinesize + uvsrcx; srcV += uvsrcy * s->uvlinesize + uvsrcx; if( (unsigned)(srcx - !!lx*2) > s->hedgepos - !!lx*2 - (width <<3) - 4 || (unsigned)(srcy - !!ly*2) > s->vedgepos - !!ly*2 - (height<<3) - 4){ uint8t *uvbuf = s->edgeemubuffer + 22 * s->linesize; srcY -= 2 + 2*s->linesize; s->dsp.emulatededgemc(s->edgeemubuffer, srcY, s->linesize, (width<<3)+6, (height<<3)+6, srcx - 2, srcy - 2, s->hedgepos, s->vedgepos); srcY = s->edgeemubuffer + 2 + 2*s->linesize; s->dsp.emulatededgemc(uvbuf , srcU, s->uvlinesize, (width<<2)+1, (height<<2)+1, uvsrcx, uvsrcy, s->hedgepos >> 1, s->vedgepos >> 1); s->dsp.emulatededgemc(uvbuf + 16, srcV, s->uvlinesize, (width<<2)+1, (height<<2)+1, uvsrcx, uvsrcy, s->hedgepos >> 1, s->vedgepos >> 1); srcU = uvbuf; srcV = uvbuf + 16; } if(!weighted){ Y = s->dest[0] + xoff + yoff *s->linesize; U = s->dest[1] + (xoff>>1) + (yoff>>1)*s->uvlinesize; V = s->dest[2] + (xoff>>1) + (yoff>>1)*s->uvlinesize; }else{ Y = r->tmpbblocky [dir] + xoff + yoff *s->linesize; U = r->tmpbblockuv[dir*2] + (xoff>>1) + (yoff>>1)*s->uvlinesize; V = r->tmpbblockuv[dir*2+1] + (xoff>>1) + (yoff>>1)*s->uvlinesize; } if(blocktype == RV34MBP16x8){ qpelmc[1][dxy](Y, srcY, s->linesize); Y += 8; srcY += 8; }else if(blocktype == RV34MBP8x16){ qpelmc[1][dxy](Y, srcY, s->linesize); Y += 8 * s->linesize; srcY += 8 * s->linesize; } is16x16 = (blocktype != RV34MBP8x8) && (blocktype != RV34MBP16x8) && (blocktype != RV34MBP8x16); qpelmc[!is16x16][dxy](Y, srcY, s->linesize); chromamc[2-width] (U, srcU, s->uvlinesize, height*4, uvmx, uvmy); chromamc[2-width] (V, srcV, s->uvlinesize, height*4, uvmx, uvmy); } ", "target": 1}
{"func": "void migratefdconnect(MigrationState *s) { s->state = MIGSTATESETUP; tracemigratesetstate(MIGSTATESETUP); /* This is a best 1st approximation. ns to ms */ s->expecteddowntime = maxdowntime/1000000; s->cleanupbh = qemubhnew(migratefdcleanup, s); qemufilesetratelimit(s->file, s->bandwidthlimit / XFERLIMITRATIO); qemuthreadcreate(&s->thread, migrationthread, s, QEMUTHREADJOINABLE); notifierlistnotify(&migrationstatenotifiers, s); } ", "target": 1}
{"func": "static void ppc405crclksetup (ppc405crcpct *cpc) { uint64t VCOout, PLLout; uint32t CPUclk, TMRclk, SDRAMclk, PLBclk, OPBclk, EXTclk, UARTclk; int M, D0, D1, D2; D0 = ((cpc->pllmr >> 26) & 0x3) + 1; /* CBDV */ if (cpc->pllmr & 0x80000000) { D1 = (((cpc->pllmr >> 20) - 1) & 0xF) + 1; /* FBDV */ D2 = 8 - ((cpc->pllmr >> 16) & 0x7); /* FWDVA */ M = D0 * D1 * D2; VCOout = cpc->sysclk * M; if (VCOout < 400000000 || VCOout > 800000000) { /* PLL cannot lock */ cpc->pllmr &= ~0x80000000; goto bypasspll; } PLLout = VCOout / D2; } else { /* Bypass PLL */ bypasspll: M = D0; PLLout = cpc->sysclk * M; } CPUclk = PLLout; if (cpc->cr1 & 0x00800000) TMRclk = cpc->sysclk; /* Should have a separate clock */ else TMRclk = CPUclk; PLBclk = CPUclk / D0; SDRAMclk = PLBclk; D0 = ((cpc->pllmr >> 10) & 0x3) + 1; OPBclk = PLBclk / D0; D0 = ((cpc->pllmr >> 24) & 0x3) + 2; EXTclk = PLBclk / D0; D0 = ((cpc->cr0 >> 1) & 0x1F) + 1; UARTclk = CPUclk / D0; /* Setup CPU clocks */ clksetup(&cpc->clksetup[PPC405CRCPUCLK], CPUclk); /* Setup time-base clock */ clksetup(&cpc->clksetup[PPC405CRTMRCLK], TMRclk); /* Setup PLB clock */ clksetup(&cpc->clksetup[PPC405CRPLBCLK], PLBclk); /* Setup SDRAM clock */ clksetup(&cpc->clksetup[PPC405CRSDRAMCLK], SDRAMclk); /* Setup OPB clock */ clksetup(&cpc->clksetup[PPC405CROPBCLK], OPBclk); /* Setup external clock */ clksetup(&cpc->clksetup[PPC405CREXTCLK], EXTclk); /* Setup UART clock */ clksetup(&cpc->clksetup[PPC405CRUARTCLK], UARTclk); } ", "target": 1}
{"func": "static uint64t cmd646cmdread(void *opaque, targetphysaddrt addr, unsigned size) { CMD646BAR *cmd646bar = opaque; if (addr != 2 || size != 1) { return ((uint64t)1 << (size * 8)) - 1; } return idestatusread(cmd646bar->bus, addr + 2); } ", "target": 0}
{"func": "static uint64t hpetramread(void *opaque, targetphysaddrt addr, unsigned size) { HPETState *s = opaque; uint64t curtick, index; DPRINTF(\"qemu: Enter hpetramreadl at %\" PRIx64 \"\\n\", addr); index = addr; /*address range of all TN regs*/ if (index >= 0x100 && index <= 0x3ff) { uint8t timerid = (addr - 0x100) / 0x20; HPETTimer *timer = &s->timer[timerid]; if (timerid > s->numtimers) { DPRINTF(\"qemu: timer id out of range\\n\"); return 0; } switch ((addr - 0x100) % 0x20) { case HPETTNCFG: return timer->config; case HPETTNCFG + 4: // Interrupt capabilities return timer->config >> 32; case HPETTNCMP: // comparator register return timer->cmp; case HPETTNCMP + 4: return timer->cmp >> 32; case HPETTNROUTE: return timer->fsb; case HPETTNROUTE + 4: return timer->fsb >> 32; default: DPRINTF(\"qemu: invalid hpetramreadl\\n\"); break; } } else { switch (index) { case HPETID: return s->capability; case HPETPERIOD: return s->capability >> 32; case HPETCFG: return s->config; case HPETCFG + 4: DPRINTF(\"qemu: invalid HPETCFG + 4 hpetramreadl\\n\"); return 0; case HPETCOUNTER: if (hpetenabled(s)) { curtick = hpetgetticks(s); } else { curtick = s->hpetcounter; } DPRINTF(\"qemu: reading counter = %\" PRIx64 \"\\n\", curtick); return curtick; case HPETCOUNTER + 4: if (hpetenabled(s)) { curtick = hpetgetticks(s); } else { curtick = s->hpetcounter; } DPRINTF(\"qemu: reading counter + 4 = %\" PRIx64 \"\\n\", curtick); return curtick >> 32; case HPETSTATUS: return s->isr; default: DPRINTF(\"qemu: invalid hpetramreadl\\n\"); break; } } return 0; } ", "target": 0}
{"func": "static void virtioinitpci(VirtIOPCIProxy *proxy, VirtIODevice *vdev, uint16t vendor, uint16t device, uint16t classcode, uint8t pif) { uint8t *config; uint32t size; proxy->vdev = vdev; config = proxy->pcidev.config; pciconfigsetvendorid(config, vendor); pciconfigsetdeviceid(config, device); config[0x08] = VIRTIOPCIABIVERSION; config[0x09] = pif; pciconfigsetclass(config, classcode); config[0x2c] = vendor & 0xFF; config[0x2d] = (vendor >> 8) & 0xFF; config[0x2e] = vdev->deviceid & 0xFF; config[0x2f] = (vdev->deviceid >> 8) & 0xFF; config[0x3d] = 1; if (vdev->nvectors && !msixinit(&proxy->pcidev, vdev->nvectors, 1, 0)) { pciregisterbar(&proxy->pcidev, 1, msixbarsize(&proxy->pcidev), PCIBASEADDRESSSPACEMEMORY, msixmmiomap); } else vdev->nvectors = 0; proxy->pcidev.configwrite = virtiowriteconfig; size = VIRTIOPCIREGIONSIZE(&proxy->pcidev) + vdev->configlen; if (size & (size-1)) size = 1 << qemufls(size); pciregisterbar(&proxy->pcidev, 0, size, PCIBASEADDRESSSPACEIO, virtiomap); if (!kvmhasmanyioeventfds()) { proxy->flags &= ~VIRTIOPCIFLAGUSEIOEVENTFD; } virtiobinddevice(vdev, &virtiopcibindings, proxy); proxy->hostfeatures |= 0x1 << VIRTIOFNOTIFYONEMPTY; proxy->hostfeatures |= 0x1 << VIRTIOFBADFEATURE; proxy->hostfeatures = vdev->getfeatures(vdev, proxy->hostfeatures); } ", "target": 0}
{"func": "static int usbdeviceadd(const char *devname, int ishotplug) { const char *p; USBDevice *dev; if (!freeusbports) return -1; if (strstart(devname, \"host:\", &p)) { dev = usbhostdeviceopen(p); } else if (!strcmp(devname, \"mouse\")) { dev = usbmouseinit(); } else if (!strcmp(devname, \"tablet\")) { dev = usbtabletinit(); } else if (!strcmp(devname, \"keyboard\")) { dev = usbkeyboardinit(); } else if (strstart(devname, \"disk:\", &p)) { BlockDriverState *bs; dev = usbmsdinit(p, &bs); if (!dev) return -1; if (bdrvkeyrequired(bs)) { autostart = 0; if (ishotplug && monitorreadbdrvkey(bs) < 0) { dev->handledestroy(dev); return -1; } } } else if (!strcmp(devname, \"wacom-tablet\")) { dev = usbwacominit(); } else if (strstart(devname, \"serial:\", &p)) { dev = usbserialinit(p); #ifdef CONFIGBRLAPI } else if (!strcmp(devname, \"braille\")) { dev = usbbauminit(); #endif } else if (strstart(devname, \"net:\", &p)) { int nic = nbnics; if (netclientinit(\"nic\", p) < 0) return -1; ndtable[nic].model = \"usb\"; dev = usbnetinit(&ndtable[nic]); } else if (!strcmp(devname, \"bt\") || strstart(devname, \"bt:\", &p)) { dev = usbbtinit(devname[2] ? hciinit(p) : btnewhci(qemufindbtvlan(0))); } else { return -1; } if (!dev) return -1; return usbdeviceadddev(dev); } ", "target": 0}
{"func": "void ioinsthandlemsch(S390CPU *cpu, uint64t reg1, uint32t ipb) { int cssid, ssid, schid, m; SubchDev *sch; SCHIB schib; uint64t addr; int ret = -ENODEV; int cc; CPUS390XState *env = &cpu->env; uint8t ar; addr = decodebasedisps(env, ipb, &ar); if (addr & 3) { programinterrupt(env, PGMSPECIFICATION, 2); return; } if (s390cpuvirtmemread(cpu, addr, ar, &schib, sizeof(schib))) { return; } if (ioinstdisassembleschident(reg1, &m, &cssid, &ssid, &schid) || !ioinstschibvalid(&schib)) { programinterrupt(env, PGMOPERAND, 2); return; } traceioinstschid(\"msch\", cssid, ssid, schid); sch = cssfindsubch(m, cssid, ssid, schid); if (sch && csssubchvisible(sch)) { ret = cssdomsch(sch, &schib); } switch (ret) { case -ENODEV: cc = 3; break; case -EBUSY: cc = 2; break; case 0: cc = 0; break; default: cc = 1; break; } setcc(cpu, cc); } ", "target": 0}
{"func": "int loaduimage(const char *filename, targetulong *ep, targetulong *loadaddr, int *islinux) { int fd; int size; ubootimageheadert h; ubootimageheadert *hdr = &h; uint8t *data = NULL; int ret = -1; fd = open(filename, ORDONLY | OBINARY); if (fd < 0) return -1; size = read(fd, hdr, sizeof(ubootimageheadert)); if (size < 0) goto out; bswapubootheader(hdr); if (hdr->ihmagic != IHMAGIC) goto out; /* TODO: Implement Multi-File images. */ if (hdr->ihtype == IHTYPEMULTI) { fprintf(stderr, \"Unable to load multi-file u-boot images\\n\"); goto out; } switch (hdr->ihcomp) { case IHCOMPNONE: case IHCOMPGZIP: break; default: fprintf(stderr, \"Unable to load u-boot images with compression type %d\\n\", hdr->ihcomp); goto out; } /* TODO: Check CPU type. */ if (islinux) { if (hdr->ihtype == IHTYPEKERNEL && hdr->ihos == IHOSLINUX) *islinux = 1; else *islinux = 0; } *ep = hdr->ihep; data = qemumalloc(hdr->ihsize); if (!data) goto out; if (read(fd, data, hdr->ihsize) != hdr->ihsize) { fprintf(stderr, \"Error reading file\\n\"); goto out; } if (hdr->ihcomp == IHCOMPGZIP) { uint8t *compresseddata; sizet maxbytes; ssizet bytes; compresseddata = data; maxbytes = UBOOTMAXGUNZIPBYTES; data = qemumalloc(maxbytes); bytes = gunzip(data, maxbytes, compresseddata, hdr->ihsize); qemufree(compresseddata); if (bytes < 0) { fprintf(stderr, \"Unable to decompress gzipped image!\\n\"); goto out; } hdr->ihsize = bytes; } cpuphysicalmemorywriterom(hdr->ihload, data, hdr->ihsize); if (loadaddr) *loadaddr = hdr->ihload; ret = hdr->ihsize; out: if (data) qemufree(data); close(fd); return ret; } ", "target": 1}
{"func": "static int mpcreadpacket(AVFormatContext *s, AVPacket *pkt) { MPCContext *c = s->privdata; int ret, size, size2, curbits, cur = c->curframe; int64t tmp, pos; if (c->curframe >= c->fcount) return -1; if(c->curframe != c->lastframe + 1){ urlfseek(s->pb, c->frames[c->curframe].pos, SEEKSET); c->curbits = c->frames[c->curframe].skip; } c->lastframe = c->curframe; c->curframe++; curbits = c->curbits; pos = urlftell(s->pb); tmp = getle32(s->pb); if(curbits <= 12){ size2 = (tmp >> (12 - curbits)) & 0xFFFFF; }else{ tmp = (tmp << 32) | getle32(s->pb); size2 = (tmp >> (44 - curbits)) & 0xFFFFF; } curbits += 20; urlfseek(s->pb, pos, SEEKSET); size = ((size2 + curbits + 31) & ~31) >> 3; if(cur == c->framesnoted){ c->frames[cur].pos = pos; c->frames[cur].size = size; c->frames[cur].skip = curbits - 20; avaddindexentry(s->streams[0], cur, cur, size, 0, AVINDEXKEYFRAME); c->framesnoted++; } c->curbits = (curbits + size2) & 0x1F; if (avnewpacket(pkt, size) < 0) return AVERROR(EIO); pkt->data[0] = curbits; pkt->data[1] = (c->curframe > c->fcount); pkt->streamindex = 0; pkt->pts = cur; ret = getbuffer(s->pb, pkt->data + 4, size); if(c->curbits) urlfseek(s->pb, -4, SEEKCUR); if(ret < size){ avfreepacket(pkt); return AVERROR(EIO); } pkt->size = ret + 4; return 0; }", "target": 1}
{"func": "static void hpetramwritel(void *opaque, targetphysaddrt addr, uint32t value) { int i; HPETState *s = (HPETState *)opaque; uint64t oldval, newval, val, index; DPRINTF(\"qemu: Enter hpetramwritel at %\" PRIx64 \" = %#x\\n\", addr, value); index = addr; oldval = hpetramreadl(opaque, addr); newval = value; /*address range of all TN regs*/ if (index >= 0x100 && index <= 0x3ff) { uint8t timerid = (addr - 0x100) / 0x20; DPRINTF(\"qemu: hpetramwritel timerid = %#x \\n\", timerid); HPETTimer *timer = &s->timer[timerid]; if (timerid > HPETNUMTIMERS - 1) { DPRINTF(\"qemu: timer id out of range\\n\"); return; } switch ((addr - 0x100) % 0x20) { case HPETTNCFG: DPRINTF(\"qemu: hpetramwritel HPETTNCFG\\n\"); val = hpetfixupreg(newval, oldval, HPETTNCFGWRITEMASK); timer->config = (timer->config & 0xffffffff00000000ULL) | val; if (newval & HPETTN32BIT) { timer->cmp = (uint32t)timer->cmp; timer->period = (uint32t)timer->period; } if (newval & HPETTIMERTYPELEVEL) { printf(\"qemu: level-triggered hpet not supported\\n\"); exit (-1); } break; case HPETTNCFG + 4: // Interrupt capabilities DPRINTF(\"qemu: invalid HPETTNCFG+4 write\\n\"); break; case HPETTNCMP: // comparator register DPRINTF(\"qemu: hpetramwritel HPETTNCMP \\n\"); if (timer->config & HPETTN32BIT) newval = (uint32t)newval; if (!timerisperiodic(timer) || (timer->config & HPETTNSETVAL)) timer->cmp = (timer->cmp & 0xffffffff00000000ULL) | newval; if (timerisperiodic(timer)) { /* * FIXME: Clamp period to reasonable min value? * Clamp period to reasonable max value */ newval &= (timer->config & HPETTN32BIT ? ~0u : ~0ull) >> 1; timer->period = (timer->period & 0xffffffff00000000ULL) | newval; } timer->config &= ~HPETTNSETVAL; if (hpetenabled()) hpetsettimer(timer); break; case HPETTNCMP + 4: // comparator register high order DPRINTF(\"qemu: hpetramwritel HPETTNCMP + 4\\n\"); if (!timerisperiodic(timer) || (timer->config & HPETTNSETVAL)) timer->cmp = (timer->cmp & 0xffffffffULL) | newval << 32; else { /* * FIXME: Clamp period to reasonable min value? * Clamp period to reasonable max value */ newval &= (timer->config & HPETTN32BIT ? ~0u : ~0ull) >> 1; timer->period = (timer->period & 0xffffffffULL) | newval << 32; } timer->config &= ~HPETTNSETVAL; if (hpetenabled()) hpetsettimer(timer); break; case HPETTNROUTE + 4: DPRINTF(\"qemu: hpetramwritel HPETTNROUTE + 4\\n\"); break; default: DPRINTF(\"qemu: invalid hpetramwritel\\n\"); break; } return; } else { switch (index) { case HPETID: return; case HPETCFG: val = hpetfixupreg(newval, oldval, HPETCFGWRITEMASK); s->config = (s->config & 0xffffffff00000000ULL) | val; if (activatingbit(oldval, newval, HPETCFGENABLE)) { /* Enable main counter and interrupt generation. */ s->hpetoffset = tickstons(s->hpetcounter) - qemugetclock(vmclock); for (i = 0; i < HPETNUMTIMERS; i++) if ((&s->timer[i])->cmp != ~0ULL) hpetsettimer(&s->timer[i]); } else if (deactivatingbit(oldval, newval, HPETCFGENABLE)) { /* Halt main counter and disable interrupt generation. */ s->hpetcounter = hpetgetticks(); for (i = 0; i < HPETNUMTIMERS; i++) hpetdeltimer(&s->timer[i]); } /* i8254 and RTC are disabled when HPET is in legacy mode */ if (activatingbit(oldval, newval, HPETCFGLEGACY)) { hpetpitdisable(); } else if (deactivatingbit(oldval, newval, HPETCFGLEGACY)) { hpetpitenable(); } break; case HPETCFG + 4: DPRINTF(\"qemu: invalid HPETCFG+4 write \\n\"); break; case HPETSTATUS: /* FIXME: need to handle level-triggered interrupts */ break; case HPETCOUNTER: if (hpetenabled()) printf(\"qemu: Writing counter while HPET enabled!\\n\"); s->hpetcounter = (s->hpetcounter & 0xffffffff00000000ULL) | value; DPRINTF(\"qemu: HPET counter written. ctr = %#x -> %\" PRIx64 \"\\n\", value, s->hpetcounter); break; case HPETCOUNTER + 4: if (hpetenabled()) printf(\"qemu: Writing counter while HPET enabled!\\n\"); s->hpetcounter = (s->hpetcounter & 0xffffffffULL) | (((uint64t)value) << 32); DPRINTF(\"qemu: HPET counter + 4 written. ctr = %#x -> %\" PRIx64 \"\\n\", value, s->hpetcounter); break; default: DPRINTF(\"qemu: invalid hpetramwritel\\n\"); break; } } } ", "target": 1}
{"func": "void cpudumpstate(CPUState *env, FILE *f, fprintffunction cpufprintf, int flags) { int i; cpufprintf(f, \"PC=%08x\\n\", env->pc); for (i = 0; i < 16; ++i) { cpufprintf(f, \"A%02d=%08x%c\", i, env->regs[i], (i % 4) == 3 ? '\\n' : ' '); } } ", "target": 0}
{"func": "int netinitsocket(const NetClientOptions *opts, const char *name, NetClientState *peer, Error **errp) { /* FIXME errorsetg(errp, ...) on failure */ Error *err = NULL; const NetdevSocketOptions *sock; assert(opts->kind == NETCLIENTOPTIONSKINDSOCKET); sock = opts->socket; if (sock->hasfd + sock->haslisten + sock->hasconnect + sock->hasmcast + sock->hasudp != 1) { errorreport(\"exactly one of fd=, listen=, connect=, mcast= or udp=\" \" is required\"); return -1; } if (sock->haslocaladdr && !sock->hasmcast && !sock->hasudp) { errorreport(\"localaddr= is only valid with mcast= or udp=\"); return -1; } if (sock->hasfd) { int fd; fd = monitorfdparam(curmon, sock->fd, &err); if (fd == -1) { errorreporterr(err); return -1; } qemusetnonblock(fd); if (!netsocketfdinit(peer, \"socket\", name, fd, 1)) { return -1; } return 0; } if (sock->haslisten) { if (netsocketlisteninit(peer, \"socket\", name, sock->listen) == -1) { return -1; } return 0; } if (sock->hasconnect) { if (netsocketconnectinit(peer, \"socket\", name, sock->connect) == -1) { return -1; } return 0; } if (sock->hasmcast) { /* if sock->localaddr is missing, it has been initialized to \"all bits * zero\" */ if (netsocketmcastinit(peer, \"socket\", name, sock->mcast, sock->localaddr) == -1) { return -1; } return 0; } assert(sock->hasudp); if (!sock->haslocaladdr) { errorreport(\"localaddr= is mandatory with udp=\"); return -1; } if (netsocketudpinit(peer, \"socket\", name, sock->udp, sock->localaddr) == -1) { return -1; } return 0; } ", "target": 0}
{"func": "void visittypebool(Visitor *v, bool *obj, const char *name, Error **errp) { if (!errorisset(errp)) { v->typebool(v, obj, name, errp); } } ", "target": 1}
{"func": "static avalwaysinline avflatten void h264loopfilterchromaintrac(uint8t *pix, int xstride, int ystride, int alpha, int beta) { int d; for( d = 0; d < 8; d++ ) { const int p0 = pix[-1*xstride]; const int p1 = pix[-2*xstride]; const int q0 = pix[0]; const int q1 = pix[1*xstride]; if( FFABS( p0 - q0 ) < alpha && FFABS( p1 - p0 ) < beta && FFABS( q1 - q0 ) < beta ) { pix[-xstride] = ( 2*p1 + p0 + q1 + 2 ) >> 2; /* p0' */ pix[0] = ( 2*q1 + q0 + p1 + 2 ) >> 2; /* q0' */ } pix += ystride; } } ", "target": 0}
{"func": "static int protocolversion(VncState *vs, uint8t *version, sizet len) { char local[13]; memcpy(local, version, 12); local[12] = 0; if (sscanf(local, \"RFB %03d.%03d\\n\", &vs->major, &vs->minor) != 2) { VNCDEBUG(\"Malformed protocol version %s\\n\", local); vncclienterror(vs); return 0; } VNCDEBUG(\"Client request protocol version %d.%d\\n\", vs->major, vs->minor); if (vs->major != 3 || (vs->minor != 3 && vs->minor != 4 && vs->minor != 5 && vs->minor != 7 && vs->minor != 8)) { VNCDEBUG(\"Unsupported client version\\n\"); vncwriteu32(vs, VNCAUTHINVALID); vncflush(vs); vncclienterror(vs); return 0; } /* Some broken clients report v3.4 or v3.5, which spec requires to be treated * as equivalent to v3.3 by servers */ if (vs->minor == 4 || vs->minor == 5) vs->minor = 3; if (vs->minor == 3) { if (vs->auth == VNCAUTHNONE) { VNCDEBUG(\"Tell client auth none\\n\"); vncwriteu32(vs, vs->auth); vncflush(vs); startclientinit(vs); } else if (vs->auth == VNCAUTHVNC) { VNCDEBUG(\"Tell client VNC auth\\n\"); vncwriteu32(vs, vs->auth); vncflush(vs); startauthvnc(vs); } else { VNCDEBUG(\"Unsupported auth %d for protocol 3.3\\n\", vs->auth); vncwriteu32(vs, VNCAUTHINVALID); vncflush(vs); vncclienterror(vs); } } else { VNCDEBUG(\"Telling client we support auth %d\\n\", vs->auth); vncwriteu8(vs, 1); /* num auth */ vncwriteu8(vs, vs->auth); vncreadwhen(vs, protocolclientauth, 1); vncflush(vs); } return 0; } ", "target": 1}
{"func": "qemuirq *pxa2xxpicinit(targetphysaddrt base, CPUState *env) { struct pxa2xxpicstates *s; int iomemtype; qemuirq *qi; s = (struct pxa2xxpicstates *) qemumallocz(sizeof(struct pxa2xxpicstates)); if (!s) return NULL; s->cpuenv = env; s->base = base; s->intpending[0] = 0; s->intpending[1] = 0; s->intenabled[0] = 0; s->intenabled[1] = 0; s->isfiq[0] = 0; s->isfiq[1] = 0; qi = qemuallocateirqs(pxa2xxpicsetirq, s, PXA2XXPICSRCS); /* Enable IC memory-mapped registers access. */ iomemtype = cpuregisteriomemory(0, pxa2xxpicreadfn, pxa2xxpicwritefn, s); cpuregisterphysicalmemory(base, 0x000fffff, iomemtype); /* Enable IC coprocessor access. */ cpuarmsetcpio(env, 6, pxa2xxpiccpread, pxa2xxpiccpwrite, s); registersavevm(\"pxa2xxpic\", 0, 0, pxa2xxpicsave, pxa2xxpicload, s); return qi; } ", "target": 1}
{"func": "static int mpdecodeframe(MPADecodeContext *s, OUTINT **samples, const uint8t *buf, int bufsize) { int i, nbframes, ch, ret; OUTINT *samplesptr; initgetbits(&s->gb, buf + HEADERSIZE, (bufsize - HEADERSIZE) * 8); /* skip error protection field */ if (s->errorprotection) skipbits(&s->gb, 16); switch(s->layer) { case 1: s->avctx->framesize = 384; nbframes = mpdecodelayer1(s); break; case 2: s->avctx->framesize = 1152; nbframes = mpdecodelayer2(s); break; case 3: s->avctx->framesize = s->lsf ? 576 : 1152; default: nbframes = mpdecodelayer3(s); if (nbframes < 0) return nbframes; s->lastbufsize=0; if (s->ingb.buffer) { aligngetbits(&s->gb); i = getbitsleft(&s->gb)>>3; if (i >= 0 && i <= BACKSTEPSIZE) { memmove(s->lastbuf, s->gb.buffer + (getbitscount(&s->gb)>>3), i); s->lastbufsize=i; } else avlog(s->avctx, AVLOGERROR, \"invalid old backstep %d\\n\", i); s->gb = s->ingb; s->ingb.buffer = NULL; } aligngetbits(&s->gb); assert((getbitscount(&s->gb) & 7) == 0); i = getbitsleft(&s->gb) >> 3; if (i < 0 || i > BACKSTEPSIZE || nbframes < 0) { if (i < 0) avlog(s->avctx, AVLOGERROR, \"invalid new backstep %d\\n\", i); i = FFMIN(BACKSTEPSIZE, bufsize - HEADERSIZE); } assert(i <= bufsize - HEADERSIZE && i >= 0); memcpy(s->lastbuf + s->lastbufsize, s->gb.buffer + bufsize - HEADERSIZE - i, i); s->lastbufsize += i; } /* get output buffer */ if (!samples) { avassert0(s->frame != NULL); s->frame->nbsamples = s->avctx->framesize; if ((ret = ffgetbuffer(s->avctx, s->frame, 0)) < 0) { avlog(s->avctx, AVLOGERROR, \"getbuffer() failed\\n\"); return ret; } samples = (OUTINT **)s->frame->extendeddata; } /* apply the synthesis filter */ for (ch = 0; ch < s->nbchannels; ch++) { int samplestride; if (s->avctx->samplefmt == OUTFMTP) { samplesptr = samples[ch]; samplestride = 1; } else { samplesptr = samples[0] + ch; samplestride = s->nbchannels; } for (i = 0; i < nbframes; i++) { RENAME(ffmpasynthfilter)(&s->mpadsp, s->synthbuf[ch], &(s->synthbufoffset[ch]), RENAME(ffmpasynthwindow), &s->ditherstate, samplesptr, samplestride, s->sbsamples[ch][i]); samplesptr += 32 * samplestride; } } return nbframes * 32 * sizeof(OUTINT) * s->nbchannels; } ", "target": 1}
{"func": "static InetSocketAddress *sshconfig(QDict *options, Error **errp) { InetSocketAddress *inet = NULL; QDict *addr = NULL; QObject *crumpledaddr = NULL; Visitor *iv = NULL; Error *localerror = NULL; qdictextractsubqdict(options, &addr, \"server.\"); if (!qdictsize(addr)) { errorsetg(errp, \"SSH server address missing\"); goto out; } crumpledaddr = qdictcrumple(addr, errp); if (!crumpledaddr) { goto out; } iv = qobjectinputvisitornew(crumpledaddr); visittypeInetSocketAddress(iv, NULL, &inet, &localerror); if (localerror) { errorpropagate(errp, localerror); goto out; } out: QDECREF(addr); qobjectdecref(crumpledaddr); visitfree(iv); return inet; }", "target": 1}
{"func": "sdhcibuffaccessissequential(SDHCIState *s, unsigned bytenum) { if ((s->datacount & 0x3) != bytenum) { ERRPRINT(\"Non-sequential access to Buffer Data Port register\" \"is prohibited\\n\"); return false; } return true; } ", "target": 1}
{"func": "static int nbdnegotiatewrite(QIOChannel *ioc, const void *buffer, sizet size) { ssizet ret; guint watch; assert(qemuincoroutine()); /* Negotiation are always in main loop. */ watch = qiochanneladdwatch(ioc, GIOOUT, nbdnegotiatecontinue, qemucoroutineself(), NULL); ret = writesync(ioc, buffer, size, NULL); gsourceremove(watch); return ret; } ", "target": 0}
{"func": "static void aioreaddone(void *opaque, int ret) { struct aioctx *ctx = opaque; struct timeval t2; gettimeofday(&t2, NULL); if (ret < 0) { printf(\"readv failed: %s\\n\", strerror(-ret)); goto out; } if (ctx->Pflag) { void *cmpbuf = malloc(ctx->qiov.size); memset(cmpbuf, ctx->pattern, ctx->qiov.size); if (memcmp(ctx->buf, cmpbuf, ctx->qiov.size)) { printf(\"Pattern verification failed at offset %\" PRId64 \", %zd bytes\\n\", ctx->offset, ctx->qiov.size); } free(cmpbuf); } if (ctx->qflag) { goto out; } if (ctx->vflag) { dumpbuffer(ctx->buf, ctx->offset, ctx->qiov.size); } /* Finally, report back -- -C gives a parsable format */ t2 = tsub(t2, ctx->t1); printreport(\"read\", &t2, ctx->offset, ctx->qiov.size, ctx->qiov.size, 1, ctx->Cflag); out: qemuiofree(ctx->buf); free(ctx); } ", "target": 0}
{"func": "static void sprreadtbu (DisasContext *ctx, int gprn, int sprn) { if (useicount) { geniostart(); } genhelperloadtbu(cpugpr[gprn], cpuenv); if (useicount) { genioend(); genstopexception(ctx); } } ", "target": 0}
{"func": "static void nvdimmbuildcommondsm(Aml *dev) { Aml *method, *ifctx, *function, *dsmmem, *unpatched, *resultsize; uint8t bytelist[1]; method = amlmethod(NVDIMMCOMMONDSM, 4, AMLSERIALIZED); function = amlarg(2); dsmmem = amlname(NVDIMMACPIMEMADDR); /* * do not support any method if DSM memory address has not been * patched. */ unpatched = amlif(amlequal(dsmmem, amlint(0x0))); /* * function 0 is called to inquire what functions are supported by * OSPM */ ifctx = amlif(amlequal(function, amlint(0))); bytelist[0] = 0 /* No function Supported */; amlappend(ifctx, amlreturn(amlbuffer(1, bytelist))); amlappend(unpatched, ifctx); /* No function is supported yet. */ bytelist[0] = 1 /* Not Supported */; amlappend(unpatched, amlreturn(amlbuffer(1, bytelist))); amlappend(method, unpatched); /* * The HDLE indicates the DSM function is issued from which device, * it is not used at this time as no function is supported yet. * Currently we make it always be 0 for all the devices and will set * the appropriate value once real function is implemented. */ amlappend(method, amlstore(amlint(0x0), amlname(\"HDLE\"))); amlappend(method, amlstore(amlarg(1), amlname(\"REVS\"))); amlappend(method, amlstore(amlarg(2), amlname(\"FUNC\"))); /* * tell QEMU about the real address of DSM memory, then QEMU * gets the control and fills the result in DSM memory. */ amlappend(method, amlstore(dsmmem, amlname(\"NTFI\"))); resultsize = amllocal(1); amlappend(method, amlstore(amlname(\"RLEN\"), resultsize)); amlappend(method, amlstore(amlshiftleft(resultsize, amlint(3)), resultsize)); amlappend(method, amlcreatefield(amlname(\"ODAT\"), amlint(0), resultsize, \"OBUF\")); amlappend(method, amlconcatenate(amlbuffer(0, NULL), amlname(\"OBUF\"), amlarg(6))); amlappend(method, amlreturn(amlarg(6))); amlappend(dev, method); } ", "target": 0}
{"func": "static gnutlsanonservercredentials vnctlsinitializeanoncred(void) { gnutlsanonservercredentials anoncred; int ret; if ((ret = gnutlsanonallocateservercredentials(&anoncred)) < 0) { \tVNCDEBUG(\"Cannot allocate credentials %s\\n\", gnutlsstrerror(ret)); \treturn NULL; } gnutlsanonsetserverdhparams(anoncred, dhparams); return anoncred; } ", "target": 0}
{"func": "static int zerosinglel2(BlockDriverState *bs, uint64t offset, unsigned int nbclusters) { BDRVQcowState *s = bs->opaque; uint64t *l2table; int l2index; int ret; int i; ret = getclustertable(bs, offset, &l2table, &l2index); if (ret < 0) { return ret; } /* Limit nbclusters to one L2 table */ nbclusters = MIN(nbclusters, s->l2size - l2index); for (i = 0; i < nbclusters; i++) { uint64t oldoffset; oldoffset = be64tocpu(l2table[l2index + i]); /* Update L2 entries */ qcow2cacheentrymarkdirty(bs, s->l2tablecache, l2table); if (oldoffset & QCOWOFLAGCOMPRESSED) { l2table[l2index + i] = cputobe64(QCOWOFLAGZERO); qcow2freeanyclusters(bs, oldoffset, 1, QCOW2DISCARDREQUEST); } else { l2table[l2index + i] |= cputobe64(QCOWOFLAGZERO); } } ret = qcow2cacheput(bs, s->l2tablecache, (void**) &l2table); if (ret < 0) { return ret; } return nbclusters; } ", "target": 0}
{"func": "static AddressSpace *s390pcidmaiommu(PCIBus *bus, void *opaque, int devfn) { S390pciState *s = opaque; return &s->pbdev[PCISLOT(devfn)].as; } ", "target": 0}
{"func": "static void testinfocommands(void) { char *resp, *info, *infobuf, *endp; infobuf = info = hmp(\"help info\"); while (*info) { /* Extract the info command, ignore parameters and description */ gassert(strncmp(info, \"info \", 5) == 0); endp = strchr(&info[5], ' '); gassert(endp != NULL); *endp = '\\0'; /* Now run the info command */ if (verbose) { fprintf(stderr, \"\\t%s\\n\", info); } resp = hmp(info); gfree(resp); /* And move forward to the next line */ info = strchr(endp + 1, '\\n'); if (!info) { break; } info += 1; } gfree(infobuf); } ", "target": 0}
{"func": "static void tcgoutmov(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg) { uint8t *oldcodeptr = s->codeptr; assert(ret != arg); #if TCGTARGETREGBITS == 32 tcgoutopt(s, INDEXopmovi32); #else tcgoutopt(s, INDEXopmovi64); #endif tcgoutr(s, ret); tcgoutr(s, arg); oldcodeptr[1] = s->codeptr - oldcodeptr; } ", "target": 0}
{"func": "static int dotokenin(USBDevice *s, USBPacket *p) { int request, value, index; int ret = 0; assert(p->devep == 0); request = (s->setupbuf[0] << 8) | s->setupbuf[1]; value = (s->setupbuf[3] << 8) | s->setupbuf[2]; index = (s->setupbuf[5] << 8) | s->setupbuf[4]; switch(s->setupstate) { case SETUPSTATEACK: if (!(s->setupbuf[0] & USBDIRIN)) { ret = usbdevicehandlecontrol(s, p, request, value, index, s->setuplen, s->databuf); if (ret == USBRETASYNC) { return USBRETASYNC; } s->setupstate = SETUPSTATEIDLE; if (ret > 0) return 0; return ret; } /* return 0 byte */ return 0; case SETUPSTATEDATA: if (s->setupbuf[0] & USBDIRIN) { int len = s->setuplen - s->setupindex; if (len > p->iov.size) { len = p->iov.size; } usbpacketcopy(p, s->databuf + s->setupindex, len); s->setupindex += len; if (s->setupindex >= s->setuplen) s->setupstate = SETUPSTATEACK; return len; } s->setupstate = SETUPSTATEIDLE; return USBRETSTALL; default: return USBRETSTALL; } } ", "target": 0}
{"func": "static int coroutinefn backupdocow(BackupBlockJob *job, int64t offset, uint64t bytes, bool *errorisread, bool iswritenotifier) { BlockBackend *blk = job->common.blk; CowRequest cowrequest; struct iovec iov; QEMUIOVector bounceqiov; void *bouncebuffer = NULL; int ret = 0; int64t start, end; /* bytes */ int n; /* bytes */ qemucorwlockrdlock(&job->flushrwlock); start = QEMUALIGNDOWN(offset, job->clustersize); end = QEMUALIGNUP(bytes + offset, job->clustersize); tracebackupdocowenter(job, start, offset, bytes); waitforoverlappingrequests(job, start, end); cowrequestbegin(&cowrequest, job, start, end); for (; start < end; start += job->clustersize) { if (testbit(start / job->clustersize, job->donebitmap)) { tracebackupdocowskip(job, start); continue; /* already copied */ } tracebackupdocowprocess(job, start); n = MIN(job->clustersize, job->common.len - start); if (!bouncebuffer) { bouncebuffer = blkblockalign(blk, job->clustersize); } iov.iovbase = bouncebuffer; iov.iovlen = n; qemuiovecinitexternal(&bounceqiov, &iov, 1); ret = blkcopreadv(blk, start, bounceqiov.size, &bounceqiov, iswritenotifier ? BDRVREQNOSERIALISING : 0); if (ret < 0) { tracebackupdocowreadfail(job, start, ret); if (errorisread) { *errorisread = true; } goto out; } if (bufferiszero(iov.iovbase, iov.iovlen)) { ret = blkcopwritezeroes(job->target, start, bounceqiov.size, BDRVREQMAYUNMAP); } else { ret = blkcopwritev(job->target, start, bounceqiov.size, &bounceqiov, job->compress ? BDRVREQWRITECOMPRESSED : 0); } if (ret < 0) { tracebackupdocowwritefail(job, start, ret); if (errorisread) { *errorisread = false; } goto out; } setbit(start / job->clustersize, job->donebitmap); /* Publish progress, guest I/O counts as progress too. Note that the * offset field is an opaque progress value, it is not a disk offset. */ job->bytesread += n; job->common.offset += n; } out: if (bouncebuffer) { qemuvfree(bouncebuffer); } cowrequestend(&cowrequest); tracebackupdocowreturn(job, offset, bytes, ret); qemucorwlockunlock(&job->flushrwlock); return ret; } ", "target": 0}
{"func": "static int injecterror(BlockDriverState *bs, BlkdebugRule *rule) { BDRVBlkdebugState *s = bs->opaque; int error = rule->options.inject.error; bool immediately = rule->options.inject.immediately; if (rule->options.inject.once) { QSIMPLEQREMOVE(&s->activerules, rule, BlkdebugRule, activenext); removerule(rule); } if (!immediately) { aiocoschedule(qemugetcurrentaiocontext(), qemucoroutineself()); qemucoroutineyield(); } return -error; } ", "target": 0}
{"func": "static void pflashwrite(pflasht *pfl, hwaddr offset, uint32t value, int width, int be) { uint8t *p; uint8t cmd; cmd = value; DPRINTF(\"%s: writing offset \" TARGETFMTplx \" value %08x width %d wcycle 0x%x\\n\", func, offset, value, width, pfl->wcycle); if (!pfl->wcycle) { /* Set the device in I/O access mode */ memoryregionromdevicesetreadable(&pfl->mem, false); } switch (pfl->wcycle) { case 0: /* read mode */ switch (cmd) { case 0x00: /* ??? */ goto resetflash; case 0x10: /* Single Byte Program */ case 0x40: /* Single Byte Program */ DPRINTF(\"%s: Single Byte Program\\n\", func); break; case 0x20: /* Block erase */ p = pfl->storage; offset &= ~(pfl->sectorlen - 1); DPRINTF(\"%s: block erase at \" TARGETFMTplx \" bytes %x\\n\", func, offset, (unsigned)pfl->sectorlen); if (!pfl->ro) { memset(p + offset, 0xff, pfl->sectorlen); pflashupdate(pfl, offset, pfl->sectorlen); } else { pfl->status |= 0x20; /* Block erase error */ } pfl->status |= 0x80; /* Ready! */ break; case 0x50: /* Clear status bits */ DPRINTF(\"%s: Clear status bits\\n\", func); pfl->status = 0x0; goto resetflash; case 0x60: /* Block (un)lock */ DPRINTF(\"%s: Block unlock\\n\", func); break; case 0x70: /* Status Register */ DPRINTF(\"%s: Read status register\\n\", func); pfl->cmd = cmd; return; case 0x90: /* Read Device ID */ DPRINTF(\"%s: Read Device information\\n\", func); pfl->cmd = cmd; return; case 0x98: /* CFI query */ DPRINTF(\"%s: CFI query\\n\", func); break; case 0xe8: /* Write to buffer */ DPRINTF(\"%s: Write to buffer\\n\", func); pfl->status |= 0x80; /* Ready! */ break; case 0xf0: /* Probe for AMD flash */ DPRINTF(\"%s: Probe for AMD flash\\n\", func); goto resetflash; case 0xff: /* Read array mode */ DPRINTF(\"%s: Read array mode\\n\", func); goto resetflash; default: goto errorflash; } pfl->wcycle++; pfl->cmd = cmd; break; case 1: switch (pfl->cmd) { case 0x10: /* Single Byte Program */ case 0x40: /* Single Byte Program */ DPRINTF(\"%s: Single Byte Program\\n\", func); if (!pfl->ro) { pflashdatawrite(pfl, offset, value, width, be); pflashupdate(pfl, offset, width); } else { pfl->status |= 0x10; /* Programming error */ } pfl->status |= 0x80; /* Ready! */ pfl->wcycle = 0; break; case 0x20: /* Block erase */ case 0x28: if (cmd == 0xd0) { /* confirm */ pfl->wcycle = 0; pfl->status |= 0x80; } else if (cmd == 0xff) { /* read array mode */ goto resetflash; } else goto errorflash; break; case 0xe8: DPRINTF(\"%s: block write of %x bytes\\n\", func, value); pfl->counter = value; pfl->wcycle++; break; case 0x60: if (cmd == 0xd0) { pfl->wcycle = 0; pfl->status |= 0x80; } else if (cmd == 0x01) { pfl->wcycle = 0; pfl->status |= 0x80; } else if (cmd == 0xff) { goto resetflash; } else { DPRINTF(\"%s: Unknown (un)locking command\\n\", func); goto resetflash; } break; case 0x98: if (cmd == 0xff) { goto resetflash; } else { DPRINTF(\"%s: leaving query mode\\n\", func); } break; default: goto errorflash; } break; case 2: switch (pfl->cmd) { case 0xe8: /* Block write */ if (!pfl->ro) { pflashdatawrite(pfl, offset, value, width, be); } else { pfl->status |= 0x10; /* Programming error */ } pfl->status |= 0x80; if (!pfl->counter) { hwaddr mask = pfl->writeblocksize - 1; mask = ~mask; DPRINTF(\"%s: block write finished\\n\", func); pfl->wcycle++; if (!pfl->ro) { /* Flush the entire write buffer onto backing storage. */ pflashupdate(pfl, offset & mask, pfl->writeblocksize); } else { pfl->status |= 0x10; /* Programming error */ } } pfl->counter--; break; default: goto errorflash; } break; case 3: /* Confirm mode */ switch (pfl->cmd) { case 0xe8: /* Block write */ if (cmd == 0xd0) { pfl->wcycle = 0; pfl->status |= 0x80; } else { DPRINTF(\"%s: unknown command for \\\"write block\\\"\\n\", func); PFLASHBUG(\"Write block confirm\"); goto resetflash; } break; default: goto errorflash; } break; default: /* Should never happen */ DPRINTF(\"%s: invalid write state\\n\", func); goto resetflash; } return; errorflash: qemulogmask(LOGUNIMP, \"%s: Unimplemented flash cmd sequence \" \"(offset \" TARGETFMTplx \", wcycle 0x%x cmd 0x%x value 0x%x)\" \"\\n\", func, offset, pfl->wcycle, pfl->cmd, value); resetflash: memoryregionromdevicesetreadable(&pfl->mem, true); pfl->bypass = 0; pfl->wcycle = 0; pfl->cmd = 0; } ", "target": 0}
{"func": "int kvminitvcpu(CPUState *cpu) { KVMState *s = kvmstate; long mmapsize; int ret; DPRINTF(\"kvminitvcpu\\n\"); ret = kvmvmioctl(s, KVMCREATEVCPU, (void *)kvmarchvcpuid(cpu)); if (ret < 0) { DPRINTF(\"kvmcreatevcpu failed\\n\"); goto err; } cpu->kvmfd = ret; cpu->kvmstate = s; cpu->kvmvcpudirty = true; mmapsize = kvmioctl(s, KVMGETVCPUMMAPSIZE, 0); if (mmapsize < 0) { ret = mmapsize; DPRINTF(\"KVMGETVCPUMMAPSIZE failed\\n\"); goto err; } cpu->kvmrun = mmap(NULL, mmapsize, PROTREAD | PROTWRITE, MAPSHARED, cpu->kvmfd, 0); if (cpu->kvmrun == MAPFAILED) { ret = -errno; DPRINTF(\"mmap'ing vcpu state failed\\n\"); goto err; } if (s->coalescedmmio && !s->coalescedmmioring) { s->coalescedmmioring = (void *)cpu->kvmrun + s->coalescedmmio * PAGESIZE; } ret = kvmarchinitvcpu(cpu); err: return ret; } ", "target": 0}
{"func": "void armcpudointerrupt(CPUState *cs) { ARMCPU *cpu = ARMCPU(cs); CPUARMState *env = &cpu->env; unsigned int newel = env->exception.targetel; assert(!armfeature(env, ARMFEATUREM)); armlogexception(cs->exceptionindex); qemulogmask(CPULOGINT, \"...from EL%d to EL%d\\n\", armcurrentel(env), newel); if (qemuloglevelmask(CPULOGINT) && !excpisinternal(cs->exceptionindex)) { qemulogmask(CPULOGINT, \"...with ESR %x/0x%\" PRIx32 \"\\n\", env->exception.syndrome >> ARMELECSHIFT, env->exception.syndrome); } if (armispscicall(cpu, cs->exceptionindex)) { armhandlepscicall(cpu); qemulogmask(CPULOGINT, \"...handled as PSCI call\\n\"); return; } /* Semihosting semantics depend on the register width of the * code that caused the exception, not the target exception level, * so must be handled here. if (checkforsemihosting(cs)) { return; } assert(!excpisinternal(cs->exceptionindex)); if (armelisaa64(env, newel)) { armcpudointerruptaarch64(cs); } else { armcpudointerruptaarch32(cs); } armcallelchangehook(cpu); if (!kvmenabled()) { cs->interruptrequest |= CPUINTERRUPTEXITTB; } }", "target": 1}
{"func": "static void virtionetflushtx(VirtIONet *n, VirtQueue *vq) { VirtQueueElement elem; if (!(n->vdev.status & VIRTIOCONFIGSDRIVEROK)) return; if (n->asynctx.elem.outnum) { virtioqueuesetnotification(n->txvq, 0); return; } while (virtqueuepop(vq, &elem)) { ssizet ret, len = 0; unsigned int outnum = elem.outnum; struct iovec *outsg = &elem.outsg[0]; unsigned hdrlen; /* hdrlen refers to the header received from the guest */ hdrlen = n->mergeablerxbufs ? sizeof(struct virtionethdrmrgrxbuf) : sizeof(struct virtionethdr); if (outnum < 1 || outsg->iovlen != hdrlen) { fprintf(stderr, \"virtio-net header not in first element\\n\"); exit(1); } /* ignore the header if GSO is not supported */ if (!n->hasvnethdr) { outnum--; outsg++; len += hdrlen; } else if (n->mergeablerxbufs) { /* tapfd expects a struct virtionethdr */ hdrlen -= sizeof(struct virtionethdr); outsg->iovlen -= hdrlen; len += hdrlen; } ret = qemusendvpacketasync(&n->nic->nc, outsg, outnum, virtionettxcomplete); if (ret == 0) { virtioqueuesetnotification(n->txvq, 0); n->asynctx.elem = elem; n->asynctx.len = len; return; } len += ret; virtqueuepush(vq, &elem, len); virtionotify(&n->vdev, vq); } } ", "target": 1}
{"func": "static void flushqueueddata(VirtIOSerialPort *port, bool discard) { assert(port || discard); doflushqueueddata(port, port->ovq, &port->vser->vdev, discard); } ", "target": 1}
{"func": "static int hdevopen(BlockDriverState *bs, QDict *options, int flags, Error **errp) { BDRVRawState *s = bs->opaque; Error *localerr = NULL; int ret; #if defined(APPLE) && defined(MACH) const char *filename = qdictgetstr(options, \"filename\"); char bsdpath[MAXPATHLEN] = \"\"; bool erroroccurred = false; /* If using a real cdrom */ if (strcmp(filename, \"/dev/cdrom\") == 0) { char *mediaType = NULL; kernreturnt retval; ioiteratort mediaIterator = 0; mediaType = FindEjectableOpticalMedia(&mediaIterator); if (mediaType == NULL) { errorsetg(errp, \"Please make sure your CD/DVD is in the optical\" \" drive\"); erroroccurred = true; goto hdevopenMacerror; } retval = GetBSDPath(mediaIterator, bsdpath, sizeof(bsdpath), flags); if (retval != KERNSUCCESS) { errorsetg(errp, \"Could not get BSD path for optical drive\"); erroroccurred = true; goto hdevopenMacerror; } /* If a real optical drive was not found */ if (bsdpath[0] == '\\0') { errorsetg(errp, \"Failed to obtain bsd path for optical drive\"); erroroccurred = true; goto hdevopenMacerror; } /* If using a cdrom disc and finding a partition on the disc failed */ if (strncmp(mediaType, kIOCDMediaClass, 9) == 0 && setupcdrom(bsdpath, errp) == false) { printunmountingdirections(bsdpath); erroroccurred = true; goto hdevopenMacerror; } qdictput(options, \"filename\", qstringfromstr(bsdpath)); hdevopenMacerror: gfree(mediaType); if (mediaIterator) { IOObjectRelease(mediaIterator); } if (erroroccurred) { return -ENOENT; } } #endif /* defined(APPLE) && defined(MACH) */ s->type = FTYPEFILE; ret = rawopencommon(bs, options, flags, 0, &localerr); if (ret < 0) { errorpropagate(errp, localerr); #if defined(APPLE) && defined(MACH) if (*bsdpath) { filename = bsdpath; } /* if a physical device experienced an error while being opened */ if (strncmp(filename, \"/dev/\", 5) == 0) { printunmountingdirections(filename); } #endif /* defined(APPLE) && defined(MACH) */ return ret; } /* Since this does ioctl the device must be already opened */ bs->sg = hdevissg(bs); if (flags & BDRVORDWR) { ret = checkhdevwritable(s); if (ret < 0) { rawclose(bs); errorsetgerrno(errp, -ret, \"The device is not writable\"); return ret; } } return ret; }", "target": 1}
{"func": "int scsibuslegacyhandlecmdline(SCSIBus *bus) { Location loc; DriveInfo *dinfo; int res = 0, unit; locpushnone(&loc); for (unit = 0; unit < bus->info->maxtarget; unit++) { dinfo = driveget(IFSCSI, bus->busnr, unit); if (dinfo == NULL) { continue; } qemuoptslocrestore(dinfo->opts); if (!scsibuslegacyadddrive(bus, dinfo->bdrv, unit, false, -1)) { res = -1; break; } } locpop(&loc); return res; } ", "target": 1}
{"func": "static int linkfilterinouts(AVFilterContext *filtctx, AVFilterInOut **currinputs, AVFilterInOut **openinputs, AVClass *logctx) { int pad = filtctx->inputcount, ret; while (pad--) { AVFilterInOut *p = *currinputs; if (!p) { avlog(logctx, AVLOGERROR, \"Not enough inputs specified for the \\\"%s\\\" filter.\\n\", filtctx->filter->name); return AVERROR(EINVAL); } *currinputs = (*currinputs)->next; if (p->filter) { if ((ret = linkfilter(p->filter, p->padidx, filtctx, pad, logctx)) < 0) return ret; avfree(p->name); avfree(p); } else { p->filter = filtctx; p->padidx = pad; insertinout(openinputs, p); } } if (*currinputs) { avlog(logctx, AVLOGERROR, \"Too many inputs specified for the \\\"%s\\\" filter.\\n\", filtctx->filter->name); return AVERROR(EINVAL); } pad = filtctx->outputcount; while (pad--) { AVFilterInOut *currlinkn = avmallocz(sizeof(AVFilterInOut)); currlinkn->filter = filtctx; currlinkn->padidx = pad; insertinout(currinputs, currlinkn); } return 0; }", "target": 1}
{"func": "static void x86cpucommonclassinit(ObjectClass *oc, void *data) { X86CPUClass *xcc = X86CPUCLASS(oc); CPUClass *cc = CPUCLASS(oc); DeviceClass *dc = DEVICECLASS(oc); xcc->parentrealize = dc->realize; dc->realize = x86cpurealizefn; dc->bustype = TYPEICCBUS; dc->props = x86cpuproperties; xcc->parentreset = cc->reset; cc->reset = x86cpureset; cc->resetdumpflags = CPUDUMPFPU | CPUDUMPCCOP; cc->classbyname = x86cpuclassbyname; cc->parsefeatures = x86cpuparsefeaturestr; cc->haswork = x86cpuhaswork; cc->dointerrupt = x86cpudointerrupt; cc->cpuexecinterrupt = x86cpuexecinterrupt; cc->dumpstate = x86cpudumpstate; cc->setpc = x86cpusetpc; cc->synchronizefromtb = x86cpusynchronizefromtb; cc->gdbreadregister = x86cpugdbreadregister; cc->gdbwriteregister = x86cpugdbwriteregister; cc->getarchid = x86cpugetarchid; cc->getpagingenabled = x86cpugetpagingenabled; #ifdef CONFIGUSERONLY cc->handlemmufault = x86cpuhandlemmufault; #else cc->getmemorymapping = x86cpugetmemorymapping; cc->getphyspagedebug = x86cpugetphyspagedebug; cc->writeelf64note = x86cpuwriteelf64note; cc->writeelf64qemunote = x86cpuwriteelf64qemunote; cc->writeelf32note = x86cpuwriteelf32note; cc->writeelf32qemunote = x86cpuwriteelf32qemunote; cc->vmsd = &vmstatex86cpu; #endif cc->gdbnumcoreregs = CPUNBREGS * 2 + 25; #ifndef CONFIGUSERONLY cc->debugexcphandler = breakpointhandler; #endif cc->cpuexecenter = x86cpuexecenter; cc->cpuexecexit = x86cpuexecexit; } ", "target": 0}
{"func": "static int qpainitin (HWVoiceIn *hw, audsettingst *as) { int error; static pasamplespec ss; audsettingst obtas = *as; PAVoiceIn *pa = (PAVoiceIn *) hw; ss.format = audfmttopa (as->fmt, as->endianness); ss.channels = as->nchannels; ss.rate = as->freq; obtas.fmt = patoaudfmt (ss.format, &obtas.endianness); pa->s = pasimplenew ( conf.server, \"qemu\", PASTREAMRECORD, conf.source, \"pcm.capture\", &ss, NULL, /* channel map */ NULL, /* buffering attributes */ &error ); if (!pa->s) { qpalogerr (error, \"pasimplenew for capture failed\\n\"); goto fail1; } audiopcminitinfo (&hw->info, &obtas); hw->samples = conf.samples; pa->pcmbuf = audiocalloc (AUDIOFUNC, hw->samples, 1 << hw->info.shift); if (!pa->pcmbuf) { dolog (\"Could not allocate buffer (%d bytes)\\n\", hw->samples << hw->info.shift); goto fail2; } if (audioptinit (&pa->pt, qpathreadin, hw, AUDIOCAP, AUDIOFUNC)) { goto fail3; } return 0; fail3: free (pa->pcmbuf); pa->pcmbuf = NULL; fail2: pasimplefree (pa->s); pa->s = NULL; fail1: return -1; } ", "target": 0}
{"func": "uint32t helpercomputefprf (uint64t arg, uint32t setfprf) { CPUDoubleU farg; int isneg; int ret; farg.ll = arg; isneg = float64isneg(farg.d); if (unlikely(float64isnan(farg.d))) { if (float64issignalingnan(farg.d)) { /* Signaling NaN: flags are undefined */ ret = 0x00; } else { /* Quiet NaN */ ret = 0x11; } } else if (unlikely(float64isinfinity(farg.d))) { /* +/- infinity */ if (isneg) ret = 0x09; else ret = 0x05; } else { if (float64iszero(farg.d)) { /* +/- zero */ if (isneg) ret = 0x12; else ret = 0x02; } else { if (isden(farg.d)) { /* Denormalized numbers */ ret = 0x10; } else { /* Normalized numbers */ ret = 0x00; } if (isneg) { ret |= 0x08; } else { ret |= 0x04; } } } if (setfprf) { /* We update FPSCRFPRF */ env->fpscr &= ~(0x1F << FPSCRFPRF); env->fpscr |= ret << FPSCRFPRF; } /* We just need fpcc to update Rc1 */ return ret & 0xF; } ", "target": 0}
{"func": "void vgaioportwrite(void *opaque, uint32t addr, uint32t val) { VGACommonState *s = opaque; int index; /* check port range access depending on color/monochrome mode */ if (vgaioportinvalid(s, addr)) { return; } #ifdef DEBUGVGA printf(\"VGA: write addr=0x%04x data=0x%02x\\n\", addr, val); #endif switch(addr) { case VGAATTW: if (s->arflipflop == 0) { val &= 0x3f; s->arindex = val; } else { index = s->arindex & 0x1f; switch(index) { case VGAATCPALETTE0 ... VGAATCPALETTEF: s->ar[index] = val & 0x3f; break; case VGAATCMODE: s->ar[index] = val & ~0x10; break; case VGAATCOVERSCAN: s->ar[index] = val; break; case VGAATCPLANEENABLE: s->ar[index] = val & ~0xc0; break; case VGAATCPEL: s->ar[index] = val & ~0xf0; break; case VGAATCCOLORPAGE: s->ar[index] = val & ~0xf0; break; default: break; } } s->arflipflop ^= 1; break; case VGAMISW: s->msr = val & ~0x10; s->updateretraceinfo(s); break; case VGASEQI: s->srindex = val & 7; break; case VGASEQD: #ifdef DEBUGVGAREG printf(\"vga: write SR%x = 0x%02x\\n\", s->srindex, val); #endif s->sr[s->srindex] = val & srmask[s->srindex]; if (s->srindex == VGASEQCLOCKMODE) { s->updateretraceinfo(s); } vgaupdatememoryaccess(s); break; case VGAPELIR: s->dacreadindex = val; s->dacsubindex = 0; s->dacstate = 3; break; case VGAPELIW: s->dacwriteindex = val; s->dacsubindex = 0; s->dacstate = 0; break; case VGAPELD: s->daccache[s->dacsubindex] = val; if (++s->dacsubindex == 3) { memcpy(&s->palette[s->dacwriteindex * 3], s->daccache, 3); s->dacsubindex = 0; s->dacwriteindex++; } break; case VGAGFXI: s->grindex = val & 0x0f; break; case VGAGFXD: #ifdef DEBUGVGAREG printf(\"vga: write GR%x = 0x%02x\\n\", s->grindex, val); #endif s->gr[s->grindex] = val & grmask[s->grindex]; vgaupdatememoryaccess(s); break; case VGACRTIM: case VGACRTIC: s->crindex = val; break; case VGACRTDM: case VGACRTDC: #ifdef DEBUGVGAREG printf(\"vga: write CR%x = 0x%02x\\n\", s->crindex, val); #endif /* handle CR0-7 protection */ if (s->cr[VGACRTCVSYNCEND] & VGACR11LOCKCR0CR7) { if (s->crindex <= VGACRTCOVERFLOW) { /* can always write bit 4 of CR7 */ if (s->crindex == VGACRTCOVERFLOW) { s->cr[VGACRTCOVERFLOW] = (s->cr[VGACRTCOVERFLOW] & ~0x10) | (val & 0x10); } return; } else if ((vgacgahacks & VGACGAHACKFONTHEIGHT) && !(s->sr[VGASEQCLOCKMODE] & VGASR01CHARCLK8DOTS)) { /* extra CGA compatibility hacks (not in standard VGA) */ if (s->crindex == VGACRTCMAXSCAN && val == 7 && (s->cr[VGACRTCMAXSCAN] & 0xf) == 0xf) { return; } else if (s->crindex == VGACRTCCURSORSTART && val == 6 && (s->cr[VGACRTCMAXSCAN] & 0xf) == 0xf) { val = 0xd; } else if (s->crindex == VGACRTCCURSOREND && val == 7 && (s->cr[VGACRTCMAXSCAN] & 0xf) == 0xf) { val = 0xe; } } } s->cr[s->crindex] = val; switch(s->crindex) { case VGACRTCHTOTAL: case VGACRTCHSYNCSTART: case VGACRTCHSYNCEND: case VGACRTCVTOTAL: case VGACRTCOVERFLOW: case VGACRTCVSYNCEND: case VGACRTCMODE: s->updateretraceinfo(s); break; } break; case VGAIS1RM: case VGAIS1RC: s->fcr = val & 0x10; break; } } ", "target": 0}
{"func": "static int usbnetcanreceive(NetClientState *nc) { USBNetState *s = qemugetnicopaque(nc); if (!s->dev.config) { return 0; } if (isrndis(s) && s->rndisstate != RNDISDATAINITIALIZED) { return 1; } return !s->inlen; } ", "target": 0}
{"func": "static void dhcpdecode(const uint8t *buf, int size, int *pmsgtype) { const uint8t *p, *pend; int len, tag; *pmsgtype = 0; p = buf; pend = buf + size; if (size < 5) return; if (memcmp(p, rfc1533cookie, 4) != 0) return; p += 4; while (p < pend) { tag = p[0]; if (tag == RFC1533PAD) { p++; } else if (tag == RFC1533END) { break; } else { p++; if (p >= pend) break; len = *p++; dprintf(\"dhcp: tag=0x%02x len=%d\\n\", tag, len); switch(tag) { case RFC2132MSGTYPE: if (len >= 1) *pmsgtype = p[0]; break; default: break; } p += len; } } } ", "target": 0}
{"func": "static int xhcifirectltransfer(XHCIState *xhci, XHCITransfer *xfer) { XHCITRB *trbsetup, *trbstatus; uint8t bmRequestType; trbsetup = &xfer->trbs[0]; trbstatus = &xfer->trbs[xfer->trbcount-1]; traceusbxhcixferstart(xfer, xfer->epctx->slotid, xfer->epctx->epid, xfer->streamid); /* at most one Event Data TRB allowed after STATUS */ if (TRBTYPE(*trbstatus) == TREVDATA && xfer->trbcount > 2) { trbstatus--; } /* do some sanity checks */ if (TRBTYPE(*trbsetup) != TRSETUP) { DPRINTF(\"xhci: ep0 first TD not SETUP: %d\\n\", TRBTYPE(*trbsetup)); return -1; } if (TRBTYPE(*trbstatus) != TRSTATUS) { DPRINTF(\"xhci: ep0 last TD not STATUS: %d\\n\", TRBTYPE(*trbstatus)); return -1; } if (!(trbsetup->control & TRBTRIDT)) { DPRINTF(\"xhci: Setup TRB doesn't have IDT set\\n\"); return -1; } if ((trbsetup->status & 0x1ffff) != 8) { DPRINTF(\"xhci: Setup TRB has bad length (%d)\\n\", (trbsetup->status & 0x1ffff)); return -1; } bmRequestType = trbsetup->parameter; xfer->inxfer = bmRequestType & USBDIRIN; xfer->isoxfer = false; xfer->timedxfer = false; if (xhcisetuppacket(xfer) < 0) { return -1; } xfer->packet.parameter = trbsetup->parameter; usbhandlepacket(xfer->packet.ep->dev, &xfer->packet); xhcitrycompletepacket(xfer); if (!xfer->runningasync && !xfer->runningretry) { xhcikickepctx(xfer->epctx, 0); } return 0; } ", "target": 0}
{"func": "void qemufreetimer(QEMUTimer *ts) { gfree(ts); } ", "target": 0}
{"func": "static avcold int dvdsubclose(AVCodecContext *avctx) { DVDSubContext *ctx = avctx->privdata; avfreep(&ctx->buf); ctx->bufsize = 0; return 0; } ", "target": 1}
{"func": "static int scsidiskemulatereadtoc(SCSIRequest *req, uint8t *outbuf) { SCSIDiskState *s = DOUPCAST(SCSIDiskState, qdev, req->dev); int starttrack, format, msf, toclen; uint64t nbsectors; msf = req->cmd.buf[1] & 2; format = req->cmd.buf[2] & 0xf; starttrack = req->cmd.buf[6]; bdrvgetgeometry(s->qdev.conf.bs, &nbsectors); DPRINTF(\"Read TOC (track %d format %d msf %d)\\n\", starttrack, format, msf >> 1); nbsectors /= s->qdev.blocksize / 512; switch (format) { case 0: toclen = cdromreadtoc(nbsectors, outbuf, msf, starttrack); break; case 1: /* multi session : only a single session defined */ toclen = 12; memset(outbuf, 0, 12); outbuf[1] = 0x0a; outbuf[2] = 0x01; outbuf[3] = 0x01; break; case 2: toclen = cdromreadtocraw(nbsectors, outbuf, msf, starttrack); break; default: return -1; } return toclen; } ", "target": 0}
{"func": "void bdrvinvalidatecache(BlockDriverState *bs, Error **errp) { Error *localerr = NULL; int ret; if (!bs->drv) { return; } if (!(bs->openflags & BDRVOINACTIVE)) { return; } bs->openflags &= ~BDRVOINACTIVE; if (bs->drv->bdrvinvalidatecache) { bs->drv->bdrvinvalidatecache(bs, &localerr); } else if (bs->file) { bdrvinvalidatecache(bs->file->bs, &localerr); } if (localerr) { bs->openflags |= BDRVOINACTIVE; errorpropagate(errp, localerr); return; } ret = refreshtotalsectors(bs, bs->totalsectors); if (ret < 0) { bs->openflags |= BDRVOINACTIVE; errorsetgerrno(errp, -ret, \"Could not refresh total sector count\"); return; } } ", "target": 0}
{"func": "static int usbuhcivt82c686binitfn(PCIDevice *dev) { UHCIState *s = DOUPCAST(UHCIState, dev, dev); uint8t *pciconf = s->dev.config; pciconfigsetvendorid(pciconf, PCIVENDORIDVIA); pciconfigsetdeviceid(pciconf, PCIDEVICEIDVIAUHCI); /* USB misc control 1/2 */ pcisetlong(pciconf + 0x40,0x00001000); /* PM capability */ pcisetlong(pciconf + 0x80,0x00020001); /* USB legacy support */ pcisetlong(pciconf + 0xc0,0x00002000); return usbuhcicommoninitfn(s); } ", "target": 0}
{"func": "static inline int geniwmmxtshift(uint32t insn, uint32t mask, TCGv dest) { int rd = (insn >> 0) & 0xf; TCGv tmp; if (insn & (1 << 8)) { if (rd < ARMIWMMXTwCGR0 || rd > ARMIWMMXTwCGR3) { return 1; } else { tmp = iwmmxtloadcreg(rd); } } else { tmp = newtmp(); iwmmxtloadreg(cpuV0, rd); tcggentrunci64i32(tmp, cpuV0); } tcggenandii32(tmp, tmp, mask); tcggenmovi32(dest, tmp); deadtmp(tmp); return 0; } ", "target": 1}
{"func": "static void vfiovgaprobenvidia3d0quirk(VFIOPCIDevice *vdev) { VFIOQuirk *quirk; VFIONvidia3d0Quirk *data; if (!vfiopciis(vdev, PCIVENDORIDNVIDIA, PCIANYID) || !vdev->bars[1].region.size) { return; } quirk = gmalloc0(sizeof(*quirk)); quirk->data = data = gmalloc0(sizeof(*data)); quirk->mem = gmalloc0(sizeof(MemoryRegion) * 2); quirk->nrmem = 2; data->vdev = vdev; memoryregioninitio(&quirk->mem[0], OBJECT(vdev), &vfionvidia3d4quirk, data, \"vfio-nvidia-3d4-quirk\", 2); memoryregionaddsubregion(&vdev->vga.region[QEMUPCIVGAIOHI].mem, 0x14 /* 0x3c0 + 0x14 */, &quirk->mem[0]); memoryregioninitio(&quirk->mem[1], OBJECT(vdev), &vfionvidia3d0quirk, data, \"vfio-nvidia-3d0-quirk\", 2); memoryregionaddsubregion(&vdev->vga.region[QEMUPCIVGAIOHI].mem, 0x10 /* 0x3c0 + 0x10 */, &quirk->mem[1]); QLISTINSERTHEAD(&vdev->vga.region[QEMUPCIVGAIOHI].quirks, quirk, next); tracevfioquirknvidia3d0probe(vdev->vbasedev.name); } ", "target": 1}
{"func": "static int cookiestring(AVDictionary *dict, char **cookies) { AVDictionaryEntry *e = NULL; int len = 1; // determine how much memory is needed for the cookies string while (e = avdictget(dict, \"\", e, AVDICTIGNORESUFFIX)) len += strlen(e->key) + strlen(e->value) + 1; // reallocate the cookies e = NULL; if (*cookies) avfree(*cookies); *cookies = avmalloc(len); if (!cookies) return AVERROR(ENOMEM); *cookies[0] = '\\0'; // write out the cookies while (e = avdictget(dict, \"\", e, AVDICTIGNORESUFFIX)) avstrlcatf(*cookies, len, \"%s%s\\n\", e->key, e->value); return 0; } ", "target": 0}
{"func": "static int getphysicaladdress (CPUMIPSState *env, hwaddr *physical, int *prot, targetulong realaddress, int rw, int accesstype) { /* User mode can only access useg/xuseg */ int usermode = (env->hflags & MIPSHFLAGMODE) == MIPSHFLAGUM; int supervisormode = (env->hflags & MIPSHFLAGMODE) == MIPSHFLAGSM; int kernelmode = !usermode && !supervisormode; #if defined(TARGETMIPS64) int UX = (env->CP0Status & (1 << CP0StUX)) != 0; int SX = (env->CP0Status & (1 << CP0StSX)) != 0; int KX = (env->CP0Status & (1 << CP0StKX)) != 0; #endif int ret = TLBRETMATCH; /* effective address (modified for KVM T&E kernel segments) */ targetulong address = realaddress; #define USEGLIMIT 0x7FFFFFFFUL #define KSEG0BASE 0x80000000UL #define KSEG1BASE 0xA0000000UL #define KSEG2BASE 0xC0000000UL #define KSEG3BASE 0xE0000000UL #define KVMKSEG0BASE 0x40000000UL #define KVMKSEG2BASE 0x60000000UL if (kvmenabled()) { /* KVM T&E adds guest kernel segments in useg */ if (realaddress >= KVMKSEG0BASE) { if (realaddress < KVMKSEG2BASE) { /* kseg0 */ address += KSEG0BASE - KVMKSEG0BASE; } else if (realaddress <= USEGLIMIT) { /* kseg2/3 */ address += KSEG2BASE - KVMKSEG2BASE; } } } if (address <= USEGLIMIT) { /* useg */ if (env->CP0Status & (1 << CP0StERL)) { *physical = address & 0xFFFFFFFF; *prot = PAGEREAD | PAGEWRITE; } else { ret = env->tlb->mapaddress(env, physical, prot, realaddress, rw, accesstype); } #if defined(TARGETMIPS64) } else if (address < 0x4000000000000000ULL) { /* xuseg */ if (UX && address <= (0x3FFFFFFFFFFFFFFFULL & env->SEGMask)) { ret = env->tlb->mapaddress(env, physical, prot, realaddress, rw, accesstype); } else { ret = TLBRETBADADDR; } } else if (address < 0x8000000000000000ULL) { /* xsseg */ if ((supervisormode || kernelmode) && SX && address <= (0x7FFFFFFFFFFFFFFFULL & env->SEGMask)) { ret = env->tlb->mapaddress(env, physical, prot, realaddress, rw, accesstype); } else { ret = TLBRETBADADDR; } } else if (address < 0xC000000000000000ULL) { /* xkphys */ if (kernelmode && KX && (address & 0x07FFFFFFFFFFFFFFULL) <= env->PAMask) { *physical = address & env->PAMask; *prot = PAGEREAD | PAGEWRITE; } else { ret = TLBRETBADADDR; } } else if (address < 0xFFFFFFFF80000000ULL) { /* xkseg */ if (kernelmode && KX && address <= (0xFFFFFFFF7FFFFFFFULL & env->SEGMask)) { ret = env->tlb->mapaddress(env, physical, prot, realaddress, rw, accesstype); } else { ret = TLBRETBADADDR; } #endif } else if (address < (int32t)KSEG1BASE) { /* kseg0 */ if (kernelmode) { *physical = address - (int32t)KSEG0BASE; *prot = PAGEREAD | PAGEWRITE; } else { ret = TLBRETBADADDR; } } else if (address < (int32t)KSEG2BASE) { /* kseg1 */ if (kernelmode) { *physical = address - (int32t)KSEG1BASE; *prot = PAGEREAD | PAGEWRITE; } else { ret = TLBRETBADADDR; } } else if (address < (int32t)KSEG3BASE) { /* sseg (kseg2) */ if (supervisormode || kernelmode) { ret = env->tlb->mapaddress(env, physical, prot, realaddress, rw, accesstype); } else { ret = TLBRETBADADDR; } } else { /* kseg3 */ /* XXX: debug segment is not emulated */ if (kernelmode) { ret = env->tlb->mapaddress(env, physical, prot, realaddress, rw, accesstype); } else { ret = TLBRETBADADDR; } } return ret; } ", "target": 1}
{"func": "static int gethtabfd(sPAPRMachineState *spapr) { if (spapr->htabfd >= 0) { return spapr->htabfd; } spapr->htabfd = kvmppcgethtabfd(false); if (spapr->htabfd < 0) { errorreport(\"Unable to open fd for reading hash table from KVM: %s\", strerror(errno)); } return spapr->htabfd; } ", "target": 1}
{"func": "static void qobjectinputstartlist(Visitor *v, const char *name, GenericList **list, sizet size, Error **errp) { QObjectInputVisitor *qiv = toqiv(v); QObject *qobj = qobjectinputgetobject(qiv, name, true, errp); const QListEntry *entry; if (list) { *list = NULL; } if (!qobj) { return; } if (qobjecttype(qobj) != QTYPEQLIST) { errorsetg(errp, QERRINVALIDPARAMETERTYPE, name ? name : \"null\", \"list\"); return; } entry = qobjectinputpush(qiv, qobj, list); if (entry && list) { *list = gmalloc0(size); } } ", "target": 1}
{"func": "static void testqgafilewriteread(gconstpointer fix) { const TestFixture *fixture = fix; const unsigned char helloworld[] = \"Hello World!\\n\"; const char *b64; gchar *cmd, *enc; QDict *ret, *val; int64t id, eof; gsize count; /* open */ ret = qmpfd(fixture->fd, \"{'execute': 'guest-file-open',\" \" 'arguments': { 'path': 'foo', 'mode': 'w+' } }\"); gassertnonnull(ret); qmpassertnoerror(ret); id = qdictgetint(ret, \"return\"); QDECREF(ret); enc = gbase64encode(helloworld, sizeof(helloworld)); /* write */ cmd = gstrdupprintf(\"{'execute': 'guest-file-write',\" \" 'arguments': { 'handle': %\" PRId64 \",\" \" 'buf-b64': '%s' } }\", id, enc); ret = qmpfd(fixture->fd, cmd); gassertnonnull(ret); qmpassertnoerror(ret); val = qdictgetqdict(ret, \"return\"); count = qdictgetint(val, \"count\"); eof = qdictgetbool(val, \"eof\"); gassertcmpint(count, ==, sizeof(helloworld)); gassertcmpint(eof, ==, 0); QDECREF(ret); gfree(cmd); /* read (check implicit flush) */ cmd = gstrdupprintf(\"{'execute': 'guest-file-read',\" \" 'arguments': { 'handle': %\" PRId64 \"} }\", id); ret = qmpfd(fixture->fd, cmd); val = qdictgetqdict(ret, \"return\"); count = qdictgetint(val, \"count\"); eof = qdictgetbool(val, \"eof\"); b64 = qdictgetstr(val, \"buf-b64\"); gassertcmpint(count, ==, 0); gassert(eof); gassertcmpstr(b64, ==, \"\"); QDECREF(ret); gfree(cmd); /* seek to 0 */ cmd = gstrdupprintf(\"{'execute': 'guest-file-seek',\" \" 'arguments': { 'handle': %\" PRId64 \", \" \" 'offset': %d, 'whence': %d } }\", id, 0, SEEKSET); ret = qmpfd(fixture->fd, cmd); qmpassertnoerror(ret); val = qdictgetqdict(ret, \"return\"); count = qdictgetint(val, \"position\"); eof = qdictgetbool(val, \"eof\"); gassertcmpint(count, ==, 0); gassert(!eof); QDECREF(ret); gfree(cmd); /* read */ cmd = gstrdupprintf(\"{'execute': 'guest-file-read',\" \" 'arguments': { 'handle': %\" PRId64 \"} }\", id); ret = qmpfd(fixture->fd, cmd); val = qdictgetqdict(ret, \"return\"); count = qdictgetint(val, \"count\"); eof = qdictgetbool(val, \"eof\"); b64 = qdictgetstr(val, \"buf-b64\"); gassertcmpint(count, ==, sizeof(helloworld)); gassert(eof); gassertcmpstr(b64, ==, enc); QDECREF(ret); gfree(cmd); gfree(enc); /* close */ cmd = gstrdupprintf(\"{'execute': 'guest-file-close',\" \" 'arguments': {'handle': %\" PRId64 \"} }\", id); ret = qmpfd(fixture->fd, cmd); QDECREF(ret); gfree(cmd); } ", "target": 0}
{"func": "static void testvisitoroutnativelistuint16(TestOutputVisitorData *data, const void *unused) { testnativelist(data, unused, USERDEFNATIVELISTUNIONKINDU16); } ", "target": 0}
{"func": "static int xen9pfsconnect(struct XenDevice *xendev) { int i; Xen9pfsDev *xen9pdev = containerof(xendev, Xen9pfsDev, xendev); V9fsState *s = &xen9pdev->state; QemuOpts *fsdev; if (xenstorereadfeint(&xen9pdev->xendev, \"num-rings\", &xen9pdev->numrings) == -1 || xen9pdev->numrings > MAXRINGS || xen9pdev->numrings < 1) { return -1; } xen9pdev->rings = gmalloc0(xen9pdev->numrings * sizeof(Xen9pfsRing)); for (i = 0; i < xen9pdev->numrings; i++) { char *str; int ringorder; xen9pdev->rings[i].priv = xen9pdev; xen9pdev->rings[i].evtchn = -1; xen9pdev->rings[i].localport = -1; str = gstrdupprintf(\"ring-ref%u\", i); if (xenstorereadfeint(&xen9pdev->xendev, str, &xen9pdev->rings[i].ref) == -1) { gfree(str); goto out; } gfree(str); str = gstrdupprintf(\"event-channel-%u\", i); if (xenstorereadfeint(&xen9pdev->xendev, str, &xen9pdev->rings[i].evtchn) == -1) { gfree(str); goto out; } gfree(str); xen9pdev->rings[i].intf = xengnttabmapgrantref( xen9pdev->xendev.gnttabdev, xen9pdev->xendev.dom, xen9pdev->rings[i].ref, PROTREAD | PROTWRITE); if (!xen9pdev->rings[i].intf) { goto out; } ringorder = xen9pdev->rings[i].intf->ringorder; if (ringorder > MAXRINGORDER) { goto out; } xen9pdev->rings[i].ringorder = ringorder; xen9pdev->rings[i].data = xengnttabmapdomaingrantrefs( xen9pdev->xendev.gnttabdev, (1 << ringorder), xen9pdev->xendev.dom, xen9pdev->rings[i].intf->ref, PROTREAD | PROTWRITE); if (!xen9pdev->rings[i].data) { goto out; } xen9pdev->rings[i].ring.in = xen9pdev->rings[i].data; xen9pdev->rings[i].ring.out = xen9pdev->rings[i].data + XENFLEXRINGSIZE(ringorder); xen9pdev->rings[i].bh = qemubhnew(xen9pfsbh, &xen9pdev->rings[i]); xen9pdev->rings[i].outcons = 0; xen9pdev->rings[i].outsize = 0; xen9pdev->rings[i].inprogress = false; xen9pdev->rings[i].evtchndev = xenevtchnopen(NULL, 0); if (xen9pdev->rings[i].evtchndev == NULL) { goto out; } fcntl(xenevtchnfd(xen9pdev->rings[i].evtchndev), FSETFD, FDCLOEXEC); xen9pdev->rings[i].localport = xenevtchnbindinterdomain (xen9pdev->rings[i].evtchndev, xendev->dom, xen9pdev->rings[i].evtchn); if (xen9pdev->rings[i].localport == -1) { xenpvprintf(xendev, 0, \"xenevtchnbindinterdomain failed port=%d\\n\", xen9pdev->rings[i].evtchn); goto out; } xenpvprintf(xendev, 2, \"bind evtchn port %d\\n\", xendev->localport); qemusetfdhandler(xenevtchnfd(xen9pdev->rings[i].evtchndev), xen9pfsevtchnevent, NULL, &xen9pdev->rings[i]); } xen9pdev->securitymodel = xenstorereadbestr(xendev, \"securitymodel\"); xen9pdev->path = xenstorereadbestr(xendev, \"path\"); xen9pdev->id = s->fsconf.fsdevid = gstrdupprintf(\"xen9p%d\", xendev->dev); xen9pdev->tag = s->fsconf.tag = xenstorereadfestr(xendev, \"tag\"); v9fsregistertransport(s, &xen9ptransport); fsdev = qemuoptscreate(qemufindopts(\"fsdev\"), s->fsconf.tag, 1, NULL); qemuoptset(fsdev, \"fsdriver\", \"local\", NULL); qemuoptset(fsdev, \"path\", xen9pdev->path, NULL); qemuoptset(fsdev, \"securitymodel\", xen9pdev->securitymodel, NULL); qemuoptssetid(fsdev, s->fsconf.fsdevid); qemufsdevadd(fsdev); v9fsdevicerealizecommon(s, NULL); return 0; out: xen9pfsfree(xendev); return -1; } ", "target": 0}
{"func": "static void tcgoptgenmov(TCGContext *s, TCGOp *op, TCGArg *args, TCGArg dst, TCGArg src) { if (tempsarecopies(dst, src)) { tcgopremove(s, op); return; } if (tempisconst(src)) { tcgoptgenmovi(s, op, args, dst, temps[src].val); return; } TCGOpcode newop = optomov(op->opc); tcgtargetulong mask; op->opc = newop; resettemp(dst); mask = temps[src].mask; if (TCGTARGETREGBITS > 32 && newop == INDEXopmovi32) { /* High bits of the destination are now garbage. */ mask |= ~0xffffffffull; } temps[dst].mask = mask; assert(!tempisconst(src)); if (s->temps[src].type == s->temps[dst].type) { temps[dst].nextcopy = temps[src].nextcopy; temps[dst].prevcopy = src; temps[temps[dst].nextcopy].prevcopy = dst; temps[src].nextcopy = dst; temps[dst].isconst = false; } args[0] = dst; args[1] = src; } ", "target": 0}
{"func": "avcold void ffdsputilinitvis(DSPContext *c, AVCodecContext *avctx) { /* VIS-specific optimizations */ int accel = vislevel (); const int highbitdepth = avctx->bitsperrawsample > 8; if (accel & ACCELSPARCVIS) { if (avctx->bitsperrawsample <= 8 && avctx->idctalgo == FFIDCTSIMPLEVIS) { c->idctput = ffsimpleidctputvis; c->idctadd = ffsimpleidctaddvis; c->idct = ffsimpleidctvis; c->idctpermutationtype = FFTRANSPOSEIDCTPERM; } if (!highbitdepth) { c->putpixelstab[0][0] = MCputo16vis; c->putpixelstab[0][1] = MCputx16vis; c->putpixelstab[0][2] = MCputy16vis; c->putpixelstab[0][3] = MCputxy16vis; c->putpixelstab[1][0] = MCputo8vis; c->putpixelstab[1][1] = MCputx8vis; c->putpixelstab[1][2] = MCputy8vis; c->putpixelstab[1][3] = MCputxy8vis; c->avgpixelstab[0][0] = MCavgo16vis; c->avgpixelstab[0][1] = MCavgx16vis; c->avgpixelstab[0][2] = MCavgy16vis; c->avgpixelstab[0][3] = MCavgxy16vis; c->avgpixelstab[1][0] = MCavgo8vis; c->avgpixelstab[1][1] = MCavgx8vis; c->avgpixelstab[1][2] = MCavgy8vis; c->avgpixelstab[1][3] = MCavgxy8vis; c->putnorndpixelstab[0][0] = MCputnoroundo16vis; c->putnorndpixelstab[0][1] = MCputnoroundx16vis; c->putnorndpixelstab[0][2] = MCputnoroundy16vis; c->putnorndpixelstab[0][3] = MCputnoroundxy16vis; c->putnorndpixelstab[1][0] = MCputnoroundo8vis; c->putnorndpixelstab[1][1] = MCputnoroundx8vis; c->putnorndpixelstab[1][2] = MCputnoroundy8vis; c->putnorndpixelstab[1][3] = MCputnoroundxy8vis; c->avgnorndpixelstab[0] = MCavgnoroundo16vis; c->avgnorndpixelstab[1] = MCavgnoroundx16vis; c->avgnorndpixelstab[2] = MCavgnoroundy16vis; c->avgnorndpixelstab[3] = MCavgnoroundxy16vis; } } } ", "target": 0}
{"func": "void vp8mc(VP8Context *s, int luma, uint8t *dst, uint8t *src, const VP56mv *mv, int xoff, int yoff, int blockw, int blockh, int width, int height, int linesize, vp8mcfunc mcfunc[3][3]) { if (AVRN32A(mv)) { static const uint8t idx[3][8] = { { 0, 1, 2, 1, 2, 1, 2, 1 }, // nr. of left extra pixels, // also function pointer index { 0, 3, 5, 3, 5, 3, 5, 3 }, // nr. of extra pixels required { 0, 2, 3, 2, 3, 2, 3, 2 }, // nr. of right extra pixels }; int mx = (mv->x << luma)&7, mxidx = idx[0][mx]; int my = (mv->y << luma)&7, myidx = idx[0][my]; xoff += mv->x >> (3 - luma); yoff += mv->y >> (3 - luma); // edge emulation src += yoff * linesize + xoff; if (xoff < mxidx || xoff >= width - blockw - idx[2][mx] || yoff < myidx || yoff >= height - blockh - idx[2][my]) { s->dsp.emulatededgemc(s->edgeemubuffer, src - myidx * linesize - mxidx, linesize, blockw + idx[1][mx], blockh + idx[1][my], xoff - mxidx, yoff - myidx, width, height); src = s->edgeemubuffer + mxidx + linesize * myidx; } mcfunc[myidx][mxidx](dst, linesize, src, linesize, blockh, mx, my); } else mcfunc[0][0](dst, linesize, src + yoff * linesize + xoff, linesize, blockh, 0, 0); } ", "target": 0}
{"func": "static int parseuint16(DeviceState *dev, Property *prop, const char *str) { uint16t *ptr = qdevgetpropptr(dev, prop); const char *fmt; /* accept both hex and decimal */ fmt = strncasecmp(str, \"0x\",2) == 0 ? \"%\" PRIx16 : \"%\" PRIu16; if (sscanf(str, fmt, ptr) != 1) return -EINVAL; return 0; } ", "target": 1}
{"func": "DECLARELOOPFILTER(mmxext) DECLARELOOPFILTER(sse2) DECLARELOOPFILTER(ssse3) DECLARELOOPFILTER(sse4) #endif /* HAVEYASM */ #define VP8LUMAMCFUNC(IDX, SIZE, OPT) \\ c->putvp8epelpixelstab[IDX][0][2] = ffputvp8epel ## SIZE ## h6 ## OPT; \\ c->putvp8epelpixelstab[IDX][2][0] = ffputvp8epel ## SIZE ## v6 ## OPT; \\ c->putvp8epelpixelstab[IDX][2][2] = ffputvp8epel ## SIZE ## h6v6 ## OPT #define VP8MCFUNC(IDX, SIZE, OPT) \\ c->putvp8epelpixelstab[IDX][0][1] = ffputvp8epel ## SIZE ## h4 ## OPT; \\ c->putvp8epelpixelstab[IDX][1][0] = ffputvp8epel ## SIZE ## v4 ## OPT; \\ c->putvp8epelpixelstab[IDX][1][1] = ffputvp8epel ## SIZE ## h4v4 ## OPT; \\ c->putvp8epelpixelstab[IDX][1][2] = ffputvp8epel ## SIZE ## h6v4 ## OPT; \\ c->putvp8epelpixelstab[IDX][2][1] = ffputvp8epel ## SIZE ## h4v6 ## OPT; \\ VP8LUMAMCFUNC(IDX, SIZE, OPT) #define VP8BILINEARMCFUNC(IDX, SIZE, OPT) \\ c->putvp8bilinearpixelstab[IDX][0][1] = ffputvp8bilinear ## SIZE ## h ## OPT; \\ c->putvp8bilinearpixelstab[IDX][0][2] = ffputvp8bilinear ## SIZE ## h ## OPT; \\ c->putvp8bilinearpixelstab[IDX][1][0] = ffputvp8bilinear ## SIZE ## v ## OPT; \\ c->putvp8bilinearpixelstab[IDX][1][1] = ffputvp8bilinear ## SIZE ## hv ## OPT; \\ c->putvp8bilinearpixelstab[IDX][1][2] = ffputvp8bilinear ## SIZE ## hv ## OPT; \\ c->putvp8bilinearpixelstab[IDX][2][0] = ffputvp8bilinear ## SIZE ## v ## OPT; \\ c->putvp8bilinearpixelstab[IDX][2][1] = ffputvp8bilinear ## SIZE ## hv ## OPT; \\ c->putvp8bilinearpixelstab[IDX][2][2] = ffputvp8bilinear ## SIZE ## hv ## OPT avcold void ffvp8dspinitx86(VP8DSPContext* c) { #if HAVEYASM int cpuflags = avgetcpuflags(); if (EXTERNALMMX(cpuflags)) { c->vp8idctdcadd = ffvp8idctdcaddmmx; c->vp8idctdcadd4uv = ffvp8idctdcadd4uvmmx; #if ARCHX8632 c->vp8idctdcadd4y = ffvp8idctdcadd4ymmx; c->vp8idctadd = ffvp8idctaddmmx; c->vp8lumadcwht = ffvp8lumadcwhtmmx; c->putvp8epelpixelstab[0][0][0] = c->putvp8bilinearpixelstab[0][0][0] = ffputvp8pixels16mmx; #endif c->putvp8epelpixelstab[1][0][0] = c->putvp8bilinearpixelstab[1][0][0] = ffputvp8pixels8mmx; #if ARCHX8632 c->vp8vloopfiltersimple = ffvp8vloopfiltersimplemmx; c->vp8hloopfiltersimple = ffvp8hloopfiltersimplemmx; c->vp8vloopfilter16yinner = ffvp8vloopfilter16yinnermmx; c->vp8hloopfilter16yinner = ffvp8hloopfilter16yinnermmx; c->vp8vloopfilter8uvinner = ffvp8vloopfilter8uvinnermmx; c->vp8hloopfilter8uvinner = ffvp8hloopfilter8uvinnermmx; c->vp8vloopfilter16y = ffvp8vloopfilter16ymbedgemmx; c->vp8hloopfilter16y = ffvp8hloopfilter16ymbedgemmx; c->vp8vloopfilter8uv = ffvp8vloopfilter8uvmbedgemmx; c->vp8hloopfilter8uv = ffvp8hloopfilter8uvmbedgemmx; #endif } /* note that 4-tap width=16 functions are missing because w=16 * is only used for luma, and luma is always a copy or sixtap. */ if (EXTERNALMMXEXT(cpuflags)) { VP8MCFUNC(2, 4, mmxext); VP8BILINEARMCFUNC(2, 4, mmxext); #if ARCHX8632 VP8LUMAMCFUNC(0, 16, mmxext); VP8MCFUNC(1, 8, mmxext); VP8BILINEARMCFUNC(0, 16, mmxext); VP8BILINEARMCFUNC(1, 8, mmxext); c->vp8vloopfiltersimple = ffvp8vloopfiltersimplemmxext; c->vp8hloopfiltersimple = ffvp8hloopfiltersimplemmxext; c->vp8vloopfilter16yinner = ffvp8vloopfilter16yinnermmxext; c->vp8hloopfilter16yinner = ffvp8hloopfilter16yinnermmxext; c->vp8vloopfilter8uvinner = ffvp8vloopfilter8uvinnermmxext; c->vp8hloopfilter8uvinner = ffvp8hloopfilter8uvinnermmxext; c->vp8vloopfilter16y = ffvp8vloopfilter16ymbedgemmxext; c->vp8hloopfilter16y = ffvp8hloopfilter16ymbedgemmxext; c->vp8vloopfilter8uv = ffvp8vloopfilter8uvmbedgemmxext; c->vp8hloopfilter8uv = ffvp8hloopfilter8uvmbedgemmxext; #endif } if (EXTERNALSSE(cpuflags)) { c->vp8idctadd = ffvp8idctaddsse; c->vp8lumadcwht = ffvp8lumadcwhtsse; c->putvp8epelpixelstab[0][0][0] = c->putvp8bilinearpixelstab[0][0][0] = ffputvp8pixels16sse; } if (EXTERNALSSE2(cpuflags) && (cpuflags & AVCPUFLAGSSE2SLOW)) { VP8LUMAMCFUNC(0, 16, sse2); VP8MCFUNC(1, 8, sse2); VP8BILINEARMCFUNC(0, 16, sse2); VP8BILINEARMCFUNC(1, 8, sse2); c->vp8vloopfiltersimple = ffvp8vloopfiltersimplesse2; c->vp8vloopfilter16yinner = ffvp8vloopfilter16yinnersse2; c->vp8vloopfilter8uvinner = ffvp8vloopfilter8uvinnersse2; c->vp8vloopfilter16y = ffvp8vloopfilter16ymbedgesse2; c->vp8vloopfilter8uv = ffvp8vloopfilter8uvmbedgesse2; } if (EXTERNALSSE2(cpuflags)) { c->vp8idctdcadd4y = ffvp8idctdcadd4ysse2; c->vp8hloopfiltersimple = ffvp8hloopfiltersimplesse2; c->vp8hloopfilter16yinner = ffvp8hloopfilter16yinnersse2; c->vp8hloopfilter8uvinner = ffvp8hloopfilter8uvinnersse2; c->vp8hloopfilter16y = ffvp8hloopfilter16ymbedgesse2; c->vp8hloopfilter8uv = ffvp8hloopfilter8uvmbedgesse2; } if (EXTERNALSSSE3(cpuflags)) { VP8LUMAMCFUNC(0, 16, ssse3); VP8MCFUNC(1, 8, ssse3); VP8MCFUNC(2, 4, ssse3); VP8BILINEARMCFUNC(0, 16, ssse3); VP8BILINEARMCFUNC(1, 8, ssse3); VP8BILINEARMCFUNC(2, 4, ssse3); c->vp8vloopfiltersimple = ffvp8vloopfiltersimplessse3; c->vp8hloopfiltersimple = ffvp8hloopfiltersimplessse3; c->vp8vloopfilter16yinner = ffvp8vloopfilter16yinnerssse3; c->vp8hloopfilter16yinner = ffvp8hloopfilter16yinnerssse3; c->vp8vloopfilter8uvinner = ffvp8vloopfilter8uvinnerssse3; c->vp8hloopfilter8uvinner = ffvp8hloopfilter8uvinnerssse3; c->vp8vloopfilter16y = ffvp8vloopfilter16ymbedgessse3; c->vp8hloopfilter16y = ffvp8hloopfilter16ymbedgessse3; c->vp8vloopfilter8uv = ffvp8vloopfilter8uvmbedgessse3; c->vp8hloopfilter8uv = ffvp8hloopfilter8uvmbedgessse3; } if (EXTERNALSSE4(cpuflags)) { c->vp8idctdcadd = ffvp8idctdcaddsse4; c->vp8hloopfiltersimple = ffvp8hloopfiltersimplesse4; c->vp8hloopfilter16y = ffvp8hloopfilter16ymbedgesse4; c->vp8hloopfilter8uv = ffvp8hloopfilter8uvmbedgesse4; } #endif /* HAVEYASM */ } ", "target": 1}
{"func": "static int getbat (CPUState *env, mmuctxt *ctx, targetulong virtual, int rw, int type) { targetulong *BATlt, *BATut, *BATu, *BATl; targetulong base, BEPIl, BEPIu, bl; int i; int ret = -1; #if defined (DEBUGBATS) if (loglevel != 0) { fprintf(logfile, \"%s: %cBAT v 0x\" ADDRX \"\\n\", func, type == ACCESSCODE ? 'I' : 'D', virtual); } #endif switch (type) { case ACCESSCODE: BATlt = env->IBAT[1]; BATut = env->IBAT[0]; break; default: BATlt = env->DBAT[1]; BATut = env->DBAT[0]; break; } #if defined (DEBUGBATS) if (loglevel != 0) { fprintf(logfile, \"%s...: %cBAT v 0x\" ADDRX \"\\n\", func, type == ACCESSCODE ? 'I' : 'D', virtual); } #endif base = virtual & 0xFFFC0000; for (i = 0; i < 4; i++) { BATu = &BATut[i]; BATl = &BATlt[i]; BEPIu = *BATu & 0xF0000000; BEPIl = *BATu & 0x0FFE0000; bl = (*BATu & 0x00001FFC) << 15; #if defined (DEBUGBATS) if (loglevel != 0) { fprintf(logfile, \"%s: %cBAT%d v 0x\" ADDRX \" BATu 0x\" ADDRX \" BATl 0x\" ADDRX \"\\n\", func, type == ACCESSCODE ? 'I' : 'D', i, virtual, *BATu, *BATl); } #endif if ((virtual & 0xF0000000) == BEPIu && ((virtual & 0x0FFE0000) & ~bl) == BEPIl) { /* BAT matches */ if ((msrpr == 0 && (*BATu & 0x00000002)) || (msrpr == 1 && (*BATu & 0x00000001))) { /* Get physical address */ ctx->raddr = (*BATl & 0xF0000000) | ((virtual & 0x0FFE0000 & bl) | (*BATl & 0x0FFE0000)) | (virtual & 0x0001F000); if (*BATl & 0x00000001) ctx->prot = PAGEREAD; if (*BATl & 0x00000002) ctx->prot = PAGEWRITE | PAGEREAD; #if defined (DEBUGBATS) if (loglevel != 0) { fprintf(logfile, \"BAT %d match: r 0x\" PADDRX \" prot=%c%c\\n\", i, ctx->raddr, ctx->prot & PAGEREAD ? 'R' : '-', ctx->prot & PAGEWRITE ? 'W' : '-'); } #endif ret = 0; break; } } } if (ret < 0) { #if defined (DEBUGBATS) if (loglevel != 0) { fprintf(logfile, \"no BAT match for 0x\" ADDRX \":\\n\", virtual); for (i = 0; i < 4; i++) { BATu = &BATut[i]; BATl = &BATlt[i]; BEPIu = *BATu & 0xF0000000; BEPIl = *BATu & 0x0FFE0000; bl = (*BATu & 0x00001FFC) << 15; fprintf(logfile, \"%s: %cBAT%d v 0x\" ADDRX \" BATu 0x\" ADDRX \" BATl 0x\" ADDRX \" \\n\\t\" \"0x\" ADDRX \" 0x\" ADDRX \" 0x\" ADDRX \"\\n\", func, type == ACCESSCODE ? 'I' : 'D', i, virtual, *BATu, *BATl, BEPIu, BEPIl, bl); } } #endif } /* No hit */ return ret; } ", "target": 0}
{"func": "static void *migrationthread(void *opaque) { MigrationState *s = opaque; /* Used by the bandwidth calcs, updated later */ int64t initialtime = qemuclockgetms(QEMUCLOCKREALTIME); int64t setupstart = qemuclockgetms(QEMUCLOCKHOST); int64t initialbytes = 0; int64t maxsize = 0; int64t starttime = initialtime; int64t endtime; bool oldvmrunning = false; bool enteredpostcopy = false; /* The active state we expect to be in; ACTIVE or POSTCOPYACTIVE */ enum MigrationStatus currentactivestate = MIGRATIONSTATUSACTIVE; rcuregisterthread(); qemusavevmstateheader(s->todstfile); if (migratepostcopyram()) { /* Now tell the dest that it should open its end so it can reply */ qemusavevmsendopenreturnpath(s->todstfile); /* And do a ping that will make stuff easier to debug */ qemusavevmsendping(s->todstfile, 1); /* * Tell the destination that we *might* want to do postcopy later; * if the other end can't do postcopy it should fail now, nice and * early. */ qemusavevmsendpostcopyadvise(s->todstfile); } qemusavevmstatebegin(s->todstfile, &s->params); s->setuptime = qemuclockgetms(QEMUCLOCKHOST) - setupstart; currentactivestate = MIGRATIONSTATUSACTIVE; migratesetstate(&s->state, MIGRATIONSTATUSSETUP, MIGRATIONSTATUSACTIVE); tracemigrationthreadsetupcomplete(); while (s->state == MIGRATIONSTATUSACTIVE || s->state == MIGRATIONSTATUSPOSTCOPYACTIVE) { int64t currenttime; uint64t pendingsize; if (!qemufileratelimit(s->todstfile)) { uint64t pendpost, pendnonpost; qemusavevmstatepending(s->todstfile, maxsize, &pendnonpost, &pendpost); pendingsize = pendnonpost + pendpost; tracemigratepending(pendingsize, maxsize, pendpost, pendnonpost); if (pendingsize && pendingsize >= maxsize) { /* Still a significant amount to transfer */ if (migratepostcopyram() && s->state != MIGRATIONSTATUSPOSTCOPYACTIVE && pendnonpost <= maxsize && atomicread(&s->startpostcopy)) { if (!postcopystart(s, &oldvmrunning)) { currentactivestate = MIGRATIONSTATUSPOSTCOPYACTIVE; enteredpostcopy = true; } continue; } /* Just another iteration step */ qemusavevmstateiterate(s->todstfile, enteredpostcopy); } else { tracemigrationthreadlowpending(pendingsize); migrationcompletion(s, currentactivestate, &oldvmrunning, &starttime); break; } } if (qemufilegeterror(s->todstfile)) { migratesetstate(&s->state, currentactivestate, MIGRATIONSTATUSFAILED); tracemigrationthreadfileerr(); break; } currenttime = qemuclockgetms(QEMUCLOCKREALTIME); if (currenttime >= initialtime + BUFFERDELAY) { uint64t transferredbytes = qemuftell(s->todstfile) - initialbytes; uint64t timespent = currenttime - initialtime; double bandwidth = (double)transferredbytes / timespent; maxsize = bandwidth * migratemaxdowntime() / 1000000; s->mbps = (((double) transferredbytes * 8.0) / ((double) timespent / 1000.0)) / 1000.0 / 1000.0; tracemigratetransferred(transferredbytes, timespent, bandwidth, maxsize); /* if we haven't sent anything, we don't want to recalculate 10000 is a small enough number for our purposes */ if (s->dirtybytesrate && transferredbytes > 10000) { s->expecteddowntime = s->dirtybytesrate / bandwidth; } qemufileresetratelimit(s->todstfile); initialtime = currenttime; initialbytes = qemuftell(s->todstfile); } if (qemufileratelimit(s->todstfile)) { /* usleep expects microseconds */ gusleep((initialtime + BUFFERDELAY - currenttime)*1000); } } tracemigrationthreadafterloop(); /* If we enabled cpu throttling for auto-converge, turn it off. */ cputhrottlestop(); endtime = qemuclockgetms(QEMUCLOCKREALTIME); qemumutexlockiothread(); qemusavevmstatecleanup(); if (s->state == MIGRATIONSTATUSCOMPLETED) { uint64t transferredbytes = qemuftell(s->todstfile); s->totaltime = endtime - s->totaltime; if (!enteredpostcopy) { s->downtime = endtime - starttime; } if (s->totaltime) { s->mbps = (((double) transferredbytes * 8.0) / ((double) s->totaltime)) / 1000; } runstateset(RUNSTATEPOSTMIGRATE); } else { if (oldvmrunning && !enteredpostcopy) { vmstart(); } else { if (runstatecheck(RUNSTATEFINISHMIGRATE)) { runstateset(RUNSTATEPOSTMIGRATE); } } } qemubhschedule(s->cleanupbh); qemumutexunlockiothread(); rcuunregisterthread(); return NULL; } ", "target": 0}
{"func": "void replayinputevent(QemuConsole *src, InputEvent *evt) { if (replaymode == REPLAYMODEPLAY) { /* Nothing */ } else if (replaymode == REPLAYMODERECORD) { replayaddinputevent(qapicloneInputEvent(evt)); } else { qemuinputeventsendimpl(src, evt); } } ", "target": 0}
{"func": "static inline unsigned int getuint(ShortenContext *s, int k) { if (s->version != 0) k = geturgolombshorten(&s->gb, ULONGSIZE); return geturgolombshorten(&s->gb, k); } ", "target": 1}
{"func": "static void scalecoefs ( int32t *dst, const int32t *src, int dynrng, int len) { int i, shift, round; int16t mul; int temp, temp1, temp2, temp3, temp4, temp5, temp6, temp7; mul = (dynrng & 0x1f) + 0x20; shift = 4 - ((dynrng << 23) >> 28); if (shift > 0 ) { round = 1 << (shift-1); for (i=0; i<len; i+=8) { temp = src[i] * mul; temp1 = src[i+1] * mul; temp = temp + round; temp2 = src[i+2] * mul; temp1 = temp1 + round; dst[i] = temp >> shift; temp3 = src[i+3] * mul; temp2 = temp2 + round; dst[i+1] = temp1 >> shift; temp4 = src[i + 4] * mul; temp3 = temp3 + round; dst[i+2] = temp2 >> shift; temp5 = src[i+5] * mul; temp4 = temp4 + round; dst[i+3] = temp3 >> shift; temp6 = src[i+6] * mul; dst[i+4] = temp4 >> shift; temp5 = temp5 + round; temp7 = src[i+7] * mul; temp6 = temp6 + round; dst[i+5] = temp5 >> shift; temp7 = temp7 + round; dst[i+6] = temp6 >> shift; dst[i+7] = temp7 >> shift; } } else { shift = -shift; for (i=0; i<len; i+=8) { temp = src[i] * mul; temp1 = src[i+1] * mul; temp2 = src[i+2] * mul; dst[i] = temp << shift; temp3 = src[i+3] * mul; dst[i+1] = temp1 << shift; temp4 = src[i + 4] * mul; dst[i+2] = temp2 << shift; temp5 = src[i+5] * mul; dst[i+3] = temp3 << shift; temp6 = src[i+6] * mul; dst[i+4] = temp4 << shift; temp7 = src[i+7] * mul; dst[i+5] = temp5 << shift; dst[i+6] = temp6 << shift; dst[i+7] = temp7 << shift; } } } ", "target": 1}
{"func": "static int handleparseopts(QemuOpts *opts, FsDriverEntry *fse, Error **errp) { const char *secmodel = qemuoptget(opts, \"securitymodel\"); const char *path = qemuoptget(opts, \"path\"); if (secmodel) { errorreport(\"Invalid argument securitymodel specified with handle fsdriver\"); return -1; } if (!path) { errorreport(\"fsdev: No path specified\"); return -1; } fse->path = gstrdup(path); return 0; }", "target": 1}
{"func": "void vncsaslclientcleanup(VncState *vs) { if (vs->sasl.conn) { vs->sasl.runSSF = vs->sasl.waitWriteSSF = vs->sasl.wantSSF = 0; vs->sasl.encodedLength = vs->sasl.encodedOffset = 0; vs->sasl.encoded = NULL; gfree(vs->sasl.username); free(vs->sasl.mechlist); vs->sasl.username = vs->sasl.mechlist = NULL; sasldispose(&vs->sasl.conn); vs->sasl.conn = NULL; } } ", "target": 1}
{"func": "static int integratorcminit(SysBusDevice *dev) { IntegratorCMState *s = INTEGRATORCM(dev); s->cmosc = 0x01000048; /* ??? What should the high bits of this value be? */ s->cmauxosc = 0x0007feff; s->cmsdram = 0x00011122; if (s->memsz >= 256) { integratorspd[31] = 64; s->cmsdram |= 0x10; } else if (s->memsz >= 128) { integratorspd[31] = 32; s->cmsdram |= 0x0c; } else if (s->memsz >= 64) { integratorspd[31] = 16; s->cmsdram |= 0x08; } else if (s->memsz >= 32) { integratorspd[31] = 4; s->cmsdram |= 0x04; } else { integratorspd[31] = 2; } memcpy(integratorspd + 73, \"QEMU-MEMORY\", 11); s->cminit = 0x00000112; s->cmrefcntoffset = muldiv64(qemuclockgetns(QEMUCLOCKVIRTUAL), 24, 1000); memoryregioninitram(&s->flash, OBJECT(s), \"integrator.flash\", 0x100000, &errorabort); vmstateregisterramglobal(&s->flash); memoryregioninitio(&s->iomem, OBJECT(s), &integratorcmops, s, \"integratorcm\", 0x00800000); sysbusinitmmio(dev, &s->iomem); integratorcmdoremap(s); /* ??? Save/restore. */ return 0; } ", "target": 1}
{"func": "static void unterminatedarraycomma(void) { QObject *obj = qobjectfromjson(\"[32,\", NULL); gassert(obj == NULL); } ", "target": 1}
{"func": "static int svq1decodeframeheader(GetBitContext *bitbuf, MpegEncContext *s) { int framesizecode; skipbits(bitbuf, 8); /* temporalreference */ /* frame type */ s->picttype = getbits(bitbuf, 2) + 1; if (s->picttype == 4) return AVERRORINVALIDDATA; if (s->picttype == AVPICTURETYPEI) { /* unknown fields */ if (s->fcode == 0x50 || s->fcode == 0x60) { int csum = getbits(bitbuf, 16); csum = ffsvq1packetchecksum(bitbuf->buffer, bitbuf->sizeinbits >> 3, csum); avdlog(s->avctx, \"%s checksum (%02x) for packet data\\n\", (csum == 0) ? \"correct\" : \"incorrect\", csum); } if ((s->fcode ^ 0x10) >= 0x50) { uint8t msg[256]; svq1parsestring(bitbuf, msg); avlog(s->avctx, AVLOGERROR, \"embedded message: \\\"%s\\\"\\n\", (char *)msg); } skipbits(bitbuf, 2); skipbits(bitbuf, 2); skipbits1(bitbuf); /* load frame size */ framesizecode = getbits(bitbuf, 3); if (framesizecode == 7) { /* load width, height (12 bits each) */ s->width = getbits(bitbuf, 12); s->height = getbits(bitbuf, 12); if (!s->width || !s->height) return AVERRORINVALIDDATA; } else { /* get width, height from table */ s->width = ffsvq1framesizetable[framesizecode].width; s->height = ffsvq1framesizetable[framesizecode].height; } } /* unknown fields */ if (getbits1(bitbuf) == 1) { skipbits1(bitbuf); /* use packet checksum if (1) */ skipbits1(bitbuf); /* component checksums after image data if (1) */ if (getbits(bitbuf, 2) != 0) return AVERRORINVALIDDATA; } if (getbits1(bitbuf) == 1) { skipbits1(bitbuf); skipbits(bitbuf, 4); skipbits1(bitbuf); skipbits(bitbuf, 2); while (getbits1(bitbuf) == 1) skipbits(bitbuf, 8); } return 0; } ", "target": 0}
{"func": "void preparegrab(void) { fprintf(stderr, \"Must supply at least one input file\\n\"); exit(1); } ", "target": 1}
{"func": "static int comparecodecdesc(const void *a, const void *b) { const AVCodecDescriptor * const *da = a; const AVCodecDescriptor * const *db = b; return (*da)->type != (*db)->type ? (*da)->type - (*db)->type : strcmp((*da)->name, (*db)->name); } ", "target": 1}
{"func": "static int coroutinefn addaiorequest(BDRVSheepdogState *s, AIOReq *aioreq, struct iovec *iov, int niov, int create, enum AIOCBState aiocbtype) { int nrcopies = s->inode.nrcopies; SheepdogObjReq hdr; unsigned int wlen; int ret; uint64t oid = aioreq->oid; unsigned int datalen = aioreq->datalen; uint64t offset = aioreq->offset; uint8t flags = aioreq->flags; uint64t oldoid = aioreq->baseoid; if (!nrcopies) { errorreport(\"bug\"); } memset(&hdr, 0, sizeof(hdr)); if (aiocbtype == AIOCBREADUDATA) { wlen = 0; hdr.opcode = SDOPREADOBJ; hdr.flags = flags; } else if (create) { wlen = datalen; hdr.opcode = SDOPCREATEANDWRITEOBJ; hdr.flags = SDFLAGCMDWRITE | flags; } else { wlen = datalen; hdr.opcode = SDOPWRITEOBJ; hdr.flags = SDFLAGCMDWRITE | flags; } hdr.oid = oid; hdr.cowoid = oldoid; hdr.copies = s->inode.nrcopies; hdr.datalength = datalen; hdr.offset = offset; hdr.id = aioreq->id; qemucomutexlock(&s->lock); s->cosend = qemucoroutineself(); qemuaiosetfdhandler(s->fd, coreadresponse, cowriterequest, aioflushrequest, NULL, s); setcork(s->fd, 1); /* send a header */ ret = dowrite(s->fd, &hdr, sizeof(hdr)); if (ret) { errorreport(\"failed to send a req, %s\", strerror(errno)); return -EIO; } if (wlen) { ret = dowritev(s->fd, iov, wlen, aioreq->iovoffset); if (ret) { errorreport(\"failed to send a data, %s\", strerror(errno)); return -EIO; } } setcork(s->fd, 0); qemuaiosetfdhandler(s->fd, coreadresponse, NULL, aioflushrequest, NULL, s); return 0; }", "target": 1}
{"func": "static void ehciwritebackasynccompletepacket(EHCIPacket *p) { EHCIQueue *q = p->queue; int state; state = ehcigetstate(q->ehci, q->async); ehcistateexecuting(q); ehcistatewriteback(q); /* Frees the packet! */ if (!(q->qh.token & QTDTOKENHALT)) { ehcistateadvqueue(q); ehcisetstate(q->ehci, q->async, state);", "target": 1}
{"func": "static void genldstpair (DisasContext *ctx, uint32t opc, int rd, int base, int16t offset) { const char *opn = \"ldstpair\"; TCGv t0, t1; if (ctx->hflags & MIPSHFLAGBMASK || rd == 31 || rd == base) { generateexception(ctx, EXCPRI); return; } t0 = tcgtempnew(); t1 = tcgtempnew(); genbaseoffsetaddr(ctx, t0, base, offset); switch (opc) { case LWP: savecpustate(ctx, 0); opldlw(t1, t0, ctx); genstoregpr(t1, rd); tcggenmovitl(t1, 4); genopaddradd(ctx, t0, t0, t1); opldlw(t1, t0, ctx); genstoregpr(t1, rd+1); opn = \"lwp\"; break; case SWP: savecpustate(ctx, 0); genloadgpr(t1, rd); opstsw(t1, t0, ctx); tcggenmovitl(t1, 4); genopaddradd(ctx, t0, t0, t1); genloadgpr(t1, rd+1); opstsw(t1, t0, ctx); opn = \"swp\"; break; #ifdef TARGETMIPS64 case LDP: savecpustate(ctx, 0); opldld(t1, t0, ctx); genstoregpr(t1, rd); tcggenmovitl(t1, 8); genopaddradd(ctx, t0, t0, t1); opldld(t1, t0, ctx); genstoregpr(t1, rd+1); opn = \"ldp\"; break; case SDP: savecpustate(ctx, 0); genloadgpr(t1, rd); opstsd(t1, t0, ctx); tcggenmovitl(t1, 8); genopaddradd(ctx, t0, t0, t1); genloadgpr(t1, rd+1); opstsd(t1, t0, ctx); opn = \"sdp\"; break; #endif } (void)opn; /* avoid a compiler warning */ MIPSDEBUG(\"%s, %s, %d(%s)\", opn, regnames[rd], offset, regnames[base]); tcgtempfree(t0); tcgtempfree(t1); } ", "target": 1}
{"func": "static void wdtdiag288classinit(ObjectClass *klass, void *data) { DeviceClass *dc = DEVICECLASS(klass); DIAG288Class *diag288 = DIAG288CLASS(klass); dc->realize = wdtdiag288realize; dc->unrealize = wdtdiag288unrealize; dc->reset = wdtdiag288reset; setbit(DEVICECATEGORYMISC, dc->categories); dc->vmsd = &vmstatediag288; diag288->handletimer = wdtdiag288handletimer; }", "target": 1}
{"func": "int ffestimatemotionb(MpegEncContext * s, int mbx, int mby, int16t (*mvtable)[2], uint8t *refpicture, int fcode) { int mx, my, range, dmin; int xmin, ymin, xmax, ymax; int relxmin, relymin, relxmax, relymax; int predx=0, predy=0; int P[6][2]; const int shift= 1+s->quartersample; const int motstride = s->mbwidth + 2; const int motxy = (mby + 1)*motstride + mbx + 1; getlimits(s, &range, &xmin, &ymin, &xmax, &ymax, fcode); switch(s->memethod) { case MEZERO: default: \tnomotionsearch(s, &mx, &my); dmin = 0; break; case MEFULL: \tdmin = fullmotionsearch(s, &mx, &my, range, xmin, ymin, xmax, ymax, refpicture); break; case MELOG: \tdmin = logmotionsearch(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, refpicture); break; case MEPHODS: \tdmin = phodsmotionsearch(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, refpicture); break; case MEX1: case MEEPZS: { relxmin= xmin - mbx*16; relxmax= xmax - mbx*16; relymin= ymin - mby*16; relymax= ymax - mby*16; P[0][0] = mvtable[motxy ][0]; P[0][1] = mvtable[motxy ][1]; P[1][0] = mvtable[motxy - 1][0]; P[1][1] = mvtable[motxy - 1][1]; if(P[1][0] > (relxmax<<shift)) P[1][0]= (relxmax<<shift); /* special case for first line */ if ((mby == 0 || s->firstsliceline || s->firstgobline)) { P[4][0] = P[1][0]; P[4][1] = P[1][1]; } else { P[2][0] = mvtable[motxy - motstride ][0]; P[2][1] = mvtable[motxy - motstride ][1]; P[3][0] = mvtable[motxy - motstride + 1 ][0]; P[3][1] = mvtable[motxy - motstride + 1 ][1]; if(P[2][1] > (relymax<<shift)) P[2][1]= (relymax<<shift); if(P[3][0] < (relxmin<<shift)) P[3][0]= (relxmin<<shift); if(P[3][1] > (relymax<<shift)) P[3][1]= (relymax<<shift); P[4][0]= midpred(P[1][0], P[2][0], P[3][0]); P[4][1]= midpred(P[1][1], P[2][1], P[3][1]); } predx= P[1][0]; predy= P[1][1]; } dmin = epzsmotionsearch(s, &mx, &my, P, predx, predy, relxmin, relymin, relxmax, relymax, refpicture); mx+= mbx*16; my+= mby*16; break; } /* intra / predictive decision */ // xx = mbx * 16; // yy = mby * 16; // pix = s->newpicture[0] + (yy * s->linesize) + xx; /* At this point (mx,my) are full-pell and the absolute displacement */ // ppix = refpicture + (my * s->linesize) + mx; dmin= halfpelmotionsearch(s, &mx, &my, dmin, xmin, ymin, xmax, ymax, predx, predy, refpicture); // s->mbtype[mby*s->mbwidth + mbx]= mbtype; mvtable[motxy][0]= mx; mvtable[motxy][1]= my; return dmin; } ", "target": 0}
{"func": "static int decodenalunits(H264Context *h, const uint8t *buf, int bufsize){ MpegEncContext * const s = &h->s; AVCodecContext * const avctx= s->avctx; H264Context *hx; ///< thread context int bufindex; int contextcount; int nextavc; int pass = !(avctx->activethreadtype & FFTHREADFRAME); int nalsneeded=0; ///< number of NALs that need decoding before the next frame thread starts int nalindex; h->nalunittype= 0; h->maxcontexts = (HAVETHREADS && (s->avctx->activethreadtype&FFTHREADSLICE)) ? avctx->threadcount : 1; if(!(s->flags2 & CODECFLAG2CHUNKS)){ h->currentslice = 0; if (!s->firstfield) s->currentpictureptr= NULL; ffh264resetsei(h); } for(;pass <= 1;pass++){ bufindex = 0; contextcount = 0; nextavc = h->isavc ? 0 : bufsize; nalindex = 0; for(;;){ int consumed; int dstlength; int bitlength; uint8t *ptr; int i, nalsize = 0; int err; if(bufindex >= nextavc) { if (bufindex >= bufsize - h->nallengthsize) break; nalsize = 0; for(i = 0; i < h->nallengthsize; i++) nalsize = (nalsize << 8) | buf[bufindex++]; if(nalsize <= 0 || nalsize > bufsize - bufindex){ avlog(h->s.avctx, AVLOGERROR, \"AVC: nal size %d\\n\", nalsize); break; } nextavc= bufindex + nalsize; } else { // start code prefix search for(; bufindex + 3 < nextavc; bufindex++){ // This should always succeed in the first iteration. if(buf[bufindex] == 0 && buf[bufindex+1] == 0 && buf[bufindex+2] == 1) break; } if(bufindex+3 >= bufsize) break; bufindex+=3; if(bufindex >= nextavc) continue; } hx = h->threadcontext[contextcount]; ptr= ffh264decodenal(hx, buf + bufindex, &dstlength, &consumed, nextavc - bufindex); if (ptr==NULL || dstlength < 0){ return -1; } i= bufindex + consumed; if((s->workaroundbugs & FFBUGAUTODETECT) && i+3<nextavc && buf[i]==0x00 && buf[i+1]==0x00 && buf[i+2]==0x01 && buf[i+3]==0xE0) s->workaroundbugs |= FFBUGTRUNCATED; if(!(s->workaroundbugs & FFBUGTRUNCATED)){ while(dstlength > 0 && ptr[dstlength - 1] == 0) dstlength--; } bitlength= !dstlength ? 0 : (8*dstlength - ffh264decoderbsptrailing(h, ptr + dstlength - 1)); if(s->avctx->debug&FFDEBUGSTARTCODE){ avlog(h->s.avctx, AVLOGDEBUG, \"NAL %d/%d at %d/%d length %d pass %d\\n\", hx->nalunittype, hx->nalrefidc, bufindex, bufsize, dstlength, pass); } if (h->isavc && (nalsize != consumed) && nalsize){ avlog(h->s.avctx, AVLOGDEBUG, \"AVC: Consumed only %d bytes instead of %d\\n\", consumed, nalsize); } bufindex += consumed; nalindex++; if(pass == 0) { // packets can sometimes contain multiple PPS/SPS // e.g. two PAFF field pictures in one packet, or a demuxer which splits NALs strangely // if so, when frame threading we can't start the next thread until we've read all of them switch (hx->nalunittype) { case NALSPS: case NALPPS: nalsneeded = nalindex; break; case NALIDRSLICE: case NALSLICE: initgetbits(&hx->s.gb, ptr, bitlength); if (!getuegolomb(&hx->s.gb)) nalsneeded = nalindex; } continue; } //FIXME do not discard SEI id if(avctx->skipframe >= AVDISCARDNONREF && h->nalrefidc == 0) continue; again: err = 0; switch(hx->nalunittype){ case NALIDRSLICE: if (h->nalunittype != NALIDRSLICE) { avlog(h->s.avctx, AVLOGERROR, \"Invalid mix of idr and non-idr slices\"); return -1; } idr(h); // FIXME ensure we don't lose some frames if there is reordering case NALSLICE: initgetbits(&hx->s.gb, ptr, bitlength); hx->intragbptr= hx->intergbptr= &hx->s.gb; hx->s.datapartitioning = 0; if((err = decodesliceheader(hx, h))) break; if ( h->seirecoveryframecnt >= 0 && ((h->recoveryframe - h->framenum) & ((1 << h->sps.log2maxframenum)-1)) > h->seirecoveryframecnt) { h->recoveryframe = (h->framenum + h->seirecoveryframecnt) % (1 << h->sps.log2maxframenum); } s->currentpictureptr->f.keyframe |= (hx->nalunittype == NALIDRSLICE); if (h->recoveryframe == h->framenum) { h->sync |= 1; h->recoveryframe = -1; } h->sync |= !!s->currentpictureptr->f.keyframe; h->sync |= 3*!!(s->flags2 & CODECFLAG2SHOWALL); s->currentpictureptr->sync = h->sync; if (h->currentslice == 1) { if(!(s->flags2 & CODECFLAG2CHUNKS)) { decodepostinit(h, nalindex >= nalsneeded); } if (s->avctx->hwaccel && s->avctx->hwaccel->startframe(s->avctx, NULL, 0) < 0) return -1; if(CONFIGH264VDPAUDECODER && s->avctx->codec->capabilities&CODECCAPHWACCELVDPAU) ffvdpauh264picturestart(s); } if(hx->redundantpiccount==0 && (avctx->skipframe < AVDISCARDNONREF || hx->nalrefidc) && (avctx->skipframe < AVDISCARDBIDIR || hx->slicetypenos!=AVPICTURETYPEB) && (avctx->skipframe < AVDISCARDNONKEY || hx->slicetypenos==AVPICTURETYPEI) && avctx->skipframe < AVDISCARDALL){ if(avctx->hwaccel) { if (avctx->hwaccel->decodeslice(avctx, &buf[bufindex - consumed], consumed) < 0) return -1; }else if(CONFIGH264VDPAUDECODER && s->avctx->codec->capabilities&CODECCAPHWACCELVDPAU){ static const uint8t startcode[] = {0x00, 0x00, 0x01}; ffvdpauadddatachunk(s, startcode, sizeof(startcode)); ffvdpauadddatachunk(s, &buf[bufindex - consumed], consumed ); }else contextcount++; } break; case NALDPA: initgetbits(&hx->s.gb, ptr, bitlength); hx->intragbptr= hx->intergbptr= NULL; if ((err = decodesliceheader(hx, h)) < 0) break; hx->s.datapartitioning = 1; break; case NALDPB: initgetbits(&hx->intragb, ptr, bitlength); hx->intragbptr= &hx->intragb; break; case NALDPC: initgetbits(&hx->intergb, ptr, bitlength); hx->intergbptr= &hx->intergb; if(hx->redundantpiccount==0 && hx->intragbptr && hx->s.datapartitioning && s->contextinitialized && (avctx->skipframe < AVDISCARDNONREF || hx->nalrefidc) && (avctx->skipframe < AVDISCARDBIDIR || hx->slicetypenos!=AVPICTURETYPEB) && (avctx->skipframe < AVDISCARDNONKEY || hx->slicetypenos==AVPICTURETYPEI) && avctx->skipframe < AVDISCARDALL) contextcount++; break; case NALSEI: initgetbits(&s->gb, ptr, bitlength); ffh264decodesei(h); break; case NALSPS: initgetbits(&s->gb, ptr, bitlength); if(ffh264decodeseqparameterset(h) < 0 && (h->isavc ? (nalsize != consumed) && nalsize : 1)){ avlog(h->s.avctx, AVLOGDEBUG, \"SPS decoding failure, trying alternative mode\\n\"); if(h->isavc) avassert0(nextavc - bufindex + consumed == nalsize); initgetbits(&s->gb, &buf[bufindex + 1 - consumed], 8*(nextavc - bufindex + consumed)); ffh264decodeseqparameterset(h); } if (s->flags& CODECFLAGLOWDELAY || (h->sps.bitstreamrestrictionflag && !h->sps.numreorderframes)) s->lowdelay=1; if(avctx->hasbframes < 2) avctx->hasbframes= !s->lowdelay; break; case NALPPS: initgetbits(&s->gb, ptr, bitlength); ffh264decodepictureparameterset(h, bitlength); break; case NALAUD: case NALENDSEQUENCE: case NALENDSTREAM: case NALFILLERDATA: case NALSPSEXT: case NALAUXILIARYSLICE: break; default: avlog(avctx, AVLOGDEBUG, \"Unknown NAL code: %d (%d bits)\\n\", hx->nalunittype, bitlength); } if(contextcount == h->maxcontexts) { executedecodeslices(h, contextcount); contextcount = 0; } if (err < 0) avlog(h->s.avctx, AVLOGERROR, \"decodesliceheader error\\n\"); else if(err == 1) { /* Slice could not be decoded in parallel mode, copy down * NAL unit stuff to context 0 and restart. Note that * rbspbuffer is not transferred, but since we no longer * run in parallel mode this should not be an issue. */ h->nalunittype = hx->nalunittype; h->nalrefidc = hx->nalrefidc; hx = h; goto again; } } } if(contextcount) executedecodeslices(h, contextcount); return bufindex; } ", "target": 0}
{"func": "static int dnxhdfindframeend(DNXHDParserContext *dctx, const uint8t *buf, int bufsize) { ParseContext *pc = &dctx->pc; uint64t state = pc->state64; int picfound = pc->framestartfound; int i = 0; if (!picfound) { for (i = 0; i < bufsize; i++) { state = (state << 8) | buf[i]; if (ffdnxhdcheckheaderprefix(state & 0xffffffffff00LL) != 0) { i++; picfound = 1; dctx->curbyte = 0; dctx->remaining = 0; break; } } } if (picfound && !dctx->remaining) { if (!bufsize) /* EOF considered as end of frame */ return 0; for (; i < bufsize; i++) { dctx->curbyte++; state = (state << 8) | buf[i]; if (dctx->curbyte == 24) { dctx->h = (state >> 32) & 0xFFFF; } else if (dctx->curbyte == 26) { dctx->w = (state >> 32) & 0xFFFF; } else if (dctx->curbyte == 42) { int cid = (state >> 32) & 0xFFFFFFFF; if (cid <= 0) continue; dctx->remaining = avprivdnxhdgetframesize(cid); if (dctx->remaining <= 0) { dctx->remaining = ffdnxhdgethrframesize(cid, dctx->w, dctx->h); if (dctx->remaining <= 0) return dctx->remaining; } if (bufsize - i + 47 >= dctx->remaining) { int remaining = dctx->remaining; pc->framestartfound = 0; pc->state64 = -1; dctx->curbyte = 0; dctx->remaining = 0; return remaining; } else { dctx->remaining -= bufsize; } } } } else if (picfound) { if (dctx->remaining > bufsize) { dctx->remaining -= bufsize; } else { int remaining = dctx->remaining; pc->framestartfound = 0; pc->state64 = -1; dctx->curbyte = 0; dctx->remaining = 0; return remaining; } } pc->framestartfound = picfound; pc->state64 = state; return ENDNOTFOUND; } ", "target": 1}
{"func": "static avcold int vaapiencodeh264initconstantbitrate(AVCodecContext *avctx) { VAAPIEncodeContext *ctx = avctx->privdata; VAAPIEncodeH264Context *priv = ctx->privdata; int hrdbuffersize; int hrdinitialbufferfullness; if (avctx->bitrate > INT32MAX) { avlog(avctx, AVLOGERROR, \"Target bitrate of 2^31 bps or \" \"higher is not supported.\\n\"); return AVERROR(EINVAL); } if (avctx->rcbuffersize) hrdbuffersize = avctx->rcbuffersize; else hrdbuffersize = avctx->bitrate; if (avctx->rcinitialbufferoccupancy) hrdinitialbufferfullness = avctx->rcinitialbufferoccupancy; else hrdinitialbufferfullness = hrdbuffersize * 3 / 4; priv->rcparams.misc.type = VAEncMiscParameterTypeRateControl; priv->rcparams.rc = (VAEncMiscParameterRateControl) { .bitspersecond = avctx->bitrate, .targetpercentage = 66, .windowsize = 1000, .initialqp = (avctx->qmax >= 0 ? avctx->qmax : 40), .minqp = (avctx->qmin >= 0 ? avctx->qmin : 18), .basicunitsize = 0, }; ctx->globalparams[ctx->nbglobalparams] = &priv->rcparams.misc; ctx->globalparamssize[ctx->nbglobalparams++] = sizeof(priv->rcparams); priv->hrdparams.misc.type = VAEncMiscParameterTypeHRD; priv->hrdparams.hrd = (VAEncMiscParameterHRD) { .initialbufferfullness = hrdinitialbufferfullness, .buffersize = hrdbuffersize, }; ctx->globalparams[ctx->nbglobalparams] = &priv->hrdparams.misc; ctx->globalparamssize[ctx->nbglobalparams++] = sizeof(priv->hrdparams); // These still need to be set for picinitqp/sliceqpdelta. priv->fixedqpidr = 26; priv->fixedqpp = 26; priv->fixedqpb = 26; avlog(avctx, AVLOGDEBUG, \"Using constant-bitrate = %\"PRId64\" bps.\\n\", avctx->bitrate); return 0; } ", "target": 0}
{"func": "static inline void RENAME(planar2x)(const uint8t *src, uint8t *dst, long srcWidth, long srcHeight, long srcStride, long dstStride) { \tlong x,y; \tdst[0]= src[0]; \t// first line \tfor(x=0; x<srcWidth-1; x++){ \t\tdst[2*x+1]= (3*src[x] + src[x+1])>>2; \t\tdst[2*x+2]= ( src[x] + 3*src[x+1])>>2; \t} \tdst[2*srcWidth-1]= src[srcWidth-1]; dst+= dstStride; \tfor(y=1; y<srcHeight; y++){ #if defined (HAVEMMX2) || defined (HAVE3DNOW) \t\tconst long mmxSize= srcWidth&~15; \t\tasm volatile( \t\t\t\"mov %4, %%\"REGa\"\t\t\\n\\t\" \t\t\t\"1:\t\t\t\t\\n\\t\" \t\t\t\"movq (%0, %%\"REGa\"), %%mm0\t\\n\\t\" \t\t\t\"movq (%1, %%\"REGa\"), %%mm1\t\\n\\t\" \t\t\t\"movq 1(%0, %%\"REGa\"), %%mm2\t\\n\\t\" \t\t\t\"movq 1(%1, %%\"REGa\"), %%mm3\t\\n\\t\" \t\t\t\"movq -1(%0, %%\"REGa\"), %%mm4\t\\n\\t\" \t\t\t\"movq -1(%1, %%\"REGa\"), %%mm5\t\\n\\t\" \t\t\tPAVGB\" %%mm0, %%mm5\t\t\\n\\t\" \t\t\tPAVGB\" %%mm0, %%mm3\t\t\\n\\t\" \t\t\tPAVGB\" %%mm0, %%mm5\t\t\\n\\t\" \t\t\tPAVGB\" %%mm0, %%mm3\t\t\\n\\t\" \t\t\tPAVGB\" %%mm1, %%mm4\t\t\\n\\t\" \t\t\tPAVGB\" %%mm1, %%mm2\t\t\\n\\t\" \t\t\tPAVGB\" %%mm1, %%mm4\t\t\\n\\t\" \t\t\tPAVGB\" %%mm1, %%mm2\t\t\\n\\t\" \t\t\t\"movq %%mm5, %%mm7\t\t\\n\\t\" \t\t\t\"movq %%mm4, %%mm6\t\t\\n\\t\" \t\t\t\"punpcklbw %%mm3, %%mm5\t\t\\n\\t\" \t\t\t\"punpckhbw %%mm3, %%mm7\t\t\\n\\t\" \t\t\t\"punpcklbw %%mm2, %%mm4\t\t\\n\\t\" \t\t\t\"punpckhbw %%mm2, %%mm6\t\t\\n\\t\" #if 1 \t\t\tMOVNTQ\" %%mm5, (%2, %%\"REGa\", 2)\\n\\t\" \t\t\tMOVNTQ\" %%mm7, 8(%2, %%\"REGa\", 2)\\n\\t\" \t\t\tMOVNTQ\" %%mm4, (%3, %%\"REGa\", 2)\\n\\t\" \t\t\tMOVNTQ\" %%mm6, 8(%3, %%\"REGa\", 2)\\n\\t\" #else \t\t\t\"movq %%mm5, (%2, %%\"REGa\", 2)\t\\n\\t\" \t\t\t\"movq %%mm7, 8(%2, %%\"REGa\", 2)\\n\\t\" \t\t\t\"movq %%mm4, (%3, %%\"REGa\", 2)\t\\n\\t\" \t\t\t\"movq %%mm6, 8(%3, %%\"REGa\", 2)\\n\\t\" #endif \t\t\t\"add $8, %%\"REGa\"\t\t\\n\\t\" \t\t\t\" js 1b\t\t\t\t\\n\\t\" \t\t\t:: \"r\" (src + mmxSize ), \"r\" (src + srcStride + mmxSize ), \t\t\t \"r\" (dst + mmxSize*2), \"r\" (dst + dstStride + mmxSize*2), \t\t\t \"g\" (-mmxSize) \t\t\t: \"%\"REGa \t\t); #else \t\tconst long mmxSize=1; #endif \t\tdst[0 ]= (3*src[0] + src[srcStride])>>2; \t\tdst[dstStride]= ( src[0] + 3*src[srcStride])>>2; \t\tfor(x=mmxSize-1; x<srcWidth-1; x++){ \t\t\tdst[2*x +1]= (3*src[x+0] + src[x+srcStride+1])>>2; \t\t\tdst[2*x+dstStride+2]= ( src[x+0] + 3*src[x+srcStride+1])>>2; \t\t\tdst[2*x+dstStride+1]= ( src[x+1] + 3*src[x+srcStride ])>>2; \t\t\tdst[2*x +2]= (3*src[x+1] + src[x+srcStride ])>>2; \t\t} \t\tdst[srcWidth*2 -1 ]= (3*src[srcWidth-1] + src[srcWidth-1 + srcStride])>>2; \t\tdst[srcWidth*2 -1 + dstStride]= ( src[srcWidth-1] + 3*src[srcWidth-1 + srcStride])>>2; \t\tdst+=dstStride*2; \t\tsrc+=srcStride; \t} \t// last line #if 1 \tdst[0]= src[0]; \tfor(x=0; x<srcWidth-1; x++){ \t\tdst[2*x+1]= (3*src[x] + src[x+1])>>2; \t\tdst[2*x+2]= ( src[x] + 3*src[x+1])>>2; \t} \tdst[2*srcWidth-1]= src[srcWidth-1]; #else \tfor(x=0; x<srcWidth; x++){ \t\tdst[2*x+0]= \t\tdst[2*x+1]= src[x]; \t} #endif #ifdef HAVEMMX asm volatile( EMMS\" \\n\\t\" \tSFENCE\" \\n\\t\" \t:::\"memory\"); #endif } ", "target": 1}
{"func": "static void genmtmsr(DisasContext *ctx) { #if defined(CONFIGUSERONLY) geninvalexception(ctx, POWERPCEXCPPRIVREG); #else if (unlikely(ctx->pr)) { geninvalexception(ctx, POWERPCEXCPPRIVREG); return; } if (ctx->opcode & 0x00010000) { /* Special form that does not need any synchronisation */ TCGv t0 = tcgtempnew(); tcggenanditl(t0, cpugpr[rS(ctx->opcode)], (1 << MSRRI) | (1 << MSREE)); tcggenanditl(cpumsr, cpumsr, ~(targetulong)((1 << MSRRI) | (1 << MSREE))); tcggenortl(cpumsr, cpumsr, t0); tcgtempfree(t0); } else { TCGv msr = tcgtempnew(); /* XXX: we need to update nip before the store * if we enter power saving mode, we will exit the loop * directly from ppcstoremsr */ genupdatenip(ctx, ctx->nip); #if defined(TARGETPPC64) tcggendeposittl(msr, cpumsr, cpugpr[rS(ctx->opcode)], 0, 32); #else tcggenmovtl(msr, cpugpr[rS(ctx->opcode)]); #endif genhelperstoremsr(cpuenv, msr); tcgtempfree(msr); /* Must stop the translation as machine state (may have) changed */ /* Note that mtmsr is not always defined as context-synchronizing */ genstopexception(ctx); } #endif } ", "target": 1}
{"func": "static void flatviewref(FlatView *view) { atomicinc(&view->ref); } ", "target": 1}
{"func": "static int huffbuild10(VLC *vlc, uint8t *len) { HuffEntry he[1024]; uint32t codes[1024]; uint8t bits[1024]; uint16t syms[1024]; uint32t code; int i; for (i = 0; i < 1024; i++) { he[i].sym = 1023 - i; he[i].len = len[i]; } AVQSORT(he, 1024, HuffEntry, huffcmplen10); code = 1; for (i = 1023; i >= 0; i--) { codes[i] = code >> (32 - he[i].len); bits[i] = he[i].len; syms[i] = he[i].sym; code += 0x80000000u >> (he[i].len - 1); } fffreevlc(vlc); return ffinitvlcsparse(vlc, FFMIN(he[1023].len, 12), 1024, bits, sizeof(*bits), sizeof(*bits), codes, sizeof(*codes), sizeof(*codes), syms, sizeof(*syms), sizeof(*syms), 0); }", "target": 1}
{"func": "static void testtaskcomplete(void) { QIOTask *task; Object *obj = objectnew(TYPEDUMMY); Object *src; struct TestTaskData data = { NULL, NULL, false }; task = qiotasknew(obj, taskcallback, &data, NULL); src = qiotaskgetsource(task); qiotaskcomplete(task); gassert(obj == src); objectunref(obj); objectunref(src); gassert(data.source == obj); gassert(data.err == NULL); gassert(data.freed == false); } ", "target": 1}
{"func": "static int nutreadheader(AVFormatContext *s, AVFormatParameters *ap) { NUTContext *nut = s->privdata; ByteIOContext *bc = &s->pb; int64t pos; int initedstreamcount; nut->avf= s; avsetptsinfo(s, 60, 1, AVTIMEBASE); /* main header */ pos=0; for(;;){ if (findstartcode(bc, MAINSTARTCODE, pos)<0){ avlog(s, AVLOGERROR, \"no main startcode found\\n\"); return -1; } pos= urlftell(bc); if(decodemainheader(nut) >= 0) break; } s->bitrate = 0; nut->stream = avmalloc(sizeof(StreamContext)*nut->streamcount); /* stream headers */ pos=0; for(initedstreamcount=0; initedstreamcount < nut->streamcount;){ if (findstartcode(bc, STREAMSTARTCODE, pos)<0){ avlog(s, AVLOGERROR, \"not all stream headers found\\n\"); return -1; } pos= urlftell(bc); if(decodestreamheader(nut) >= 0) initedstreamcount++; } /* info headers */ pos=0; for(;;){ uint64t startcode= findanystartcode(bc, pos); pos= urlftell(bc); if(startcode==0){ avlog(s, AVLOGERROR, \"EOF before video frames\\n\"); return -1; }else if(startcode == KEYFRAMESTARTCODE){ urlfseek(bc, -8, SEEKCUR); //FIXME break; }else if(startcode != INFOSTARTCODE){ continue; } decodeinfoheader(nut); } return 0; } ", "target": 0}
{"func": "int ffv4l2m2mcodecreinit(V4L2m2mContext* s) { int ret; avlog(s->avctx, AVLOGDEBUG, \"reinit context\\n\"); /* 1. streamoff */ ret = ffv4l2contextsetstatus(&s->capture, VIDIOCSTREAMOFF); if (ret) avlog(s->avctx, AVLOGERROR, \"capture VIDIOCSTREAMOFF\\n\"); /* 2. unmap the capture buffers (v4l2 and ffmpeg): * we must wait for all references to be released before being allowed * to queue new buffers. */ avlog(s->avctx, AVLOGDEBUG, \"waiting for user to release AVBufferRefs\\n\"); if (atomicload(&s->refcount)) while(semwait(&s->refsync) == -1 && errno == EINTR); ffv4l2contextrelease(&s->capture); /* 3. get the new capture format */ ret = ffv4l2contextgetformat(&s->capture); if (ret) { avlog(s->avctx, AVLOGERROR, \"query the new capture format\\n\"); return ret; } /* 4. set the capture format */ ret = ffv4l2contextsetformat(&s->capture); if (ret) { avlog(s->avctx, AVLOGERROR, \"setting capture format\\n\"); return ret; } /* 5. complete reinit */ semdestroy(&s->refsync); seminit(&s->refsync, 0, 0); s->draining = 0; s->reinit = 0; return 0; } ", "target": 1}
{"func": "static int wsvqareadheader(AVFormatContext *s, AVFormatParameters *ap) { WsVqaDemuxContext *wsvqa = s->privdata; AVIOContext *pb = s->pb; AVStream *st; unsigned char *header; unsigned char scratch[VQAPREAMBLESIZE]; unsigned int chunktag; unsigned int chunksize; /* initialize the video decoder stream */ st = avnewstream(s, 0); if (!st) return AVERROR(ENOMEM); avsetptsinfo(st, 33, 1, VQAFRAMERATE); wsvqa->videostreamindex = st->index; st->codec->codectype = AVMEDIATYPEVIDEO; st->codec->codecid = CODECIDWSVQA; st->codec->codectag = 0; /* no fourcc */ /* skip to the start of the VQA header */ avioseek(pb, 20, SEEKSET); /* the VQA header needs to go to the decoder */ st->codec->extradatasize = VQAHEADERSIZE; st->codec->extradata = avmallocz(VQAHEADERSIZE + FFINPUTBUFFERPADDINGSIZE); header = (unsigned char *)st->codec->extradata; if (avioread(pb, st->codec->extradata, VQAHEADERSIZE) != VQAHEADERSIZE) { avfree(st->codec->extradata); return AVERROR(EIO); } st->codec->width = AVRL16(&header[6]); st->codec->height = AVRL16(&header[8]); /* initialize the audio decoder stream for VQA v1 or nonzero samplerate */ if (AVRL16(&header[24]) || (AVRL16(&header[0]) == 1 && AVRL16(&header[2]) == 1)) { st = avnewstream(s, 0); if (!st) return AVERROR(ENOMEM); avsetptsinfo(st, 33, 1, VQAFRAMERATE); st->codec->codectype = AVMEDIATYPEAUDIO; if (AVRL16(&header[0]) == 1) st->codec->codecid = CODECIDWESTWOODSND1; else st->codec->codecid = CODECIDADPCMIMAWS; st->codec->codectag = 0; /* no tag */ st->codec->samplerate = AVRL16(&header[24]); if (!st->codec->samplerate) st->codec->samplerate = 22050; st->codec->channels = header[26]; if (!st->codec->channels) st->codec->channels = 1; st->codec->bitspercodedsample = 16; st->codec->bitrate = st->codec->channels * st->codec->samplerate * st->codec->bitspercodedsample / 4; st->codec->blockalign = st->codec->channels * st->codec->bitspercodedsample; wsvqa->audiostreamindex = st->index; wsvqa->audiosamplerate = st->codec->samplerate; wsvqa->audiochannels = st->codec->channels; wsvqa->audioframecounter = 0; } /* there are 0 or more chunks before the FINF chunk; iterate until * FINF has been skipped and the file will be ready to be demuxed */ do { if (avioread(pb, scratch, VQAPREAMBLESIZE) != VQAPREAMBLESIZE) { avfree(st->codec->extradata); return AVERROR(EIO); } chunktag = AVRB32(&scratch[0]); chunksize = AVRB32(&scratch[4]); /* catch any unknown header tags, for curiousity */ switch (chunktag) { case CINFTAG: case CINHTAG: case CINDTAG: case PINFTAG: case PINHTAG: case PINDTAG: case FINFTAG: case CMDSTAG: break; default: avlog (s, AVLOGERROR, \" note: unknown chunk seen (%c%c%c%c)\\n\", scratch[0], scratch[1], scratch[2], scratch[3]); break; } avioskip(pb, chunksize); } while (chunktag != FINFTAG); return 0; } ", "target": 1}
{"func": "int ffwmainit(AVCodecContext *avctx, int flags2) { WMACodecContext *s = avctx->privdata; int i; float bps1, highfreq; volatile float bps; int samplerate1; int coefvlctable; if ( avctx->samplerate <= 0 || avctx->samplerate > 50000 || avctx->channels <= 0 || avctx->channels > 2 || avctx->bitrate <= 0) return -1; fffmtconvertinit(&s->fmtconv, avctx); avprivfloatdspinit(&s->fdsp, avctx->flags & CODECFLAGBITEXACT); if (avctx->codec->id == AVCODECIDWMAV1) { s->version = 1; } else { s->version = 2; /* compute MDCT block size */ s->framelenbits = ffwmagetframelenbits(avctx->samplerate, s->version, 0); s->nextblocklenbits = s->framelenbits; s->prevblocklenbits = s->framelenbits; s->blocklenbits = s->framelenbits; s->framelen = 1 << s->framelenbits; if (s->usevariableblocklen) { int nbmax, nb; nb = ((flags2 >> 3) & 3) + 1; if ((avctx->bitrate / avctx->channels) >= 32000) nb += 2; nbmax = s->framelenbits - BLOCKMINBITS; if (nb > nbmax) nb = nbmax; s->nbblocksizes = nb + 1; } else { s->nbblocksizes = 1; /* init rate dependent parameters */ s->usenoisecoding = 1; highfreq = avctx->samplerate * 0.5; /* if version 2, then the rates are normalized */ samplerate1 = avctx->samplerate; if (s->version == 2) { if (samplerate1 >= 44100) { samplerate1 = 44100; } else if (samplerate1 >= 22050) { samplerate1 = 22050; } else if (samplerate1 >= 16000) { samplerate1 = 16000; } else if (samplerate1 >= 11025) { samplerate1 = 11025; } else if (samplerate1 >= 8000) { samplerate1 = 8000; bps = (float)avctx->bitrate / (float)(avctx->channels * avctx->samplerate); s->byteoffsetbits = avlog2((int)(bps * s->framelen / 8.0 + 0.5)) + 2; /* compute high frequency value and choose if noise coding should be activated */ bps1 = bps; if (avctx->channels == 2) bps1 = bps * 1.6; if (samplerate1 == 44100) { if (bps1 >= 0.61) { s->usenoisecoding = 0; } else { highfreq = highfreq * 0.4; } else if (samplerate1 == 22050) { if (bps1 >= 1.16) { s->usenoisecoding = 0; } else if (bps1 >= 0.72) { highfreq = highfreq * 0.7; } else { highfreq = highfreq * 0.6; } else if (samplerate1 == 16000) { if (bps > 0.5) { highfreq = highfreq * 0.5; } else { highfreq = highfreq * 0.3; } else if (samplerate1 == 11025) { highfreq = highfreq * 0.7; } else if (samplerate1 == 8000) { if (bps <= 0.625) { highfreq = highfreq * 0.5; } else if (bps > 0.75) { s->usenoisecoding = 0; } else { highfreq = highfreq * 0.65; } else { if (bps >= 0.8) { highfreq = highfreq * 0.75; } else if (bps >= 0.6) { highfreq = highfreq * 0.6; } else { highfreq = highfreq * 0.5; avdlog(s->avctx, \"flags2=0x%x\\n\", flags2); avdlog(s->avctx, \"version=%d channels=%d samplerate=%d bitrate=%d blockalign=%d\\n\", s->version, avctx->channels, avctx->samplerate, avctx->bitrate, avctx->blockalign); avdlog(s->avctx, \"bps=%f bps1=%f highfreq=%f bitoffset=%d\\n\", bps, bps1, highfreq, s->byteoffsetbits); avdlog(s->avctx, \"usenoisecoding=%d useexpvlc=%d nbblocksizes=%d\\n\", s->usenoisecoding, s->useexpvlc, s->nbblocksizes); /* compute the scale factor band sizes for each MDCT block size */ { int a, b, pos, lpos, k, blocklen, i, j, n; const uint8t *table; if (s->version == 1) { s->coefsstart = 3; } else { s->coefsstart = 0; for (k = 0; k < s->nbblocksizes; k++) { blocklen = s->framelen >> k; if (s->version == 1) { lpos = 0; for (i = 0; i < 25; i++) { a = ffwmacriticalfreqs[i]; b = avctx->samplerate; pos = ((blocklen * 2 * a) + (b >> 1)) / b; if (pos > blocklen) pos = blocklen; s->exponentbands[0][i] = pos - lpos; if (pos >= blocklen) { i++; break; lpos = pos; s->exponentsizes[0] = i; } else { /* hardcoded tables */ table = NULL; a = s->framelenbits - BLOCKMINBITS - k; if (a < 3) { if (avctx->samplerate >= 44100) { table = exponentband44100[a]; } else if (avctx->samplerate >= 32000) { table = exponentband32000[a]; } else if (avctx->samplerate >= 22050) { table = exponentband22050[a]; if (table) { n = *table++; for (i = 0; i < n; i++) s->exponentbands[k][i] = table[i]; s->exponentsizes[k] = n; } else { j = 0; lpos = 0; for (i = 0; i < 25; i++) { a = ffwmacriticalfreqs[i]; b = avctx->samplerate; pos = ((blocklen * 2 * a) + (b << 1)) / (4 * b); pos <<= 2; if (pos > blocklen) pos = blocklen; if (pos > lpos) s->exponentbands[k][j++] = pos - lpos; if (pos >= blocklen) break; lpos = pos; s->exponentsizes[k] = j; /* max number of coefs */ s->coefsend[k] = (s->framelen - ((s->framelen * 9) / 100)) >> k; /* high freq computation */ s->highbandstart[k] = (int)((blocklen * 2 * highfreq) / avctx->samplerate + 0.5); n = s->exponentsizes[k]; j = 0; pos = 0; for (i = 0; i < n; i++) { int start, end; start = pos; pos += s->exponentbands[k][i]; end = pos; if (start < s->highbandstart[k]) start = s->highbandstart[k]; if (end > s->coefsend[k]) end = s->coefsend[k]; if (end > start) s->exponenthighbands[k][j++] = end - start; s->exponenthighsizes[k] = j; #if 0 tprintf(s->avctx, \"%5d: coefsend=%d highbandstart=%d nbhighbands=%d: \", s->framelen >> k, s->coefsend[k], s->highbandstart[k], s->exponenthighsizes[k]); for (j = 0; j < s->exponenthighsizes[k]; j++) tprintf(s->avctx, \" %d\", s->exponenthighbands[k][j]); tprintf(s->avctx, \"\\n\"); #endif #ifdef TRACE { int i, j; for (i = 0; i < s->nbblocksizes; i++) { tprintf(s->avctx, \"%5d: n=%2d:\", s->framelen >> i, s->exponentsizes[i]); for (j = 0; j < s->exponentsizes[i]; j++) tprintf(s->avctx, \" %d\", s->exponentbands[i][j]); tprintf(s->avctx, \"\\n\"); #endif /* init MDCT windows : simple sinus window */ for (i = 0; i < s->nbblocksizes; i++) { ffinitffsinewindows(s->framelenbits - i); s->windows[i] = ffsinewindows[s->framelenbits - i]; s->resetblocklengths = 1; if (s->usenoisecoding) { /* init the noise generator */ if (s->useexpvlc) { s->noisemult = 0.02; } else { s->noisemult = 0.04; #ifdef TRACE for (i = 0; i < NOISETABSIZE; i++) s->noisetable[i] = 1.0 * s->noisemult; #else { unsigned int seed; float norm; seed = 1; norm = (1.0 / (float)(1LL << 31)) * sqrt(3) * s->noisemult; for (i = 0; i < NOISETABSIZE; i++) { seed = seed * 314159 + 1; s->noisetable[i] = (float)((int)seed) * norm; #endif /* choose the VLC tables for the coefficients */ coefvlctable = 2; if (avctx->samplerate >= 32000) { if (bps1 < 0.72) { coefvlctable = 0; } else if (bps1 < 1.16) { coefvlctable = 1; s->coefvlcs[0]= &coefvlcs[coefvlctable * 2 ]; s->coefvlcs[1]= &coefvlcs[coefvlctable * 2 + 1]; initcoefvlc(&s->coefvlc[0], &s->runtable[0], &s->leveltable[0], &s->inttable[0], s->coefvlcs[0]); initcoefvlc(&s->coefvlc[1], &s->runtable[1], &s->leveltable[1], &s->inttable[1], s->coefvlcs[1]); return 0; ", "target": 1}
{"func": "avcold int ffividecodeclose(AVCodecContext *avctx) { IVI45DecContext *ctx = avctx->privdata; ivifreebuffers(&ctx->planes[0]); if (ctx->mbvlc.custtab.table) fffreevlc(&ctx->mbvlc.custtab); avframefree(&ctx->pframe); return 0; }", "target": 1}
{"func": "int qemuchecknicmodellist(NICInfo *nd, const char * const *models, const char *defaultmodel) { int i, exitstatus = 0; if (!nd->model) nd->model = strdup(defaultmodel); if (strcmp(nd->model, \"?\") != 0) { for (i = 0 ; models[i]; i++) if (strcmp(nd->model, models[i]) == 0) return i; fprintf(stderr, \"qemu: Unsupported NIC model: %s\\n\", nd->model); exitstatus = 1; } fprintf(stderr, \"qemu: Supported NIC models: \"); for (i = 0 ; models[i]; i++) fprintf(stderr, \"%s%c\", models[i], models[i+1] ? ',' : '\\n'); exit(exitstatus); } ", "target": 1}
{"func": "static void virtios390notify(void *opaque, uint16t vector) { VirtIOS390Device *dev = (VirtIOS390Device*)opaque; uint64t token = s390virtiodevicevqtoken(dev, vector); /* XXX kvm dependency! */ kvms390virtioirq(s390cpuaddr2state(0), 0, token); } ", "target": 0}
{"func": "static bool checkthrottleconfig(ThrottleConfig *cfg, Error **errp) { if (throttleconflicting(cfg, errp)) { return false; } if (!throttleisvalid(cfg, errp)) { return false; } if (throttlemaxismissinglimit(cfg, errp)) { return false; } return true; } ", "target": 0}
{"func": "static void decodeblock(BinkAudioContext *s, short *out, int usedct) { int ch, i, j, k; float q, quant[25]; int width, coeff; GetBitContext *gb = &s->gb; if (usedct) skipbits(gb, 2); for (ch = 0; ch < s->channels; ch++) { FFTSample *coeffs = s->coeffsptr[ch]; if (s->versionb) { coeffs[0] = avint2flt(getbits(gb, 32)) * s->root; coeffs[1] = avint2flt(getbits(gb, 32)) * s->root; } else { coeffs[0] = getfloat(gb) * s->root; coeffs[1] = getfloat(gb) * s->root; } for (i = 0; i < s->numbands; i++) { /* constant is result of 0.066399999/log10(ME) */ int value = getbits(gb, 8); quant[i] = expf(FFMIN(value, 95) * 0.15289164787221953823f) * s->root; } k = 0; q = quant[0]; // parse coefficients i = 2; while (i < s->framelen) { if (s->versionb) { j = i + 16; } else if (getbits1(gb)) { j = i + rlelengthtab[getbits(gb, 4)] * 8; } else { j = i + 8; } j = FFMIN(j, s->framelen); width = getbits(gb, 4); if (width == 0) { memset(coeffs + i, 0, (j - i) * sizeof(*coeffs)); i = j; while (s->bands[k] < i) q = quant[k++]; } else { while (i < j) { if (s->bands[k] == i) q = quant[k++]; coeff = getbits(gb, width); if (coeff) { if (getbits1(gb)) coeffs[i] = -q * coeff; else coeffs[i] = q * coeff; } else { coeffs[i] = 0.0f; } i++; } } } if (CONFIGBINKAUDIODCTDECODER && usedct) { coeffs[0] /= 0.5; s->trans.dct.dctcalc(&s->trans.dct, coeffs); s->dsp.vectorfmulscalar(coeffs, coeffs, s->framelen / 2, s->framelen); } else if (CONFIGBINKAUDIORDFTDECODER) s->trans.rdft.rdftcalc(&s->trans.rdft, coeffs); } s->fmtconv.floattoint16interleave(out, (const float **)s->coeffsptr, s->framelen, s->channels); if (!s->first) { int count = s->overlaplen * s->channels; int shift = avlog2(count); for (i = 0; i < count; i++) { out[i] = (s->previous[i] * (count - i) + out[i] * i) >> shift; } } memcpy(s->previous, out + s->blocksize, s->overlaplen * s->channels * sizeof(*out)); s->first = 0; } ", "target": 1}
{"func": "void qemumainloopstart(void) { } ", "target": 1}
{"func": "static int mpegmuxwritepacket(AVFormatContext *ctx, int streamindex, const uint8t *buf, int size, int64t pts) { MpegMuxContext *s = ctx->privdata; AVStream *st = ctx->streams[streamindex]; StreamInfo *stream = st->privdata; int64t dts; int len; /* XXX: system clock should be computed precisely, especially for CBR case. The current mode gives at least something coherent */ if (streamindex == s->scrstreamindex) s->lastscr = pts; #if 0 printf(\"%d: pts=%0.3f scr=%0.3f\\n\", streamindex, pts / 90000.0, s->lastscr / 90000.0); #endif /* XXX: currently no way to pass dts, will change soon */ dts = AVNOPTSVALUE; /* we assume here that pts != AVNOPTSVALUE */ if (stream->startpts == AVNOPTSVALUE) { stream->startpts = pts; stream->startdts = dts; } while (size > 0) { len = s->packetdatamaxsize - stream->bufferptr; if (len > size) len = size; memcpy(stream->buffer + stream->bufferptr, buf, len); stream->bufferptr += len; buf += len; size -= len; while (stream->bufferptr >= s->packetdatamaxsize) { /* output the packet */ flushpacket(ctx, streamindex, stream->startpts, stream->startdts, s->lastscr); /* Make sure only the FIRST pes packet for this frame has a timestamp */ stream->startpts = AVNOPTSVALUE; stream->startdts = AVNOPTSVALUE; } } return 0; } ", "target": 1}
{"func": "static void cpudevinit(const char *cpumodel, unsigned int id, uint64t promaddr, qemuirq **cpuirqs) { CPUState *cs; SPARCCPU *cpu; CPUSPARCState *env; cpu = SPARCCPU(cpugenericinit(TYPESPARCCPU, cpumodel)); if (cpu == NULL) { fprintf(stderr, \"qemu: Unable to find Sparc CPU definition\\n\"); exit(1); } env = &cpu->env; cpusparcsetid(env, id); if (id == 0) { qemuregisterreset(maincpureset, cpu); } else { qemuregisterreset(secondarycpureset, cpu); cs = CPU(cpu); cs->halted = 1; } *cpuirqs = qemuallocateirqs(cpusetirq, cpu, MAXPILS); env->promaddr = promaddr; } ", "target": 1}
{"func": "avcold void avcodecregister(AVCodec *codec) { AVCodec **p; avcodecinit(); p = &firstavcodec; while (*p != NULL) p = &(*p)->next; *p = codec; codec->next = NULL; if (codec->initstaticdata) codec->initstaticdata(codec); } ", "target": 0}
{"func": "static int readnaaid(const uint8t *p, uint64t *pwwn) { int i; if ((p[1] & 0xF) == 3) { /* NAA designator type */ if (p[3] != 8) { return -EINVAL; } *pwwn = ldqbep(p + 4); return 0; } if ((p[1] & 0xF) == 8) { /* SCSI name string designator type */ if (p[3] < 20 || memcmp(&p[4], \"naa.\", 4)) { return -EINVAL; } if (p[3] > 20 && p[24] != ',') { return -EINVAL; } *pwwn = 0; for (i = 8; i < 24; i++) { char c = toupper(p[i]); c -= (c >= '0' && c <= '9' ? '0' : 'A' - 10); *pwwn = (*pwwn << 4) | c; } return 0; } return -EINVAL; } ", "target": 1}
{"func": "static int decodeipictureheader(VC9Context *v) { GetBitContext *gb = &v->s.gb; int pqindex, status = 0; /* Prolog common to all frametypes should be done in caller */ //BF = Buffer Fullness if (v->profile <= PROFILEMAIN && getbits(gb, 7)) { avlog(v->s.avctx, AVLOGDEBUG, \"I BufferFullness not 0\\n\"); } /* Quantizer stuff */ pqindex = getbits(gb, 5); if (v->quantizermode == QUANTFRAMEIMPLICIT) v->pq = pquanttable[0][pqindex]; else { v->pq = pquanttable[v->quantizermode-1][pqindex]; } if (pqindex < 9) v->halfpq = getbits(gb, 1); if (v->quantizermode == QUANTFRAMEEXPLICIT) v->pquantizer = getbits(gb, 1); avlog(v->s.avctx, AVLOGDEBUG, \"I frame: QP=%i (+%i/2)\\n\", v->pq, v->halfpq); #if HASADVANCEDPROFILE if (v->profile <= PROFILEMAIN) #endif { if (v->extendedmv) v->mvrange = getprefix(gb, 0, 3); if (v->multires) v->respic = getbits(gb, 2); } #if HASADVANCEDPROFILE else { v->s.acpred = getbits(gb, 1); if (v->postprocflag) v->postproc = getbits(gb, 1); /* 7.1.1.34 + 8.5.2 */ if (v->overlap && v->pq<9) { v->condover = getbits(gb, 1); if (v->condover) { v->condover = 2+getbits(gb, 1); if (v->condover == 3) { status = bitplanedecoding(&v->overflagsplane, v); if (status < 0) return -1; #if TRACE avlog(v->s.avctx, AVLOGDEBUG, \"Overflags plane encoding: \" \"Imode: %i, Invert: %i\\n\", status>>1, status&1); #endif } } } } #endif /* Epilog (AC/DC syntax) should be done in caller */ return status; } ", "target": 1}
{"func": "static void showstream(AVFormatContext *fmtctx, int streamidx) { AVStream *stream = fmtctx->streams[streamidx]; AVCodecContext *decctx; AVCodec *dec; char valstr[128]; AVDictionaryEntry *tag = NULL; AVRational displayaspectratio; printf(\"[STREAM]\\n\"); printf(\"index=%d\\n\", stream->index); if ((decctx = stream->codec)) { if ((dec = decctx->codec)) { printf(\"codecname=%s\\n\", dec->name); printf(\"codeclongname=%s\\n\", dec->longname); } else { printf(\"codecname=unknown\\n\"); } printf(\"codectype=%s\\n\", mediatypestring(decctx->codectype)); printf(\"codectimebase=%d/%d\\n\", decctx->timebase.num, decctx->timebase.den); /* print AVI/FourCC tag */ avgetcodectagstring(valstr, sizeof(valstr), decctx->codectag); printf(\"codectagstring=%s\\n\", valstr); printf(\"codectag=0x%04x\\n\", decctx->codectag); switch (decctx->codectype) { case AVMEDIATYPEVIDEO: printf(\"width=%d\\n\", decctx->width); printf(\"height=%d\\n\", decctx->height); printf(\"hasbframes=%d\\n\", decctx->hasbframes); if (decctx->sampleaspectratio.num) { printf(\"sampleaspectratio=%d:%d\\n\", decctx->sampleaspectratio.num, decctx->sampleaspectratio.den); avreduce(&displayaspectratio.num, &displayaspectratio.den, decctx->width * decctx->sampleaspectratio.num, decctx->height * decctx->sampleaspectratio.den, 1024*1024); printf(\"displayaspectratio=%d:%d\\n\", displayaspectratio.num, displayaspectratio.den); } printf(\"pixfmt=%s\\n\", decctx->pixfmt != PIXFMTNONE ? avpixfmtdescriptors[decctx->pixfmt].name : \"unknown\"); printf(\"level=%d\\n\", decctx->level); break; case AVMEDIATYPEAUDIO: printf(\"samplerate=%s\\n\", valuestring(valstr, sizeof(valstr), decctx->samplerate, unithertzstr)); printf(\"channels=%d\\n\", decctx->channels); printf(\"bitspersample=%d\\n\", avgetbitspersample(decctx->codecid)); break; } } else { printf(\"codectype=unknown\\n\"); } if (fmtctx->iformat->flags & AVFMTSHOWIDS) printf(\"id=0x%x\\n\", stream->id); printf(\"rframerate=%d/%d\\n\", stream->rframerate.num, stream->rframerate.den); printf(\"avgframerate=%d/%d\\n\", stream->avgframerate.num, stream->avgframerate.den); printf(\"timebase=%d/%d\\n\", stream->timebase.num, stream->timebase.den); printf(\"starttime=%s\\n\", timevaluestring(valstr, sizeof(valstr), stream->starttime, &stream->timebase)); printf(\"duration=%s\\n\", timevaluestring(valstr, sizeof(valstr), stream->duration, &stream->timebase)); if (stream->nbframes) printf(\"nbframes=%\"PRId64\"\\n\", stream->nbframes); while ((tag = avdictget(stream->metadata, \"\", tag, AVDICTIGNORESUFFIX))) printf(\"TAG:%s=%s\\n\", tag->key, tag->value); printf(\"[/STREAM]\\n\"); } ", "target": 0}
{"func": "static void encodeblock(MpegEncContext *s, int16t *block, int n) { int i, j, tableid; int component, dc, lastindex, val, run; MJpegContext *m = s->mjpegctx; /* DC coef */ component = (n <= 3 ? 0 : (n&1) + 1); tableid = (n <= 3 ? 0 : 1); dc = block[0]; /* overflow is impossible */ val = dc - s->lastdc[component]; ffmjpegencodecoef(m, tableid, val, 0); s->lastdc[component] = dc; /* AC coefs */ run = 0; lastindex = s->blocklastindex[n]; tableid |= 2; for(i=1;i<=lastindex;i++) { j = s->intrascantable.permutated[i]; val = block[j]; if (val == 0) { run++; } else { while (run >= 16) { ffmjpegencodecode(m, tableid, 0xf0); run -= 16; } ffmjpegencodecoef(m, tableid, val, run); run = 0; } } /* output EOB only if not already 64 values */ if (lastindex < 63 || run != 0) ffmjpegencodecode(m, tableid, 0); } ", "target": 0}
{"func": "static void RENAME(swScale)(SwsContext *c, uint8t* srcParam[], int srcStrideParam[], int srcSliceY, int srcSliceH, uint8t* dstParam[], int dstStride[]){ \t/* load a few things into local vars to make the code more readable? and faster */ \tconst int srcW= c->srcW; \tconst int dstW= c->dstW; \tconst int dstH= c->dstH; \tconst int chrDstW= c->chrDstW; \tconst int lumXInc= c->lumXInc; \tconst int chrXInc= c->chrXInc; \tconst int dstFormat= c->dstFormat; \tconst int flags= c->flags; \tconst int canMMX2BeUsed= c->canMMX2BeUsed; \tint16t *vLumFilterPos= c->vLumFilterPos; \tint16t *vChrFilterPos= c->vChrFilterPos; \tint16t *hLumFilterPos= c->hLumFilterPos; \tint16t *hChrFilterPos= c->hChrFilterPos; \tint16t *vLumFilter= c->vLumFilter; \tint16t *vChrFilter= c->vChrFilter; \tint16t *hLumFilter= c->hLumFilter; \tint16t *hChrFilter= c->hChrFilter; \tint16t *lumMmxFilter= c->lumMmxFilter; \tint16t *chrMmxFilter= c->chrMmxFilter; \tconst int vLumFilterSize= c->vLumFilterSize; \tconst int vChrFilterSize= c->vChrFilterSize; \tconst int hLumFilterSize= c->hLumFilterSize; \tconst int hChrFilterSize= c->hChrFilterSize; \tint16t **lumPixBuf= c->lumPixBuf; \tint16t **chrPixBuf= c->chrPixBuf; \tconst int vLumBufSize= c->vLumBufSize; \tconst int vChrBufSize= c->vChrBufSize; \tuint8t *funnyYCode= c->funnyYCode; \tuint8t *funnyUVCode= c->funnyUVCode; \tuint8t *formatConvBuffer= c->formatConvBuffer; \t/* vars whch will change and which we need to storw back in the context */ \tint dstY= c->dstY; \tint lumBufIndex= c->lumBufIndex; \tint chrBufIndex= c->chrBufIndex; \tint lastInLumBuf= c->lastInLumBuf; \tint lastInChrBuf= c->lastInChrBuf; \tint srcStride[3]; \tuint8t *src[3]; \tuint8t *dst[3]; \t \tif((c->srcFormat == IMGFMTIYUV) || (c->srcFormat == IMGFMTI420)){ \t\tsrc[0]= srcParam[0]; \t\tsrc[1]= srcParam[2]; \t\tsrc[2]= srcParam[1]; \t\tsrcStride[0]= srcStrideParam[0]; \t\tsrcStride[1]= srcStrideParam[2]; \t\tsrcStride[2]= srcStrideParam[1]; \t} \telse if(c->srcFormat==IMGFMTYV12){ \t\tsrc[0]= srcParam[0]; \t\tsrc[1]= srcParam[1]; \t\tsrc[2]= srcParam[2]; \t\tsrcStride[0]= srcStrideParam[0]; \t\tsrcStride[1]= srcStrideParam[1]; \t\tsrcStride[2]= srcStrideParam[2]; \t} \telse if(isPacked(c->srcFormat)){ \t\tsrc[0]= \t\tsrc[1]= \t\tsrc[2]= srcParam[0]; \t\tsrcStride[0]= srcStrideParam[0]; \t\tsrcStride[1]= \t\tsrcStride[2]= srcStrideParam[0]<<1; \t} \telse if(c->srcFormat==IMGFMTY8){ \t\tsrc[0]= srcParam[0]; \t\tsrc[1]= \t\tsrc[2]= NULL; \t\tsrcStride[0]= srcStrideParam[0]; \t\tsrcStride[1]= \t\tsrcStride[2]= 0; \t} \tif((c->dstFormat == IMGFMTIYUV) || (c->dstFormat == IMGFMTI420)){ \t\tdst[0]= dstParam[0]; \t\tdst[1]= dstParam[2]; \t\tdst[2]= dstParam[1]; \t\t \t}else{ \t\tdst[0]= dstParam[0]; \t\tdst[1]= dstParam[1]; \t\tdst[2]= dstParam[2]; \t} \t \tif(dstStride[0]%8 !=0 || dstStride[1]%8 !=0 || dstStride[2]%8 !=0) \t{ \t\tstatic int firstTime=1; //FIXME move this into the context perhaps \t\tif(flags & SWSPRINTINFO && firstTime) \t\t{ \t\t\tfprintf(stderr, \"SwScaler: Warning: dstStride is not aligned!\\n\" \t\t\t\t\t\"SwScaler: ->cannot do aligned memory acesses anymore\\n\"); \t\t\tfirstTime=0; \t\t} \t} \t/* Note the user might start scaling the picture in the middle so this will not get executed \t this is not really intended but works currently, so ppl might do it */ \tif(srcSliceY ==0){ \t\tlumBufIndex=0; \t\tchrBufIndex=0; \t\tdstY=0;\t \t\tlastInLumBuf= -1; \t\tlastInChrBuf= -1; \t} \tfor(;dstY < dstH; dstY++){ \t\tunsigned char *dest =dst[0]+dstStride[0]*dstY; \t\tunsigned char *uDest=dst[1]+dstStride[1]*(dstY>>1); \t\tunsigned char *vDest=dst[2]+dstStride[2]*(dstY>>1); \t\tconst int chrDstY= isHalfChrV(dstFormat) ? (dstY>>1) : dstY; \t\tconst int firstLumSrcY= vLumFilterPos[dstY]; //First line needed as input \t\tconst int firstChrSrcY= vChrFilterPos[chrDstY]; //First line needed as input \t\tconst int lastLumSrcY= firstLumSrcY + vLumFilterSize -1; // Last line needed as input \t\tconst int lastChrSrcY= firstChrSrcY + vChrFilterSize -1; // Last line needed as input \t\t//handle holes (FASTBILINEAR & weird filters) \t\tif(firstLumSrcY > lastInLumBuf) lastInLumBuf= firstLumSrcY-1; \t\tif(firstChrSrcY > lastInChrBuf) lastInChrBuf= firstChrSrcY-1; //printf(\"%d %d %d\\n\", firstChrSrcY, lastInChrBuf, vChrBufSize); \t\tASSERT(firstLumSrcY >= lastInLumBuf - vLumBufSize + 1) \t\tASSERT(firstChrSrcY >= lastInChrBuf - vChrBufSize + 1) \t\t// Do we have enough lines in this slice to output the dstY line \t\tif(lastLumSrcY < srcSliceY + srcSliceH && lastChrSrcY < ((srcSliceY + srcSliceH)>>1)) \t\t{ \t\t\t//Do horizontal scaling \t\t\twhile(lastInLumBuf < lastLumSrcY) \t\t\t{ \t\t\t\tuint8t *s= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0]; \t\t\t\tlumBufIndex++; //\t\t\t\tprintf(\"%d %d %d %d\\n\", lumBufIndex, vLumBufSize, lastInLumBuf, lastLumSrcY); \t\t\t\tASSERT(lumBufIndex < 2*vLumBufSize) \t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY < srcSliceH) \t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY >= 0) //\t\t\t\tprintf(\"%d %d\\n\", lumBufIndex, vLumBufSize); \t\t\t\tRENAME(hyscale)(lumPixBuf[ lumBufIndex ], dstW, s, srcW, lumXInc, \t\t\t\t\t\tflags, canMMX2BeUsed, hLumFilter, hLumFilterPos, hLumFilterSize, \t\t\t\t\t\tfunnyYCode, c->srcFormat, formatConvBuffer); \t\t\t\tlastInLumBuf++; \t\t\t} \t\t\twhile(lastInChrBuf < lastChrSrcY) \t\t\t{ \t\t\t\tuint8t *src1= src[1]+(lastInChrBuf + 1 - (srcSliceY>>1))*srcStride[1]; \t\t\t\tuint8t *src2= src[2]+(lastInChrBuf + 1 - (srcSliceY>>1))*srcStride[2]; \t\t\t\tchrBufIndex++; \t\t\t\tASSERT(chrBufIndex < 2*vChrBufSize) \t\t\t\tASSERT(lastInChrBuf + 1 - (srcSliceY>>1) < (srcSliceH>>1)) \t\t\t\tASSERT(lastInChrBuf + 1 - (srcSliceY>>1) >= 0) \t\t\t\t//FIXME replace parameters through context struct (some at least) \t\t\t\tRENAME(hcscale)(chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, (srcW+1)>>1, chrXInc, \t\t\t\t\t\tflags, canMMX2BeUsed, hChrFilter, hChrFilterPos, hChrFilterSize, \t\t\t\t\t\tfunnyUVCode, c->srcFormat, formatConvBuffer); \t\t\t\tlastInChrBuf++; \t\t\t} \t\t\t//wrap buf index around to stay inside the ring buffer \t\t\tif(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize; \t\t\tif(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize; \t\t} \t\telse // not enough lines left in this slice -> load the rest in the buffer \t\t{ /*\t\tprintf(\"%d %d Last:%d %d LastInBuf:%d %d Index:%d %d Y:%d FSize: %d %d BSize: %d %d\\n\", \t\t\tfirstChrSrcY,firstLumSrcY,lastChrSrcY,lastLumSrcY, \t\t\tlastInChrBuf,lastInLumBuf,chrBufIndex,lumBufIndex,dstY,vChrFilterSize,vLumFilterSize, \t\t\tvChrBufSize, vLumBufSize); */ \t\t\t//Do horizontal scaling \t\t\twhile(lastInLumBuf+1 < srcSliceY + srcSliceH) \t\t\t{ \t\t\t\tuint8t *s= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0]; \t\t\t\tlumBufIndex++; \t\t\t\tASSERT(lumBufIndex < 2*vLumBufSize) \t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY < srcSliceH) \t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY >= 0) \t\t\t\tRENAME(hyscale)(lumPixBuf[ lumBufIndex ], dstW, s, srcW, lumXInc, \t\t\t\t\t\tflags, canMMX2BeUsed, hLumFilter, hLumFilterPos, hLumFilterSize, \t\t\t\t\t\tfunnyYCode, c->srcFormat, formatConvBuffer); \t\t\t\tlastInLumBuf++; \t\t\t} \t\t\twhile(lastInChrBuf+1 < ((srcSliceY + srcSliceH)>>1)) \t\t\t{ \t\t\t\tuint8t *src1= src[1]+(lastInChrBuf + 1 - (srcSliceY>>1))*srcStride[1]; \t\t\t\tuint8t *src2= src[2]+(lastInChrBuf + 1 - (srcSliceY>>1))*srcStride[2]; \t\t\t\tchrBufIndex++; \t\t\t\tASSERT(chrBufIndex < 2*vChrBufSize) \t\t\t\tASSERT(lastInChrBuf + 1 - (srcSliceY>>1) < (srcSliceH>>1)) \t\t\t\tASSERT(lastInChrBuf + 1 - (srcSliceY>>1) >= 0) \t\t\t\tRENAME(hcscale)(chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, (srcW+1)>>1, chrXInc, \t\t\t\t\t\tflags, canMMX2BeUsed, hChrFilter, hChrFilterPos, hChrFilterSize, \t\t\t\t\t\tfunnyUVCode, c->srcFormat, formatConvBuffer); \t\t\t\tlastInChrBuf++; \t\t\t} \t\t\t//wrap buf index around to stay inside the ring buffer \t\t\tif(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize; \t\t\tif(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize; \t\t\tbreak; //we cant output a dstY line so lets try with the next slice \t\t} #ifdef HAVEMMX \t\tb5Dither= dither8[dstY&1]; \t\tg6Dither= dither4[dstY&1]; \t\tg5Dither= dither8[dstY&1]; \t\tr5Dither= dither8[(dstY+1)&1]; #endif \t if(dstY < dstH-2) \t { \t\tif(isPlanarYUV(dstFormat)) //YV12 like \t\t{ \t\t\tif(dstY&1) uDest=vDest= NULL; //FIXME split functions in lumi / chromi \t\t\tif(vLumFilterSize == 1 && vChrFilterSize == 1) // Unscaled YV12 \t\t\t{ \t\t\t\tint16t *lumBuf = lumPixBuf[0]; \t\t\t\tint16t *chrBuf= chrPixBuf[0]; \t\t\t\tRENAME(yuv2yuv1)(lumBuf, chrBuf, dest, uDest, vDest, dstW); \t\t\t} \t\t\telse //General YV12 \t\t\t{ \t\t\t\tint16t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize; \t\t\t\tint16t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize; \t\t\t\tRENAME(yuv2yuvX)( \t\t\t\t\tvLumFilter+dstY*vLumFilterSize , lumSrcPtr, vLumFilterSize, \t\t\t\t\tvChrFilter+(dstY>>1)*vChrFilterSize, chrSrcPtr, vChrFilterSize, \t\t\t\t\tdest, uDest, vDest, dstW, \t\t\t\t\tlumMmxFilter+dstY*vLumFilterSize*4, chrMmxFilter+(dstY>>1)*vChrFilterSize*4); \t\t\t} \t\t} \t\telse \t\t{ \t\t\tint16t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize; \t\t\tint16t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize; \t\t\tASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2); \t\t\tASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2); \t\t\tif(vLumFilterSize == 1 && vChrFilterSize == 2) //Unscaled RGB \t\t\t{ \t\t\t\tint chrAlpha= vChrFilter[2*dstY+1]; \t\t\t\tRENAME(yuv2rgb1)(*lumSrcPtr, *chrSrcPtr, *(chrSrcPtr+1), \t\t\t\t\t\t dest, dstW, chrAlpha, dstFormat, flags); \t\t\t} \t\t\telse if(vLumFilterSize == 2 && vChrFilterSize == 2) //BiLinear Upscale RGB \t\t\t{ \t\t\t\tint lumAlpha= vLumFilter[2*dstY+1]; \t\t\t\tint chrAlpha= vChrFilter[2*dstY+1]; \t\t\t\tRENAME(yuv2rgb2)(*lumSrcPtr, *(lumSrcPtr+1), *chrSrcPtr, *(chrSrcPtr+1), \t\t\t\t\t\t dest, dstW, lumAlpha, chrAlpha, dstFormat, flags); \t\t\t} \t\t\telse //General RGB \t\t\t{ \t\t\t\tRENAME(yuv2rgbX)( \t\t\t\t\tvLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize, \t\t\t\t\tvChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize, \t\t\t\t\tdest, dstW, dstFormat, \t\t\t\t\tlumMmxFilter+dstY*vLumFilterSize*4, chrMmxFilter+dstY*vChrFilterSize*4); \t\t\t} \t\t} } \t else // hmm looks like we cant use MMX here without overwriting this arrays tail \t { \t\tint16t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize; \t\tint16t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize; \t\tif(isPlanarYUV(dstFormat)) //YV12 \t\t{ \t\t\tif(dstY&1) uDest=vDest= NULL; //FIXME split functions in lumi / chromi \t\t\tyuv2yuvXinC( \t\t\t\tvLumFilter+dstY*vLumFilterSize , lumSrcPtr, vLumFilterSize, \t\t\t\tvChrFilter+(dstY>>1)*vChrFilterSize, chrSrcPtr, vChrFilterSize, \t\t\t\tdest, uDest, vDest, dstW); \t\t} \t\telse \t\t{ \t\t\tASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2); \t\t\tASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2); \t\t\tyuv2rgbXinC( \t\t\t\tvLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize, \t\t\t\tvChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize, \t\t\t\tdest, dstW, dstFormat); \t\t} \t } \t} #ifdef HAVEMMX \tasm volatile(SFENCE:::\"memory\"); \tasm volatile(EMMS:::\"memory\"); #endif \t/* store changed local vars back in the context */ \tc->dstY= dstY; \tc->lumBufIndex= lumBufIndex; \tc->chrBufIndex= chrBufIndex; \tc->lastInLumBuf= lastInLumBuf; \tc->lastInChrBuf= lastInChrBuf; } ", "target": 0}
{"func": "static int vscsiqueuecmd(VSCSIState *s, vscsireq *req) { union srpiu *srp = &req->iu.srp; SCSIDevice *sdev; int n, id, lun; vscsidecodeidlun(be64tocpu(srp->cmd.lun), &id, &lun); /* Qemu vs. linux issue with LUNs to be sorted out ... */ sdev = (id < 8 && lun < 16) ? s->bus.devs[id] : NULL; if (!sdev) { dprintf(\"VSCSI: Command for id %d with no drive\\n\", id); if (srp->cmd.cdb[0] == INQUIRY) { vscsiinquirynotarget(s, req); } else { vscsimakeupsense(s, req, ILLEGALREQUEST, 0x24, 0x00); vscsisendrsp(s, req, CHECKCONDITION, 0, 0); } return 1; } req->sdev = sdev; req->lun = lun; n = sdev->info->sendcommand(sdev, req->qtag, srp->cmd.cdb, lun); dprintf(\"VSCSI: Queued command tag 0x%x CMD 0x%x ID %d LUN %d ret: %d\\n\", req->qtag, srp->cmd.cdb[0], id, lun, n); if (n) { /* Transfer direction must be set before preprocessing the * descriptors */ req->writing = (n < 1); /* Preprocess RDMA descriptors */ vscsipreprocessdesc(req); } /* Get transfer direction and initiate transfer */ if (n > 0) { req->datalen = n; sdev->info->readdata(sdev, req->qtag); } else if (n < 0) { req->datalen = -n; sdev->info->writedata(sdev, req->qtag); } /* Don't touch req here, it may have been recycled already */ return 0; } ", "target": 1}
{"func": "static int dosendvrecvv(int sockfd, struct iovec *iov, int len, int offset, int dosendv) { int ret, diff, iovlen; struct iovec *lastiov; /* lastiov is inclusive, so count from one. */ iovlen = 1; lastiov = iov; len += offset; while (lastiov->iovlen < len) { len -= lastiov->iovlen; lastiov++; iovlen++; } diff = lastiov->iovlen - len; lastiov->iovlen -= diff; while (iov->iovlen <= offset) { offset -= iov->iovlen; iov++; iovlen--; } iov->iovbase = (char *) iov->iovbase + offset; iov->iovlen -= offset; { #if defined CONFIGIOVEC && defined CONFIGPOSIX struct msghdr msg; memset(&msg, 0, sizeof(msg)); msg.msgiov = iov; msg.msgiovlen = iovlen; do { if (dosendv) { ret = sendmsg(sockfd, &msg, 0); } else { ret = recvmsg(sockfd, &msg, 0); } } while (ret == -1 && errno == EINTR); #else struct iovec *p = iov; ret = 0; while (iovlen > 0) { int rc; if (dosendv) { rc = send(sockfd, p->iovbase, p->iovlen, 0); } else { rc = qemurecv(sockfd, p->iovbase, p->iovlen, 0); } if (rc == -1) { if (errno == EINTR) { continue; } if (ret == 0) { ret = -1; } break; } if (rc == 0) { break; } ret += rc; iovlen--, p++; } #endif } /* Undo the changes above */ iov->iovbase = (char *) iov->iovbase - offset; iov->iovlen += offset; lastiov->iovlen += diff; return ret; } ", "target": 1}
{"func": "static int vp9decodeframe(AVCodecContext *ctx, void *frame, int *gotframe, AVPacket *pkt) { const uint8t *data = pkt->data; int size = pkt->size; VP9Context *s = ctx->privdata; int res, tilerow, tilecol, i, ref, row, col; int retainsegmapref = s->s.frames[REFFRAMESEGMAP].segmentationmap && (!s->s.h.segmentation.enabled || !s->s.h.segmentation.updatemap); ptrdifft yoff, uvoff, lsy, lsuv; AVFrame *f; int bytesperpixel; if ((res = decodeframeheader(ctx, data, size, &ref)) < 0) { return res; } else if (res == 0) { if (!s->s.refs[ref].f->buf[0]) { avlog(ctx, AVLOGERROR, \"Requested reference %d not available\\n\", ref); return AVERRORINVALIDDATA; } if ((res = avframeref(frame, s->s.refs[ref].f)) < 0) return res; ((AVFrame *)frame)->pts = pkt->pts; #if FFAPIPKTPTS FFDISABLEDEPRECATIONWARNINGS ((AVFrame *)frame)->pktpts = pkt->pts; FFENABLEDEPRECATIONWARNINGS #endif ((AVFrame *)frame)->pktdts = pkt->dts; for (i = 0; i < 8; i++) { if (s->nextrefs[i].f->buf[0]) ffthreadreleasebuffer(ctx, &s->nextrefs[i]); if (s->s.refs[i].f->buf[0] && (res = ffthreadrefframe(&s->nextrefs[i], &s->s.refs[i])) < 0) return res; } *gotframe = 1; return pkt->size; } data += res; size -= res; if (!retainsegmapref || s->s.h.keyframe || s->s.h.intraonly) { if (s->s.frames[REFFRAMESEGMAP].tf.f->buf[0]) vp9unrefframe(ctx, &s->s.frames[REFFRAMESEGMAP]); if (!s->s.h.keyframe && !s->s.h.intraonly && !s->s.h.errorres && s->s.frames[CURFRAME].tf.f->buf[0] && (res = vp9refframe(ctx, &s->s.frames[REFFRAMESEGMAP], &s->s.frames[CURFRAME])) < 0) return res; } if (s->s.frames[REFFRAMEMVPAIR].tf.f->buf[0]) vp9unrefframe(ctx, &s->s.frames[REFFRAMEMVPAIR]); if (!s->s.h.intraonly && !s->s.h.keyframe && !s->s.h.errorres && s->s.frames[CURFRAME].tf.f->buf[0] && (res = vp9refframe(ctx, &s->s.frames[REFFRAMEMVPAIR], &s->s.frames[CURFRAME])) < 0) return res; if (s->s.frames[CURFRAME].tf.f->buf[0]) vp9unrefframe(ctx, &s->s.frames[CURFRAME]); if ((res = vp9allocframe(ctx, &s->s.frames[CURFRAME])) < 0) return res; f = s->s.frames[CURFRAME].tf.f; f->keyframe = s->s.h.keyframe; f->picttype = (s->s.h.keyframe || s->s.h.intraonly) ? AVPICTURETYPEI : AVPICTURETYPEP; lsy = f->linesize[0]; lsuv =f->linesize[1]; if (s->s.frames[REFFRAMESEGMAP].tf.f->buf[0] && (s->s.frames[REFFRAMEMVPAIR].tf.f->width != s->s.frames[CURFRAME].tf.f->width || s->s.frames[REFFRAMEMVPAIR].tf.f->height != s->s.frames[CURFRAME].tf.f->height)) { vp9unrefframe(ctx, &s->s.frames[REFFRAMESEGMAP]); } // ref frame setup for (i = 0; i < 8; i++) { if (s->nextrefs[i].f->buf[0]) ffthreadreleasebuffer(ctx, &s->nextrefs[i]); if (s->s.h.refreshrefmask & (1 << i)) { res = ffthreadrefframe(&s->nextrefs[i], &s->s.frames[CURFRAME].tf); } else if (s->s.refs[i].f->buf[0]) { res = ffthreadrefframe(&s->nextrefs[i], &s->s.refs[i]); } if (res < 0) return res; } if (ctx->hwaccel) { res = ctx->hwaccel->startframe(ctx, NULL, 0); if (res < 0) return res; res = ctx->hwaccel->decodeslice(ctx, pkt->data, pkt->size); if (res < 0) return res; res = ctx->hwaccel->endframe(ctx); if (res < 0) return res; goto finish; } // main tile decode loop bytesperpixel = s->bytesperpixel; memset(s->abovepartitionctx, 0, s->cols); memset(s->aboveskipctx, 0, s->cols); if (s->s.h.keyframe || s->s.h.intraonly) { memset(s->abovemodectx, DCPRED, s->cols * 2); } else { memset(s->abovemodectx, NEARESTMV, s->cols); } memset(s->aboveynnzctx, 0, s->sbcols * 16); memset(s->aboveuvnnzctx[0], 0, s->sbcols * 16 >> s->ssh); memset(s->aboveuvnnzctx[1], 0, s->sbcols * 16 >> s->ssh); memset(s->abovesegpredctx, 0, s->cols); s->pass = s->s.frames[CURFRAME].uses2pass = ctx->activethreadtype == FFTHREADFRAME && s->s.h.refreshctx && !s->s.h.parallelmode; if ((res = updateblockbuffers(ctx)) < 0) { avlog(ctx, AVLOGERROR, \"Failed to allocate block buffers\\n\"); return res; } if (s->s.h.refreshctx && s->s.h.parallelmode) { int j, k, l, m; for (i = 0; i < 4; i++) { for (j = 0; j < 2; j++) for (k = 0; k < 2; k++) for (l = 0; l < 6; l++) for (m = 0; m < 6; m++) memcpy(s->probctx[s->s.h.framectxid].coef[i][j][k][l][m], s->prob.coef[i][j][k][l][m], 3); if (s->s.h.txfmmode == i) break; } s->probctx[s->s.h.framectxid].p = s->prob.p; ffthreadfinishsetup(ctx); } else if (!s->s.h.refreshctx) { ffthreadfinishsetup(ctx); } do { yoff = uvoff = 0; s->b = s->bbase; s->block = s->blockbase; s->uvblock[0] = s->uvblockbase[0]; s->uvblock[1] = s->uvblockbase[1]; s->eob = s->eobbase; s->uveob[0] = s->uveobbase[0]; s->uveob[1] = s->uveobbase[1]; for (tilerow = 0; tilerow < s->s.h.tiling.tilerows; tilerow++) { settileoffset(&s->tilerowstart, &s->tilerowend, tilerow, s->s.h.tiling.log2tilerows, s->sbrows); if (s->pass != 2) { for (tilecol = 0; tilecol < s->s.h.tiling.tilecols; tilecol++) { int64t tilesize; if (tilecol == s->s.h.tiling.tilecols - 1 && tilerow == s->s.h.tiling.tilerows - 1) { tilesize = size; } else { tilesize = AVRB32(data); data += 4; size -= 4; } if (tilesize > size) { ffthreadreportprogress(&s->s.frames[CURFRAME].tf, INTMAX, 0); return AVERRORINVALIDDATA; } ffvp56initrangedecoder(&s->cb[tilecol], data, tilesize); if (vp56racgetprobbranchy(&s->cb[tilecol], 128)) { // marker bit ffthreadreportprogress(&s->s.frames[CURFRAME].tf, INTMAX, 0); return AVERRORINVALIDDATA; } data += tilesize; size -= tilesize; } } for (row = s->tilerowstart; row < s->tilerowend; row += 8, yoff += lsy * 64, uvoff += lsuv * 64 >> s->ssv) { struct VP9Filter *lflvlptr = s->lflvl; ptrdifft yoff2 = yoff, uvoff2 = uvoff; for (tilecol = 0; tilecol < s->s.h.tiling.tilecols; tilecol++) { settileoffset(&s->tilecolstart, &s->tilecolend, tilecol, s->s.h.tiling.log2tilecols, s->sbcols); if (s->pass != 2) { memset(s->leftpartitionctx, 0, 8); memset(s->leftskipctx, 0, 8); if (s->s.h.keyframe || s->s.h.intraonly) { memset(s->leftmodectx, DCPRED, 16); } else { memset(s->leftmodectx, NEARESTMV, 8); } memset(s->leftynnzctx, 0, 16); memset(s->leftuvnnzctx, 0, 32); memset(s->leftsegpredctx, 0, 8); memcpy(&s->c, &s->cb[tilecol], sizeof(s->c)); } for (col = s->tilecolstart; col < s->tilecolend; col += 8, yoff2 += 64 * bytesperpixel, uvoff2 += 64 * bytesperpixel >> s->ssh, lflvlptr++) { // FIXME integrate with lf code (i.e. zero after each // use, similar to invtxfm coefficients, or similar) if (s->pass != 1) { memset(lflvlptr->mask, 0, sizeof(lflvlptr->mask)); } if (s->pass == 2) { decodesbmem(ctx, row, col, lflvlptr, yoff2, uvoff2, BL64X64); } else { decodesb(ctx, row, col, lflvlptr, yoff2, uvoff2, BL64X64); } } if (s->pass != 2) { memcpy(&s->cb[tilecol], &s->c, sizeof(s->c)); } } if (s->pass == 1) { continue; } // backup pre-loopfilter reconstruction data for intra // prediction of next row of sb64s if (row + 8 < s->rows) { memcpy(s->intrapreddata[0], f->data[0] + yoff + 63 * lsy, 8 * s->cols * bytesperpixel); memcpy(s->intrapreddata[1], f->data[1] + uvoff + ((64 >> s->ssv) - 1) * lsuv, 8 * s->cols * bytesperpixel >> s->ssh); memcpy(s->intrapreddata[2], f->data[2] + uvoff + ((64 >> s->ssv) - 1) * lsuv, 8 * s->cols * bytesperpixel >> s->ssh); } // loopfilter one row if (s->s.h.filter.level) { yoff2 = yoff; uvoff2 = uvoff; lflvlptr = s->lflvl; for (col = 0; col < s->cols; col += 8, yoff2 += 64 * bytesperpixel, uvoff2 += 64 * bytesperpixel >> s->ssh, lflvlptr++) { loopfiltersb(ctx, lflvlptr, row, col, yoff2, uvoff2); } } // FIXME maybe we can make this more finegrained by running the // loopfilter per-block instead of after each sbrow // In fact that would also make intra pred left preparation easier? ffthreadreportprogress(&s->s.frames[CURFRAME].tf, row >> 3, 0); } } if (s->pass < 2 && s->s.h.refreshctx && !s->s.h.parallelmode) { adaptprobs(s); ffthreadfinishsetup(ctx); } } while (s->pass++ == 1); ffthreadreportprogress(&s->s.frames[CURFRAME].tf, INTMAX, 0); finish: // ref frame setup for (i = 0; i < 8; i++) { if (s->s.refs[i].f->buf[0]) ffthreadreleasebuffer(ctx, &s->s.refs[i]); if (s->nextrefs[i].f->buf[0] && (res = ffthreadrefframe(&s->s.refs[i], &s->nextrefs[i])) < 0) return res; } if (!s->s.h.invisible) { if ((res = avframeref(frame, s->s.frames[CURFRAME].tf.f)) < 0) return res; *gotframe = 1; } return pkt->size; } ", "target": 1}
{"func": "static uint64t gt64120readl (void *opaque, targetphysaddrt addr, unsigned size) { GT64120State *s = opaque; PCIHostState *phb = PCIHOSTBRIDGE(s); uint32t val; uint32t saddr; saddr = (addr & 0xfff) >> 2; switch (saddr) { /* CPU Configuration */ case GTMULTI: /* Only one GT64xxx is present on the CPU bus, return the initial value */ val = s->regs[saddr]; break; /* CPU Error Report */ case GTCPUERRADDRLO: case GTCPUERRADDRHI: case GTCPUERRDATALO: case GTCPUERRDATAHI: case GTCPUERRPARITY: /* Emulated memory has no error, always return the initial values */ val = s->regs[saddr]; break; /* CPU Sync Barrier */ case GTPCI0SYNC: case GTPCI1SYNC: /* Reading those register should empty all FIFO on the PCI bus, which are not emulated. The return value should be a random value that should be ignored. */ val = 0xc000ffee; break; /* ECC */ case GTECCERRDATALO: case GTECCERRDATAHI: case GTECCMEM: case GTECCCALC: case GTECCERRADDR: /* Emulated memory has no error, always return the initial values */ val = s->regs[saddr]; break; case GTCPU: case GTSCS10LD: case GTSCS10HD: case GTSCS32LD: case GTSCS32HD: case GTCS20LD: case GTCS20HD: case GTCS3BOOTLD: case GTCS3BOOTHD: case GTSCS10AR: case GTSCS32AR: case GTCS20R: case GTCS3BOOTR: case GTPCI0IOLD: case GTPCI0M0LD: case GTPCI0M1LD: case GTPCI1IOLD: case GTPCI1M0LD: case GTPCI1M1LD: case GTPCI0IOHD: case GTPCI0M0HD: case GTPCI0M1HD: case GTPCI1IOHD: case GTPCI1M0HD: case GTPCI1M1HD: case GTPCI0IOREMAP: case GTPCI0M0REMAP: case GTPCI0M1REMAP: case GTPCI1IOREMAP: case GTPCI1M0REMAP: case GTPCI1M1REMAP: case GTISD: val = s->regs[saddr]; break; case GTPCI0IACK: /* Read the IRQ number */ val = picreadirq(isapic); break; /* SDRAM and Device Address Decode */ case GTSCS0LD: case GTSCS0HD: case GTSCS1LD: case GTSCS1HD: case GTSCS2LD: case GTSCS2HD: case GTSCS3LD: case GTSCS3HD: case GTCS0LD: case GTCS0HD: case GTCS1LD: case GTCS1HD: case GTCS2LD: case GTCS2HD: case GTCS3LD: case GTCS3HD: case GTBOOTLD: case GTBOOTHD: case GTADERR: val = s->regs[saddr]; break; /* SDRAM Configuration */ case GTSDRAMCFG: case GTSDRAMOPMODE: case GTSDRAMBM: case GTSDRAMADDRDECODE: val = s->regs[saddr]; break; /* SDRAM Parameters */ case GTSDRAMB0: case GTSDRAMB1: case GTSDRAMB2: case GTSDRAMB3: /* We don't simulate electrical parameters of the SDRAM. Just return the last written value. */ val = s->regs[saddr]; break; /* Device Parameters */ case GTDEVB0: case GTDEVB1: case GTDEVB2: case GTDEVB3: case GTDEVBOOT: val = s->regs[saddr]; break; /* DMA Record */ case GTDMA0CNT: case GTDMA1CNT: case GTDMA2CNT: case GTDMA3CNT: case GTDMA0SA: case GTDMA1SA: case GTDMA2SA: case GTDMA3SA: case GTDMA0DA: case GTDMA1DA: case GTDMA2DA: case GTDMA3DA: case GTDMA0NEXT: case GTDMA1NEXT: case GTDMA2NEXT: case GTDMA3NEXT: case GTDMA0CUR: case GTDMA1CUR: case GTDMA2CUR: case GTDMA3CUR: val = s->regs[saddr]; break; /* DMA Channel Control */ case GTDMA0CTRL: case GTDMA1CTRL: case GTDMA2CTRL: case GTDMA3CTRL: val = s->regs[saddr]; break; /* DMA Arbiter */ case GTDMAARB: val = s->regs[saddr]; break; /* Timer/Counter */ case GTTC0: case GTTC1: case GTTC2: case GTTC3: case GTTCCONTROL: val = s->regs[saddr]; break; /* PCI Internal */ case GTPCI0CFGADDR: val = phb->configreg; break; case GTPCI0CFGDATA: if (!(phb->configreg & (1 << 31))) { val = 0xffffffff; } else { val = pcidataread(phb->bus, phb->configreg, 4); } if (!(s->regs[GTPCI0CMD] & 1) && (phb->configreg & 0x00fff800)) { val = bswap32(val); } break; case GTPCI0CMD: case GTPCI0TOR: case GTPCI0BSSCS10: case GTPCI0BSSCS32: case GTPCI0BSCS20: case GTPCI0BSCS3BT: case GTPCI1IACK: case GTPCI0BARE: case GTPCI0PREFMBR: case GTPCI0SCS10BAR: case GTPCI0SCS32BAR: case GTPCI0CS20BAR: case GTPCI0CS3BTBAR: case GTPCI0SSCS10BAR: case GTPCI0SSCS32BAR: case GTPCI0SCS3BTBAR: case GTPCI1CMD: case GTPCI1TOR: case GTPCI1BSSCS10: case GTPCI1BSSCS32: case GTPCI1BSCS20: case GTPCI1BSCS3BT: case GTPCI1BARE: case GTPCI1PREFMBR: case GTPCI1SCS10BAR: case GTPCI1SCS32BAR: case GTPCI1CS20BAR: case GTPCI1CS3BTBAR: case GTPCI1SSCS10BAR: case GTPCI1SSCS32BAR: case GTPCI1SCS3BTBAR: case GTPCI1CFGADDR: case GTPCI1CFGDATA: val = s->regs[saddr]; break; /* Interrupts */ case GTINTRCAUSE: val = s->regs[saddr]; DPRINTF(\"INTRCAUSE %x\\n\", val); break; case GTINTRMASK: val = s->regs[saddr]; DPRINTF(\"INTRMASK %x\\n\", val); break; case GTPCI0ICMASK: val = s->regs[saddr]; DPRINTF(\"ICMASK %x\\n\", val); break; case GTPCI0SERR0MASK: val = s->regs[saddr]; DPRINTF(\"SERR0MASK %x\\n\", val); break; /* Reserved when only PCI0 is configured. */ case GTHINTRCAUSE: case GTCPUINTSEL: case GTPCI0INTSEL: case GTHINTRMASK: case GTPCI0HICMASK: case GTPCI1SERR1MASK: val = s->regs[saddr]; break; default: val = s->regs[saddr]; DPRINTF (\"Bad register offset 0x%x\\n\", (int)addr); break; } if (!(s->regs[GTCPU] & 0x00001000)) val = bswap32(val); return val; } ", "target": 0}
{"func": "int qemuoptset(QemuOpts *opts, const char *name, const char *value) { QemuOpt *opt; opt = qemuoptfind(opts, name); if (!opt) { QemuOptDesc *desc = opts->list->desc; int i; for (i = 0; desc[i].name != NULL; i++) { if (strcmp(desc[i].name, name) == 0) { break; } } if (desc[i].name == NULL) { if (i == 0) { /* empty list -> allow any */; } else { fprintf(stderr, \"option \\\"%s\\\" is not valid for %s\\n\", name, opts->list->name); return -1; } } opt = qemumallocz(sizeof(*opt)); opt->name = qemustrdup(name); opt->opts = opts; TAILQINSERTTAIL(&opts->head, opt, next); if (desc[i].name != NULL) { opt->desc = desc+i; } } qemufree((/* !const */ char*)opt->str); opt->str = NULL; if (value) { opt->str = qemustrdup(value); } if (qemuoptparse(opt) < 0) { fprintf(stderr, \"Failed to parse \\\"%s\\\" for \\\"%s.%s\\\"\\n\", opt->str, opts->list->name, opt->name); qemuoptdel(opt); return -1; } return 0; } ", "target": 0}
{"func": "static int scsiinitfn(SCSIDevice *dev) { SCSIDiskState *s = DOUPCAST(SCSIDiskState, qdev, dev); Error *err = NULL; if (!s->qdev.conf.bs) { errorreport(\"drive property not set\"); return -1; } if (!(s->features & (1 << SCSIDISKFREMOVABLE)) && !bdrvisinserted(s->qdev.conf.bs)) { errorreport(\"Device needs media, but drive is empty\"); return -1; } blkconfserial(&s->qdev.conf, &s->serial); if (dev->type == TYPEDISK) { blkconfgeometry(&dev->conf, NULL, 65535, 255, 255, &err); if (err) { errorreport(\"%s\", errorgetpretty(err)); errorfree(err); return -1; } } if (s->qdev.conf.discardgranularity == -1) { s->qdev.conf.discardgranularity = MAX(s->qdev.conf.logicalblocksize, DEFAULTDISCARDGRANULARITY); } if (!s->version) { s->version = gstrdup(qemugetversion()); } if (!s->vendor) { s->vendor = gstrdup(\"QEMU\"); } if (bdrvissg(s->qdev.conf.bs)) { errorreport(\"unwanted /dev/sg*\"); return -1; } if ((s->features & (1 << SCSIDISKFREMOVABLE)) && !(s->features & (1 << SCSIDISKFNOREMOVABLEDEVOPS))) { bdrvsetdevops(s->qdev.conf.bs, &scsidiskremovableblockops, s); } else { bdrvsetdevops(s->qdev.conf.bs, &scsidiskblockops, s); } bdrvsetguestblocksize(s->qdev.conf.bs, s->qdev.blocksize); bdrviostatusenable(s->qdev.conf.bs); addbootdevicepath(s->qdev.conf.bootindex, &dev->qdev, NULL); return 0; } ", "target": 0}
{"func": "static void ehciupdatefrindex(EHCIState *ehci, int frames) { int i; if (!ehcienabled(ehci)) { return; } for (i = 0; i < frames; i++) { ehci->frindex += 8; if (ehci->frindex == 0x00002000) { ehciraiseirq(ehci, USBSTSFLR); } if (ehci->frindex == 0x00004000) { ehciraiseirq(ehci, USBSTSFLR); ehci->frindex = 0; if (ehci->usbstsfrindex >= 0x00004000) { ehci->usbstsfrindex -= 0x00004000; } else { ehci->usbstsfrindex = 0; } } } } ", "target": 0}
{"func": "static const MXFCodecUL *mxfgetcodecul(const MXFCodecUL *uls, UID *uid) { while (uls->id != CODECIDNONE) { if(mxfmatchuid(uls->uid, *uid, 16)) break; uls++; } return uls; } ", "target": 0}
{"func": "static void ptychrstate(CharDriverState *chr, int connected) { PtyCharDriver *s = chr->opaque; if (!connected) { if (s->fdtag) { gsourceremove(s->fdtag); s->fdtag = 0; } s->connected = 0; s->polling = 0; /* (re-)connect poll interval for idle guests: once per second. * We check more frequently in case the guests sends data to * the virtual device linked to our pty. */ ptychrrearmtimer(chr, 1000); } else { if (!s->connected) qemuchrbegenericopen(chr); s->connected = 1; } } ", "target": 0}
{"func": "int h263decodepictureheader(MpegEncContext *s) { int format, width, height; /* picture header */ if (getbits(&s->gb, 22) != 0x20) return -1; skipbits(&s->gb, 8); /* picture timestamp */ if (getbits1(&s->gb) != 1) return -1;\t/* marker */ if (getbits1(&s->gb) != 0) return -1;\t/* h263 id */ skipbits1(&s->gb);\t/* split screen off */ skipbits1(&s->gb);\t/* camera off */ skipbits1(&s->gb);\t/* freeze picture release off */ format = getbits(&s->gb, 3); if (format != 7) { s->h263plus = 0; /* H.263v1 */ width = h263format[format][0]; height = h263format[format][1]; if (!width) return -1; s->picttype = ITYPE + getbits1(&s->gb); s->unrestrictedmv = getbits1(&s->gb); s->h263longvectors = s->unrestrictedmv; if (getbits1(&s->gb) != 0) return -1;\t/* SAC: off */ if (getbits1(&s->gb) != 0) return -1;\t/* advanced prediction mode: off */ if (getbits1(&s->gb) != 0) return -1;\t/* not PB frame */ s->qscale = getbits(&s->gb, 5); skipbits1(&s->gb);\t/* Continuous Presence Multipoint mode: off */ } else { s->h263plus = 1; /* H.263v2 */ /* OPPTYPE */ if (getbits(&s->gb, 3) != 1) /* Update Full Extended PTYPE */ return -1; format = getbits(&s->gb, 3); skipbits(&s->gb,1); /* Custom PCF */ umvplusdec = getbits(&s->gb, 1); /* Unrestricted Motion Vector */ skipbits(&s->gb, 10); skipbits(&s->gb, 3); /* Reserved */ /* MPPTYPE */ s->picttype = getbits(&s->gb, 3) + 1; if (s->picttype != ITYPE && s->picttype != PTYPE) return -1; skipbits(&s->gb, 7); /* Get the picture dimensions */ if (format == 6) { /* Custom Picture Format (CPFMT) */ skipbits(&s->gb, 4); /* aspect ratio */ width = (getbits(&s->gb, 9) + 1) * 4; skipbits1(&s->gb); height = getbits(&s->gb, 9) * 4; #ifdef DEBUG fprintf(stderr,\"\\nH.263+ Custom picture: %dx%d\\n\",width,height); #endif } else { width = h263format[format][0]; height = h263format[format][1]; } if ((width == 0) || (height == 0)) return -1; if (umvplusdec) { skipbits1(&s->gb); /* Unlimited Unrestricted Motion Vectors Indicator (UUI) */ } s->qscale = getbits(&s->gb, 5); } /* PEI */ while (getbits1(&s->gb) != 0) { skipbits(&s->gb, 8); } s->fcode = 1; s->width = width; s->height = height; return 0; } ", "target": 1}
{"func": "static void stellarisinit(const char *kernelfilename, const char *cpumodel, DisplayState *ds, stellarisboardinfo *board) { static const int uartirq[] = {5, 6, 33, 34}; static const int timerirq[] = {19, 21, 23, 35}; static const uint32t gpioaddr[7] = { 0x40004000, 0x40005000, 0x40006000, 0x40007000, 0x40024000, 0x40025000, 0x40026000}; static const int gpioirq[7] = {0, 1, 2, 3, 4, 30, 31}; qemuirq *pic; qemuirq *gpioin[5]; qemuirq *gpioout[5]; qemuirq adc; int sramsize; int flashsize; i2cbus *i2c; int i; flashsize = ((board->dc0 & 0xffff) + 1) << 1; sramsize = (board->dc0 >> 18) + 1; pic = armv7minit(flashsize, sramsize, kernelfilename, cpumodel); if (board->dc1 & (1 << 16)) { adc = stellarisadcinit(0x40038000, pic[14]); } else { adc = NULL; } for (i = 0; i < 4; i++) { if (board->dc2 & (0x10000 << i)) { stellarisgptminit(0x40030000 + i * 0x1000, pic[timerirq[i]], adc); } } stellarissysinit(0x400fe000, pic[28], board, ndtable[0].macaddr); for (i = 0; i < 7; i++) { if (board->dc4 & (1 << i)) { gpioin[i] = pl061init(gpioaddr[i], pic[gpioirq[i]], &gpioout[i]); } } if (board->dc2 & (1 << 12)) { i2c = i2cinitbus(); stellarisi2cinit(0x40020000, pic[8], i2c); if (board->peripherals & BPOLEDI2C) { ssd0303init(ds, i2c, 0x3d); } } for (i = 0; i < 4; i++) { if (board->dc2 & (1 << i)) { pl011init(0x4000c000 + i * 0x1000, pic[uartirq[i]], serialhds[i], PL011LUMINARY); } } if (board->dc2 & (1 << 4)) { if (board->peripherals & BPOLEDSSI) { void * oled; void * sd; void *ssibus; int index; oled = ssd0323init(ds, &gpioout[GPIOC][7]); index = drivegetindex(IFSD, 0, 0); sd = ssisdinit(drivestable[index].bdrv); ssibus = stellarisssibusinit(&gpioout[GPIOD][0], ssisdxfer, sd, ssd0323xferssi, oled); pl022init(0x40008000, pic[7], stellarisssibusxfer, ssibus); /* Make sure the select pin is high. */ qemuirqraise(gpioout[GPIOD][0]); } else { pl022init(0x40008000, pic[7], NULL, NULL); } } if (board->dc4 & (1 << 28)) { /* FIXME: Obey network model. */ stellarisenetinit(&ndtable[0], 0x40048000, pic[42]); } if (board->peripherals & BPGAMEPAD) { qemuirq gpadirq[5]; static const int gpadkeycode[5] = { 0xc8, 0xd0, 0xcb, 0xcd, 0x1d }; gpadirq[0] = qemuirqinvert(gpioin[GPIOE][0]); /* up */ gpadirq[1] = qemuirqinvert(gpioin[GPIOE][1]); /* down */ gpadirq[2] = qemuirqinvert(gpioin[GPIOE][2]); /* left */ gpadirq[3] = qemuirqinvert(gpioin[GPIOE][3]); /* right */ gpadirq[4] = qemuirqinvert(gpioin[GPIOF][1]); /* select */ stellarisgamepadinit(5, gpadirq, gpadkeycode); } } ", "target": 1}
{"func": "static void dovideoout(AVFormatContext *s, OutputStream *ost, InputStream *ist, AVFrame *inpicture, int *framesize, float quality) { int nbframes, i, ret, avunused resamplechanged; AVFrame *finalpicture, *formattedpicture; AVCodecContext *enc, *dec; double syncipts; enc = ost->st->codec; dec = ist->st->codec; syncipts = getsyncipts(ost) / avq2d(enc->timebase); /* by default, we output a single frame */ nbframes = 1; *framesize = 0; if(videosyncmethod){ double vdelta = syncipts - ost->syncopts; //FIXME set to 0.5 after we fix some dts/pts bugs like in avidec.c if (vdelta < -1.1) nbframes = 0; else if (videosyncmethod == 2 || (videosyncmethod<0 && (s->oformat->flags & AVFMTVARIABLEFPS))){ if(vdelta<=-0.6){ nbframes=0; }else if(vdelta>0.6) ost->syncopts= lrintf(syncipts); }else if (vdelta > 1.1) nbframes = lrintf(vdelta); //fprintf(stderr, \"vdelta:%f, ost->syncopts:%\"PRId64\", ost->syncipts:%f nbframes:%d\\n\", vdelta, ost->syncopts, getsyncipts(ost), nbframes); if (nbframes == 0){ ++nbframesdrop; if (verbose>2) fprintf(stderr, \"*** drop!\\n\"); }else if (nbframes > 1) { nbframesdup += nbframes - 1; if (verbose>2) fprintf(stderr, \"*** %d dup!\\n\", nbframes-1); } }else ost->syncopts= lrintf(syncipts); nbframes= FFMIN(nbframes, maxframes[AVMEDIATYPEVIDEO] - ost->framenumber); if (nbframes <= 0) return; formattedpicture = inpicture; finalpicture = formattedpicture; #if !CONFIGAVFILTER resamplechanged = ost->resamplewidth != dec->width || ost->resampleheight != dec->height || ost->resamplepixfmt != dec->pixfmt; if (resamplechanged) { avlog(NULL, AVLOGINFO, \"Input stream #%d.%d frame changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s\\n\", ist->fileindex, ist->st->index, ost->resamplewidth, ost->resampleheight, avgetpixfmtname(ost->resamplepixfmt), dec->width , dec->height , avgetpixfmtname(dec->pixfmt)); ost->resamplewidth = dec->width; ost->resampleheight = dec->height; ost->resamplepixfmt = dec->pixfmt; } ost->videoresample = dec->width != enc->width || dec->height != enc->height || dec->pixfmt != enc->pixfmt; if (ost->videoresample) { finalpicture = &ost->resampleframe; if (!ost->imgresamplectx || resamplechanged) { /* initialize the destination picture */ if (!ost->resampleframe.data[0]) { avcodecgetframedefaults(&ost->resampleframe); if (avpicturealloc((AVPicture *)&ost->resampleframe, enc->pixfmt, enc->width, enc->height)) { fprintf(stderr, \"Cannot allocate temp picture, check pix fmt\\n\"); exitprogram(1); } } /* initialize a new scaler context */ swsfreeContext(ost->imgresamplectx); ost->imgresamplectx = swsgetContext(dec->width, dec->height, dec->pixfmt, enc->width, enc->height, enc->pixfmt, ost->swsflags, NULL, NULL, NULL); if (ost->imgresamplectx == NULL) { fprintf(stderr, \"Cannot get resampling context\\n\"); exitprogram(1); } } swsscale(ost->imgresamplectx, formattedpicture->data, formattedpicture->linesize, 0, ost->resampleheight, finalpicture->data, finalpicture->linesize); } #else if (resamplechanged) { avfiltergraphfree(&ost->graph); if (configurevideofilters(ist, ost)) { fprintf(stderr, \"Error reinitialising filters!\\n\"); exitprogram(1); } } #endif if (resamplechanged) { ost->resamplewidth = dec->width; ost->resampleheight = dec->height; ost->resamplepixfmt = dec->pixfmt; } /* duplicates frame if needed */ for(i=0;i<nbframes;i++) { AVPacket pkt; avinitpacket(&pkt); pkt.streamindex= ost->index; if (s->oformat->flags & AVFMTRAWPICTURE) { /* raw pictures are written as AVPicture structure to avoid any copies. We support temorarily the older method. */ AVFrame* oldframe = enc->codedframe; enc->codedframe = dec->codedframe; //FIXME/XXX remove this hack pkt.data= (uint8t *)finalpicture; pkt.size= sizeof(AVPicture); pkt.pts= avrescaleq(ost->syncopts, enc->timebase, ost->st->timebase); pkt.flags |= AVPKTFLAGKEY; writeframe(s, &pkt, ost->st->codec, ost->bitstreamfilters); enc->codedframe = oldframe; } else { AVFrame bigpicture; bigpicture= *finalpicture; /* better than nothing: use input picture interlaced settings */ bigpicture.interlacedframe = inpicture->interlacedframe; if (ost->st->codec->flags & (CODECFLAGINTERLACEDDCT|CODECFLAGINTERLACEDME)) { if(topfieldfirst == -1) bigpicture.topfieldfirst = inpicture->topfieldfirst; else bigpicture.topfieldfirst = topfieldfirst; } /* handles sameq here. This is not correct because it may not be a global option */ bigpicture.quality = quality; if(!methreshold) bigpicture.picttype = 0; // bigpicture.pts = AVNOPTSVALUE; bigpicture.pts= ost->syncopts; // bigpicture.pts= avrescale(ost->syncopts, AVTIMEBASE*(int64t)enc->timebase.num, enc->timebase.den); //avlog(NULL, AVLOGDEBUG, \"%\"PRId64\" -> encoder\\n\", ost->syncopts); if (ost->forcedkfindex < ost->forcedkfcount && bigpicture.pts >= ost->forcedkfpts[ost->forcedkfindex]) { bigpicture.picttype = AVPICTURETYPEI; ost->forcedkfindex++; } ret = avcodecencodevideo(enc, bitbuffer, bitbuffersize, &bigpicture); if (ret < 0) { fprintf(stderr, \"Video encoding failed\\n\"); exitprogram(1); } if(ret>0){ pkt.data= bitbuffer; pkt.size= ret; if(enc->codedframe->pts != AVNOPTSVALUE) pkt.pts= avrescaleq(enc->codedframe->pts, enc->timebase, ost->st->timebase); /*avlog(NULL, AVLOGDEBUG, \"encoder -> %\"PRId64\"/%\"PRId64\"\\n\", pkt.pts != AVNOPTSVALUE ? avrescale(pkt.pts, enc->timebase.den, AVTIMEBASE*(int64t)enc->timebase.num) : -1, pkt.dts != AVNOPTSVALUE ? avrescale(pkt.dts, enc->timebase.den, AVTIMEBASE*(int64t)enc->timebase.num) : -1);*/ if(enc->codedframe->keyframe) pkt.flags |= AVPKTFLAGKEY; writeframe(s, &pkt, ost->st->codec, ost->bitstreamfilters); *framesize = ret; videosize += ret; //fprintf(stderr,\"\\nFrame: %3d size: %5d type: %d\", // enc->framenumber-1, ret, enc->picttype); /* if two pass, output log */ if (ost->logfile && enc->statsout) { fprintf(ost->logfile, \"%s\", enc->statsout); } } } ost->syncopts++; ost->framenumber++; } } ", "target": 1}
{"func": "static void continueaftermapfailure(void *opaque) { DMAAIOCB *dbs = (DMAAIOCB *)opaque; dbs->bh = qemubhnew(rescheduledma, dbs); qemubhschedule(dbs->bh); } ", "target": 1}
{"func": "static void ehcimemwritel(void *ptr, targetphysaddrt addr, uint32t val) { EHCIState *s = ptr; uint32t *mmio = (uint32t *)(&s->mmio[addr]); uint32t old = *mmio; int i; traceusbehcimmiowritel(addr, addr2str(addr), val); /* Only aligned reads are allowed on OHCI */ if (addr & 3) { fprintf(stderr, \"usb-ehci: Mis-aligned write to addr 0x\" TARGETFMTplx \"\\n\", addr); return; } if (addr >= PORTSC && addr < PORTSC + 4 * NBPORTS) { handleportstatuswrite(s, (addr-PORTSC)/4, val); traceusbehcimmiochange(addr, addr2str(addr), *mmio, old); return; } if (addr < OPREGBASE) { fprintf(stderr, \"usb-ehci: write attempt to read-only register\" TARGETFMTplx \"\\n\", addr); return; } /* Do any register specific pre-write processing here. */ switch(addr) { case USBCMD: if (val & USBCMDHCRESET) { ehcireset(s); val = s->usbcmd; break; } if (((USBCMDRUNSTOP | USBCMDPSE | USBCMDASE) & val) != ((USBCMDRUNSTOP | USBCMDPSE | USBCMDASE) & s->usbcmd)) { if (!ehcienabled(s)) { qemumodtimer(s->frametimer, qemugetclockns(vmclock)); SETLASTRUNCLOCK(s); } ehciupdatehalt(s); } /* not supporting dynamic frame list size at the moment */ if ((val & USBCMDFLS) && !(s->usbcmd & USBCMDFLS)) { fprintf(stderr, \"attempt to set frame list size -- value %d\\n\", val & USBCMDFLS); val &= ~USBCMDFLS; } break; case USBSTS: val &= USBSTSROMASK; // bits 6 through 31 are RO ehciclearusbsts(s, val); // bits 0 through 5 are R/WC val = s->usbsts; ehcisetinterrupt(s, 0); break; case USBINTR: val &= USBINTRMASK; break; case FRINDEX: val &= 0x00003ff8; /* frindex is 14bits and always a multiple of 8 */ break; case CONFIGFLAG: val &= 0x1; if (val) { for(i = 0; i < NBPORTS; i++) handleportownerwrite(s, i, 0); } break; case PERIODICLISTBASE: if (ehciperiodicenabled(s)) { fprintf(stderr, \"ehci: PERIODIC list base register set while periodic schedule\\n\" \" is enabled and HC is enabled\\n\"); } break; case ASYNCLISTADDR: if (ehciasyncenabled(s)) { fprintf(stderr, \"ehci: ASYNC list address register set while async schedule\\n\" \" is enabled and HC is enabled\\n\"); } break; } *mmio = val; traceusbehcimmiochange(addr, addr2str(addr), *mmio, old); } ", "target": 0}
{"func": "sPAPRDRConnector *spaprdrcbyindex(uint32t index) { Object *obj; char name[256]; snprintf(name, sizeof(name), \"%s/%x\", DRCCONTAINERPATH, index); obj = objectresolvepath(name, NULL); return !obj ? NULL : SPAPRDRCONNECTOR(obj); } ", "target": 0}
{"func": "uint64t helperfnmadd (uint64t arg1, uint64t arg2, uint64t arg3) { CPUDoubleU farg1, farg2, farg3; farg1.ll = arg1; farg2.ll = arg2; farg3.ll = arg3; if (unlikely(float64issignalingnan(farg1.d) || float64issignalingnan(farg2.d) || float64issignalingnan(farg3.d))) { /* sNaN operation */ farg1.ll = floadinvalidopexcp(POWERPCEXCPFPVXSNAN); } else if (unlikely((float64isinfinity(farg1.d) && float64iszero(farg2.d)) || (float64iszero(farg1.d) && float64isinfinity(farg2.d)))) { /* Multiplication of zero by infinity */ farg1.ll = floadinvalidopexcp(POWERPCEXCPFPVXIMZ); } else { #if USEPRECISEEMULATION #ifdef FLOAT128 /* This is the way the PowerPC specification defines it */ float128 ft0128, ft1128; ft0128 = float64tofloat128(farg1.d, &env->fpstatus); ft1128 = float64tofloat128(farg2.d, &env->fpstatus); ft0128 = float128mul(ft0128, ft1128, &env->fpstatus); if (unlikely(float128isinfinity(ft0128) && float64isinfinity(farg3.d) && float128isneg(ft0128) != float64isneg(farg3.d))) { /* Magnitude subtraction of infinities */ farg1.ll = floadinvalidopexcp(POWERPCEXCPFPVXISI); } else { ft1128 = float64tofloat128(farg3.d, &env->fpstatus); ft0128 = float128add(ft0128, ft1128, &env->fpstatus); farg1.d = float128tofloat64(ft0128, &env->fpstatus); } #else /* This is OK on x86 hosts */ farg1.d = (farg1.d * farg2.d) + farg3.d; #endif #else farg1.d = float64mul(farg1.d, farg2.d, &env->fpstatus); farg1.d = float64add(farg1.d, farg3.d, &env->fpstatus); #endif if (likely(!float64isnan(farg1.d))) farg1.d = float64chs(farg1.d); } return farg1.ll; } ", "target": 0}
{"func": "static int cowprobe(const uint8t *buf, int bufsize, const char *filename) { const struct cowheaderv2 *cowheader = (const void *)buf; if (bufsize >= sizeof(struct cowheaderv2) && be32tocpu(cowheader->magic) == COWMAGIC && be32tocpu(cowheader->version) == COWVERSION) return 100; else return 0; } ", "target": 0}
{"func": "uint64t rambytesremaining(void) { return ramsaveremaining() * TARGETPAGESIZE; } ", "target": 0}
{"func": "static int decodeics(AACContext * ac, SingleChannelElement * sce, GetBitContext * gb, int commonwindow, int scaleflag) { Pulse pulse; TemporalNoiseShaping * tns = &sce->tns; IndividualChannelStream * ics = &sce->ics; float * out = sce->coeffs; int globalgain, pulsepresent = 0; /* This assignment is to silence a GCC warning about the variable being used * uninitialized when in fact it always is. */ pulse.numpulse = 0; globalgain = getbits(gb, 8); if (!commonwindow && !scaleflag) { if (decodeicsinfo(ac, ics, gb, 0) < 0) return -1; } if (decodebandtypes(ac, sce->bandtype, sce->bandtyperunend, gb, ics) < 0) return -1; if (decodescalefactors(ac, sce->sf, gb, globalgain, ics, sce->bandtype, sce->bandtyperunend) < 0) return -1; pulsepresent = 0; if (!scaleflag) { if ((pulsepresent = getbits1(gb))) { if (ics->windowsequence[0] == EIGHTSHORTSEQUENCE) { avlog(ac->avccontext, AVLOGERROR, \"Pulse tool not allowed in eight short sequence.\\n\"); return -1; } decodepulses(&pulse, gb, ics->swboffset); } if ((tns->present = getbits1(gb)) && decodetns(ac, tns, gb, ics)) return -1; if (getbits1(gb)) { avlogmissingfeature(ac->avccontext, \"SSR\", 1); return -1; } } if (decodespectrumanddequant(ac, out, gb, sce->sf, pulsepresent, &pulse, ics, sce->bandtype) < 0) return -1; return 0; } ", "target": 0}
{"func": "static ssizet bufferedflush(QEMUFileBuffered *s) { sizet offset = 0; ssizet ret = 0; DPRINTF(\"flushing %zu byte(s) of data\\n\", s->buffersize); while (s->bytesxfer < s->xferlimit && offset < s->buffersize) { sizet tosend = MIN(s->buffersize - offset, s->xferlimit - s->bytesxfer); ret = migratefdputbuffer(s->migrationstate, s->buffer + offset, tosend); if (ret <= 0) { DPRINTF(\"error flushing data, %zd\\n\", ret); break; } else { DPRINTF(\"flushed %zd byte(s)\\n\", ret); offset += ret; s->bytesxfer += ret; } } DPRINTF(\"flushed %zu of %zu byte(s)\\n\", offset, s->buffersize); memmove(s->buffer, s->buffer + offset, s->buffersize - offset); s->buffersize -= offset; if (ret < 0) { return ret; } return offset; } ", "target": 0}
{"func": "void pciqdevregister(PCIDeviceInfo *info) { info->qdev.init = pciqdevinit; info->qdev.bustype = BUSTYPEPCI; qdevregister(&info->qdev); } ", "target": 0}
{"func": "static void vhostnetstopone(struct vhostnet *net, VirtIODevice *dev) { struct vhostvringfile file = { .fd = -1 }; if (!net->dev.started) { return; } if (net->nc->info->type == NETCLIENTOPTIONSKINDTAP) { for (file.index = 0; file.index < net->dev.nvqs; ++file.index) { const VhostOps *vhostops = net->dev.vhostops; int r = vhostops->vhostcall(&net->dev, VHOSTNETSETBACKEND, &file); assert(r >= 0); } } if (net->nc->info->poll) { net->nc->info->poll(net->nc, true); } vhostdevstop(&net->dev, dev); vhostdevdisablenotifiers(&net->dev, dev); } ", "target": 0}
{"func": "static int rtspreadheader(AVFormatContext *s, AVFormatParameters *ap) { RTSPState *rt = s->privdata; char host[1024], path[1024], tcpname[1024], cmd[2048]; URLContext *rtsphd; int port, i, ret, err; RTSPHeader reply1, *reply = &reply1; unsigned char *content = NULL; AVStream *st; RTSPStream *rtspst; int protocolmask; rtspabortreq = 0; /* extract hostname and port */ urlsplit(NULL, 0, host, sizeof(host), &port, path, sizeof(path), s->filename); if (port < 0) port = RTSPDEFAULTPORT; /* open the tcp connexion */ snprintf(tcpname, sizeof(tcpname), \"tcp://%s:%d\", host, port); if (urlopen(&rtsphd, tcpname, URLRDWR) < 0) return AVERRORIO; rt->rtsphd = rtsphd; rt->seq = 0; /* describe the stream */ snprintf(cmd, sizeof(cmd), \"DESCRIBE %s RTSP/1.0\\r\\n\" \"Accept: application/sdp\\r\\n\", s->filename); rtspsendcmd(s, cmd, reply, &content); if (!content) { err = AVERRORINVALIDDATA; goto fail; } if (reply->statuscode != RTSPSTATUSOK) { err = AVERRORINVALIDDATA; goto fail; } /* now we got the SDP description, we parse it */ ret = sdpparse(s, (const char *)content); avfreep(&content); if (ret < 0) { err = AVERRORINVALIDDATA; goto fail; } protocolmask = rtspdefaultprotocols; /* for each stream, make the setup request */ /* XXX: we assume the same server is used for the control of each RTSP stream */ for(i=0;i<s->nbstreams;i++) { char transport[2048]; AVInputFormat *fmt; st = s->streams[i]; rtspst = st->privdata; /* compute available transports */ transport[0] = '\\0'; /* RTP/UDP */ if (protocolmask & (1 << RTSPPROTOCOLRTPUDP)) { char buf[256]; int j; /* first try in specified port range */ if (rtsprtpportmin != 0) { for(j=rtsprtpportmin;j<=rtsprtpportmax;j++) { snprintf(buf, sizeof(buf), \"rtp://?localport=%d\", j); if (!avopeninputfile(&rtspst->ic, buf, &rtpdemux, 0, NULL)) goto rtpopened; } } /* then try on any port */ if (avopeninputfile(&rtspst->ic, \"rtp://\", &rtpdemux, 0, NULL) < 0) { err = AVERRORINVALIDDATA; goto fail; } rtpopened: port = rtpgetlocalport(urlfileno(&rtspst->ic->pb)); if (transport[0] != '\\0') pstrcat(transport, sizeof(transport), \",\"); snprintf(transport + strlen(transport), sizeof(transport) - strlen(transport) - 1, \"RTP/AVP/UDP;unicast;clientport=%d-%d\", port, port + 1); } /* RTP/TCP */ if (protocolmask & (1 << RTSPPROTOCOLRTPTCP)) { if (transport[0] != '\\0') pstrcat(transport, sizeof(transport), \",\"); snprintf(transport + strlen(transport), sizeof(transport) - strlen(transport) - 1, \"RTP/AVP/TCP\"); } if (protocolmask & (1 << RTSPPROTOCOLRTPUDPMULTICAST)) { if (transport[0] != '\\0') pstrcat(transport, sizeof(transport), \",\"); snprintf(transport + strlen(transport), sizeof(transport) - strlen(transport) - 1, \"RTP/AVP/UDP;multicast\"); } snprintf(cmd, sizeof(cmd), \"SETUP %s RTSP/1.0\\r\\n\" \"Transport: %s\\r\\n\", rtspst->controlurl, transport); rtspsendcmd(s, cmd, reply, NULL); if (reply->statuscode != RTSPSTATUSOK || reply->nbtransports != 1) { err = AVERRORINVALIDDATA; goto fail; } /* XXX: same protocol for all streams is required */ if (i > 0) { if (reply->transports[0].protocol != rt->protocol) { err = AVERRORINVALIDDATA; goto fail; } } else { rt->protocol = reply->transports[0].protocol; } /* close RTP connection if not choosen */ if (reply->transports[0].protocol != RTSPPROTOCOLRTPUDP && (protocolmask & (1 << RTSPPROTOCOLRTPUDP))) { avcloseinputfile(rtspst->ic); rtspst->ic = NULL; } switch(reply->transports[0].protocol) { case RTSPPROTOCOLRTPTCP: fmt = &rtpdemux; if (avopeninputfile(&rtspst->ic, \"null\", fmt, 0, NULL) < 0) { err = AVERRORINVALIDDATA; goto fail; } rtspst->interleavedmin = reply->transports[0].interleavedmin; rtspst->interleavedmax = reply->transports[0].interleavedmax; break; case RTSPPROTOCOLRTPUDP: { char url[1024]; /* XXX: also use address if specified */ snprintf(url, sizeof(url), \"rtp://%s:%d\", host, reply->transports[0].serverportmin); if (rtpsetremoteurl(urlfileno(&rtspst->ic->pb), url) < 0) { err = AVERRORINVALIDDATA; goto fail; } } break; case RTSPPROTOCOLRTPUDPMULTICAST: { char url[1024]; int ttl; fmt = &rtpdemux; ttl = reply->transports[0].ttl; if (!ttl) ttl = 16; snprintf(url, sizeof(url), \"rtp://%s:%d?multicast=1&ttl=%d\", host, reply->transports[0].serverportmin, ttl); if (avopeninputfile(&rtspst->ic, url, fmt, 0, NULL) < 0) { err = AVERRORINVALIDDATA; goto fail; } } break; } } /* use callback if available to extend setup */ if (ffrtspcallback) { if (ffrtspcallback(RTSPACTIONCLIENTSETUP, rt->sessionid, NULL, 0, rt->lastreply) < 0) { err = AVERRORINVALIDDATA; goto fail; } } /* start playing */ snprintf(cmd, sizeof(cmd), \"PLAY %s RTSP/1.0\\r\\n\" \"Range: npt=0-\\r\\n\", s->filename); rtspsendcmd(s, cmd, reply, NULL); if (reply->statuscode != RTSPSTATUSOK) { err = AVERRORINVALIDDATA; goto fail; } #if 0 /* open TCP with bufferized input */ if (rt->protocol == RTSPPROTOCOLRTPTCP) { if (urlfdopen(&rt->rtspgb, rt->rtsphd) < 0) { err = AVERRORNOMEM; goto fail; } } #endif return 0; fail: for(i=0;i<s->nbstreams;i++) { st = s->streams[i]; rtspst = st->privdata; if (rtspst) { if (rtspst->ic) avcloseinputfile(rtspst->ic); } avfree(rtspst); } avfreep(&content); urlclose(rt->rtsphd); return err; } ", "target": 0}
{"func": "int cpus390xhandlemmufault (CPUState *env, targetulong address, int rw, int mmuidx, int issoftmmu) { targetulong phys; int prot; /* XXX: implement mmu */ phys = address; prot = PAGEREAD | PAGEWRITE; return tlbsetpage(env, address & TARGETPAGEMASK, phys & TARGETPAGEMASK, prot, mmuidx, issoftmmu); } ", "target": 0}
{"func": "static int increfcounts(BlockDriverState *bs, BdrvCheckResult *res, void **refcounttable, int64t *refcounttablesize, int64t offset, int64t size) { BDRVQcow2State *s = bs->opaque; uint64t start, last, clusteroffset, k, refcount; int ret; if (size <= 0) { return 0; } start = startofcluster(s, offset); last = startofcluster(s, offset + size - 1); for(clusteroffset = start; clusteroffset <= last; clusteroffset += s->clustersize) { k = clusteroffset >> s->clusterbits; if (k >= *refcounttablesize) { ret = reallocrefcountarray(s, refcounttable, refcounttablesize, k + 1); if (ret < 0) { res->checkerrors++; return ret; } } refcount = s->getrefcount(*refcounttable, k); if (refcount == s->refcountmax) { fprintf(stderr, \"ERROR: overflow cluster offset=0x%\" PRIx64 \"\\n\", clusteroffset); fprintf(stderr, \"Use qemu-img amend to increase the refcount entry \" \"width or qemu-img convert to create a clean copy if the \" \"image cannot be opened for writing\\n\"); res->corruptions++; continue; } s->setrefcount(*refcounttable, k, refcount + 1); } return 0; } ", "target": 0}
{"func": "static void gicdocpuwrite(void *opaque, targetphysaddrt addr, uint64t value, unsigned size) { GICState **backref = (GICState **)opaque; GICState *s = *backref; int id = (backref - s->backref); giccpuwrite(s, id, addr, value); } ", "target": 0}
{"func": "void stqbephys(targetphysaddrt addr, uint64t val) { val = cputobe64(val); cpuphysicalmemorywrite(addr, &val, 8); } ", "target": 0}
{"func": "static int fbinitialise(struct XenDevice *xendev) { struct XenFB *fb = containerof(xendev, struct XenFB, c.xendev); struct xenfbpage *fbpage; int videoram; int rc; if (xenstorereadfeint(xendev, \"videoram\", &videoram) == -1) \tvideoram = 0; rc = commonbind(&fb->c); if (rc != 0) \treturn rc; fbpage = fb->c.page; rc = xenfbconfigurefb(fb, videoram * 1024 * 1024U, \t\t\t fbpage->width, fbpage->height, fbpage->depth, \t\t\t fbpage->memlength, 0, fbpage->linelength); if (rc != 0) \treturn rc; rc = xenfbmapfb(fb); if (rc != 0) \treturn rc; #if 0 /* handled in xeninitdisplay() for now */ if (!fb->haveconsole) { fb->c.ds = graphicconsoleinit(xenfbupdate, xenfbinvalidate, NULL, NULL, fb); fb->haveconsole = 1; } #endif if (xenstorereadfeint(xendev, \"feature-update\", &fb->featureupdate) == -1) \tfb->featureupdate = 0; if (fb->featureupdate) \txenstorewritebeint(xendev, \"request-update\", 1); xenpvprintf(xendev, 1, \"feature-update=%d, videoram=%d\\n\", \t\t fb->featureupdate, videoram); return 0; } ", "target": 0}
{"func": "static void genexts(int ot, TCGv reg) { switch(ot) { case OTBYTE: tcggenext8stl(reg, reg); break; case OTWORD: tcggenext16stl(reg, reg); break; case OTLONG: tcggenext32stl(reg, reg); break; default: break; } } ", "target": 0}
{"func": "bool isvalidoptionlist(const char *param) { sizet buflen = strlen(param) + 1; char *buf = gmalloc(buflen); const char *p = param; bool result = true; while (*p) { p = getoptvalue(buf, buflen, p); if (*p && !*++p) { result = false; goto out; } if (!*buf || *buf == ',') { result = false; goto out; } } out: free(buf); return result; } ", "target": 0}
{"func": "int ffh264alloctables(H264Context *h){ MpegEncContext * const s = &h->s; const int bigmbnum= s->mbstride * (s->mbheight+1); const int rowmbnum= 2*s->mbstride*s->avctx->threadcount; int x,y; FFALLOCZORGOTO(h->s.avctx, h->intra4x4predmode, rowmbnum * 8 * sizeof(uint8t), fail) FFALLOCZORGOTO(h->s.avctx, h->nonzerocount , bigmbnum * 48 * sizeof(uint8t), fail) FFALLOCZORGOTO(h->s.avctx, h->slicetablebase , (bigmbnum+s->mbstride) * sizeof(*h->slicetablebase), fail) FFALLOCZORGOTO(h->s.avctx, h->cbptable, bigmbnum * sizeof(uint16t), fail) FFALLOCZORGOTO(h->s.avctx, h->chromapredmodetable, bigmbnum * sizeof(uint8t), fail) FFALLOCZORGOTO(h->s.avctx, h->mvdtable[0], 16*rowmbnum * sizeof(uint8t), fail); FFALLOCZORGOTO(h->s.avctx, h->mvdtable[1], 16*rowmbnum * sizeof(uint8t), fail); FFALLOCZORGOTO(h->s.avctx, h->directtable, 4*bigmbnum * sizeof(uint8t) , fail); FFALLOCZORGOTO(h->s.avctx, h->listcounts, bigmbnum * sizeof(uint8t), fail) memset(h->slicetablebase, -1, (bigmbnum+s->mbstride) * sizeof(*h->slicetablebase)); h->slicetable= h->slicetablebase + s->mbstride*2 + 1; FFALLOCZORGOTO(h->s.avctx, h->mb2bxy , bigmbnum * sizeof(uint32t), fail); FFALLOCZORGOTO(h->s.avctx, h->mb2brxy , bigmbnum * sizeof(uint32t), fail); for(y=0; y<s->mbheight; y++){ for(x=0; x<s->mbwidth; x++){ const int mbxy= x + y*s->mbstride; const int bxy = 4*x + 4*y*h->bstride; h->mb2bxy [mbxy]= bxy; h->mb2brxy[mbxy]= 8*(FMO ? mbxy : (mbxy % (2*s->mbstride))); } } s->obmcscratchpad = NULL; if(!h->dequant4coeff[0]) initdequanttables(h); return 0; fail: freetables(h, 1); return -1; } ", "target": 1}
{"func": "static inline CopyRet copyframe(AVCodecContext *avctx, BCDTSPROCOUT *output, void *data, int *datasize, uint8t secondfield) { BCSTATUS ret; BCDTSSTATUS decoderstatus; uint8t ispaff; uint8t nextframesame; uint8t interlaced; CHDContext *priv = avctx->privdata; uint8t bottomfield = (output->PicInfo.flags & VDECFLAGBOTTOMFIELD) == VDECFLAGBOTTOMFIELD; uint8t bottomfirst = !!(output->PicInfo.flags & VDECFLAGBOTTOMFIRST); int width = output->PicInfo.width; int height = output->PicInfo.height; int bwidth; uint8t *src = output->Ybuff; int sStride; uint8t *dst; int dStride; ret = DtsGetDriverStatus(priv->dev, &decoderstatus); if (ret != BCSTSSUCCESS) { avlog(avctx, AVLOGERROR, \"CrystalHD: GetDriverStatus failed: %u\\n\", ret); return RETERROR; } ispaff = ASSUMEPAFFOVERMBAFF || !(output->PicInfo.flags & VDECFLAGUNKNOWNSRC); nextframesame = output->PicInfo.picturenumber == (decoderstatus.picNumFlags & ~0x40000000); interlaced = ((output->PicInfo.flags & VDECFLAGINTERLACEDSRC) && ispaff) || nextframesame || bottomfield || secondfield; avlog(avctx, AVLOGVERBOSE, \"CrystalHD: nextframesame: %u | %u | %u\\n\", nextframesame, output->PicInfo.picturenumber, decoderstatus.picNumFlags & ~0x40000000); if (priv->pic.data[0] && !priv->needsecondfield) avctx->releasebuffer(avctx, &priv->pic); priv->needsecondfield = interlaced && !priv->needsecondfield; priv->pic.bufferhints = FFBUFFERHINTSVALID | FFBUFFERHINTSPRESERVE | FFBUFFERHINTSREUSABLE; if (!priv->pic.data[0]) { if (avctx->getbuffer(avctx, &priv->pic) < 0) { avlog(avctx, AVLOGERROR, \"getbuffer() failed\\n\"); return RETERROR; } } bwidth = avimagegetlinesize(avctx->pixfmt, width, 0); if (priv->is70012) { int pStride; if (width <= 720) pStride = 720; else if (width <= 1280) pStride = 1280; else if (width <= 1080) pStride = 1080; sStride = avimagegetlinesize(avctx->pixfmt, pStride, 0); } else { sStride = bwidth; } dStride = priv->pic.linesize[0]; dst = priv->pic.data[0]; avlog(priv->avctx, AVLOGVERBOSE, \"CrystalHD: Copying out frame\\n\"); if (interlaced) { int dY = 0; int sY = 0; height /= 2; if (bottomfield) { avlog(priv->avctx, AVLOGVERBOSE, \"Interlaced: bottom field\\n\"); dY = 1; } else { avlog(priv->avctx, AVLOGVERBOSE, \"Interlaced: top field\\n\"); dY = 0; } for (sY = 0; sY < height; dY++, sY++) { memcpy(&(dst[dY * dStride]), &(src[sY * sStride]), bwidth); if (interlaced) dY++; } } else { avimagecopyplane(dst, dStride, src, sStride, bwidth, height); } priv->pic.interlacedframe = interlaced; if (interlaced) priv->pic.topfieldfirst = !bottomfirst; if (output->PicInfo.timeStamp != 0) { priv->pic.pktpts = opaquelistpop(priv, output->PicInfo.timeStamp); avlog(avctx, AVLOGVERBOSE, \"output \\\"pts\\\": %\"PRIu64\"\\n\", priv->pic.pktpts); } if (!priv->needsecondfield) { *datasize = sizeof(AVFrame); *(AVFrame *)data = priv->pic; } if (ASSUMETWOINPUTSONEOUTPUT && output->PicInfo.flags & VDECFLAGUNKNOWNSRC) { avlog(priv->avctx, AVLOGVERBOSE, \"Fieldpair from two packets.\\n\"); return RETSKIPNEXTCOPY; } return RETOK; } ", "target": 0}
{"func": "static void netl2tpv3cleanup(NetClientState *nc) { NetL2TPV3State *s = DOUPCAST(NetL2TPV3State, nc, nc); qemupurgequeuedpackets(nc); l2tpv3readpoll(s, false); l2tpv3writepoll(s, false); if (s->fd > 0) { close(s->fd); } destroyvector(s->msgvec, MAXL2TPV3MSGCNT, IOVSIZE); gfree(s->vec); gfree(s->headerbuf); gfree(s->dgramdst); } ", "target": 1}
{"func": "static AioHandler *findaiohandler(int fd) { AioHandler *node; LISTFOREACH(node, &aiohandlers, node) { if (node->fd == fd) return node; } return NULL; } ", "target": 1}
{"func": "static inline void RENAME(yuv2yuv1)(SwsContext *c, const int16t *lumSrc, const int16t *chrSrc, const int16t *alpSrc, uint8t *dest, uint8t *uDest, uint8t *vDest, uint8t *aDest, long dstW, long chrDstW) { int i; #if COMPILETEMPLATEMMX if(!(c->flags & SWSBITEXACT)) { long p= 4; const int16t *src[4]= {alpSrc + dstW, lumSrc + dstW, chrSrc + chrDstW, chrSrc + VOFW + chrDstW}; uint8t *dst[4]= {aDest, dest, uDest, vDest}; x86reg counter[4]= {dstW, dstW, chrDstW, chrDstW}; if (c->flags & SWSACCURATERND) { while(p--) { if (dst[p]) { asm volatile( YSCALEYUV2YV121ACCURATE :: \"r\" (src[p]), \"r\" (dst[p] + counter[p]), \"g\" (-counter[p]) : \"%\"REGa ); } } } else { while(p--) { if (dst[p]) { asm volatile( YSCALEYUV2YV121 :: \"r\" (src[p]), \"r\" (dst[p] + counter[p]), \"g\" (-counter[p]) : \"%\"REGa ); } } } return; } #endif for (i=0; i<dstW; i++) { int val= (lumSrc[i]+64)>>7; if (val&256) { if (val<0) val=0; else val=255; } dest[i]= val; } if (uDest) for (i=0; i<chrDstW; i++) { int u=(chrSrc[i ]+64)>>7; int v=(chrSrc[i + VOFW]+64)>>7; if ((u|v)&256) { if (u<0) u=0; else if (u>255) u=255; if (v<0) v=0; else if (v>255) v=255; } uDest[i]= u; vDest[i]= v; } if (CONFIGSWSCALEALPHA && aDest) for (i=0; i<dstW; i++) { int val= (alpSrc[i]+64)>>7; aDest[i]= avclipuint8(val); } } ", "target": 0}
{"func": "int x86cpugdbwriteregister(CPUState *cs, uint8t *membuf, int n) { X86CPU *cpu = X86CPU(cs); CPUX86State *env = &cpu->env; uint32t tmp; if (n < CPUNBREGS) { if (TARGETLONGBITS == 64 && env->hflags & HFCS64MASK) { env->regs[gprmap[n]] = ldtulp(membuf); return sizeof(targetulong); } else if (n < CPUNBREGS32) { n = gprmap32[n]; env->regs[n] &= ~0xffffffffUL; env->regs[n] |= (uint32t)ldlp(membuf); return 4; } } else if (n >= IDXFPREGS && n < IDXFPREGS + 8) { #ifdef USEX86LDOUBLE /* FIXME: byteswap float values - after fixing fpregs layout. */ memcpy(&env->fpregs[n - IDXFPREGS], membuf, 10); #endif return 10; } else if (n >= IDXXMMREGS && n < IDXXMMREGS + CPUNBREGS) { n -= IDXXMMREGS; if (n < CPUNBREGS32 || (TARGETLONGBITS == 64 && env->hflags & HFCS64MASK)) { env->xmmregs[n].XMMQ(0) = ldqp(membuf); env->xmmregs[n].XMMQ(1) = ldqp(membuf + 8); return 16; } } else { switch (n) { case IDXIPREG: if (TARGETLONGBITS == 64 && env->hflags & HFCS64MASK) { env->eip = ldqp(membuf); return 8; } else { env->eip &= ~0xffffffffUL; env->eip |= (uint32t)ldlp(membuf); return 4; } case IDXFLAGSREG: env->eflags = ldlp(membuf); return 4; case IDXSEGREGS: return x86cpugdbloadseg(cpu, RCS, membuf); case IDXSEGREGS + 1: return x86cpugdbloadseg(cpu, RSS, membuf); case IDXSEGREGS + 2: return x86cpugdbloadseg(cpu, RDS, membuf); case IDXSEGREGS + 3: return x86cpugdbloadseg(cpu, RES, membuf); case IDXSEGREGS + 4: return x86cpugdbloadseg(cpu, RFS, membuf); case IDXSEGREGS + 5: return x86cpugdbloadseg(cpu, RGS, membuf); case IDXFPREGS + 8: env->fpuc = ldlp(membuf); return 4; case IDXFPREGS + 9: tmp = ldlp(membuf); env->fpstt = (tmp >> 11) & 7; env->fpus = tmp & ~0x3800; return 4; case IDXFPREGS + 10: /* ftag */ return 4; case IDXFPREGS + 11: /* fiseg */ return 4; case IDXFPREGS + 12: /* fioff */ return 4; case IDXFPREGS + 13: /* foseg */ return 4; case IDXFPREGS + 14: /* fooff */ return 4; case IDXFPREGS + 15: /* fop */ return 4; case IDXMXCSRREG: env->mxcsr = ldlp(membuf); return 4; } } /* Unrecognised register. */ return 0; } ", "target": 1}
{"func": "int ffh264decodeseqparameterset(GetBitContext *gb, AVCodecContext *avctx, H264ParamSets *ps) { AVBufferRef *spsbuf; int profileidc, levelidc, constraintsetflags = 0; unsigned int spsid; int i, log2maxframenumminus4; SPS *sps; profileidc = getbits(gb, 8); constraintsetflags |= getbits1(gb) << 0; // constraintset0flag constraintsetflags |= getbits1(gb) << 1; // constraintset1flag constraintsetflags |= getbits1(gb) << 2; // constraintset2flag constraintsetflags |= getbits1(gb) << 3; // constraintset3flag constraintsetflags |= getbits1(gb) << 4; // constraintset4flag constraintsetflags |= getbits1(gb) << 5; // constraintset5flag skipbits(gb, 2); // reservedzero2bits levelidc = getbits(gb, 8); spsid = getuegolomb31(gb); if (spsid >= MAXSPSCOUNT) { avlog(avctx, AVLOGERROR, \"spsid %u out of range\\n\", spsid); return AVERRORINVALIDDATA; } spsbuf = avbufferallocz(sizeof(*sps)); if (!spsbuf) return AVERROR(ENOMEM); sps = (SPS*)spsbuf->data; sps->spsid = spsid; sps->timeoffsetlength = 24; sps->profileidc = profileidc; sps->constraintsetflags = constraintsetflags; sps->levelidc = levelidc; memset(sps->scalingmatrix4, 16, sizeof(sps->scalingmatrix4)); memset(sps->scalingmatrix8, 16, sizeof(sps->scalingmatrix8)); sps->scalingmatrixpresent = 0; if (sps->profileidc == 100 || // High profile sps->profileidc == 110 || // High10 profile sps->profileidc == 122 || // High422 profile sps->profileidc == 244 || // High444 Predictive profile sps->profileidc == 44 || // Cavlc444 profile sps->profileidc == 83 || // Scalable Constrained High profile (SVC) sps->profileidc == 86 || // Scalable High Intra profile (SVC) sps->profileidc == 118 || // Stereo High profile (MVC) sps->profileidc == 128 || // Multiview High profile (MVC) sps->profileidc == 138 || // Multiview Depth High profile (MVCD) sps->profileidc == 144) { // old High444 profile sps->chromaformatidc = getuegolomb31(gb); if (sps->chromaformatidc > 3) { avprivrequestsample(avctx, \"chromaformatidc %u\", sps->chromaformatidc); goto fail; } else if (sps->chromaformatidc == 3) { sps->residualcolortransformflag = getbits1(gb); } sps->bitdepthluma = getuegolomb(gb) + 8; sps->bitdepthchroma = getuegolomb(gb) + 8; if (sps->bitdepthchroma != sps->bitdepthluma) { avprivrequestsample(avctx, \"Different chroma and luma bit depth\"); goto fail; } sps->transformbypass = getbits1(gb); decodescalingmatrices(gb, sps, NULL, 1, sps->scalingmatrix4, sps->scalingmatrix8); } else { sps->chromaformatidc = 1; sps->bitdepthluma = 8; sps->bitdepthchroma = 8; } log2maxframenumminus4 = getuegolomb(gb); if (log2maxframenumminus4 < MINLOG2MAXFRAMENUM - 4 || log2maxframenumminus4 > MAXLOG2MAXFRAMENUM - 4) { avlog(avctx, AVLOGERROR, \"log2maxframenumminus4 out of range (0-12): %d\\n\", log2maxframenumminus4); goto fail; } sps->log2maxframenum = log2maxframenumminus4 + 4; sps->poctype = getuegolomb31(gb); if (sps->poctype == 0) { // FIXME #define sps->log2maxpoclsb = getuegolomb(gb) + 4; } else if (sps->poctype == 1) { // FIXME #define sps->deltapicorderalwayszeroflag = getbits1(gb); sps->offsetfornonrefpic = getsegolomb(gb); sps->offsetfortoptobottomfield = getsegolomb(gb); sps->poccyclelength = getuegolomb(gb); if ((unsigned)sps->poccyclelength >= FFARRAYELEMS(sps->offsetforrefframe)) { avlog(avctx, AVLOGERROR, \"poccyclelength overflow %d\\n\", sps->poccyclelength); goto fail; } for (i = 0; i < sps->poccyclelength; i++) sps->offsetforrefframe[i] = getsegolomb(gb); } else if (sps->poctype != 2) { avlog(avctx, AVLOGERROR, \"illegal POC type %d\\n\", sps->poctype); goto fail; } sps->refframecount = getuegolomb31(gb); if (sps->refframecount > H264MAXPICTURECOUNT - 2 || sps->refframecount >= 32U) { avlog(avctx, AVLOGERROR, \"too many reference frames %d\\n\", sps->refframecount); goto fail; } sps->gapsinframenumallowedflag = getbits1(gb); sps->mbwidth = getuegolomb(gb) + 1; sps->mbheight = getuegolomb(gb) + 1; if ((unsigned)sps->mbwidth >= INTMAX / 16 || (unsigned)sps->mbheight >= INTMAX / 16 || avimagechecksize(16 * sps->mbwidth, 16 * sps->mbheight, 0, avctx)) { avlog(avctx, AVLOGERROR, \"mbwidth/height overflow\\n\"); goto fail; } sps->framembsonlyflag = getbits1(gb); if (!sps->framembsonlyflag) sps->mbaff = getbits1(gb); else sps->mbaff = 0; sps->direct8x8inferenceflag = getbits1(gb); if (!sps->framembsonlyflag && !sps->direct8x8inferenceflag) { avlog(avctx, AVLOGERROR, \"This stream was generated by a broken encoder, invalid 8x8 inference\\n\"); goto fail; } #ifndef ALLOWINTERLACE if (sps->mbaff) avlog(avctx, AVLOGERROR, \"MBAFF support not included; enable it at compile-time.\\n\"); #endif sps->crop = getbits1(gb); if (sps->crop) { unsigned int cropleft = getuegolomb(gb); unsigned int cropright = getuegolomb(gb); unsigned int croptop = getuegolomb(gb); unsigned int cropbottom = getuegolomb(gb); if (avctx->flags2 & AVCODECFLAG2IGNORECROP) { avlog(avctx, AVLOGDEBUG, \"discarding sps cropping, original \" \"values are l:%d r:%d t:%d b:%d\\n\", cropleft, cropright, croptop, cropbottom); sps->cropleft = sps->cropright = sps->croptop = sps->cropbottom = 0; } else { int vsub = (sps->chromaformatidc == 1) ? 1 : 0; int hsub = (sps->chromaformatidc == 1 || sps->chromaformatidc == 2) ? 1 : 0; int stepx = 1 << hsub; int stepy = (2 - sps->framembsonlyflag) << vsub; if (cropleft & (0x1F >> (sps->bitdepthluma > 8)) && !(avctx->flags & AVCODECFLAGUNALIGNED)) { cropleft &= ~(0x1F >> (sps->bitdepthluma > 8)); avlog(avctx, AVLOGWARNING, \"Reducing left cropping to %d \" \"chroma samples to preserve alignment.\\n\", cropleft); } if (INTMAX / stepx <= cropleft || INTMAX / stepx - cropleft <= cropright || 16 * sps->mbwidth <= stepx * (cropleft + cropright) || INTMAX / stepy <= croptop || INTMAX / stepy - croptop <= cropbottom || 16 * sps->mbheight <= stepy * (croptop + cropbottom)) { avlog(avctx, AVLOGWARNING, \"Invalid crop parameters\\n\"); if (avctx->errrecognition & AVEFEXPLODE) goto fail; cropleft = cropright = croptop = cropbottom = 0; } sps->cropleft = cropleft * stepx; sps->cropright = cropright * stepx; sps->croptop = croptop * stepy; sps->cropbottom = cropbottom * stepy; } } else { sps->cropleft = sps->cropright = sps->croptop = sps->cropbottom = sps->crop = 0; } sps->vuiparameterspresentflag = getbits1(gb); if (sps->vuiparameterspresentflag) { int ret = decodevuiparameters(gb, avctx, sps); if (ret < 0 && avctx->errrecognition & AVEFEXPLODE) goto fail; } /* if the maximum delay is not stored in the SPS, derive it based on the * level */ if (!sps->bitstreamrestrictionflag && (sps->refframecount || avctx->strictstdcompliance >= FFCOMPLIANCESTRICT)) { sps->numreorderframes = MAXDELAYEDPICCOUNT - 1; for (i = 0; i < FFARRAYELEMS(levelmaxdpbmbs); i++) { if (levelmaxdpbmbs[i][0] == sps->levelidc) { sps->numreorderframes = FFMIN(levelmaxdpbmbs[i][1] / (sps->mbwidth * sps->mbheight), sps->numreorderframes); break; } } } if (!sps->sar.den) sps->sar.den = 1; if (avctx->debug & FFDEBUGPICTINFO) { static const char csp[4][5] = { \"Gray\", \"420\", \"422\", \"444\" }; avlog(avctx, AVLOGDEBUG, \"sps:%u profile:%d/%d poc:%d ref:%d %dx%d %s %s crop:%u/%u/%u/%u %s %s %\"PRId32\"/%\"PRId32\"\\n\", spsid, sps->profileidc, sps->levelidc, sps->poctype, sps->refframecount, sps->mbwidth, sps->mbheight, sps->framembsonlyflag ? \"FRM\" : (sps->mbaff ? \"MB-AFF\" : \"PIC-AFF\"), sps->direct8x8inferenceflag ? \"8B8\" : \"\", sps->cropleft, sps->cropright, sps->croptop, sps->cropbottom, sps->vuiparameterspresentflag ? \"VUI\" : \"\", csp[sps->chromaformatidc], sps->timinginfopresentflag ? sps->numunitsintick : 0, sps->timinginfopresentflag ? sps->timescale : 0); } /* check if this is a repeat of an already parsed SPS, then keep the * original one. * otherwise drop all PPSes that depend on it */ if (ps->spslist[spsid] && !memcmp(ps->spslist[spsid]->data, spsbuf->data, spsbuf->size)) { avbufferunref(&spsbuf); } else { removesps(ps, spsid); ps->spslist[spsid] = spsbuf; } return 0; fail: avbufferunref(&spsbuf); return AVERRORINVALIDDATA; } ", "target": 0}
{"func": "static void cchipwrite(void *opaque, hwaddr addr, uint64t val, unsigned size) { TyphoonState *s = opaque; uint64t oldval, newval; switch (addr) { case 0x0000: /* CSC: Cchip System Configuration Register. */ /* All sorts of data here; nothing relevant RW. */ break; case 0x0040: /* MTR: Memory Timing Register. */ /* All sorts of stuff related to real DRAM. */ break; case 0x0080: /* MISC: Miscellaneous Register. */ newval = oldval = s->cchip.misc; newval &= ~(val & 0x10000ff0); /* W1C fields */ if (val & 0x100000) { newval &= ~0xff0000ull; /* ACL clears ABT and ABW */ } else { newval |= val & 0x00f00000; /* ABT field is W1S */ if ((newval & 0xf0000) == 0) { newval |= val & 0xf0000; /* ABW field is W1S iff zero */ } } newval |= (val & 0xf000) >> 4; /* IPREQ field sets IPINTR. */ newval &= ~0xf0000000000ull; /* WO and RW fields */ newval |= val & 0xf0000000000ull; s->cchip.misc = newval; /* Pass on changes to IPI and ITI state. */ if ((newval ^ oldval) & 0xff0) { int i; for (i = 0; i < 4; ++i) { AlphaCPU *cpu = s->cchip.cpu[i]; if (cpu != NULL) { CPUState *cs = CPU(cpu); /* IPI can be either cleared or set by the write. */ if (newval & (1 << (i + 8))) { cpuinterrupt(cs, CPUINTERRUPTSMP); } else { cpuresetinterrupt(cs, CPUINTERRUPTSMP); } /* ITI can only be cleared by the write. */ if ((newval & (1 << (i + 4))) == 0) { cpuresetinterrupt(cs, CPUINTERRUPTTIMER); } } } } break; case 0x00c0: /* MPD: Memory Presence Detect Register. */ break; case 0x0100: /* AAR0 */ case 0x0140: /* AAR1 */ case 0x0180: /* AAR2 */ case 0x01c0: /* AAR3 */ /* AAR: Array Address Register. */ /* All sorts of information about DRAM. */ break; case 0x0200: /* DIM0 */ /* DIM: Device Interrupt Mask Register, CPU0. */ s->cchip.dim[0] = val; cpuirqchange(s->cchip.cpu[0], val & s->cchip.drir); break; case 0x0240: /* DIM1 */ /* DIM: Device Interrupt Mask Register, CPU1. */ s->cchip.dim[0] = val; cpuirqchange(s->cchip.cpu[1], val & s->cchip.drir); break; case 0x0280: /* DIR0 (RO) */ case 0x02c0: /* DIR1 (RO) */ case 0x0300: /* DRIR (RO) */ break; case 0x0340: /* PRBEN: Probe Enable Register. */ break; case 0x0380: /* IIC0 */ s->cchip.iic[0] = val & 0xffffff; break; case 0x03c0: /* IIC1 */ s->cchip.iic[1] = val & 0xffffff; break; case 0x0400: /* MPR0 */ case 0x0440: /* MPR1 */ case 0x0480: /* MPR2 */ case 0x04c0: /* MPR3 */ /* MPR: Memory Programming Register. */ break; case 0x0580: /* TTR: TIGbus Timing Register. */ /* All sorts of stuff related to interrupt delivery timings. */ break; case 0x05c0: /* TDR: TIGbug Device Timing Register. */ break; case 0x0600: /* DIM2: Device Interrupt Mask Register, CPU2. */ s->cchip.dim[2] = val; cpuirqchange(s->cchip.cpu[2], val & s->cchip.drir); break; case 0x0640: /* DIM3: Device Interrupt Mask Register, CPU3. */ s->cchip.dim[3] = val; cpuirqchange(s->cchip.cpu[3], val & s->cchip.drir); break; case 0x0680: /* DIR2 (RO) */ case 0x06c0: /* DIR3 (RO) */ break; case 0x0700: /* IIC2 */ s->cchip.iic[2] = val & 0xffffff; break; case 0x0740: /* IIC3 */ s->cchip.iic[3] = val & 0xffffff; break; case 0x0780: /* PWR: Power Management Control. */ break; case 0x0c00: /* CMONCTLA */ case 0x0c40: /* CMONCTLB */ case 0x0c80: /* CMONCNT01 */ case 0x0cc0: /* CMONCNT23 */ break; default: cpuunassignedaccess(currentcpu, addr, true, false, 0, size); return; } } ", "target": 0}
{"func": "static void exynos4210combinerwrite(void *opaque, targetphysaddrt offset, uint64t val, unsigned size) { struct Exynos4210CombinerState *s = (struct Exynos4210CombinerState *)opaque; uint32t reqquadbasen; /* Base of registers quad. Multiply it by 4 and get a start of corresponding group quad */ uint32t grpquadbasen; /* Base of group quad */ uint32t regn; /* Register number inside the quad */ reqquadbasen = offset >> 4; grpquadbasen = reqquadbasen << 2; regn = (offset - (reqquadbasen << 4)) >> 2; if (reqquadbasen >= IICNGRP) { hwerror(\"exynos4210.combiner: unallowed write access at offset 0x\" TARGETFMTplx \"\\n\", offset); return; } if (regn > 1) { hwerror(\"exynos4210.combiner: unallowed write access at offset 0x\" TARGETFMTplx \"\\n\", offset); return; } if (offset >> 2 >= IICREGSETSIZE) { hwerror(\"exynos4210.combiner: overflow of regset by 0x\" TARGETFMTplx \"offset\\n\", offset); } s->regset[offset >> 2] = val; switch (regn) { /* IIESR */ case 0: /* FIXME: what if irq is pending, allowed by mask, and we allow it * again. Interrupt will rise again! */ DPRINTF(\"%s enable IRQ for groups %d, %d, %d, %d\\n\", s->external ? \"EXT\" : \"INT\", grpquadbasen, grpquadbasen + 1, grpquadbasen + 2, grpquadbasen + 3); /* Enable interrupt sources */ s->group[grpquadbasen].srcmask |= val & 0xFF; s->group[grpquadbasen + 1].srcmask |= (val & 0xFF00) >> 8; s->group[grpquadbasen + 2].srcmask |= (val & 0xFF0000) >> 16; s->group[grpquadbasen + 3].srcmask |= (val & 0xFF000000) >> 24; exynos4210combinerupdate(s, grpquadbasen); exynos4210combinerupdate(s, grpquadbasen + 1); exynos4210combinerupdate(s, grpquadbasen + 2); exynos4210combinerupdate(s, grpquadbasen + 3); break; /* IIECR */ case 1: DPRINTF(\"%s disable IRQ for groups %d, %d, %d, %d\\n\", s->external ? \"EXT\" : \"INT\", grpquadbasen, grpquadbasen + 1, grpquadbasen + 2, grpquadbasen + 3); /* Disable interrupt sources */ s->group[grpquadbasen].srcmask &= ~(val & 0xFF); s->group[grpquadbasen + 1].srcmask &= ~((val & 0xFF00) >> 8); s->group[grpquadbasen + 2].srcmask &= ~((val & 0xFF0000) >> 16); s->group[grpquadbasen + 3].srcmask &= ~((val & 0xFF000000) >> 24); exynos4210combinerupdate(s, grpquadbasen); exynos4210combinerupdate(s, grpquadbasen + 1); exynos4210combinerupdate(s, grpquadbasen + 2); exynos4210combinerupdate(s, grpquadbasen + 3); break; default: hwerror(\"exynos4210.combiner: unallowed write access at offset 0x\" TARGETFMTplx \"\\n\", offset); break; } } ", "target": 0}
{"func": "static void btsubmitacl(struct HCIInfo *info, const uint8t *data, int length) { struct bthcis *hci = hcifrominfo(info); uint16t handle; int datalen, flags; struct btlinks *link; if (length < HCIACLHDRSIZE) { fprintf(stderr, \"%s: ACL packet too short (%iB)\\n\", FUNCTION, length); return; } handle = aclhandle((data[1] << 8) | data[0]); flags = aclflags((data[1] << 8) | data[0]); datalen = (data[3] << 8) | data[2]; data += HCIACLHDRSIZE; length -= HCIACLHDRSIZE; if (bthcihandlebad(hci, handle)) { fprintf(stderr, \"%s: invalid ACL handle %03x\\n\", FUNCTION, handle); /* TODO: signal an error */ return; } handle &= ~HCIHANDLEOFFSET; if (datalen > length) { fprintf(stderr, \"%s: ACL packet too short (%iB < %iB)\\n\", FUNCTION, length, datalen); return; } link = hci->lm.handle[handle].link; if ((flags & ~3) == ACLACTIVEBCAST) { if (!hci->asbhandle) hci->asbhandle = handle; else if (handle != hci->asbhandle) { fprintf(stderr, \"%s: Bad handle %03x in Active Slave Broadcast\\n\", FUNCTION, handle); /* TODO: signal an error */ return; } /* TODO */ } if ((flags & ~3) == ACLPICOBCAST) { if (!hci->psbhandle) hci->psbhandle = handle; else if (handle != hci->psbhandle) { fprintf(stderr, \"%s: Bad handle %03x in Parked Slave Broadcast\\n\", FUNCTION, handle); /* TODO: signal an error */ return; } /* TODO */ } /* TODO: increase counter and send EVTNUMCOMPPKTS */ bthcieventnumcomppkts(hci, handle | HCIHANDLEOFFSET, 1); /* Do this last as it can trigger further events even in this HCI */ hci->lm.handle[handle].lmpacldata(link, data, (flags & 3) == ACLSTART, length); } ", "target": 0}
{"func": "static int nbdcoflush(BlockDriverState *bs) { BDRVNBDState *s = bs->opaque; return nbdclientsessioncoflush(&s->client); } ", "target": 0}
{"func": "static int qiovisaligned(QEMUIOVector *qiov) { int i; for (i = 0; i < qiov->niov; i++) { if ((uintptrt) qiov->iov[i].iovbase % BDRVSECTORSIZE) { return 0; } } return 1; } ", "target": 0}
{"func": "static int seqvideodecodeframe(AVCodecContext *avctx, void *data, int *datasize, AVPacket *avpkt) { const uint8t *buf = avpkt->data; int bufsize = avpkt->size; SeqVideoContext *seq = avctx->privdata; seq->frame.reference = 1; seq->frame.bufferhints = FFBUFFERHINTSVALID | FFBUFFERHINTSPRESERVE | FFBUFFERHINTSREUSABLE; if (avctx->regetbuffer(avctx, &seq->frame)) { avlog(seq->avctx, AVLOGERROR, \"tiertexseqvideo: regetbuffer() failed\\n\"); return -1; } seqvideodecode(seq, buf, bufsize); *datasize = sizeof(AVFrame); *(AVFrame *)data = seq->frame; return bufsize; } ", "target": 1}
{"func": "static ssizet imxfecreceive(NetClientState *nc, const uint8t *buf, sizet len) { IMXFECState *s = IMXFEC(qemugetnicopaque(nc)); IMXFECBufDesc bd; uint32t flags = 0; uint32t addr; uint32t crc; uint32t bufaddr; uint8t *crcptr; unsigned int buflen; sizet size = len; FECPRINTF(\"len %d\\n\", (int)size); if (!s->regs[ENETRDAR]) { qemulogmask(LOGGUESTERROR, \"[%s]%s: Unexpected packet\\n\", TYPEIMXFEC, func); return 0; } /* 4 bytes for the CRC. */ size += 4; crc = cputobe32(crc32(~0, buf, size)); crcptr = (uint8t *) &crc; /* Huge frames are truncated. */ if (size > ENETMAXFRAMESIZE) { size = ENETMAXFRAMESIZE; flags |= ENETBDTR | ENETBDLG; } /* Frames larger than the user limit just set error flags. */ if (size > (s->regs[ENETRCR] >> 16)) { flags |= ENETBDLG; } addr = s->rxdescriptor; while (size > 0) { imxfecreadbd(&bd, addr); if ((bd.flags & ENETBDE) == 0) { /* No descriptors available. Bail out. */ /* * FIXME: This is wrong. We should probably either * save the remainder for when more RX buffers are * available, or flag an error. */ qemulogmask(LOGGUESTERROR, \"[%s]%s: Lost end of frame\\n\", TYPEIMXFEC, func); break; } buflen = (size <= s->regs[ENETMRBR]) ? size : s->regs[ENETMRBR]; bd.length = buflen; size -= buflen; FECPRINTF(\"rxbd 0x%x length %d\\n\", addr, bd.length); /* The last 4 bytes are the CRC. */ if (size < 4) { buflen += size - 4; } bufaddr = bd.data; dmamemorywrite(&addressspacememory, bufaddr, buf, buflen); buf += buflen; if (size < 4) { dmamemorywrite(&addressspacememory, bufaddr + buflen, crcptr, 4 - size); crcptr += 4 - size; } bd.flags &= ~ENETBDE; if (size == 0) { /* Last buffer in frame. */ bd.flags |= flags | ENETBDL; FECPRINTF(\"rx frame flags %04x\\n\", bd.flags); s->regs[ENETEIR] |= ENETINTRXF; } else { s->regs[ENETEIR] |= ENETINTRXB; } imxfecwritebd(&bd, addr); /* Advance to the next descriptor. */ if ((bd.flags & ENETBDW) != 0) { addr = s->regs[ENETRDSR]; } else { addr += sizeof(bd); } } s->rxdescriptor = addr; imxethenablerx(s); imxethupdate(s); return len; } ", "target": 1}
{"func": "static void breakpointhandler(CPUState *env) { CPUBreakpoint *bp; if (env->watchpointhit) { if (env->watchpointhit->flags & BPCPU) { env->watchpointhit = NULL; if (checkhwbreakpoints(env, 0)) raiseexception(EXCP01DB); else cpuresumefromsignal(env, NULL); } } else { TAILQFOREACH(bp, &env->breakpoints, entry) if (bp->pc == env->eip) { if (bp->flags & BPCPU) { checkhwbreakpoints(env, 1); raiseexception(EXCP01DB); } break; } } if (prevdebugexcphandler) prevdebugexcphandler(env); } ", "target": 0}
{"func": "static gboolean gdbuttonevent(GtkWidget *widget, GdkEventButton *button, void *opaque) { VirtualConsole *vc = opaque; GtkDisplayState *s = vc->s; InputButton btn; /* implicitly grab the input at the first click in the relative mode */ if (button->button == 1 && button->type == GDKBUTTONPRESS && !qemuinputisabsolute() && !gdisgrabactive(s)) { gtkcheckmenuitemsetactive(GTKCHECKMENUITEM(s->grabitem), TRUE); return TRUE; } if (button->button == 1) { btn = INPUTBUTTONLEFT; } else if (button->button == 2) { btn = INPUTBUTTONMIDDLE; } else if (button->button == 3) { btn = INPUTBUTTONRIGHT; } else { return TRUE; } qemuinputqueuebtn(vc->gfx.dcl.con, btn, button->type == GDKBUTTONPRESS); qemuinputeventsync(); return TRUE; } ", "target": 0}
{"func": "static void * attributealignarg worker(void *v){ AVCodecContext *avctx = v; ThreadContext *c = avctx->internal->framethreadencoder; AVPacket *pkt = NULL; while(!c->exit){ int gotpacket, ret; AVFrame *frame; Task task; if(!pkt) pkt= avmallocz(sizeof(*pkt)); if(!pkt) continue; avinitpacket(pkt); pthreadmutexlock(&c->taskfifomutex); while (avfifosize(c->taskfifo) <= 0 || c->exit) { if(c->exit){ pthreadmutexunlock(&c->taskfifomutex); goto end; } pthreadcondwait(&c->taskfifocond, &c->taskfifomutex); } avfifogenericread(c->taskfifo, &task, sizeof(task), NULL); pthreadmutexunlock(&c->taskfifomutex); frame = task.indata; ret = avcodecencodevideo2(avctx, pkt, frame, &gotpacket); pthreadmutexlock(&c->buffermutex); avframeunref(frame); pthreadmutexunlock(&c->buffermutex); avframefree(&frame); if(gotpacket) { int ret2 = avduppacket(pkt); if (ret >= 0 && ret2 < 0) ret = ret2; } else { pkt->data = NULL; pkt->size = 0; } pthreadmutexlock(&c->finishedtaskmutex); c->finishedtasks[task.index].outdata = pkt; pkt = NULL; c->finishedtasks[task.index].returncode = ret; pthreadcondsignal(&c->finishedtaskcond); pthreadmutexunlock(&c->finishedtaskmutex); } end: avfree(pkt); pthreadmutexlock(&c->buffermutex); avcodecclose(avctx); pthreadmutexunlock(&c->buffermutex); avfreep(&avctx); return NULL; } ", "target": 1}
{"func": "static void decodeopc(DisasContext * ctx) { /* This code tries to make movcal emulation sufficiently accurate for Linux purposes. This instruction writes memory, and prior to that, always allocates a cache line. It is used in two contexts: - in memcpy, where data is copied in blocks, the first write of to a block uses movca.l for performance. - in arch/sh/mm/cache-sh4.c, movcal.l + ocbi combination is used to flush the cache. Here, the data written by movcal.l is never written to memory, and the data written is just bogus. To simulate this, we simulate movcal.l, we store the value to memory, but we also remember the previous content. If we see ocbi, we check if movcal.l for that address was done previously. If so, the write should not have hit the memory, so we restore the previous content. When we see an instruction that is neither movca.l nor ocbi, the previous content is discarded. To optimize, we only try to flush stores when we're at the start of TB, or if we already saw movca.l in this TB and did not flush stores yet. */ if (ctx->hasmovcal) \t{ \t int opcode = ctx->opcode & 0xf0ff; \t if (opcode != 0x0093 /* ocbi */ \t && opcode != 0x00c3 /* movca.l */) \t { \t\t genhelperdiscardmovcalbackup (); \t\t ctx->hasmovcal = 0; \t } \t} #if 0 fprintf(stderr, \"Translating opcode 0x%04x\\n\", ctx->opcode); #endif switch (ctx->opcode) { case 0x0019:\t\t/* div0u */ \ttcggenandii32(cpusr, cpusr, ~(SRM | SRQ | SRT)); \treturn; case 0x000b:\t\t/* rts */ \tCHECKNOTDELAYSLOT \ttcggenmovi32(cpudelayedpc, cpupr); \tctx->flags |= DELAYSLOT; \tctx->delayedpc = (uint32t) - 1; \treturn; case 0x0028:\t\t/* clrmac */ \ttcggenmovii32(cpumach, 0); \ttcggenmovii32(cpumacl, 0); \treturn; case 0x0048:\t\t/* clrs */ \ttcggenandii32(cpusr, cpusr, ~SRS); \treturn; case 0x0008:\t\t/* clrt */ \tgenclrt(); \treturn; case 0x0038:\t\t/* ldtlb */ \tCHECKPRIVILEGED \tgenhelperldtlb(); \treturn; case 0x002b:\t\t/* rte */ \tCHECKPRIVILEGED \tCHECKNOTDELAYSLOT \ttcggenmovi32(cpusr, cpussr); \ttcggenmovi32(cpudelayedpc, cpuspc); \tctx->flags |= DELAYSLOT; \tctx->delayedpc = (uint32t) - 1; \treturn; case 0x0058:\t\t/* sets */ \ttcggenorii32(cpusr, cpusr, SRS); \treturn; case 0x0018:\t\t/* sett */ \tgensett(); \treturn; case 0xfbfd:\t\t/* frchg */ \ttcggenxorii32(cpufpscr, cpufpscr, FPSCRFR); \tctx->bstate = BSSTOP; \treturn; case 0xf3fd:\t\t/* fschg */ \ttcggenxorii32(cpufpscr, cpufpscr, FPSCRSZ); \tctx->bstate = BSSTOP; \treturn; case 0x0009:\t\t/* nop */ \treturn; case 0x001b:\t\t/* sleep */ \tCHECKPRIVILEGED \tgenhelpersleep(tcgconsti32(ctx->pc + 2)); \treturn; } switch (ctx->opcode & 0xf000) { case 0x1000:\t\t/* mov.l Rm,@(disp,Rn) */ \t{ \t TCGv addr = tcgtempnew(); \t tcggenaddii32(addr, REG(B118), B30 * 4); \t tcggenqemust32(REG(B74), addr, ctx->memidx); \t tcgtempfree(addr); \t} \treturn; case 0x5000:\t\t/* mov.l @(disp,Rm),Rn */ \t{ \t TCGv addr = tcgtempnew(); \t tcggenaddii32(addr, REG(B74), B30 * 4); \t tcggenqemuld32s(REG(B118), addr, ctx->memidx); \t tcgtempfree(addr); \t} \treturn; case 0xe000:\t\t/* mov #imm,Rn */ \ttcggenmovii32(REG(B118), B70s); \treturn; case 0x9000:\t\t/* mov.w @(disp,PC),Rn */ \t{ \t TCGv addr = tcgconsti32(ctx->pc + 4 + B70 * 2); \t tcggenqemuld16s(REG(B118), addr, ctx->memidx); \t tcgtempfree(addr); \t} \treturn; case 0xd000:\t\t/* mov.l @(disp,PC),Rn */ \t{ \t TCGv addr = tcgconsti32((ctx->pc + 4 + B70 * 4) & ~3); \t tcggenqemuld32s(REG(B118), addr, ctx->memidx); \t tcgtempfree(addr); \t} \treturn; case 0x7000:\t\t/* add #imm,Rn */ \ttcggenaddii32(REG(B118), REG(B118), B70s); \treturn; case 0xa000:\t\t/* bra disp */ \tCHECKNOTDELAYSLOT \tctx->delayedpc = ctx->pc + 4 + B110s * 2; \ttcggenmovii32(cpudelayedpc, ctx->delayedpc); \tctx->flags |= DELAYSLOT; \treturn; case 0xb000:\t\t/* bsr disp */ \tCHECKNOTDELAYSLOT \ttcggenmovii32(cpupr, ctx->pc + 4); \tctx->delayedpc = ctx->pc + 4 + B110s * 2; \ttcggenmovii32(cpudelayedpc, ctx->delayedpc); \tctx->flags |= DELAYSLOT; \treturn; } switch (ctx->opcode & 0xf00f) { case 0x6003:\t\t/* mov Rm,Rn */ \ttcggenmovi32(REG(B118), REG(B74)); \treturn; case 0x2000:\t\t/* mov.b Rm,@Rn */ \ttcggenqemust8(REG(B74), REG(B118), ctx->memidx); \treturn; case 0x2001:\t\t/* mov.w Rm,@Rn */ \ttcggenqemust16(REG(B74), REG(B118), ctx->memidx); \treturn; case 0x2002:\t\t/* mov.l Rm,@Rn */ \ttcggenqemust32(REG(B74), REG(B118), ctx->memidx); \treturn; case 0x6000:\t\t/* mov.b @Rm,Rn */ \ttcggenqemuld8s(REG(B118), REG(B74), ctx->memidx); \treturn; case 0x6001:\t\t/* mov.w @Rm,Rn */ \ttcggenqemuld16s(REG(B118), REG(B74), ctx->memidx); \treturn; case 0x6002:\t\t/* mov.l @Rm,Rn */ \ttcggenqemuld32s(REG(B118), REG(B74), ctx->memidx); \treturn; case 0x2004:\t\t/* mov.b Rm,@-Rn */ \t{ \t TCGv addr = tcgtempnew(); \t tcggensubii32(addr, REG(B118), 1); \t tcggenqemust8(REG(B74), addr, ctx->memidx);\t/* might cause re-execution */ \t tcggenmovi32(REG(B118), addr);\t\t\t/* modify register status */ \t tcgtempfree(addr); \t} \treturn; case 0x2005:\t\t/* mov.w Rm,@-Rn */ \t{ \t TCGv addr = tcgtempnew(); \t tcggensubii32(addr, REG(B118), 2); \t tcggenqemust16(REG(B74), addr, ctx->memidx); \t tcggenmovi32(REG(B118), addr); \t tcgtempfree(addr); \t} \treturn; case 0x2006:\t\t/* mov.l Rm,@-Rn */ \t{ \t TCGv addr = tcgtempnew(); \t tcggensubii32(addr, REG(B118), 4); \t tcggenqemust32(REG(B74), addr, ctx->memidx); \t tcggenmovi32(REG(B118), addr); \t} \treturn; case 0x6004:\t\t/* mov.b @Rm+,Rn */ \ttcggenqemuld8s(REG(B118), REG(B74), ctx->memidx); \tif ( B118 != B74 ) \t\ttcggenaddii32(REG(B74), REG(B74), 1); \treturn; case 0x6005:\t\t/* mov.w @Rm+,Rn */ \ttcggenqemuld16s(REG(B118), REG(B74), ctx->memidx); \tif ( B118 != B74 ) \t\ttcggenaddii32(REG(B74), REG(B74), 2); \treturn; case 0x6006:\t\t/* mov.l @Rm+,Rn */ \ttcggenqemuld32s(REG(B118), REG(B74), ctx->memidx); \tif ( B118 != B74 ) \t\ttcggenaddii32(REG(B74), REG(B74), 4); \treturn; case 0x0004:\t\t/* mov.b Rm,@(R0,Rn) */ \t{ \t TCGv addr = tcgtempnew(); \t tcggenaddi32(addr, REG(B118), REG(0)); \t tcggenqemust8(REG(B74), addr, ctx->memidx); \t tcgtempfree(addr); \t} \treturn; case 0x0005:\t\t/* mov.w Rm,@(R0,Rn) */ \t{ \t TCGv addr = tcgtempnew(); \t tcggenaddi32(addr, REG(B118), REG(0)); \t tcggenqemust16(REG(B74), addr, ctx->memidx); \t tcgtempfree(addr); \t} \treturn; case 0x0006:\t\t/* mov.l Rm,@(R0,Rn) */ \t{ \t TCGv addr = tcgtempnew(); \t tcggenaddi32(addr, REG(B118), REG(0)); \t tcggenqemust32(REG(B74), addr, ctx->memidx); \t tcgtempfree(addr); \t} \treturn; case 0x000c:\t\t/* mov.b @(R0,Rm),Rn */ \t{ \t TCGv addr = tcgtempnew(); \t tcggenaddi32(addr, REG(B74), REG(0)); \t tcggenqemuld8s(REG(B118), addr, ctx->memidx); \t tcgtempfree(addr); \t} \treturn; case 0x000d:\t\t/* mov.w @(R0,Rm),Rn */ \t{ \t TCGv addr = tcgtempnew(); \t tcggenaddi32(addr, REG(B74), REG(0)); \t tcggenqemuld16s(REG(B118), addr, ctx->memidx); \t tcgtempfree(addr); \t} \treturn; case 0x000e:\t\t/* mov.l @(R0,Rm),Rn */ \t{ \t TCGv addr = tcgtempnew(); \t tcggenaddi32(addr, REG(B74), REG(0)); \t tcggenqemuld32s(REG(B118), addr, ctx->memidx); \t tcgtempfree(addr); \t} \treturn; case 0x6008:\t\t/* swap.b Rm,Rn */ \t{ \t TCGv high, low; \t high = tcgtempnew(); \t tcggenandii32(high, REG(B74), 0xffff0000); \t low = tcgtempnew(); \t tcggenext16ui32(low, REG(B74)); \t tcggenbswap16i32(low, low); \t tcggenori32(REG(B118), high, low); \t tcgtempfree(low); \t tcgtempfree(high); \t} \treturn; case 0x6009:\t\t/* swap.w Rm,Rn */ \t{ \t TCGv high, low; \t high = tcgtempnew(); \t tcggenshlii32(high, REG(B74), 16); \t low = tcgtempnew(); \t tcggenshrii32(low, REG(B74), 16); \t tcggenext16ui32(low, low); \t tcggenori32(REG(B118), high, low); \t tcgtempfree(low); \t tcgtempfree(high); \t} \treturn; case 0x200d:\t\t/* xtrct Rm,Rn */ \t{ \t TCGv high, low; \t high = tcgtempnew(); \t tcggenshlii32(high, REG(B74), 16); \t low = tcgtempnew(); \t tcggenshrii32(low, REG(B118), 16); \t tcggenext16ui32(low, low); \t tcggenori32(REG(B118), high, low); \t tcgtempfree(low); \t tcgtempfree(high); \t} \treturn; case 0x300c:\t\t/* add Rm,Rn */ \ttcggenaddi32(REG(B118), REG(B118), REG(B74)); \treturn; case 0x300e:\t\t/* addc Rm,Rn */ \tgenhelperaddc(REG(B118), REG(B74), REG(B118)); \treturn; case 0x300f:\t\t/* addv Rm,Rn */ \tgenhelperaddv(REG(B118), REG(B74), REG(B118)); \treturn; case 0x2009:\t\t/* and Rm,Rn */ \ttcggenandi32(REG(B118), REG(B118), REG(B74)); \treturn; case 0x3000:\t\t/* cmp/eq Rm,Rn */ \tgencmp(TCGCONDEQ, REG(B74), REG(B118)); \treturn; case 0x3003:\t\t/* cmp/ge Rm,Rn */ \tgencmp(TCGCONDGE, REG(B74), REG(B118)); \treturn; case 0x3007:\t\t/* cmp/gt Rm,Rn */ \tgencmp(TCGCONDGT, REG(B74), REG(B118)); \treturn; case 0x3006:\t\t/* cmp/hi Rm,Rn */ \tgencmp(TCGCONDGTU, REG(B74), REG(B118)); \treturn; case 0x3002:\t\t/* cmp/hs Rm,Rn */ \tgencmp(TCGCONDGEU, REG(B74), REG(B118)); \treturn; case 0x200c:\t\t/* cmp/str Rm,Rn */ \t{ \t int label1 = gennewlabel(); \t int label2 = gennewlabel(); \t TCGv cmp1 = tcgtemplocalnew(); \t TCGv cmp2 = tcgtemplocalnew(); \t tcggenxori32(cmp1, REG(B74), REG(B118)); \t tcggenandii32(cmp2, cmp1, 0xff000000); \t tcggenbrcondii32(TCGCONDEQ, cmp2, 0, label1); \t tcggenandii32(cmp2, cmp1, 0x00ff0000); \t tcggenbrcondii32(TCGCONDEQ, cmp2, 0, label1); \t tcggenandii32(cmp2, cmp1, 0x0000ff00); \t tcggenbrcondii32(TCGCONDEQ, cmp2, 0, label1); \t tcggenandii32(cmp2, cmp1, 0x000000ff); \t tcggenbrcondii32(TCGCONDEQ, cmp2, 0, label1); \t tcggenandii32(cpusr, cpusr, ~SRT); \t tcggenbr(label2); \t gensetlabel(label1); \t tcggenorii32(cpusr, cpusr, SRT); \t gensetlabel(label2); \t tcgtempfree(cmp2); \t tcgtempfree(cmp1); \t} \treturn; case 0x2007:\t\t/* div0s Rm,Rn */ \t{ \t gencopybiti32(cpusr, 8, REG(B118), 31);\t/* SRQ */ \t gencopybiti32(cpusr, 9, REG(B74), 31);\t\t/* SRM */ \t TCGv val = tcgtempnew(); \t tcggenxori32(val, REG(B74), REG(B118)); \t gencopybiti32(cpusr, 0, val, 31);\t\t/* SRT */ \t tcgtempfree(val); \t} \treturn; case 0x3004:\t\t/* div1 Rm,Rn */ \tgenhelperdiv1(REG(B118), REG(B74), REG(B118)); \treturn; case 0x300d:\t\t/* dmuls.l Rm,Rn */ \t{ \t TCGvi64 tmp1 = tcgtempnewi64(); \t TCGvi64 tmp2 = tcgtempnewi64(); \t tcggenexti32i64(tmp1, REG(B74)); \t tcggenexti32i64(tmp2, REG(B118)); \t tcggenmuli64(tmp1, tmp1, tmp2); \t tcggentrunci64i32(cpumacl, tmp1); \t tcggenshrii64(tmp1, tmp1, 32); \t tcggentrunci64i32(cpumach, tmp1); \t tcgtempfreei64(tmp2); \t tcgtempfreei64(tmp1); \t} \treturn; case 0x3005:\t\t/* dmulu.l Rm,Rn */ \t{ \t TCGvi64 tmp1 = tcgtempnewi64(); \t TCGvi64 tmp2 = tcgtempnewi64(); \t tcggenextui32i64(tmp1, REG(B74)); \t tcggenextui32i64(tmp2, REG(B118)); \t tcggenmuli64(tmp1, tmp1, tmp2); \t tcggentrunci64i32(cpumacl, tmp1); \t tcggenshrii64(tmp1, tmp1, 32); \t tcggentrunci64i32(cpumach, tmp1); \t tcgtempfreei64(tmp2); \t tcgtempfreei64(tmp1); \t} \treturn; case 0x600e:\t\t/* exts.b Rm,Rn */ \ttcggenext8si32(REG(B118), REG(B74)); \treturn; case 0x600f:\t\t/* exts.w Rm,Rn */ \ttcggenext16si32(REG(B118), REG(B74)); \treturn; case 0x600c:\t\t/* extu.b Rm,Rn */ \ttcggenext8ui32(REG(B118), REG(B74)); \treturn; case 0x600d:\t\t/* extu.w Rm,Rn */ \ttcggenext16ui32(REG(B118), REG(B74)); \treturn; case 0x000f:\t\t/* mac.l @Rm+,@Rn+ */ \t{ \t TCGv arg0, arg1; \t arg0 = tcgtempnew(); \t tcggenqemuld32s(arg0, REG(B74), ctx->memidx); \t arg1 = tcgtempnew(); \t tcggenqemuld32s(arg1, REG(B118), ctx->memidx); \t genhelpermacl(arg0, arg1); \t tcgtempfree(arg1); \t tcgtempfree(arg0); \t tcggenaddii32(REG(B74), REG(B74), 4); \t tcggenaddii32(REG(B118), REG(B118), 4); \t} \treturn; case 0x400f:\t\t/* mac.w @Rm+,@Rn+ */ \t{ \t TCGv arg0, arg1; \t arg0 = tcgtempnew(); \t tcggenqemuld32s(arg0, REG(B74), ctx->memidx); \t arg1 = tcgtempnew(); \t tcggenqemuld32s(arg1, REG(B118), ctx->memidx); \t genhelpermacw(arg0, arg1); \t tcgtempfree(arg1); \t tcgtempfree(arg0); \t tcggenaddii32(REG(B118), REG(B118), 2); \t tcggenaddii32(REG(B74), REG(B74), 2); \t} \treturn; case 0x0007:\t\t/* mul.l Rm,Rn */ \ttcggenmuli32(cpumacl, REG(B74), REG(B118)); \treturn; case 0x200f:\t\t/* muls.w Rm,Rn */ \t{ \t TCGv arg0, arg1; \t arg0 = tcgtempnew(); \t tcggenext16si32(arg0, REG(B74)); \t arg1 = tcgtempnew(); \t tcggenext16si32(arg1, REG(B118)); \t tcggenmuli32(cpumacl, arg0, arg1); \t tcgtempfree(arg1); \t tcgtempfree(arg0); \t} \treturn; case 0x200e:\t\t/* mulu.w Rm,Rn */ \t{ \t TCGv arg0, arg1; \t arg0 = tcgtempnew(); \t tcggenext16ui32(arg0, REG(B74)); \t arg1 = tcgtempnew(); \t tcggenext16ui32(arg1, REG(B118)); \t tcggenmuli32(cpumacl, arg0, arg1); \t tcgtempfree(arg1); \t tcgtempfree(arg0); \t} \treturn; case 0x600b:\t\t/* neg Rm,Rn */ \ttcggennegi32(REG(B118), REG(B74)); \treturn; case 0x600a:\t\t/* negc Rm,Rn */ \tgenhelpernegc(REG(B118), REG(B74)); \treturn; case 0x6007:\t\t/* not Rm,Rn */ \ttcggennoti32(REG(B118), REG(B74)); \treturn; case 0x200b:\t\t/* or Rm,Rn */ \ttcggenori32(REG(B118), REG(B118), REG(B74)); \treturn; case 0x400c:\t\t/* shad Rm,Rn */ \t{ \t int label1 = gennewlabel(); \t int label2 = gennewlabel(); \t int label3 = gennewlabel(); \t int label4 = gennewlabel(); \t TCGv shift; \t tcggenbrcondii32(TCGCONDLT, REG(B74), 0, label1); \t /* Rm positive, shift to the left */ shift = tcgtempnew(); \t tcggenandii32(shift, REG(B74), 0x1f); \t tcggenshli32(REG(B118), REG(B118), shift); \t tcgtempfree(shift); \t tcggenbr(label4); \t /* Rm negative, shift to the right */ \t gensetlabel(label1); shift = tcgtempnew(); \t tcggenandii32(shift, REG(B74), 0x1f); \t tcggenbrcondii32(TCGCONDEQ, shift, 0, label2); \t tcggennoti32(shift, REG(B74)); \t tcggenandii32(shift, shift, 0x1f); \t tcggenaddii32(shift, shift, 1); \t tcggensari32(REG(B118), REG(B118), shift); \t tcgtempfree(shift); \t tcggenbr(label4); \t /* Rm = -32 */ \t gensetlabel(label2); \t tcggenbrcondii32(TCGCONDLT, REG(B118), 0, label3); \t tcggenmovii32(REG(B118), 0); \t tcggenbr(label4); \t gensetlabel(label3); \t tcggenmovii32(REG(B118), 0xffffffff); \t gensetlabel(label4); \t} \treturn; case 0x400d:\t\t/* shld Rm,Rn */ \t{ \t int label1 = gennewlabel(); \t int label2 = gennewlabel(); \t int label3 = gennewlabel(); \t TCGv shift; \t tcggenbrcondii32(TCGCONDLT, REG(B74), 0, label1); \t /* Rm positive, shift to the left */ shift = tcgtempnew(); \t tcggenandii32(shift, REG(B74), 0x1f); \t tcggenshli32(REG(B118), REG(B118), shift); \t tcgtempfree(shift); \t tcggenbr(label3); \t /* Rm negative, shift to the right */ \t gensetlabel(label1); shift = tcgtempnew(); \t tcggenandii32(shift, REG(B74), 0x1f); \t tcggenbrcondii32(TCGCONDEQ, shift, 0, label2); \t tcggennoti32(shift, REG(B74)); \t tcggenandii32(shift, shift, 0x1f); \t tcggenaddii32(shift, shift, 1); \t tcggenshri32(REG(B118), REG(B118), shift); \t tcgtempfree(shift); \t tcggenbr(label3); \t /* Rm = -32 */ \t gensetlabel(label2); \t tcggenmovii32(REG(B118), 0); \t gensetlabel(label3); \t} \treturn; case 0x3008:\t\t/* sub Rm,Rn */ \ttcggensubi32(REG(B118), REG(B118), REG(B74)); \treturn; case 0x300a:\t\t/* subc Rm,Rn */ \tgenhelpersubc(REG(B118), REG(B74), REG(B118)); \treturn; case 0x300b:\t\t/* subv Rm,Rn */ \tgenhelpersubv(REG(B118), REG(B74), REG(B118)); \treturn; case 0x2008:\t\t/* tst Rm,Rn */ \t{ \t TCGv val = tcgtempnew(); \t tcggenandi32(val, REG(B74), REG(B118)); \t gencmpimm(TCGCONDEQ, val, 0); \t tcgtempfree(val); \t} \treturn; case 0x200a:\t\t/* xor Rm,Rn */ \ttcggenxori32(REG(B118), REG(B118), REG(B74)); \treturn; case 0xf00c: /* fmov {F,D,X}Rm,{F,D,X}Rn - FPSCR: Nothing */ \tCHECKFPUENABLED \tif (ctx->fpscr & FPSCRSZ) { \t TCGvi64 fp = tcgtempnewi64(); \t genloadfpr64(fp, XREG(B74)); \t genstorefpr64(fp, XREG(B118)); \t tcgtempfreei64(fp); \t} else { \t tcggenmovi32(cpufregs[FREG(B118)], cpufregs[FREG(B74)]); \t} \treturn; case 0xf00a: /* fmov {F,D,X}Rm,@Rn - FPSCR: Nothing */ \tCHECKFPUENABLED \tif (ctx->fpscr & FPSCRSZ) { \t TCGv addrhi = tcgtempnew(); \t int fr = XREG(B74); \t tcggenaddii32(addrhi, REG(B118), 4); \t tcggenqemust32(cpufregs[fr ], REG(B118), ctx->memidx); \t tcggenqemust32(cpufregs[fr+1], addrhi,\t ctx->memidx); \t tcgtempfree(addrhi); \t} else { \t tcggenqemust32(cpufregs[FREG(B74)], REG(B118), ctx->memidx); \t} \treturn; case 0xf008: /* fmov @Rm,{F,D,X}Rn - FPSCR: Nothing */ \tCHECKFPUENABLED \tif (ctx->fpscr & FPSCRSZ) { \t TCGv addrhi = tcgtempnew(); \t int fr = XREG(B118); \t tcggenaddii32(addrhi, REG(B74), 4); \t tcggenqemuld32u(cpufregs[fr ], REG(B74), ctx->memidx); \t tcggenqemuld32u(cpufregs[fr+1], addrhi, ctx->memidx); \t tcgtempfree(addrhi); \t} else { \t tcggenqemuld32u(cpufregs[FREG(B118)], REG(B74), ctx->memidx); \t} \treturn; case 0xf009: /* fmov @Rm+,{F,D,X}Rn - FPSCR: Nothing */ \tCHECKFPUENABLED \tif (ctx->fpscr & FPSCRSZ) { \t TCGv addrhi = tcgtempnew(); \t int fr = XREG(B118); \t tcggenaddii32(addrhi, REG(B74), 4); \t tcggenqemuld32u(cpufregs[fr ], REG(B74), ctx->memidx); \t tcggenqemuld32u(cpufregs[fr+1], addrhi, ctx->memidx); \t tcggenaddii32(REG(B74), REG(B74), 8); \t tcgtempfree(addrhi); \t} else { \t tcggenqemuld32u(cpufregs[FREG(B118)], REG(B74), ctx->memidx); \t tcggenaddii32(REG(B74), REG(B74), 4); \t} \treturn; case 0xf00b: /* fmov {F,D,X}Rm,@-Rn - FPSCR: Nothing */ \tCHECKFPUENABLED \tif (ctx->fpscr & FPSCRSZ) { \t TCGv addr = tcgtempnewi32(); \t int fr = XREG(B74); \t tcggensubii32(addr, REG(B118), 4); \t tcggenqemust32(cpufregs[fr+1], addr, ctx->memidx); \t tcggensubii32(addr, addr, 4); \t tcggenqemust32(cpufregs[fr ], addr, ctx->memidx); \t tcggenmovi32(REG(B118), addr); \t tcgtempfree(addr); \t} else { \t TCGv addr; \t addr = tcgtempnewi32(); \t tcggensubii32(addr, REG(B118), 4); \t tcggenqemust32(cpufregs[FREG(B74)], addr, ctx->memidx); \t tcggenmovi32(REG(B118), addr); \t tcgtempfree(addr); \t} \treturn; case 0xf006: /* fmov @(R0,Rm),{F,D,X}Rm - FPSCR: Nothing */ \tCHECKFPUENABLED \t{ \t TCGv addr = tcgtempnewi32(); \t tcggenaddi32(addr, REG(B74), REG(0)); \t if (ctx->fpscr & FPSCRSZ) { \t\tint fr = XREG(B118); \t\ttcggenqemuld32u(cpufregs[fr\t ], addr, ctx->memidx); \t\ttcggenaddii32(addr, addr, 4); \t\ttcggenqemuld32u(cpufregs[fr+1], addr, ctx->memidx); \t } else { \t\ttcggenqemuld32u(cpufregs[FREG(B118)], addr, ctx->memidx); \t } \t tcgtempfree(addr); \t} \treturn; case 0xf007: /* fmov {F,D,X}Rn,@(R0,Rn) - FPSCR: Nothing */ \tCHECKFPUENABLED \t{ \t TCGv addr = tcgtempnew(); \t tcggenaddi32(addr, REG(B118), REG(0)); \t if (ctx->fpscr & FPSCRSZ) { \t\tint fr = XREG(B74); \t\ttcggenqemuld32u(cpufregs[fr\t ], addr, ctx->memidx); \t\ttcggenaddii32(addr, addr, 4); \t\ttcggenqemuld32u(cpufregs[fr+1], addr, ctx->memidx); \t } else { \t\ttcggenqemust32(cpufregs[FREG(B74)], addr, ctx->memidx); \t } \t tcgtempfree(addr); \t} \treturn; case 0xf000: /* fadd Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */ case 0xf001: /* fsub Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */ case 0xf002: /* fmul Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */ case 0xf003: /* fdiv Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */ case 0xf004: /* fcmp/eq Rm,Rn - FPSCR: R[PR,Enable.V]/W[Cause,Flag] */ case 0xf005: /* fcmp/gt Rm,Rn - FPSCR: R[PR,Enable.V]/W[Cause,Flag] */ \t{ \t CHECKFPUENABLED \t if (ctx->fpscr & FPSCRPR) { TCGvi64 fp0, fp1; \t\tif (ctx->opcode & 0x0110) \t\t break; /* illegal instruction */ \t\tfp0 = tcgtempnewi64(); \t\tfp1 = tcgtempnewi64(); \t\tgenloadfpr64(fp0, DREG(B118)); \t\tgenloadfpr64(fp1, DREG(B74)); switch (ctx->opcode & 0xf00f) { case 0xf000:\t\t/* fadd Rm,Rn */ genhelperfaddDT(fp0, fp0, fp1); break; case 0xf001:\t\t/* fsub Rm,Rn */ genhelperfsubDT(fp0, fp0, fp1); break; case 0xf002:\t\t/* fmul Rm,Rn */ genhelperfmulDT(fp0, fp0, fp1); break; case 0xf003:\t\t/* fdiv Rm,Rn */ genhelperfdivDT(fp0, fp0, fp1); break; case 0xf004:\t\t/* fcmp/eq Rm,Rn */ genhelperfcmpeqDT(fp0, fp1); return; case 0xf005:\t\t/* fcmp/gt Rm,Rn */ genhelperfcmpgtDT(fp0, fp1); return; } \t\tgenstorefpr64(fp0, DREG(B118)); tcgtempfreei64(fp0); tcgtempfreei64(fp1); \t } else { switch (ctx->opcode & 0xf00f) { case 0xf000:\t\t/* fadd Rm,Rn */ genhelperfaddFT(cpufregs[FREG(B118)], cpufregs[FREG(B118)], cpufregs[FREG(B74)]); break; case 0xf001:\t\t/* fsub Rm,Rn */ genhelperfsubFT(cpufregs[FREG(B118)], cpufregs[FREG(B118)], cpufregs[FREG(B74)]); break; case 0xf002:\t\t/* fmul Rm,Rn */ genhelperfmulFT(cpufregs[FREG(B118)], cpufregs[FREG(B118)], cpufregs[FREG(B74)]); break; case 0xf003:\t\t/* fdiv Rm,Rn */ genhelperfdivFT(cpufregs[FREG(B118)], cpufregs[FREG(B118)], cpufregs[FREG(B74)]); break; case 0xf004:\t\t/* fcmp/eq Rm,Rn */ genhelperfcmpeqFT(cpufregs[FREG(B118)], cpufregs[FREG(B74)]); return; case 0xf005:\t\t/* fcmp/gt Rm,Rn */ genhelperfcmpgtFT(cpufregs[FREG(B118)], cpufregs[FREG(B74)]); return; } \t } \t} \treturn; case 0xf00e: /* fmac FR0,RM,Rn */ { CHECKFPUENABLED if (ctx->fpscr & FPSCRPR) { break; /* illegal instruction */ } else { genhelperfmacFT(cpufregs[FREG(B118)], cpufregs[FREG(0)], cpufregs[FREG(B74)], cpufregs[FREG(B118)]); return; } } } switch (ctx->opcode & 0xff00) { case 0xc900:\t\t/* and #imm,R0 */ \ttcggenandii32(REG(0), REG(0), B70); \treturn; case 0xcd00:\t\t/* and.b #imm,@(R0,GBR) */ \t{ \t TCGv addr, val; \t addr = tcgtempnew(); \t tcggenaddi32(addr, REG(0), cpugbr); \t val = tcgtempnew(); \t tcggenqemuld8u(val, addr, ctx->memidx); \t tcggenandii32(val, val, B70); \t tcggenqemust8(val, addr, ctx->memidx); \t tcgtempfree(val); \t tcgtempfree(addr); \t} \treturn; case 0x8b00:\t\t/* bf label */ \tCHECKNOTDELAYSLOT \t genconditionaljump(ctx, ctx->pc + 2, \t\t\t\t ctx->pc + 4 + B70s * 2); \tctx->bstate = BSBRANCH; \treturn; case 0x8f00:\t\t/* bf/s label */ \tCHECKNOTDELAYSLOT \tgenbranchslot(ctx->delayedpc = ctx->pc + 4 + B70s * 2, 0); \tctx->flags |= DELAYSLOTCONDITIONAL; \treturn; case 0x8900:\t\t/* bt label */ \tCHECKNOTDELAYSLOT \t genconditionaljump(ctx, ctx->pc + 4 + B70s * 2, \t\t\t\t ctx->pc + 2); \tctx->bstate = BSBRANCH; \treturn; case 0x8d00:\t\t/* bt/s label */ \tCHECKNOTDELAYSLOT \tgenbranchslot(ctx->delayedpc = ctx->pc + 4 + B70s * 2, 1); \tctx->flags |= DELAYSLOTCONDITIONAL; \treturn; case 0x8800:\t\t/* cmp/eq #imm,R0 */ \tgencmpimm(TCGCONDEQ, REG(0), B70s); \treturn; case 0xc400:\t\t/* mov.b @(disp,GBR),R0 */ \t{ \t TCGv addr = tcgtempnew(); \t tcggenaddii32(addr, cpugbr, B70); \t tcggenqemuld8s(REG(0), addr, ctx->memidx); \t tcgtempfree(addr); \t} \treturn; case 0xc500:\t\t/* mov.w @(disp,GBR),R0 */ \t{ \t TCGv addr = tcgtempnew(); \t tcggenaddii32(addr, cpugbr, B70 * 2); \t tcggenqemuld16s(REG(0), addr, ctx->memidx); \t tcgtempfree(addr); \t} \treturn; case 0xc600:\t\t/* mov.l @(disp,GBR),R0 */ \t{ \t TCGv addr = tcgtempnew(); \t tcggenaddii32(addr, cpugbr, B70 * 4); \t tcggenqemuld32s(REG(0), addr, ctx->memidx); \t tcgtempfree(addr); \t} \treturn; case 0xc000:\t\t/* mov.b R0,@(disp,GBR) */ \t{ \t TCGv addr = tcgtempnew(); \t tcggenaddii32(addr, cpugbr, B70); \t tcggenqemust8(REG(0), addr, ctx->memidx); \t tcgtempfree(addr); \t} \treturn; case 0xc100:\t\t/* mov.w R0,@(disp,GBR) */ \t{ \t TCGv addr = tcgtempnew(); \t tcggenaddii32(addr, cpugbr, B70 * 2); \t tcggenqemust16(REG(0), addr, ctx->memidx); \t tcgtempfree(addr); \t} \treturn; case 0xc200:\t\t/* mov.l R0,@(disp,GBR) */ \t{ \t TCGv addr = tcgtempnew(); \t tcggenaddii32(addr, cpugbr, B70 * 4); \t tcggenqemust32(REG(0), addr, ctx->memidx); \t tcgtempfree(addr); \t} \treturn; case 0x8000:\t\t/* mov.b R0,@(disp,Rn) */ \t{ \t TCGv addr = tcgtempnew(); \t tcggenaddii32(addr, REG(B74), B30); \t tcggenqemust8(REG(0), addr, ctx->memidx); \t tcgtempfree(addr); \t} \treturn; case 0x8100:\t\t/* mov.w R0,@(disp,Rn) */ \t{ \t TCGv addr = tcgtempnew(); \t tcggenaddii32(addr, REG(B74), B30 * 2); \t tcggenqemust16(REG(0), addr, ctx->memidx); \t tcgtempfree(addr); \t} \treturn; case 0x8400:\t\t/* mov.b @(disp,Rn),R0 */ \t{ \t TCGv addr = tcgtempnew(); \t tcggenaddii32(addr, REG(B74), B30); \t tcggenqemuld8s(REG(0), addr, ctx->memidx); \t tcgtempfree(addr); \t} \treturn; case 0x8500:\t\t/* mov.w @(disp,Rn),R0 */ \t{ \t TCGv addr = tcgtempnew(); \t tcggenaddii32(addr, REG(B74), B30 * 2); \t tcggenqemuld16s(REG(0), addr, ctx->memidx); \t tcgtempfree(addr); \t} \treturn; case 0xc700:\t\t/* mova @(disp,PC),R0 */ \ttcggenmovii32(REG(0), ((ctx->pc & 0xfffffffc) + 4 + B70 * 4) & ~3); \treturn; case 0xcb00:\t\t/* or #imm,R0 */ \ttcggenorii32(REG(0), REG(0), B70); \treturn; case 0xcf00:\t\t/* or.b #imm,@(R0,GBR) */ \t{ \t TCGv addr, val; \t addr = tcgtempnew(); \t tcggenaddi32(addr, REG(0), cpugbr); \t val = tcgtempnew(); \t tcggenqemuld8u(val, addr, ctx->memidx); \t tcggenorii32(val, val, B70); \t tcggenqemust8(val, addr, ctx->memidx); \t tcgtempfree(val); \t tcgtempfree(addr); \t} \treturn; case 0xc300:\t\t/* trapa #imm */ \t{ \t TCGv imm; \t CHECKNOTDELAYSLOT \t tcggenmovii32(cpupc, ctx->pc); \t imm = tcgconsti32(B70); \t genhelpertrapa(imm); \t tcgtempfree(imm); \t ctx->bstate = BSBRANCH; \t} \treturn; case 0xc800:\t\t/* tst #imm,R0 */ \t{ \t TCGv val = tcgtempnew(); \t tcggenandii32(val, REG(0), B70); \t gencmpimm(TCGCONDEQ, val, 0); \t tcgtempfree(val); \t} \treturn; case 0xcc00:\t\t/* tst.b #imm,@(R0,GBR) */ \t{ \t TCGv val = tcgtempnew(); \t tcggenaddi32(val, REG(0), cpugbr); \t tcggenqemuld8u(val, val, ctx->memidx); \t tcggenandii32(val, val, B70); \t gencmpimm(TCGCONDEQ, val, 0); \t tcgtempfree(val); \t} \treturn; case 0xca00:\t\t/* xor #imm,R0 */ \ttcggenxorii32(REG(0), REG(0), B70); \treturn; case 0xce00:\t\t/* xor.b #imm,@(R0,GBR) */ \t{ \t TCGv addr, val; \t addr = tcgtempnew(); \t tcggenaddi32(addr, REG(0), cpugbr); \t val = tcgtempnew(); \t tcggenqemuld8u(val, addr, ctx->memidx); \t tcggenxorii32(val, val, B70); \t tcggenqemust8(val, addr, ctx->memidx); \t tcgtempfree(val); \t tcgtempfree(addr); \t} \treturn; } switch (ctx->opcode & 0xf08f) { case 0x408e:\t\t/* ldc Rm,RnBANK */ \tCHECKPRIVILEGED \ttcggenmovi32(ALTREG(B64), REG(B118)); \treturn; case 0x4087:\t\t/* ldc.l @Rm+,RnBANK */ \tCHECKPRIVILEGED \ttcggenqemuld32s(ALTREG(B64), REG(B118), ctx->memidx); \ttcggenaddii32(REG(B118), REG(B118), 4); \treturn; case 0x0082:\t\t/* stc RmBANK,Rn */ \tCHECKPRIVILEGED \ttcggenmovi32(REG(B118), ALTREG(B64)); \treturn; case 0x4083:\t\t/* stc.l RmBANK,@-Rn */ \tCHECKPRIVILEGED \t{ \t TCGv addr = tcgtempnew(); \t tcggensubii32(addr, REG(B118), 4); \t tcggenqemust32(ALTREG(B64), addr, ctx->memidx); \t tcggenmovi32(REG(B118), addr); \t tcgtempfree(addr); \t} \treturn; } switch (ctx->opcode & 0xf0ff) { case 0x0023:\t\t/* braf Rn */ \tCHECKNOTDELAYSLOT \ttcggenaddii32(cpudelayedpc, REG(B118), ctx->pc + 4); \tctx->flags |= DELAYSLOT; \tctx->delayedpc = (uint32t) - 1; \treturn; case 0x0003:\t\t/* bsrf Rn */ \tCHECKNOTDELAYSLOT \ttcggenmovii32(cpupr, ctx->pc + 4); \ttcggenaddi32(cpudelayedpc, REG(B118), cpupr); \tctx->flags |= DELAYSLOT; \tctx->delayedpc = (uint32t) - 1; \treturn; case 0x4015:\t\t/* cmp/pl Rn */ \tgencmpimm(TCGCONDGT, REG(B118), 0); \treturn; case 0x4011:\t\t/* cmp/pz Rn */ \tgencmpimm(TCGCONDGE, REG(B118), 0); \treturn; case 0x4010:\t\t/* dt Rn */ \ttcggensubii32(REG(B118), REG(B118), 1); \tgencmpimm(TCGCONDEQ, REG(B118), 0); \treturn; case 0x402b:\t\t/* jmp @Rn */ \tCHECKNOTDELAYSLOT \ttcggenmovi32(cpudelayedpc, REG(B118)); \tctx->flags |= DELAYSLOT; \tctx->delayedpc = (uint32t) - 1; \treturn; case 0x400b:\t\t/* jsr @Rn */ \tCHECKNOTDELAYSLOT \ttcggenmovii32(cpupr, ctx->pc + 4); \ttcggenmovi32(cpudelayedpc, REG(B118)); \tctx->flags |= DELAYSLOT; \tctx->delayedpc = (uint32t) - 1; \treturn; case 0x400e:\t\t/* ldc Rm,SR */ \tCHECKPRIVILEGED \ttcggenandii32(cpusr, REG(B118), 0x700083f3); \tctx->bstate = BSSTOP; \treturn; case 0x4007:\t\t/* ldc.l @Rm+,SR */ \tCHECKPRIVILEGED \t{ \t TCGv val = tcgtempnew(); \t tcggenqemuld32s(val, REG(B118), ctx->memidx); \t tcggenandii32(cpusr, val, 0x700083f3); \t tcgtempfree(val); \t tcggenaddii32(REG(B118), REG(B118), 4); \t ctx->bstate = BSSTOP; \t} \treturn; case 0x0002:\t\t/* stc SR,Rn */ \tCHECKPRIVILEGED \ttcggenmovi32(REG(B118), cpusr); \treturn; case 0x4003:\t\t/* stc SR,@-Rn */ \tCHECKPRIVILEGED \t{ \t TCGv addr = tcgtempnew(); \t tcggensubii32(addr, REG(B118), 4); \t tcggenqemust32(cpusr, addr, ctx->memidx); \t tcggenmovi32(REG(B118), addr); \t tcgtempfree(addr); \t} \treturn; #define LD(reg,ldnum,ldpnum,prechk)\t\t\\ case ldnum:\t\t\t\t\t\t\t\\ prechk \t\t\t\t\t\t\t\\ tcggenmovi32 (cpu##reg, REG(B118));\t\t\t\\ return;\t\t\t\t\t\t\t\\ case ldpnum:\t\t\t\t\t\t\t\\ prechk \t\t\t\t\t\t\t\\ tcggenqemuld32s (cpu##reg, REG(B118), ctx->memidx);\t\\ tcggenaddii32(REG(B118), REG(B118), 4);\t\t\\ return; #define ST(reg,stnum,stpnum,prechk)\t\t\\ case stnum:\t\t\t\t\t\t\t\\ prechk \t\t\t\t\t\t\t\\ tcggenmovi32 (REG(B118), cpu##reg);\t\t\t\\ return;\t\t\t\t\t\t\t\\ case stpnum:\t\t\t\t\t\t\t\\ prechk \t\t\t\t\t\t\t\\ {\t\t\t\t\t\t\t\t\\ \tTCGv addr = tcgtempnew();\t\t\t\t\\ \ttcggensubii32(addr, REG(B118), 4);\t\t\t\\ \ttcggenqemust32 (cpu##reg, addr, ctx->memidx);\t\\ \ttcggenmovi32(REG(B118), addr);\t\t\t\\ \ttcgtempfree(addr);\t\t\t\t\t\\ }\t\t\t\t\t\t\t\t\\ return; #define LDST(reg,ldnum,ldpnum,stnum,stpnum,prechk)\t\t\\ \tLD(reg,ldnum,ldpnum,prechk)\t\t\t\t\\ \tST(reg,stnum,stpnum,prechk) \tLDST(gbr, 0x401e, 0x4017, 0x0012, 0x4013, {}) \tLDST(vbr, 0x402e, 0x4027, 0x0022, 0x4023, CHECKPRIVILEGED) \tLDST(ssr, 0x403e, 0x4037, 0x0032, 0x4033, CHECKPRIVILEGED) \tLDST(spc, 0x404e, 0x4047, 0x0042, 0x4043, CHECKPRIVILEGED) \tST(sgr, 0x003a, 0x4032, CHECKPRIVILEGED) \tLD(sgr, 0x403a, 0x4036, CHECKPRIVILEGED if (!(ctx->features & SHFEATURESH4A)) break;) \tLDST(dbr, 0x40fa, 0x40f6, 0x00fa, 0x40f2, CHECKPRIVILEGED) \tLDST(mach, 0x400a, 0x4006, 0x000a, 0x4002, {}) \tLDST(macl, 0x401a, 0x4016, 0x001a, 0x4012, {}) \tLDST(pr, 0x402a, 0x4026, 0x002a, 0x4022, {}) \tLDST(fpul, 0x405a, 0x4056, 0x005a, 0x4052, {CHECKFPUENABLED}) case 0x406a:\t\t/* lds Rm,FPSCR */ \tCHECKFPUENABLED \tgenhelperldfpscr(REG(B118)); \tctx->bstate = BSSTOP; \treturn; case 0x4066:\t\t/* lds.l @Rm+,FPSCR */ \tCHECKFPUENABLED \t{ \t TCGv addr = tcgtempnew(); \t tcggenqemuld32s(addr, REG(B118), ctx->memidx); \t tcggenaddii32(REG(B118), REG(B118), 4); \t genhelperldfpscr(addr); \t tcgtempfree(addr); \t ctx->bstate = BSSTOP; \t} \treturn; case 0x006a:\t\t/* sts FPSCR,Rn */ \tCHECKFPUENABLED \ttcggenandii32(REG(B118), cpufpscr, 0x003fffff); \treturn; case 0x4062:\t\t/* sts FPSCR,@-Rn */ \tCHECKFPUENABLED \t{ \t TCGv addr, val; \t val = tcgtempnew(); \t tcggenandii32(val, cpufpscr, 0x003fffff); \t addr = tcgtempnew(); \t tcggensubii32(addr, REG(B118), 4); \t tcggenqemust32(val, addr, ctx->memidx); \t tcggenmovi32(REG(B118), addr); \t tcgtempfree(addr); \t tcgtempfree(val); \t} \treturn; case 0x00c3:\t\t/* movca.l R0,@Rm */ { TCGv val = tcgtempnew(); tcggenqemuld32u(val, REG(B118), ctx->memidx); genhelpermovcal (REG(B118), val); tcggenqemust32(REG(0), REG(B118), ctx->memidx); } ctx->hasmovcal = 1; \treturn; case 0x40a9: \t/* MOVUA.L @Rm,R0 (Rm) -> R0 \t Load non-boundary-aligned data */ \ttcggenqemuld32u(REG(0), REG(B118), ctx->memidx); \treturn; case 0x40e9: \t/* MOVUA.L @Rm+,R0 (Rm) -> R0, Rm + 4 -> Rm \t Load non-boundary-aligned data */ \ttcggenqemuld32u(REG(0), REG(B118), ctx->memidx); \ttcggenaddii32(REG(B118), REG(B118), 4); \treturn; case 0x0029:\t\t/* movt Rn */ \ttcggenandii32(REG(B118), cpusr, SRT); \treturn; case 0x0073: /* MOVCO.L \t LDST -> T If (T == 1) R0 -> (Rn) 0 -> LDST */ if (ctx->features & SHFEATURESH4A) { \t int label = gennewlabel(); \t genclrt(); \t tcggenori32(cpusr, cpusr, cpuldst); \t tcggenbrcondii32(TCGCONDEQ, cpuldst, 0, label); \t tcggenqemust32(REG(0), REG(B118), ctx->memidx); \t gensetlabel(label); \t tcggenmovii32(cpuldst, 0); \t return; \t} else \t break; case 0x0063: /* MOVLI.L @Rm,R0 1 -> LDST (Rm) -> R0 When interrupt/exception occurred 0 -> LDST */ \tif (ctx->features & SHFEATURESH4A) { \t tcggenmovii32(cpuldst, 0); \t tcggenqemuld32s(REG(0), REG(B118), ctx->memidx); \t tcggenmovii32(cpuldst, 1); \t return; \t} else \t break; case 0x0093:\t\t/* ocbi @Rn */ \t{ \t genhelperocbi (REG(B118)); \t} \treturn; case 0x00a3:\t\t/* ocbp @Rn */ \t{ \t TCGv dummy = tcgtempnew(); \t tcggenqemuld32s(dummy, REG(B118), ctx->memidx); \t tcgtempfree(dummy); \t} \treturn; case 0x00b3:\t\t/* ocbwb @Rn */ \t{ \t TCGv dummy = tcgtempnew(); \t tcggenqemuld32s(dummy, REG(B118), ctx->memidx); \t tcgtempfree(dummy); \t} \treturn; case 0x0083:\t\t/* pref @Rn */ \treturn; case 0x00d3:\t\t/* prefi @Rn */ \tif (ctx->features & SHFEATURESH4A) \t return; \telse \t break; case 0x00e3:\t\t/* icbi @Rn */ \tif (ctx->features & SHFEATURESH4A) \t return; \telse \t break; case 0x00ab:\t\t/* synco */ \tif (ctx->features & SHFEATURESH4A) \t return; \telse \t break; case 0x4024:\t\t/* rotcl Rn */ \t{ \t TCGv tmp = tcgtempnew(); \t tcggenmovi32(tmp, cpusr); \t gencopybiti32(cpusr, 0, REG(B118), 31); \t tcggenshlii32(REG(B118), REG(B118), 1); \t gencopybiti32(REG(B118), 0, tmp, 0); \t tcgtempfree(tmp); \t} \treturn; case 0x4025:\t\t/* rotcr Rn */ \t{ \t TCGv tmp = tcgtempnew(); \t tcggenmovi32(tmp, cpusr); \t gencopybiti32(cpusr, 0, REG(B118), 0); \t tcggenshrii32(REG(B118), REG(B118), 1); \t gencopybiti32(REG(B118), 31, tmp, 0); \t tcgtempfree(tmp); \t} \treturn; case 0x4004:\t\t/* rotl Rn */ \tgencopybiti32(cpusr, 0, REG(B118), 31); \ttcggenshlii32(REG(B118), REG(B118), 1); \tgencopybiti32(REG(B118), 0, cpusr, 0); \treturn; case 0x4005:\t\t/* rotr Rn */ \tgencopybiti32(cpusr, 0, REG(B118), 0); \ttcggenshrii32(REG(B118), REG(B118), 1); \tgencopybiti32(REG(B118), 31, cpusr, 0); \treturn; case 0x4000:\t\t/* shll Rn */ case 0x4020:\t\t/* shal Rn */ \tgencopybiti32(cpusr, 0, REG(B118), 31); \ttcggenshlii32(REG(B118), REG(B118), 1); \treturn; case 0x4021:\t\t/* shar Rn */ \tgencopybiti32(cpusr, 0, REG(B118), 0); \ttcggensarii32(REG(B118), REG(B118), 1); \treturn; case 0x4001:\t\t/* shlr Rn */ \tgencopybiti32(cpusr, 0, REG(B118), 0); \ttcggenshrii32(REG(B118), REG(B118), 1); \treturn; case 0x4008:\t\t/* shll2 Rn */ \ttcggenshlii32(REG(B118), REG(B118), 2); \treturn; case 0x4018:\t\t/* shll8 Rn */ \ttcggenshlii32(REG(B118), REG(B118), 8); \treturn; case 0x4028:\t\t/* shll16 Rn */ \ttcggenshlii32(REG(B118), REG(B118), 16); \treturn; case 0x4009:\t\t/* shlr2 Rn */ \ttcggenshrii32(REG(B118), REG(B118), 2); \treturn; case 0x4019:\t\t/* shlr8 Rn */ \ttcggenshrii32(REG(B118), REG(B118), 8); \treturn; case 0x4029:\t\t/* shlr16 Rn */ \ttcggenshrii32(REG(B118), REG(B118), 16); \treturn; case 0x401b:\t\t/* tas.b @Rn */ \t{ \t TCGv addr, val; \t addr = tcgtemplocalnew(); \t tcggenmovi32(addr, REG(B118)); \t val = tcgtemplocalnew(); \t tcggenqemuld8u(val, addr, ctx->memidx); \t gencmpimm(TCGCONDEQ, val, 0); \t tcggenorii32(val, val, 0x80); \t tcggenqemust8(val, addr, ctx->memidx); \t tcgtempfree(val); \t tcgtempfree(addr); \t} \treturn; case 0xf00d: /* fsts FPUL,FRn - FPSCR: Nothing */ \tCHECKFPUENABLED \ttcggenmovi32(cpufregs[FREG(B118)], cpufpul); \treturn; case 0xf01d: /* flds FRm,FPUL - FPSCR: Nothing */ \tCHECKFPUENABLED \ttcggenmovi32(cpufpul, cpufregs[FREG(B118)]); \treturn; case 0xf02d: /* float FPUL,FRn/DRn - FPSCR: R[PR,Enable.I]/W[Cause,Flag] */ \tCHECKFPUENABLED \tif (ctx->fpscr & FPSCRPR) { \t TCGvi64 fp; \t if (ctx->opcode & 0x0100) \t\tbreak; /* illegal instruction */ \t fp = tcgtempnewi64(); \t genhelperfloatDT(fp, cpufpul); \t genstorefpr64(fp, DREG(B118)); \t tcgtempfreei64(fp); \t} \telse { \t genhelperfloatFT(cpufregs[FREG(B118)], cpufpul); \t} \treturn; case 0xf03d: /* ftrc FRm/DRm,FPUL - FPSCR: R[PR,Enable.V]/W[Cause,Flag] */ \tCHECKFPUENABLED \tif (ctx->fpscr & FPSCRPR) { \t TCGvi64 fp; \t if (ctx->opcode & 0x0100) \t\tbreak; /* illegal instruction */ \t fp = tcgtempnewi64(); \t genloadfpr64(fp, DREG(B118)); \t genhelperftrcDT(cpufpul, fp); \t tcgtempfreei64(fp); \t} \telse { \t genhelperftrcFT(cpufpul, cpufregs[FREG(B118)]); \t} \treturn; case 0xf04d: /* fneg FRn/DRn - FPSCR: Nothing */ \tCHECKFPUENABLED \t{ \t genhelperfnegT(cpufregs[FREG(B118)], cpufregs[FREG(B118)]); \t} \treturn; case 0xf05d: /* fabs FRn/DRn */ \tCHECKFPUENABLED \tif (ctx->fpscr & FPSCRPR) { \t if (ctx->opcode & 0x0100) \t\tbreak; /* illegal instruction */ \t TCGvi64 fp = tcgtempnewi64(); \t genloadfpr64(fp, DREG(B118)); \t genhelperfabsDT(fp, fp); \t genstorefpr64(fp, DREG(B118)); \t tcgtempfreei64(fp); \t} else { \t genhelperfabsFT(cpufregs[FREG(B118)], cpufregs[FREG(B118)]); \t} \treturn; case 0xf06d: /* fsqrt FRn */ \tCHECKFPUENABLED \tif (ctx->fpscr & FPSCRPR) { \t if (ctx->opcode & 0x0100) \t\tbreak; /* illegal instruction */ \t TCGvi64 fp = tcgtempnewi64(); \t genloadfpr64(fp, DREG(B118)); \t genhelperfsqrtDT(fp, fp); \t genstorefpr64(fp, DREG(B118)); \t tcgtempfreei64(fp); \t} else { \t genhelperfsqrtFT(cpufregs[FREG(B118)], cpufregs[FREG(B118)]); \t} \treturn; case 0xf07d: /* fsrra FRn */ \tCHECKFPUENABLED \tbreak; case 0xf08d: /* fldi0 FRn - FPSCR: R[PR] */ \tCHECKFPUENABLED \tif (!(ctx->fpscr & FPSCRPR)) { \t tcggenmovii32(cpufregs[FREG(B118)], 0); \t} \treturn; case 0xf09d: /* fldi1 FRn - FPSCR: R[PR] */ \tCHECKFPUENABLED \tif (!(ctx->fpscr & FPSCRPR)) { \t tcggenmovii32(cpufregs[FREG(B118)], 0x3f800000); \t} \treturn; case 0xf0ad: /* fcnvsd FPUL,DRn */ \tCHECKFPUENABLED \t{ \t TCGvi64 fp = tcgtempnewi64(); \t genhelperfcnvsdFTDT(fp, cpufpul); \t genstorefpr64(fp, DREG(B118)); \t tcgtempfreei64(fp); \t} \treturn; case 0xf0bd: /* fcnvds DRn,FPUL */ \tCHECKFPUENABLED \t{ \t TCGvi64 fp = tcgtempnewi64(); \t genloadfpr64(fp, DREG(B118)); \t genhelperfcnvdsDTFT(cpufpul, fp); \t tcgtempfreei64(fp); \t} \treturn; } #if 0 fprintf(stderr, \"unknown instruction 0x%04x at pc 0x%08x\\n\", \t ctx->opcode, ctx->pc); fflush(stderr); #endif genhelperraiseillegalinstruction(); ctx->bstate = BSEXCP; } ", "target": 1}
{"func": "void wm8750setbclkin(void *opaque, int hz) { struct wm8750s *s = (struct wm8750s *) opaque; s->extadchz = hz; s->extdachz = hz; wm8750clkupdate(s, 1); } ", "target": 1}
{"func": "static void pmacdmawrite(BlockBackend *blk, int64t sectornum, int nbsectors, void (*cb)(void *opaque, int ret), void *opaque) { DBDMAio *io = opaque; MACIOIDEState *m = io->opaque; IDEState *s = idebusactiveif(&m->bus); dmaaddrt dmaaddr, dmalen; void *mem; int nsector, remainder; int extra = 0; qemuiovecdestroy(&io->iov); qemuiovecinit(&io->iov, io->len / MACIOPAGESIZE + 1); if (io->remainderlen > 0) { /* Return remainder of request */ int transfer = MIN(io->remainderlen, io->len); MACIODPRINTF(\"--- processing write remainder %x\\n\", transfer); cpuphysicalmemoryread(io->addr, &io->remainder + (0x200 - transfer), transfer); io->remainderlen -= transfer; io->len -= transfer; io->addr += transfer; s->iobufferindex += transfer; s->iobuffersize -= transfer; if (io->remainderlen != 0) { /* Still waiting for remainder */ return; } MACIODPRINTF(\"--> prepending bounce buffer with size 0x200\\n\"); /* Sector transfer complete - prepend to request */ qemuiovecadd(&io->iov, &io->remainder, 0x200); extra = 1; } if (s->drivekind == IDECD) { sectornum = (int64t)(s->lba << 2) + (s->iobufferindex >> 9); } else { sectornum = idegetsector(s) + (s->iobufferindex >> 9); } nsector = (io->len >> 9); remainder = io->len - (nsector << 9); MACIODPRINTF(\"--- DMA write transfer - addr: %\" HWADDRPRIx \" len: %x\\n\", io->addr, io->len); MACIODPRINTF(\"xxx remainder: %x\\n\", remainder); MACIODPRINTF(\"xxx sectornum: %\"PRIx64\" nsector: %x\\n\", sectornum, nsector); dmaaddr = io->addr; dmalen = io->len; mem = dmamemorymap(&addressspacememory, dmaaddr, &dmalen, DMADIRECTIONTODEVICE); if (!remainder) { MACIODPRINTF(\"--- DMA write aligned - addr: %\" HWADDRPRIx \" len: %x\\n\", io->addr, io->len); qemuiovecadd(&io->iov, mem, io->len); } else { /* Write up to last complete sector */ MACIODPRINTF(\"--- DMA write unaligned - addr: %\" HWADDRPRIx \" len: %x\\n\", io->addr, (nsector << 9)); qemuiovecadd(&io->iov, mem, (nsector << 9)); MACIODPRINTF(\"--- DMA write read - bounce addr: %p \" \"remainderlen: %x\\n\", &io->remainder, remainder); cpuphysicalmemoryread(io->addr + (nsector << 9), &io->remainder, remainder); io->remainderlen = 0x200 - remainder; MACIODPRINTF(\"xxx remainderlen: %x\\n\", io->remainderlen); } s->iobuffersize -= ((nsector + extra) << 9); s->iobufferindex += ((nsector + extra) << 9); io->len = 0; MACIODPRINTF(\"--- Block write transfer - sectornum: %\"PRIx64\" \" \"nsector: %x\\n\", sectornum, nsector + extra); m->aiocb = blkaiowritev(blk, sectornum, &io->iov, nsector + extra, cb, io); } ", "target": 1}
{"func": "static void bdrvdelete(BlockDriverState *bs) { assert(!bs->job); assert(bdrvopblockerisempty(bs)); assert(!bs->refcnt); assert(QLISTEMPTY(&bs->dirtybitmaps)); bdrvclose(bs); /* remove from list, if necessary */ bdrvmakeanon(bs); gfree(bs); } ", "target": 0}
{"func": "static void vtdiommureplay(IOMMUMemoryRegion *iommumr, IOMMUNotifier *n) { VTDAddressSpace *vtdas = containerof(iommumr, VTDAddressSpace, iommu); IntelIOMMUState *s = vtdas->iommustate; uint8t busn = pcibusnum(vtdas->bus); VTDContextEntry ce; /* * The replay can be triggered by either a invalidation or a newly * created entry. No matter what, we release existing mappings * (it means flushing caches for UNMAP-only registers). */ vtdaddressspaceunmap(vtdas, n); if (vtddevtocontextentry(s, busn, vtdas->devfn, &ce) == 0) { tracevtdreplaycevalid(busn, PCISLOT(vtdas->devfn), PCIFUNC(vtdas->devfn), VTDCONTEXTENTRYDID(ce.hi), ce.hi, ce.lo); vtdpagewalk(&ce, 0, ~0ULL, vtdreplayhook, (void *)n, false); } else { tracevtdreplayceinvalid(busn, PCISLOT(vtdas->devfn), PCIFUNC(vtdas->devfn)); } return; } ", "target": 0}
{"func": "static inline int sdwpaddr(SDState *sd, uint32t addr) { return sd->wpgroups[addr >> (HWBLOCKSHIFT + SECTORSHIFT + WPGROUPSHIFT)]; } ", "target": 0}
{"func": "static void consolehandleescape(QemuConsole *s) { int i; for (i=0; i<s->nbescparams; i++) { switch (s->escparams[i]) { case 0: /* reset all console attributes to default */ s->tattrib = s->tattribdefault; break; case 1: s->tattrib.bold = 1; break; case 4: s->tattrib.uline = 1; break; case 5: s->tattrib.blink = 1; break; case 7: s->tattrib.invers = 1; break; case 8: s->tattrib.unvisible = 1; break; case 22: s->tattrib.bold = 0; break; case 24: s->tattrib.uline = 0; break; case 25: s->tattrib.blink = 0; break; case 27: s->tattrib.invers = 0; break; case 28: s->tattrib.unvisible = 0; break; /* set foreground color */ case 30: s->tattrib.fgcol=COLORBLACK; break; case 31: s->tattrib.fgcol=COLORRED; break; case 32: s->tattrib.fgcol=COLORGREEN; break; case 33: s->tattrib.fgcol=COLORYELLOW; break; case 34: s->tattrib.fgcol=COLORBLUE; break; case 35: s->tattrib.fgcol=COLORMAGENTA; break; case 36: s->tattrib.fgcol=COLORCYAN; break; case 37: s->tattrib.fgcol=COLORWHITE; break; /* set background color */ case 40: s->tattrib.bgcol=COLORBLACK; break; case 41: s->tattrib.bgcol=COLORRED; break; case 42: s->tattrib.bgcol=COLORGREEN; break; case 43: s->tattrib.bgcol=COLORYELLOW; break; case 44: s->tattrib.bgcol=COLORBLUE; break; case 45: s->tattrib.bgcol=COLORMAGENTA; break; case 46: s->tattrib.bgcol=COLORCYAN; break; case 47: s->tattrib.bgcol=COLORWHITE; break; } } } ", "target": 0}
{"func": "static void writevecelement(DisasContext *s, TCGvi64 tcgsrc, int destidx, int element, TCGMemOp memop) { int vectoff = vecregoffset(destidx, element, memop & MOSIZE); switch (memop) { case MO8: tcggenst8i64(tcgsrc, cpuenv, vectoff); break; case MO16: tcggenst16i64(tcgsrc, cpuenv, vectoff); break; case MO32: tcggenst32i64(tcgsrc, cpuenv, vectoff); break; case MO64: tcggensti64(tcgsrc, cpuenv, vectoff); break; default: gassertnotreached(); } } ", "target": 0}
{"func": "static alwaysinline void genexth(void (*tcggenexti64)(TCGv t0, TCGv t1), int ra, int rb, int rc, int islit, uint8t lit) { if (unlikely(rc == 31)) return; if (ra != 31) { if (islit) { if (lit != 0) tcggenshlii64(cpuir[rc], cpuir[ra], 64 - ((lit & 7) * 8)); else tcggenmovi64(cpuir[rc], cpuir[ra]); } else { TCGv tmp1, tmp2; tmp1 = tcgtempnew(TCGTYPEI64); tcggenandii64(tmp1, cpuir[rb], 7); tcggenshlii64(tmp1, tmp1, 3); tmp2 = tcgconsti64(64); tcggensubi64(tmp1, tmp2, tmp1); tcgtempfree(tmp2); tcggenshli64(cpuir[rc], cpuir[ra], tmp1); tcgtempfree(tmp1); } if (tcggenexti64) tcggenexti64(cpuir[rc], cpuir[rc]); } else tcggenmovii64(cpuir[rc], 0); } ", "target": 0}
{"func": "void ffh264initdequanttables(H264Context *h) { int i, x; initdequant4coefftable(h); if (h->pps.transform8x8mode) initdequant8coefftable(h); if (h->sps.transformbypass) { for (i = 0; i < 6; i++) for (x = 0; x < 16; x++) h->dequant4coeff[i][0][x] = 1 << 6; if (h->pps.transform8x8mode) for (i = 0; i < 6; i++) for (x = 0; x < 64; x++) h->dequant8coeff[i][0][x] = 1 << 6; } } ", "target": 0}
{"func": "static avcold int g722encodeinit(AVCodecContext * avctx) { G722Context *c = avctx->privdata; int ret; if (avctx->channels != 1) { avlog(avctx, AVLOGERROR, \"Only mono tracks are allowed.\\n\"); return AVERRORINVALIDDATA; } c->band[0].scalefactor = 8; c->band[1].scalefactor = 2; c->prevsamplespos = 22; if (avctx->trellis) { int frontier = 1 << avctx->trellis; int maxpaths = frontier * FREEZEINTERVAL; int i; for (i = 0; i < 2; i++) { c->paths[i] = avmallocz(maxpaths * sizeof(**c->paths)); c->nodebuf[i] = avmallocz(2 * frontier * sizeof(**c->nodebuf)); c->nodepbuf[i] = avmallocz(2 * frontier * sizeof(**c->nodepbuf)); if (!c->paths[i] || !c->nodebuf[i] || !c->nodepbuf[i]) { ret = AVERROR(ENOMEM); goto error; } } } if (avctx->framesize) { /* validate frame size */ if (avctx->framesize & 1 || avctx->framesize > MAXFRAMESIZE) { int newframesize; if (avctx->framesize == 1) newframesize = 2; else if (avctx->framesize > MAXFRAMESIZE) newframesize = MAXFRAMESIZE; else newframesize = avctx->framesize - 1; avlog(avctx, AVLOGWARNING, \"Requested frame size is not \" \"allowed. Using %d instead of %d\\n\", newframesize, avctx->framesize); avctx->framesize = newframesize; } } else { /* This is arbitrary. We use 320 because it's 20ms @ 16kHz, which is a common packet size for VoIP applications */ avctx->framesize = 320; } avctx->delay = 22; if (avctx->trellis) { /* validate trellis */ if (avctx->trellis < MINTRELLIS || avctx->trellis > MAXTRELLIS) { int newtrellis = avclip(avctx->trellis, MINTRELLIS, MAXTRELLIS); avlog(avctx, AVLOGWARNING, \"Requested trellis value is not \" \"allowed. Using %d instead of %d\\n\", newtrellis, avctx->trellis); avctx->trellis = newtrellis; } } return 0; error: g722encodeclose(avctx); return ret; } ", "target": 0}
{"func": "static uint64t lsimmioread(void *opaque, targetphysaddrt addr, unsigned size) { LSIState *s = opaque; return lsiregreadb(s, addr & 0xff); } ", "target": 0}
{"func": "static int cryptodevbuiltincreateciphersession( CryptoDevBackendBuiltin *builtin, CryptoDevBackendSymSessionInfo *sessinfo, Error **errp) { int algo; int mode; QCryptoCipher *cipher; int index; CryptoDevBackendBuiltinSession *sess; if (sessinfo->optype != VIRTIOCRYPTOSYMOPCIPHER) { errorsetg(errp, \"Unsupported optype :%u\", sessinfo->optype); return -1; } index = cryptodevbuiltingetunusedsessionindex(builtin); if (index < 0) { errorsetg(errp, \"Total number of sessions created exceeds %u\", MAXNUMSESSIONS); return -1; } switch (sessinfo->cipheralg) { case VIRTIOCRYPTOCIPHERAESECB: algo = cryptodevbuiltingetaesalgo(sessinfo->keylen, errp); if (algo < 0) { return -1; } mode = QCRYPTOCIPHERMODEECB; break; case VIRTIOCRYPTOCIPHERAESCBC: algo = cryptodevbuiltingetaesalgo(sessinfo->keylen, errp); if (algo < 0) { return -1; } mode = QCRYPTOCIPHERMODECBC; break; case VIRTIOCRYPTOCIPHERAESCTR: algo = cryptodevbuiltingetaesalgo(sessinfo->keylen, errp); if (algo < 0) { return -1; } mode = QCRYPTOCIPHERMODECTR; break; case VIRTIOCRYPTOCIPHERDESECB: algo = QCRYPTOCIPHERALGDESRFB; mode = QCRYPTOCIPHERMODEECB; break; default: errorsetg(errp, \"Unsupported cipher alg :%u\", sessinfo->cipheralg); return -1; } cipher = qcryptociphernew(algo, mode, sessinfo->cipherkey, sessinfo->keylen, errp); if (!cipher) { return -1; } sess = gnew0(CryptoDevBackendBuiltinSession, 1); sess->cipher = cipher; sess->direction = sessinfo->direction; sess->type = sessinfo->optype; builtin->sessions[index] = sess; return index; } ", "target": 0}
{"func": "envlistfree(envlistt *envlist) { \tstruct envlistentry *entry; \tassert(envlist != NULL); \twhile (envlist->elentries.lhfirst != NULL) { \t\tentry = envlist->elentries.lhfirst; \t\tLISTREMOVE(entry, evlink); \t\tfree((char *)entry->evvar); \t\tfree(entry); \t} \tfree(envlist); } ", "target": 0}
{"func": "static void testhbaenable(void) { AHCIQState *ahci; ahci = ahciboot(); ahcipcienable(ahci); ahcihbaenable(ahci); ahcishutdown(ahci); } ", "target": 0}
{"func": "static int writevf(int argc, char **argv) { struct timeval t1, t2; int Cflag = 0, qflag = 0; int c, cnt; char *buf; int64t offset; /* Some compilers get confused and warn if this is not initialized. */ int total = 0; int nriov; int pattern = 0xcd; QEMUIOVector qiov; while ((c = getopt(argc, argv, \"CqP:\")) != EOF) { switch (c) { case 'C': Cflag = 1; break; case 'q': qflag = 1; break; case 'P': pattern = parsepattern(optarg); if (pattern < 0) { return 0; } break; default: return commandusage(&writevcmd); } } if (optind > argc - 2) { return commandusage(&writevcmd); } offset = cvtnum(argv[optind]); if (offset < 0) { printf(\"non-numeric length argument -- %s\\n\", argv[optind]); return 0; } optind++; if (offset & 0x1ff) { printf(\"offset %\" PRId64 \" is not sector aligned\\n\", offset); return 0; } nriov = argc - optind; buf = createiovec(&qiov, &argv[optind], nriov, pattern); if (buf == NULL) { return 0; } gettimeofday(&t1, NULL); cnt = doaiowritev(&qiov, offset, &total); gettimeofday(&t2, NULL); if (cnt < 0) { printf(\"writev failed: %s\\n\", strerror(-cnt)); goto out; } if (qflag) { goto out; } /* Finally, report back -- -C gives a parsable format */ t2 = tsub(t2, t1); printreport(\"wrote\", &t2, offset, qiov.size, total, cnt, Cflag); out: qemuiofree(buf); return 0; }", "target": 1}
{"func": "static void RENAME(chrRangeToJpeg)(int16t *dst, int width) { int i; for (i = 0; i < width; i++) { dst[i ] = (FFMIN(dst[i ],30775)*4663 - 9289992)>>12; //-264 dst[i+VOFW] = (FFMIN(dst[i+VOFW],30775)*4663 - 9289992)>>12; //-264 } } ", "target": 0}
{"func": "static int decodepce(AVCodecContext *avctx, MPEG4AudioConfig *m4ac, enum ChannelPosition newchepos[4][MAXELEMID], GetBitContext *gb) { int numfront, numside, numback, numlfe, numassocdata, numcc, samplingindex; int commentlen; skipbits(gb, 2); // objecttype samplingindex = getbits(gb, 4); if (m4ac->samplingindex != samplingindex) avlog(avctx, AVLOGWARNING, \"Sample rate index in program config element does not match the sample rate index configured by the container.\\n\"); numfront = getbits(gb, 4); numside = getbits(gb, 4); numback = getbits(gb, 4); numlfe = getbits(gb, 2); numassocdata = getbits(gb, 3); numcc = getbits(gb, 4); if (getbits1(gb)) skipbits(gb, 4); // monomixdowntag if (getbits1(gb)) skipbits(gb, 4); // stereomixdowntag if (getbits1(gb)) skipbits(gb, 3); // mixdowncoeffindex and pseudosurround decodechannelmap(newchepos[TYPECPE], newchepos[TYPESCE], AACCHANNELFRONT, gb, numfront); decodechannelmap(newchepos[TYPECPE], newchepos[TYPESCE], AACCHANNELSIDE, gb, numside ); decodechannelmap(newchepos[TYPECPE], newchepos[TYPESCE], AACCHANNELBACK, gb, numback ); decodechannelmap(NULL, newchepos[TYPELFE], AACCHANNELLFE, gb, numlfe ); skipbitslong(gb, 4 * numassocdata); decodechannelmap(newchepos[TYPECCE], newchepos[TYPECCE], AACCHANNELCC, gb, numcc ); aligngetbits(gb); /* comment field, first byte is length */ commentlen = getbits(gb, 8) * 8; if (getbitsleft(gb) < commentlen) { skipbitslong(gb, commentlen); return 0; ", "target": 1}
{"func": "static int wssnddecodeframe(AVCodecContext *avctx, void *data, int *gotframeptr, AVPacket *avpkt) { WSSndContext *s = avctx->privdata; const uint8t *buf = avpkt->data; int bufsize = avpkt->size; int insize, outsize, ret; int sample = 128; uint8t *samples; uint8t *samplesend; if (!bufsize) return 0; if (bufsize < 4) { avlog(avctx, AVLOGERROR, \"packet is too small\\n\"); return AVERROR(EINVAL); } outsize = AVRL16(&buf[0]); insize = AVRL16(&buf[2]); buf += 4; if (insize > bufsize) { avlog(avctx, AVLOGERROR, \"Frame data is larger than input buffer\\n\"); return -1; } /* get output buffer */ s->frame.nbsamples = outsize; if ((ret = avctx->getbuffer(avctx, &s->frame)) < 0) { avlog(avctx, AVLOGERROR, \"getbuffer() failed\\n\"); return ret; } samples = s->frame.data[0]; samplesend = samples + outsize; if (insize == outsize) { memcpy(samples, buf, outsize); *gotframeptr = 1; *(AVFrame *)data = s->frame; return bufsize; } while (samples < samplesend && buf - avpkt->data < bufsize) { int code, smp, size; uint8t count; code = *buf >> 6; count = *buf & 0x3F; buf++; /* make sure we don't write past the output buffer */ switch (code) { case 0: smp = 4; break; case 1: smp = 2; break; case 2: smp = (count & 0x20) ? 1 : count + 1; break; default: smp = count + 1; break; } if (samplesend - samples < smp) break; /* make sure we don't read past the input buffer */ size = ((code == 2 && (count & 0x20)) || code == 3) ? 0 : count + 1; if ((buf - avpkt->data) + size > bufsize) break; switch (code) { case 0: /* ADPCM 2-bit */ for (count++; count > 0; count--) { code = *buf++; sample += ( code & 0x3) - 2; sample = avclipuint8(sample); *samples++ = sample; sample += ((code >> 2) & 0x3) - 2; sample = avclipuint8(sample); *samples++ = sample; sample += ((code >> 4) & 0x3) - 2; sample = avclipuint8(sample); *samples++ = sample; sample += (code >> 6) - 2; sample = avclipuint8(sample); *samples++ = sample; } break; case 1: /* ADPCM 4-bit */ for (count++; count > 0; count--) { code = *buf++; sample += wsadpcm4bit[code & 0xF]; sample = avclipuint8(sample); *samples++ = sample; sample += wsadpcm4bit[code >> 4]; sample = avclipuint8(sample); *samples++ = sample; } break; case 2: /* no compression */ if (count & 0x20) { /* big delta */ int8t t; t = count; t <<= 3; sample += t >> 3; sample = avclipuint8(sample); *samples++ = sample; } else { /* copy */ memcpy(samples, buf, smp); samples += smp; buf += smp; sample = buf[-1]; } break; default: /* run */ memset(samples, sample, smp); samples += smp; } } s->frame.nbsamples = samples - s->frame.data[0]; *gotframeptr = 1; *(AVFrame *)data = s->frame; return bufsize; } ", "target": 1}
{"func": "static avalwaysinline void hyscale(SwsContext *c, int16t *dst, int dstWidth, const uint8t *srcin[4], int srcW, int xInc, const int16t *hLumFilter, const int16t *hLumFilterPos, int hLumFilterSize, uint8t *formatConvBuffer, uint32t *pal, int isAlpha) { void (*toYV12)(uint8t *, const uint8t *, int, uint32t *) = isAlpha ? c->alpToYV12 : c->lumToYV12; void (*convertRange)(int16t *, int) = isAlpha ? NULL : c->lumConvertRange; const uint8t *src = srcin[isAlpha ? 3 : 0]; if (toYV12) { toYV12(formatConvBuffer, src, srcW, pal); src= formatConvBuffer; } else if (c->readLumPlanar && !isAlpha) { c->readLumPlanar(formatConvBuffer, srcin, srcW); src = formatConvBuffer; } if (!c->hyscalefast) { c->hyScale(c, dst, dstWidth, src, hLumFilter, hLumFilterPos, hLumFilterSize); } else { // fast bilinear upscale / crap downscale c->hyscalefast(c, dst, dstWidth, src, srcW, xInc); } if (convertRange) convertRange(dst, dstWidth); } ", "target": 1}
{"func": "static avalwaysinline avflatten void h264loopfilterchromac(uint8t *pix, int xstride, int ystride, int alpha, int beta, int8t *tc0) { int i, d; for( i = 0; i < 4; i++ ) { const int tc = tc0[i]; if( tc <= 0 ) { pix += 2*ystride; continue; } for( d = 0; d < 2; d++ ) { const int p0 = pix[-1*xstride]; const int p1 = pix[-2*xstride]; const int q0 = pix[0]; const int q1 = pix[1*xstride]; if( FFABS( p0 - q0 ) < alpha && FFABS( p1 - p0 ) < beta && FFABS( q1 - q0 ) < beta ) { int delta = avclip( (((q0 - p0 ) << 2) + (p1 - q1) + 4) >> 3, -tc, tc ); pix[-xstride] = avclipuint8( p0 + delta ); /* p0' */ pix[0] = avclipuint8( q0 - delta ); /* q0' */ } pix += ystride; } } } ", "target": 0}
{"func": "int ffmpeg4decodepictureheader(MpegEncContext * s, GetBitContext *gb) { int startcode, v; /* search next start code */ aligngetbits(gb); startcode = 0xff; for(;;) { v = getbits(gb, 8); startcode = ((startcode << 8) | v) & 0xffffffff; if(getbitscount(gb) >= gb->size*8){ if(gb->size==1 && s->divxversion){ printf(\"frame skip %d\\n\", gb->size); return FRAMESKIPED; //divx bug }else return -1; //end of stream } if((startcode&0xFFFFFF00) != 0x100) continue; //no startcode if(s->avctx->debug&FFDEBUGSTARTCODE){ printf(\"startcode: %3X \", startcode); if (startcode<=0x11F) printf(\"Video Object Start\"); else if(startcode<=0x12F) printf(\"Video Object Layer Start\"); else if(startcode<=0x13F) printf(\"Reserved\"); else if(startcode<=0x15F) printf(\"FGS bp start\"); else if(startcode<=0x1AF) printf(\"Reserved\"); else if(startcode==0x1B0) printf(\"Visual Object Seq Start\"); else if(startcode==0x1B1) printf(\"Visual Object Seq End\"); else if(startcode==0x1B2) printf(\"User Data\"); else if(startcode==0x1B3) printf(\"Group of VOP start\"); else if(startcode==0x1B4) printf(\"Video Session Error\"); else if(startcode==0x1B5) printf(\"Visual Object Start\"); else if(startcode==0x1B6) printf(\"Video Object Plane start\"); else if(startcode==0x1B7) printf(\"slice start\"); else if(startcode==0x1B8) printf(\"extension start\"); else if(startcode==0x1B9) printf(\"fgs start\"); else if(startcode==0x1BA) printf(\"FBA Object start\"); else if(startcode==0x1BB) printf(\"FBA Object Plane start\"); else if(startcode==0x1BC) printf(\"Mesh Object start\"); else if(startcode==0x1BD) printf(\"Mesh Object Plane start\"); else if(startcode==0x1BE) printf(\"Still Textutre Object start\"); else if(startcode==0x1BF) printf(\"Textutre Spatial Layer start\"); else if(startcode==0x1C0) printf(\"Textutre SNR Layer start\"); else if(startcode==0x1C1) printf(\"Textutre Tile start\"); else if(startcode==0x1C2) printf(\"Textutre Shape Layer start\"); else if(startcode==0x1C3) printf(\"stuffing start\"); else if(startcode<=0x1C5) printf(\"reserved\"); else if(startcode<=0x1FF) printf(\"System start\"); printf(\" at %d\\n\", getbitscount(gb)); } switch(startcode){ case 0x120: decodevolheader(s, gb); break; case USERDATASTARTCODE: decodeuserdata(s, gb); break; case GOPSTARTCODE: mpeg4decodegopheader(s, gb); break; case VOPSTARTCODE: return decodevopheader(s, gb); default: break; } aligngetbits(gb); startcode = 0xff; } } ", "target": 0}
{"func": "static void mpegvideoextractheaders(AVCodecParserContext *s, AVCodecContext *avctx, const uint8t *buf, int bufsize) { ParseContext1 *pc = s->privdata; const uint8t *bufend; const uint8t *bufstart= buf; uint32t startcode; int framerateindex, exttype, bytesleft; int framerateextn, framerateextd; int picturestructure, topfieldfirst, repeatfirstfield, progressiveframe; int horizsizeext, vertsizeext, bitrateext; //FIXME replace the crap with getbits() s->repeatpict = 0; bufend = buf + bufsize; while (buf < bufend) { startcode= -1; buf= fffindstartcode(buf, bufend, &startcode); bytesleft = bufend - buf; switch(startcode) { case PICTURESTARTCODE: fffetchtimestamp(s, buf-bufstart-4, 1); if (bytesleft >= 2) { s->picttype = (buf[1] >> 3) & 7; } break; case SEQSTARTCODE: if (bytesleft >= 7) { pc->width = (buf[0] << 4) | (buf[1] >> 4); pc->height = ((buf[1] & 0x0f) << 8) | buf[2]; avcodecsetdimensions(avctx, pc->width, pc->height); framerateindex = buf[3] & 0xf; pc->framerate.den = avctx->timebase.den = ffframeratetab[framerateindex].num; pc->framerate.num = avctx->timebase.num = ffframeratetab[framerateindex].den; avctx->bitrate = ((buf[4]<<10) | (buf[5]<<2) | (buf[6]>>6))*400; avctx->codecid = CODECIDMPEG1VIDEO; avctx->subid = 1; } break; case EXTSTARTCODE: if (bytesleft >= 1) { exttype = (buf[0] >> 4); switch(exttype) { case 0x1: /* sequence extension */ if (bytesleft >= 6) { horizsizeext = ((buf[1] & 1) << 1) | (buf[2] >> 7); vertsizeext = (buf[2] >> 5) & 3; bitrateext = ((buf[2] & 0x1F)<<7) | (buf[3]>>1); framerateextn = (buf[5] >> 5) & 3; framerateextd = (buf[5] & 0x1f); pc->progressivesequence = buf[1] & (1 << 3); avctx->hasbframes= !(buf[5] >> 7); pc->width |=(horizsizeext << 12); pc->height |=( vertsizeext << 12); avctx->bitrate += (bitrateext << 18) * 400; avcodecsetdimensions(avctx, pc->width, pc->height); avctx->timebase.den = pc->framerate.den * (framerateextn + 1) * 2; avctx->timebase.num = pc->framerate.num * (framerateextd + 1); avctx->codecid = CODECIDMPEG2VIDEO; avctx->subid = 2; /* forces MPEG2 */ } break; case 0x8: /* picture coding extension */ if (bytesleft >= 5) { picturestructure = buf[2]&3; topfieldfirst = buf[3] & (1 << 7); repeatfirstfield = buf[3] & (1 << 1); progressiveframe = buf[4] & (1 << 7); /* check if we must repeat the frame */ s->repeatpict = 1; if (repeatfirstfield) { if (pc->progressivesequence) { if (topfieldfirst) s->repeatpict = 5; else s->repeatpict = 3; } else if (progressiveframe) { s->repeatpict = 2; } } } break; } } break; case -1: goto theend; default: /* we stop parsing when we encounter a slice. It ensures that this function takes a negligible amount of time */ if (startcode >= SLICEMINSTARTCODE && startcode <= SLICEMAXSTARTCODE) goto theend; break; } } theend: ; } ", "target": 0}
{"func": "static int setchromaformat(AVCodecContext *avctx) { int numformats = sizeof(schropixelformatmap) / sizeof(schropixelformatmap[0]); int idx; SchroEncoderParams *pschroparams = avctx->privdata; for (idx = 0; idx < numformats; ++idx) { if (schropixelformatmap[idx].ffpixfmt == avctx->pixfmt) { pschroparams->format->chromaformat = schropixelformatmap[idx].schropixfmt; return 0; } } avlog(avctx, AVLOGERROR, \"This codec currently only supports planar YUV 4:2:0, 4:2:2\" \" and 4:4:4 formats.\\n\"); return -1; } ", "target": 1}
{"func": "IEEEARITH2(sqrtt) IEEEARITH2(cvtst) IEEEARITH2(cvtts) static void gencvttq(DisasContext *ctx, int rb, int rc, int fn11) { TCGv vb, vc; /* No need to set flushzero, since we have an integer output. */ vb = genieeeinput(ctx, rb, fn11, 0); vc = destfpr(ctx, rc); /* Almost all integer conversions use cropped rounding, and most also do not have integer overflow enabled. Special case that. */ switch (fn11) { case QUALRMC: genhelpercvttqc(vc, cpuenv, vb); break; case QUALV | QUALRMC: case QUALS | QUALV | QUALRMC: case QUALS | QUALV | QUALI | QUALRMC: genhelpercvttqsvic(vc, cpuenv, vb); break; default: genqualroundmode(ctx, fn11); genhelpercvttq(vc, cpuenv, vb); break; } genfpexcraise(rc, fn11); } ", "target": 1}
{"func": "static int virtioserialdeviceexit(DeviceState *dev) { VirtIOSerial *vser = VIRTIOSERIAL(dev); VirtIODevice *vdev = VIRTIODEVICE(dev); unregistersavevm(dev, \"virtio-console\", vser); gfree(vser->ivqs); gfree(vser->ovqs); gfree(vser->portsmap); if (vser->postload) { gfree(vser->postload->connected); timerdel(vser->postload->timer); timerfree(vser->postload->timer); gfree(vser->postload); } virtiocleanup(vdev); return 0; } ", "target": 1}
{"func": "int kvmarchinitvcpu(CPUState *cenv) { int ret = 0; struct kvmsregs sregs; sregs.pvr = cenv->spr[SPRPVR]; ret = kvmvcpuioctl(cenv, KVMSETSREGS, &sregs); idletimer = qemunewtimerns(vmclock, kvmkickenv, cenv); return ret; } ", "target": 1}
{"func": "static void virtioqueuenotifyvq(VirtQueue *vq) { if (vq->vring.desc && vq->handleoutput) { VirtIODevice *vdev = vq->vdev; tracevirtioqueuenotify(vdev, vq - vdev->vq, vq); vq->handleoutput(vdev, vq);", "target": 1}
{"func": "static avcold int mpdecodeinit(AVCodecContext *avctx) { MotionPixelsContext *mp = avctx->privdata; int w4 = (avctx->width + 3) & ~3; int h4 = (avctx->height + 3) & ~3; if(avctx->extradatasize < 2){ avlog(avctx, AVLOGERROR, \"extradata too small\\n\"); return AVERRORINVALIDDATA; } motionpixelstableinit(); mp->avctx = avctx; ffdsputilinit(&mp->dsp, avctx); mp->changesmap = avmallocz(avctx->width * h4); mp->offsetbitslen = avlog2(avctx->width * avctx->height) + 1; mp->vpt = avmallocz(avctx->height * sizeof(YuvPixel)); mp->hpt = avmallocz(h4 * w4 / 16 * sizeof(YuvPixel)); avctx->pixfmt = AVPIXFMTRGB555; avcodecgetframedefaults(&mp->frame); return 0; }", "target": 1}
{"func": "static void putpayloadheader( AVFormatContext *s, ASFStream *stream, int presentationtime, int mobjsize, int mobjoffset, int payloadlen ) { ASFContext *asf = s->privdata; ByteIOContext *pb = &asf->pb; int val; val = stream->num; if (s->streams[val - 1]->codec.codedframe->keyframe) val |= ASFPLFLAGKEYFRAME; putbyte(pb, val); putbyte(pb, stream->seq); //Media object number putle32(pb, mobjoffset); //Offset Into Media Object // Replicated Data shall be at least 8 bytes long. // The first 4 bytes of data shall contain the // Size of the Media Object that the payload belongs to. // The next 4 bytes of data shall contain the // Presentation Time for the media object that the payload belongs to. putbyte(pb, ASFPAYLOADREPLICATEDDATALENGTH); putle32(pb, mobjsize); //Replicated Data - Media Object Size putle32(pb, presentationtime);//Replicated Data - Presentation Time if (asf->multipayloadspresent){ putle16(pb, payloadlen); //payload length } } ", "target": 0}
{"func": "static int pcmencodeframe(AVCodecContext *avctx, \t\t\t unsigned char *frame, int bufsize, void *data) { int n, samplesize, v; short *samples; unsigned char *dst; switch(avctx->codec->id) { case CODECIDPCMS16LE: case CODECIDPCMS16BE: case CODECIDPCMU16LE: case CODECIDPCMU16BE: samplesize = 2; break; default: samplesize = 1; break; } n = bufsize / samplesize; samples = data; dst = frame; switch(avctx->codec->id) { case CODECIDPCMS16LE: for(;n>0;n--) { v = *samples++; dst[0] = v & 0xff; dst[1] = v >> 8; dst += 2; } break; case CODECIDPCMS16BE: for(;n>0;n--) { v = *samples++; dst[0] = v >> 8; dst[1] = v; dst += 2; } break; case CODECIDPCMU16LE: for(;n>0;n--) { v = *samples++; v += 0x8000; dst[0] = v & 0xff; dst[1] = v >> 8; dst += 2; } break; case CODECIDPCMU16BE: for(;n>0;n--) { v = *samples++; v += 0x8000; dst[0] = v >> 8; dst[1] = v; dst += 2; } break; case CODECIDPCMS8: for(;n>0;n--) { v = *samples++; dst[0] = (v + 128) >> 8; dst++; } break; case CODECIDPCMU8: for(;n>0;n--) { v = *samples++; dst[0] = ((v + 128) >> 8) + 128; dst++; } break; case CODECIDPCMALAW: for(;n>0;n--) { v = *samples++; dst[0] = lineartoalaw[(v + 32768) >> 2]; dst++; } break; case CODECIDPCMMULAW: for(;n>0;n--) { v = *samples++; dst[0] = lineartoulaw[(v + 32768) >> 2]; dst++; } break; default: return -1; } avctx->keyframe = 1; //avctx->framesize = (dst - frame) / (samplesize * avctx->channels); return dst - frame; } ", "target": 1}
{"func": "static inline void hScalealtivecreal(int16t *dst, int dstW, uint8t *src, int srcW, int xInc, int16t *filter, int16t *filterPos, int filterSize) { register int i; int attribute ((aligned (16))) tempo[4]; if (filterSize % 4) { for(i=0; i<dstW; i++) { register int j; register int srcPos = filterPos[i]; register int val = 0; for(j=0; j<filterSize; j++) { \tval += ((int)src[srcPos + j])*filter[filterSize*i + j]; } dst[i] = avclip(val>>7, 0, (1<<15)-1); } } else switch (filterSize) { case 4: { for(i=0; i<dstW; i++) { \tregister int srcPos = filterPos[i]; \tvector unsigned char srcv0 = vecld(srcPos, src); \tvector unsigned char srcv1, srcvF; \tvector signed short srcv, filterv; \tvector signed int valvEven, vals; \tif ((((int)src + srcPos)% 16) > 12) { \t srcv1 = vecld(srcPos + 16, src); \t} \tsrcvF = vecperm(srcv0, srcv1, veclvsl(srcPos, src)); \tsrcv = // vecunpackh sign-extends... \t (vector signed short)(vecmergeh((vector unsigned char)vzero, srcvF)); \t// now put our elements in the even slots \tsrcv = vecmergeh(srcv, (vector signed short)vzero); \tfilterv = vecld(i << 3, filter); // the 3 above is 2 (filterSize == 4) + 1 (sizeof(short) == 2) // the neat trick : we only care for half the elements, // high or low depending on (i<<3)%16 (it's 0 or 8 here), // and we're going to use vecmule, so we chose // carefully how to \"unpack\" the elements into the even slots \tif ((i << 3) % 16) \t filterv = vecmergel(filterv,(vector signed short)vzero); \telse \t filterv = vecmergeh(filterv,(vector signed short)vzero); \tvalvEven = vecmule(srcv, filterv); \tvals = vecsums(valvEven, vzero); \tvecst(vals, 0, tempo); \tdst[i] = avclip(tempo[3]>>7, 0, (1<<15)-1); } } break; case 8: { for(i=0; i<dstW; i++) { \tregister int srcPos = filterPos[i]; \tvector unsigned char srcv0 = vecld(srcPos, src); \tvector unsigned char srcv1, srcvF; \tvector signed short srcv, filterv; \tvector signed int valv, vals; \tif ((((int)src + srcPos)% 16) > 8) { \t srcv1 = vecld(srcPos + 16, src); \t} \tsrcvF = vecperm(srcv0, srcv1, veclvsl(srcPos, src)); \tsrcv = // vecunpackh sign-extends... \t (vector signed short)(vecmergeh((vector unsigned char)vzero, srcvF)); \tfilterv = vecld(i << 4, filter); // the 4 above is 3 (filterSize == 8) + 1 (sizeof(short) == 2) \tvalv = vecmsums(srcv, filterv, (vector signed int)vzero); \tvals = vecsums(valv, vzero); \tvecst(vals, 0, tempo); \tdst[i] = avclip(tempo[3]>>7, 0, (1<<15)-1); } } break; case 16: { for(i=0; i<dstW; i++) { \tregister int srcPos = filterPos[i]; \tvector unsigned char srcv0 = vecld(srcPos, src); \tvector unsigned char srcv1 = vecld(srcPos + 16, src); \tvector unsigned char srcvF = vecperm(srcv0, srcv1, veclvsl(srcPos, src)); \tvector signed short srcvA = // vecunpackh sign-extends... \t (vector signed short)(vecmergeh((vector unsigned char)vzero, srcvF)); \tvector signed short srcvB = // vecunpackh sign-extends... \t (vector signed short)(vecmergel((vector unsigned char)vzero, srcvF)); \tvector signed short filterv0 = vecld(i << 5, filter); \tvector signed short filterv1 = vecld((i << 5) + 16, filter); // the 5 above are 4 (filterSize == 16) + 1 (sizeof(short) == 2) \tvector signed int valacc = vecmsums(srcvA, filterv0, (vector signed int)vzero); \tvector signed int valv = vecmsums(srcvB, filterv1, valacc); \tvector signed int vals = vecsums(valv, vzero); \tvecst(vals, 0, tempo); \tdst[i] = avclip(tempo[3]>>7, 0, (1<<15)-1); } } break; default: { for(i=0; i<dstW; i++) { \tregister int j; \tregister int srcPos = filterPos[i]; vector signed int vals, valv = (vector signed int)vzero; \tvector signed short filterv0R = vecld(i * 2 * filterSize, filter); vector unsigned char permF = veclvsl((i * 2 * filterSize), filter); vector unsigned char srcv0 = vecld(srcPos, src); vector unsigned char permS = veclvsl(srcPos, src); for (j = 0 ; j < filterSize - 15; j += 16) { vector unsigned char srcv1 = vecld(srcPos + j + 16, src); vector unsigned char srcvF = vecperm(srcv0, srcv1, permS); vector signed short srcvA = // vecunpackh sign-extends... (vector signed short)(vecmergeh((vector unsigned char)vzero, srcvF)); vector signed short srcvB = // vecunpackh sign-extends... (vector signed short)(vecmergel((vector unsigned char)vzero, srcvF)); vector signed short filterv1R = vecld((i * 2 * filterSize) + (j * 2) + 16, filter); vector signed short filterv2R = vecld((i * 2 * filterSize) + (j * 2) + 32, filter); vector signed short filterv0 = vecperm(filterv0R, filterv1R, permF); vector signed short filterv1 = vecperm(filterv1R, filterv2R, permF); vector signed int valacc = vecmsums(srcvA, filterv0, valv); valv = vecmsums(srcvB, filterv1, valacc); filterv0R = filterv2R; srcv0 = srcv1; } if (j < (filterSize-7)) { // loading srcv0 is useless, it's already done above //vector unsigned char srcv0 = vecld(srcPos + j, src); vector unsigned char srcv1, srcvF; vector signed short srcv, filterv1R, filterv; if ((((int)src + srcPos)% 16) > 8) { srcv1 = vecld(srcPos + j + 16, src); } srcvF = vecperm(srcv0, srcv1, permS); srcv = // vecunpackh sign-extends... (vector signed short)(vecmergeh((vector unsigned char)vzero, srcvF)); // loading filterv0R is useless, it's already done above //vector signed short filterv0R = vecld((i * 2 * filterSize) + j, filter); filterv1R = vecld((i * 2 * filterSize) + (j * 2) + 16, filter); filterv = vecperm(filterv0R, filterv1R, permF); valv = vecmsums(srcv, filterv, valv); } vals = vecsums(valv, vzero); vecst(vals, 0, tempo); dst[i] = avclip(tempo[3]>>7, 0, (1<<15)-1); } } } } ", "target": 1}
{"func": "void ppcstorexer (CPUPPCState *env, uint32t value) { xerso = (value >> XERSO) & 0x01; xerov = (value >> XEROV) & 0x01; xerca = (value >> XERCA) & 0x01; xercmp = (value >> XERCMP) & 0xFF; xerbc = (value >> XERBC) & 0x3F; } ", "target": 1}
{"func": "static void propertygetenum(Object *obj, Visitor *v, void *opaque, const char *name, Error **errp) { EnumProperty *prop = opaque; int value; value = prop->get(obj, errp); visittypeenum(v, &value, prop->strings, NULL, name, errp); } ", "target": 1}
{"func": "static int pathhasprotocol(const char *path) { #ifdef WIN32 if (iswindowsdrive(path) || iswindowsdriveprefix(path)) { return 0; } #endif return strchr(path, ':') != NULL; } ", "target": 0}
{"func": "static int mchinit(PCIDevice *d) { int i; MCHPCIState *mch = MCHPCIDEVICE(d); /* setup pci memory regions */ memoryregioninitalias(&mch->pcihole, OBJECT(mch), \"pci-hole\", mch->pciaddressspace, mch->below4gmemsize, 0x100000000ULL - mch->below4gmemsize); memoryregionaddsubregion(mch->systemmemory, mch->below4gmemsize, &mch->pcihole); pcinitpci64hole(&mch->pciinfo, 0x100000000ULL + mch->above4gmemsize, mch->pcihole64size); memoryregioninitalias(&mch->pcihole64bit, OBJECT(mch), \"pci-hole64\", mch->pciaddressspace, mch->pciinfo.w64.begin, mch->pcihole64size); if (mch->pcihole64size) { memoryregionaddsubregion(mch->systemmemory, mch->pciinfo.w64.begin, &mch->pcihole64bit); } /* smram */ cpusmmregister(&mchsetsmm, mch); memoryregioninitalias(&mch->smramregion, OBJECT(mch), \"smram-region\", mch->pciaddressspace, 0xa0000, 0x20000); memoryregionaddsubregionoverlap(mch->systemmemory, 0xa0000, &mch->smramregion, 1); memoryregionsetenabled(&mch->smramregion, false); initpam(DEVICE(mch), mch->rammemory, mch->systemmemory, mch->pciaddressspace, &mch->pamregions[0], PAMBIOSBASE, PAMBIOSSIZE); for (i = 0; i < 12; ++i) { initpam(DEVICE(mch), mch->rammemory, mch->systemmemory, mch->pciaddressspace, &mch->pamregions[i+1], PAMEXPANBASE + i * PAMEXPANSIZE, PAMEXPANSIZE); } return 0; } ", "target": 0}
{"func": "static int h261findframeend(ParseContext *pc, AVCodecContext* avctx, const uint8t *buf, int bufsize){ int vopfound, i, j, bitsleft, lastbits; uint32t state; H261Context *h = avctx->privdata; if(h){ bitsleft = h->bitsleft; lastbits = h->lastbits; } else{ bitsleft = 0; lastbits = 0; } vopfound= pc->framestartfound; state= pc->state; if(bitsleft!=0 && !vopfound) state = state << (8-bitsleft) | lastbits; i=0; if(!vopfound){ for(i=0; i<bufsize; i++){ state= (state<<8) | buf[i]; for(j=0; j<8; j++){ if(( ( (state<<j) | (buf[i]>>(8-j)) )>>(32-20) == 0x10 )&&(((state >> (17-j)) & 0x4000) == 0x0)){ i++; vopfound=1; break; } } if(vopfound) break; } } if(vopfound){ for(; i<bufsize; i++){ if(avctx->flags & CODECFLAGTRUNCATED)//XXX ffplay workaround, someone a better solution? state= (state<<8) | buf[i]; for(j=0; j<8; j++){ if(( ( (state<<j) | (buf[i]>>(8-j)) )>>(32-20) == 0x10 )&&(((state >> (17-j)) & 0x4000) == 0x0)){ pc->framestartfound=0; pc->state=-1; return i-3; } } } } pc->framestartfound= vopfound; pc->state= state; return ENDNOTFOUND; } ", "target": 0}
{"func": "void addressspacewrite(AddressSpace *as, targetphysaddrt addr, const uint8t *buf, int len) { addressspacerw(as, addr, (uint8t *)buf, len, true); } ", "target": 0}
{"func": "static void audioruncapture (AudioState *s) { CaptureVoiceOut *cap; for (cap = s->caphead.lhfirst; cap; cap = cap->entries.lenext) { int live, rpos, captured; HWVoiceOut *hw = &cap->hw; SWVoiceOut *sw; captured = live = audiopcmhwgetliveout (hw); rpos = hw->rpos; while (live) { int left = hw->samples - rpos; int tocapture = audioMIN (live, left); stsamplet *src; struct capturecallback *cb; src = hw->mixbuf + rpos; hw->clip (cap->buf, src, tocapture); mixengclear (src, tocapture); for (cb = cap->cbhead.lhfirst; cb; cb = cb->entries.lenext) { cb->ops.capture (cb->opaque, cap->buf, tocapture << hw->info.shift); } rpos = (rpos + tocapture) % hw->samples; live -= tocapture; } hw->rpos = rpos; for (sw = hw->swhead.lhfirst; sw; sw = sw->entries.lenext) { if (!sw->active && sw->empty) { continue; } if (audiobug (AUDIOFUNC, captured > sw->totalhwsamplesmixed)) { dolog (\"captured=%d sw->totalhwsamplesmixed=%d\\n\", captured, sw->totalhwsamplesmixed); captured = sw->totalhwsamplesmixed; } sw->totalhwsamplesmixed -= captured; sw->empty = sw->totalhwsamplesmixed == 0; } } } ", "target": 0}
{"func": "CharDriverState *qemuchralloc(void) { CharDriverState *chr = gmalloc0(sizeof(CharDriverState)); return chr; }", "target": 1}
{"func": "static void eccinit(targetphysaddrt base, qemuirq irq, uint32t version) { DeviceState *dev; SysBusDevice *s; dev = qdevcreate(NULL, \"eccmemctl\"); qdevpropsetuint32(dev, \"version\", version); qdevinit(dev); s = sysbusfromqdev(dev); sysbusconnectirq(s, 0, irq); sysbusmmiomap(s, 0, base); if (version == 0) { // SS-600MP only sysbusmmiomap(s, 1, base + 0x1000); } } ", "target": 1}
{"func": "int pcistbservicecall(S390CPU *cpu, uint8t r1, uint8t r3, uint64t gaddr, uint8t ar) { CPUS390XState *env = &cpu->env; S390PCIBusDevice *pbdev; MemoryRegion *mr; int i; uint32t fh; uint8t pcias; uint8t len; uint8t buffer[128]; if (env->psw.mask & PSWMASKPSTATE) { programinterrupt(env, PGMPRIVILEGED, 6); return 0; } fh = env->regs[r1] >> 32; pcias = (env->regs[r1] >> 16) & 0xf; len = env->regs[r1] & 0xff; if (pcias > 5) { DPRINTF(\"pcistb invalid space\\n\"); setcc(cpu, ZPCIPCILSERR); s390setstatuscode(env, r1, ZPCIPCISTINVALAS); return 0; } switch (len) { case 16: case 32: case 64: case 128: break; default: programinterrupt(env, PGMSPECIFICATION, 6); return 0; } pbdev = s390pcifinddevbyfh(fh); if (!pbdev || !(pbdev->fh & FHMASKENABLE)) { DPRINTF(\"pcistb no pci dev fh 0x%x\\n\", fh); setcc(cpu, ZPCIPCILSINVALHANDLE); return 0; } if (pbdev->lgstgblocked) { setcc(cpu, ZPCIPCILSERR); s390setstatuscode(env, r1, ZPCIPCISTBLOCKED); return 0; } mr = pbdev->pdev->ioregions[pcias].memory; if (!memoryregionaccessvalid(mr, env->regs[r3], len, true)) { programinterrupt(env, PGMADDRESSING, 6); return 0; } if (s390cpuvirtmemread(cpu, gaddr, ar, buffer, len)) { return 0; } for (i = 0; i < len / 8; i++) { memoryregiondispatchwrite(mr, env->regs[r3] + i * 8, ldqp(buffer + i * 8), 8, MEMTXATTRSUNSPECIFIED); } setcc(cpu, ZPCIPCILSOK); return 0; } ", "target": 0}
{"func": "static gboolean monitorunblocked(GIOChannel *chan, GIOCondition cond, void *opaque) { monitorflush(opaque); return FALSE; } ", "target": 0}
{"func": "static alwaysinline void genstorespr(int reg, TCGv t) { tcggensttl(t, cpuenv, offsetof(CPUState, spr[reg])); } ", "target": 0}
{"func": "int bdrvisreadonly(BlockDriverState *bs) { return bs->readonly; } ", "target": 0}
{"func": "static void bwconf1write(void *opaque, targetphysaddrt addr, uint64t val, unsigned size) { PCIBus *b = opaque; pcidatawrite(b, addr, val, size); } ", "target": 0}
{"func": "void tlbfill(targetulong addr, int iswrite, int isuser, void *retaddr) { TranslationBlock *tb; int ret; unsigned long pc; CPUX86State *savedenv; /* XXX: hack to restore env in all cases, even if not called from generated code */ savedenv = env; env = cpusingleenv; ret = cpux86handlemmufault(env, addr, iswrite, isuser, 1); if (ret) { if (retaddr) { /* now we have a real cpu fault */ pc = (unsigned long)retaddr; tb = tbfindpc(pc); if (tb) { /* the PC is inside the translated code. It means that we have a virtual CPU fault */ cpurestorestate(tb, env, pc, NULL); } } if (retaddr) raiseexceptionerr(EXCP0EPAGE, env->errorcode); else raiseexceptionerrnorestore(EXCP0EPAGE, env->errorcode); } env = savedenv; } ", "target": 0}
{"func": "static void testtco1statusbits(void) { TestData d; uint16t ticks = 8; uint16t val; int ret; d.args = NULL; d.noreboot = true; testinit(&d); stoptco(&d); cleartcostatus(&d); resetonsecondtimeout(false); settcotimeout(&d, ticks); loadtco(&d); starttco(&d); clockstep(ticks * TCOTICKNSEC); qpciiowriteb(d.dev, d.tcoiobase + TCODATIN, 0); qpciiowriteb(d.dev, d.tcoiobase + TCODATOUT, 0); val = qpciioreadw(d.dev, d.tcoiobase + TCO1STS); ret = val & (TCOTIMEOUT | SWTCOSMI | TCOINTSTS) ? 1 : 0; gassert(ret == 1); qpciiowritew(d.dev, d.tcoiobase + TCO1STS, val); gassertcmpint(qpciioreadw(d.dev, d.tcoiobase + TCO1STS), ==, 0); qtestend(); } ", "target": 1}
{"func": "blockcryptocreateoptsinit(QCryptoBlockFormat format, QemuOpts *opts, Error **errp) { OptsVisitor *ov; QCryptoBlockCreateOptions *ret = NULL; Error *localerr = NULL; ret = gnew0(QCryptoBlockCreateOptions, 1); ret->format = format; ov = optsvisitornew(opts); visitstartstruct(optsgetvisitor(ov), NULL, NULL, 0, &localerr); if (localerr) { goto out; } switch (format) { case QCRYPTOBLOCKFORMATLUKS: visittypeQCryptoBlockCreateOptionsLUKSmembers( optsgetvisitor(ov), &ret->u.luks, &localerr); break; default: errorsetg(&localerr, \"Unsupported block format %d\", format); break; } errorpropagate(errp, localerr); localerr = NULL; visitendstruct(optsgetvisitor(ov), &localerr); out: if (localerr) { errorpropagate(errp, localerr); qapifreeQCryptoBlockCreateOptions(ret); ret = NULL; } optsvisitorcleanup(ov); return ret; } ", "target": 1}
{"func": "static void RENAME(yuv2yuvX)(SwsContext *c, const int16t *lumFilter, const int16t **lumSrc, int lumFilterSize, const int16t *chrFilter, const int16t **chrUSrc, const int16t **chrVSrc, int chrFilterSize, const int16t **alpSrc, uint8t *dest, uint8t *uDest, uint8t *vDest, uint8t *aDest, int dstW, int chrDstW) { if (uDest) { x86reg uvoff = c->uvoff; YSCALEYUV2YV12X(CHRMMXFILTEROFFSET, uDest, chrDstW, 0) YSCALEYUV2YV12X(CHRMMXFILTEROFFSET, vDest - uvoff, chrDstW + uvoff, uvoff) } if (CONFIGSWSCALEALPHA && aDest) { YSCALEYUV2YV12X(ALPMMXFILTEROFFSET, aDest, dstW, 0) } YSCALEYUV2YV12X(LUMMMXFILTEROFFSET, dest, dstW, 0) } ", "target": 0}
{"func": "static void addcpregtolist(gpointer key, gpointer opaque) { ARMCPU *cpu = opaque; uint64t regidx; const ARMCPRegInfo *ri; regidx = *(uint32t *)key; ri = getarmcpreginfo(cpu->cpregs, regidx); if (!(ri->type & ARMCPNOMIGRATE)) { cpu->cpregindexes[cpu->cpregarraylen] = cpregtokvmid(regidx); /* The value array need not be initialized at this point */ cpu->cpregarraylen++; } } ", "target": 0}
{"func": "static int xanhuffmandecode(unsigned char *dest, unsigned char *src) { unsigned char byte = *src++; unsigned char ival = byte + 0x16; unsigned char * ptr = src + byte*2; unsigned char val = ival; int counter = 0; unsigned char bits = *ptr++; while ( val != 0x16 ) { if ( (1 << counter) & bits ) val = src[byte + val - 0x17]; else val = src[val - 0x17]; if ( val < 0x16 ) { *dest++ = val; val = ival; } if (counter++ == 7) { counter = 0; bits = *ptr++; } } return 0; } ", "target": 0}
{"func": "static inline int alarmhasdynticks(struct qemualarmtimer *t) { return t && t->rearm; } ", "target": 0}
{"func": "static int iffreadheader(AVFormatContext *s) { IffDemuxContext *iff = s->privdata; AVIOContext *pb = s->pb; AVStream *st; uint8t *buf; uint32t chunkid, datasize; uint32t screenmode = 0, num, den; unsigned transparency = 0; unsigned masking = 0; // no mask uint8t fmt[16]; int fmtsize; st = avformatnewstream(s, NULL); if (!st) return AVERROR(ENOMEM); st->codec->channels = 1; st->codec->channellayout = AVCHLAYOUTMONO; avioskip(pb, 8); // codectag used by ByteRun1 decoder to distinguish progressive (PBM) and interlaced (ILBM) content st->codec->codectag = aviorl32(pb); iff->bitmapcompression = -1; iff->svx8compression = -1; iff->maudbits = -1; iff->maudcompression = -1; while(!urlfeof(pb)) { uint64t origpos; int res; const char *metadatatag = NULL; chunkid = aviorl32(pb); datasize = aviorb32(pb); origpos = aviotell(pb); switch(chunkid) { case IDVHDR: st->codec->codectype = AVMEDIATYPEAUDIO; if (datasize < 14) return AVERRORINVALIDDATA; avioskip(pb, 12); st->codec->samplerate = aviorb16(pb); if (datasize >= 16) { avioskip(pb, 1); iff->svx8compression = avior8(pb); } break; case IDMHDR: st->codec->codectype = AVMEDIATYPEAUDIO; if (datasize < 32) return AVERRORINVALIDDATA; avioskip(pb, 4); iff->maudbits = aviorb16(pb); avioskip(pb, 2); num = aviorb32(pb); den = aviorb16(pb); if (!den) return AVERRORINVALIDDATA; avioskip(pb, 2); st->codec->samplerate = num / den; st->codec->channels = aviorb16(pb); iff->maudcompression = aviorb16(pb); if (st->codec->channels == 1) st->codec->channellayout = AVCHLAYOUTMONO; else if (st->codec->channels == 2) st->codec->channellayout = AVCHLAYOUTSTEREO; break; case IDABIT: case IDBODY: case IDDBOD: case IDMDAT: iff->bodypos = aviotell(pb); iff->bodyend = iff->bodypos + datasize; iff->bodysize = datasize; break; case IDCHAN: if (datasize < 4) return AVERRORINVALIDDATA; if (aviorb32(pb) < 6) { st->codec->channels = 1; st->codec->channellayout = AVCHLAYOUTMONO; } else { st->codec->channels = 2; st->codec->channellayout = AVCHLAYOUTSTEREO; } break; case IDCAMG: if (datasize < 4) return AVERRORINVALIDDATA; screenmode = aviorb32(pb); break; case IDCMAP: if (datasize > INTMAX - IFFEXTRAVIDEOSIZE - FFINPUTBUFFERPADDINGSIZE) return AVERRORINVALIDDATA; st->codec->extradatasize = datasize + IFFEXTRAVIDEOSIZE; st->codec->extradata = avmalloc(datasize + IFFEXTRAVIDEOSIZE + FFINPUTBUFFERPADDINGSIZE); if (!st->codec->extradata) return AVERROR(ENOMEM); if (avioread(pb, st->codec->extradata + IFFEXTRAVIDEOSIZE, datasize) < 0) return AVERROR(EIO); break; case IDBMHD: st->codec->codectype = AVMEDIATYPEVIDEO; if (datasize <= 8) return AVERRORINVALIDDATA; st->codec->width = aviorb16(pb); st->codec->height = aviorb16(pb); avioskip(pb, 4); // x, y offset st->codec->bitspercodedsample = avior8(pb); if (datasize >= 10) masking = avior8(pb); if (datasize >= 11) iff->bitmapcompression = avior8(pb); if (datasize >= 14) { avioskip(pb, 1); // padding transparency = aviorb16(pb); } if (datasize >= 16) { st->sampleaspectratio.num = avior8(pb); st->sampleaspectratio.den = avior8(pb); } break; case IDDPEL: if (datasize < 4 || (datasize & 3)) return AVERRORINVALIDDATA; if ((fmtsize = avioread(pb, fmt, sizeof(fmt))) < 0) return fmtsize; if (fmtsize == sizeof(deeprgb24) && !memcmp(fmt, deeprgb24, sizeof(deeprgb24))) st->codec->pixfmt = AVPIXFMTRGB24; else if (fmtsize == sizeof(deeprgba) && !memcmp(fmt, deeprgba, sizeof(deeprgba))) st->codec->pixfmt = AVPIXFMTRGBA; else if (fmtsize == sizeof(deepbgra) && !memcmp(fmt, deepbgra, sizeof(deepbgra))) st->codec->pixfmt = AVPIXFMTBGRA; else if (fmtsize == sizeof(deepargb) && !memcmp(fmt, deepargb, sizeof(deepargb))) st->codec->pixfmt = AVPIXFMTARGB; else if (fmtsize == sizeof(deepabgr) && !memcmp(fmt, deepabgr, sizeof(deepabgr))) st->codec->pixfmt = AVPIXFMTABGR; else { avlogaskforsample(s, \"unsupported color format\\n\"); return AVERRORPATCHWELCOME; } break; case IDDGBL: st->codec->codectype = AVMEDIATYPEVIDEO; if (datasize < 8) return AVERRORINVALIDDATA; st->codec->width = aviorb16(pb); st->codec->height = aviorb16(pb); iff->bitmapcompression = aviorb16(pb); st->sampleaspectratio.num = avior8(pb); st->sampleaspectratio.den = avior8(pb); st->codec->bitspercodedsample = 24; break; case IDDLOC: if (datasize < 4) return AVERRORINVALIDDATA; st->codec->width = aviorb16(pb); st->codec->height = aviorb16(pb); break; case IDTVDC: if (datasize < sizeof(iff->tvdc)) return AVERRORINVALIDDATA; res = avioread(pb, iff->tvdc, sizeof(iff->tvdc)); if (res < 0) return res; break; case IDANNO: case IDTEXT: metadatatag = \"comment\"; break; case IDAUTH: metadatatag = \"artist\"; break; case IDCOPYRIGHT: metadatatag = \"copyright\"; break; case IDNAME: metadatatag = \"title\"; break; } if (metadatatag) { if ((res = getmetadata(s, metadatatag, datasize)) < 0) { avlog(s, AVLOGERROR, \"cannot allocate metadata tag %s!\\n\", metadatatag); return res; } } avioskip(pb, datasize - (aviotell(pb) - origpos) + (datasize & 1)); } avioseek(pb, iff->bodypos, SEEKSET); switch(st->codec->codectype) { case AVMEDIATYPEAUDIO: avprivsetptsinfo(st, 32, 1, st->codec->samplerate); if (st->codec->codectag == ID16SV) st->codec->codecid = AVCODECIDPCMS16BEPLANAR; else if (st->codec->codectag == IDMAUD) { if (iff->maudbits == 8 && !iff->maudcompression) { st->codec->codecid = AVCODECIDPCMU8; } else if (iff->maudbits == 16 && !iff->maudcompression) { st->codec->codecid = AVCODECIDPCMS16BE; } else if (iff->maudbits == 8 && iff->maudcompression == 2) { st->codec->codecid = AVCODECIDPCMALAW; } else if (iff->maudbits == 8 && iff->maudcompression == 3) { st->codec->codecid = AVCODECIDPCMMULAW; } else { avlogaskforsample(s, \"unsupported compression %d and bit depth %d\\n\", iff->maudcompression, iff->maudbits); return AVERRORPATCHWELCOME; } st->codec->bitspercodedsample = avgetbitspersample(st->codec->codecid); st->codec->blockalign = st->codec->bitspercodedsample * st->codec->channels / 8; } else { switch (iff->svx8compression) { case COMPNONE: st->codec->codecid = AVCODECIDPCMS8PLANAR; break; case COMPFIB: st->codec->codecid = AVCODECID8SVXFIB; break; case COMPEXP: st->codec->codecid = AVCODECID8SVXEXP; break; default: avlog(s, AVLOGERROR, \"Unknown SVX8 compression method '%d'\\n\", iff->svx8compression); return -1; } } st->codec->bitspercodedsample = avgetbitspersample(st->codec->codecid); st->codec->bitrate = st->codec->channels * st->codec->samplerate * st->codec->bitspercodedsample; st->codec->blockalign = st->codec->channels * st->codec->bitspercodedsample; break; case AVMEDIATYPEVIDEO: iff->bpp = st->codec->bitspercodedsample; if ((screenmode & 0x800 /* Hold And Modify */) && iff->bpp <= 8) { iff->ham = iff->bpp > 6 ? 6 : 4; st->codec->bitspercodedsample = 24; } iff->flags = (screenmode & 0x80 /* Extra HalfBrite */) && iff->bpp <= 8; iff->masking = masking; iff->transparency = transparency; if (!st->codec->extradata) { st->codec->extradatasize = IFFEXTRAVIDEOSIZE; st->codec->extradata = avmalloc(IFFEXTRAVIDEOSIZE + FFINPUTBUFFERPADDINGSIZE); if (!st->codec->extradata) return AVERROR(ENOMEM); } buf = st->codec->extradata; bytestreamputbe16(&buf, IFFEXTRAVIDEOSIZE); bytestreamputbyte(&buf, iff->bitmapcompression); bytestreamputbyte(&buf, iff->bpp); bytestreamputbyte(&buf, iff->ham); bytestreamputbyte(&buf, iff->flags); bytestreamputbe16(&buf, iff->transparency); bytestreamputbyte(&buf, iff->masking); bytestreamputbuffer(&buf, iff->tvdc, sizeof(iff->tvdc)); st->codec->codecid = AVCODECIDIFFILBM; break; default: return -1; } return 0; }", "target": 1}
{"func": "static int ftpstatus(FTPContext *s, char **line, const int responsecodes[]) { int err, i, dash = 0, result = 0, codefound = 0; char buf[CONTROLBUFFERSIZE]; AVBPrint linebuffer; if (line) avbprintinit(&linebuffer, 0, AVBPRINTSIZEAUTOMATIC); while (!codefound || dash) { if ((err = ftpgetline(s, buf, sizeof(buf))) < 0) { avbprintfinalize(&linebuffer, NULL); return err; } avlog(s, AVLOGDEBUG, \"%s\\n\", buf); if (strlen(buf) < 4) continue; err = 0; for (i = 0; i < 3; ++i) { if (buf[i] < '0' || buf[i] > '9') continue; err *= 10; err += buf[i] - '0'; } dash = !!(buf[3] == '-'); for (i = 0; responsecodes[i]; ++i) { if (err == responsecodes[i]) { if (line) avbprintf(&linebuffer, \"%s\", buf); codefound = 1; result = err; break; } } } if (line) avbprintfinalize(&linebuffer, line); return result; } ", "target": 1}
{"func": "static uint32t armsysctlread(void *opaque, targetphysaddrt offset) { armsysctlstate *s = (armsysctlstate *)opaque; switch (offset) { case 0x00: /* ID */ return s->sysid; case 0x04: /* SW */ /* General purpose hardware switches. We don't have a useful way of exposing these to the user. */ return 0; case 0x08: /* LED */ return s->leds; case 0x20: /* LOCK */ return s->lockval; case 0x0c: /* OSC0 */ case 0x10: /* OSC1 */ case 0x14: /* OSC2 */ case 0x18: /* OSC3 */ case 0x1c: /* OSC4 */ case 0x24: /* 100HZ */ /* ??? Implement these. */ return 0; case 0x28: /* CFGDATA1 */ return s->cfgdata1; case 0x2c: /* CFGDATA2 */ return s->cfgdata2; case 0x30: /* FLAGS */ return s->flags; case 0x38: /* NVFLAGS */ return s->nvflags; case 0x40: /* RESETCTL */ return s->resetlevel; case 0x44: /* PCICTL */ return 1; case 0x48: /* MCI */ return 0; case 0x4c: /* FLASH */ return 0; case 0x50: /* CLCD */ return 0x1000; case 0x54: /* CLCDSER */ return 0; case 0x58: /* BOOTCS */ return 0; case 0x5c: /* 24MHz */ return muldiv64(qemugetclock(vmclock), 24000000, gettickspersec()); case 0x60: /* MISC */ return 0; case 0x84: /* PROCID0 */ /* ??? Don't know what the proper value for the core tile ID is. */ return 0x02000000; case 0x88: /* PROCID1 */ return 0xff000000; case 0x64: /* DMAPSR0 */ case 0x68: /* DMAPSR1 */ case 0x6c: /* DMAPSR2 */ case 0x70: /* IOSEL */ case 0x74: /* PLDCTL */ case 0x80: /* BUSID */ case 0x8c: /* OSCRESET0 */ case 0x90: /* OSCRESET1 */ case 0x94: /* OSCRESET2 */ case 0x98: /* OSCRESET3 */ case 0x9c: /* OSCRESET4 */ case 0xc0: /* SYSTESTOSC0 */ case 0xc4: /* SYSTESTOSC1 */ case 0xc8: /* SYSTESTOSC2 */ case 0xcc: /* SYSTESTOSC3 */ case 0xd0: /* SYSTESTOSC4 */ return 0; default: printf (\"armsysctlread: Bad register offset 0x%x\\n\", (int)offset); return 0; } } ", "target": 0}
{"func": "void runoncpu(CPUState *cpu, void (*func)(void *data), void *data) { struct qemuworkitem wi; if (qemucpuisself(cpu)) { func(data); return; } wi.func = func; wi.data = data; wi.free = false; if (cpu->queuedworkfirst == NULL) { cpu->queuedworkfirst = &wi; } else { cpu->queuedworklast->next = &wi; } cpu->queuedworklast = &wi; wi.next = NULL; wi.done = false; qemucpukick(cpu); while (!wi.done) { CPUState *selfcpu = currentcpu; qemucondwait(&qemuworkcond, &qemuglobalmutex); currentcpu = selfcpu; } } ", "target": 0}
{"func": "double avprivstrtod(char *restrict nptr, char **restrict endptr) { char *end; double res; /* Skip leading spaces */ while (isspace(*nptr)) nptr++; if (!avstrncasecmp(nptr, \"infinity\", 8)) { end = nptr + 8; res = INFINITY; } else if (!avstrncasecmp(nptr, \"inf\", 3)) { end = nptr + 3; res = INFINITY; } else if (!avstrncasecmp(nptr, \"+infinity\", 9)) { end = nptr + 9; res = INFINITY; } else if (!avstrncasecmp(nptr, \"+inf\", 4)) { end = nptr + 4; res = INFINITY; } else if (!avstrncasecmp(nptr, \"-infinity\", 9)) { end = nptr + 9; res = -INFINITY; } else if (!avstrncasecmp(nptr, \"-inf\", 4)) { end = nptr + 4; res = -INFINITY; } else if (!avstrncasecmp(nptr, \"nan\", 3)) { end = checknansuffix(nptr + 3); res = NAN; } else if (!avstrncasecmp(nptr, \"+nan\", 4) || !avstrncasecmp(nptr, \"-nan\", 4)) { end = checknansuffix(nptr + 4); res = NAN; } else if (!avstrncasecmp(nptr, \"0x\", 2) || !avstrncasecmp(nptr, \"-0x\", 3) || !avstrncasecmp(nptr, \"+0x\", 3)) { /* FIXME this doesn't handle exponents, non-integers (float/double) * and numbers too large for long long */ res = strtoll(nptr, &end, 16); } else { res = strtod(nptr, &end); } if (endptr) *endptr = end; return res; } ", "target": 0}
{"func": "static void updatevideopts(VideoState *is, double pts, int64t pos, int serial) { double time = avgettime() / 1000000.0; /* update current video pts */ is->videocurrentpts = pts; is->videocurrentptsdrift = is->videocurrentpts - time; is->videocurrentpos = pos; is->framelastpts = pts; checkexternalclocksync(is, is->videocurrentpts); } ", "target": 0}
{"func": "openf(int argc, char **argv) { \tint flags = 0; \tint readonly = 0; \tint growable = 0; \tint c; \twhile ((c = getopt(argc, argv, \"snrg\")) != EOF) { \t\tswitch (c) { \t\tcase 's': \t\t\tflags |= BDRVOSNAPSHOT; \t\t\tbreak; \t\tcase 'n': \t\t\tflags |= BDRVONOCACHE; \t\t\tbreak; \t\tcase 'r': \t\t\treadonly = 1; \t\t\tbreak; \t\tcase 'g': \t\t\tgrowable = 1; \t\t\tbreak; \t\tdefault: \t\t\treturn commandusage(&opencmd); \t\t} \t} \tif (!readonly) { flags |= BDRVORDWR; } \tif (optind != argc - 1) \t\treturn commandusage(&opencmd); \treturn openfile(argv[optind], flags, growable); } ", "target": 0}
{"func": "static unsigned int eventstatusmedia(IDEState *s, uint8t *buf) { uint8t eventcode, mediastatus; mediastatus = 0; if (s->trayopen) { mediastatus = MSTRAYOPEN; } else if (bdrvisinserted(s->bs)) { mediastatus = MSMEDIAPRESENT; } /* Event notification descriptor */ eventcode = MECNOCHANGE; if (mediastatus != MSTRAYOPEN) { if (s->events.newmedia) { eventcode = MECNEWMEDIA; s->events.newmedia = false; } else if (s->events.ejectrequest) { eventcode = MECEJECTREQUESTED; s->events.ejectrequest = false; } } buf[4] = eventcode; buf[5] = mediastatus; /* These fields are reserved, just clear them. */ buf[6] = 0; buf[7] = 0; return 8; /* We wrote to 4 extra bytes from the header */ } ", "target": 0}
{"func": "static void virtioscsihotunplug(HotplugHandler *hotplugdev, DeviceState *dev, Error **errp) { VirtIODevice *vdev = VIRTIODEVICE(hotplugdev); VirtIOSCSI *s = VIRTIOSCSI(vdev); SCSIDevice *sd = SCSIDEVICE(dev); if ((vdev->guestfeatures >> VIRTIOSCSIFHOTPLUG) & 1) { virtioscsipushevent(s, sd, VIRTIOSCSITTRANSPORTRESET, VIRTIOSCSIEVTRESETREMOVED); } if (s->ctx) { blkopunblockall(sd->conf.blk, s->blocker); } qdevsimpledeviceunplugcb(hotplugdev, dev, errp); } ", "target": 0}
{"func": "int qiochannelsocketconnectsync(QIOChannelSocket *ioc, SocketAddress *addr, Error **errp) { int fd; traceqiochannelsocketconnectsync(ioc, addr); fd = socketconnect(addr, NULL, NULL, errp); if (fd < 0) { traceqiochannelsocketconnectfail(ioc); return -1; } traceqiochannelsocketconnectcomplete(ioc, fd); if (qiochannelsocketsetfd(ioc, fd, errp) < 0) { close(fd); return -1; } return 0; } ", "target": 0}
{"func": "static void savebits(WMAProDecodeCtx *s, GetBitContext* gb, int len, int append) { int buflen; /** when the frame data does not need to be concatenated, the input buffer is resetted and additional bits from the previous frame are copyed and skipped later so that a fast byte copy is possible */ if (!append) { s->frameoffset = getbitscount(gb) & 7; s->numsavedbits = s->frameoffset; initputbits(&s->pb, s->framedata, MAXFRAMESIZE); buflen = (s->numsavedbits + len + 8) >> 3; if (len <= 0 || buflen > MAXFRAMESIZE) { avprivrequestsample(s->avctx, \"Too small input buffer\"); s->numsavedbits += len; if (!append) { avprivcopybits(&s->pb, gb->buffer + (getbitscount(gb) >> 3), s->numsavedbits); } else { int align = 8 - (getbitscount(gb) & 7); align = FFMIN(align, len); putbits(&s->pb, align, getbits(gb, align)); len -= align; avprivcopybits(&s->pb, gb->buffer + (getbitscount(gb) >> 3), len); skipbitslong(gb, len); { PutBitContext tmp = s->pb; flushputbits(&tmp); initgetbits(&s->gb, s->framedata, s->numsavedbits); skipbits(&s->gb, s->frameoffset);", "target": 1}
{"func": "static int readintervalpackets(WriterContext *w, AVFormatContext *fmtctx, const ReadInterval *interval, int64t *curts) { AVPacket pkt, pkt1; AVFrame *frame = NULL; int ret = 0, i = 0, framecount = 0; int64t start = -INT64MAX, end = interval->end; int hasstart = 0, hasend = interval->hasend && !interval->endisoffset; avinitpacket(&pkt); avlog(NULL, AVLOGVERBOSE, \"Processing read interval \"); logreadinterval(interval, NULL, AVLOGVERBOSE); if (interval->hasstart) { int64t target; if (interval->startisoffset) { if (*curts == AVNOPTSVALUE) { avlog(NULL, AVLOGERROR, \"Could not seek to relative position since current \" \"timestamp is not defined\\n\"); ret = AVERROR(EINVAL); target = *curts + interval->start; } else { target = interval->start; avlog(NULL, AVLOGVERBOSE, \"Seeking to read interval start point %s\\n\", avts2timestr(target, &AVTIMEBASEQ)); if ((ret = avformatseekfile(fmtctx, -1, -INT64MAX, target, INT64MAX, 0)) < 0) { avlog(NULL, AVLOGERROR, \"Could not seek to position %\"PRId64\": %s\\n\", interval->start, averr2str(ret)); frame = avframealloc(); while (!avreadframe(fmtctx, &pkt)) { if (selectedstreams[pkt.streamindex]) { AVRational tb = fmtctx->streams[pkt.streamindex]->timebase; if (pkt.pts != AVNOPTSVALUE) *curts = avrescaleq(pkt.pts, tb, AVTIMEBASEQ); if (!hasstart && *curts != AVNOPTSVALUE) { start = *curts; hasstart = 1; if (hasstart && !hasend && interval->endisoffset) { end = start + interval->end; hasend = 1; if (interval->endisoffset && interval->durationframes) { if (framecount >= interval->end) break; } else if (hasend && *curts != AVNOPTSVALUE && *curts >= end) { break; framecount++; if (doreadpackets) { if (doshowpackets) showpacket(w, fmtctx, &pkt, i++); nbstreamspackets[pkt.streamindex]++; if (doreadframes) { pkt1 = pkt; while (pkt1.size && processframe(w, fmtctx, frame, &pkt1) > 0); avfreepacket(&pkt); avinitpacket(&pkt); pkt.data = NULL; pkt.size = 0; //Flush remaining frames that are cached in the decoder for (i = 0; i < fmtctx->nbstreams; i++) { pkt.streamindex = i; if (doreadframes) while (processframe(w, fmtctx, frame, &pkt) > 0); end: avframefree(&frame); if (ret < 0) { avlog(NULL, AVLOGERROR, \"Could not read packets in interval \"); logreadinterval(interval, NULL, AVLOGERROR); return ret; ", "target": 1}
{"func": "int attributealignarg avcodecencodeaudio(AVCodecContext *avctx, uint8t *buf, int bufsize, const short *samples) { AVPacket pkt; AVFrame *frame; int ret, samplessize, gotpacket; avinitpacket(&pkt); pkt.data = buf; pkt.size = bufsize; if (samples) { frame = avframealloc(); if (!frame) return AVERROR(ENOMEM); if (avctx->framesize) { frame->nbsamples = avctx->framesize; } else { /* if framesize is not set, the number of samples must be * calculated from the buffer size */ int64t nbsamples; if (!avgetbitspersample(avctx->codecid)) { avlog(avctx, AVLOGERROR, \"avcodecencodeaudio() does not \" \"support this codec\\n\"); avframefree(&frame); return AVERROR(EINVAL); } nbsamples = (int64t)bufsize * 8 / (avgetbitspersample(avctx->codecid) * avctx->channels); if (nbsamples >= INTMAX) { avframefree(&frame); return AVERROR(EINVAL); } frame->nbsamples = nbsamples; } /* it is assumed that the samples buffer is large enough based on the * relevant parameters */ samplessize = avsamplesgetbuffersize(NULL, avctx->channels, frame->nbsamples, avctx->samplefmt, 1); if ((ret = avcodecfillaudioframe(frame, avctx->channels, avctx->samplefmt, (const uint8t *)samples, samplessize, 1)) < 0) { avframefree(&frame); return ret; } /* fabricate frame pts from sample count. * this is needed because the avcodecencodeaudio() API does not have * a way for the user to provide pts */ if (avctx->samplerate && avctx->timebase.num) frame->pts = ffsamplestotimebase(avctx, avctx->internal->samplecount); else frame->pts = AVNOPTSVALUE; avctx->internal->samplecount += frame->nbsamples; } else { frame = NULL; } gotpacket = 0; ret = avcodecencodeaudio2(avctx, &pkt, frame, &gotpacket); if (!ret && gotpacket && avctx->codedframe) { avctx->codedframe->pts = pkt.pts; avctx->codedframe->keyframe = !!(pkt.flags & AVPKTFLAGKEY); } /* free any side data since we cannot return it */ avpacketfreesidedata(&pkt); if (frame && frame->extendeddata != frame->data) avfreep(&frame->extendeddata); avframefree(&frame); return ret ? ret : pkt.size; }", "target": 1}
{"func": "static void hostcpuid(uint32t function, uint32t count, uint32t *eax, uint32t *ebx, uint32t *ecx, uint32t *edx) { #if defined(CONFIGKVM) uint32t vec[4]; #ifdef x8664 asm volatile(\"cpuid\" : \"=a\"(vec[0]), \"=b\"(vec[1]), \"=c\"(vec[2]), \"=d\"(vec[3]) : \"0\"(function), \"c\"(count) : \"cc\"); #else asm volatile(\"pusha \\n\\t\" \"cpuid \\n\\t\" \"mov %%eax, 0(%1) \\n\\t\" \"mov %%ebx, 4(%1) \\n\\t\" \"mov %%ecx, 8(%1) \\n\\t\" \"mov %%edx, 12(%1) \\n\\t\" \"popa\" : : \"a\"(function), \"c\"(count), \"S\"(vec) : \"memory\", \"cc\"); #endif if (eax) \t*eax = vec[0]; if (ebx) \t*ebx = vec[1]; if (ecx) \t*ecx = vec[2]; if (edx) \t*edx = vec[3]; #endif } ", "target": 1}
{"func": "static int dxva2mapframe(AVHWFramesContext *ctx, AVFrame *dst, const AVFrame *src, int flags) { IDirect3DSurface9 *surface = (IDirect3DSurface9*)src->data[3]; DXVA2Mapping *map; D3DSURFACEDESC surfaceDesc; D3DLOCKEDRECT LockedRect; HRESULT hr; int i, err, nbplanes; int lockflags = 0; nbplanes = avpixfmtcountplanes(dst->format); hr = IDirect3DSurface9GetDesc(surface, &surfaceDesc); if (FAILED(hr)) { avlog(ctx, AVLOGERROR, \"Error getting a surface description\\n\"); return AVERRORUNKNOWN; } if (!(flags & AVHWFRAMEMAPWRITE)) lockflags |= D3DLOCKREADONLY; if (flags & AVHWFRAMEMAPOVERWRITE) lockflags |= D3DLOCKDISCARD; hr = IDirect3DSurface9LockRect(surface, &LockedRect, NULL, lockflags); if (FAILED(hr)) { avlog(ctx, AVLOGERROR, \"Unable to lock DXVA2 surface\\n\"); return AVERRORUNKNOWN; } map = avmallocz(sizeof(*map)); if (!map) goto fail; err = ffhwframemapcreate(src->hwframesctx, dst, src, dxva2unmapframe, map); if (err < 0) { avfreep(&map); goto fail; } for (i = 0; i < nbplanes; i++) dst->linesize[i] = LockedRect.Pitch; avimagefillpointers(dst->data, dst->format, surfaceDesc.Height, (uint8t*)LockedRect.pBits, dst->linesize); if (dst->format == AVPIXFMTPAL8) dst->data[1] = (uint8t*)map->palettedummy; return 0; fail: IDirect3DSurface9UnlockRect(surface); return err; } ", "target": 1}
{"func": "void showhelp(void) { const char *prog; const OptionDef *po; int i, expert; prog = doplay ? \"ffplay\" : \"ffmpeg\"; printf(\"%s version \" FFMPEGVERSION \", Copyright (c) 2000, 2001, 2002 Gerard Lantau\\n\", prog); if (!doplay) { printf(\"usage: ffmpeg [[options] -i inputfile]... {[options] outfile}...\\n\" \"Hyper fast MPEG1/MPEG4/H263/RV and AC3/MPEG audio encoder\\n\"); } else { printf(\"usage: ffplay [options] inputfile...\\n\" \"Simple audio player\\n\"); } printf(\"\\n\" \"Main options are:\\n\"); for(i=0;i<2;i++) { if (i == 1) printf(\"\\nAdvanced options are:\\n\"); for(po = options; po->name != NULL; po++) { char buf[64]; expert = (po->flags & OPTEXPERT) != 0; if (expert == i) { strcpy(buf, po->name); if (po->flags & HASARG) { strcat(buf, \" \"); strcat(buf, po->argname); } printf(\"-%-17s %s\\n\", buf, po->help); } } } exit(1); } ", "target": 1}
{"func": "avcold int ffv1commoninit(AVCodecContext *avctx) { FFV1Context *s = avctx->privdata; if (!avctx->width || !avctx->height) return AVERRORINVALIDDATA; s->avctx = avctx; s->flags = avctx->flags; s->picture.f = avcodecallocframe(); s->lastpicture.f = avframealloc(); ffdsputilinit(&s->dsp, avctx); s->width = avctx->width; s->height = avctx->height; // defaults s->numhslices = 1; s->numvslices = 1; return 0; }", "target": 1}
{"func": "static int vqadecodechunk(VqaContext *s) { unsigned int chunktype; unsigned int chunksize; int byteskip; unsigned int index = 0; int i; unsigned char r, g, b; int indexshift; int res; int cbf0chunk = -1; int cbfzchunk = -1; int cbp0chunk = -1; int cbpzchunk = -1; int cpl0chunk = -1; int cplzchunk = -1; int vptzchunk = -1; int x, y; int lines = 0; int pixelptr; int vectorindex = 0; int lobyte = 0; int hibyte = 0; int lobytes = 0; int hibytes = s->decodebuffersize / 2; /* first, traverse through the frame and find the subchunks */ while (bytestream2getbytesleft(&s->gb) >= 8) { chunktype = bytestream2getbe32u(&s->gb); index = bytestream2tell(&s->gb); chunksize = bytestream2getbe32u(&s->gb); switch (chunktype) { case CBF0TAG: cbf0chunk = index; break; case CBFZTAG: cbfzchunk = index; break; case CBP0TAG: cbp0chunk = index; break; case CBPZTAG: cbpzchunk = index; break; case CPL0TAG: cpl0chunk = index; break; case CPLZTAG: cplzchunk = index; break; case VPTZTAG: vptzchunk = index; break; default: avlog(s->avctx, AVLOGERROR, \" VQA video: Found unknown chunk type: %c%c%c%c (%08X)\\n\", (chunktype >> 24) & 0xFF, (chunktype >> 16) & 0xFF, (chunktype >> 8) & 0xFF, (chunktype >> 0) & 0xFF, chunktype); break; } byteskip = chunksize & 0x01; bytestream2skip(&s->gb, chunksize + byteskip); } /* next, deal with the palette */ if ((cpl0chunk != -1) && (cplzchunk != -1)) { /* a chunk should not have both chunk types */ avlog(s->avctx, AVLOGERROR, \" VQA video: problem: found both CPL0 and CPLZ chunks\\n\"); return AVERRORINVALIDDATA; } /* decompress the palette chunk */ if (cplzchunk != -1) { /* yet to be handled */ } /* convert the RGB palette into the machine's endian format */ if (cpl0chunk != -1) { bytestream2seek(&s->gb, cpl0chunk, SEEKSET); chunksize = bytestream2getbe32(&s->gb); /* sanity check the palette size */ if (chunksize / 3 > 256 || chunksize > bytestream2getbytesleft(&s->gb)) { avlog(s->avctx, AVLOGERROR, \" VQA video: problem: found a palette chunk with %d colors\\n\", chunksize / 3); return AVERRORINVALIDDATA; } for (i = 0; i < chunksize / 3; i++) { /* scale by 4 to transform 6-bit palette -> 8-bit */ r = bytestream2getbyteu(&s->gb) * 4; g = bytestream2getbyteu(&s->gb) * 4; b = bytestream2getbyteu(&s->gb) * 4; s->palette[i] = (r << 16) | (g << 8) | (b); } } /* next, look for a full codebook */ if ((cbf0chunk != -1) && (cbfzchunk != -1)) { /* a chunk should not have both chunk types */ avlog(s->avctx, AVLOGERROR, \" VQA video: problem: found both CBF0 and CBFZ chunks\\n\"); return AVERRORINVALIDDATA; } /* decompress the full codebook chunk */ if (cbfzchunk != -1) { bytestream2seek(&s->gb, cbfzchunk, SEEKSET); chunksize = bytestream2getbe32(&s->gb); if ((res = decodeformat80(&s->gb, chunksize, s->codebook, s->codebooksize, 0)) < 0) return res; } /* copy a full codebook */ if (cbf0chunk != -1) { bytestream2seek(&s->gb, cbf0chunk, SEEKSET); chunksize = bytestream2getbe32(&s->gb); /* sanity check the full codebook size */ if (chunksize > MAXCODEBOOKSIZE) { avlog(s->avctx, AVLOGERROR, \" VQA video: problem: CBF0 chunk too large (0x%X bytes)\\n\", chunksize); return AVERRORINVALIDDATA; } bytestream2getbuffer(&s->gb, s->codebook, chunksize); } /* decode the frame */ if (vptzchunk == -1) { /* something is wrong if there is no VPTZ chunk */ avlog(s->avctx, AVLOGERROR, \" VQA video: problem: no VPTZ chunk found\\n\"); return AVERRORINVALIDDATA; } bytestream2seek(&s->gb, vptzchunk, SEEKSET); chunksize = bytestream2getbe32(&s->gb); if ((res = decodeformat80(&s->gb, chunksize, s->decodebuffer, s->decodebuffersize, 1)) < 0) return res; /* render the final PAL8 frame */ if (s->vectorheight == 4) indexshift = 4; else indexshift = 3; for (y = 0; y < s->frame.linesize[0] * s->height; y += s->frame.linesize[0] * s->vectorheight) { for (x = y; x < y + s->width; x += 4, lobytes++, hibytes++) { pixelptr = x; /* get the vector index, the method for which varies according to * VQA file version */ switch (s->vqaversion) { case 1: lobyte = s->decodebuffer[lobytes * 2]; hibyte = s->decodebuffer[(lobytes * 2) + 1]; vectorindex = ((hibyte << 8) | lobyte) >> 3; vectorindex <<= indexshift; lines = s->vectorheight; /* uniform color fill - a quick hack */ if (hibyte == 0xFF) { while (lines--) { s->frame.data[0][pixelptr + 0] = 255 - lobyte; s->frame.data[0][pixelptr + 1] = 255 - lobyte; s->frame.data[0][pixelptr + 2] = 255 - lobyte; s->frame.data[0][pixelptr + 3] = 255 - lobyte; pixelptr += s->frame.linesize[0]; } lines=0; } break; case 2: lobyte = s->decodebuffer[lobytes]; hibyte = s->decodebuffer[hibytes]; vectorindex = (hibyte << 8) | lobyte; vectorindex <<= indexshift; lines = s->vectorheight; break; case 3: /* not implemented yet */ lines = 0; break; } while (lines--) { s->frame.data[0][pixelptr + 0] = s->codebook[vectorindex++]; s->frame.data[0][pixelptr + 1] = s->codebook[vectorindex++]; s->frame.data[0][pixelptr + 2] = s->codebook[vectorindex++]; s->frame.data[0][pixelptr + 3] = s->codebook[vectorindex++]; pixelptr += s->frame.linesize[0]; } } } /* handle partial codebook */ if ((cbp0chunk != -1) && (cbpzchunk != -1)) { /* a chunk should not have both chunk types */ avlog(s->avctx, AVLOGERROR, \" VQA video: problem: found both CBP0 and CBPZ chunks\\n\"); return AVERRORINVALIDDATA; } if (cbp0chunk != -1) { bytestream2seek(&s->gb, cbp0chunk, SEEKSET); chunksize = bytestream2getbe32(&s->gb); /* accumulate partial codebook */ bytestream2getbuffer(&s->gb, &s->nextcodebookbuffer[s->nextcodebookbufferindex], chunksize); s->nextcodebookbufferindex += chunksize; s->partialcountdown--; if (s->partialcountdown == 0) { /* time to replace codebook */ memcpy(s->codebook, s->nextcodebookbuffer, s->nextcodebookbufferindex); /* reset accounting */ s->nextcodebookbufferindex = 0; s->partialcountdown = s->partialcount; } } if (cbpzchunk != -1) { bytestream2seek(&s->gb, cbpzchunk, SEEKSET); chunksize = bytestream2getbe32(&s->gb); /* accumulate partial codebook */ bytestream2getbuffer(&s->gb, &s->nextcodebookbuffer[s->nextcodebookbufferindex], chunksize); s->nextcodebookbufferindex += chunksize; s->partialcountdown--; if (s->partialcountdown == 0) { GetByteContext gb; bytestream2init(&gb, s->nextcodebookbuffer, s->nextcodebookbufferindex); /* decompress codebook */ if ((res = decodeformat80(&gb, s->nextcodebookbufferindex, s->codebook, s->codebooksize, 0)) < 0) return res; /* reset accounting */ s->nextcodebookbufferindex = 0; s->partialcountdown = s->partialcount; } } return 0; } ", "target": 0}
{"func": "static void platformmmiomap(PCIDevice *d, int regionnum, pcibust addr, pcibust size, int type) { int mmioioaddr; mmioioaddr = cpuregisteriomemorysimple(&platformmmiohandler, DEVICENATIVEENDIAN); cpuregisterphysicalmemory(addr, size, mmioioaddr); } ", "target": 0}
{"func": "static void btsubmithci(struct HCIInfo *info, const uint8t *data, int length) { struct bthcis *hci = hcifrominfo(info); uint16t cmd; int paramlen, i; if (length < HCICOMMANDHDRSIZE) goto shorthci; memcpy(&hci->lastcmd, data, 2); cmd = (data[1] << 8) | data[0]; paramlen = data[2]; if (cmdopcodeogf(cmd) == 0 || cmdopcodeocf(cmd) == 0)\t/* NOP */ return; data += HCICOMMANDHDRSIZE; length -= HCICOMMANDHDRSIZE; if (paramlen > length) return; #define PARAM(cmd, param)\t(((cmd##cp *) data)->param) #define PARAM16(cmd, param)\tle16tocpup(&PARAM(cmd, param)) #define PARAMHANDLE(cmd)\tHNDL(PARAM(cmd, handle)) #define LENGTHCHECK(cmd)\tif (length < sizeof(cmd##cp)) goto shorthci /* Note: the supported commands bitmask in bthcireadlocalcommandsrp * needs to be updated every time a command is implemented here! */ switch (cmd) { case cmdopcodepack(OGFLINKCTL, OCFINQUIRY): LENGTHCHECK(inquiry); if (PARAM(inquiry, length) < 1) { bthcieventcompletestatus(hci, HCIINVALIDPARAMETERS); break; } hci->lm.inquire = 1; hci->lm.periodic = 0; hci->lm.responsesleft = PARAM(inquiry, numrsp) ?: INTMAX; hci->lm.responses = 0; bthcieventstatus(hci, HCISUCCESS); bthciinquirystart(hci, PARAM(inquiry, length)); break; case cmdopcodepack(OGFLINKCTL, OCFINQUIRYCANCEL): if (!hci->lm.inquire || hci->lm.periodic) { fprintf(stderr, \"%s: Inquiry Cancel should only be issued after \" \"the Inquiry command has been issued, a Command \" \"Status event has been received for the Inquiry \" \"command, and before the Inquiry Complete event \" \"occurs\", FUNCTION); bthcieventcompletestatus(hci, HCICOMMANDDISALLOWED); break; } hci->lm.inquire = 0; qemudeltimer(hci->lm.inquirydone); bthcieventcompletestatus(hci, HCISUCCESS); break; case cmdopcodepack(OGFLINKCTL, OCFPERIODICINQUIRY): LENGTHCHECK(periodicinquiry); if (!(PARAM(periodicinquiry, length) < PARAM16(periodicinquiry, minperiod) && PARAM16(periodicinquiry, minperiod) < PARAM16(periodicinquiry, maxperiod)) || PARAM(periodicinquiry, length) < 1 || PARAM16(periodicinquiry, minperiod) < 2 || PARAM16(periodicinquiry, maxperiod) < 3) { bthcieventcompletestatus(hci, HCIINVALIDPARAMETERS); break; } hci->lm.inquire = 1; hci->lm.periodic = 1; hci->lm.responsesleft = PARAM(periodicinquiry, numrsp); hci->lm.responses = 0; hci->lm.inquiryperiod = PARAM16(periodicinquiry, maxperiod); bthcieventcompletestatus(hci, HCISUCCESS); bthciinquirystart(hci, PARAM(periodicinquiry, length)); break; case cmdopcodepack(OGFLINKCTL, OCFEXITPERIODICINQUIRY): if (!hci->lm.inquire || !hci->lm.periodic) { fprintf(stderr, \"%s: Inquiry Cancel should only be issued after \" \"the Inquiry command has been issued, a Command \" \"Status event has been received for the Inquiry \" \"command, and before the Inquiry Complete event \" \"occurs\", FUNCTION); bthcieventcompletestatus(hci, HCICOMMANDDISALLOWED); break; } hci->lm.inquire = 0; qemudeltimer(hci->lm.inquirydone); qemudeltimer(hci->lm.inquirynext); bthcieventcompletestatus(hci, HCISUCCESS); break; case cmdopcodepack(OGFLINKCTL, OCFCREATECONN): LENGTHCHECK(createconn); if (hci->lm.connecting >= HCIHANDLESMAX) { bthcieventstatus(hci, HCIREJECTEDLIMITEDRESOURCES); break; } bthcieventstatus(hci, HCISUCCESS); if (bthciconnect(hci, &PARAM(createconn, bdaddr))) bthciconnectionrejectevent(hci, &PARAM(createconn, bdaddr)); break; case cmdopcodepack(OGFLINKCTL, OCFDISCONNECT): LENGTHCHECK(disconnect); if (bthcihandlebad(hci, PARAMHANDLE(disconnect))) { bthcieventstatus(hci, HCINOCONNECTION); break; } bthcieventstatus(hci, HCISUCCESS); bthcidisconnect(hci, PARAMHANDLE(disconnect), PARAM(disconnect, reason)); break; case cmdopcodepack(OGFLINKCTL, OCFCREATECONNCANCEL): LENGTHCHECK(createconncancel); if (bthcilmpconnectionready(hci, &PARAM(createconncancel, bdaddr))) { for (i = 0; i < HCIHANDLESMAX; i ++) if (bthcirolemaster(hci, i) && hci->lm.handle[i].link && !bacmp(&hci->lm.handle[i].link->slave->bdaddr, &PARAM(createconncancel, bdaddr))) break; bthcieventcompleteconncancel(hci, i < HCIHANDLESMAX ? HCIACLCONNECTIONEXISTS : HCINOCONNECTION, &PARAM(createconncancel, bdaddr)); } else bthcieventcompleteconncancel(hci, HCISUCCESS, &PARAM(createconncancel, bdaddr)); break; case cmdopcodepack(OGFLINKCTL, OCFACCEPTCONNREQ): LENGTHCHECK(acceptconnreq); if (!hci->connreqhost || bacmp(&PARAM(acceptconnreq, bdaddr), &hci->connreqhost->bdaddr)) { bthcieventstatus(hci, HCIINVALIDPARAMETERS); break; } bthcieventstatus(hci, HCISUCCESS); bthciconnectionaccept(hci, hci->connreqhost); hci->connreqhost = 0; break; case cmdopcodepack(OGFLINKCTL, OCFREJECTCONNREQ): LENGTHCHECK(rejectconnreq); if (!hci->connreqhost || bacmp(&PARAM(rejectconnreq, bdaddr), &hci->connreqhost->bdaddr)) { bthcieventstatus(hci, HCIINVALIDPARAMETERS); break; } bthcieventstatus(hci, HCISUCCESS); bthciconnectionreject(hci, hci->connreqhost, PARAM(rejectconnreq, reason)); bthciconnectionrejectevent(hci, &hci->connreqhost->bdaddr); hci->connreqhost = 0; break; case cmdopcodepack(OGFLINKCTL, OCFAUTHREQUESTED): LENGTHCHECK(authrequested); if (bthcihandlebad(hci, PARAMHANDLE(authrequested))) bthcieventstatus(hci, HCINOCONNECTION); else { bthcieventstatus(hci, HCISUCCESS); bthcieventauthcomplete(hci, PARAMHANDLE(authrequested)); } break; case cmdopcodepack(OGFLINKCTL, OCFSETCONNENCRYPT): LENGTHCHECK(setconnencrypt); if (bthcihandlebad(hci, PARAMHANDLE(setconnencrypt))) bthcieventstatus(hci, HCINOCONNECTION); else { bthcieventstatus(hci, HCISUCCESS); bthcieventencryptchange(hci, PARAMHANDLE(setconnencrypt), PARAM(setconnencrypt, encrypt)); } break; case cmdopcodepack(OGFLINKCTL, OCFREMOTENAMEREQ): LENGTHCHECK(remotenamereq); if (bthcinamereq(hci, &PARAM(remotenamereq, bdaddr))) bthcieventstatus(hci, HCINOCONNECTION); break; case cmdopcodepack(OGFLINKCTL, OCFREMOTENAMEREQCANCEL): LENGTHCHECK(remotenamereqcancel); bthcieventcompletenamecancel(hci, &PARAM(remotenamereqcancel, bdaddr)); break; case cmdopcodepack(OGFLINKCTL, OCFREADREMOTEFEATURES): LENGTHCHECK(readremotefeatures); if (bthcifeaturesreq(hci, PARAMHANDLE(readremotefeatures))) bthcieventstatus(hci, HCINOCONNECTION); break; case cmdopcodepack(OGFLINKCTL, OCFREADREMOTEEXTFEATURES): LENGTHCHECK(readremoteextfeatures); if (bthcihandlebad(hci, PARAMHANDLE(readremoteextfeatures))) bthcieventstatus(hci, HCINOCONNECTION); else { bthcieventstatus(hci, HCISUCCESS); bthcieventreadremoteextfeatures(hci, PARAMHANDLE(readremoteextfeatures)); } break; case cmdopcodepack(OGFLINKCTL, OCFREADREMOTEVERSION): LENGTHCHECK(readremoteversion); if (bthciversionreq(hci, PARAMHANDLE(readremoteversion))) bthcieventstatus(hci, HCINOCONNECTION); break; case cmdopcodepack(OGFLINKCTL, OCFREADCLOCKOFFSET): LENGTHCHECK(readclockoffset); if (bthciclkoffsetreq(hci, PARAMHANDLE(readclockoffset))) bthcieventstatus(hci, HCINOCONNECTION); break; case cmdopcodepack(OGFLINKCTL, OCFREADLMPHANDLE): LENGTHCHECK(readlmphandle); /* TODO: */ bthcieventcompletelmphandle(hci, PARAMHANDLE(readlmphandle)); break; case cmdopcodepack(OGFLINKPOLICY, OCFHOLDMODE): LENGTHCHECK(holdmode); if (PARAM16(holdmode, mininterval) > PARAM16(holdmode, maxinterval) || PARAM16(holdmode, mininterval) < 0x0002 || PARAM16(holdmode, maxinterval) > 0xff00 || (PARAM16(holdmode, mininterval) & 1) || (PARAM16(holdmode, maxinterval) & 1)) { bthcieventstatus(hci, HCIINVALIDPARAMETERS); break; } if (bthcimodechange(hci, PARAMHANDLE(holdmode), PARAM16(holdmode, maxinterval), aclhold)) bthcieventstatus(hci, HCINOCONNECTION); break; case cmdopcodepack(OGFLINKPOLICY, OCFPARKMODE): LENGTHCHECK(parkmode); if (PARAM16(parkmode, mininterval) > PARAM16(parkmode, maxinterval) || PARAM16(parkmode, mininterval) < 0x000e || (PARAM16(parkmode, mininterval) & 1) || (PARAM16(parkmode, maxinterval) & 1)) { bthcieventstatus(hci, HCIINVALIDPARAMETERS); break; } if (bthcimodechange(hci, PARAMHANDLE(parkmode), PARAM16(parkmode, maxinterval), aclparked)) bthcieventstatus(hci, HCINOCONNECTION); break; case cmdopcodepack(OGFLINKPOLICY, OCFEXITPARKMODE): LENGTHCHECK(exitparkmode); if (bthcimodecancel(hci, PARAMHANDLE(exitparkmode), aclparked)) bthcieventstatus(hci, HCINOCONNECTION); break; case cmdopcodepack(OGFLINKPOLICY, OCFROLEDISCOVERY): LENGTHCHECK(rolediscovery); if (bthcihandlebad(hci, PARAMHANDLE(rolediscovery))) bthcieventcompleterolediscovery(hci, HCINOCONNECTION, PARAMHANDLE(rolediscovery), 0); else bthcieventcompleterolediscovery(hci, HCISUCCESS, PARAMHANDLE(rolediscovery), bthcirolemaster(hci, PARAMHANDLE(rolediscovery))); break; case cmdopcodepack(OGFHOSTCTL, OCFSETEVENTMASK): LENGTHCHECK(seteventmask); memcpy(hci->eventmask, PARAM(seteventmask, mask), 8); bthcieventcompletestatus(hci, HCISUCCESS); break; case cmdopcodepack(OGFHOSTCTL, OCFRESET): bthcireset(hci); bthcieventstatus(hci, HCISUCCESS); break; case cmdopcodepack(OGFHOSTCTL, OCFSETEVENTFLT): if (length >= 1 && PARAM(seteventflt, flttype) == FLTCLEARALL) /* No length check */; else LENGTHCHECK(seteventflt); /* Filters are not implemented */ bthcieventcompletestatus(hci, HCISUCCESS); break; case cmdopcodepack(OGFHOSTCTL, OCFFLUSH): LENGTHCHECK(flush); if (bthcihandlebad(hci, PARAMHANDLE(flush))) bthcieventcompleteflush(hci, HCINOCONNECTION, PARAMHANDLE(flush)); else { /* TODO: ordering? */ bthcievent(hci, EVTFLUSHOCCURRED, &PARAM(flush, handle), EVTFLUSHOCCURREDSIZE); bthcieventcompleteflush(hci, HCISUCCESS, PARAMHANDLE(flush)); } break; case cmdopcodepack(OGFHOSTCTL, OCFCHANGELOCALNAME): LENGTHCHECK(changelocalname); if (hci->device.lmpname) free((void *) hci->device.lmpname); hci->device.lmpname = strndup(PARAM(changelocalname, name), sizeof(PARAM(changelocalname, name))); bthcieventcompletestatus(hci, HCISUCCESS); break; case cmdopcodepack(OGFHOSTCTL, OCFREADLOCALNAME): bthcieventcompletereadlocalname(hci); break; case cmdopcodepack(OGFHOSTCTL, OCFREADCONNACCEPTTIMEOUT): bthcieventcompletereadconnaccepttimeout(hci); break; case cmdopcodepack(OGFHOSTCTL, OCFWRITECONNACCEPTTIMEOUT): /* TODO */ LENGTHCHECK(writeconnaccepttimeout); if (PARAM16(writeconnaccepttimeout, timeout) < 0x0001 || PARAM16(writeconnaccepttimeout, timeout) > 0xb540) { bthcieventcompletestatus(hci, HCIINVALIDPARAMETERS); break; } hci->connaccepttout = PARAM16(writeconnaccepttimeout, timeout); bthcieventcompletestatus(hci, HCISUCCESS); break; case cmdopcodepack(OGFHOSTCTL, OCFREADSCANENABLE): bthcieventcompletereadscanenable(hci); break; case cmdopcodepack(OGFHOSTCTL, OCFWRITESCANENABLE): LENGTHCHECK(writescanenable); /* TODO: check that the remaining bits are all 0 */ hci->device.inquiryscan = !!(PARAM(writescanenable, scanenable) & SCANINQUIRY); hci->device.pagescan = !!(PARAM(writescanenable, scanenable) & SCANPAGE); bthcieventcompletestatus(hci, HCISUCCESS); break; case cmdopcodepack(OGFHOSTCTL, OCFREADCLASSOFDEV): bthcieventcompletereadlocalclass(hci); break; case cmdopcodepack(OGFHOSTCTL, OCFWRITECLASSOFDEV): LENGTHCHECK(writeclassofdev); memcpy(hci->device.class, PARAM(writeclassofdev, devclass), sizeof(PARAM(writeclassofdev, devclass))); bthcieventcompletestatus(hci, HCISUCCESS); break; case cmdopcodepack(OGFHOSTCTL, OCFREADVOICESETTING): bthcieventcompletevoicesetting(hci); break; case cmdopcodepack(OGFHOSTCTL, OCFWRITEVOICESETTING): LENGTHCHECK(writevoicesetting); hci->voicesetting = PARAM(writevoicesetting, voicesetting); bthcieventcompletestatus(hci, HCISUCCESS); break; case cmdopcodepack(OGFHOSTCTL, OCFHOSTNUMBEROFCOMPLETEDPACKETS): if (length < data[0] * 2 + 1) goto shorthci; for (i = 0; i < data[0]; i ++) if (bthcihandlebad(hci, data[i * 2 + 1] | (data[i * 2 + 2] << 8))) bthcieventcompletestatus(hci, HCIINVALIDPARAMETERS); break; case cmdopcodepack(OGFHOSTCTL, OCFREADINQUIRYMODE): /* Only if (localfeatures[3] & 0x40) && (localcommands[12] & 0x40) * else * goto unknowncommand */ bthcieventcompletereadinquirymode(hci); break; case cmdopcodepack(OGFHOSTCTL, OCFWRITEINQUIRYMODE): /* Only if (localfeatures[3] & 0x40) && (localcommands[12] & 0x80) * else * goto unknowncommand */ LENGTHCHECK(writeinquirymode); if (PARAM(writeinquirymode, mode) > 0x01) { bthcieventcompletestatus(hci, HCIINVALIDPARAMETERS); break; } hci->lm.inquirymode = PARAM(writeinquirymode, mode); bthcieventcompletestatus(hci, HCISUCCESS); break; case cmdopcodepack(OGFINFOPARAM, OCFREADLOCALVERSION): bthcireadlocalversionrp(hci); break; case cmdopcodepack(OGFINFOPARAM, OCFREADLOCALCOMMANDS): bthcireadlocalcommandsrp(hci); break; case cmdopcodepack(OGFINFOPARAM, OCFREADLOCALFEATURES): bthcireadlocalfeaturesrp(hci); break; case cmdopcodepack(OGFINFOPARAM, OCFREADLOCALEXTFEATURES): LENGTHCHECK(readlocalextfeatures); bthcireadlocalextfeaturesrp(hci, PARAM(readlocalextfeatures, pagenum)); break; case cmdopcodepack(OGFINFOPARAM, OCFREADBUFFERSIZE): bthcireadbuffersizerp(hci); break; case cmdopcodepack(OGFINFOPARAM, OCFREADCOUNTRYCODE): bthcireadcountrycoderp(hci); break; case cmdopcodepack(OGFINFOPARAM, OCFREADBDADDR): bthcireadbdaddrrp(hci); break; case cmdopcodepack(OGFSTATUSPARAM, OCFREADLINKQUALITY): LENGTHCHECK(readlinkquality); bthcilinkqualityrp(hci, PARAMHANDLE(readlinkquality)); break; default: bthcieventstatus(hci, HCIUNKNOWNCOMMAND); break; shorthci: fprintf(stderr, \"%s: HCI packet too short (%iB)\\n\", FUNCTION, length); bthcieventstatus(hci, HCIINVALIDPARAMETERS); break; } } ", "target": 0}
{"func": "static int kvms390registerioadapter(S390FLICState *fs, uint32t id, uint8t isc, bool swap, bool ismaskable) { struct kvms390ioadapter adapter = { .id = id, .isc = isc, .maskable = ismaskable, .swap = swap, }; KVMS390FLICState *flic = KVMS390FLIC(fs); int r, ret; struct kvmdeviceattr attr = { .group = KVMDEVFLICADAPTERREGISTER, .addr = (uint64t)&adapter, }; if (!kvmcheckextension(kvmstate, KVMCAPIRQROUTING)) { /* nothing to do */ return 0; } r = ioctl(flic->fd, KVMSETDEVICEATTR, &attr); ret = r ? -errno : 0; return ret; } ", "target": 0}
{"func": "static void deccalc(DisasContext *dc, uint32t insn) { uint32t op0, op1, op2; uint32t ra, rb, rd; op0 = extract32(insn, 0, 4); op1 = extract32(insn, 8, 2); op2 = extract32(insn, 6, 2); ra = extract32(insn, 16, 5); rb = extract32(insn, 11, 5); rd = extract32(insn, 21, 5); switch (op0) { case 0x0000: switch (op1) { case 0x00: /* l.add */ LOGDIS(\"l.add r%d, r%d, r%d\\n\", rd, ra, rb); { int lab = gennewlabel(); TCGvi64 ta = tcgtempnewi64(); TCGvi64 tb = tcgtempnewi64(); TCGvi64 td = tcgtemplocalnewi64(); TCGvi32 res = tcgtemplocalnewi32(); TCGvi32 srove = tcgtemplocalnewi32(); tcggenextui32i64(ta, cpuR[ra]); tcggenextui32i64(tb, cpuR[rb]); tcggenaddi64(td, ta, tb); tcggentrunci64i32(res, td); tcggenshrii64(td, td, 31); tcggenandii64(td, td, 0x3); /* Jump to lab when no overflow. */ tcggenbrcondii64(TCGCONDEQ, td, 0x0, lab); tcggenbrcondii64(TCGCONDEQ, td, 0x3, lab); tcggenorii32(cpusr, cpusr, (SROV | SRCY)); tcggenandii32(srove, cpusr, SROVE); tcggenbrcondii32(TCGCONDNE, srove, SROVE, lab); genexception(dc, EXCPRANGE); gensetlabel(lab); tcggenmovi32(cpuR[rd], res); tcgtempfreei64(ta); tcgtempfreei64(tb); tcgtempfreei64(td); tcgtempfreei32(res); tcgtempfreei32(srove); } break; default: genillegalexception(dc); break; } break; case 0x0001: /* l.addc */ switch (op1) { case 0x00: LOGDIS(\"l.addc r%d, r%d, r%d\\n\", rd, ra, rb); { int lab = gennewlabel(); TCGvi64 ta = tcgtempnewi64(); TCGvi64 tb = tcgtempnewi64(); TCGvi64 tcy = tcgtemplocalnewi64(); TCGvi64 td = tcgtemplocalnewi64(); TCGvi32 res = tcgtemplocalnewi32(); TCGvi32 srcy = tcgtemplocalnewi32(); TCGvi32 srove = tcgtemplocalnewi32(); tcggenextui32i64(ta, cpuR[ra]); tcggenextui32i64(tb, cpuR[rb]); tcggenandii32(srcy, cpusr, SRCY); tcggenextui32i64(tcy, srcy); tcggenshrii64(tcy, tcy, 10); tcggenaddi64(td, ta, tb); tcggenaddi64(td, td, tcy); tcggentrunci64i32(res, td); tcggenshrii64(td, td, 32); tcggenandii64(td, td, 0x3); /* Jump to lab when no overflow. */ tcggenbrcondii64(TCGCONDEQ, td, 0x0, lab); tcggenbrcondii64(TCGCONDEQ, td, 0x3, lab); tcggenorii32(cpusr, cpusr, (SROV | SRCY)); tcggenandii32(srove, cpusr, SROVE); tcggenbrcondii32(TCGCONDNE, srove, SROVE, lab); genexception(dc, EXCPRANGE); gensetlabel(lab); tcggenmovi32(cpuR[rd], res); tcgtempfreei64(ta); tcgtempfreei64(tb); tcgtempfreei64(tcy); tcgtempfreei64(td); tcgtempfreei32(res); tcgtempfreei32(srcy); tcgtempfreei32(srove); } break; default: genillegalexception(dc); break; } break; case 0x0002: /* l.sub */ switch (op1) { case 0x00: LOGDIS(\"l.sub r%d, r%d, r%d\\n\", rd, ra, rb); { int lab = gennewlabel(); TCGvi64 ta = tcgtempnewi64(); TCGvi64 tb = tcgtempnewi64(); TCGvi64 td = tcgtemplocalnewi64(); TCGvi32 res = tcgtemplocalnewi32(); TCGvi32 srove = tcgtemplocalnewi32(); tcggenextui32i64(ta, cpuR[ra]); tcggenextui32i64(tb, cpuR[rb]); tcggensubi64(td, ta, tb); tcggentrunci64i32(res, td); tcggenshrii64(td, td, 31); tcggenandii64(td, td, 0x3); /* Jump to lab when no overflow. */ tcggenbrcondii64(TCGCONDEQ, td, 0x0, lab); tcggenbrcondii64(TCGCONDEQ, td, 0x3, lab); tcggenorii32(cpusr, cpusr, (SROV | SRCY)); tcggenandii32(srove, cpusr, SROVE); tcggenbrcondii32(TCGCONDNE, srove, SROVE, lab); genexception(dc, EXCPRANGE); gensetlabel(lab); tcggenmovi32(cpuR[rd], res); tcgtempfreei64(ta); tcgtempfreei64(tb); tcgtempfreei64(td); tcgtempfreei32(res); tcgtempfreei32(srove); } break; default: genillegalexception(dc); break; } break; case 0x0003: /* l.and */ switch (op1) { case 0x00: LOGDIS(\"l.and r%d, r%d, r%d\\n\", rd, ra, rb); tcggenandtl(cpuR[rd], cpuR[ra], cpuR[rb]); break; default: genillegalexception(dc); break; } break; case 0x0004: /* l.or */ switch (op1) { case 0x00: LOGDIS(\"l.or r%d, r%d, r%d\\n\", rd, ra, rb); tcggenortl(cpuR[rd], cpuR[ra], cpuR[rb]); break; default: genillegalexception(dc); break; } break; case 0x0005: switch (op1) { case 0x00: /* l.xor */ LOGDIS(\"l.xor r%d, r%d, r%d\\n\", rd, ra, rb); tcggenxortl(cpuR[rd], cpuR[ra], cpuR[rb]); break; default: genillegalexception(dc); break; } break; case 0x0006: switch (op1) { case 0x03: /* l.mul */ LOGDIS(\"l.mul r%d, r%d, r%d\\n\", rd, ra, rb); if (ra != 0 && rb != 0) { genhelpermul32(cpuR[rd], cpuenv, cpuR[ra], cpuR[rb]); } else { tcggenmovitl(cpuR[rd], 0x0); } break; default: genillegalexception(dc); break; } break; case 0x0009: switch (op1) { case 0x03: /* l.div */ LOGDIS(\"l.div r%d, r%d, r%d\\n\", rd, ra, rb); { int lab0 = gennewlabel(); int lab1 = gennewlabel(); int lab2 = gennewlabel(); int lab3 = gennewlabel(); TCGvi32 srove = tcgtemplocalnewi32(); if (rb == 0) { tcggenoritl(cpusr, cpusr, (SROV | SRCY)); tcggenanditl(srove, cpusr, SROVE); tcggenbrconditl(TCGCONDNE, srove, SROVE, lab0); genexception(dc, EXCPRANGE); gensetlabel(lab0); } else { tcggenbrconditl(TCGCONDEQ, cpuR[rb], 0x00000000, lab1); tcggenbrconditl(TCGCONDNE, cpuR[ra], 0x80000000, lab2); tcggenbrconditl(TCGCONDNE, cpuR[rb], 0xffffffff, lab2); gensetlabel(lab1); tcggenoritl(cpusr, cpusr, (SROV | SRCY)); tcggenanditl(srove, cpusr, SROVE); tcggenbrconditl(TCGCONDNE, srove, SROVE, lab3); genexception(dc, EXCPRANGE); gensetlabel(lab2); tcggendivtl(cpuR[rd], cpuR[ra], cpuR[rb]); gensetlabel(lab3); } tcgtempfreei32(srove); } break; default: genillegalexception(dc); break; } break; case 0x000a: switch (op1) { case 0x03: /* l.divu */ LOGDIS(\"l.divu r%d, r%d, r%d\\n\", rd, ra, rb); { int lab0 = gennewlabel(); int lab1 = gennewlabel(); int lab2 = gennewlabel(); TCGvi32 srove = tcgtemplocalnewi32(); if (rb == 0) { tcggenoritl(cpusr, cpusr, (SROV | SRCY)); tcggenanditl(srove, cpusr, SROVE); tcggenbrconditl(TCGCONDNE, srove, SROVE, lab0); genexception(dc, EXCPRANGE); gensetlabel(lab0); } else { tcggenbrconditl(TCGCONDNE, cpuR[rb], 0x00000000, lab1); tcggenoritl(cpusr, cpusr, (SROV | SRCY)); tcggenanditl(srove, cpusr, SROVE); tcggenbrconditl(TCGCONDNE, srove, SROVE, lab2); genexception(dc, EXCPRANGE); gensetlabel(lab1); tcggendivutl(cpuR[rd], cpuR[ra], cpuR[rb]); gensetlabel(lab2); } tcgtempfreei32(srove); } break; default: genillegalexception(dc); break; } break; case 0x000b: switch (op1) { case 0x03: /* l.mulu */ LOGDIS(\"l.mulu r%d, r%d, r%d\\n\", rd, ra, rb); if (rb != 0 && ra != 0) { TCGvi64 result = tcgtemplocalnewi64(); TCGvi64 tra = tcgtemplocalnewi64(); TCGvi64 trb = tcgtemplocalnewi64(); TCGvi64 high = tcgtempnewi64(); TCGvi32 srove = tcgtemplocalnewi32(); int lab = gennewlabel(); /* Calculate each result. */ tcggenextui32i64(tra, cpuR[ra]); tcggenextui32i64(trb, cpuR[rb]); tcggenmuli64(result, tra, trb); tcgtempfreei64(tra); tcgtempfreei64(trb); tcggenshrii64(high, result, TARGETLONGBITS); /* Overflow or not. */ tcggenbrcondii64(TCGCONDEQ, high, 0x00000000, lab); tcggenoritl(cpusr, cpusr, (SROV | SRCY)); tcggenanditl(srove, cpusr, SROVE); tcggenbrconditl(TCGCONDNE, srove, SROVE, lab); genexception(dc, EXCPRANGE); gensetlabel(lab); tcgtempfreei64(high); tcggentrunci64tl(cpuR[rd], result); tcgtempfreei64(result); tcgtempfreei32(srove); } else { tcggenmovitl(cpuR[rd], 0); } break; default: genillegalexception(dc); break; } break; case 0x000e: switch (op1) { case 0x00: /* l.cmov */ LOGDIS(\"l.cmov r%d, r%d, r%d\\n\", rd, ra, rb); { int lab = gennewlabel(); TCGv res = tcgtemplocalnew(); TCGv srf = tcgtempnew(); tcggenanditl(srf, cpusr, SRF); tcggenmovtl(res, cpuR[rb]); tcggenbrconditl(TCGCONDNE, srf, SRF, lab); tcggenmovtl(res, cpuR[ra]); gensetlabel(lab); tcggenmovtl(cpuR[rd], res); tcgtempfree(srf); tcgtempfree(res); } break; default: genillegalexception(dc); break; } break; case 0x000f: switch (op1) { case 0x00: /* l.ff1 */ LOGDIS(\"l.ff1 r%d, r%d, r%d\\n\", rd, ra, rb); genhelperff1(cpuR[rd], cpuR[ra]); break; case 0x01: /* l.fl1 */ LOGDIS(\"l.fl1 r%d, r%d, r%d\\n\", rd, ra, rb); genhelperfl1(cpuR[rd], cpuR[ra]); break; default: genillegalexception(dc); break; } break; case 0x0008: switch (op1) { case 0x00: switch (op2) { case 0x00: /* l.sll */ LOGDIS(\"l.sll r%d, r%d, r%d\\n\", rd, ra, rb); tcggenshltl(cpuR[rd], cpuR[ra], cpuR[rb]); break; case 0x01: /* l.srl */ LOGDIS(\"l.srl r%d, r%d, r%d\\n\", rd, ra, rb); tcggenshrtl(cpuR[rd], cpuR[ra], cpuR[rb]); break; case 0x02: /* l.sra */ LOGDIS(\"l.sra r%d, r%d, r%d\\n\", rd, ra, rb); tcggensartl(cpuR[rd], cpuR[ra], cpuR[rb]); break; case 0x03: /* l.ror */ LOGDIS(\"l.ror r%d, r%d, r%d\\n\", rd, ra, rb); tcggenrotrtl(cpuR[rd], cpuR[ra], cpuR[rb]); break; default: genillegalexception(dc); break; } break; default: genillegalexception(dc); break; } break; case 0x000c: switch (op1) { case 0x00: switch (op2) { case 0x00: /* l.exths */ LOGDIS(\"l.exths r%d, r%d\\n\", rd, ra); tcggenext16stl(cpuR[rd], cpuR[ra]); break; case 0x01: /* l.extbs */ LOGDIS(\"l.extbs r%d, r%d\\n\", rd, ra); tcggenext8stl(cpuR[rd], cpuR[ra]); break; case 0x02: /* l.exthz */ LOGDIS(\"l.exthz r%d, r%d\\n\", rd, ra); tcggenext16utl(cpuR[rd], cpuR[ra]); break; case 0x03: /* l.extbz */ LOGDIS(\"l.extbz r%d, r%d\\n\", rd, ra); tcggenext8utl(cpuR[rd], cpuR[ra]); break; default: genillegalexception(dc); break; } break; default: genillegalexception(dc); break; } break; case 0x000d: switch (op1) { case 0x00: switch (op2) { case 0x00: /* l.extws */ LOGDIS(\"l.extws r%d, r%d\\n\", rd, ra); tcggenext32stl(cpuR[rd], cpuR[ra]); break; case 0x01: /* l.extwz */ LOGDIS(\"l.extwz r%d, r%d\\n\", rd, ra); tcggenext32utl(cpuR[rd], cpuR[ra]); break; default: genillegalexception(dc); break; } break; default: genillegalexception(dc); break; } break; default: genillegalexception(dc); break; } } ", "target": 0}
{"func": "QEMUClockType timerlistgetclock(QEMUTimerList *timerlist) { return timerlist->clock->type; } ", "target": 0}
{"func": "void palette8tobgr16(const uint8t *src, uint8t *dst, long numpixels, const uint8t *palette) { \tlong i; \tfor(i=0; i<numpixels; i++) \t\t((uint16t *)dst)[i] = bswap16(((uint16t *)palette)[ src[i] ]); } ", "target": 1}
{"func": "static void qiochannelcommandfinalize(Object *obj) { QIOChannelCommand *ioc = QIOCHANNELCOMMAND(obj); if (ioc->readfd != -1) { close(ioc->readfd); ioc->readfd = -1; } if (ioc->writefd != -1) { close(ioc->writefd); ioc->writefd = -1; } if (ioc->pid > 0) { #ifndef WIN32 qiochannelcommandabort(ioc, NULL); #endif } } ", "target": 1}
{"func": "static int readgab2sub(AVStream *st, AVPacket *pkt) { if (!strcmp(pkt->data, \"GAB2\") && AVRL16(pkt->data+5) == 2) { uint8t desc[256]; int score = AVPROBESCOREMAX / 2, ret; AVIStream *ast = st->privdata; AVInputFormat *subdemuxer; AVRational timebase; AVIOContext *pb = avioalloccontext( pkt->data + 7, pkt->size - 7, 0, NULL, NULL, NULL, NULL); AVProbeData pd; unsigned int desclen = aviorl32(pb); if (desclen > pb->bufend - pb->bufptr) goto error; ret = aviogetstr16le(pb, desclen, desc, sizeof(desc)); avioskip(pb, desclen - ret); if (*desc) avdictset(&st->metadata, \"title\", desc, 0); aviorl16(pb); /* flags? */ aviorl32(pb); /* data size */ pd = (AVProbeData) { .buf = pb->bufptr, .bufsize = pb->bufend - pb->bufptr }; if (!(subdemuxer = avprobeinputformat2(&pd, 1, &score))) goto error; if (!(ast->subctx = avformatalloccontext())) goto error; ast->subctx->pb = pb; if (!avformatopeninput(&ast->subctx, \"\", subdemuxer, NULL)) { ffreadpacket(ast->subctx, &ast->subpkt); *st->codec = *ast->subctx->streams[0]->codec; ast->subctx->streams[0]->codec->extradata = NULL; timebase = ast->subctx->streams[0]->timebase; avprivsetptsinfo(st, 64, timebase.num, timebase.den); } ast->subbuffer = pkt->data; memset(pkt, 0, sizeof(*pkt)); return 1; error: avfreep(&pb); } return 0; } ", "target": 1}
{"func": "int avsetstring3(void *obj, const char *name, const char *val, int alloc, const AVOption **oout) { int ret; const AVOption *o = avoptfind(obj, name, NULL, 0, 0); if (oout) *oout = o; if (!o) return AVERROROPTIONNOTFOUND; if (!val || o->offset<=0) return AVERROR(EINVAL); if (o->type == FFOPTTYPEBINARY) { uint8t **dst = (uint8t **)(((uint8t*)obj) + o->offset); int *lendst = (int *)(dst + 1); uint8t *bin, *ptr; int len = strlen(val); avfreep(dst); *lendst = 0; if (len & 1) return AVERROR(EINVAL); len /= 2; ptr = bin = avmalloc(len); while (*val) { int a = hexchar2int(*val++); int b = hexchar2int(*val++); if (a < 0 || b < 0) { avfree(bin); return AVERROR(EINVAL); } *ptr++ = (a << 4) | b; } *dst = bin; *lendst = len; return 0; } if (o->type != FFOPTTYPESTRING) { int notfirst=0; for (;;) { int i; char buf[256]; int cmd=0; double d; if (*val == '+' || *val == '-') cmd= *(val++); for (i=0; i<sizeof(buf)-1 && val[i] && val[i]!='+' && val[i]!='-'; i++) buf[i]= val[i]; buf[i]=0; { const AVOption *onamed = avoptfind(obj, buf, o->unit, 0, 0); if (onamed && onamed->type == FFOPTTYPECONST) d= onamed->defaultval.dbl; else if (!strcmp(buf, \"default\")) d= o->defaultval.dbl; else if (!strcmp(buf, \"max\" )) d= o->max; else if (!strcmp(buf, \"min\" )) d= o->min; else if (!strcmp(buf, \"none\" )) d= 0; else if (!strcmp(buf, \"all\" )) d= ~0; else { int res = avexprparseandeval(&d, buf, constnames, constvalues, NULL, NULL, NULL, NULL, NULL, 0, obj); if (res < 0) { avlog(obj, AVLOGERROR, \"Unable to parse option value \\\"%s\\\"\\n\", val); return res; } } } if (o->type == FFOPTTYPEFLAGS) { if (cmd=='+') d= avgetint(obj, name, NULL) | (int64t)d; else if (cmd=='-') d= avgetint(obj, name, NULL) &~(int64t)d; } else { if (cmd=='+') d= notfirst*avgetdouble(obj, name, NULL) + d; else if (cmd=='-') d= notfirst*avgetdouble(obj, name, NULL) - d; } if ((ret = avsetnumber2(obj, name, d, 1, 1, oout)) < 0) return ret; val+= i; if (!*val) return 0; notfirst=1; } return AVERROR(EINVAL); } if (alloc) { avfree(*(void**)(((uint8t*)obj) + o->offset)); val= avstrdup(val); } memcpy(((uint8t*)obj) + o->offset, &val, sizeof(val)); return 0; } ", "target": 0}
{"func": "void ffh264hlpfchromaintermsa(uint8t *data, int imgwidth, int alpha, int beta, int8t *tc) { uint8t bs0 = 1; uint8t bs1 = 1; uint8t bs2 = 1; uint8t bs3 = 1; if (tc[0] < 0) bs0 = 0; if (tc[1] < 0) bs1 = 0; if (tc[2] < 0) bs2 = 0; if (tc[3] < 0) bs3 = 0; avcloopfiltercborcrinteredgevermsa(data, bs0, bs1, bs2, bs3, tc[0], tc[1], tc[2], tc[3], alpha, beta, imgwidth); } ", "target": 0}
{"func": "void slirpselectpoll(fdset *readfds, fdset *writefds, fdset *xfds, int selecterror) { Slirp *slirp; struct socket *so, *sonext; int ret; if (QTAILQEMPTY(&slirpinstances)) { return; } globalreadfds = readfds; globalwritefds = writefds; globalxfds = xfds; curtime = qemugetclockms(rtclock); QTAILQFOREACH(slirp, &slirpinstances, entry) { \t/* \t * See if anything has timed out \t */ \t\tif (timefasttimo && ((curtime - timefasttimo) >= 2)) { \t\t\ttcpfasttimo(slirp); \t\t\ttimefasttimo = 0; \t\t} \t\tif (doslowtimo && ((curtime - lastslowtimo) >= 499)) { \t\t\tipslowtimo(slirp); \t\t\ttcpslowtimo(slirp); \t\t\tlastslowtimo = curtime; \t\t} \t/* \t * Check sockets \t */ \tif (!selecterror) { \t\t/* \t\t * Check TCP sockets \t\t */ \t\tfor (so = slirp->tcb.sonext; so != &slirp->tcb; \t\t so = sonext) { \t\t\tsonext = so->sonext; \t\t\t/* \t\t\t * FDISSET is meaningless on these sockets \t\t\t * (and they can crash the program) \t\t\t */ \t\t\tif (so->sostate & SSNOFDREF || so->s == -1) \t\t\t continue; \t\t\t/* \t\t\t * Check for URG data \t\t\t * This will soread as well, so no need to \t\t\t * test for readfds below if this succeeds \t\t\t */ \t\t\tif (FDISSET(so->s, xfds)) \t\t\t sorecvoob(so); \t\t\t/* \t\t\t * Check sockets for reading \t\t\t */ \t\t\telse if (FDISSET(so->s, readfds)) { \t\t\t\t/* \t\t\t\t * Check for incoming connections \t\t\t\t */ \t\t\t\tif (so->sostate & SSFACCEPTCONN) { \t\t\t\t\ttcpconnect(so); \t\t\t\t\tcontinue; \t\t\t\t} /* else */ \t\t\t\tret = soread(so); \t\t\t\t/* Output it if we read something */ \t\t\t\tif (ret > 0) \t\t\t\t tcpoutput(sototcpcb(so)); \t\t\t} \t\t\t/* \t\t\t * Check sockets for writing \t\t\t */ \t\t\tif (FDISSET(so->s, writefds)) { \t\t\t /* \t\t\t * Check for non-blocking, still-connecting sockets \t\t\t */ \t\t\t if (so->sostate & SSISFCONNECTING) { \t\t\t /* Connected */ \t\t\t so->sostate &= ~SSISFCONNECTING; \t\t\t ret = send(so->s, (const void *) &ret, 0, 0); \t\t\t if (ret < 0) { \t\t\t /* XXXXX Must fix, zero bytes is a NOP */ \t\t\t if (errno == EAGAIN || errno == EWOULDBLOCK || \t\t\t\t errno == EINPROGRESS || errno == ENOTCONN) \t\t\t\tcontinue; \t\t\t /* else failed */ \t\t\t so->sostate &= SSPERSISTENTMASK; \t\t\t so->sostate |= SSNOFDREF; \t\t\t } \t\t\t /* else so->sostate &= ~SSISFCONNECTING; */ \t\t\t /* \t\t\t * Continue tcpinput \t\t\t */ \t\t\t tcpinput((struct mbuf *)NULL, sizeof(struct ip), so); \t\t\t /* continue; */ \t\t\t } else \t\t\t ret = sowrite(so); \t\t\t /* \t\t\t * XXXXX If we wrote something (a lot), there \t\t\t * could be a need for a window update. \t\t\t * In the worst case, the remote will send \t\t\t * a window probe to get things going again \t\t\t */ \t\t\t} \t\t\t/* \t\t\t * Probe a still-connecting, non-blocking socket \t\t\t * to check if it's still alive \t \t \t */ #ifdef PROBECONN \t\t\tif (so->sostate & SSISFCONNECTING) { ret = qemurecv(so->s, &ret, 0,0); \t\t\t if (ret < 0) { \t\t\t /* XXX */ \t\t\t if (errno == EAGAIN || errno == EWOULDBLOCK || \t\t\t\terrno == EINPROGRESS || errno == ENOTCONN) \t\t\t continue; /* Still connecting, continue */ \t\t\t /* else failed */ \t\t\t so->sostate &= SSPERSISTENTMASK; \t\t\t so->sostate |= SSNOFDREF; \t\t\t /* tcpinput will take care of it */ \t\t\t } else { \t\t\t ret = send(so->s, &ret, 0,0); \t\t\t if (ret < 0) { \t\t\t /* XXX */ \t\t\t if (errno == EAGAIN || errno == EWOULDBLOCK || \t\t\t\t errno == EINPROGRESS || errno == ENOTCONN) \t\t\t\tcontinue; \t\t\t /* else failed */ \t\t\t so->sostate &= SSPERSISTENTMASK; \t\t\t so->sostate |= SSNOFDREF; \t\t\t } else \t\t\t so->sostate &= ~SSISFCONNECTING; \t\t\t } \t\t\t tcpinput((struct mbuf *)NULL, sizeof(struct ip),so); \t\t\t} /* SSISFCONNECTING */ #endif \t\t} \t\t/* \t\t * Now UDP sockets. \t\t * Incoming packets are sent straight away, they're not buffered. \t\t * Incoming UDP data isn't buffered either. \t\t */ \t\tfor (so = slirp->udb.sonext; so != &slirp->udb; \t\t so = sonext) { \t\t\tsonext = so->sonext; \t\t\tif (so->s != -1 && FDISSET(so->s, readfds)) { sorecvfrom(so); } \t\t} /* * Check incoming ICMP relies. */ for (so = slirp->icmp.sonext; so != &slirp->icmp; so = sonext) { sonext = so->sonext; if (so->s != -1 && FDISSET(so->s, readfds)) { icmpreceive(so); } } \t} \t/* \t * See if we can start outputting \t */ \tif (slirp->ifqueued) { \t ifstart(slirp); \t} } \t/* clear global file descriptor sets. \t * these reside on the stack in vl.c \t * so they're unusable if we're not in \t * slirpselectfill or slirpselectpoll. \t */ \t globalreadfds = NULL; \t globalwritefds = NULL; \t globalxfds = NULL; } ", "target": 0}
{"func": "uint64t helpercmpbge (uint64t op1, uint64t op2) { uint8t opa, opb, res; int i; res = 0; for (i = 0; i < 7; i++) { opa = op1 >> (i * 8); opb = op2 >> (i * 8); if (opa >= opb) res |= 1 << i; } return res; } ", "target": 0}
{"func": "static int s390iplinit(SysBusDevice *dev) { S390IPLState *ipl = S390IPL(dev); uint64t pentry = KERNIMAGESTART; int kernelsize; int biossize; char *biosfilename; /* * Always load the bios if it was enforced, * even if an external kernel has been defined. */ if (!ipl->kernel || ipl->enforcebios) { uint64t fwbase = (MIN(ramsize, 0x80000000U) - 0x200000) & ~0xffffUL; if (biosname == NULL) { biosname = ipl->firmware; } biosfilename = qemufindfile(QEMUFILETYPEBIOS, biosname); if (biosfilename == NULL) { hwerror(\"could not find stage1 bootloader\\n\"); } biossize = loadelf(biosfilename, biostranslateaddr, &fwbase, &ipl->biosstartaddr, NULL, NULL, 1, ELFMACHINE, 0); if (biossize > 0) { /* Adjust ELF start address to final location */ ipl->biosstartaddr += fwbase; } else { /* Try to load non-ELF file (e.g. s390-zipl.rom) */ biossize = loadimagetargphys(biosfilename, ZIPLIMAGESTART, 4096); ipl->biosstartaddr = ZIPLIMAGESTART; if (biossize > 4096) { hwerror(\"stage1 bootloader is > 4k\\n\"); } } gfree(biosfilename); if (biossize == -1) { hwerror(\"could not load bootloader '%s'\\n\", biosname); } /* default boot target is the bios */ ipl->startaddr = ipl->biosstartaddr; } if (ipl->kernel) { kernelsize = loadelf(ipl->kernel, NULL, NULL, &pentry, NULL, NULL, 1, ELFMACHINE, 0); if (kernelsize < 0) { kernelsize = loadimagetargphys(ipl->kernel, 0, ramsize); } if (kernelsize < 0) { fprintf(stderr, \"could not load kernel '%s'\\n\", ipl->kernel); return -1; } /* * Is it a Linux kernel (starting at 0x10000)? If yes, we fill in the * kernel parameters here as well. Note: For old kernels (up to 3.2) * we can not rely on the ELF entry point - it was 0x800 (the SALIPL * loader) and it won't work. For this case we force it to 0x10000, too. */ if (pentry == KERNIMAGESTART || pentry == 0x800) { ipl->startaddr = KERNIMAGESTART; /* Overwrite parameters in the kernel image, which are \"rom\" */ strcpy(romptr(KERNPARMAREA), ipl->cmdline); } else { ipl->startaddr = pentry; } if (ipl->initrd) { ramaddrt initrdoffset; int initrdsize; initrdoffset = INITRDSTART; while (kernelsize + 0x100000 > initrdoffset) { initrdoffset += 0x100000; } initrdsize = loadimagetargphys(ipl->initrd, initrdoffset, ramsize - initrdoffset); if (initrdsize == -1) { fprintf(stderr, \"qemu: could not load initrd '%s'\\n\", ipl->initrd); exit(1); } /* * we have to overwrite values in the kernel image, * which are \"rom\" */ stqp(romptr(INITRDPARMSTART), initrdoffset); stqp(romptr(INITRDPARMSIZE), initrdsize); } } return 0; } ", "target": 0}
{"func": "static int virtconparse(const char *devname) { QemuOptsList *device = qemufindopts(\"device\"); static int index = 0; char label[32]; QemuOpts *busopts, *devopts; if (strcmp(devname, \"none\") == 0) return 0; if (index == MAXVIRTIOCONSOLES) { fprintf(stderr, \"qemu: too many virtio consoles\\n\"); exit(1); } busopts = qemuoptscreate(device, NULL, 0); if (archtype == QEMUARCHS390X) { qemuoptset(busopts, \"driver\", \"virtio-serial-s390\"); } else { qemuoptset(busopts, \"driver\", \"virtio-serial-pci\"); } devopts = qemuoptscreate(device, NULL, 0); qemuoptset(devopts, \"driver\", \"virtconsole\"); snprintf(label, sizeof(label), \"virtcon%d\", index); virtconhds[index] = qemuchrnew(label, devname, NULL); if (!virtconhds[index]) { fprintf(stderr, \"qemu: could not open virtio console '%s': %s\\n\", devname, strerror(errno)); return -1; } qemuoptset(devopts, \"chardev\", label); index++; return 0; } ", "target": 1}
{"func": "static void monitorputs(Monitor *mon, const char *str) { char c; for(;;) { c = *str++; if (c == '\\0') break; if (c == '\\n') { qstringappendchr(mon->outbuf, '\\r'); } qstringappendchr(mon->outbuf, c); if (c == '\\n') { monitorflush(mon); } } } ", "target": 0}
{"func": "static void genmovlsegT0(DisasContext *s, int segreg) { if (s->pe && !s->vm86) { tcggentrunctli32(cputmp2i32, cpuT0); genhelperloadseg(cpuenv, tcgconsti32(segreg), cputmp2i32); /* abort translation because the addseg value may change or because ss32 may change. For RSS, translation must always stop as a special handling must be done to disable hardware interrupts for the next instruction */ if (segreg == RSS || (s->code32 && segreg < RFS)) s->isjmp = DISASTBJUMP; } else { genopmovlsegT0vm(segreg); if (segreg == RSS) s->isjmp = DISASTBJUMP; } } ", "target": 0}
{"func": "void genintermediatecodea64(ARMCPU *cpu, TranslationBlock *tb) { CPUState *cs = CPU(cpu); CPUARMState *env = &cpu->env; DisasContext dc1, *dc = &dc1; targetulong pcstart; targetulong nextpagestart; int numinsns; int maxinsns; pcstart = tb->pc; dc->tb = tb; dc->isjmp = DISASNEXT; dc->pc = pcstart; dc->singlestepenabled = cs->singlestepenabled; dc->condjmp = 0; dc->aarch64 = 1; /* If we are coming from secure EL0 in a system with a 32-bit EL3, then * there is no secure EL1, so we route exceptions to EL3. */ dc->secureroutedtoel3 = armfeature(env, ARMFEATUREEL3) && !armelisaa64(env, 3); dc->thumb = 0; dc->bswapcode = 0; dc->condexecmask = 0; dc->condexeccond = 0; dc->mmuidx = ARMTBFLAGMMUIDX(tb->flags); dc->currentel = armmmuidxtoel(dc->mmuidx); #if !defined(CONFIGUSERONLY) dc->user = (dc->currentel == 0); #endif dc->fpexcpel = ARMTBFLAGFPEXCEL(tb->flags); dc->veclen = 0; dc->vecstride = 0; dc->cpregs = cpu->cpregs; dc->features = env->features; /* Single step state. The code-generation logic here is: * SSACTIVE == 0: * generate code with no special handling for single-stepping (except * that anything that can make us go to SSACTIVE == 1 must end the TB; * this happens anyway because those changes are all system register or * PSTATE writes). * SSACTIVE == 1, PSTATE.SS == 1: (active-not-pending) * emit code for one insn * emit code to clear PSTATE.SS * emit code to generate software step exception for completed step * end TB (as usual for having generated an exception) * SSACTIVE == 1, PSTATE.SS == 0: (active-pending) * emit code to generate a software step exception * end the TB */ dc->ssactive = ARMTBFLAGSSACTIVE(tb->flags); dc->pstatess = ARMTBFLAGPSTATESS(tb->flags); dc->isldex = false; dc->sssameel = (armdebugtargetel(env) == dc->currentel); inittmpa64array(dc); nextpagestart = (pcstart & TARGETPAGEMASK) + TARGETPAGESIZE; numinsns = 0; maxinsns = tb->cflags & CFCOUNTMASK; if (maxinsns == 0) { maxinsns = CFCOUNTMASK; } if (maxinsns > TCGMAXINSNS) { maxinsns = TCGMAXINSNS; } gentbstart(tb); tcgcleartempcount(); do { tcggeninsnstart(dc->pc, 0); numinsns++; if (unlikely(!QTAILQEMPTY(&cs->breakpoints))) { CPUBreakpoint *bp; QTAILQFOREACH(bp, &cs->breakpoints, entry) { if (bp->pc == dc->pc) { genexceptioninternalinsn(dc, 0, EXCPDEBUG); /* Advance PC so that clearing the breakpoint will invalidate this TB. */ dc->pc += 2; goto donegenerating; } } } if (numinsns == maxinsns && (tb->cflags & CFLASTIO)) { geniostart(); } if (dc->ssactive && !dc->pstatess) { /* Singlestep state is Active-pending. * If we're in this state at the start of a TB then either * a) we just took an exception to an EL which is being debugged * and this is the first insn in the exception handler * b) debug exceptions were masked and we just unmasked them * without changing EL (eg by clearing PSTATE.D) * In either case we're going to take a swstep exception in the * \"did not step an insn\" case, and so the syndrome ISV and EX * bits should be zero. */ assert(numinsns == 1); genexception(EXCPUDEF, synswstep(dc->sssameel, 0, 0), defaultexceptionel(dc)); dc->isjmp = DISASEXC; break; } disasa64insn(env, dc); if (tcgchecktempcount()) { fprintf(stderr, \"TCG temporary leak before \"TARGETFMTlx\"\\n\", dc->pc); } /* Translation stops when a conditional branch is encountered. * Otherwise the subsequent code could get translated several times. * Also stop translation when a page boundary is reached. This * ensures prefetch aborts occur at the right place. */ } while (!dc->isjmp && !tcgopbuffull() && !cs->singlestepenabled && !singlestep && !dc->ssactive && dc->pc < nextpagestart && numinsns < maxinsns); if (tb->cflags & CFLASTIO) { genioend(); } if (unlikely(cs->singlestepenabled || dc->ssactive) && dc->isjmp != DISASEXC) { /* Note that this means single stepping WFI doesn't halt the CPU. * For conditional branch insns this is harmless unreachable code as * gengototb() has already handled emitting the debug exception * (and thus a tb-jump is not possible when singlestepping). */ assert(dc->isjmp != DISASTBJUMP); if (dc->isjmp != DISASJUMP) { gena64setpcim(dc->pc); } if (cs->singlestepenabled) { genexceptioninternal(EXCPDEBUG); } else { genstepcompleteexception(dc); } } else { switch (dc->isjmp) { case DISASNEXT: gengototb(dc, 1, dc->pc); break; default: case DISASUPDATE: gena64setpcim(dc->pc); /* fall through */ case DISASJUMP: /* indicate that the hash table must be used to find the next TB */ tcggenexittb(0); break; case DISASTBJUMP: case DISASEXC: case DISASSWI: break; case DISASWFE: gena64setpcim(dc->pc); genhelperwfe(cpuenv); break; case DISASYIELD: gena64setpcim(dc->pc); genhelperyield(cpuenv); break; case DISASWFI: /* This is a special case because we don't want to just halt the CPU * if trying to debug across a WFI. */ gena64setpcim(dc->pc); genhelperwfi(cpuenv); /* The helper doesn't necessarily throw an exception, but we * must go back to the main loop to check for interrupts anyway. */ tcggenexittb(0); break; } } donegenerating: gentbend(tb, numinsns); #ifdef DEBUGDISAS if (qemuloglevelmask(CPULOGTBINASM)) { qemulog(\"----------------\\n\"); qemulog(\"IN: %s\\n\", lookupsymbol(pcstart)); logtargetdisas(cs, pcstart, dc->pc - pcstart, 4 | (dc->bswapcode << 1)); qemulog(\"\\n\"); } #endif tb->size = dc->pc - pcstart; tb->icount = numinsns; } ", "target": 0}
{"func": "static int movreadstsc(MOVContext *c, AVIOContext *pb, MOVAtom atom) { AVStream *st; MOVStreamContext *sc; unsigned int i, entries; if (c->fc->nbstreams < 1) return 0; st = c->fc->streams[c->fc->nbstreams-1]; sc = st->privdata; avior8(pb); /* version */ aviorb24(pb); /* flags */ entries = aviorb32(pb); avlog(c->fc, AVLOGTRACE, \"track[%i].stsc.entries = %i\\n\", c->fc->nbstreams-1, entries); if (!entries) return 0; if (entries >= UINTMAX / sizeof(*sc->stscdata)) return AVERRORINVALIDDATA; sc->stscdata = avmalloc(entries * sizeof(*sc->stscdata)); if (!sc->stscdata) return AVERROR(ENOMEM); for (i = 0; i < entries && !pb->eofreached; i++) { sc->stscdata[i].first = aviorb32(pb); sc->stscdata[i].count = aviorb32(pb); sc->stscdata[i].id = aviorb32(pb); if (sc->stscdata[i].id < 0 || sc->stscdata[i].id > sc->stsdcount) { sc->stscdata[i].id = 0; if (c->fc->errorrecognition & AVEFEXPLODE) { avlog(c->fc, AVLOGERROR, \"Invalid stsc index.\\n\"); return AVERRORINVALIDDATA; } } } sc->stsccount = i; if (pb->eofreached) return AVERROREOF; return 0; } ", "target": 0}
{"func": "static int decodecopy(uint8t *frame, int width, int height, const uint8t *src, const uint8t *srcend) { const int size = width * height; if (srcend - src < size) return -1; bytestreamgetbuffer(&src, frame, size); return 0; } ", "target": 1}
{"func": "static uint16t nvmeiocmd(NvmeCtrl *n, NvmeCmd *cmd, NvmeRequest *req) { NvmeNamespace *ns; uint32t nsid = le32tocpu(cmd->nsid); if (nsid == 0 || nsid > n->numnamespaces) { return NVMEINVALIDNSID | NVMEDNR; } ns = &n->namespaces[nsid - 1]; switch (cmd->opcode) { case NVMECMDFLUSH: return nvmeflush(n, ns, cmd, req); case NVMECMDWRITEZEROS: return nvmewritezeros(n, ns, cmd, req); case NVMECMDWRITE: case NVMECMDREAD: return nvmerw(n, ns, cmd, req); default: return NVMEINVALIDOPCODE | NVMEDNR; } } ", "target": 1}
{"func": "void avfilterlinkfree(AVFilterLink **link) { if (!*link) return; if ((*link)->pool) { int i; for (i = 0; i < POOLSIZE; i++) { if ((*link)->pool->pic[i]) { AVFilterBufferRef *picref = (*link)->pool->pic[i]; /* free buffer: picrefs stored in the pool are not * supposed to contain a free callback */ avfreep(&picref->buf->data[0]); avfreep(&picref->buf); avfreep(&picref->audio); avfreep(&picref->video); avfreep(&picref); } } avfreep(&(*link)->pool); } avfreep(link); } ", "target": 1}
{"func": "static uint64t pl110read(void *opaque, hwaddr offset, unsigned size) { pl110state *s = (pl110state *)opaque; if (offset >= 0xfe0 && offset < 0x1000) { return idregs[s->version][(offset - 0xfe0) >> 2]; } if (offset >= 0x200 && offset < 0x400) { return s->rawpalette[(offset - 0x200) >> 2]; } switch (offset >> 2) { case 0: /* LCDTiming0 */ return s->timing[0]; case 1: /* LCDTiming1 */ return s->timing[1]; case 2: /* LCDTiming2 */ return s->timing[2]; case 3: /* LCDTiming3 */ return s->timing[3]; case 4: /* LCDUPBASE */ return s->upbase; case 5: /* LCDLPBASE */ return s->lpbase; case 6: /* LCDIMSC */ if (s->version != PL110) { return s->cr; } return s->intmask; case 7: /* LCDControl */ if (s->version != PL110) { return s->intmask; } return s->cr; case 8: /* LCDRIS */ return s->intstatus; case 9: /* LCDMIS */ return s->intstatus & s->intmask; case 11: /* LCDUPCURR */ /* TODO: Implement vertical refresh. */ return s->upbase; case 12: /* LCDLPCURR */ return s->lpbase; default: hwerror(\"pl110read: Bad offset %x\\n\", (int)offset); return 0; } } ", "target": 0}
{"func": "static void fillcodingmethodarray (sbint8array tonelevelidx, sbint8array tonelevelidxtemp, sbint8array codingmethod, int nbchannels, int c, int superblocktype23, int cmtableselect) { int ch, sb, j; int tmp, acc, esp40, comp; int add1, add2, add3, add4; int64t multres; // This should never happen if (nbchannels <= 0) return; if (!superblocktype23) { /* This case is untested, no samples available */ SAMPLESNEEDED for (ch = 0; ch < nbchannels; ch++) for (sb = 0; sb < 30; sb++) { for (j = 1; j < 63; j++) { // The loop only iterates to 63 so the code doesn't overflow the buffer add1 = tonelevelidx[ch][sb][j] - 10; if (add1 < 0) add1 = 0; add2 = add3 = add4 = 0; if (sb > 1) { add2 = tonelevelidx[ch][sb - 2][j] + tonelevelidxoffsettable[sb][0] - 6; if (add2 < 0) add2 = 0; } if (sb > 0) { add3 = tonelevelidx[ch][sb - 1][j] + tonelevelidxoffsettable[sb][1] - 6; if (add3 < 0) add3 = 0; } if (sb < 29) { add4 = tonelevelidx[ch][sb + 1][j] + tonelevelidxoffsettable[sb][3] - 6; if (add4 < 0) add4 = 0; } tmp = tonelevelidx[ch][sb][j + 1] * 2 - add4 - add3 - add2 - add1; if (tmp < 0) tmp = 0; tonelevelidxtemp[ch][sb][j + 1] = tmp & 0xff; } tonelevelidxtemp[ch][sb][0] = tonelevelidxtemp[ch][sb][1]; } acc = 0; for (ch = 0; ch < nbchannels; ch++) for (sb = 0; sb < 30; sb++) for (j = 0; j < 64; j++) acc += tonelevelidxtemp[ch][sb][j]; multres = 0x66666667 * (acc * 10); esp40 = (multres >> 32) / 8 + ((multres & 0xffffffff) >> 31); for (ch = 0; ch < nbchannels; ch++) for (sb = 0; sb < 30; sb++) for (j = 0; j < 64; j++) { comp = tonelevelidxtemp[ch][sb][j]* esp40 * 10; if (comp < 0) comp += 0xff; comp /= 256; // signed shift switch(sb) { case 0: if (comp < 30) comp = 30; comp += 15; break; case 1: if (comp < 24) comp = 24; comp += 10; break; case 2: case 3: case 4: if (comp < 16) comp = 16; } if (comp <= 5) tmp = 0; else if (comp <= 10) tmp = 10; else if (comp <= 16) tmp = 16; else if (comp <= 24) tmp = -1; else tmp = 0; codingmethod[ch][sb][j] = ((tmp & 0xfffa) + 30 )& 0xff; } for (sb = 0; sb < 30; sb++) fixcodingmethodarray(sb, nbchannels, codingmethod); for (ch = 0; ch < nbchannels; ch++) for (sb = 0; sb < 30; sb++) for (j = 0; j < 64; j++) if (sb >= 10) { if (codingmethod[ch][sb][j] < 10) codingmethod[ch][sb][j] = 10; } else { if (sb >= 2) { if (codingmethod[ch][sb][j] < 16) codingmethod[ch][sb][j] = 16; } else { if (codingmethod[ch][sb][j] < 30) codingmethod[ch][sb][j] = 30; } } } else { // superblocktype23 != 0 for (ch = 0; ch < nbchannels; ch++) for (sb = 0; sb < 30; sb++) for (j = 0; j < 64; j++) codingmethod[ch][sb][j] = codingmethodtable[cmtableselect][sb]; } return; } ", "target": 0}
{"func": "void armcpudumpstate(CPUState *cs, FILE *f, fprintffunction cpufprintf, int flags) { ARMCPU *cpu = ARMCPU(cs); CPUARMState *env = &cpu->env; int i; if (isa64(env)) { aarch64cpudumpstate(cs, f, cpufprintf, flags); return; } for(i=0;i<16;i++) { cpufprintf(f, \"R%02d=%08x\", i, env->regs[i]); if ((i % 4) == 3) cpufprintf(f, \"\\n\"); else cpufprintf(f, \" \"); } if (armfeature(env, ARMFEATUREM)) { uint32t xpsr = xpsrread(env); const char *mode; if (xpsr & XPSREXCP) { mode = \"handler\"; } else { if (env->v7m.control & RV7MCONTROLNPRIVMASK) { mode = \"unpriv-thread\"; } else { mode = \"priv-thread\"; } } cpufprintf(f, \"XPSR=%08x %c%c%c%c %c %s\\n\", xpsr, xpsr & XPSRN ? 'N' : '-', xpsr & XPSRZ ? 'Z' : '-', xpsr & XPSRC ? 'C' : '-', xpsr & XPSRV ? 'V' : '-', xpsr & XPSRT ? 'T' : 'A', mode); } else { uint32t psr = cpsrread(env); const char *nsstatus = \"\"; if (armfeature(env, ARMFEATUREEL3) && (psr & CPSRM) != ARMCPUMODEMON) { nsstatus = env->cp15.screl3 & SCRNS ? \"NS \" : \"S \"; } cpufprintf(f, \"PSR=%08x %c%c%c%c %c %s%s%d\\n\", psr, psr & CPSRN ? 'N' : '-', psr & CPSRZ ? 'Z' : '-', psr & CPSRC ? 'C' : '-', psr & CPSRV ? 'V' : '-', psr & CPSRT ? 'T' : 'A', nsstatus, cpumodenames[psr & 0xf], (psr & 0x10) ? 32 : 26); } if (flags & CPUDUMPFPU) { int numvfpregs = 0; if (armfeature(env, ARMFEATUREVFP)) { numvfpregs += 16; } if (armfeature(env, ARMFEATUREVFP3)) { numvfpregs += 16; } for (i = 0; i < numvfpregs; i++) { uint64t v = float64val(env->vfp.regs[i]); cpufprintf(f, \"s%02d=%08x s%02d=%08x d%02d=%016\" PRIx64 \"\\n\", i * 2, (uint32t)v, i * 2 + 1, (uint32t)(v >> 32), i, v); } cpufprintf(f, \"FPSCR: %08x\\n\", (int)env->vfp.xregs[ARMVFPFPSCR]); } } ", "target": 0}
{"func": "int vmstateloadstate(QEMUFile *f, const VMStateDescription *vmsd, void *opaque, int versionid) { VMStateField *field = vmsd->fields; int ret = 0; tracevmstateloadstate(vmsd->name, versionid); if (versionid > vmsd->versionid) { errorreport(\"%s: incoming versionid %d is too new \" \"for local versionid %d\", vmsd->name, versionid, vmsd->versionid); tracevmstateloadstateend(vmsd->name, \"too new\", -EINVAL); return -EINVAL; } if (versionid < vmsd->minimumversionid) { if (vmsd->loadstateold && versionid >= vmsd->minimumversionidold) { ret = vmsd->loadstateold(f, opaque, versionid); tracevmstateloadstateend(vmsd->name, \"old path\", ret); return ret; } errorreport(\"%s: incoming versionid %d is too old \" \"for local minimum versionid %d\", vmsd->name, versionid, vmsd->minimumversionid); tracevmstateloadstateend(vmsd->name, \"too old\", -EINVAL); return -EINVAL; } if (vmsd->preload) { int ret = vmsd->preload(opaque); if (ret) { return ret; } } while (field->name) { tracevmstateloadstatefield(vmsd->name, field->name); if ((field->fieldexists && field->fieldexists(opaque, versionid)) || (!field->fieldexists && field->versionid <= versionid)) { void *firstelem = opaque + field->offset; int i, nelems = vmstatenelems(opaque, field); int size = vmstatesize(opaque, field); vmstatehandlealloc(firstelem, field, opaque); if (field->flags & VMSPOINTER) { firstelem = *(void **)firstelem; assert(firstelem || !nelems); } for (i = 0; i < nelems; i++) { void *currelem = firstelem + size * i; if (field->flags & VMSARRAYOFPOINTER) { currelem = *(void **)currelem; } if (field->flags & VMSSTRUCT) { ret = vmstateloadstate(f, field->vmsd, currelem, field->vmsd->versionid); } else { ret = field->info->get(f, currelem, size, field); } if (ret >= 0) { ret = qemufilegeterror(f); } if (ret < 0) { qemufileseterror(f, ret); errorreport(\"Failed to load %s:%s\", vmsd->name, field->name); tracevmstateloadfielderror(field->name, ret); return ret; } } } else if (field->flags & VMSMUSTEXIST) { errorreport(\"Input validation failed: %s/%s\", vmsd->name, field->name); return -1; } field++; } ret = vmstatesubsectionload(f, vmsd, opaque); if (ret != 0) { return ret; } if (vmsd->postload) { ret = vmsd->postload(opaque, versionid); } tracevmstateloadstateend(vmsd->name, \"end\", ret); return ret; } ", "target": 1}
{"func": "static void xenlogstart(MemoryListener *listener, MemoryRegionSection *section) { XenIOState *state = containerof(listener, XenIOState, memorylistener); xensyncdirtybitmap(state, section->offsetwithinaddressspace, int128get64(section->size)); } ", "target": 0}
{"func": "static void mpegvideoextractheaders(AVCodecParserContext *s, AVCodecContext *avctx, const uint8t *buf, int bufsize) { ParseContext1 *pc = s->privdata; const uint8t *bufend; uint32t startcode; int framerateindex, exttype, bytesleft; int framerateextn, framerateextd; int picturestructure, topfieldfirst, repeatfirstfield, progressiveframe; int horizsizeext, vertsizeext, bitrateext; //FIXME replace the crap with getbits() s->repeatpict = 0; bufend = buf + bufsize; while (buf < bufend) { startcode= -1; buf= fffindstartcode(buf, bufend, &startcode); bytesleft = bufend - buf; switch(startcode) { case PICTURESTARTCODE: fffetchtimestamp(s, buf-bufstart-4, 1); if (bytesleft >= 2) { s->picttype = (buf[1] >> 3) & 7; } break; case SEQSTARTCODE: if (bytesleft >= 7) { pc->width = (buf[0] << 4) | (buf[1] >> 4); pc->height = ((buf[1] & 0x0f) << 8) | buf[2]; avcodecsetdimensions(avctx, pc->width, pc->height); framerateindex = buf[3] & 0xf; pc->framerate.den = avctx->timebase.den = ffframeratetab[framerateindex].num; pc->framerate.num = avctx->timebase.num = ffframeratetab[framerateindex].den; avctx->bitrate = ((buf[4]<<10) | (buf[5]<<2) | (buf[6]>>6))*400; avctx->codecid = CODECIDMPEG1VIDEO; avctx->subid = 1; } break; case EXTSTARTCODE: if (bytesleft >= 1) { exttype = (buf[0] >> 4); switch(exttype) { case 0x1: /* sequence extension */ if (bytesleft >= 6) { horizsizeext = ((buf[1] & 1) << 1) | (buf[2] >> 7); vertsizeext = (buf[2] >> 5) & 3; bitrateext = ((buf[2] & 0x1F)<<7) | (buf[3]>>1); framerateextn = (buf[5] >> 5) & 3; framerateextd = (buf[5] & 0x1f); pc->progressivesequence = buf[1] & (1 << 3); avctx->hasbframes= !(buf[5] >> 7); pc->width |=(horizsizeext << 12); pc->height |=( vertsizeext << 12); avctx->bitrate += (bitrateext << 18) * 400; avcodecsetdimensions(avctx, pc->width, pc->height); avctx->timebase.den = pc->framerate.den * (framerateextn + 1); avctx->timebase.num = pc->framerate.num * (framerateextd + 1); avctx->codecid = CODECIDMPEG2VIDEO; avctx->subid = 2; /* forces MPEG2 */ } break; case 0x8: /* picture coding extension */ if (bytesleft >= 5) { picturestructure = buf[2]&3; topfieldfirst = buf[3] & (1 << 7); repeatfirstfield = buf[3] & (1 << 1); progressiveframe = buf[4] & (1 << 7); /* check if we must repeat the frame */ if (repeatfirstfield) { if (pc->progressivesequence) { if (topfieldfirst) s->repeatpict = 4; else s->repeatpict = 2; } else if (progressiveframe) { s->repeatpict = 1; } } } break; } } break; case -1: goto theend; default: /* we stop parsing when we encounter a slice. It ensures that this function takes a negligible amount of time */ if (startcode >= SLICEMINSTARTCODE && startcode <= SLICEMAXSTARTCODE) goto theend; break; } } theend: ; }", "target": 1}
{"func": "static void testsmbiosepaddress(testdata *data) { uint32t off; /* find smbios entry point structure */ for (off = 0xf0000; off < 0x100000; off += 0x10) { uint8t sig[] = \"SM\"; int i; for (i = 0; i < sizeof sig - 1; ++i) { sig[i] = readb(off + i); } if (!memcmp(sig, \"SM\", sizeof sig)) { break; } } gassertcmphex(off, <, 0x100000); data->smbiosepaddr = off; } ", "target": 1}
{"func": "static void movupdatedtsshift(MOVStreamContext *sc, int duration) { if (duration < 0) { sc->dtsshift = FFMAX(sc->dtsshift, -duration); ", "target": 1}
{"func": "static void fftcalcc(FFTContext *s, FFTComplex *z) { int nbits, i, n, numtransforms, offset, step; int n4, n2, n34; FFTSample tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7, tmp8; FFTComplex *tmpz; const int fftsize = (1 << s->nbits); int64t accu; numtransforms = (0x2aab >> (16 - s->nbits)) | 1; for (n=0; n<numtransforms; n++){ offset = fffftoffsetslut[n] << 2; tmpz = z + offset; tmp1 = tmpz[0].re + tmpz[1].re; tmp5 = tmpz[2].re + tmpz[3].re; tmp2 = tmpz[0].im + tmpz[1].im; tmp6 = tmpz[2].im + tmpz[3].im; tmp3 = tmpz[0].re - tmpz[1].re; tmp8 = tmpz[2].im - tmpz[3].im; tmp4 = tmpz[0].im - tmpz[1].im; tmp7 = tmpz[2].re - tmpz[3].re; tmpz[0].re = tmp1 + tmp5; tmpz[2].re = tmp1 - tmp5; tmpz[0].im = tmp2 + tmp6; tmpz[2].im = tmp2 - tmp6; tmpz[1].re = tmp3 + tmp8; tmpz[3].re = tmp3 - tmp8; tmpz[1].im = tmp4 - tmp7; tmpz[3].im = tmp4 + tmp7; } if (fftsize < 8) return; numtransforms = (numtransforms >> 1) | 1; for (n=0; n<numtransforms; n++){ offset = fffftoffsetslut[n] << 3; tmpz = z + offset; tmp1 = tmpz[4].re + tmpz[5].re; tmp3 = tmpz[6].re + tmpz[7].re; tmp2 = tmpz[4].im + tmpz[5].im; tmp4 = tmpz[6].im + tmpz[7].im; tmp5 = tmp1 + tmp3; tmp7 = tmp1 - tmp3; tmp6 = tmp2 + tmp4; tmp8 = tmp2 - tmp4; tmp1 = tmpz[4].re - tmpz[5].re; tmp2 = tmpz[4].im - tmpz[5].im; tmp3 = tmpz[6].re - tmpz[7].re; tmp4 = tmpz[6].im - tmpz[7].im; tmpz[4].re = tmpz[0].re - tmp5; tmpz[0].re = tmpz[0].re + tmp5; tmpz[4].im = tmpz[0].im - tmp6; tmpz[0].im = tmpz[0].im + tmp6; tmpz[6].re = tmpz[2].re - tmp8; tmpz[2].re = tmpz[2].re + tmp8; tmpz[6].im = tmpz[2].im + tmp7; tmpz[2].im = tmpz[2].im - tmp7; accu = (int64t)Q31(MSQRT12)*(tmp1 + tmp2); tmp5 = (int32t)((accu + 0x40000000) >> 31); accu = (int64t)Q31(MSQRT12)*(tmp3 - tmp4); tmp7 = (int32t)((accu + 0x40000000) >> 31); accu = (int64t)Q31(MSQRT12)*(tmp2 - tmp1); tmp6 = (int32t)((accu + 0x40000000) >> 31); accu = (int64t)Q31(MSQRT12)*(tmp3 + tmp4); tmp8 = (int32t)((accu + 0x40000000) >> 31); tmp1 = tmp5 + tmp7; tmp3 = tmp5 - tmp7; tmp2 = tmp6 + tmp8; tmp4 = tmp6 - tmp8; tmpz[5].re = tmpz[1].re - tmp1; tmpz[1].re = tmpz[1].re + tmp1; tmpz[5].im = tmpz[1].im - tmp2; tmpz[1].im = tmpz[1].im + tmp2; tmpz[7].re = tmpz[3].re - tmp4; tmpz[3].re = tmpz[3].re + tmp4; tmpz[7].im = tmpz[3].im + tmp3; tmpz[3].im = tmpz[3].im - tmp3; } step = 1 << ((MAXLOG2NFFT-4) - 4); n4 = 4; for (nbits=4; nbits<=s->nbits; nbits++){ n2 = 2*n4; n34 = 3*n4; numtransforms = (numtransforms >> 1) | 1; for (n=0; n<numtransforms; n++){ const FFTSample *wreptr = ffwtabsr + step; const FFTSample *wimptr = ffwtabsr + MAXFFTSIZE/(4*16) - step; offset = fffftoffsetslut[n] << nbits; tmpz = z + offset; tmp5 = tmpz[ n2].re + tmpz[n34].re; tmp1 = tmpz[ n2].re - tmpz[n34].re; tmp6 = tmpz[ n2].im + tmpz[n34].im; tmp2 = tmpz[ n2].im - tmpz[n34].im; tmpz[ n2].re = tmpz[ 0].re - tmp5; tmpz[ 0].re = tmpz[ 0].re + tmp5; tmpz[ n2].im = tmpz[ 0].im - tmp6; tmpz[ 0].im = tmpz[ 0].im + tmp6; tmpz[n34].re = tmpz[n4].re - tmp2; tmpz[ n4].re = tmpz[n4].re + tmp2; tmpz[n34].im = tmpz[n4].im + tmp1; tmpz[ n4].im = tmpz[n4].im - tmp1; for (i=1; i<n4; i++){ FFTSample wre = wreptr[0]; FFTSample wim = wimptr[0]; accu = (int64t)wre*tmpz[ n2+i].re; accu += (int64t)wim*tmpz[ n2+i].im; tmp1 = (int32t)((accu + 0x40000000) >> 31); accu = (int64t)wre*tmpz[ n2+i].im; accu -= (int64t)wim*tmpz[ n2+i].re; tmp2 = (int32t)((accu + 0x40000000) >> 31); accu = (int64t)wre*tmpz[n34+i].re; accu -= (int64t)wim*tmpz[n34+i].im; tmp3 = (int32t)((accu + 0x40000000) >> 31); accu = (int64t)wre*tmpz[n34+i].im; accu += (int64t)wim*tmpz[n34+i].re; tmp4 = (int32t)((accu + 0x40000000) >> 31); tmp5 = tmp1 + tmp3; tmp1 = tmp1 - tmp3; tmp6 = tmp2 + tmp4; tmp2 = tmp2 - tmp4; tmpz[ n2+i].re = tmpz[ i].re - tmp5; tmpz[ i].re = tmpz[ i].re + tmp5; tmpz[ n2+i].im = tmpz[ i].im - tmp6; tmpz[ i].im = tmpz[ i].im + tmp6; tmpz[n34+i].re = tmpz[n4+i].re - tmp2; tmpz[ n4+i].re = tmpz[n4+i].re + tmp2; tmpz[n34+i].im = tmpz[n4+i].im + tmp1; tmpz[ n4+i].im = tmpz[n4+i].im - tmp1; wreptr += step; wimptr -= step; } } step >>= 1; n4 <<= 1; } } ", "target": 1}
{"func": "int cpuppchandlemmufault(CPUPPCState *env, targetulong address, int rw, int mmuidx) { mmuctxt ctx; int accesstype; int ret = 0; if (rw == 2) { /* code access */ rw = 0; accesstype = ACCESSCODE; } else { /* data access */ accesstype = env->accesstype; } ret = getphysicaladdress(env, &ctx, address, rw, accesstype); if (ret == 0) { tlbsetpage(env, address & TARGETPAGEMASK, ctx.raddr & TARGETPAGEMASK, ctx.prot, mmuidx, TARGETPAGESIZE); ret = 0; } else if (ret < 0) { LOGMMUSTATE(env); if (accesstype == ACCESSCODE) { switch (ret) { case -1: /* No matches in page tables or TLB */ switch (env->mmumodel) { case POWERPCMMUSOFT6xx: env->exceptionindex = POWERPCEXCPIFTLB; env->errorcode = 1 << 18; env->spr[SPRIMISS] = address; env->spr[SPRICMP] = 0x80000000 | ctx.ptem; goto tlbmiss; case POWERPCMMUSOFT74xx: env->exceptionindex = POWERPCEXCPIFTLB; goto tlbmiss74xx; case POWERPCMMUSOFT4xx: case POWERPCMMUSOFT4xxZ: env->exceptionindex = POWERPCEXCPITLB; env->errorcode = 0; env->spr[SPR40xDEAR] = address; env->spr[SPR40xESR] = 0x00000000; break; case POWERPCMMU32B: case POWERPCMMU601: #if defined(TARGETPPC64) case POWERPCMMU620: case POWERPCMMU64B: case POWERPCMMU206: #endif env->exceptionindex = POWERPCEXCPISI; env->errorcode = 0x40000000; break; case POWERPCMMUBOOKE206: booke206updatemastlbmiss(env, address, rw); /* fall through */ case POWERPCMMUBOOKE: env->exceptionindex = POWERPCEXCPITLB; env->errorcode = 0; env->spr[SPRBOOKEDEAR] = address; return -1; case POWERPCMMUMPC8xx: /* XXX: TODO */ cpuabort(env, \"MPC8xx MMU model is not implemented\\n\"); break; case POWERPCMMUREAL: cpuabort(env, \"PowerPC in real mode should never raise \" \"any MMU exceptions\\n\"); return -1; default: cpuabort(env, \"Unknown or invalid MMU model\\n\"); return -1; } break; case -2: /* Access rights violation */ env->exceptionindex = POWERPCEXCPISI; env->errorcode = 0x08000000; break; case -3: /* No execute protection violation */ if ((env->mmumodel == POWERPCMMUBOOKE) || (env->mmumodel == POWERPCMMUBOOKE206)) { env->spr[SPRBOOKEESR] = 0x00000000; } env->exceptionindex = POWERPCEXCPISI; env->errorcode = 0x10000000; break; case -4: /* Direct store exception */ /* No code fetch is allowed in direct-store areas */ env->exceptionindex = POWERPCEXCPISI; env->errorcode = 0x10000000; break; #if defined(TARGETPPC64) case -5: /* No match in segment table */ if (env->mmumodel == POWERPCMMU620) { env->exceptionindex = POWERPCEXCPISI; /* XXX: this might be incorrect */ env->errorcode = 0x40000000; } else { env->exceptionindex = POWERPCEXCPISEG; env->errorcode = 0; } break; #endif } } else { switch (ret) { case -1: /* No matches in page tables or TLB */ switch (env->mmumodel) { case POWERPCMMUSOFT6xx: if (rw == 1) { env->exceptionindex = POWERPCEXCPDSTLB; env->errorcode = 1 << 16; } else { env->exceptionindex = POWERPCEXCPDLTLB; env->errorcode = 0; } env->spr[SPRDMISS] = address; env->spr[SPRDCMP] = 0x80000000 | ctx.ptem; tlbmiss: env->errorcode |= ctx.key << 19; env->spr[SPRHASH1] = env->htabbase + getptegoffset(env, ctx.hash[0], HASHPTESIZE32); env->spr[SPRHASH2] = env->htabbase + getptegoffset(env, ctx.hash[1], HASHPTESIZE32); break; case POWERPCMMUSOFT74xx: if (rw == 1) { env->exceptionindex = POWERPCEXCPDSTLB; } else { env->exceptionindex = POWERPCEXCPDLTLB; } tlbmiss74xx: /* Implement LRU algorithm */ env->errorcode = ctx.key << 19; env->spr[SPRTLBMISS] = (address & ~((targetulong)0x3)) | ((env->lastway + 1) & (env->nbways - 1)); env->spr[SPRPTEHI] = 0x80000000 | ctx.ptem; break; case POWERPCMMUSOFT4xx: case POWERPCMMUSOFT4xxZ: env->exceptionindex = POWERPCEXCPDTLB; env->errorcode = 0; env->spr[SPR40xDEAR] = address; if (rw) { env->spr[SPR40xESR] = 0x00800000; } else { env->spr[SPR40xESR] = 0x00000000; } break; case POWERPCMMU32B: case POWERPCMMU601: #if defined(TARGETPPC64) case POWERPCMMU620: case POWERPCMMU64B: case POWERPCMMU206: #endif env->exceptionindex = POWERPCEXCPDSI; env->errorcode = 0; env->spr[SPRDAR] = address; if (rw == 1) { env->spr[SPRDSISR] = 0x42000000; } else { env->spr[SPRDSISR] = 0x40000000; } break; case POWERPCMMUMPC8xx: /* XXX: TODO */ cpuabort(env, \"MPC8xx MMU model is not implemented\\n\"); break; case POWERPCMMUBOOKE206: booke206updatemastlbmiss(env, address, rw); /* fall through */ case POWERPCMMUBOOKE: env->exceptionindex = POWERPCEXCPDTLB; env->errorcode = 0; env->spr[SPRBOOKEDEAR] = address; env->spr[SPRBOOKEESR] = rw ? ESRST : 0; return -1; case POWERPCMMUREAL: cpuabort(env, \"PowerPC in real mode should never raise \" \"any MMU exceptions\\n\"); return -1; default: cpuabort(env, \"Unknown or invalid MMU model\\n\"); return -1; } break; case -2: /* Access rights violation */ env->exceptionindex = POWERPCEXCPDSI; env->errorcode = 0; if (env->mmumodel == POWERPCMMUSOFT4xx || env->mmumodel == POWERPCMMUSOFT4xxZ) { env->spr[SPR40xDEAR] = address; if (rw) { env->spr[SPR40xESR] |= 0x00800000; } } else if ((env->mmumodel == POWERPCMMUBOOKE) || (env->mmumodel == POWERPCMMUBOOKE206)) { env->spr[SPRBOOKEDEAR] = address; env->spr[SPRBOOKEESR] = rw ? ESRST : 0; } else { env->spr[SPRDAR] = address; if (rw == 1) { env->spr[SPRDSISR] = 0x0A000000; } else { env->spr[SPRDSISR] = 0x08000000; } } break; case -4: /* Direct store exception */ switch (accesstype) { case ACCESSFLOAT: /* Floating point load/store */ env->exceptionindex = POWERPCEXCPALIGN; env->errorcode = POWERPCEXCPALIGNFP; env->spr[SPRDAR] = address; break; case ACCESSRES: /* lwarx, ldarx or stwcx. */ env->exceptionindex = POWERPCEXCPDSI; env->errorcode = 0; env->spr[SPRDAR] = address; if (rw == 1) { env->spr[SPRDSISR] = 0x06000000; } else { env->spr[SPRDSISR] = 0x04000000; } break; case ACCESSEXT: /* eciwx or ecowx */ env->exceptionindex = POWERPCEXCPDSI; env->errorcode = 0; env->spr[SPRDAR] = address; if (rw == 1) { env->spr[SPRDSISR] = 0x06100000; } else { env->spr[SPRDSISR] = 0x04100000; } break; default: printf(\"DSI: invalid exception (%d)\\n\", ret); env->exceptionindex = POWERPCEXCPPROGRAM; env->errorcode = POWERPCEXCPINVAL | POWERPCEXCPINVALINVAL; env->spr[SPRDAR] = address; break; } break; #if defined(TARGETPPC64) case -5: /* No match in segment table */ if (env->mmumodel == POWERPCMMU620) { env->exceptionindex = POWERPCEXCPDSI; env->errorcode = 0; env->spr[SPRDAR] = address; /* XXX: this might be incorrect */ if (rw == 1) { env->spr[SPRDSISR] = 0x42000000; } else { env->spr[SPRDSISR] = 0x40000000; } } else { env->exceptionindex = POWERPCEXCPDSEG; env->errorcode = 0; env->spr[SPRDAR] = address; } break; #endif } } #if 0 printf(\"%s: set exception to %d %02x\\n\", func, env->exception, env->errorcode); #endif ret = 1; } return ret; }", "target": 1}
{"func": "void qemuspicedisplayinit(DisplayState *ds) { assert(sdpy.ds == NULL); qemuspicedisplayinitcommon(&sdpy, ds); registerdisplaychangelistener(ds, &displaylistener); sdpy.qxl.base.sif = &dpyinterface.base; qemuspiceaddinterface(&sdpy.qxl.base); assert(sdpy.worker); qemuspicecreatehostmemslot(&sdpy); qemuspicecreatehostprimary(&sdpy); } ", "target": 1}
{"func": "static int qcow2isallocated(BlockDriverState *bs, int64t sectornum, int nbsectors, int *pnum) { uint64t clusteroffset; int ret; *pnum = nbsectors; /* FIXME We can get errors here, but the bdrvisallocated interface can't * pass them on today */ ret = qcow2getclusteroffset(bs, sectornum << 9, pnum, &clusteroffset); if (ret < 0) { *pnum = 0; } return (clusteroffset != 0); } ", "target": 0}
{"func": "static void migrateparamstestapply(MigrateSetParameters *params, MigrationParameters *dest) { *dest = migrategetcurrent()->parameters; /* TODO use QAPICLONE() instead of duplicating it inline */ if (params->hascompresslevel) { dest->compresslevel = params->compresslevel; } if (params->hascompressthreads) { dest->compressthreads = params->compressthreads; } if (params->hasdecompressthreads) { dest->decompressthreads = params->decompressthreads; } if (params->hascputhrottleinitial) { dest->cputhrottleinitial = params->cputhrottleinitial; } if (params->hascputhrottleincrement) { dest->cputhrottleincrement = params->cputhrottleincrement; } if (params->hastlscreds) { dest->tlscreds = gstrdup(params->tlscreds); } if (params->hastlshostname) { dest->tlshostname = gstrdup(params->tlshostname); } if (params->hasmaxbandwidth) { dest->maxbandwidth = params->maxbandwidth; } if (params->hasdowntimelimit) { dest->downtimelimit = params->downtimelimit; } if (params->hasxcheckpointdelay) { dest->xcheckpointdelay = params->xcheckpointdelay; } if (params->hasblockincremental) { dest->blockincremental = params->blockincremental; } } ", "target": 0}
{"func": "void cpustatereset(CPUMIPSState *env) { if (qemuloglevelmask(CPULOGRESET)) { qemulog(\"CPU Reset (CPU %d)\\n\", env->cpuindex); logcpustate(env, 0); } memset(env, 0, offsetof(CPUMIPSState, breakpoints)); tlbflush(env, 1); /* Reset registers to their default values */ env->CP0PRid = env->cpumodel->CP0PRid; env->CP0Config0 = env->cpumodel->CP0Config0; #ifdef TARGETWORDSBIGENDIAN env->CP0Config0 |= (1 << CP0C0BE); #endif env->CP0Config1 = env->cpumodel->CP0Config1; env->CP0Config2 = env->cpumodel->CP0Config2; env->CP0Config3 = env->cpumodel->CP0Config3; env->CP0Config6 = env->cpumodel->CP0Config6; env->CP0Config7 = env->cpumodel->CP0Config7; env->CP0LLAddrrwbitmask = env->cpumodel->CP0LLAddrrwbitmask << env->cpumodel->CP0LLAddrshift; env->CP0LLAddrshift = env->cpumodel->CP0LLAddrshift; env->SYNCIStep = env->cpumodel->SYNCIStep; env->CCRes = env->cpumodel->CCRes; env->CP0Statusrwbitmask = env->cpumodel->CP0Statusrwbitmask; env->CP0TCStatusrwbitmask = env->cpumodel->CP0TCStatusrwbitmask; env->CP0SRSCtl = env->cpumodel->CP0SRSCtl; env->currenttc = 0; env->SEGBITS = env->cpumodel->SEGBITS; env->SEGMask = (targetulong)((1ULL << env->cpumodel->SEGBITS) - 1); #if defined(TARGETMIPS64) if (env->cpumodel->insnflags & ISAMIPS3) { env->SEGMask |= 3ULL << 62; } #endif env->PABITS = env->cpumodel->PABITS; env->PAMask = (targetulong)((1ULL << env->cpumodel->PABITS) - 1); env->CP0SRSConf0rwbitmask = env->cpumodel->CP0SRSConf0rwbitmask; env->CP0SRSConf0 = env->cpumodel->CP0SRSConf0; env->CP0SRSConf1rwbitmask = env->cpumodel->CP0SRSConf1rwbitmask; env->CP0SRSConf1 = env->cpumodel->CP0SRSConf1; env->CP0SRSConf2rwbitmask = env->cpumodel->CP0SRSConf2rwbitmask; env->CP0SRSConf2 = env->cpumodel->CP0SRSConf2; env->CP0SRSConf3rwbitmask = env->cpumodel->CP0SRSConf3rwbitmask; env->CP0SRSConf3 = env->cpumodel->CP0SRSConf3; env->CP0SRSConf4rwbitmask = env->cpumodel->CP0SRSConf4rwbitmask; env->CP0SRSConf4 = env->cpumodel->CP0SRSConf4; env->activefpu.fcr0 = env->cpumodel->CP1fcr0; env->insnflags = env->cpumodel->insnflags; #if defined(CONFIGUSERONLY) env->hflags = MIPSHFLAGUM; /* Enable access to the CPUNum, SYNCIStep, CC, and CCRes RDHWR hardware registers. */ env->CP0HWREna |= 0x0000000F; if (env->CP0Config1 & (1 << CP0C1FP)) { env->hflags |= MIPSHFLAGFPU; } #ifdef TARGETMIPS64 if (env->activefpu.fcr0 & (1 << FCR0F64)) { env->hflags |= MIPSHFLAGF64; } #endif #else if (env->hflags & MIPSHFLAGBMASK) { /* If the exception was raised from a delay slot, come back to the jump. */ env->CP0ErrorEPC = env->activetc.PC - 4; } else { env->CP0ErrorEPC = env->activetc.PC; } env->activetc.PC = (int32t)0xBFC00000; env->CP0Random = env->tlb->nbtlb - 1; env->tlb->tlbinuse = env->tlb->nbtlb; env->CP0Wired = 0; env->CP0EBase = 0x80000000 | (env->cpuindex & 0x3FF); env->CP0Status = (1 << CP0StBEV) | (1 << CP0StERL); /* vectored interrupts not implemented, timer on int 7, no performance counters. */ env->CP0IntCtl = 0xe0000000; { int i; for (i = 0; i < 7; i++) { env->CP0WatchLo[i] = 0; env->CP0WatchHi[i] = 0x80000000; } env->CP0WatchLo[7] = 0; env->CP0WatchHi[7] = 0; } /* Count register increments in debug mode, EJTAG version 1 */ env->CP0Debug = (1 << CP0DBCNT) | (0x1 << CP0DBVER); env->hflags = MIPSHFLAGCP0; if (env->CP0Config3 & (1 << CP0C3MT)) { int i; /* Only TC0 on VPE 0 starts as active. */ for (i = 0; i < ARRAYSIZE(env->tcs); i++) { env->tcs[i].CP0TCBind = env->cpuindex << CP0TCBdCurVPE; env->tcs[i].CP0TCHalt = 1; } env->activetc.CP0TCHalt = 1; env->halted = 1; if (!env->cpuindex) { /* VPE0 starts up enabled. */ env->mvp->CP0MVPControl |= (1 << CP0MVPCoEVP); env->CP0VPEConf0 |= (1 << CP0VPEC0MVP) | (1 << CP0VPEC0VPA); /* TC0 starts up unhalted. */ env->halted = 0; env->activetc.CP0TCHalt = 0; env->tcs[0].CP0TCHalt = 0; /* With thread 0 active. */ env->activetc.CP0TCStatus = (1 << CP0TCStA); env->tcs[0].CP0TCStatus = (1 << CP0TCStA); } } #endif #if defined(TARGETMIPS64) if (env->cpumodel->insnflags & ISAMIPS3) { env->hflags |= MIPSHFLAG64; } #endif env->exceptionindex = EXCPNONE; } ", "target": 0}
{"func": "bool bdrvopisblocked(BlockDriverState *bs, BlockOpType op, Error **errp) { BdrvOpBlocker *blocker; assert((int) op >= 0 && op < BLOCKOPTYPEMAX); if (!QLISTEMPTY(&bs->opblockers[op])) { blocker = QLISTFIRST(&bs->opblockers[op]); if (errp) { *errp = errorcopy(blocker->reason); errorprepend(errp, \"Node '%s' is busy: \", bdrvgetdeviceornodename(bs)); } return true; } return false; } ", "target": 0}
{"func": "static BlockJob *findblockjob(const char *device, AioContext **aiocontext, Error **errp) { BlockBackend *blk; BlockDriverState *bs; *aiocontext = NULL; blk = blkbyname(device); if (!blk) { goto notfound; } *aiocontext = blkgetaiocontext(blk); aiocontextacquire(*aiocontext); if (!blkisavailable(blk)) { goto notfound; } bs = blkbs(blk); if (!bs->job) { goto notfound; } return bs->job; notfound: errorset(errp, ERRORCLASSDEVICENOTACTIVE, \"No active block job on device '%s'\", device); if (*aiocontext) { aiocontextrelease(*aiocontext); *aiocontext = NULL; } return NULL; } ", "target": 0}
{"func": "static int bthciparse(const char *str) { struct HCIInfo *hci; bdaddrt bdaddr; if (nbhcis >= MAXNICS) { fprintf(stderr, \"qemu: Too many bluetooth HCIs (max %i).\\n\", MAXNICS); return -1; } hci = hciinit(str); if (!hci) return -1; bdaddr.b[0] = 0x52; bdaddr.b[1] = 0x54; bdaddr.b[2] = 0x00; bdaddr.b[3] = 0x12; bdaddr.b[4] = 0x34; bdaddr.b[5] = 0x56 + nbhcis; hci->bdaddrset(hci, bdaddr.b); hcitable[nbhcis++] = hci; return 0; } ", "target": 0}
{"func": "static int crismmutranslatepage(struct crismmuresult *res, \t\t\t\t CPUState *env, uint32t vaddr, \t\t\t\t int rw, int usermode, int debug) { \tunsigned int vpage; \tunsigned int idx; \tuint32t pid, lo, hi; \tuint32t tlbvpn, tlbpfn = 0; \tint tlbpid, tlbg, tlbv, tlbk, tlbw, tlbx; \tint cfgv, cfgk, cfgw, cfgx;\t \tint set, match = 0; \tuint32t rcause; \tuint32t rcfg; \tint rwcause; \tint mmu = 1; /* Data mmu is default. */ \tint vectbase; \trcause = env->sregs[SFRRMMCAUSE]; \trcfg = env->sregs[SFRRWMMCFG]; \tpid = env->pregs[PRPID] & 0xff; \tswitch (rw) { \t\tcase 2: rwcause = CRISMMUERREXEC; mmu = 0; break; \t\tcase 1: rwcause = CRISMMUERRWRITE; break; \t\tdefault: \t\tcase 0: rwcause = CRISMMUERRREAD; break; \t} \t/* I exception vectors 4 - 7, D 8 - 11. */ \tvectbase = (mmu + 1) * 4; \tvpage = vaddr >> 13; \t/* We know the index which to check on each set. \t Scan both I and D. */ #if 0 \tfor (set = 0; set < 4; set++) { \t\tfor (idx = 0; idx < 16; idx++) { \t\t\tlo = env->tlbsets[mmu][set][idx].lo; \t\t\thi = env->tlbsets[mmu][set][idx].hi; \t\t\ttlbvpn = EXTRACTFIELD(hi, 13, 31); \t\t\ttlbpfn = EXTRACTFIELD(lo, 13, 31); \t\t\tprintf (\"TLB: [%d][%d] hi=%x lo=%x v=%x p=%x\\n\", \t\t\t\t\tset, idx, hi, lo, tlbvpn, tlbpfn); \t\t} \t} #endif \tidx = vpage & 15; \tfor (set = 0; set < 4; set++) \t{ \t\tlo = env->tlbsets[mmu][set][idx].lo; \t\thi = env->tlbsets[mmu][set][idx].hi; \t\ttlbvpn = hi >> 13; \t\ttlbpid = EXTRACTFIELD(hi, 0, 7); \t\ttlbg = EXTRACTFIELD(lo, 4, 4); \t\tDLOG(\"TLB[%d][%d][%d] v=%x vpage=%x lo=%x hi=%x\\n\", \t\t\t mmu, set, idx, tlbvpn, vpage, lo, hi); \t\tif ((tlbg || (tlbpid == pid)) \t\t && tlbvpn == vpage) { \t\t\tmatch = 1; \t\t\tbreak; \t\t} \t} \tres->bfvec = vectbase; \tif (match) { \t\tcfgw = EXTRACTFIELD(rcfg, 19, 19); \t\tcfgk = EXTRACTFIELD(rcfg, 18, 18); \t\tcfgx = EXTRACTFIELD(rcfg, 17, 17); \t\tcfgv = EXTRACTFIELD(rcfg, 16, 16); \t\ttlbpfn = EXTRACTFIELD(lo, 13, 31); \t\ttlbv = EXTRACTFIELD(lo, 3, 3); \t\ttlbk = EXTRACTFIELD(lo, 2, 2); \t\ttlbw = EXTRACTFIELD(lo, 1, 1); \t\ttlbx = EXTRACTFIELD(lo, 0, 0); \t\t/* \t\tsetexceptionvector(0x04, immurefill); \t\tsetexceptionvector(0x05, immuinvalid); \t\tsetexceptionvector(0x06, immuaccess); \t\tsetexceptionvector(0x07, immuexecute); \t\tsetexceptionvector(0x08, dmmurefill); \t\tsetexceptionvector(0x09, dmmuinvalid); \t\tsetexceptionvector(0x0a, dmmuaccess); \t\tsetexceptionvector(0x0b, dmmuwrite); \t\t*/ \t\tif (cfgk && tlbk && usermode) { \t\t\tD(printf (\"tlb: kernel protected %x lo=%x pc=%x\\n\", \t\t\t\t vaddr, lo, env->pc)); \t\t\tmatch = 0; \t\t\tres->bfvec = vectbase + 2; \t\t} else if (rw == 1 && cfgw && !tlbw) { \t\t\tD(printf (\"tlb: write protected %x lo=%x pc=%x\\n\", \t\t\t\t vaddr, lo, env->pc)); \t\t\tmatch = 0; \t\t\t/* write accesses never go through the I mmu. */ \t\t\tres->bfvec = vectbase + 3; \t\t} else if (rw == 2 && cfgx && !tlbx) { \t\t\tD(printf (\"tlb: exec protected %x lo=%x pc=%x\\n\", \t\t\t\t vaddr, lo, env->pc)); \t\t\tmatch = 0; \t\t\tres->bfvec = vectbase + 3; \t\t} else if (cfgv && !tlbv) { \t\t\tD(printf (\"tlb: invalid %x\\n\", vaddr)); \t\t\tmatch = 0; \t\t\tres->bfvec = vectbase + 1; \t\t} \t\tres->prot = 0; \t\tif (match) { \t\t\tres->prot |= PAGEREAD; \t\t\tif (tlbw) \t\t\t\tres->prot |= PAGEWRITE; \t\t\tif (tlbx) \t\t\t\tres->prot |= PAGEEXEC; \t\t} \t\telse \t\t\tD(dumptlb(env, mmu)); \t} else { \t\t/* If refill, provide a randomized set. */ \t\tset = env->mmurandlfsr & 3; \t} \tif (!match && !debug) { \t\tcrismmuupdaterandlfsr(env); \t\t/* Compute index. */ \t\tidx = vpage & 15; \t\t/* Update RWMMTLBSEL. */ \t\tenv->sregs[SFRRWMMTLBSEL] = 0; \t\tsetfield(&env->sregs[SFRRWMMTLBSEL], idx, 0, 4); \t\tsetfield(&env->sregs[SFRRWMMTLBSEL], set, 4, 2); \t\t/* Update RWMMCAUSE. */ \t\tsetfield(&rcause, rwcause, 8, 2); \t\tsetfield(&rcause, vpage, 13, 19); \t\tsetfield(&rcause, pid, 0, 8); \t\tenv->sregs[SFRRMMCAUSE] = rcause; \t\tD(printf(\"refill vaddr=%x pc=%x\\n\", vaddr, env->pc)); \t} \tD(printf (\"%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x\" \t\t \" %x cause=%x sel=%x sp=%x %x %x\\n\", \t\t func, rw, match, env->pc, \t\t vaddr, vpage, \t\t tlbvpn, tlbpfn, tlbpid, \t\t pid, \t\t rcause, \t\t env->sregs[SFRRWMMTLBSEL], \t\t env->regs[RSP], env->pregs[PRUSP], env->ksp)); \tres->phy = tlbpfn << TARGETPAGEBITS; \treturn !match; } ", "target": 0}
{"func": "static void gendst(DisasContext *ctx) { if (rA(ctx->opcode) == 0) { geninvalexception(ctx, POWERPCEXCPINVALLSWX); } else { /* interpreted as no-op */ } } ", "target": 1}
{"func": "static void x86cpuenablexsavecomponents(X86CPU *cpu) { CPUX86State *env = &cpu->env; int i; if (!(env->features[FEAT1ECX] & CPUIDEXTXSAVE)) { return; } env->xsavecomponents = (XSTATEFPMASK | XSTATESSEMASK); for (i = 2; i < ARRAYSIZE(x86extsaveareas); i++) { const ExtSaveArea *esa = &x86extsaveareas[i]; if (env->features[esa->feature] & esa->bits) { env->xsavecomponents |= (1ULL << i); } } if (kvmenabled()) { KVMState *s = kvmstate; uint64t kvmmask = kvmarchgetsupportedcpuid(s, 0xd, 0, REDX); kvmmask <<= 32; kvmmask |= kvmarchgetsupportedcpuid(s, 0xd, 0, REAX); env->xsavecomponents &= kvmmask; } } ", "target": 0}
{"func": "int mmutranslatereal(CPUS390XState *env, targetulong raddr, int rw, targetulong *addr, int *flags) { /* TODO: low address protection once we flush the tlb on cr changes */ *flags = PAGEREAD | PAGEWRITE; *addr = mmureal2abs(env, raddr); /* TODO: storage key handling */ return 0; } ", "target": 0}
{"func": "static void nicselectivereset(EEPRO100State * s) { sizet i; uint16t *eepromcontents = eeprom93xxdata(s->eeprom); //~ eeprom93xxreset(s->eeprom); memcpy(eepromcontents, s->conf.macaddr.a, 6); eepromcontents[0xa] = 0x4000; if (s->device == i82557B || s->device == i82557C) eepromcontents[5] = 0x0100; uint16t sum = 0; for (i = 0; i < EEPROMSIZE - 1; i++) { sum += eepromcontents[i]; } eepromcontents[EEPROMSIZE - 1] = 0xbaba - sum; TRACE(EEPROM, logout(\"checksum=0x%04x\\n\", eepromcontents[EEPROMSIZE - 1])); memset(s->mem, 0, sizeof(s->mem)); uint32t val = BIT(21); memcpy(&s->mem[SCBCtrlMDI], &val, sizeof(val)); assert(sizeof(s->mdimem) == sizeof(eepro100mdidefault)); memcpy(&s->mdimem[0], &eepro100mdidefault[0], sizeof(s->mdimem)); } ", "target": 0}
{"func": "void pcibridgeresetreg(PCIDevice *dev) { uint8t *conf = dev->config; conf[PCIPRIMARYBUS] = 0; conf[PCISECONDARYBUS] = 0; conf[PCISUBORDINATEBUS] = 0; conf[PCISECLATENCYTIMER] = 0; conf[PCIIOBASE] = 0; conf[PCIIOLIMIT] = 0; pcisetword(conf + PCIMEMORYBASE, 0); pcisetword(conf + PCIMEMORYLIMIT, 0); pcisetword(conf + PCIPREFMEMORYBASE, 0); pcisetword(conf + PCIPREFMEMORYLIMIT, 0); pcisetword(conf + PCIPREFBASEUPPER32, 0); pcisetword(conf + PCIPREFLIMITUPPER32, 0); pcisetword(conf + PCIBRIDGECONTROL, 0); } ", "target": 1}
{"func": "static int kvmclientsyncdirtybitmap(struct CPUPhysMemoryClient *client, targetphysaddrt startaddr, targetphysaddrt endaddr) { return kvmphysicalsyncdirtybitmap(startaddr, endaddr); } ", "target": 1}
{"func": "static uint32t bonitoreadl(void *opaque, targetphysaddrt addr) { PCIBonitoState *s = opaque; uint32t saddr; saddr = (addr - BONITOREGBASE) >> 2; DPRINTF(\"bonitoreadl \"TARGETFMTplx\" \\n\", addr); switch (saddr) { case BONITOINTISR: return s->regs[saddr]; default: return s->regs[saddr]; } } ", "target": 0}
{"func": "struct omapmpustates *omap310mpuinit(MemoryRegion *systemmemory, unsigned long sdramsize, const char *core) { int i; struct omapmpustates *s = (struct omapmpustates *) gmalloc0(sizeof(struct omapmpustates)); qemuirq dmairqs[6]; DriveInfo *dinfo; SysBusDevice *busdev; if (!core) core = \"ti925t\"; /* Core */ s->mpumodel = omap310; s->cpu = cpuarminit(core); if (s->cpu == NULL) { fprintf(stderr, \"Unable to find CPU definition\\n\"); exit(1); } s->sdramsize = sdramsize; s->sramsize = OMAP15XXSRAMSIZE; s->wakeup = qemuallocateirq(omapmpuwakeup, s, 0); /* Clocks */ omapclkinit(s); /* Memory-mapped stuff */ memoryregioninitram(&s->emiffram, NULL, \"omap1.dram\", s->sdramsize, &errorabort); vmstateregisterramglobal(&s->emiffram); memoryregionaddsubregion(systemmemory, OMAPEMIFFBASE, &s->emiffram); memoryregioninitram(&s->imifram, NULL, \"omap1.sram\", s->sramsize, &errorabort); vmstateregisterramglobal(&s->imifram); memoryregionaddsubregion(systemmemory, OMAPIMIFBASE, &s->imifram); omapclkminit(systemmemory, 0xfffece00, 0xe1008000, s); s->ih[0] = qdevcreate(NULL, \"omap-intc\"); qdevpropsetuint32(s->ih[0], \"size\", 0x100); qdevpropsetptr(s->ih[0], \"clk\", omapfindclk(s, \"arminthck\")); qdevinitnofail(s->ih[0]); busdev = SYSBUSDEVICE(s->ih[0]); sysbusconnectirq(busdev, 0, qdevgetgpioin(DEVICE(s->cpu), ARMCPUIRQ)); sysbusconnectirq(busdev, 1, qdevgetgpioin(DEVICE(s->cpu), ARMCPUFIQ)); sysbusmmiomap(busdev, 0, 0xfffecb00); s->ih[1] = qdevcreate(NULL, \"omap-intc\"); qdevpropsetuint32(s->ih[1], \"size\", 0x800); qdevpropsetptr(s->ih[1], \"clk\", omapfindclk(s, \"arminthck\")); qdevinitnofail(s->ih[1]); busdev = SYSBUSDEVICE(s->ih[1]); sysbusconnectirq(busdev, 0, qdevgetgpioin(s->ih[0], OMAPINT15XXIH2IRQ)); /* The second interrupt controller's FIQ output is not wired up */ sysbusmmiomap(busdev, 0, 0xfffe0000); for (i = 0; i < 6; i++) { dmairqs[i] = qdevgetgpioin(s->ih[omap1dmairqmap[i].ih], omap1dmairqmap[i].intr); } s->dma = omapdmainit(0xfffed800, dmairqs, systemmemory, qdevgetgpioin(s->ih[0], OMAPINTDMALCD), s, omapfindclk(s, \"dmack\"), omapdma31); s->port[emiff ].addrvalid = omapvalidateemiffaddr; s->port[emifs ].addrvalid = omapvalidateemifsaddr; s->port[imif ].addrvalid = omapvalidateimifaddr; s->port[tipb ].addrvalid = omapvalidatetipbaddr; s->port[local ].addrvalid = omapvalidatelocaladdr; s->port[tipbmpui].addrvalid = omapvalidatetipbmpuiaddr; /* Register SDRAM and SRAM DMA ports for fast transfers. */ socdmaportaddmem(s->dma, memoryregiongetramptr(&s->emiffram), OMAPEMIFFBASE, s->sdramsize); socdmaportaddmem(s->dma, memoryregiongetramptr(&s->imifram), OMAPIMIFBASE, s->sramsize); s->timer[0] = omapmputimerinit(systemmemory, 0xfffec500, qdevgetgpioin(s->ih[0], OMAPINTTIMER1), omapfindclk(s, \"mputimck\")); s->timer[1] = omapmputimerinit(systemmemory, 0xfffec600, qdevgetgpioin(s->ih[0], OMAPINTTIMER2), omapfindclk(s, \"mputimck\")); s->timer[2] = omapmputimerinit(systemmemory, 0xfffec700, qdevgetgpioin(s->ih[0], OMAPINTTIMER3), omapfindclk(s, \"mputimck\")); s->wdt = omapwdtimerinit(systemmemory, 0xfffec800, qdevgetgpioin(s->ih[0], OMAPINTWDTIMER), omapfindclk(s, \"armwdtck\")); s->ostimer = omapostimerinit(systemmemory, 0xfffb9000, qdevgetgpioin(s->ih[1], OMAPINTOSTIMER), omapfindclk(s, \"clk32-kHz\")); s->lcd = omaplcdcinit(systemmemory, 0xfffec000, qdevgetgpioin(s->ih[0], OMAPINTLCDCTRL), omapdmagetlcdch(s->dma), omapfindclk(s, \"lcdck\")); omapulpdpminit(systemmemory, 0xfffe0800, s); omappincfginit(systemmemory, 0xfffe1000, s); omapidinit(systemmemory, s); omapmpuiinit(systemmemory, 0xfffec900, s); s->privatetipb = omaptipbbridgeinit(systemmemory, 0xfffeca00, qdevgetgpioin(s->ih[0], OMAPINTBRIDGEPRIV), omapfindclk(s, \"tipbck\")); s->publictipb = omaptipbbridgeinit(systemmemory, 0xfffed300, qdevgetgpioin(s->ih[0], OMAPINTBRIDGEPUB), omapfindclk(s, \"tipbck\")); omaptcmiinit(systemmemory, 0xfffecc00, s); s->uart[0] = omapuartinit(0xfffb0000, qdevgetgpioin(s->ih[1], OMAPINTUART1), omapfindclk(s, \"uart1ck\"), omapfindclk(s, \"uart1ck\"), s->drq[OMAPDMAUART1TX], s->drq[OMAPDMAUART1RX], \"uart1\", serialhds[0]); s->uart[1] = omapuartinit(0xfffb0800, qdevgetgpioin(s->ih[1], OMAPINTUART2), omapfindclk(s, \"uart2ck\"), omapfindclk(s, \"uart2ck\"), s->drq[OMAPDMAUART2TX], s->drq[OMAPDMAUART2RX], \"uart2\", serialhds[0] ? serialhds[1] : NULL); s->uart[2] = omapuartinit(0xfffb9800, qdevgetgpioin(s->ih[0], OMAPINTUART3), omapfindclk(s, \"uart3ck\"), omapfindclk(s, \"uart3ck\"), s->drq[OMAPDMAUART3TX], s->drq[OMAPDMAUART3RX], \"uart3\", serialhds[0] && serialhds[1] ? serialhds[2] : NULL); s->dpll[0] = omapdpllinit(systemmemory, 0xfffecf00, omapfindclk(s, \"dpll1\")); s->dpll[1] = omapdpllinit(systemmemory, 0xfffed000, omapfindclk(s, \"dpll2\")); s->dpll[2] = omapdpllinit(systemmemory, 0xfffed100, omapfindclk(s, \"dpll3\")); dinfo = driveget(IFSD, 0, 0); if (!dinfo) { fprintf(stderr, \"qemu: missing SecureDigital device\\n\"); exit(1); } s->mmc = omapmmcinit(0xfffb7800, systemmemory, blkbs(blkbylegacydinfo(dinfo)), qdevgetgpioin(s->ih[1], OMAPINTOQN), &s->drq[OMAPDMAMMCTX], omapfindclk(s, \"mmcck\")); s->mpuio = omapmpuioinit(systemmemory, 0xfffb5000, qdevgetgpioin(s->ih[1], OMAPINTKEYBOARD), qdevgetgpioin(s->ih[1], OMAPINTMPUIO), s->wakeup, omapfindclk(s, \"clk32-kHz\")); s->gpio = qdevcreate(NULL, \"omap-gpio\"); qdevpropsetint32(s->gpio, \"mpumodel\", s->mpumodel); qdevpropsetptr(s->gpio, \"clk\", omapfindclk(s, \"armgpiock\")); qdevinitnofail(s->gpio); sysbusconnectirq(SYSBUSDEVICE(s->gpio), 0, qdevgetgpioin(s->ih[0], OMAPINTGPIOBANK1)); sysbusmmiomap(SYSBUSDEVICE(s->gpio), 0, 0xfffce000); s->microwire = omapuwireinit(systemmemory, 0xfffb3000, qdevgetgpioin(s->ih[1], OMAPINTuWireTX), qdevgetgpioin(s->ih[1], OMAPINTuWireRX), s->drq[OMAPDMAUWIRETX], omapfindclk(s, \"mpuperck\")); s->pwl = omappwlinit(systemmemory, 0xfffb5800, omapfindclk(s, \"armxorck\")); s->pwt = omappwtinit(systemmemory, 0xfffb6000, omapfindclk(s, \"armxorck\")); s->i2c[0] = qdevcreate(NULL, \"omapi2c\"); qdevpropsetuint8(s->i2c[0], \"revision\", 0x11); qdevpropsetptr(s->i2c[0], \"fclk\", omapfindclk(s, \"mpuperck\")); qdevinitnofail(s->i2c[0]); busdev = SYSBUSDEVICE(s->i2c[0]); sysbusconnectirq(busdev, 0, qdevgetgpioin(s->ih[1], OMAPINTI2C)); sysbusconnectirq(busdev, 1, s->drq[OMAPDMAI2CTX]); sysbusconnectirq(busdev, 2, s->drq[OMAPDMAI2CRX]); sysbusmmiomap(busdev, 0, 0xfffb3800); s->rtc = omaprtcinit(systemmemory, 0xfffb4800, qdevgetgpioin(s->ih[1], OMAPINTRTCTIMER), qdevgetgpioin(s->ih[1], OMAPINTRTCALARM), omapfindclk(s, \"clk32-kHz\")); s->mcbsp1 = omapmcbspinit(systemmemory, 0xfffb1800, qdevgetgpioin(s->ih[1], OMAPINTMcBSP1TX), qdevgetgpioin(s->ih[1], OMAPINTMcBSP1RX), &s->drq[OMAPDMAMCBSP1TX], omapfindclk(s, \"dspxorck\")); s->mcbsp2 = omapmcbspinit(systemmemory, 0xfffb1000, qdevgetgpioin(s->ih[0], OMAPINT310McBSP2TX), qdevgetgpioin(s->ih[0], OMAPINT310McBSP2RX), &s->drq[OMAPDMAMCBSP2TX], omapfindclk(s, \"mpuperck\")); s->mcbsp3 = omapmcbspinit(systemmemory, 0xfffb7000, qdevgetgpioin(s->ih[1], OMAPINTMcBSP3TX), qdevgetgpioin(s->ih[1], OMAPINTMcBSP3RX), &s->drq[OMAPDMAMCBSP3TX], omapfindclk(s, \"dspxorck\")); s->led[0] = omaplpginit(systemmemory, 0xfffbd000, omapfindclk(s, \"clk32-kHz\")); s->led[1] = omaplpginit(systemmemory, 0xfffbd800, omapfindclk(s, \"clk32-kHz\")); /* Register mappings not currenlty implemented: * MCSI2 Comm\tfffb2000 - fffb27ff (not mapped on OMAP310) * MCSI1 Bluetooth\tfffb2800 - fffb2fff (not mapped on OMAP310) * USB W2FC\t\tfffb4000 - fffb47ff * Camera Interface\tfffb6800 - fffb6fff * USB Host\t\tfffba000 - fffba7ff * FAC\t\tfffba800 - fffbafff * HDQ/1-Wire\tfffbc000 - fffbc7ff * TIPB switches\tfffbc800 - fffbcfff * Mailbox\t\tfffcf000 - fffcf7ff * Local bus IF\tfffec100 - fffec1ff * Local bus MMU\tfffec200 - fffec2ff * DSP MMU\t\tfffed200 - fffed2ff */ omapsetupdspmapping(systemmemory, omap15xxdspmm); omapsetupmpuiio(systemmemory, s); qemuregisterreset(omap1mpureset, s); return s; } ", "target": 0}
{"func": "void nbdclientclose(NBDClient *client) { if (client->closing) { return; } client->closing = true; /* Force requests to finish. They will drop their own references, * then we'll close the socket and free the NBDClient. */ shutdown(client->sock, 2); /* Also tell the client, so that they release their reference. */ if (client->close) { client->close(client); } } ", "target": 0}
{"func": "static bool finddirtyblock(RAMState *rs, PageSearchStatus *pss, bool *again, ramaddrt *ramaddrabs) { pss->offset = migrationbitmapfinddirty(rs, pss->block, pss->offset, ramaddrabs); if (pss->completeround && pss->block == rs->lastseenblock && pss->offset >= rs->lastoffset) { /* * We've been once around the RAM and haven't found anything. * Give up. */ *again = false; return false; } if (pss->offset >= pss->block->usedlength) { /* Didn't find anything in this RAM Block */ pss->offset = 0; pss->block = QLISTNEXTRCU(pss->block, next); if (!pss->block) { /* Hit the end of the list */ pss->block = QLISTFIRSTRCU(&ramlist.blocks); /* Flag that we've looped */ pss->completeround = true; rs->rambulkstage = false; if (migrateusexbzrle()) { /* If xbzrle is on, stop using the data compression at this * point. In theory, xbzrle can do better than compression. */ flushcompresseddata(rs); } } /* Didn't find anything this time, but try again on the new block */ *again = true; return false; } else { /* Can go around again, but... */ *again = true; /* We've found something so probably don't need to */ return true; } } ", "target": 1}
{"func": "void OPPROTO opPOWERdoz (void) { if (Ts1 > Ts0) T0 = T1 - T0; else T0 = 0; RETURN(); } ", "target": 1}
{"func": "int ffwmv2decodesecondarypictureheader(MpegEncContext *s) { Wmv2Context *const w = (Wmv2Context *) s; if (s->picttype == AVPICTURETYPEI) { if (w->jtypebit) w->jtype = getbits1(&s->gb); else w->jtype = 0; // FIXME check if (!w->jtype) { if (w->permbrlbit) s->permbrltable = getbits1(&s->gb); else s->permbrltable = 0; if (!s->permbrltable) { s->rlchromatableindex = decode012(&s->gb); s->rltableindex = decode012(&s->gb); } s->dctableindex = getbits1(&s->gb); } s->interintrapred = 0; s->norounding = 1; if (s->avctx->debug & FFDEBUGPICTINFO) { avlog(s->avctx, AVLOGDEBUG, \"qscale:%d rlc:%d rl:%d dc:%d mbrl:%d jtype:%d \\n\", s->qscale, s->rlchromatableindex, s->rltableindex, s->dctableindex, s->permbrltable, w->jtype); } } else { int cbpindex; w->jtype = 0; parsembskip(w); cbpindex = decode012(&s->gb); if (s->qscale <= 10) { int map[3] = { 0, 2, 1 }; w->cbptableindex = map[cbpindex]; } else if (s->qscale <= 20) { int map[3] = { 1, 0, 2 }; w->cbptableindex = map[cbpindex]; } else { int map[3] = {2,1,0}; w->cbptableindex = map[cbpindex]; } if (w->mspelbit) s->mspel = getbits1(&s->gb); else s->mspel = 0; // FIXME check if (w->abtflag) { w->permbabt = getbits1(&s->gb) ^ 1; if (!w->permbabt) w->abttype = decode012(&s->gb); } if (w->permbrlbit) s->permbrltable = getbits1(&s->gb); else s->permbrltable = 0; if (!s->permbrltable) { s->rltableindex = decode012(&s->gb); s->rlchromatableindex = s->rltableindex; } s->dctableindex = getbits1(&s->gb); s->mvtableindex = getbits1(&s->gb); s->interintrapred = 0; // (s->width * s->height < 320 * 240 && s->bitrate <= IIBITRATE); s->norounding ^= 1; if (s->avctx->debug & FFDEBUGPICTINFO) { avlog(s->avctx, AVLOGDEBUG, \"rl:%d rlc:%d dc:%d mv:%d mbrl:%d qp:%d mspel:%d \" \"permbabt:%d abttype:%d cbp:%d ii:%d\\n\", s->rltableindex, s->rlchromatableindex, s->dctableindex, s->mvtableindex, s->permbrltable, s->qscale, s->mspel, w->permbabt, w->abttype, w->cbptableindex, s->interintrapred); } } s->esc3levellength = 0; s->esc3runlength = 0; s->picturenumber++; // FIXME ? if (w->jtype) { ffintrax8decodepicture(&w->x8, 2 * s->qscale, (s->qscale - 1) | 1); fferaddslice(&w->s.er, 0, 0, (w->s.mbx >> 1) - 1, (w->s.mby >> 1) - 1, ERMBEND); return 1; } return 0; } ", "target": 0}
{"func": "static void filltable(uint8t* table[256 + 2*YUVRGBTABLEHEADROOM], const int elemsize, const int inc, void *ytab) { int i; uint8t *ytable = ytab; ytable -= elemsize * (inc >> 9); for (i = 0; i < 256 + 2*YUVRGBTABLEHEADROOM; i++) { int64t cb = avclip(i-YUVRGBTABLEHEADROOM, 0, 255)*inc; table[i] = ytable + elemsize * (cb >> 16); } } ", "target": 1}
{"func": "static int allocatebuffers(ALACContext *alac) { int ch; for (ch = 0; ch < FFMIN(alac->channels, 2); ch++) { int bufsize = alac->maxsamplesperframe * sizeof(int32t); FFALLOCORGOTO(alac->avctx, alac->predicterrorbuffer[ch], bufsize, bufallocfail); if (alac->samplesize == 16) { FFALLOCORGOTO(alac->avctx, alac->outputsamplesbuffer[ch], bufsize, bufallocfail); } FFALLOCORGOTO(alac->avctx, alac->extrabitsbuffer[ch], bufsize, bufallocfail); } return 0; bufallocfail: alacdecodeclose(alac->avctx); return AVERROR(ENOMEM); } ", "target": 0}
{"func": "static int putcod(Jpeg2000EncoderContext *s) { Jpeg2000CodingStyle *codsty = &s->codsty; if (s->bufend - s->buf < 14) return -1; bytestreamputbe16(&s->buf, JPEG2000COD); bytestreamputbe16(&s->buf, 12); // Lcod bytestreamputbyte(&s->buf, 0); // Scod // SGcod bytestreamputbyte(&s->buf, 0); // progression level bytestreamputbe16(&s->buf, 1); // num of layers if(s->avctx->pixfmt == AVPIXFMTYUV444P){ bytestreamputbyte(&s->buf, 2); // ICT }else{ bytestreamputbyte(&s->buf, 0); // unspecified } // SPcod bytestreamputbyte(&s->buf, codsty->nreslevels - 1); // num of decomp. levels bytestreamputbyte(&s->buf, codsty->log2cblkwidth-2); // cblk width bytestreamputbyte(&s->buf, codsty->log2cblkheight-2); // cblk height bytestreamputbyte(&s->buf, 0); // cblk style bytestreamputbyte(&s->buf, codsty->transform); // transformation return 0; } ", "target": 0}
{"func": "bool memoryregiontestandcleardirty(MemoryRegion *mr, hwaddr addr, hwaddr size, unsigned client) { assert(mr->terminates); return cpuphysicalmemorytestandcleardirty(mr->ramaddr + addr, size, client); } ", "target": 0}
{"func": "static int bdrvgetclustersize(BlockDriverState *bs) { BlockDriverInfo bdi; int ret; ret = bdrvgetinfo(bs, &bdi); if (ret < 0 || bdi.clustersize == 0) { return bs->requestalignment; } else { return bdi.clustersize; } } ", "target": 0}
{"func": "static int libschroedingerencodeframe(AVCodecContext *avctx, AVPacket *pkt, const AVFrame *frame, int *gotpacket) { int encsize = 0; SchroEncoderParams *pschroparams = avctx->privdata; SchroEncoder *encoder = pschroparams->encoder; struct FFSchroEncodedFrame *pframeoutput = NULL; int go = 1; SchroBuffer *encbuf; int presentationframe; int parsecode; int lastframeinsequence = 0; int pktsize, ret; if (!frame) { /* Push end of sequence if not already signalled. */ if (!pschroparams->eossignalled) { schroencoderendofstream(encoder); pschroparams->eossignalled = 1; } } else { /* Allocate frame data to schro input buffer. */ SchroFrame *inframe = libschroedingerframefromdata(avctx, frame); if (!inframe) return AVERROR(ENOMEM); /* Load next frame. */ schroencoderpushframe(encoder, inframe); } if (pschroparams->eospulled) go = 0; /* Now check to see if we have any output from the encoder. */ while (go) { int err; SchroStateEnum state; state = schroencoderwait(encoder); switch (state) { case SCHROSTATEHAVEBUFFER: case SCHROSTATEENDOFSTREAM: encbuf = schroencoderpull(encoder, &presentationframe); if (encbuf->length <= 0) return AVERRORBUG; parsecode = encbuf->data[4]; /* All non-frame data is prepended to actual frame data to * be able to set the pts correctly. So we don't write data * to the frame output queue until we actually have a frame */ if ((err = avreallocp(&pschroparams->encbuf, pschroparams->encbufsize + encbuf->length)) < 0) { pschroparams->encbufsize = 0; return err; } memcpy(pschroparams->encbuf + pschroparams->encbufsize, encbuf->data, encbuf->length); pschroparams->encbufsize += encbuf->length; if (state == SCHROSTATEENDOFSTREAM) { pschroparams->eospulled = 1; go = 0; } if (!SCHROPARSECODEISPICTURE(parsecode)) { schrobufferunref(encbuf); break; } /* Create output frame. */ pframeoutput = avmallocz(sizeof(FFSchroEncodedFrame)); if (!pframeoutput) return AVERROR(ENOMEM); /* Set output data. */ pframeoutput->size = pschroparams->encbufsize; pframeoutput->pencbuf = pschroparams->encbuf; if (SCHROPARSECODEISINTRA(parsecode) && SCHROPARSECODEISREFERENCE(parsecode)) pframeoutput->keyframe = 1; /* Parse the coded frame number from the bitstream. Bytes 14 * through 17 represesent the frame number. */ pframeoutput->framenum = AVRB32(encbuf->data + 13); ffschroqueuepushback(&pschroparams->encframequeue, pframeoutput); pschroparams->encbufsize = 0; pschroparams->encbuf = NULL; schrobufferunref(encbuf); break; case SCHROSTATENEEDFRAME: go = 0; break; case SCHROSTATEAGAIN: break; default: avlog(avctx, AVLOGERROR, \"Unknown Schro Encoder state\\n\"); return -1; } } /* Copy 'next' frame in queue. */ if (pschroparams->encframequeue.size == 1 && pschroparams->eospulled) lastframeinsequence = 1; pframeoutput = ffschroqueuepop(&pschroparams->encframequeue); if (!pframeoutput) return 0; pktsize = pframeoutput->size; if (lastframeinsequence && pschroparams->encbufsize > 0) pktsize += pschroparams->encbufsize; if ((ret = ffallocpacket(pkt, pktsize)) < 0) { avlog(avctx, AVLOGERROR, \"Error getting output packet of size %d.\\n\", pktsize); goto error; } memcpy(pkt->data, pframeoutput->pencbuf, pframeoutput->size); avctx->codedframe->keyframe = pframeoutput->keyframe; /* Use the frame number of the encoded frame as the pts. It is OK to * do so since Dirac is a constant frame rate codec. It expects input * to be of constant frame rate. */ pkt->pts = avctx->codedframe->pts = pframeoutput->framenum; pkt->dts = pschroparams->dts++; encsize = pframeoutput->size; /* Append the end of sequence information to the last frame in the * sequence. */ if (lastframeinsequence && pschroparams->encbufsize > 0) { memcpy(pkt->data + encsize, pschroparams->encbuf, pschroparams->encbufsize); encsize += pschroparams->encbufsize; avfreep(&pschroparams->encbuf); pschroparams->encbufsize = 0; } if (pframeoutput->keyframe) pkt->flags |= AVPKTFLAGKEY; *gotpacket = 1; error: /* free frame */ libschroedingerfreeframe(pframeoutput); return ret; } ", "target": 0}
{"func": "static int filldefaultreflist(H264Context *h){ MpegEncContext * const s = &h->s; int i; int smallestpocgreaterthancurrent = -1; int structuresel; Picture sortedshortref[32]; Picture fieldentrylist[2][32]; Picture *framelist[2]; if (FIELDPICTURE) { structuresel = PICTFRAME; framelist[0] = fieldentrylist[0]; framelist[1] = fieldentrylist[1]; } else { structuresel = 0; framelist[0] = h->defaultreflist[0]; framelist[1] = h->defaultreflist[1]; } if(h->slicetypenos==FFBTYPE){ int list; int len[2]; int shortlen[2]; int outi; int limit= INTMIN; /* sort frame according to POC in B slice */ for(outi=0; outi<h->shortrefcount; outi++){ int besti=INTMIN; int bestpoc=INTMAX; for(i=0; i<h->shortrefcount; i++){ const int poc= h->shortref[i]->poc; if(poc > limit && poc < bestpoc){ bestpoc= poc; besti= i; } } assert(besti != INTMIN); limit= bestpoc; sortedshortref[outi]= *h->shortref[besti]; tprintf(h->s.avctx, \"sorted poc: %d->%d poc:%d fn:%d\\n\", besti, outi, sortedshortref[outi].poc, sortedshortref[outi].framenum); if (-1 == smallestpocgreaterthancurrent) { if (h->shortref[besti]->poc >= s->currentpictureptr->poc) { smallestpocgreaterthancurrent = outi; } } } tprintf(h->s.avctx, \"current poc: %d, smallestpocgreaterthancurrent: %d\\n\", s->currentpictureptr->poc, smallestpocgreaterthancurrent); // find the largest POC for(list=0; list<2; list++){ int index = 0; int j= -99; int step= list ? -1 : 1; for(i=0; i<h->shortrefcount && index < h->refcount[list]; i++, j+=step) { int sel; while(j<0 || j>= h->shortrefcount){ if(j != -99 && step == (list ? -1 : 1)) return -1; step = -step; j= smallestpocgreaterthancurrent + (step>>1); } sel = sortedshortref[j].reference | structuresel; if(sel != PICTFRAME) continue; framelist[list][index ]= sortedshortref[j]; framelist[list][index++].picid= sortedshortref[j].framenum; } shortlen[list] = index; for(i = 0; i < 16 && index < h->refcount[ list ]; i++){ int sel; if(h->longref[i] == NULL) continue; sel = h->longref[i]->reference | structuresel; if(sel != PICTFRAME) continue; framelist[ list ][index ]= *h->longref[i]; framelist[ list ][index++].picid= i; } len[list] = index; } for(list=0; list<2; list++){ if (FIELDPICTURE) len[list] = splitfieldreflist(h->defaultreflist[list], h->refcount[list], framelist[list], len[list], s->picturestructure, shortlen[list]); // swap the two first elements of L1 when L0 and L1 are identical if(list && len[0] > 1 && len[0] == len[1]) for(i=0; h->defaultreflist[0][i].data[0] == h->defaultreflist[1][i].data[0]; i++) if(i == len[0]){ FFSWAP(Picture, h->defaultreflist[1][0], h->defaultreflist[1][1]); break; } if(len[list] < h->refcount[ list ]) memset(&h->defaultreflist[list][len[list]], 0, sizeof(Picture)*(h->refcount[ list ] - len[list])); } }else{ int index=0; int shortlen; for(i=0; i<h->shortrefcount; i++){ int sel; sel = h->shortref[i]->reference | structuresel; if(sel != PICTFRAME) continue; framelist[0][index ]= *h->shortref[i]; framelist[0][index++].picid= h->shortref[i]->framenum; } shortlen = index; for(i = 0; i < 16; i++){ int sel; if(h->longref[i] == NULL) continue; sel = h->longref[i]->reference | structuresel; if(sel != PICTFRAME) continue; framelist[0][index ]= *h->longref[i]; framelist[0][index++].picid= i; } if (FIELDPICTURE) index = splitfieldreflist(h->defaultreflist[0], h->refcount[0], framelist[0], index, s->picturestructure, shortlen); if(index < h->refcount[0]) memset(&h->defaultreflist[0][index], 0, sizeof(Picture)*(h->refcount[0] - index)); } #ifdef TRACE for (i=0; i<h->refcount[0]; i++) { tprintf(h->s.avctx, \"List0: %s fn:%d 0x%p\\n\", (h->defaultreflist[0][i].longref ? \"LT\" : \"ST\"), h->defaultreflist[0][i].picid, h->defaultreflist[0][i].data[0]); } if(h->slicetypenos==FFBTYPE){ for (i=0; i<h->refcount[1]; i++) { tprintf(h->s.avctx, \"List1: %s fn:%d 0x%p\\n\", (h->defaultreflist[1][i].longref ? \"LT\" : \"ST\"), h->defaultreflist[1][i].picid, h->defaultreflist[1][i].data[0]); } } #endif return 0; } ", "target": 0}
{"func": "void qemusavevmstatecomplete(QEMUFile *f) { QJSON *vmdesc; int vmdesclen; SaveStateEntry *se; int ret; tracesavevmstatecomplete(); cpusynchronizeallstates(); QTAILQFOREACH(se, &savevmstate.handlers, entry) { if (!se->ops || !se->ops->savelivecomplete) { continue; } if (se->ops && se->ops->isactive) { if (!se->ops->isactive(se->opaque)) { continue; } } tracesavevmsectionstart(se->idstr, se->sectionid); savesectionheader(f, se, QEMUVMSECTIONEND); ret = se->ops->savelivecomplete(f, se->opaque); tracesavevmsectionend(se->idstr, se->sectionid, ret); if (ret < 0) { qemufileseterror(f, ret); return; } } vmdesc = qjsonnew(); jsonpropint(vmdesc, \"pagesize\", TARGETPAGESIZE); jsonstartarray(vmdesc, \"devices\"); QTAILQFOREACH(se, &savevmstate.handlers, entry) { if ((!se->ops || !se->ops->savestate) && !se->vmsd) { continue; } tracesavevmsectionstart(se->idstr, se->sectionid); jsonstartobject(vmdesc, NULL); jsonpropstr(vmdesc, \"name\", se->idstr); jsonpropint(vmdesc, \"instanceid\", se->instanceid); savesectionheader(f, se, QEMUVMSECTIONFULL); vmstatesave(f, se, vmdesc); jsonendobject(vmdesc); tracesavevmsectionend(se->idstr, se->sectionid, 0); } qemuputbyte(f, QEMUVMEOF); jsonendarray(vmdesc); qjsonfinish(vmdesc); vmdesclen = strlen(qjsongetstr(vmdesc)); if (shouldsendvmdesc()) { qemuputbyte(f, QEMUVMVMDESCRIPTION); qemuputbe32(f, vmdesclen); qemuputbuffer(f, (uint8t *)qjsongetstr(vmdesc), vmdesclen); } objectunref(OBJECT(vmdesc)); qemufflush(f); }", "target": 1}
{"func": "static void mvpinit (CPUMIPSState *env, const mipsdeft *def) { env->mvp = gmalloc0(sizeof(CPUMIPSMVPContext)); /* MVPConf1 implemented, TLB sharable, no gating storage support, programmable cache partitioning implemented, number of allocatable and sharable TLB entries, MVP has allocatable TCs, 2 VPEs implemented, 5 TCs implemented. */ env->mvp->CP0MVPConf0 = (1 << CP0MVPC0M) | (1 << CP0MVPC0TLBS) | (0 << CP0MVPC0GS) | (1 << CP0MVPC0PCP) | // TODO: actually do 2 VPEs. // (1 << CP0MVPC0TCA) | (0x1 << CP0MVPC0PVPE) | // (0x04 << CP0MVPC0PTC); (1 << CP0MVPC0TCA) | (0x0 << CP0MVPC0PVPE) | (0x00 << CP0MVPC0PTC); #if !defined(CONFIGUSERONLY) /* Usermode has no TLB support */ env->mvp->CP0MVPConf0 |= (env->tlb->nbtlb << CP0MVPC0PTLBE); #endif /* Allocatable CP1 have media extensions, allocatable CP1 have FP support, no UDI implemented, no CP2 implemented, 1 CP1 implemented. */ env->mvp->CP0MVPConf1 = (1 << CP0MVPC1CIM) | (1 << CP0MVPC1CIF) | (0x0 << CP0MVPC1PCX) | (0x0 << CP0MVPC1PCP2) | (0x1 << CP0MVPC1PCP1); } ", "target": 1}
{"func": "static int decodeband(IVI45DecContext *ctx, int planenum, IVIBandDesc *band, AVCodecContext *avctx) { int result, i, t, idx1, idx2, pos; IVITile *tile; band->buf = band->bufs[ctx->dstbuf]; if (!band->buf) { avlog(avctx, AVLOGERROR, \"Band buffer points to no data!\\n\"); return AVERRORINVALIDDATA; } band->refbuf = band->bufs[ctx->refbuf]; band->dataptr = ctx->framedata + (getbitscount(&ctx->gb) >> 3); result = ctx->decodebandhdr(ctx, band, avctx); if (result) { avlog(avctx, AVLOGERROR, \"Error while decoding band header: %d\\n\", result); return result; } if (band->isempty) { avlog(avctx, AVLOGERROR, \"Empty band encountered!\\n\"); return AVERRORINVALIDDATA; } band->rvmap = &ctx->rvmaptabs[band->rvmapsel]; /* apply corrections to the selected rvmap table if present */ for (i = 0; i < band->numcorr; i++) { idx1 = band->corr[i * 2]; idx2 = band->corr[i * 2 + 1]; FFSWAP(uint8t, band->rvmap->runtab[idx1], band->rvmap->runtab[idx2]); FFSWAP(int16t, band->rvmap->valtab[idx1], band->rvmap->valtab[idx2]); } pos = getbitscount(&ctx->gb); for (t = 0; t < band->numtiles; t++) { tile = &band->tiles[t]; if (tile->mbsize != band->mbsize) { avlog(avctx, AVLOGERROR, \"MB sizes mismatch: %d vs. %d\\n\", band->mbsize, tile->mbsize); return AVERRORINVALIDDATA; } tile->isempty = getbits1(&ctx->gb); if (tile->isempty) { iviprocessemptytile(avctx, band, tile, (ctx->planes[0].bands[0].mbsize >> 3) - (band->mbsize >> 3)); avdlog(avctx, \"Empty tile encountered!\\n\"); } else { tile->datasize = ffividectiledatasize(&ctx->gb); if (!tile->datasize) { avlog(avctx, AVLOGERROR, \"Tile data size is zero!\\n\"); return AVERRORINVALIDDATA; } result = ctx->decodembinfo(ctx, band, tile, avctx); if (result < 0) break; result = ffividecodeblocks(&ctx->gb, band, tile); if (result < 0 || ((getbitscount(&ctx->gb) - pos) >> 3) != tile->datasize) { avlog(avctx, AVLOGERROR, \"Corrupted tile data encountered!\\n\"); break; } pos += tile->datasize << 3; // skip to next tile } } /* restore the selected rvmap table by applying its corrections in reverse order */ for (i = band->numcorr-1; i >= 0; i--) { idx1 = band->corr[i*2]; idx2 = band->corr[i*2+1]; FFSWAP(uint8t, band->rvmap->runtab[idx1], band->rvmap->runtab[idx2]); FFSWAP(int16t, band->rvmap->valtab[idx1], band->rvmap->valtab[idx2]); } #ifdef DEBUG if (band->checksumpresent) { uint16t chksum = ivicalcbandchecksum(band); if (chksum != band->checksum) { avlog(avctx, AVLOGERROR, \"Band checksum mismatch! Plane %d, band %d, received: %x, calculated: %x\\n\", band->plane, band->bandnum, band->checksum, chksum); } } #endif aligngetbits(&ctx->gb); return result; } ", "target": 1}
{"func": "static int s390virtiodeviceinit(VirtIOS390Device *dev, VirtIODevice *vdev) { VirtIOS390Bus *bus; int devlen; bus = DOUPCAST(VirtIOS390Bus, bus, dev->qdev.parentbus); dev->vdev = vdev; dev->devoffs = bus->devoffs; dev->featlen = sizeof(uint32t); /* always keep 32 bits features */ devlen = VIRTIODEVOFFSCONFIG; devlen += s390virtiodevicenumvq(dev) * VIRTIOVQCONFIGLEN; devlen += dev->featlen * 2; devlen += virtiobusgetvdevconfiglen(&dev->bus); bus->devoffs += devlen; dev->hostfeatures = virtiobusgetvdevfeatures(&dev->bus, dev->hostfeatures); s390virtiodevicesync(dev); s390virtioresetidx(dev); if (dev->qdev.hotplugged) { S390CPU *cpu = s390cpuaddr2state(0); s390virtioirq(cpu, VIRTIOPARAMDEVADD, dev->devoffs); } return 0; } ", "target": 0}
{"func": "RAMBlock *qemuramallocinternal(ramaddrt size, ramaddrt maxsize, void (*resized)(const char*, uint64t length, void *host), void *host, bool resizeable, MemoryRegion *mr, Error **errp) { RAMBlock *newblock; Error *localerr = NULL; size = HOSTPAGEALIGN(size); maxsize = HOSTPAGEALIGN(maxsize); newblock = gmalloc0(sizeof(*newblock)); newblock->mr = mr; newblock->resized = resized; newblock->usedlength = size; newblock->maxlength = maxsize; assert(maxsize >= size); newblock->fd = -1; newblock->host = host; if (host) { newblock->flags |= RAMPREALLOC; } if (resizeable) { newblock->flags |= RAMRESIZEABLE; } ramblockadd(newblock, &localerr); if (localerr) { gfree(newblock); errorpropagate(errp, localerr); return NULL; } mr->ramblock = newblock; return newblock; } ", "target": 0}
{"func": "static inline void tcgoutmovi(TCGContext *s, TCGType type, int ret, tcgtargetlong arg) { #if defined(sparcv9) && !defined(sparcv8plus) if (arg != (arg & 0xffffffff)) fprintf(stderr, \"unimplemented %s with constant %ld\\n\", func, arg); #endif if (arg == (arg & 0xfff)) tcgout32(s, ARITHOR | INSNRD(ret) | INSNRS1(TCGREGG0) | INSNIMM13(arg)); else { tcgout32(s, SETHI | INSNRD(ret) | ((arg & 0xfffffc00) >> 10)); if (arg & 0x3ff) tcgout32(s, ARITHOR | INSNRD(ret) | INSNRS1(ret) | INSNIMM13(arg & 0x3ff)); } } ", "target": 0}
{"func": "qcryptoblocklukscreate(QCryptoBlock *block, QCryptoBlockCreateOptions *options, QCryptoBlockInitFunc initfunc, QCryptoBlockWriteFunc writefunc, void *opaque, Error **errp) { QCryptoBlockLUKS *luks; QCryptoBlockCreateOptionsLUKS luksopts; Error *localerr = NULL; uint8t *masterkey = NULL; uint8t *slotkey = NULL; uint8t *splitkey = NULL; sizet splitkeylen = 0; sizet i; QCryptoCipher *cipher = NULL; QCryptoIVGen *ivgen = NULL; char *password; const char *cipheralg; const char *ciphermode; const char *ivgenalg; const char *ivgenhashalg = NULL; const char *hashalg; char *ciphermodespec = NULL; QCryptoCipherAlgorithm ivcipheralg = 0; uint64t iters; memcpy(&luksopts, &options->u.luks, sizeof(luksopts)); if (!luksopts.hasitertime) { luksopts.itertime = 2000; } if (!luksopts.hascipheralg) { luksopts.cipheralg = QCRYPTOCIPHERALGAES256; } if (!luksopts.hasciphermode) { luksopts.ciphermode = QCRYPTOCIPHERMODEXTS; } if (!luksopts.hasivgenalg) { luksopts.ivgenalg = QCRYPTOIVGENALGPLAIN64; } if (!luksopts.hashashalg) { luksopts.hashalg = QCRYPTOHASHALGSHA256; } if (luksopts.ivgenalg == QCRYPTOIVGENALGESSIV) { if (!luksopts.hasivgenhashalg) { luksopts.ivgenhashalg = QCRYPTOHASHALGSHA256; luksopts.hasivgenhashalg = true; } } /* Note we're allowing ivgenhashalg to be set even for * non-essiv iv generators that don't need a hash. It will * be silently ignored, for compatibility with dm-crypt */ if (!options->u.luks.keysecret) { errorsetg(errp, \"Parameter 'key-secret' is required for cipher\"); return -1; } password = qcryptosecretlookupasutf8(luksopts.keysecret, errp); if (!password) { return -1; } luks = gnew0(QCryptoBlockLUKS, 1); block->opaque = luks; memcpy(luks->header.magic, qcryptoblockluksmagic, QCRYPTOBLOCKLUKSMAGICLEN); /* We populate the header in native endianness initially and * then convert everything to big endian just before writing * it out to disk */ luks->header.version = QCRYPTOBLOCKLUKSVERSION; qcryptoblockluksuuidgen(luks->header.uuid); cipheralg = qcryptoblocklukscipheralglookup(luksopts.cipheralg, errp); if (!cipheralg) { goto error; } ciphermode = QCryptoCipherModelookup[luksopts.ciphermode]; ivgenalg = QCryptoIVGenAlgorithmlookup[luksopts.ivgenalg]; if (luksopts.hasivgenhashalg) { ivgenhashalg = QCryptoHashAlgorithmlookup[luksopts.ivgenhashalg]; ciphermodespec = gstrdupprintf(\"%s-%s:%s\", ciphermode, ivgenalg, ivgenhashalg); } else { ciphermodespec = gstrdupprintf(\"%s-%s\", ciphermode, ivgenalg); } hashalg = QCryptoHashAlgorithmlookup[luksopts.hashalg]; if (strlen(cipheralg) >= QCRYPTOBLOCKLUKSCIPHERNAMELEN) { errorsetg(errp, \"Cipher name '%s' is too long for LUKS header\", cipheralg); goto error; } if (strlen(ciphermodespec) >= QCRYPTOBLOCKLUKSCIPHERMODELEN) { errorsetg(errp, \"Cipher mode '%s' is too long for LUKS header\", ciphermodespec); goto error; } if (strlen(hashalg) >= QCRYPTOBLOCKLUKSHASHSPECLEN) { errorsetg(errp, \"Hash name '%s' is too long for LUKS header\", hashalg); goto error; } if (luksopts.ivgenalg == QCRYPTOIVGENALGESSIV) { ivcipheralg = qcryptoblockluksessivcipher(luksopts.cipheralg, luksopts.ivgenhashalg, &localerr); if (localerr) { errorpropagate(errp, localerr); goto error; } } else { ivcipheralg = luksopts.cipheralg; } strcpy(luks->header.ciphername, cipheralg); strcpy(luks->header.ciphermode, ciphermodespec); strcpy(luks->header.hashspec, hashalg); luks->header.keybytes = qcryptociphergetkeylen(luksopts.cipheralg); if (luksopts.ciphermode == QCRYPTOCIPHERMODEXTS) { luks->header.keybytes *= 2; } /* Generate the salt used for hashing the master key * with PBKDF later */ if (qcryptorandombytes(luks->header.masterkeysalt, QCRYPTOBLOCKLUKSSALTLEN, errp) < 0) { goto error; } /* Generate random master key */ masterkey = gnew0(uint8t, luks->header.keybytes); if (qcryptorandombytes(masterkey, luks->header.keybytes, errp) < 0) { goto error; } /* Setup the block device payload encryption objects */ block->cipher = qcryptociphernew(luksopts.cipheralg, luksopts.ciphermode, masterkey, luks->header.keybytes, errp); if (!block->cipher) { goto error; } block->kdfhash = luksopts.hashalg; block->niv = qcryptociphergetivlen(luksopts.cipheralg, luksopts.ciphermode); block->ivgen = qcryptoivgennew(luksopts.ivgenalg, ivcipheralg, luksopts.ivgenhashalg, masterkey, luks->header.keybytes, errp); if (!block->ivgen) { goto error; } /* Determine how many iterations we need to hash the master * key, in order to have 1 second of compute time used */ iters = qcryptopbkdf2countiters(luksopts.hashalg, masterkey, luks->header.keybytes, luks->header.masterkeysalt, QCRYPTOBLOCKLUKSSALTLEN, QCRYPTOBLOCKLUKSDIGESTLEN, &localerr); if (localerr) { errorpropagate(errp, localerr); goto error; } if (iters > (ULLONGMAX / luksopts.itertime)) { errorsetgerrno(errp, ERANGE, \"PBKDF iterations %llu too large to scale\", (unsigned long long)iters); goto error; } /* itertime was in millis, but countiters reported for secs */ iters = iters * luksopts.itertime / 1000; /* Why /= 8 ? That matches cryptsetup, but there's no * explanation why they chose /= 8... Probably so that * if all 8 keyslots are active we only spend 1 second * in total time to check all keys */ iters /= 8; if (iters > UINT32MAX) { errorsetgerrno(errp, ERANGE, \"PBKDF iterations %llu larger than %u\", (unsigned long long)iters, UINT32MAX); goto error; } iters = MAX(iters, QCRYPTOBLOCKLUKSMINMASTERKEYITERS); luks->header.masterkeyiterations = iters; /* Hash the master key, saving the result in the LUKS * header. This hash is used when opening the encrypted * device to verify that the user password unlocked a * valid master key */ if (qcryptopbkdf2(luksopts.hashalg, masterkey, luks->header.keybytes, luks->header.masterkeysalt, QCRYPTOBLOCKLUKSSALTLEN, luks->header.masterkeyiterations, luks->header.masterkeydigest, QCRYPTOBLOCKLUKSDIGESTLEN, errp) < 0) { goto error; } /* Although LUKS has multiple key slots, we're just going * to use the first key slot */ splitkeylen = luks->header.keybytes * QCRYPTOBLOCKLUKSSTRIPES; for (i = 0; i < QCRYPTOBLOCKLUKSNUMKEYSLOTS; i++) { luks->header.keyslots[i].active = i == 0 ? QCRYPTOBLOCKLUKSKEYSLOTENABLED : QCRYPTOBLOCKLUKSKEYSLOTDISABLED; luks->header.keyslots[i].stripes = QCRYPTOBLOCKLUKSSTRIPES; /* This calculation doesn't match that shown in the spec, * but instead follows the cryptsetup implementation. */ luks->header.keyslots[i].keyoffset = (QCRYPTOBLOCKLUKSKEYSLOTOFFSET / QCRYPTOBLOCKLUKSSECTORSIZE) + (ROUNDUP(DIVROUNDUP(splitkeylen, QCRYPTOBLOCKLUKSSECTORSIZE), (QCRYPTOBLOCKLUKSKEYSLOTOFFSET / QCRYPTOBLOCKLUKSSECTORSIZE)) * i); } if (qcryptorandombytes(luks->header.keyslots[0].salt, QCRYPTOBLOCKLUKSSALTLEN, errp) < 0) { goto error; } /* Again we determine how many iterations are required to * hash the user password while consuming 1 second of compute * time */ iters = qcryptopbkdf2countiters(luksopts.hashalg, (uint8t *)password, strlen(password), luks->header.keyslots[0].salt, QCRYPTOBLOCKLUKSSALTLEN, luks->header.keybytes, &localerr); if (localerr) { errorpropagate(errp, localerr); goto error; } if (iters > (ULLONGMAX / luksopts.itertime)) { errorsetgerrno(errp, ERANGE, \"PBKDF iterations %llu too large to scale\", (unsigned long long)iters); goto error; } /* itertime was in millis, but countiters reported for secs */ iters = iters * luksopts.itertime / 1000; if (iters > UINT32MAX) { errorsetgerrno(errp, ERANGE, \"PBKDF iterations %llu larger than %u\", (unsigned long long)iters, UINT32MAX); goto error; } luks->header.keyslots[0].iterations = MAX(iters, QCRYPTOBLOCKLUKSMINSLOTKEYITERS); /* Generate a key that we'll use to encrypt the master * key, from the user's password */ slotkey = gnew0(uint8t, luks->header.keybytes); if (qcryptopbkdf2(luksopts.hashalg, (uint8t *)password, strlen(password), luks->header.keyslots[0].salt, QCRYPTOBLOCKLUKSSALTLEN, luks->header.keyslots[0].iterations, slotkey, luks->header.keybytes, errp) < 0) { goto error; } /* Setup the encryption objects needed to encrypt the * master key material */ cipher = qcryptociphernew(luksopts.cipheralg, luksopts.ciphermode, slotkey, luks->header.keybytes, errp); if (!cipher) { goto error; } ivgen = qcryptoivgennew(luksopts.ivgenalg, ivcipheralg, luksopts.ivgenhashalg, slotkey, luks->header.keybytes, errp); if (!ivgen) { goto error; } /* Before storing the master key, we need to vastly * increase its size, as protection against forensic * disk data recovery */ splitkey = gnew0(uint8t, splitkeylen); if (qcryptoafsplitencode(luksopts.hashalg, luks->header.keybytes, luks->header.keyslots[0].stripes, masterkey, splitkey, errp) < 0) { goto error; } /* Now we encrypt the split master key with the key generated * from the user's password, before storing it */ if (qcryptoblockencrypthelper(cipher, block->niv, ivgen, QCRYPTOBLOCKLUKSSECTORSIZE, 0, splitkey, splitkeylen, errp) < 0) { goto error; } /* The total size of the LUKS headers is the partition header + key * slot headers, rounded up to the nearest sector, combined with * the size of each master key material region, also rounded up * to the nearest sector */ luks->header.payloadoffset = (QCRYPTOBLOCKLUKSKEYSLOTOFFSET / QCRYPTOBLOCKLUKSSECTORSIZE) + (ROUNDUP(DIVROUNDUP(splitkeylen, QCRYPTOBLOCKLUKSSECTORSIZE), (QCRYPTOBLOCKLUKSKEYSLOTOFFSET / QCRYPTOBLOCKLUKSSECTORSIZE)) * QCRYPTOBLOCKLUKSNUMKEYSLOTS); block->payloadoffset = luks->header.payloadoffset * QCRYPTOBLOCKLUKSSECTORSIZE; /* Reserve header space to match payload offset */ initfunc(block, block->payloadoffset, &localerr, opaque); if (localerr) { errorpropagate(errp, localerr); goto error; } /* Everything on disk uses Big Endian, so flip header fields * before writing them */ cputobe16s(&luks->header.version); cputobe32s(&luks->header.payloadoffset); cputobe32s(&luks->header.keybytes); cputobe32s(&luks->header.masterkeyiterations); for (i = 0; i < QCRYPTOBLOCKLUKSNUMKEYSLOTS; i++) { cputobe32s(&luks->header.keyslots[i].active); cputobe32s(&luks->header.keyslots[i].iterations); cputobe32s(&luks->header.keyslots[i].keyoffset); cputobe32s(&luks->header.keyslots[i].stripes); } /* Write out the partition header and key slot headers */ writefunc(block, 0, (const uint8t *)&luks->header, sizeof(luks->header), &localerr, opaque); /* Delay checking localerr until we've byte-swapped */ /* Byte swap the header back to native, in case we need * to read it again later */ be16tocpus(&luks->header.version); be32tocpus(&luks->header.payloadoffset); be32tocpus(&luks->header.keybytes); be32tocpus(&luks->header.masterkeyiterations); for (i = 0; i < QCRYPTOBLOCKLUKSNUMKEYSLOTS; i++) { be32tocpus(&luks->header.keyslots[i].active); be32tocpus(&luks->header.keyslots[i].iterations); be32tocpus(&luks->header.keyslots[i].keyoffset); be32tocpus(&luks->header.keyslots[i].stripes); } if (localerr) { errorpropagate(errp, localerr); goto error; } /* Write out the master key material, starting at the * sector immediately following the partition header. */ if (writefunc(block, luks->header.keyslots[0].keyoffset * QCRYPTOBLOCKLUKSSECTORSIZE, splitkey, splitkeylen, errp, opaque) != splitkeylen) { goto error; } luks->cipheralg = luksopts.cipheralg; luks->ciphermode = luksopts.ciphermode; luks->ivgenalg = luksopts.ivgenalg; luks->ivgenhashalg = luksopts.ivgenhashalg; luks->hashalg = luksopts.hashalg; memset(masterkey, 0, luks->header.keybytes); gfree(masterkey); memset(slotkey, 0, luks->header.keybytes); gfree(slotkey); gfree(splitkey); gfree(password); gfree(ciphermodespec); qcryptoivgenfree(ivgen); qcryptocipherfree(cipher); return 0; error: if (masterkey) { memset(masterkey, 0, luks->header.keybytes); } gfree(masterkey); if (slotkey) { memset(slotkey, 0, luks->header.keybytes); } gfree(slotkey); gfree(splitkey); gfree(password); gfree(ciphermodespec); qcryptoivgenfree(ivgen); qcryptocipherfree(cipher); gfree(luks); return -1; } ", "target": 0}
{"func": "static int swfwritetrailer(AVFormatContext *s) { SWFContext *swf = s->privdata; ByteIOContext *pb = &s->pb; AVCodecContext *enc, *videoenc; int filesize, i; videoenc = NULL; for(i=0;i<s->nbstreams;i++) { enc = &s->streams[i]->codec; if (enc->codectype == CODECTYPEVIDEO) videoenc = enc; } putswftag(s, TAGEND); putswfendtag(s); putflushpacket(&s->pb); /* patch file size and number of frames if not streamed */ if (!urlisstreamed(&s->pb) && videoenc) { filesize = urlftell(pb); urlfseek(pb, 4, SEEKSET); putle32(pb, filesize); urlfseek(pb, swf->durationpos, SEEKSET); putle16(pb, videoenc->framenumber); } avfree(swf); return 0; } ", "target": 1}
{"func": "static int xpmdecodeframe(AVCodecContext *avctx, void *data, int *gotframe, AVPacket *avpkt) { XPMDecContext *x = avctx->privdata; AVFrame *p=data; const uint8t *end, *ptr = avpkt->data; int ncolors, cpp, ret, i, j; int64t size; uint32t *dst; avctx->pixfmt = AVPIXFMTBGRA; end = avpkt->data + avpkt->size; while (memcmp(ptr, \"/* XPM */\\n\", 10) && ptr < end - 10) ptr++; if (ptr >= end) { avlog(avctx, AVLOGERROR, \"missing signature\\n\"); return AVERRORINVALIDDATA; } ptr += modstrcspn(ptr, \"\\\"\"); if (sscanf(ptr, \"\\\"%u %u %u %u\\\",\", &avctx->width, &avctx->height, &ncolors, &cpp) != 4) { avlog(avctx, AVLOGERROR, \"missing image parameters\\n\"); return AVERRORINVALIDDATA; } if ((ret = ffsetdimensions(avctx, avctx->width, avctx->height)) < 0) return ret; if ((ret = ffgetbuffer(avctx, p, 0)) < 0) return ret; if (cpp <= 0 || cpp >= 5) { avlog(avctx, AVLOGERROR, \"unsupported/invalid number of chars per pixel: %d\\n\", cpp); return AVERRORINVALIDDATA; } size = 1; for (i = 0; i < cpp; i++) size *= 94; if (ncolors <= 0 || ncolors > size) { avlog(avctx, AVLOGERROR, \"invalid number of colors: %d\\n\", ncolors); return AVERRORINVALIDDATA; } size *= 4; avfastpaddedmalloc(&x->pixels, &x->pixelssize, size); if (!x->pixels) return AVERROR(ENOMEM); ptr += modstrcspn(ptr, \",\") + 1; for (i = 0; i < ncolors; i++) { const uint8t *index; int len; ptr += modstrcspn(ptr, \"\\\"\") + 1; if (ptr + cpp > end) return AVERRORINVALIDDATA; index = ptr; ptr += cpp; ptr = strstr(ptr, \"c \"); if (ptr) { ptr += 2; } else { return AVERRORINVALIDDATA; } len = strcspn(ptr, \"\\\" \"); if ((ret = ascii2index(index, cpp)) < 0) return ret; x->pixels[ret] = colorstringtorgba(ptr, len); ptr += modstrcspn(ptr, \",\") + 1; } for (i = 0; i < avctx->height; i++) { dst = (uint32t *)(p->data[0] + i * p->linesize[0]); ptr += modstrcspn(ptr, \"\\\"\") + 1; for (j = 0; j < avctx->width; j++) { if (ptr + cpp > end) return AVERRORINVALIDDATA; if ((ret = ascii2index(ptr, cpp)) < 0) return ret; *dst++ = x->pixels[ret]; ptr += cpp; } ptr += modstrcspn(ptr, \",\") + 1; } p->keyframe = 1; p->picttype = AVPICTURETYPEI; *gotframe = 1; return avpkt->size; } ", "target": 1}
{"func": "static void ripemd160transform(uint32t *state, const uint8t buffer[64], int ext) { uint32t a, b, c, d, e, f, g, h, i, j; uint32t block[16]; int n; if (ext) { a = state[0]; b = state[1]; c = state[2]; d = state[3]; e = state[4]; f = state[5]; g = state[6]; h = state[7]; i = state[8]; j = state[9]; } else { a = f = state[0]; b = g = state[1]; c = h = state[2]; d = i = state[3]; e = j = state[4]; } for (n = 0; n < 16; n++) block[n] = AVRL32(buffer + 4 * n); for (n = 0; n < 16 - 1;) { ROUND1600TO15(a,b,c,d,e,f,g,h,i,j); ROUND1600TO15(e,a,b,c,d,j,f,g,h,i); ROUND1600TO15(d,e,a,b,c,i,j,f,g,h); ROUND1600TO15(c,d,e,a,b,h,i,j,f,g); ROUND1600TO15(b,c,d,e,a,g,h,i,j,f); } ROUND1600TO15(a,b,c,d,e,f,g,h,i,j); SWAP(a,f) for (; n < 32 - 1;) { ROUND16016TO31(e,a,b,c,d,j,f,g,h,i); ROUND16016TO31(d,e,a,b,c,i,j,f,g,h); ROUND16016TO31(c,d,e,a,b,h,i,j,f,g); ROUND16016TO31(b,c,d,e,a,g,h,i,j,f); ROUND16016TO31(a,b,c,d,e,f,g,h,i,j); } ROUND16016TO31(e,a,b,c,d,j,f,g,h,i); SWAP(b,g) for (; n < 48 - 1;) { ROUND16032TO47(d,e,a,b,c,i,j,f,g,h); ROUND16032TO47(c,d,e,a,b,h,i,j,f,g); ROUND16032TO47(b,c,d,e,a,g,h,i,j,f); ROUND16032TO47(a,b,c,d,e,f,g,h,i,j); ROUND16032TO47(e,a,b,c,d,j,f,g,h,i); } ROUND16032TO47(d,e,a,b,c,i,j,f,g,h); SWAP(c,h) for (; n < 64 - 1;) { ROUND16048TO63(c,d,e,a,b,h,i,j,f,g); ROUND16048TO63(b,c,d,e,a,g,h,i,j,f); ROUND16048TO63(a,b,c,d,e,f,g,h,i,j); ROUND16048TO63(e,a,b,c,d,j,f,g,h,i); ROUND16048TO63(d,e,a,b,c,i,j,f,g,h); } ROUND16048TO63(c,d,e,a,b,h,i,j,f,g); SWAP(d,i) for (; n < 75;) { ROUND16064TO79(b,c,d,e,a,g,h,i,j,f); ROUND16064TO79(a,b,c,d,e,f,g,h,i,j); ROUND16064TO79(e,a,b,c,d,j,f,g,h,i); ROUND16064TO79(d,e,a,b,c,i,j,f,g,h); ROUND16064TO79(c,d,e,a,b,h,i,j,f,g); } ROUND16064TO79(b,c,d,e,a,g,h,i,j,f); SWAP(e,j) if (ext) { state[0] += a; state[1] += b; state[2] += c; state[3] += d; state[4] += e; state[5] += f; state[6] += g; state[7] += h; state[8] += i; state[9] += j; } else { i += c + state[1]; state[1] = state[2] + d + j; state[2] = state[3] + e + f; state[3] = state[4] + a + g; state[4] = state[0] + b + h; state[0] = i; } } ", "target": 0}
{"func": "static void optframesize(const char *arg) { if (avparsevideoframesize(&framewidth, &frameheight, arg) < 0) { fprintf(stderr, \"Incorrect frame size\\n\"); avexit(1); } if ((framewidth % 2) != 0 || (frameheight % 2) != 0) { fprintf(stderr, \"Frame size must be a multiple of 2\\n\"); avexit(1); } } ", "target": 0}
{"func": "static int sdlwritetrailer(AVFormatContext *s) { SDLContext *sdl = s->privdata; sdl->quit = 1; if (sdl->overlay) SDLFreeYUVOverlay(sdl->overlay); if (sdl->eventthread) SDLWaitThread(sdl->eventthread, NULL); if (sdl->mutex) SDLDestroyMutex(sdl->mutex); if (sdl->initcond) SDLDestroyCond(sdl->initcond); if (!sdl->sdlwasalreadyinited) SDLQuit(); return 0; }", "target": 1}
{"func": "void MPVdecodemb(MpegEncContext *s, DCTELEM block[6][64]) { int mbx, mby; int dctlinesize, dctoffset; oppixelsfunc *oppix; qpelmcfunc *opqpix; mbx = s->mbx; mby = s->mby; #ifdef FFPOSTPROCESS quantstore[mby][mbx]=s->qscale; //printf(\"[%02d][%02d] %d\\n\",mbx,mby,s->qscale); #endif /* update DC predictors for P macroblocks */ if (!s->mbintra) { if (s->h263pred || s->h263aic) { if(s->mbintratable[mbx + mby*s->mbwidth]) { int wrap, xy, v; s->mbintratable[mbx + mby*s->mbwidth]=0; wrap = 2 * s->mbwidth + 2; xy = 2 * mbx + 1 + (2 * mby + 1) * wrap; v = 1024; s->dcval[0][xy] = v; s->dcval[0][xy + 1] = v; s->dcval[0][xy + wrap] = v; s->dcval[0][xy + 1 + wrap] = v; /* ac pred */ memset(s->acval[0][xy], 0, 16 * sizeof(INT16)); memset(s->acval[0][xy + 1], 0, 16 * sizeof(INT16)); memset(s->acval[0][xy + wrap], 0, 16 * sizeof(INT16)); memset(s->acval[0][xy + 1 + wrap], 0, 16 * sizeof(INT16)); if (s->h263msmpeg4) { s->codedblock[xy] = 0; s->codedblock[xy + 1] = 0; s->codedblock[xy + wrap] = 0; s->codedblock[xy + 1 + wrap] = 0; } /* chroma */ wrap = s->mbwidth + 2; xy = mbx + 1 + (mby + 1) * wrap; s->dcval[1][xy] = v; s->dcval[2][xy] = v; /* ac pred */ memset(s->acval[1][xy], 0, 16 * sizeof(INT16)); memset(s->acval[2][xy], 0, 16 * sizeof(INT16)); } } else { s->lastdc[0] = 128 << s->intradcprecision; s->lastdc[1] = 128 << s->intradcprecision; s->lastdc[2] = 128 << s->intradcprecision; } } else if (s->h263pred || s->h263aic) s->mbintratable[mbx + mby*s->mbwidth]=1; /* update motion predictor, not for B-frames as they need the motionval from the last P/S-Frame */ if (s->outformat == FMTH263) { //FIXME move into h263.c if possible, format specific stuff shouldnt be here if(s->picttype!=BTYPE){ int xy, wrap, motionx, motiony; wrap = 2 * s->mbwidth + 2; xy = 2 * mbx + 1 + (2 * mby + 1) * wrap; if (s->mbintra) { motionx = 0; motiony = 0; goto motioninit; } else if (s->mvtype == MVTYPE16X16) { motionx = s->mv[0][0][0]; motiony = s->mv[0][0][1]; motioninit: /* no update if 8X8 because it has been done during parsing */ s->motionval[xy][0] = motionx; s->motionval[xy][1] = motiony; s->motionval[xy + 1][0] = motionx; s->motionval[xy + 1][1] = motiony; s->motionval[xy + wrap][0] = motionx; s->motionval[xy + wrap][1] = motiony; s->motionval[xy + 1 + wrap][0] = motionx; s->motionval[xy + 1 + wrap][1] = motiony; } } } if (!(s->encoding && (s->intraonly || s->picttype==BTYPE))) { UINT8 *desty, *destcb, *destcr; UINT8 *mbskipptr; /* avoid copy if macroblock skipped in last frame too dont touch it for B-frames as they need the skip info from the next p-frame */ if (s->picttype != BTYPE) { mbskipptr = &s->mbskiptable[s->mby * s->mbwidth + s->mbx]; if (s->mbskiped) { s->mbskiped = 0; /* if previous was skipped too, then nothing to do ! skip only during decoding as we might trash the buffers during encoding a bit */ if (*mbskipptr != 0 && !s->encoding) goto theend; *mbskipptr = 1; /* indicate that this time we skiped it */ } else { *mbskipptr = 0; /* not skipped */ } } desty = s->currentpicture[0] + (mby * 16 * s->linesize) + mbx * 16; destcb = s->currentpicture[1] + (mby * 8 * (s->linesize >> 1)) + mbx * 8; destcr = s->currentpicture[2] + (mby * 8 * (s->linesize >> 1)) + mbx * 8; if (s->interlaceddct) { dctlinesize = s->linesize * 2; dctoffset = s->linesize; } else { dctlinesize = s->linesize; dctoffset = s->linesize * 8; } if (!s->mbintra) { /* motion handling */ if((s->flags&CODECFLAGHQ) || (!s->encoding)){ if ((!s->norounding) || s->picttype==BTYPE){ oppix = putpixelstab; opqpix= qpelmcrndtab; }else{ oppix = putnorndpixelstab; opqpix= qpelmcnorndtab; } if (s->mvdir & MVDIRFORWARD) { MPVmotion(s, desty, destcb, destcr, 0, s->lastpicture, oppix, opqpix); if ((!s->norounding) || s->picttype==BTYPE) oppix = avgpixelstab; else oppix = avgnorndpixelstab; } if (s->mvdir & MVDIRBACKWARD) { MPVmotion(s, desty, destcb, destcr, 1, s->nextpicture, oppix, opqpix); } } /* add dct residue */ adddct(s, block[0], 0, desty, dctlinesize); adddct(s, block[1], 1, desty + 8, dctlinesize); adddct(s, block[2], 2, desty + dctoffset, dctlinesize); adddct(s, block[3], 3, desty + dctoffset + 8, dctlinesize); adddct(s, block[4], 4, destcb, s->linesize >> 1); adddct(s, block[5], 5, destcr, s->linesize >> 1); } else { /* dct only in intra block */ putdct(s, block[0], 0, desty, dctlinesize); putdct(s, block[1], 1, desty + 8, dctlinesize); putdct(s, block[2], 2, desty + dctoffset, dctlinesize); putdct(s, block[3], 3, desty + dctoffset + 8, dctlinesize); putdct(s, block[4], 4, destcb, s->linesize >> 1); putdct(s, block[5], 5, destcr, s->linesize >> 1); } } theend: emmsc(); //FIXME remove } ", "target": 0}
{"func": "static void kvmhwpoisonpageadd(ramaddrt ramaddr) { HWPoisonPage *page; QLISTFOREACH(page, &hwpoisonpagelist, list) { if (page->ramaddr == ramaddr) { return; } } page = gmalloc(sizeof(HWPoisonPage)); page->ramaddr = ramaddr; QLISTINSERTHEAD(&hwpoisonpagelist, page, list); } ", "target": 1}
{"func": "static int decodeipictureprimaryheader(VC9Context *v) { GetBitContext *gb = &v->s.gb; int pqindex; /* Prolog common to all frametypes should be done in caller */ //BF = Buffer Fullness if (v->profile <= PROFILEMAIN && getbits(gb, 7)) { avlog(v->s.avctx, AVLOGDEBUG, \"I BufferFullness not 0\\n\"); } /* Quantizer stuff */ pqindex = getbits(gb, 5); if (v->quantizermode == QUANTFRAMEIMPLICIT) v->pq = pquanttable[0][pqindex]; else { v->pq = pquanttable[v->quantizermode-1][pqindex]; } if (pqindex < 9) v->halfpq = getbits(gb, 1); if (v->quantizermode == QUANTFRAMEEXPLICIT) v->pquantizer = getbits(gb, 1); avlog(v->s.avctx, AVLOGDEBUG, \"I frame: QP=%i (+%i/2)\\n\", v->pq, v->halfpq); return 0; } ", "target": 1}
{"func": "static void pciemmcfgdatawrite(PCIBus *s, uint32t mmcfgaddr, uint32t val, int len) { PCIDevice *pcidev = pciedevfindbymmcfgaddr(s, mmcfgaddr); if (!pcidev) { return; } pcihostconfigwritecommon(pcidev, PCIEMMCFGCONFOFFSET(mmcfgaddr), pciconfigsize(pcidev), val, len); } ", "target": 1}
{"func": "static int getbits(Jpeg2000DecoderContext *s, int n) { int res = 0; if (s->bufend - s->buf < ((n - s->bitindex) >> 8)) return AVERRORINVALIDDATA; while (--n >= 0) { res <<= 1; if (s->bitindex == 0) { s->bitindex = 7 + (*s->buf != 0xff); s->buf++; } s->bitindex--; res |= (*s->buf >> s->bitindex) & 1; } return res; } ", "target": 1}
{"func": "static int movreadudtastring(MOVContext *c, ByteIOContext *pb, MOVAtom atom) { char *str = NULL; int size; uint16t strsize; if (c->itunesmetadata) { int datasize = getbe32(pb); int tag = getle32(pb); if (tag == MKTAG('d','a','t','a')) { getbe32(pb); // type getbe32(pb); // unknown strsize = datasize - 16; } else return 0; } else { strsize = getbe16(pb); // string length getbe16(pb); // language } switch (atom.type) { case MKTAG(0xa9,'n','a','m'): str = c->fc->title; size = sizeof(c->fc->title); break; case MKTAG(0xa9,'A','R','T'): case MKTAG(0xa9,'w','r','t'): str = c->fc->author; size = sizeof(c->fc->author); break; case MKTAG(0xa9,'c','p','y'): str = c->fc->copyright; size = sizeof(c->fc->copyright); break; case MKTAG(0xa9,'c','m','t'): case MKTAG(0xa9,'i','n','f'): str = c->fc->comment; size = sizeof(c->fc->comment); break; case MKTAG(0xa9,'a','l','b'): str = c->fc->album; size = sizeof(c->fc->album); break; } if (!str) return 0; getbuffer(pb, str, FFMIN(size, strsize)); dprintf(c->fc, \"%.4s %s\\n\", (char*)&atom.type, str); return 0; } ", "target": 0}
{"func": "void aiocontextsetup(AioContext *ctx, Error **errp) { #ifdef CONFIGEPOLL assert(!ctx->epollfd); ctx->epollfd = epollcreate1(EPOLLCLOEXEC); if (ctx->epollfd == -1) { ctx->epollavailable = false; } else { ctx->epollavailable = true; } #endif } ", "target": 1}
{"func": "static int dvbsubdisplayendsegment(AVCodecContext *avctx, const uint8t *buf, int bufsize, AVSubtitle *sub) { DVBSubContext *ctx = avctx->privdata; DVBSubDisplayDefinition *displaydef = ctx->displaydefinition; DVBSubRegion *region; DVBSubRegionDisplay *display; AVSubtitleRect *rect; DVBSubCLUT *clut; uint32t *cluttable; int i; int offsetx=0, offsety=0; sub->rects = NULL; sub->startdisplaytime = 0; sub->enddisplaytime = ctx->timeout * 1000; sub->format = 0; if (displaydef) { offsetx = displaydef->x; offsety = displaydef->y; } sub->numrects = ctx->displaylistsize; if (sub->numrects <= 0) return AVERRORINVALIDDATA; sub->rects = avmalloczarray(sub->numrects * sub->numrects, sizeof(*sub->rects)); if (!sub->rects) return AVERROR(ENOMEM); i = 0; for (display = ctx->displaylist; display; display = display->next) { region = getregion(ctx, display->regionid); rect = sub->rects[i]; if (!region) continue; rect->x = display->xpos + offsetx; rect->y = display->ypos + offsety; rect->w = region->width; rect->h = region->height; rect->nbcolors = 16; rect->type = SUBTITLEBITMAP; rect->pict.linesize[0] = region->width; clut = getclut(ctx, region->clut); if (!clut) clut = &defaultclut; switch (region->depth) { case 2: cluttable = clut->clut4; break; case 8: cluttable = clut->clut256; break; case 4: default: cluttable = clut->clut16; break; } rect->pict.data[1] = avmallocz(AVPALETTESIZE); if (!rect->pict.data[1]) { avfree(sub->rects); return AVERROR(ENOMEM); } memcpy(rect->pict.data[1], cluttable, (1 << region->depth) * sizeof(uint32t)); rect->pict.data[0] = avmalloc(region->bufsize); if (!rect->pict.data[0]) { avfree(rect->pict.data[1]); avfree(sub->rects); return AVERROR(ENOMEM); } memcpy(rect->pict.data[0], region->pbuf, region->bufsize); i++; } sub->numrects = i; #ifdef DEBUG savedisplayset(ctx); #endif return 1; } ", "target": 0}
{"func": "static QUANTFN(pvqencodeband) { return quantbandtemplate(pvq, f, rc, band, X, Y, N, b, blocks, lowband, duration, lowbandout, level, gain, lowbandscratch, fill, 1); } ", "target": 0}
{"func": "static void kvmsetphysmem(targetphysaddrt startaddr, \t\t\t ramaddrt size, \t\t\t ramaddrt physoffset) { KVMState *s = kvmstate; ramaddrt flags = physoffset & ~TARGETPAGEMASK; KVMSlot *mem, old; int err; /* kvm works in page size chunks, but the function may be called with sub-page size and unaligned start address. */ size = TARGETPAGEALIGN(size); startaddr = TARGETPAGEALIGN(startaddr); /* KVM does not support read-only slots */ physoffset &= ~IOMEMROM; while (1) { mem = kvmlookupoverlappingslot(s, startaddr, startaddr + size); if (!mem) { break; } if (flags < IOMEMUNASSIGNED && startaddr >= mem->startaddr && (startaddr + size <= mem->startaddr + mem->memorysize) && (physoffset - startaddr == mem->physoffset - mem->startaddr)) { /* The new slot fits into the existing one and comes with * identical parameters - nothing to be done. */ return; } old = *mem; /* unregister the overlapping slot */ mem->memorysize = 0; err = kvmsetusermemoryregion(s, mem); if (err) { fprintf(stderr, \"%s: error unregistering overlapping slot: %s\\n\", func, strerror(-err)); abort(); } /* Workaround for older KVM versions: we can't join slots, even not by * unregistering the previous ones and then registering the larger * slot. We have to maintain the existing fragmentation. Sigh. * * This workaround assumes that the new slot starts at the same * address as the first existing one. If not or if some overlapping * slot comes around later, we will fail (not seen in practice so far) * - and actually require a recent KVM version. */ if (s->brokensetmemregion && old.startaddr == startaddr && old.memorysize < size && flags < IOMEMUNASSIGNED) { mem = kvmallocslot(s); mem->memorysize = old.memorysize; mem->startaddr = old.startaddr; mem->physoffset = old.physoffset; mem->flags = 0; err = kvmsetusermemoryregion(s, mem); if (err) { fprintf(stderr, \"%s: error updating slot: %s\\n\", func, strerror(-err)); abort(); } startaddr += old.memorysize; physoffset += old.memorysize; size -= old.memorysize; continue; } /* register prefix slot */ if (old.startaddr < startaddr) { mem = kvmallocslot(s); mem->memorysize = startaddr - old.startaddr; mem->startaddr = old.startaddr; mem->physoffset = old.physoffset; mem->flags = 0; err = kvmsetusermemoryregion(s, mem); if (err) { fprintf(stderr, \"%s: error registering prefix slot: %s\\n\", func, strerror(-err)); abort(); } } /* register suffix slot */ if (old.startaddr + old.memorysize > startaddr + size) { ramaddrt sizedelta; mem = kvmallocslot(s); mem->startaddr = startaddr + size; sizedelta = mem->startaddr - old.startaddr; mem->memorysize = old.memorysize - sizedelta; mem->physoffset = old.physoffset + sizedelta; mem->flags = 0; err = kvmsetusermemoryregion(s, mem); if (err) { fprintf(stderr, \"%s: error registering suffix slot: %s\\n\", func, strerror(-err)); abort(); } } } /* in case the KVM bug workaround already \"consumed\" the new slot */ if (!size) return; /* KVM does not need to know about this memory */ if (flags >= IOMEMUNASSIGNED) return; mem = kvmallocslot(s); mem->memorysize = size; mem->startaddr = startaddr; mem->physoffset = physoffset; mem->flags = 0; err = kvmsetusermemoryregion(s, mem); if (err) { fprintf(stderr, \"%s: error registering slot: %s\\n\", func, strerror(-err)); abort(); } } ", "target": 0}
{"func": "static void masterabortmemwrite(void *opaque, hwaddr addr, uint64t val, unsigned size) { } ", "target": 1}
{"func": "void avcodecaligndimensions(AVCodecContext *s, int *width, int *height){ int walign= 1; int halign= 1; switch(s->pixfmt){ case PIXFMTYUV420P: case PIXFMTYUYV422: case PIXFMTUYVY422: case PIXFMTYUV422P: case PIXFMTYUV444P: case PIXFMTGRAY8: case PIXFMTGRAY16BE: case PIXFMTGRAY16LE: case PIXFMTYUVJ420P: case PIXFMTYUVJ422P: case PIXFMTYUVJ444P: case PIXFMTYUVA420P: walign= 16; //FIXME check for non mpeg style codecs and use less alignment halign= 16; break; case PIXFMTYUV411P: case PIXFMTUYYVYY411: walign=32; halign=8; break; case PIXFMTYUV410P: if(s->codecid == CODECIDSVQ1){ walign=64; halign=64; } case PIXFMTRGB555: if(s->codecid == CODECIDRPZA){ walign=4; halign=4; } case PIXFMTPAL8: case PIXFMTBGR8: case PIXFMTRGB8: if(s->codecid == CODECIDSMC){ walign=4; halign=4; } break; case PIXFMTBGR24: if((s->codecid == CODECIDMSZH) || (s->codecid == CODECIDZLIB)){ walign=4; halign=4; } break; default: walign= 1; halign= 1; break; } *width = ALIGN(*width , walign); *height= ALIGN(*height, halign); if(s->codecid == CODECIDH264) *height+=2; // some of the optimized chroma MC reads one line too much }", "target": 1}
{"func": "void ffinitcabacdecoder(CABACContext *c, const uint8t *buf, int bufsize){ c->bytestreamstart= c->bytestream= buf; c->bytestreamend= buf + bufsize; #if CABACBITS == 16 c->low = (*c->bytestream++)<<18; c->low+= (*c->bytestream++)<<10; #else c->low = (*c->bytestream++)<<10; #endif c->low+= ((*c->bytestream++)<<2) + 2; c->range= 0x1FE; } ", "target": 1}
{"func": "static int hlsreadheader(AVFormatContext *s) { void *u = (s->flags & AVFMTFLAGCUSTOMIO) ? NULL : s->pb; HLSContext *c = s->privdata; int ret = 0, i; int highestcurseqno = 0; c->ctx = s; c->interruptcallback = &s->interruptcallback; c->strictstdcompliance = s->strictstdcompliance; c->firstpacket = 1; c->firsttimestamp = AVNOPTSVALUE; c->curtimestamp = AVNOPTSVALUE; if (u) { // get the previous user agent & set back to null if string size is zero updateoptions(&c->useragent, \"user-agent\", u); // get the previous cookies & set back to null if string size is zero updateoptions(&c->cookies, \"cookies\", u); // get the previous headers & set back to null if string size is zero updateoptions(&c->headers, \"headers\", u); // get the previous http proxt & set back to null if string size is zero updateoptions(&c->httpproxy, \"httpproxy\", u); } if ((ret = parseplaylist(c, s->filename, NULL, s->pb)) < 0) goto fail; if ((ret = saveaviooptions(s)) < 0) goto fail; /* Some HLS servers don't like being sent the range header */ avdictset(&c->avioopts, \"seekable\", \"0\", 0); if (c->nvariants == 0) { avlog(NULL, AVLOGWARNING, \"Empty playlist\\n\"); ret = AVERROREOF; goto fail; } /* If the playlist only contained playlists (Master Playlist), * parse each individual playlist. */ if (c->nplaylists > 1 || c->playlists[0]->nsegments == 0) { for (i = 0; i < c->nplaylists; i++) { struct playlist *pls = c->playlists[i]; if ((ret = parseplaylist(c, pls->url, pls, NULL)) < 0) goto fail; } } if (c->variants[0]->playlists[0]->nsegments == 0) { avlog(NULL, AVLOGWARNING, \"Empty playlist\\n\"); ret = AVERROREOF; goto fail; } /* If this isn't a live stream, calculate the total duration of the * stream. */ if (c->variants[0]->playlists[0]->finished) { int64t duration = 0; for (i = 0; i < c->variants[0]->playlists[0]->nsegments; i++) duration += c->variants[0]->playlists[0]->segments[i]->duration; s->duration = duration; } /* Associate renditions with variants */ for (i = 0; i < c->nvariants; i++) { struct variant *var = c->variants[i]; if (var->audiogroup[0]) addrenditionstovariant(c, var, AVMEDIATYPEAUDIO, var->audiogroup); if (var->videogroup[0]) addrenditionstovariant(c, var, AVMEDIATYPEVIDEO, var->videogroup); if (var->subtitlesgroup[0]) addrenditionstovariant(c, var, AVMEDIATYPESUBTITLE, var->subtitlesgroup); } /* Create a program for each variant */ for (i = 0; i < c->nvariants; i++) { struct variant *v = c->variants[i]; AVProgram *program; program = avnewprogram(s, i); if (!program) goto fail; avdictsetint(&program->metadata, \"variantbitrate\", v->bandwidth, 0); } /* Select the starting segments */ for (i = 0; i < c->nplaylists; i++) { struct playlist *pls = c->playlists[i]; if (pls->nsegments == 0) continue; pls->curseqno = selectcurseqno(c, pls); highestcurseqno = FFMAX(highestcurseqno, pls->curseqno); } /* Open the demuxer for each playlist */ for (i = 0; i < c->nplaylists; i++) { struct playlist *pls = c->playlists[i]; AVInputFormat *infmt = NULL; if (!(pls->ctx = avformatalloccontext())) { ret = AVERROR(ENOMEM); goto fail; } if (pls->nsegments == 0) continue; pls->index = i; pls->needed = 1; pls->parent = s; /* * If this is a live stream and this playlist looks like it is one segment * behind, try to sync it up so that every substream starts at the same * time position (so e.g. avformatfindstreaminfo() will see packets from * all active streams within the first few seconds). This is not very generic, * though, as the sequence numbers are technically independent. */ if (!pls->finished && pls->curseqno == highestcurseqno - 1 && highestcurseqno < pls->startseqno + pls->nsegments) { pls->curseqno = highestcurseqno; } pls->readbuffer = avmalloc(INITIALBUFFERSIZE); if (!pls->readbuffer){ ret = AVERROR(ENOMEM); avformatfreecontext(pls->ctx); pls->ctx = NULL; goto fail; } ffioinitcontext(&pls->pb, pls->readbuffer, INITIALBUFFERSIZE, 0, pls, readdata, NULL, NULL); pls->pb.seekable = 0; ret = avprobeinputbuffer(&pls->pb, &infmt, pls->segments[0]->url, NULL, 0, 0); if (ret < 0) { /* Free the ctx - it isn't initialized properly at this point, * so avformatcloseinput shouldn't be called. If * avformatopeninput fails below, it frees and zeros the * context, so it doesn't need any special treatment like this. */ avlog(s, AVLOGERROR, \"Error when loading first segment '%s'\\n\", pls->segments[0]->url); avformatfreecontext(pls->ctx); pls->ctx = NULL; goto fail; } pls->ctx->pb = &pls->pb; pls->ctx->ioopen = nestedioopen; if ((ret = ffcopywhiteblacklists(pls->ctx, s)) < 0) goto fail; ret = avformatopeninput(&pls->ctx, pls->segments[0]->url, infmt, NULL); if (ret < 0) goto fail; if (pls->id3deferredextra && pls->ctx->nbstreams == 1) { ffid3v2parseapic(pls->ctx, &pls->id3deferredextra); avformatqueueattachedpictures(pls->ctx); ffid3v2freeextrameta(&pls->id3deferredextra); pls->id3deferredextra = NULL; } if (pls->isid3timestamped == -1) avlog(s, AVLOGWARNING, \"No expected HTTP requests have been made\\n\"); /* * For ID3 timestamped raw audio streams we need to detect the packet * durations to calculate timestamps in filltimingforid3timestampedstream(), * but for other streams we can rely on our user calling avformatfindstreaminfo() * on us if they want to. */ if (pls->isid3timestamped) { ret = avformatfindstreaminfo(pls->ctx, NULL); if (ret < 0) goto fail; } pls->hasnoheaderflag = !!(pls->ctx->ctxflags & AVFMTCTXNOHEADER); /* Create new AVStreams for each stream in this playlist */ ret = updatestreamsfromsubdemuxer(s, pls); if (ret < 0) goto fail; addmetadatafromrenditions(s, pls, AVMEDIATYPEAUDIO); addmetadatafromrenditions(s, pls, AVMEDIATYPEVIDEO); addmetadatafromrenditions(s, pls, AVMEDIATYPESUBTITLE); } updatenoheaderflag(s); return 0; fail: freeplaylistlist(c); freevariantlist(c); freerenditionlist(c); return ret; } ", "target": 1}
{"func": "AVBitStreamFilterContext *avbitstreamfilterinit(const char *name) { AVBitStreamFilter *bsf = firstbitstreamfilter; while (bsf) { if (!strcmp(name, bsf->name)) { AVBitStreamFilterContext *bsfc = avmallocz(sizeof(AVBitStreamFilterContext)); bsfc->filter = bsf; bsfc->privdata = bsf->privdatasize ? avmallocz(bsf->privdatasize) : NULL; return bsfc; } bsf = bsf->next; } return NULL; } ", "target": 0}
{"func": "PPCOP(divw) { if ((Ts0 == INT32MIN && Ts1 == -1) || Ts1 == 0) { T0 = (int32t)((-1) * (T0 >> 31)); } else { T0 = (Ts0 / Ts1); } RETURN(); } ", "target": 1}
{"func": "BlockInterfaceErrorAction drivegetonerror(BlockDriverState *bdrv) { int index; for (index = 0; index < nbdrives; index++) if (drivestable[index].bdrv == bdrv) return drivestable[index].onerror; return BLOCKERRREPORT; } ", "target": 1}
{"func": "static void netfilterfinalize(Object *obj) { NetFilterState *nf = NETFILTER(obj); NetFilterClass *nfc = NETFILTERGETCLASS(obj); if (nfc->cleanup) { nfc->cleanup(nf); } if (nf->netdev && !QTAILQEMPTY(&nf->netdev->filters)) { QTAILQREMOVE(&nf->netdev->filters, nf, next); } }", "target": 1}
{"func": "static void pccompat14(QEMUMachineInitArgs *args) { pccompat15(args); haspvpanic = false; x86cpucompatsetfeatures(\"n270\", FEAT1ECX, 0, CPUIDEXTMOVBE); x86cpucompatsetfeatures(\"Westmere\", FEAT1ECX, 0, CPUIDEXTPCLMULQDQ); } ", "target": 1}
{"func": "static void amdvirealize(DeviceState *dev, Error **err) { int ret = 0; AMDVIState *s = AMDIOMMUDEVICE(dev); X86IOMMUState *x86iommu = X86IOMMUDEVICE(dev); PCIBus *bus = PCMACHINE(qdevgetmachine())->bus; s->iotlb = ghashtablenewfull(amdviuint64hash, amdviuint64equal, gfree, gfree); /* This device should take care of IOMMU PCI properties */ x86iommu->type = TYPEAMD; qdevsetparentbus(DEVICE(&s->pci), &bus->qbus); objectpropertysetbool(OBJECT(&s->pci), true, \"realized\", err); s->capaboffset = pciaddcapability(&s->pci.dev, AMDVICAPABIDSEC, 0, AMDVICAPABSIZE); assert(s->capaboffset > 0); ret = pciaddcapability(&s->pci.dev, PCICAPIDMSI, 0, AMDVICAPABREGSIZE); assert(ret > 0); ret = pciaddcapability(&s->pci.dev, PCICAPIDHT, 0, AMDVICAPABREGSIZE); assert(ret > 0); /* set up MMIO */ memoryregioninitio(&s->mmio, OBJECT(s), &mmiomemops, s, \"amdvi-mmio\", AMDVIMMIOSIZE); sysbusinitmmio(SYSBUSDEVICE(s), &s->mmio); sysbusmmiomap(SYSBUSDEVICE(s), 0, AMDVIBASEADDR); pcisetupiommu(bus, amdvihostdmaiommu, s); s->devid = objectpropertygetint(OBJECT(&s->pci), \"addr\", err); msiinit(&s->pci.dev, 0, 1, true, false, err); amdviinit(s); } ", "target": 1}
{"func": "int avioclosedynbuf(AVIOContext *s, uint8t **pbuffer) { DynBuffer *d = s->opaque; int size; static const char padbuf[FFINPUTBUFFERPADDINGSIZE] = {0}; int padding = 0; if (!s) { *pbuffer = NULL; return 0; } /* don't attempt to pad fixed-size packet buffers */ if (!s->maxpacketsize) { aviowrite(s, padbuf, sizeof(padbuf)); padding = FFINPUTBUFFERPADDINGSIZE; } avioflush(s); *pbuffer = d->buffer; size = d->size; avfree(d); avfree(s); return size - padding; } ", "target": 1}
{"func": "static void qemunetqueueappend(NetQueue *queue, NetClientState *sender, unsigned flags, const uint8t *buf, sizet size, NetPacketSent *sentcb) { NetPacket *packet; if (queue->nqcount >= queue->nqmaxlen && !sentcb) { return; /* drop if queue full and no callback */ } packet = gmalloc(sizeof(NetPacket) + size); packet->sender = sender; packet->flags = flags; packet->size = size; packet->sentcb = sentcb; memcpy(packet->data, buf, size); QTAILQINSERTTAIL(&queue->packets, packet, entry); }", "target": 1}
{"func": "static void decodesubframelpc(ShortenContext *s, int channel, int residualsize, int predorder) { int sum, i, j; int coeffs[predorder]; for (i=0; i<predorder; i++) coeffs[i] = getsrgolombshorten(&s->gb, LPCQUANT); for (i=0; i < s->blocksize; i++) { sum = s->lpcqoffset; for (j=0; j<predorder; j++) sum += coeffs[j] * s->decoded[channel][i-j-1]; s->decoded[channel][i] = getsrgolombshorten(&s->gb, residualsize) + (sum >> LPCQUANT); } } ", "target": 1}
{"func": "bool timerlistexpired(QEMUTimerList *timerlist) { int64t expiretime; if (!atomicread(&timerlist->activetimers)) { return false; } qemumutexlock(&timerlist->activetimerslock); if (!timerlist->activetimers) { qemumutexunlock(&timerlist->activetimerslock); return false; } expiretime = timerlist->activetimers->expiretime; qemumutexunlock(&timerlist->activetimerslock); return expiretime < qemuclockgetns(timerlist->clock->type); } ", "target": 1}
{"func": "static int pxr24uncompress(EXRContext *s, const uint8t *src, int compressedsize, int uncompressedsize, EXRThreadData *td) { unsigned long destlen, expectedlen = 0; const uint8t *in = td->tmp; uint8t *out; int c, i, j; for (i = 0; i < s->nbchannels; i++) { if (s->channels[i].pixeltype == EXRFLOAT) { expectedlen += (td->xsize * td->ysize * 3);/* PRX 24 store float in 24 bit instead of 32 */ } else if (s->channels[i].pixeltype == EXRHALF) { expectedlen += (td->xsize * td->ysize * 2); } else {//UINT 32 expectedlen += (td->xsize * td->ysize * 4); } } destlen = expectedlen; if (uncompress(td->tmp, &destlen, src, compressedsize) != ZOK) { return AVERRORINVALIDDATA; } else if (destlen != expectedlen) { return AVERRORINVALIDDATA; } out = td->uncompresseddata; for (i = 0; i < td->ysize; i++) for (c = 0; c < s->nbchannels; c++) { EXRChannel *channel = &s->channels[c]; const uint8t *ptr[4]; uint32t pixel = 0; switch (channel->pixeltype) { case EXRFLOAT: ptr[0] = in; ptr[1] = ptr[0] + td->xsize; ptr[2] = ptr[1] + td->xsize; in = ptr[2] + td->xsize; for (j = 0; j < td->xsize; ++j) { uint32t diff = (*(ptr[0]++) << 24) | (*(ptr[1]++) << 16) | (*(ptr[2]++) << 8); pixel += diff; bytestreamputle32(&out, pixel); } break; case EXRHALF: ptr[0] = in; ptr[1] = ptr[0] + td->xsize; in = ptr[1] + td->xsize; for (j = 0; j < td->xsize; j++) { uint32t diff = (*(ptr[0]++) << 8) | *(ptr[1]++); pixel += diff; bytestreamputle16(&out, pixel); } break; case EXRUINT: ptr[0] = in; ptr[1] = ptr[0] + s->xdelta; ptr[2] = ptr[1] + s->xdelta; ptr[3] = ptr[2] + s->xdelta; in = ptr[3] + s->xdelta; for (j = 0; j < s->xdelta; ++j) { uint32t diff = (*(ptr[0]++) << 24) | (*(ptr[1]++) << 16) | (*(ptr[2]++) << 8 ) | (*(ptr[3]++)); pixel += diff; bytestreamputle32(&out, pixel); } break; default: return AVERRORINVALIDDATA; } } return 0; } ", "target": 1}
{"func": "static int movreaddefault(MOVContext *c, AVIOContext *pb, MOVAtom atom) { int64t totalsize = 0; MOVAtom a; int i; if (atom.size < 0) atom.size = INT64MAX; while (totalsize + 8 <= atom.size && !aviofeof(pb)) { int (*parse)(MOVContext*, AVIOContext*, MOVAtom) = NULL; a.size = atom.size; a.type=0; if (atom.size >= 8) { a.size = aviorb32(pb); a.type = aviorl32(pb); if (a.type == MKTAG('f','r','e','e') && a.size >= 8 && c->moovretry) { uint8t buf[8]; uint32t *type = (uint32t *)buf + 1; avioread(pb, buf, 8); avioseek(pb, -8, SEEKCUR); if (*type == MKTAG('m','v','h','d') || *type == MKTAG('c','m','o','v')) { avlog(c->fc, AVLOGERROR, \"Detected moov in a free atom.\\n\"); a.type = MKTAG('m','o','o','v'); } } if (atom.type != MKTAG('r','o','o','t') && atom.type != MKTAG('m','o','o','v')) { if (a.type == MKTAG('t','r','a','k') || a.type == MKTAG('m','d','a','t')) { avlog(c->fc, AVLOGERROR, \"Broken file, trak/mdat not at top-level\\n\"); avioskip(pb, -8); return 0; } } totalsize += 8; if (a.size == 1) { /* 64 bit extended size */ a.size = aviorb64(pb) - 8; totalsize += 8; } } avdlog(c->fc, \"type: %08x '%.4s' parent:'%.4s' sz: %\"PRId64\" %\"PRId64\" %\"PRId64\"\\n\", a.type, (char*)&a.type, (char*)&atom.type, a.size, totalsize, atom.size); if (a.size == 0) { a.size = atom.size - totalsize + 8; } a.size -= 8; if (a.size < 0) break; a.size = FFMIN(a.size, atom.size - totalsize); for (i = 0; movdefaultparsetable[i].type; i++) if (movdefaultparsetable[i].type == a.type) { parse = movdefaultparsetable[i].parse; break; } // container is user data if (!parse && (atom.type == MKTAG('u','d','t','a') || atom.type == MKTAG('i','l','s','t'))) parse = movreadudtastring; if (!parse) { /* skip leaf atoms data */ avioskip(pb, a.size); } else { int64t startpos = aviotell(pb); int64t left; int err = parse(c, pb, a); if (err < 0) return err; if (c->foundmoov && c->foundmdat && ((!pb->seekable || c->fc->flags & AVFMTFLAGIGNIDX) || startpos + a.size == aviosize(pb))) { if (!pb->seekable || c->fc->flags & AVFMTFLAGIGNIDX) c->nextrootatom = startpos + a.size; return 0; } left = a.size - aviotell(pb) + startpos; if (left > 0) /* skip garbage at atom end */ avioskip(pb, left); else if (left < 0) { avlog(c->fc, AVLOGWARNING, \"overread end of atom '%.4s' by %\"PRId64\" bytes\\n\", (char*)&a.type, -left); avioseek(pb, left, SEEKCUR); } } totalsize += a.size; } if (totalsize < atom.size && atom.size < 0x7ffff) avioskip(pb, atom.size - totalsize); return 0; } ", "target": 1}
{"func": "static int ahcipopulatesglist(AHCIDevice *ad, QEMUSGList *sglist, AHCICmdHdr *cmd, int64t limit, int32t offset) { uint16t opts = le16tocpu(cmd->opts); uint16t prdtl = le16tocpu(cmd->prdtl); uint64t cfisaddr = le64tocpu(cmd->tbladdr); uint64t prdtaddr = cfisaddr + 0x80; dmaaddrt prdtlen = (prdtl * sizeof(AHCISG)); dmaaddrt realprdtlen = prdtlen; uint8t *prdt; int i; int r = 0; uint64t sum = 0; int offidx = -1; int64t offpos = -1; int tblentrysize; IDEBus *bus = &ad->port; BusState *qbus = BUS(bus); /* * Note: AHCI PRDT can describe up to 256GiB. SATA/ATA only support * transactions of up to 32MiB as of ATA8-ACS3 rev 1b, assuming a * 512 byte sector size. We limit the PRDT in this implementation to * a reasonably large 2GiB, which can accommodate the maximum transfer * request for sector sizes up to 32K. */ if (!prdtl) { DPRINTF(ad->portno, \"no sg list given by guest: 0x%08x\\n\", opts); return -1; } /* map PRDT */ if (!(prdt = dmamemorymap(ad->hba->as, prdtaddr, &prdtlen, DMADIRECTIONTODEVICE))){ DPRINTF(ad->portno, \"map failed\\n\"); return -1; } if (prdtlen < realprdtlen) { DPRINTF(ad->portno, \"mapped less than expected\\n\"); r = -1; goto out; } /* Get entries in the PRDT, init a qemu sglist accordingly */ if (prdtl > 0) { AHCISG *tbl = (AHCISG *)prdt; sum = 0; for (i = 0; i < prdtl; i++) { tblentrysize = prdttblentrysize(&tbl[i]); if (offset < (sum + tblentrysize)) { offidx = i; offpos = offset - sum; break; } sum += tblentrysize; } if ((offidx == -1) || (offpos < 0) || (offpos > tblentrysize)) { DPRINTF(ad->portno, \"%s: Incorrect offset! \" \"offidx: %d, offpos: %\"PRId64\"\\n\", func, offidx, offpos); r = -1; goto out; } qemusglistinit(sglist, qbus->parent, (prdtl - offidx), ad->hba->as); qemusglistadd(sglist, le64tocpu(tbl[offidx].addr) + offpos, MIN(prdttblentrysize(&tbl[offidx]) - offpos, limit)); for (i = offidx + 1; i < prdtl && sglist->size < limit; i++) { qemusglistadd(sglist, le64tocpu(tbl[i].addr), MIN(prdttblentrysize(&tbl[i]), limit - sglist->size)); if (sglist->size > INT32MAX) { errorreport(\"AHCI Physical Region Descriptor Table describes \" \"more than 2 GiB.\"); qemusglistdestroy(sglist); r = -1; goto out; } } } out: dmamemoryunmap(ad->hba->as, prdt, prdtlen, DMADIRECTIONTODEVICE, prdtlen); return r; } ", "target": 1}
{"func": "static void dwtencode97int(DWTContext *s, int *t) { int lev, w = s->linelen[s->ndeclevels-1][0]; int *line = s->ilinebuf; line += 5; for (lev = s->ndeclevels-1; lev >= 0; lev--){ int lh = s->linelen[lev][0], lv = s->linelen[lev][1], mh = s->mod[lev][0], mv = s->mod[lev][1], lp; int *l; // VERSD l = line + mv; for (lp = 0; lp < lh; lp++) { int i, j = 0; for (i = 0; i < lv; i++) l[i] = t[w*i + lp]; sd1d97int(line, mv, mv + lv); // copy back and deinterleave for (i = mv; i < lv; i+=2, j++) t[w*j + lp] = ((l[i] * ILFTGX) + (1 << 16)) >> 17; for (i = 1-mv; i < lv; i+=2, j++) t[w*j + lp] = ((l[i] * ILFTGK) + (1 << 16)) >> 17; } // HORSD l = line + mh; for (lp = 0; lp < lv; lp++){ int i, j = 0; for (i = 0; i < lh; i++) l[i] = t[w*lp + i]; sd1d97int(line, mh, mh + lh); // copy back and deinterleave for (i = mh; i < lh; i+=2, j++) t[w*lp + j] = ((l[i] * ILFTGX) + (1 << 16)) >> 17; for (i = 1-mh; i < lh; i+=2, j++) t[w*lp + j] = ((l[i] * ILFTGK) + (1 << 16)) >> 17; } } } ", "target": 1}
{"func": "static void decodepostinit(H264Context *h){ MpegEncContext * const s = &h->s; Picture *out = s->currentpictureptr; Picture *cur = s->currentpictureptr; int i, pics, outoforder, outidx; s->currentpictureptr->qscaletype= FFQSCALETYPEH264; s->currentpictureptr->picttype= s->picttype; if (h->nextoutputpic) return; if (cur->fieldpoc[0]==INTMAX || cur->fieldpoc[1]==INTMAX) { //FIXME this allows the next thread to start once we encounter the first field of a PAFF packet //This works if the next packet contains the second field. It does not work if both fields are //in the same packet. //ffthreadfinishsetup(s->avctx); return; } cur->interlacedframe = 0; cur->repeatpict = 0; /* Signal interlacing information externally. */ /* Prioritize picture timing SEI information over used decoding process if it exists. */ if(h->sps.picstructpresentflag){ switch (h->seipicstruct) { case SEIPICSTRUCTFRAME: break; case SEIPICSTRUCTTOPFIELD: case SEIPICSTRUCTBOTTOMFIELD: cur->interlacedframe = 1; break; case SEIPICSTRUCTTOPBOTTOM: case SEIPICSTRUCTBOTTOMTOP: if (FIELDORMBAFFPICTURE) cur->interlacedframe = 1; else // try to flag soft telecine progressive cur->interlacedframe = h->previnterlacedframe; break; case SEIPICSTRUCTTOPBOTTOMTOP: case SEIPICSTRUCTBOTTOMTOPBOTTOM: // Signal the possibility of telecined film externally (picstruct 5,6) // From these hints, let the applications decide if they apply deinterlacing. cur->repeatpict = 1; break; case SEIPICSTRUCTFRAMEDOUBLING: // Force progressive here, as doubling interlaced frame is a bad idea. cur->repeatpict = 2; break; case SEIPICSTRUCTFRAMETRIPLING: cur->repeatpict = 4; break; } if ((h->seicttype & 3) && h->seipicstruct <= SEIPICSTRUCTBOTTOMTOP) cur->interlacedframe = (h->seicttype & (1<<1)) != 0; }else{ /* Derive interlacing flag from used decoding process. */ cur->interlacedframe = FIELDORMBAFFPICTURE; } h->previnterlacedframe = cur->interlacedframe; if (cur->fieldpoc[0] != cur->fieldpoc[1]){ /* Derive topfieldfirst from field pocs. */ cur->topfieldfirst = cur->fieldpoc[0] < cur->fieldpoc[1]; }else{ if(cur->interlacedframe || h->sps.picstructpresentflag){ /* Use picture timing SEI information. Even if it is a information of a past frame, better than nothing. */ if(h->seipicstruct == SEIPICSTRUCTTOPBOTTOM || h->seipicstruct == SEIPICSTRUCTTOPBOTTOMTOP) cur->topfieldfirst = 1; else cur->topfieldfirst = 0; }else{ /* Most likely progressive */ cur->topfieldfirst = 0; } } //FIXME do something with unavailable reference frames /* Sort B-frames into display order */ if(h->sps.bitstreamrestrictionflag && s->avctx->hasbframes < h->sps.numreorderframes){ s->avctx->hasbframes = h->sps.numreorderframes; s->lowdelay = 0; } if( s->avctx->strictstdcompliance >= FFCOMPLIANCESTRICT && !h->sps.bitstreamrestrictionflag){ s->avctx->hasbframes= MAXDELAYEDPICCOUNT; s->lowdelay= 0; } pics = 0; while(h->delayedpic[pics]) pics++; assert(pics <= MAXDELAYEDPICCOUNT); h->delayedpic[pics++] = cur; if(cur->reference == 0) cur->reference = DELAYEDPICREF; out = h->delayedpic[0]; outidx = 0; for(i=1; h->delayedpic[i] && !h->delayedpic[i]->keyframe && !h->delayedpic[i]->mmcoreset; i++) if(h->delayedpic[i]->poc < out->poc){ out = h->delayedpic[i]; outidx = i; } if(s->avctx->hasbframes == 0 && (h->delayedpic[0]->keyframe || h->delayedpic[0]->mmcoreset)) h->nextoutputedpoc= INTMIN; outoforder = out->poc < h->nextoutputedpoc; if(h->sps.bitstreamrestrictionflag && s->avctx->hasbframes >= h->sps.numreorderframes) { } else if((outoforder && pics-1 == s->avctx->hasbframes && s->avctx->hasbframes < MAXDELAYEDPICCOUNT) || (s->lowdelay && ((h->nextoutputedpoc != INTMIN && out->poc > h->nextoutputedpoc + 2) || cur->picttype == AVPICTURETYPEB))) { s->lowdelay = 0; s->avctx->hasbframes++; } if(outoforder || pics > s->avctx->hasbframes){ out->reference &= ~DELAYEDPICREF; out->owner2 = s; // for frame threading, the owner must be the second field's thread // or else the first thread can release the picture and reuse it unsafely for(i=outidx; h->delayedpic[i]; i++) h->delayedpic[i] = h->delayedpic[i+1]; } if(!outoforder && pics > s->avctx->hasbframes){ h->nextoutputpic = out; if(outidx==0 && h->delayedpic[0] && (h->delayedpic[0]->keyframe || h->delayedpic[0]->mmcoreset)) { h->nextoutputedpoc = INTMIN; } else h->nextoutputedpoc = out->poc; }else{ avlog(s->avctx, AVLOGDEBUG, \"no picture\\n\"); } ffthreadfinishsetup(s->avctx); } ", "target": 1}
{"func": "void errorpropagate(Error **dsterrp, Error *localerr) { if (localerr && dsterrp == &errorabort) { errorreporterr(localerr); abort(); } else if (dsterrp && !*dsterrp) { *dsterrp = localerr; } else if (localerr) { errorfree(localerr); } } ", "target": 1}
{"func": "genmsub32q(TCGv ret, TCGv arg1, TCGv arg2, TCGv arg3, uint32t n, uint32t upshift, CPUTriCoreState *env) { TCGv temp = tcgtempnew(); TCGv temp2 = tcgtempnew(); TCGv temp3 = tcgtempnew(); TCGvi64 t1 = tcgtempnewi64(); TCGvi64 t2 = tcgtempnewi64(); TCGvi64 t3 = tcgtempnewi64(); TCGvi64 t4 = tcgtempnewi64(); tcggenexti32i64(t2, arg2); tcggenexti32i64(t3, arg3); tcggenmuli64(t2, t2, t3); tcggenexti32i64(t1, arg1); /* if we shift part of the fraction out, we need to round up */ tcggenandii64(t4, t2, (1ll << (upshift - n)) - 1); tcggensetcondii64(TCGCONDNE, t4, t4, 0); tcggensarii64(t2, t2, upshift - n); tcggenaddi64(t2, t2, t4); tcggensubi64(t3, t1, t2); tcggentrunci64i32(temp3, t3); /* calc v bit */ tcggensetcondii64(TCGCONDGT, t1, t3, 0x7fffffffLL); tcggensetcondii64(TCGCONDLT, t2, t3, -0x80000000LL); tcggenori64(t1, t1, t2); tcggentrunci64i32(cpuPSWV, t1); tcggenshlitl(cpuPSWV, cpuPSWV, 31); /* We produce an overflow on the host if the mul before was (0x80000000 * 0x80000000) << 1). If this is the case, we negate the ovf. */ if (n == 1) { tcggensetconditl(TCGCONDEQ, temp, arg2, 0x80000000); tcggensetcondtl(TCGCONDEQ, temp2, arg2, arg3); tcggenandtl(temp, temp, temp2); tcggenshlitl(temp, temp, 31); /* negate v bit, if special condition */ tcggenxortl(cpuPSWV, cpuPSWV, temp); } /* Calc SV bit */ tcggenortl(cpuPSWSV, cpuPSWSV, cpuPSWV); /* Calc AV/SAV bits */ tcggenaddtl(cpuPSWAV, temp3, temp3); tcggenxortl(cpuPSWAV, temp3, cpuPSWAV); /* calc SAV */ tcggenortl(cpuPSWSAV, cpuPSWSAV, cpuPSWAV); /* write back result */ tcggenmovtl(ret, temp3); tcgtempfree(temp); tcgtempfree(temp2); tcgtempfree(temp3); tcgtempfreei64(t1); tcgtempfreei64(t2); tcgtempfreei64(t3); tcgtempfreei64(t4); } ", "target": 1}
{"func": "int32 float64toint32roundtozero( float64 a STATUSPARAM ) { flag aSign; int16 aExp, shiftCount; uint64t aSig, savedASig; int32 z; a = float64squashinputdenormal(a STATUSVAR); aSig = extractFloat64Frac( a ); aExp = extractFloat64Exp( a ); aSign = extractFloat64Sign( a ); if ( 0x41E < aExp ) { if ( ( aExp == 0x7FF ) && aSig ) aSign = 0; goto invalid; } else if ( aExp < 0x3FF ) { if ( aExp || aSig ) STATUS(floatexceptionflags) |= floatflaginexact; return 0; } aSig |= LIT64( 0x0010000000000000 ); shiftCount = 0x433 - aExp; savedASig = aSig; aSig >>= shiftCount; z = aSig; if ( aSign ) z = - z; if ( ( z < 0 ) ^ aSign ) { invalid: floatraise( floatflaginvalid STATUSVAR); return aSign ? (int32t) 0x80000000 : 0x7FFFFFFF; } if ( ( aSig<<shiftCount ) != savedASig ) { STATUS(floatexceptionflags) |= floatflaginexact; } return z; } ", "target": 1}
{"func": "BlockReopenQueue *bdrvreopenqueue(BlockReopenQueue *bsqueue, BlockDriverState *bs, int flags) { assert(bs != NULL); BlockReopenQueueEntry *bsentry; if (bsqueue == NULL) { bsqueue = gnew0(BlockReopenQueue, 1); QSIMPLEQINIT(bsqueue); } /* bdrvopen() masks this flag out */ flags &= ~BDRVOPROTOCOL; if (bs->file) { bdrvreopenqueue(bsqueue, bs->file, bdrvinheritedflags(flags)); } bsentry = gnew0(BlockReopenQueueEntry, 1); QSIMPLEQINSERTTAIL(bsqueue, bsentry, entry); bsentry->state.bs = bs; bsentry->state.flags = flags; return bsqueue; } ", "target": 0}
{"func": "static void formatline(void *ptr, int level, const char *fmt, valist vl, AVBPrint part[3], int *printprefix, int type[2]) { AVClass* avc = ptr ? *(AVClass **) ptr : NULL; avbprintinit(part+0, 0, 1); avbprintinit(part+1, 0, 1); avbprintinit(part+2, 0, 65536); if(type) type[0] = type[1] = AVCLASSCATEGORYNA + 16; if (*printprefix && avc) { if (avc->parentlogcontextoffset) { AVClass** parent = *(AVClass ***) (((uint8t *) ptr) + avc->parentlogcontextoffset); if (parent && *parent) { avbprintf(part+0, \"[%s @ %p] \", (*parent)->itemname(parent), parent); if(type) type[0] = getcategory(parent); } } avbprintf(part+1, \"[%s @ %p] \", avc->itemname(ptr), ptr); if(type) type[1] = getcategory(ptr); } avvbprintf(part+2, fmt, vl); if(*part[0].str || *part[1].str || *part[2].str) { char lastc = part[2].len ? part[2].str[part[2].len - 1] : 0; *printprefix = lastc == '\\n' || lastc == '\\r'; } } ", "target": 0}
{"func": "static int dnxhdinitvlc(DNXHDContext *ctx, uint32t cid) { if (cid != ctx->cid) { int index; if ((index = ffdnxhdgetcidtable(cid)) < 0) { avlog(ctx->avctx, AVLOGERROR, \"unsupported cid %d\\n\", cid); return AVERROR(ENOSYS); } if (ffdnxhdcidtable[index].bitdepth != ctx->bitdepth) { avlog(ctx->avctx, AVLOGERROR, \"bit depth mismatches %d %d\\n\", ffdnxhdcidtable[index].bitdepth, ctx->bitdepth); return AVERRORINVALIDDATA; } ctx->cidtable = &ffdnxhdcidtable[index]; avlog(ctx->avctx, AVLOGVERBOSE, \"Profile cid %d.\\n\", cid); fffreevlc(&ctx->acvlc); fffreevlc(&ctx->dcvlc); fffreevlc(&ctx->runvlc); initvlc(&ctx->acvlc, DNXHDVLCBITS, 257, ctx->cidtable->acbits, 1, 1, ctx->cidtable->accodes, 2, 2, 0); initvlc(&ctx->dcvlc, DNXHDDCVLCBITS, ctx->bitdepth + 4, ctx->cidtable->dcbits, 1, 1, ctx->cidtable->dccodes, 1, 1, 0); initvlc(&ctx->runvlc, DNXHDVLCBITS, 62, ctx->cidtable->runbits, 1, 1, ctx->cidtable->runcodes, 2, 2, 0); ctx->cid = cid; } return 0; } ", "target": 0}
{"func": "static void checkdefaultsettings(AVCodecContext *avctx) { X264Context *x4 = avctx->privdata; int score = 0; score += x4->params.analyse.imerange == 0; score += x4->params.rc.iqpstep == 3; score += x4->params.ikeyintmax == 12; score += x4->params.rc.iqpmin == 2; score += x4->params.rc.iqpmax == 31; score += x4->params.rc.fqcompress == 0.5; score += fabs(x4->params.rc.fipfactor - 1.25) < 0.01; score += fabs(x4->params.rc.fpbfactor - 1.25) < 0.01; score += x4->params.analyse.inter == 0 && x4->params.analyse.isubpelrefine == 8; if (score >= 5) { avlog(avctx, AVLOGERROR, \"Default settings detected, using medium profile\\n\"); x4->preset = avstrdup(\"medium\"); if (avctx->bitrate == 200*1000) avctx->crf = 23; } } ", "target": 0}
{"func": "int kvmsetsignalmask(CPUState *env, const sigsett *sigset) { struct kvmsignalmask *sigmask; int r; if (!sigset) return kvmvcpuioctl(env, KVMSETSIGNALMASK, NULL); sigmask = qemumalloc(sizeof(*sigmask) + sizeof(*sigset)); sigmask->len = 8; memcpy(sigmask->sigset, sigset, sizeof(*sigset)); r = kvmvcpuioctl(env, KVMSETSIGNALMASK, sigmask); free(sigmask); return r; } ", "target": 0}
{"func": "static int unixclose(void *opaque) { QEMUFileSocket *s = opaque; close(s->fd); gfree(s); return 0; } ", "target": 1}
{"func": "static int mpegdecodeframe(AVCodecContext *avctx, void *data, int *datasize, AVPacket *avpkt) { const uint8t *buf = avpkt->data; int bufsize = avpkt->size; Mpeg1Context *s = avctx->privdata; AVFrame *picture = data; MpegEncContext *s2 = &s->mpegencctx; avdlog(avctx, \"fillbuffer\\n\"); if (bufsize == 0 || (bufsize == 4 && AVRB32(buf) == SEQENDCODE)) { /* special case for last picture */ if (s2->lowdelay == 0 && s2->nextpictureptr) { *picture = s2->nextpictureptr->f; s2->nextpictureptr = NULL; *datasize = sizeof(AVFrame); } return bufsize; } if (s2->flags & CODECFLAGTRUNCATED) { int next = ffmpeg1findframeend(&s2->parsecontext, buf, bufsize, NULL); if (ffcombineframe(&s2->parsecontext, next, (const uint8t **)&buf, &bufsize) < 0) return bufsize; } s2->codectag = avprivtoupper4(avctx->codectag); if (s->mpegencctxallocated == 0 && ( s2->codectag == AVRL32(\"VCR2\") || s2->codectag == AVRL32(\"BW10\") )) vcr2initsequence(avctx); s->slicecount = 0; if (avctx->extradata && !avctx->framenumber) { int ret = decodechunks(avctx, picture, datasize, avctx->extradata, avctx->extradatasize); if(*datasize) { avlog(avctx, AVLOGERROR, \"picture in extradata\\n\"); *datasize = 0; } if (ret < 0 && (avctx->errrecognition & AVEFEXPLODE)) return ret; } return decodechunks(avctx, picture, datasize, buf, bufsize); } ", "target": 0}
{"func": "static void fdchrread(void *opaque) { CharDriverState *chr = opaque; FDCharDriver *s = chr->opaque; int size, len; uint8t buf[1024]; len = sizeof(buf); if (len > s->maxsize) len = s->maxsize; if (len == 0) return; size = read(s->fdin, buf, len); if (size == 0) { /* FD has been closed. Remove it from the active list. */ qemusetfdhandler2(s->fdin, NULL, NULL, NULL, NULL); qemuchrevent(chr, CHREVENTCLOSED); return; } if (size > 0) { qemuchrread(chr, buf, size); } } ", "target": 0}
{"func": "static void smbiosbuildtype1fields(QemuOpts *opts) { const char *val; val = qemuoptget(opts, \"manufacturer\"); if (val) { smbiosaddfield(1, offsetof(struct smbiostype1, manufacturerstr), val, strlen(val) + 1); } val = qemuoptget(opts, \"product\"); if (val) { smbiosaddfield(1, offsetof(struct smbiostype1, productnamestr), val, strlen(val) + 1); } val = qemuoptget(opts, \"version\"); if (val) { smbiosaddfield(1, offsetof(struct smbiostype1, versionstr), val, strlen(val) + 1); } val = qemuoptget(opts, \"serial\"); if (val) { smbiosaddfield(1, offsetof(struct smbiostype1, serialnumberstr), val, strlen(val) + 1); } val = qemuoptget(opts, \"uuid\"); if (val) { if (qemuuuidparse(val, qemuuuid) != 0) { errorreport(\"Invalid UUID\"); exit(1); } } val = qemuoptget(opts, \"sku\"); if (val) { smbiosaddfield(1, offsetof(struct smbiostype1, skunumberstr), val, strlen(val) + 1); } val = qemuoptget(opts, \"family\"); if (val) { smbiosaddfield(1, offsetof(struct smbiostype1, familystr), val, strlen(val) + 1); } } ", "target": 0}
{"func": "static void vmsvgafiforun(struct vmsvgastates *s) { uint32t cmd, colour; int args, len; int x, y, dx, dy, width, height; struct vmsvgacursordefinitions cursor; uint32t cmdstart; len = vmsvgafifolength(s); while (len > 0) { /* May need to go back to the start of the command if incomplete */ cmdstart = s->cmd->stop; switch (cmd = vmsvgafiforead(s)) { case SVGACMDUPDATE: case SVGACMDUPDATEVERBOSE: len -= 5; if (len < 0) { goto rewind; } x = vmsvgafiforead(s); y = vmsvgafiforead(s); width = vmsvgafiforead(s); height = vmsvgafiforead(s); vmsvgaupdaterectdelayed(s, x, y, width, height); break; case SVGACMDRECTFILL: len -= 6; if (len < 0) { goto rewind; } colour = vmsvgafiforead(s); x = vmsvgafiforead(s); y = vmsvgafiforead(s); width = vmsvgafiforead(s); height = vmsvgafiforead(s); #ifdef HWFILLACCEL if (vmsvgafillrect(s, colour, x, y, width, height) == 0) { break; } #endif args = 0; goto badcmd; case SVGACMDRECTCOPY: len -= 7; if (len < 0) { goto rewind; } x = vmsvgafiforead(s); y = vmsvgafiforead(s); dx = vmsvgafiforead(s); dy = vmsvgafiforead(s); width = vmsvgafiforead(s); height = vmsvgafiforead(s); #ifdef HWRECTACCEL if (vmsvgacopyrect(s, x, y, dx, dy, width, height) == 0) { break; } #endif args = 0; goto badcmd; case SVGACMDDEFINECURSOR: len -= 8; if (len < 0) { goto rewind; } cursor.id = vmsvgafiforead(s); cursor.hotx = vmsvgafiforead(s); cursor.hoty = vmsvgafiforead(s); cursor.width = x = vmsvgafiforead(s); cursor.height = y = vmsvgafiforead(s); vmsvgafiforead(s); cursor.bpp = vmsvgafiforead(s); args = SVGABITMAPSIZE(x, y) + SVGAPIXMAPSIZE(x, y, cursor.bpp); if (SVGABITMAPSIZE(x, y) > sizeof cursor.mask || SVGAPIXMAPSIZE(x, y, cursor.bpp) > sizeof cursor.image) { goto badcmd; } len -= args; if (len < 0) { goto rewind; } for (args = 0; args < SVGABITMAPSIZE(x, y); args++) { cursor.mask[args] = vmsvgafiforeadraw(s); } for (args = 0; args < SVGAPIXMAPSIZE(x, y, cursor.bpp); args++) { cursor.image[args] = vmsvgafiforeadraw(s); } #ifdef HWMOUSEACCEL vmsvgacursordefine(s, &cursor); break; #else args = 0; goto badcmd; #endif /* * Other commands that we at least know the number of arguments * for so we can avoid FIFO desync if driver uses them illegally. */ case SVGACMDDEFINEALPHACURSOR: len -= 6; if (len < 0) { goto rewind; } vmsvgafiforead(s); vmsvgafiforead(s); vmsvgafiforead(s); x = vmsvgafiforead(s); y = vmsvgafiforead(s); args = x * y; goto badcmd; case SVGACMDRECTROPFILL: args = 6; goto badcmd; case SVGACMDRECTROPCOPY: args = 7; goto badcmd; case SVGACMDDRAWGLYPHCLIPPED: len -= 4; if (len < 0) { goto rewind; } vmsvgafiforead(s); vmsvgafiforead(s); args = 7 + (vmsvgafiforead(s) >> 2); goto badcmd; case SVGACMDSURFACEALPHABLEND: args = 12; goto badcmd; /* * Other commands that are not listed as depending on any * CAPABILITIES bits, but are not described in the README either. */ case SVGACMDSURFACEFILL: case SVGACMDSURFACECOPY: case SVGACMDFRONTROPFILL: case SVGACMDFENCE: case SVGACMDINVALIDCMD: break; /* Nop */ default: args = 0; badcmd: len -= args; if (len < 0) { goto rewind; } while (args--) { vmsvgafiforead(s); } printf(\"%s: Unknown command 0x%02x in SVGA command FIFO\\n\", func, cmd); break; rewind: s->cmd->stop = cmdstart; break; } } s->syncing = 0; } ", "target": 0}
{"func": "static int hdevgetmaxsegments(const struct stat *st) { #ifdef CONFIGLINUX char buf[32]; const char *end; char *sysfspath; int ret; int fd = -1; long maxsegments; sysfspath = gstrdupprintf(\"/sys/dev/block/%u:%u/queue/maxsegments\", major(st->strdev), minor(st->strdev)); fd = open(sysfspath, ORDONLY); if (fd == -1) { ret = -errno; goto out; } do { ret = read(fd, buf, sizeof(buf)); } while (ret == -1 && errno == EINTR); if (ret < 0) { ret = -errno; goto out; } else if (ret == 0) { ret = -EIO; goto out; } buf[ret] = 0; /* The file is ended with '\\n', pass 'end' to accept that. */ ret = qemustrtol(buf, &end, 10, &maxsegments); if (ret == 0 && end && *end == '\\n') { ret = maxsegments; } out: gfree(sysfspath); return ret; #else return -ENOTSUP; #endif } ", "target": 1}
{"func": "static void apicupdateirq(APICCommonState *s) { if (!(s->spuriousvec & APICSVENABLE)) { return; } if (apicirqpending(s) > 0) { cpuinterrupt(s->cpuenv, CPUINTERRUPTHARD); } else if (apicacceptpicintr(&s->busdev.qdev) && picgetoutput(isapic)) { apicdeliverpicintr(&s->busdev.qdev, 1); } } ", "target": 0}
{"func": "PPCOP(extsh) { T0 = (int32t)((int16t)(Ts0)); RETURN(); } ", "target": 1}
{"func": "static int nfsfileopen(BlockDriverState *bs, QDict *options, int flags, Error **errp) { NFSClient *client = bs->opaque; int64t ret; client->aiocontext = bdrvgetaiocontext(bs); ret = nfsclientopen(client, options, (flags & BDRVORDWR) ? ORDWR : ORDONLY, bs->openflags, errp); if (ret < 0) { return ret; } qemumutexinit(&client->mutex); bs->totalsectors = ret; ret = 0; return ret; } ", "target": 1}
{"func": "static uint32t pmacidereadb (void *opaque,targetphysaddrt addr) { uint8t retval; MACIOIDEState *d = opaque; addr = (addr & 0xFFF) >> 4; switch (addr) { case 1 ... 7: retval = ideioportread(&d->bus, addr); break; case 8: case 22: retval = idestatusread(&d->bus, 0); break; default: retval = 0xFF; break; } return retval; } ", "target": 0}
{"func": "targetphysaddrt booke206tlbtopagesize(CPUState *env, ppcmastlbt *tlb) { uint32t tlbncfg; int tlbn = booke206tlbmtotlbn(env, tlb); int tlbmsize; tlbncfg = env->spr[SPRBOOKETLB0CFG + tlbn]; if (tlbncfg & TLBnCFGAVAIL) { tlbmsize = (tlb->mas1 & MAS1TSIZEMASK) >> MAS1TSIZESHIFT; } else { tlbmsize = (tlbncfg & TLBnCFGMINSIZE) >> TLBnCFGMINSIZESHIFT; tlbmsize <<= 1; } return 1024ULL << tlbmsize; } ", "target": 0}
{"func": "static int xhcisetuppacket(XHCITransfer *xfer, XHCIPort *port, int ep) { usbpacketsetup(&xfer->packet, xfer->inxfer ? USBTOKENIN : USBTOKENOUT, xfer->xhci->slots[xfer->slotid-1].devaddr, ep & 0x7f); usbpacketaddbuf(&xfer->packet, xfer->data, xfer->datalength); DPRINTF(\"xhci: setup packet pid 0x%x addr %d ep %d\\n\", xfer->packet.pid, xfer->packet.devaddr, xfer->packet.devep); return 0; } ", "target": 0}
{"func": "static void threadpoolcancel(BlockAIOCB *acb) { ThreadPoolElement *elem = (ThreadPoolElement *)acb; ThreadPool *pool = elem->pool; tracethreadpoolcancel(elem, elem->common.opaque); qemumutexlock(&pool->lock); if (elem->state == THREADQUEUED && /* No thread has yet started working on elem. we can try to \"steal\" * the item from the worker if we can get a signal from the * semaphore. Because this is non-blocking, we can do it with * the lock taken and ensure that elem will remain THREADQUEUED. */ qemusemtimedwait(&pool->sem, 0) == 0) { QTAILQREMOVE(&pool->requestlist, elem, reqs); qemubhschedule(pool->completionbh); elem->state = THREADDONE; elem->ret = -ECANCELED; } qemumutexunlock(&pool->lock); } ", "target": 0}
{"func": "static void monitorprotocoleventinit(void) { qemumutexinit(&monitoreventstatelock); /* Limit RTC & BALLOON events to 1 per second */ monitorprotocoleventthrottle(QEVENTRTCCHANGE, 1000); monitorprotocoleventthrottle(QEVENTBALLOONCHANGE, 1000); monitorprotocoleventthrottle(QEVENTWATCHDOG, 1000); } ", "target": 1}
{"func": "static int seektest(const char *inputfilename, const char *start, const char *end) { AVCodec *codec = NULL; AVCodecContext *ctx= NULL; AVCodecParameters *originpar = NULL; AVFrame *fr = NULL; AVFormatContext *fmtctx = NULL; int videostream; int result; int i, j; long int startts, endts; sizeofarray = 0; numberofelements = 0; crcarray = ptsarray = NULL; result = avformatopeninput(&fmtctx, inputfilename, NULL, NULL); if (result < 0) { avlog(NULL, AVLOGERROR, \"Can't open file\\n\"); return result; } result = avformatfindstreaminfo(fmtctx, NULL); if (result < 0) { avlog(NULL, AVLOGERROR, \"Can't get stream info\\n\"); return result; } startts = readseekrange(start); endts = readseekrange(end); if ((startts < 0) || (endts < 0)) return -1; //TODO: add ability to work with audio format videostream = avfindbeststream(fmtctx, AVMEDIATYPEVIDEO, -1, -1, NULL, 0); if (videostream < 0) { avlog(NULL, AVLOGERROR, \"Can't find video stream in input file\\n\"); return -1; } originpar = fmtctx->streams[videostream]->codecpar; codec = avcodecfinddecoder(originpar->codecid); if (!codec) { avlog(NULL, AVLOGERROR, \"Can't find decoder\\n\"); return -1; } ctx = avcodecalloccontext3(codec); if (!ctx) { avlog(NULL, AVLOGERROR, \"Can't allocate decoder context\\n\"); return AVERROR(ENOMEM); } result = avcodecparameterstocontext(ctx, originpar); if (result) { avlog(NULL, AVLOGERROR, \"Can't copy decoder context\\n\"); return result; } result = avcodecopen2(ctx, codec, NULL); if (result < 0) { avlog(ctx, AVLOGERROR, \"Can't open decoder\\n\"); return result; } fr = avframealloc(); if (!fr) { avlog(NULL, AVLOGERROR, \"Can't allocate frame\\n\"); return AVERROR(ENOMEM); } result = computecrcofpackets(fmtctx, videostream, ctx, fr, i, j, 1); if (result != 0) return -1; for (i = startts; i < endts; i += 100) { for (j = i + 100; j < endts; j += 100) result = computecrcofpackets(fmtctx, videostream, ctx, fr, i, j, 0); if (result != 0) return -1; } avfreep(&crcarray); avfreep(&ptsarray); avframefree(&fr); avcodecclose(ctx); avformatcloseinput(&fmtctx); avcodecfreecontext(&ctx); return 0; } ", "target": 1}
{"func": "AUXReply auxrequest(AUXBus *bus, AUXCommand cmd, uint32t address, uint8t len, uint8t *data) { AUXReply ret = AUXNACK; I2CBus *i2cbus = auxgeti2cbus(bus); sizet i; bool iswrite = false; DPRINTF(\"request at address 0x%\" PRIX32 \", command %u, len %u\\n\", address, cmd, len); switch (cmd) { /* * Forward the request on the AUX bus.. */ case WRITEAUX: case READAUX: iswrite = cmd == READAUX ? false : true; for (i = 0; i < len; i++) { if (!addressspacerw(&bus->auxaddrspace, address++, MEMTXATTRSUNSPECIFIED, data++, 1, iswrite)) { ret = AUXI2CACK; } else { ret = AUXNACK; break; } } break; /* * Classic I2C transactions.. */ case READI2C: case WRITEI2C: iswrite = cmd == READI2C ? false : true; if (i2cbusbusy(i2cbus)) { i2cendtransfer(i2cbus); } if (i2cstarttransfer(i2cbus, address, iswrite)) { ret = AUXI2CNACK; break; } ret = AUXI2CACK; while (len > 0) { if (i2csendrecv(i2cbus, data++, iswrite) < 0) { ret = AUXI2CNACK; break; } len--; } i2cendtransfer(i2cbus); break; /* * I2C MOT transactions. * * Here we send a start when: * - We didn't start transaction yet. * - We had a READ and we do a WRITE. * - We changed the address. */ case WRITEI2CMOT: case READI2CMOT: iswrite = cmd == READI2CMOT ? false : true; if (!i2cbusbusy(i2cbus)) { /* * No transactions started.. */ if (i2cstarttransfer(i2cbus, address, iswrite)) { ret = AUXI2CNACK; break; } } else if ((address != bus->lasti2caddress) || (bus->lasttransaction != cmd)) { /* * Transaction started but we need to restart.. */ i2cendtransfer(i2cbus); if (i2cstarttransfer(i2cbus, address, iswrite)) { ret = AUXI2CNACK; break; } } while (len > 0) { if (i2csendrecv(i2cbus, data++, iswrite) < 0) { ret = AUXI2CNACK; i2cendtransfer(i2cbus); break; } len--; } bus->lasttransaction = cmd; bus->lasti2caddress = address; ret = AUXI2CACK; break; default: DPRINTF(\"Not implemented!\\n\"); return AUXNACK; } DPRINTF(\"reply: %u\\n\", ret); return ret; } ", "target": 0}
{"func": "static inline void RENAME(yuv2yuvXar)(SwsContext *c, const int16t *lumFilter, const int16t **lumSrc, int lumFilterSize, const int16t *chrFilter, const int16t **chrUSrc, const int16t **chrVSrc, int chrFilterSize, const int16t **alpSrc, uint8t *dest, uint8t *uDest, uint8t *vDest, uint8t *aDest, long dstW, long chrDstW) { if (uDest) { YSCALEYUV2YV12XACCURATE(CHRMMXFILTEROFFSET, uDest, chrDstW, 0) YSCALEYUV2YV12XACCURATE(CHRMMXFILTEROFFSET, vDest, chrDstW + c->uvoff, c->uvoff) } if (CONFIGSWSCALEALPHA && aDest) { YSCALEYUV2YV12XACCURATE(ALPMMXFILTEROFFSET, aDest, dstW, 0) } YSCALEYUV2YV12XACCURATE(LUMMMXFILTEROFFSET, dest, dstW, 0) } ", "target": 1}
{"func": "MigrationInfo *qmpquerymigrate(Error **errp) { MigrationInfo *info = gmalloc0(sizeof(*info)); MigrationState *s = migrategetcurrent(); switch (s->state) { case MIGSTATENONE: /* no migration has happened ever */ break; case MIGSTATESETUP: info->hasstatus = true; info->status = gstrdup(\"setup\"); info->hastotaltime = false; break; case MIGSTATEACTIVE: case MIGSTATECANCELLING: info->hasstatus = true; info->status = gstrdup(\"active\"); info->hastotaltime = true; info->totaltime = qemuclockgetms(QEMUCLOCKREALTIME) - s->totaltime; info->hasexpecteddowntime = true; info->expecteddowntime = s->expecteddowntime; info->hassetuptime = true; info->setuptime = s->setuptime; info->hasram = true; info->ram = gmalloc0(sizeof(*info->ram)); info->ram->transferred = rambytestransferred(); info->ram->remaining = rambytesremaining(); info->ram->total = rambytestotal(); info->ram->duplicate = dupmigpagestransferred(); info->ram->skipped = skippedmigpagestransferred(); info->ram->normal = normmigpagestransferred(); info->ram->normalbytes = normmigbytestransferred(); info->ram->dirtypagesrate = s->dirtypagesrate; info->ram->mbps = s->mbps; info->ram->dirtysynccount = s->dirtysynccount; if (blkmigactive()) { info->hasdisk = true; info->disk = gmalloc0(sizeof(*info->disk)); info->disk->transferred = blkmigbytestransferred(); info->disk->remaining = blkmigbytesremaining(); info->disk->total = blkmigbytestotal(); } getxbzrlecachestats(info); break; case MIGSTATECOMPLETED: getxbzrlecachestats(info); info->hasstatus = true; info->status = gstrdup(\"completed\"); info->hastotaltime = true; info->totaltime = s->totaltime; info->hasdowntime = true; info->downtime = s->downtime; info->hassetuptime = true; info->setuptime = s->setuptime; info->hasram = true; info->ram = gmalloc0(sizeof(*info->ram)); info->ram->transferred = rambytestransferred(); info->ram->remaining = 0; info->ram->total = rambytestotal(); info->ram->duplicate = dupmigpagestransferred(); info->ram->skipped = skippedmigpagestransferred(); info->ram->normal = normmigpagestransferred(); info->ram->normalbytes = normmigbytestransferred(); info->ram->mbps = s->mbps; info->ram->dirtysynccount = s->dirtysynccount; break; case MIGSTATEERROR: info->hasstatus = true; info->status = gstrdup(\"failed\"); break; case MIGSTATECANCELLED: info->hasstatus = true; info->status = gstrdup(\"cancelled\"); break; } return info; } ", "target": 1}
{"func": "static inline int cowsetbit(BlockDriverState *bs, int64t bitnum) { uint64t offset = sizeof(struct cowheaderv2) + bitnum / 8; uint8t bitmap; if (bdrvpread(bs->file, offset, &bitmap, sizeof(bitmap)) != \t sizeof(bitmap)) { return -errno; } bitmap |= (1 << (bitnum % 8)); if (bdrvpwrite(bs->file, offset, &bitmap, sizeof(bitmap)) != \t sizeof(bitmap)) { return -errno; } return 0; } ", "target": 1}
{"func": "PPCOP(cmpl) { if (T0 < T1) { T0 = 0x08; } else if (T0 > T1) { T0 = 0x04; } else { T0 = 0x02; } RETURN(); } ", "target": 1}
{"func": "static int vocprobe(AVProbeData *p) { int version, check; if (p->bufsize < 26) return 0; if (memcmp(p->buf, vocmagic, sizeof(vocmagic) - 1)) return 0; version = p->buf[22] | (p->buf[23] << 8); check = p->buf[24] | (p->buf[25] << 8); if (~version + 0x1234 != check) return 10; return AVPROBESCOREMAX; } ", "target": 0}
{"func": "int ramload(QEMUFile *f, void *opaque, int versionid) { ramaddrt addr; int flags; if (versionid < 3 || versionid > 4) { return -EINVAL; } do { addr = qemugetbe64(f); flags = addr & ~TARGETPAGEMASK; addr &= TARGETPAGEMASK; if (flags & RAMSAVEFLAGMEMSIZE) { if (versionid == 3) { if (addr != rambytestotal()) { return -EINVAL; } } else { /* Synchronize RAM block list */ char id[256]; ramaddrt length; ramaddrt totalrambytes = addr; while (totalrambytes) { RAMBlock *block; uint8t len; len = qemugetbyte(f); qemugetbuffer(f, (uint8t *)id, len); id[len] = 0; length = qemugetbe64(f); QLISTFOREACH(block, &ramlist.blocks, next) { if (!strncmp(id, block->idstr, sizeof(id))) { if (block->length != length) return -EINVAL; break; } } if (!block) { fprintf(stderr, \"Unknown ramblock \\\"%s\\\", cannot \" \"accept migration\\n\", id); return -EINVAL; } totalrambytes -= length; } } } if (flags & RAMSAVEFLAGCOMPRESS) { void *host; uint8t ch; if (versionid == 3) host = qemugetramptr(addr); else host = hostfromstreamoffset(f, addr, flags); ch = qemugetbyte(f); memset(host, ch, TARGETPAGESIZE); #ifndef WIN32 if (ch == 0 && (!kvmenabled() || kvmhassyncmmu())) { madvise(host, TARGETPAGESIZE, MADVDONTNEED); } #endif } else if (flags & RAMSAVEFLAGPAGE) { void *host; if (versionid == 3) host = qemugetramptr(addr); else host = hostfromstreamoffset(f, addr, flags); qemugetbuffer(f, host, TARGETPAGESIZE); } if (qemufilehaserror(f)) { return -EIO; } } while (!(flags & RAMSAVEFLAGEOS)); return 0; } ", "target": 1}
{"func": "static void drivebackupprepare(BlkActionState *common, Error **errp) { DriveBackupState *state = DOUPCAST(DriveBackupState, common, common); BlockDriverState *bs; DriveBackup *backup; Error *localerr = NULL; assert(common->action->type == TRANSACTIONACTIONKINDDRIVEBACKUP); backup = common->action->u.drivebackup.data; bs = qmpgetrootbs(backup->device, errp); if (!bs) { return; } /* AioContext is released in .clean() */ state->aiocontext = bdrvgetaiocontext(bs); aiocontextacquire(state->aiocontext); bdrvdrainedbegin(bs); state->bs = bs; dodrivebackup(backup, common->blockjobtxn, &localerr); if (localerr) { errorpropagate(errp, localerr); return; } state->job = state->bs->job; } ", "target": 1}
{"func": "static inline void RETSTOP (DisasContext *ctx) { genopupdatenip((ctx)->nip); ctx->exception = EXCPMTMSR; } ", "target": 1}
{"func": "static void termexit(void) { #ifndef MINGW32 tcsetattr (0, TCSANOW, &oldtty); #endif } ", "target": 0}
{"func": "static int getsegment64(CPUPPCState *env, struct mmuctxhash64 *ctx, targetulong eaddr, int rw, int type) { hwaddr hash; targetulong vsid; int pr, targetpagebits; int ret, ret2; pr = msrpr; ctx->eaddr = eaddr; ppcslbt *slb; targetulong pageaddr; int segmentbits; LOGMMU(\"Check SLBs\\n\"); slb = slblookup(env, eaddr); if (!slb) { return -5; } if (slb->vsid & SLBVSIDB) { vsid = (slb->vsid & SLBVSIDVSID) >> SLBVSIDSHIFT1T; segmentbits = 40; } else { vsid = (slb->vsid & SLBVSIDVSID) >> SLBVSIDSHIFT; segmentbits = 28; } targetpagebits = (slb->vsid & SLBVSIDL) ? TARGETPAGEBITS16M : TARGETPAGEBITS; ctx->key = !!(pr ? (slb->vsid & SLBVSIDKP) : (slb->vsid & SLBVSIDKS)); ctx->nx = !!(slb->vsid & SLBVSIDN); pageaddr = eaddr & ((1ULL << segmentbits) - (1ULL << targetpagebits)); if (slb->vsid & SLBVSIDB) { hash = vsid ^ (vsid << 25) ^ (pageaddr >> targetpagebits); } else { hash = vsid ^ (pageaddr >> targetpagebits); } /* Only 5 bits of the page index are used in the AVPN */ ctx->ptem = (slb->vsid & SLBVSIDPTEM) | ((pageaddr >> 16) & ((1ULL << segmentbits) - 0x80)); LOGMMU(\"pte segment: key=%d nx %d vsid \" TARGETFMTlx \"\\n\", ctx->key, ctx->nx, vsid); ret = -1; /* Check if instruction fetch is allowed, if needed */ if (type != ACCESSCODE || ctx->nx == 0) { /* Page address translation */ LOGMMU(\"htabbase \" TARGETFMTplx \" htabmask \" TARGETFMTplx \" hash \" TARGETFMTplx \"\\n\", env->htabbase, env->htabmask, hash); ctx->hash[0] = hash; ctx->hash[1] = ~hash; /* Initialize real address with an invalid value */ ctx->raddr = (hwaddr)-1ULL; LOGMMU(\"0 htab=\" TARGETFMTplx \"/\" TARGETFMTplx \" vsid=\" TARGETFMTlx \" ptem=\" TARGETFMTlx \" hash=\" TARGETFMTplx \"\\n\", env->htabbase, env->htabmask, vsid, ctx->ptem, ctx->hash[0]); /* Primary table lookup */ ret = findpte64(env, ctx, 0, rw, type, targetpagebits); if (ret < 0) { /* Secondary table lookup */ LOGMMU(\"1 htab=\" TARGETFMTplx \"/\" TARGETFMTplx \" vsid=\" TARGETFMTlx \" api=\" TARGETFMTlx \" hash=\" TARGETFMTplx \"\\n\", env->htabbase, env->htabmask, vsid, ctx->ptem, ctx->hash[1]); ret2 = findpte64(env, ctx, 1, rw, type, targetpagebits); if (ret2 != -1) { ret = ret2; } } } else { LOGMMU(\"No access allowed\\n\"); ret = -3; } return ret; } ", "target": 0}
{"func": "static int v9fsreceivefd(int sockfd, int *status) { struct iovec iov; struct msghdr msg; struct cmsghdr *cmsg; int retval, data, fd; union MsgControl msgcontrol; iov.iovbase = &data; iov.iovlen = sizeof(data); memset(&msg, 0, sizeof(msg)); msg.msgiov = &iov; msg.msgiovlen = 1; msg.msgcontrol = &msgcontrol; msg.msgcontrollen = sizeof(msgcontrol); do { retval = recvmsg(sockfd, &msg, 0); } while (retval < 0 && errno == EINTR); if (retval <= 0) { return retval; } /* * data is set to V9FSFDVALID, if ancillary data is sent. If this * request doesn't need ancillary data (fd) or an error occurred, * data is set to negative errno value. */ if (data != V9FSFDVALID) { *status = data; return 0; } /* * File descriptor (fd) is sent in the ancillary data. Check if we * indeed received it. One of the reasons to fail to receive it is if * we exceeded the maximum number of file descriptors! */ for (cmsg = CMSGFIRSTHDR(&msg); cmsg; cmsg = CMSGNXTHDR(&msg, cmsg)) { if (cmsg->cmsglen != CMSGLEN(sizeof(int)) || cmsg->cmsglevel != SOLSOCKET || cmsg->cmsgtype != SCMRIGHTS) { continue; } fd = *((int *)CMSGDATA(cmsg)); *status = fd; return 0; } *status = -ENFILE; /* Ancillary data sent but not received */ return 0; } ", "target": 0}
{"func": "static void kvminjectx86mceon(CPUState *env, struct kvmx86mce *mce, int flag) { struct kvmx86mcedata data = { .env = env, .mce = mce, .abortonerror = (flag & ABORTONERROR), }; if (!env->mcgcap) { fprintf(stderr, \"MCE support is not enabled!\\n\"); return; } runoncpu(env, kvmdoinjectx86mce, &data); } ", "target": 0}
{"func": "static AioHandler *findaiohandler(AioContext *ctx, int fd) { AioHandler *node; QLISTFOREACH(node, &ctx->aiohandlers, node) { if (node->pfd.fd == fd) if (!node->deleted) return node; } return NULL; } ", "target": 0}
{"func": "static void disasxtensainsn(CPUXtensaState *env, DisasContext *dc) { #define HASOPTIONBITS(opt) do { \\ if (!optionbitsenabled(dc, opt)) { \\ qemulog(\"Option is not enabled %s:%d\\n\", \\ FILE, LINE); \\ goto invalidopcode; \\ } \\ } while (0) #define HASOPTION(opt) HASOPTIONBITS(XTENSAOPTIONBIT(opt)) #define TBD() qemulog(\"TBD(pc = %08x): %s:%d\\n\", dc->pc, FILE, LINE) #define RESERVED() do { \\ qemulog(\"RESERVED(pc = %08x, %02x%02x%02x): %s:%d\\n\", \\ dc->pc, b0, b1, b2, FILE, LINE); \\ goto invalidopcode; \\ } while (0) #ifdef TARGETWORDSBIGENDIAN #define OP0 (((b0) & 0xf0) >> 4) #define OP1 (((b2) & 0xf0) >> 4) #define OP2 ((b2) & 0xf) #define RRRR ((b1) & 0xf) #define RRRS (((b1) & 0xf0) >> 4) #define RRRT ((b0) & 0xf) #else #define OP0 (((b0) & 0xf)) #define OP1 (((b2) & 0xf)) #define OP2 (((b2) & 0xf0) >> 4) #define RRRR (((b1) & 0xf0) >> 4) #define RRRS (((b1) & 0xf)) #define RRRT (((b0) & 0xf0) >> 4) #endif #define RRRX ((RRRR & 0x4) >> 2) #define RRRY ((RRRT & 0x4) >> 2) #define RRRW (RRRR & 0x3) #define RRRNR RRRR #define RRRNS RRRS #define RRRNT RRRT #define RRI4R RRRR #define RRI4S RRRS #define RRI4T RRRT #ifdef TARGETWORDSBIGENDIAN #define RRI4IMM4 ((b2) & 0xf) #else #define RRI4IMM4 (((b2) & 0xf0) >> 4) #endif #define RRI8R RRRR #define RRI8S RRRS #define RRI8T RRRT #define RRI8IMM8 (b2) #define RRI8IMM8SE ((((b2) & 0x80) ? 0xffffff00 : 0) | RRI8IMM8) #ifdef TARGETWORDSBIGENDIAN #define RI16IMM16 (((b1) << 8) | (b2)) #else #define RI16IMM16 (((b2) << 8) | (b1)) #endif #ifdef TARGETWORDSBIGENDIAN #define CALLN (((b0) & 0xc) >> 2) #define CALLOFFSET ((((b0) & 0x3) << 16) | ((b1) << 8) | (b2)) #else #define CALLN (((b0) & 0x30) >> 4) #define CALLOFFSET ((((b0) & 0xc0) >> 6) | ((b1) << 2) | ((b2) << 10)) #endif #define CALLOFFSETSE \\ (((CALLOFFSET & 0x20000) ? 0xfffc0000 : 0) | CALLOFFSET) #define CALLXN CALLN #ifdef TARGETWORDSBIGENDIAN #define CALLXM ((b0) & 0x3) #else #define CALLXM (((b0) & 0xc0) >> 6) #endif #define CALLXS RRRS #define BRI12M CALLXM #define BRI12S RRRS #ifdef TARGETWORDSBIGENDIAN #define BRI12IMM12 ((((b1) & 0xf) << 8) | (b2)) #else #define BRI12IMM12 ((((b1) & 0xf0) >> 4) | ((b2) << 4)) #endif #define BRI12IMM12SE (((BRI12IMM12 & 0x800) ? 0xfffff000 : 0) | BRI12IMM12) #define BRI8M BRI12M #define BRI8R RRI8R #define BRI8S RRI8S #define BRI8IMM8 RRI8IMM8 #define BRI8IMM8SE RRI8IMM8SE #define RSRSR (b1) uint8t b0 = cpuldubcode(env, dc->pc); uint8t b1 = cpuldubcode(env, dc->pc + 1); uint8t b2 = 0; unsigned len = xtensaop0insnlen(OP0); static const uint32t B4CONST[] = { 0xffffffff, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 16, 32, 64, 128, 256 }; static const uint32t B4CONSTU[] = { 32768, 65536, 2, 3, 4, 5, 6, 7, 8, 10, 12, 16, 32, 64, 128, 256 }; switch (len) { case 2: HASOPTION(XTENSAOPTIONCODEDENSITY); break; case 3: b2 = cpuldubcode(env, dc->pc + 2); break; default: RESERVED(); } dc->nextpc = dc->pc + len; switch (OP0) { case 0: /*QRST*/ switch (OP1) { case 0: /*RST0*/ switch (OP2) { case 0: /*ST0*/ if ((RRRR & 0xc) == 0x8) { HASOPTION(XTENSAOPTIONBOOLEAN); } switch (RRRR) { case 0: /*SNM0*/ switch (CALLXM) { case 0: /*ILL*/ genexceptioncause(dc, ILLEGALINSTRUCTIONCAUSE); break; case 1: /*reserved*/ RESERVED(); break; case 2: /*JR*/ switch (CALLXN) { case 0: /*RET*/ case 2: /*JX*/ if (genwindowcheck1(dc, CALLXS)) { genjump(dc, cpuR[CALLXS]); } break; case 1: /*RETWw*/ HASOPTION(XTENSAOPTIONWINDOWEDREGISTER); { TCGvi32 tmp = tcgconsti32(dc->pc); genadvanceccount(dc); genhelperretw(tmp, cpuenv, tmp); genjump(dc, tmp); tcgtempfree(tmp); } break; case 3: /*reserved*/ RESERVED(); break; } break; case 3: /*CALLX*/ if (!genwindowcheck2(dc, CALLXS, CALLXN << 2)) { break; } switch (CALLXN) { case 0: /*CALLX0*/ { TCGvi32 tmp = tcgtempnewi32(); tcggenmovi32(tmp, cpuR[CALLXS]); tcggenmovii32(cpuR[0], dc->nextpc); genjump(dc, tmp); tcgtempfree(tmp); } break; case 1: /*CALLX4w*/ case 2: /*CALLX8w*/ case 3: /*CALLX12w*/ HASOPTION(XTENSAOPTIONWINDOWEDREGISTER); { TCGvi32 tmp = tcgtempnewi32(); tcggenmovi32(tmp, cpuR[CALLXS]); gencallw(dc, CALLXN, tmp); tcgtempfree(tmp); } break; } break; } break; case 1: /*MOVSPw*/ HASOPTION(XTENSAOPTIONWINDOWEDREGISTER); if (genwindowcheck2(dc, RRRT, RRRS)) { TCGvi32 pc = tcgconsti32(dc->pc); genadvanceccount(dc); genhelpermovsp(cpuenv, pc); tcggenmovi32(cpuR[RRRT], cpuR[RRRS]); tcgtempfree(pc); } break; case 2: /*SYNC*/ switch (RRRT) { case 0: /*ISYNC*/ break; case 1: /*RSYNC*/ break; case 2: /*ESYNC*/ break; case 3: /*DSYNC*/ break; case 8: /*EXCW*/ HASOPTION(XTENSAOPTIONEXCEPTION); break; case 12: /*MEMW*/ break; case 13: /*EXTW*/ break; case 15: /*NOP*/ break; default: /*reserved*/ RESERVED(); break; } break; case 3: /*RFEIx*/ switch (RRRT) { case 0: /*RFETx*/ HASOPTION(XTENSAOPTIONEXCEPTION); switch (RRRS) { case 0: /*RFEx*/ if (gencheckprivilege(dc)) { tcggenandii32(cpuSR[PS], cpuSR[PS], ~PSEXCM); genhelpercheckinterrupts(cpuenv); genjump(dc, cpuSR[EPC1]); } break; case 1: /*RFUEx*/ RESERVED(); break; case 2: /*RFDEx*/ if (gencheckprivilege(dc)) { genjump(dc, cpuSR[ dc->config->ndepc ? DEPC : EPC1]); } break; case 4: /*RFWOw*/ case 5: /*RFWUw*/ HASOPTION(XTENSAOPTIONWINDOWEDREGISTER); if (gencheckprivilege(dc)) { TCGvi32 tmp = tcgconsti32(1); tcggenandii32( cpuSR[PS], cpuSR[PS], ~PSEXCM); tcggenshli32(tmp, tmp, cpuSR[WINDOWBASE]); if (RRRS == 4) { tcggenandci32(cpuSR[WINDOWSTART], cpuSR[WINDOWSTART], tmp); } else { tcggenori32(cpuSR[WINDOWSTART], cpuSR[WINDOWSTART], tmp); } genhelperrestoreowb(cpuenv); genhelpercheckinterrupts(cpuenv); genjump(dc, cpuSR[EPC1]); tcgtempfree(tmp); } break; default: /*reserved*/ RESERVED(); break; } break; case 1: /*RFIx*/ HASOPTION(XTENSAOPTIONHIGHPRIORITYINTERRUPT); if (RRRS >= 2 && RRRS <= dc->config->nlevel) { if (gencheckprivilege(dc)) { tcggenmovi32(cpuSR[PS], cpuSR[EPS2 + RRRS - 2]); genhelpercheckinterrupts(cpuenv); genjump(dc, cpuSR[EPC1 + RRRS - 1]); } } else { qemulog(\"RFI %d is illegal\\n\", RRRS); genexceptioncause(dc, ILLEGALINSTRUCTIONCAUSE); } break; case 2: /*RFME*/ TBD(); break; default: /*reserved*/ RESERVED(); break; } break; case 4: /*BREAKx*/ HASOPTION(XTENSAOPTIONDEBUG); if (dc->debug) { gendebugexception(dc, DEBUGCAUSEBI); } break; case 5: /*SYSCALLx*/ HASOPTION(XTENSAOPTIONEXCEPTION); switch (RRRS) { case 0: /*SYSCALLx*/ genexceptioncause(dc, SYSCALLCAUSE); break; case 1: /*SIMCALL*/ if (semihostingenabled) { if (gencheckprivilege(dc)) { genhelpersimcall(cpuenv); } } else { qemulog(\"SIMCALL but semihosting is disabled\\n\"); genexceptioncause(dc, ILLEGALINSTRUCTIONCAUSE); } break; default: RESERVED(); break; } break; case 6: /*RSILx*/ HASOPTION(XTENSAOPTIONINTERRUPT); if (gencheckprivilege(dc) && genwindowcheck1(dc, RRRT)) { tcggenmovi32(cpuR[RRRT], cpuSR[PS]); tcggenandii32(cpuSR[PS], cpuSR[PS], ~PSINTLEVEL); tcggenorii32(cpuSR[PS], cpuSR[PS], RRRS); genhelpercheckinterrupts(cpuenv); genjumpicheckloopend(dc, 0); } break; case 7: /*WAITIx*/ HASOPTION(XTENSAOPTIONINTERRUPT); if (gencheckprivilege(dc)) { genwaiti(dc, RRRS); } break; case 8: /*ANY4p*/ case 9: /*ALL4p*/ case 10: /*ANY8p*/ case 11: /*ALL8p*/ HASOPTION(XTENSAOPTIONBOOLEAN); { const unsigned shift = (RRRR & 2) ? 8 : 4; TCGvi32 mask = tcgconsti32( ((1 << shift) - 1) << RRRS); TCGvi32 tmp = tcgtempnewi32(); tcggenandi32(tmp, cpuSR[BR], mask); if (RRRR & 1) { /*ALL*/ tcggenaddii32(tmp, tmp, 1 << RRRS); } else { /*ANY*/ tcggenaddi32(tmp, tmp, mask); } tcggenshrii32(tmp, tmp, RRRS + shift); tcggendepositi32(cpuSR[BR], cpuSR[BR], tmp, RRRT, 1); tcgtempfree(mask); tcgtempfree(tmp); } break; default: /*reserved*/ RESERVED(); break; } break; case 1: /*AND*/ if (genwindowcheck3(dc, RRRR, RRRS, RRRT)) { tcggenandi32(cpuR[RRRR], cpuR[RRRS], cpuR[RRRT]); } break; case 2: /*OR*/ if (genwindowcheck3(dc, RRRR, RRRS, RRRT)) { tcggenori32(cpuR[RRRR], cpuR[RRRS], cpuR[RRRT]); } break; case 3: /*XOR*/ if (genwindowcheck3(dc, RRRR, RRRS, RRRT)) { tcggenxori32(cpuR[RRRR], cpuR[RRRS], cpuR[RRRT]); } break; case 4: /*ST1*/ switch (RRRR) { case 0: /*SSR*/ if (genwindowcheck1(dc, RRRS)) { genrightshiftsar(dc, cpuR[RRRS]); } break; case 1: /*SSL*/ if (genwindowcheck1(dc, RRRS)) { genleftshiftsar(dc, cpuR[RRRS]); } break; case 2: /*SSA8L*/ if (genwindowcheck1(dc, RRRS)) { TCGvi32 tmp = tcgtempnewi32(); tcggenshlii32(tmp, cpuR[RRRS], 3); genrightshiftsar(dc, tmp); tcgtempfree(tmp); } break; case 3: /*SSA8B*/ if (genwindowcheck1(dc, RRRS)) { TCGvi32 tmp = tcgtempnewi32(); tcggenshlii32(tmp, cpuR[RRRS], 3); genleftshiftsar(dc, tmp); tcgtempfree(tmp); } break; case 4: /*SSAI*/ { TCGvi32 tmp = tcgconsti32( RRRS | ((RRRT & 1) << 4)); genrightshiftsar(dc, tmp); tcgtempfree(tmp); } break; case 6: /*RER*/ TBD(); break; case 7: /*WER*/ TBD(); break; case 8: /*ROTWw*/ HASOPTION(XTENSAOPTIONWINDOWEDREGISTER); if (gencheckprivilege(dc)) { TCGvi32 tmp = tcgconsti32( RRRT | ((RRRT & 8) ? 0xfffffff0 : 0)); genhelperrotw(cpuenv, tmp); tcgtempfree(tmp); /* This can change tb->flags, so exit tb */ genjumpicheckloopend(dc, -1); } break; case 14: /*NSAu*/ HASOPTION(XTENSAOPTIONMISCOPNSA); if (genwindowcheck2(dc, RRRS, RRRT)) { genhelpernsa(cpuR[RRRT], cpuR[RRRS]); } break; case 15: /*NSAUu*/ HASOPTION(XTENSAOPTIONMISCOPNSA); if (genwindowcheck2(dc, RRRS, RRRT)) { genhelpernsau(cpuR[RRRT], cpuR[RRRS]); } break; default: /*reserved*/ RESERVED(); break; } break; case 5: /*TLB*/ HASOPTIONBITS( XTENSAOPTIONBIT(XTENSAOPTIONMMU) | XTENSAOPTIONBIT(XTENSAOPTIONREGIONPROTECTION) | XTENSAOPTIONBIT(XTENSAOPTIONREGIONTRANSLATION)); if (gencheckprivilege(dc) && genwindowcheck2(dc, RRRS, RRRT)) { TCGvi32 dtlb = tcgconsti32((RRRR & 8) != 0); switch (RRRR & 7) { case 3: /*RITLB0*/ /*RDTLB0*/ genhelperrtlb0(cpuR[RRRT], cpuenv, cpuR[RRRS], dtlb); break; case 4: /*IITLB*/ /*IDTLB*/ genhelperitlb(cpuenv, cpuR[RRRS], dtlb); /* This could change memory mapping, so exit tb */ genjumpicheckloopend(dc, -1); break; case 5: /*PITLB*/ /*PDTLB*/ tcggenmovii32(cpupc, dc->pc); genhelperptlb(cpuR[RRRT], cpuenv, cpuR[RRRS], dtlb); break; case 6: /*WITLB*/ /*WDTLB*/ genhelperwtlb( cpuenv, cpuR[RRRT], cpuR[RRRS], dtlb); /* This could change memory mapping, so exit tb */ genjumpicheckloopend(dc, -1); break; case 7: /*RITLB1*/ /*RDTLB1*/ genhelperrtlb1(cpuR[RRRT], cpuenv, cpuR[RRRS], dtlb); break; default: tcgtempfree(dtlb); RESERVED(); break; } tcgtempfree(dtlb); } break; case 6: /*RT0*/ if (!genwindowcheck2(dc, RRRR, RRRT)) { break; } switch (RRRS) { case 0: /*NEG*/ tcggennegi32(cpuR[RRRR], cpuR[RRRT]); break; case 1: /*ABS*/ { TCGvi32 zero = tcgconsti32(0); TCGvi32 neg = tcgtempnewi32(); tcggennegi32(neg, cpuR[RRRT]); tcggenmovcondi32(TCGCONDGE, cpuR[RRRR], cpuR[RRRT], zero, cpuR[RRRT], neg); tcgtempfree(neg); tcgtempfree(zero); } break; default: /*reserved*/ RESERVED(); break; } break; case 7: /*reserved*/ RESERVED(); break; case 8: /*ADD*/ if (genwindowcheck3(dc, RRRR, RRRS, RRRT)) { tcggenaddi32(cpuR[RRRR], cpuR[RRRS], cpuR[RRRT]); } break; case 9: /*ADD**/ case 10: case 11: if (genwindowcheck3(dc, RRRR, RRRS, RRRT)) { TCGvi32 tmp = tcgtempnewi32(); tcggenshlii32(tmp, cpuR[RRRS], OP2 - 8); tcggenaddi32(cpuR[RRRR], tmp, cpuR[RRRT]); tcgtempfree(tmp); } break; case 12: /*SUB*/ if (genwindowcheck3(dc, RRRR, RRRS, RRRT)) { tcggensubi32(cpuR[RRRR], cpuR[RRRS], cpuR[RRRT]); } break; case 13: /*SUB**/ case 14: case 15: if (genwindowcheck3(dc, RRRR, RRRS, RRRT)) { TCGvi32 tmp = tcgtempnewi32(); tcggenshlii32(tmp, cpuR[RRRS], OP2 - 12); tcggensubi32(cpuR[RRRR], tmp, cpuR[RRRT]); tcgtempfree(tmp); } break; } break; case 1: /*RST1*/ switch (OP2) { case 0: /*SLLI*/ case 1: if (genwindowcheck2(dc, RRRR, RRRS)) { tcggenshlii32(cpuR[RRRR], cpuR[RRRS], 32 - (RRRT | ((OP2 & 1) << 4))); } break; case 2: /*SRAI*/ case 3: if (genwindowcheck2(dc, RRRR, RRRT)) { tcggensarii32(cpuR[RRRR], cpuR[RRRT], RRRS | ((OP2 & 1) << 4)); } break; case 4: /*SRLI*/ if (genwindowcheck2(dc, RRRR, RRRT)) { tcggenshrii32(cpuR[RRRR], cpuR[RRRT], RRRS); } break; case 6: /*XSR*/ if (genchecksr(dc, RSRSR, SRX) && (RSRSR < 64 || gencheckprivilege(dc)) && genwindowcheck1(dc, RRRT)) { TCGvi32 tmp = tcgtempnewi32(); tcggenmovi32(tmp, cpuR[RRRT]); genrsr(dc, cpuR[RRRT], RSRSR); genwsr(dc, RSRSR, tmp); tcgtempfree(tmp); } break; /* * Note: 64 bit ops are used here solely because SAR values * have range 0..63 */ #define genshiftreg(cmd, reg) do { \\ TCGvi64 tmp = tcgtempnewi64(); \\ tcggenextui32i64(tmp, reg); \\ tcggen##cmd##i64(v, v, tmp); \\ tcggentrunci64i32(cpuR[RRRR], v); \\ tcgtempfreei64(v); \\ tcgtempfreei64(tmp); \\ } while (0) #define genshift(cmd) genshiftreg(cmd, cpuSR[SAR]) case 8: /*SRC*/ if (genwindowcheck3(dc, RRRR, RRRS, RRRT)) { TCGvi64 v = tcgtempnewi64(); tcggenconcati32i64(v, cpuR[RRRT], cpuR[RRRS]); genshift(shr); } break; case 9: /*SRL*/ if (!genwindowcheck2(dc, RRRR, RRRT)) { break; } if (dc->sar5bit) { tcggenshri32(cpuR[RRRR], cpuR[RRRT], cpuSR[SAR]); } else { TCGvi64 v = tcgtempnewi64(); tcggenextui32i64(v, cpuR[RRRT]); genshift(shr); } break; case 10: /*SLL*/ if (!genwindowcheck2(dc, RRRR, RRRS)) { break; } if (dc->sarm325bit) { tcggenshli32(cpuR[RRRR], cpuR[RRRS], dc->sarm32); } else { TCGvi64 v = tcgtempnewi64(); TCGvi32 s = tcgconsti32(32); tcggensubi32(s, s, cpuSR[SAR]); tcggenandii32(s, s, 0x3f); tcggenextui32i64(v, cpuR[RRRS]); genshiftreg(shl, s); tcgtempfree(s); } break; case 11: /*SRA*/ if (!genwindowcheck2(dc, RRRR, RRRT)) { break; } if (dc->sar5bit) { tcggensari32(cpuR[RRRR], cpuR[RRRT], cpuSR[SAR]); } else { TCGvi64 v = tcgtempnewi64(); tcggenexti32i64(v, cpuR[RRRT]); genshift(sar); } break; #undef genshift #undef genshiftreg case 12: /*MUL16U*/ HASOPTION(XTENSAOPTION16BITIMUL); if (genwindowcheck3(dc, RRRR, RRRS, RRRT)) { TCGvi32 v1 = tcgtempnewi32(); TCGvi32 v2 = tcgtempnewi32(); tcggenext16ui32(v1, cpuR[RRRS]); tcggenext16ui32(v2, cpuR[RRRT]); tcggenmuli32(cpuR[RRRR], v1, v2); tcgtempfree(v2); tcgtempfree(v1); } break; case 13: /*MUL16S*/ HASOPTION(XTENSAOPTION16BITIMUL); if (genwindowcheck3(dc, RRRR, RRRS, RRRT)) { TCGvi32 v1 = tcgtempnewi32(); TCGvi32 v2 = tcgtempnewi32(); tcggenext16si32(v1, cpuR[RRRS]); tcggenext16si32(v2, cpuR[RRRT]); tcggenmuli32(cpuR[RRRR], v1, v2); tcgtempfree(v2); tcgtempfree(v1); } break; default: /*reserved*/ RESERVED(); break; } break; case 2: /*RST2*/ if (OP2 >= 8 && !genwindowcheck3(dc, RRRR, RRRS, RRRT)) { break; } if (OP2 >= 12) { HASOPTION(XTENSAOPTION32BITIDIV); int label = gennewlabel(); tcggenbrcondii32(TCGCONDNE, cpuR[RRRT], 0, label); genexceptioncause(dc, INTEGERDIVIDEBYZEROCAUSE); gensetlabel(label); } switch (OP2) { #define BOOLEANLOGIC(fn, r, s, t) \\ do { \\ HASOPTION(XTENSAOPTIONBOOLEAN); \\ TCGvi32 tmp1 = tcgtempnewi32(); \\ TCGvi32 tmp2 = tcgtempnewi32(); \\ \\ tcggenshrii32(tmp1, cpuSR[BR], s); \\ tcggenshrii32(tmp2, cpuSR[BR], t); \\ tcggen##fn##i32(tmp1, tmp1, tmp2); \\ tcggendepositi32(cpuSR[BR], cpuSR[BR], tmp1, r, 1); \\ tcgtempfree(tmp1); \\ tcgtempfree(tmp2); \\ } while (0) case 0: /*ANDBp*/ BOOLEANLOGIC(and, RRRR, RRRS, RRRT); break; case 1: /*ANDBCp*/ BOOLEANLOGIC(andc, RRRR, RRRS, RRRT); break; case 2: /*ORBp*/ BOOLEANLOGIC(or, RRRR, RRRS, RRRT); break; case 3: /*ORBCp*/ BOOLEANLOGIC(orc, RRRR, RRRS, RRRT); break; case 4: /*XORBp*/ BOOLEANLOGIC(xor, RRRR, RRRS, RRRT); break; #undef BOOLEANLOGIC case 8: /*MULLi*/ HASOPTION(XTENSAOPTION32BITIMUL); tcggenmuli32(cpuR[RRRR], cpuR[RRRS], cpuR[RRRT]); break; case 10: /*MULUHi*/ case 11: /*MULSHi*/ HASOPTION(XTENSAOPTION32BITIMULHIGH); { TCGv lo = tcgtempnew(); if (OP2 == 10) { tcggenmulu2i32(lo, cpuR[RRRR], cpuR[RRRS], cpuR[RRRT]); } else { tcggenmuls2i32(lo, cpuR[RRRR], cpuR[RRRS], cpuR[RRRT]); } tcgtempfree(lo); } break; case 12: /*QUOUi*/ tcggendivui32(cpuR[RRRR], cpuR[RRRS], cpuR[RRRT]); break; case 13: /*QUOSi*/ case 15: /*REMSi*/ { int label1 = gennewlabel(); int label2 = gennewlabel(); tcggenbrcondii32(TCGCONDNE, cpuR[RRRS], 0x80000000, label1); tcggenbrcondii32(TCGCONDNE, cpuR[RRRT], 0xffffffff, label1); tcggenmovii32(cpuR[RRRR], OP2 == 13 ? 0x80000000 : 0); tcggenbr(label2); gensetlabel(label1); if (OP2 == 13) { tcggendivi32(cpuR[RRRR], cpuR[RRRS], cpuR[RRRT]); } else { tcggenremi32(cpuR[RRRR], cpuR[RRRS], cpuR[RRRT]); } gensetlabel(label2); } break; case 14: /*REMUi*/ tcggenremui32(cpuR[RRRR], cpuR[RRRS], cpuR[RRRT]); break; default: /*reserved*/ RESERVED(); break; } break; case 3: /*RST3*/ switch (OP2) { case 0: /*RSR*/ if (genchecksr(dc, RSRSR, SRR) && (RSRSR < 64 || gencheckprivilege(dc)) && genwindowcheck1(dc, RRRT)) { genrsr(dc, cpuR[RRRT], RSRSR); } break; case 1: /*WSR*/ if (genchecksr(dc, RSRSR, SRW) && (RSRSR < 64 || gencheckprivilege(dc)) && genwindowcheck1(dc, RRRT)) { genwsr(dc, RSRSR, cpuR[RRRT]); } break; case 2: /*SEXTu*/ HASOPTION(XTENSAOPTIONMISCOPSEXT); if (genwindowcheck2(dc, RRRR, RRRS)) { int shift = 24 - RRRT; if (shift == 24) { tcggenext8si32(cpuR[RRRR], cpuR[RRRS]); } else if (shift == 16) { tcggenext16si32(cpuR[RRRR], cpuR[RRRS]); } else { TCGvi32 tmp = tcgtempnewi32(); tcggenshlii32(tmp, cpuR[RRRS], shift); tcggensarii32(cpuR[RRRR], tmp, shift); tcgtempfree(tmp); } } break; case 3: /*CLAMPSu*/ HASOPTION(XTENSAOPTIONMISCOPCLAMPS); if (genwindowcheck2(dc, RRRR, RRRS)) { TCGvi32 tmp1 = tcgtempnewi32(); TCGvi32 tmp2 = tcgtempnewi32(); TCGvi32 zero = tcgconsti32(0); tcggensarii32(tmp1, cpuR[RRRS], 24 - RRRT); tcggenxori32(tmp2, tmp1, cpuR[RRRS]); tcggenandii32(tmp2, tmp2, 0xffffffff << (RRRT + 7)); tcggensarii32(tmp1, cpuR[RRRS], 31); tcggenxorii32(tmp1, tmp1, 0xffffffff >> (25 - RRRT)); tcggenmovcondi32(TCGCONDEQ, cpuR[RRRR], tmp2, zero, cpuR[RRRS], tmp1); tcgtempfree(tmp1); tcgtempfree(tmp2); tcgtempfree(zero); } break; case 4: /*MINu*/ case 5: /*MAXu*/ case 6: /*MINUu*/ case 7: /*MAXUu*/ HASOPTION(XTENSAOPTIONMISCOPMINMAX); if (genwindowcheck3(dc, RRRR, RRRS, RRRT)) { static const TCGCond cond[] = { TCGCONDLE, TCGCONDGE, TCGCONDLEU, TCGCONDGEU }; tcggenmovcondi32(cond[OP2 - 4], cpuR[RRRR], cpuR[RRRS], cpuR[RRRT], cpuR[RRRS], cpuR[RRRT]); } break; case 8: /*MOVEQZ*/ case 9: /*MOVNEZ*/ case 10: /*MOVLTZ*/ case 11: /*MOVGEZ*/ if (genwindowcheck3(dc, RRRR, RRRS, RRRT)) { static const TCGCond cond[] = { TCGCONDEQ, TCGCONDNE, TCGCONDLT, TCGCONDGE, }; TCGvi32 zero = tcgconsti32(0); tcggenmovcondi32(cond[OP2 - 8], cpuR[RRRR], cpuR[RRRT], zero, cpuR[RRRS], cpuR[RRRR]); tcgtempfree(zero); } break; case 12: /*MOVFp*/ case 13: /*MOVTp*/ HASOPTION(XTENSAOPTIONBOOLEAN); if (genwindowcheck2(dc, RRRR, RRRS)) { TCGvi32 zero = tcgconsti32(0); TCGvi32 tmp = tcgtempnewi32(); tcggenandii32(tmp, cpuSR[BR], 1 << RRRT); tcggenmovcondi32(OP2 & 1 ? TCGCONDNE : TCGCONDEQ, cpuR[RRRR], tmp, zero, cpuR[RRRS], cpuR[RRRR]); tcgtempfree(tmp); tcgtempfree(zero); } break; case 14: /*RUR*/ if (genwindowcheck1(dc, RRRR)) { int st = (RRRS << 4) + RRRT; if (uregnames[st].name) { tcggenmovi32(cpuR[RRRR], cpuUR[st]); } else { qemulog(\"RUR %d not implemented, \", st); TBD(); } } break; case 15: /*WUR*/ if (genwindowcheck1(dc, RRRT)) { if (uregnames[RSRSR].name) { genwur(RSRSR, cpuR[RRRT]); } else { qemulog(\"WUR %d not implemented, \", RSRSR); TBD(); } } break; } break; case 4: /*EXTUI*/ case 5: if (genwindowcheck2(dc, RRRR, RRRT)) { int shiftimm = RRRS | ((OP1 & 1) << 4); int maskimm = (1 << (OP2 + 1)) - 1; TCGvi32 tmp = tcgtempnewi32(); tcggenshrii32(tmp, cpuR[RRRT], shiftimm); tcggenandii32(cpuR[RRRR], tmp, maskimm); tcgtempfree(tmp); } break; case 6: /*CUST0*/ RESERVED(); break; case 7: /*CUST1*/ RESERVED(); break; case 8: /*LSCXp*/ switch (OP2) { case 0: /*LSXf*/ case 1: /*LSXUf*/ case 4: /*SSXf*/ case 5: /*SSXUf*/ HASOPTION(XTENSAOPTIONFPCOPROCESSOR); if (genwindowcheck2(dc, RRRS, RRRT) && gencheckcpenable(dc, 0)) { TCGvi32 addr = tcgtempnewi32(); tcggenaddi32(addr, cpuR[RRRS], cpuR[RRRT]); genloadstorealignment(dc, 2, addr, false); if (OP2 & 0x4) { tcggenqemust32(cpuFR[RRRR], addr, dc->cring); } else { tcggenqemuld32u(cpuFR[RRRR], addr, dc->cring); } if (OP2 & 0x1) { tcggenmovi32(cpuR[RRRS], addr); } tcgtempfree(addr); } break; default: /*reserved*/ RESERVED(); break; } break; case 9: /*LSC4*/ if (!genwindowcheck2(dc, RRRS, RRRT)) { break; } switch (OP2) { case 0: /*L32E*/ HASOPTION(XTENSAOPTIONWINDOWEDREGISTER); if (gencheckprivilege(dc)) { TCGvi32 addr = tcgtempnewi32(); tcggenaddii32(addr, cpuR[RRRS], (0xffffffc0 | (RRRR << 2))); tcggenqemuld32u(cpuR[RRRT], addr, dc->ring); tcgtempfree(addr); } break; case 4: /*S32E*/ HASOPTION(XTENSAOPTIONWINDOWEDREGISTER); if (gencheckprivilege(dc)) { TCGvi32 addr = tcgtempnewi32(); tcggenaddii32(addr, cpuR[RRRS], (0xffffffc0 | (RRRR << 2))); tcggenqemust32(cpuR[RRRT], addr, dc->ring); tcgtempfree(addr); } break; default: RESERVED(); break; } break; case 10: /*FP0*/ HASOPTION(XTENSAOPTIONFPCOPROCESSOR); switch (OP2) { case 0: /*ADD.Sf*/ if (gencheckcpenable(dc, 0)) { genhelperadds(cpuFR[RRRR], cpuenv, cpuFR[RRRS], cpuFR[RRRT]); } break; case 1: /*SUB.Sf*/ if (gencheckcpenable(dc, 0)) { genhelpersubs(cpuFR[RRRR], cpuenv, cpuFR[RRRS], cpuFR[RRRT]); } break; case 2: /*MUL.Sf*/ if (gencheckcpenable(dc, 0)) { genhelpermuls(cpuFR[RRRR], cpuenv, cpuFR[RRRS], cpuFR[RRRT]); } break; case 4: /*MADD.Sf*/ if (gencheckcpenable(dc, 0)) { genhelpermadds(cpuFR[RRRR], cpuenv, cpuFR[RRRR], cpuFR[RRRS], cpuFR[RRRT]); } break; case 5: /*MSUB.Sf*/ if (gencheckcpenable(dc, 0)) { genhelpermsubs(cpuFR[RRRR], cpuenv, cpuFR[RRRR], cpuFR[RRRS], cpuFR[RRRT]); } break; case 8: /*ROUND.Sf*/ case 9: /*TRUNC.Sf*/ case 10: /*FLOOR.Sf*/ case 11: /*CEIL.Sf*/ case 14: /*UTRUNC.Sf*/ if (genwindowcheck1(dc, RRRR) && gencheckcpenable(dc, 0)) { static const unsigned roundingmodeconst[] = { floatroundnearesteven, floatroundtozero, floatrounddown, floatroundup, [6] = floatroundtozero, }; TCGvi32 roundingmode = tcgconsti32( roundingmodeconst[OP2 & 7]); TCGvi32 scale = tcgconsti32(RRRT); if (OP2 == 14) { genhelperftoui(cpuR[RRRR], cpuFR[RRRS], roundingmode, scale); } else { genhelperftoi(cpuR[RRRR], cpuFR[RRRS], roundingmode, scale); } tcgtempfree(roundingmode); tcgtempfree(scale); } break; case 12: /*FLOAT.Sf*/ case 13: /*UFLOAT.Sf*/ if (genwindowcheck1(dc, RRRS) && gencheckcpenable(dc, 0)) { TCGvi32 scale = tcgconsti32(-RRRT); if (OP2 == 13) { genhelperuitof(cpuFR[RRRR], cpuenv, cpuR[RRRS], scale); } else { genhelperitof(cpuFR[RRRR], cpuenv, cpuR[RRRS], scale); } tcgtempfree(scale); } break; case 15: /*FP1OP*/ switch (RRRT) { case 0: /*MOV.Sf*/ if (gencheckcpenable(dc, 0)) { tcggenmovi32(cpuFR[RRRR], cpuFR[RRRS]); } break; case 1: /*ABS.Sf*/ if (gencheckcpenable(dc, 0)) { genhelperabss(cpuFR[RRRR], cpuFR[RRRS]); } break; case 4: /*RFRf*/ if (genwindowcheck1(dc, RRRR) && gencheckcpenable(dc, 0)) { tcggenmovi32(cpuR[RRRR], cpuFR[RRRS]); } break; case 5: /*WFRf*/ if (genwindowcheck1(dc, RRRS) && gencheckcpenable(dc, 0)) { tcggenmovi32(cpuFR[RRRR], cpuR[RRRS]); } break; case 6: /*NEG.Sf*/ if (gencheckcpenable(dc, 0)) { genhelpernegs(cpuFR[RRRR], cpuFR[RRRS]); } break; default: /*reserved*/ RESERVED(); break; } break; default: /*reserved*/ RESERVED(); break; } break; case 11: /*FP1*/ HASOPTION(XTENSAOPTIONFPCOPROCESSOR); #define gencompare(rel, br, a, b) \\ do { \\ if (gencheckcpenable(dc, 0)) { \\ TCGvi32 bit = tcgconsti32(1 << br); \\ \\ genhelper##rel(cpuenv, bit, cpuFR[a], cpuFR[b]); \\ tcgtempfree(bit); \\ } \\ } while (0) switch (OP2) { case 1: /*UN.Sf*/ gencompare(uns, RRRR, RRRS, RRRT); break; case 2: /*OEQ.Sf*/ gencompare(oeqs, RRRR, RRRS, RRRT); break; case 3: /*UEQ.Sf*/ gencompare(ueqs, RRRR, RRRS, RRRT); break; case 4: /*OLT.Sf*/ gencompare(olts, RRRR, RRRS, RRRT); break; case 5: /*ULT.Sf*/ gencompare(ults, RRRR, RRRS, RRRT); break; case 6: /*OLE.Sf*/ gencompare(oles, RRRR, RRRS, RRRT); break; case 7: /*ULE.Sf*/ gencompare(ules, RRRR, RRRS, RRRT); break; #undef gencompare case 8: /*MOVEQZ.Sf*/ case 9: /*MOVNEZ.Sf*/ case 10: /*MOVLTZ.Sf*/ case 11: /*MOVGEZ.Sf*/ if (genwindowcheck1(dc, RRRT) && gencheckcpenable(dc, 0)) { static const TCGCond cond[] = { TCGCONDEQ, TCGCONDNE, TCGCONDLT, TCGCONDGE, }; TCGvi32 zero = tcgconsti32(0); tcggenmovcondi32(cond[OP2 - 8], cpuFR[RRRR], cpuR[RRRT], zero, cpuFR[RRRS], cpuFR[RRRR]); tcgtempfree(zero); } break; case 12: /*MOVF.Sf*/ case 13: /*MOVT.Sf*/ HASOPTION(XTENSAOPTIONBOOLEAN); if (gencheckcpenable(dc, 0)) { TCGvi32 zero = tcgconsti32(0); TCGvi32 tmp = tcgtempnewi32(); tcggenandii32(tmp, cpuSR[BR], 1 << RRRT); tcggenmovcondi32(OP2 & 1 ? TCGCONDNE : TCGCONDEQ, cpuFR[RRRR], tmp, zero, cpuFR[RRRS], cpuFR[RRRR]); tcgtempfree(tmp); tcgtempfree(zero); } break; default: /*reserved*/ RESERVED(); break; } break; default: /*reserved*/ RESERVED(); break; } break; case 1: /*L32R*/ if (genwindowcheck1(dc, RRRT)) { TCGvi32 tmp = tcgconsti32( ((dc->tb->flags & XTENSATBFLAGLITBASE) ? 0 : ((dc->pc + 3) & ~3)) + (0xfffc0000 | (RI16IMM16 << 2))); if (dc->tb->flags & XTENSATBFLAGLITBASE) { tcggenaddi32(tmp, tmp, dc->litbase); } tcggenqemuld32u(cpuR[RRRT], tmp, dc->cring); tcgtempfree(tmp); } break; case 2: /*LSAI*/ #define genloadstore(type, shift) do { \\ if (genwindowcheck2(dc, RRI8S, RRI8T)) { \\ TCGvi32 addr = tcgtempnewi32(); \\ \\ tcggenaddii32(addr, cpuR[RRI8S], RRI8IMM8 << shift); \\ if (shift) { \\ genloadstorealignment(dc, shift, addr, false); \\ } \\ tcggenqemu##type(cpuR[RRI8T], addr, dc->cring); \\ tcgtempfree(addr); \\ } \\ } while (0) switch (RRI8R) { case 0: /*L8UI*/ genloadstore(ld8u, 0); break; case 1: /*L16UI*/ genloadstore(ld16u, 1); break; case 2: /*L32I*/ genloadstore(ld32u, 2); break; case 4: /*S8I*/ genloadstore(st8, 0); break; case 5: /*S16I*/ genloadstore(st16, 1); break; case 6: /*S32I*/ genloadstore(st32, 2); break; #define gendcachehittest(w, shift) do { \\ if (genwindowcheck1(dc, RRI##w##S)) { \\ TCGvi32 addr = tcgtempnewi32(); \\ TCGvi32 res = tcgtempnewi32(); \\ tcggenaddii32(addr, cpuR[RRI##w##S], \\ RRI##w##IMM##w << shift); \\ tcggenqemuld8u(res, addr, dc->cring); \\ tcgtempfree(addr); \\ tcgtempfree(res); \\ } \\ } while (0) #define gendcachehittest4() gendcachehittest(4, 4) #define gendcachehittest8() gendcachehittest(8, 2) case 7: /*CACHEc*/ if (RRI8T < 8) { HASOPTION(XTENSAOPTIONDCACHE); } switch (RRI8T) { case 0: /*DPFRc*/ genwindowcheck1(dc, RRI8S); break; case 1: /*DPFWc*/ genwindowcheck1(dc, RRI8S); break; case 2: /*DPFROc*/ genwindowcheck1(dc, RRI8S); break; case 3: /*DPFWOc*/ genwindowcheck1(dc, RRI8S); break; case 4: /*DHWBc*/ gendcachehittest8(); break; case 5: /*DHWBIc*/ gendcachehittest8(); break; case 6: /*DHIc*/ if (gencheckprivilege(dc)) { gendcachehittest8(); } break; case 7: /*DIIc*/ if (gencheckprivilege(dc)) { genwindowcheck1(dc, RRI8S); } break; case 8: /*DCEc*/ switch (OP1) { case 0: /*DPFLl*/ HASOPTION(XTENSAOPTIONDCACHEINDEXLOCK); if (gencheckprivilege(dc)) { gendcachehittest4(); } break; case 2: /*DHUl*/ HASOPTION(XTENSAOPTIONDCACHEINDEXLOCK); if (gencheckprivilege(dc)) { gendcachehittest4(); } break; case 3: /*DIUl*/ HASOPTION(XTENSAOPTIONDCACHEINDEXLOCK); if (gencheckprivilege(dc)) { genwindowcheck1(dc, RRI4S); } break; case 4: /*DIWBc*/ HASOPTION(XTENSAOPTIONDCACHE); if (gencheckprivilege(dc)) { genwindowcheck1(dc, RRI4S); } break; case 5: /*DIWBIc*/ HASOPTION(XTENSAOPTIONDCACHE); if (gencheckprivilege(dc)) { genwindowcheck1(dc, RRI4S); } break; default: /*reserved*/ RESERVED(); break; } break; #undef gendcachehittest #undef gendcachehittest4 #undef gendcachehittest8 #define genicachehittest(w, shift) do { \\ if (genwindowcheck1(dc, RRI##w##S)) { \\ TCGvi32 addr = tcgtempnewi32(); \\ tcggenmovii32(cpupc, dc->pc); \\ tcggenaddii32(addr, cpuR[RRI##w##S], \\ RRI##w##IMM##w << shift); \\ genhelperitlbhittest(cpuenv, addr); \\ tcgtempfree(addr); \\ }\\ } while (0) #define genicachehittest4() genicachehittest(4, 4) #define genicachehittest8() genicachehittest(8, 2) case 12: /*IPFc*/ HASOPTION(XTENSAOPTIONICACHE); genwindowcheck1(dc, RRI8S); break; case 13: /*ICEc*/ switch (OP1) { case 0: /*IPFLl*/ HASOPTION(XTENSAOPTIONICACHEINDEXLOCK); if (gencheckprivilege(dc)) { genicachehittest4(); } break; case 2: /*IHUl*/ HASOPTION(XTENSAOPTIONICACHEINDEXLOCK); if (gencheckprivilege(dc)) { genicachehittest4(); } break; case 3: /*IIUl*/ HASOPTION(XTENSAOPTIONICACHEINDEXLOCK); if (gencheckprivilege(dc)) { genwindowcheck1(dc, RRI4S); } break; default: /*reserved*/ RESERVED(); break; } break; case 14: /*IHIc*/ HASOPTION(XTENSAOPTIONICACHE); genicachehittest8(); break; case 15: /*IIIc*/ HASOPTION(XTENSAOPTIONICACHE); if (gencheckprivilege(dc)) { genwindowcheck1(dc, RRI8S); } break; default: /*reserved*/ RESERVED(); break; } break; #undef genicachehittest #undef genicachehittest4 #undef genicachehittest8 case 9: /*L16SI*/ genloadstore(ld16s, 1); break; #undef genloadstore case 10: /*MOVI*/ if (genwindowcheck1(dc, RRI8T)) { tcggenmovii32(cpuR[RRI8T], RRI8IMM8 | (RRI8S << 8) | ((RRI8S & 0x8) ? 0xfffff000 : 0)); } break; #define genloadstorenohwalign(type) do { \\ if (genwindowcheck2(dc, RRI8S, RRI8T)) { \\ TCGvi32 addr = tcgtemplocalnewi32(); \\ tcggenaddii32(addr, cpuR[RRI8S], RRI8IMM8 << 2); \\ genloadstorealignment(dc, 2, addr, true); \\ tcggenqemu##type(cpuR[RRI8T], addr, dc->cring); \\ tcgtempfree(addr); \\ } \\ } while (0) case 11: /*L32AIy*/ HASOPTION(XTENSAOPTIONMPSYNCHRO); genloadstorenohwalign(ld32u); /*TODO acquire?*/ break; case 12: /*ADDI*/ if (genwindowcheck2(dc, RRI8S, RRI8T)) { tcggenaddii32(cpuR[RRI8T], cpuR[RRI8S], RRI8IMM8SE); } break; case 13: /*ADDMI*/ if (genwindowcheck2(dc, RRI8S, RRI8T)) { tcggenaddii32(cpuR[RRI8T], cpuR[RRI8S], RRI8IMM8SE << 8); } break; case 14: /*S32C1Iy*/ HASOPTION(XTENSAOPTIONCONDITIONALSTORE); if (genwindowcheck2(dc, RRI8S, RRI8T)) { int label = gennewlabel(); TCGvi32 tmp = tcgtemplocalnewi32(); TCGvi32 addr = tcgtemplocalnewi32(); TCGvi32 tpc; tcggenmovi32(tmp, cpuR[RRI8T]); tcggenaddii32(addr, cpuR[RRI8S], RRI8IMM8 << 2); genloadstorealignment(dc, 2, addr, true); genadvanceccount(dc); tpc = tcgconsti32(dc->pc); genhelpercheckatomctl(cpuenv, tpc, addr); tcggenqemuld32u(cpuR[RRI8T], addr, dc->cring); tcggenbrcondi32(TCGCONDNE, cpuR[RRI8T], cpuSR[SCOMPARE1], label); tcggenqemust32(tmp, addr, dc->cring); gensetlabel(label); tcgtempfree(tpc); tcgtempfree(addr); tcgtempfree(tmp); } break; case 15: /*S32RIy*/ HASOPTION(XTENSAOPTIONMPSYNCHRO); genloadstorenohwalign(st32); /*TODO release?*/ break; #undef genloadstorenohwalign default: /*reserved*/ RESERVED(); break; } break; case 3: /*LSCIp*/ switch (RRI8R) { case 0: /*LSIf*/ case 4: /*SSIf*/ case 8: /*LSIUf*/ case 12: /*SSIUf*/ HASOPTION(XTENSAOPTIONFPCOPROCESSOR); if (genwindowcheck1(dc, RRI8S) && gencheckcpenable(dc, 0)) { TCGvi32 addr = tcgtempnewi32(); tcggenaddii32(addr, cpuR[RRI8S], RRI8IMM8 << 2); genloadstorealignment(dc, 2, addr, false); if (RRI8R & 0x4) { tcggenqemust32(cpuFR[RRI8T], addr, dc->cring); } else { tcggenqemuld32u(cpuFR[RRI8T], addr, dc->cring); } if (RRI8R & 0x8) { tcggenmovi32(cpuR[RRI8S], addr); } tcgtempfree(addr); } break; default: /*reserved*/ RESERVED(); break; } break; case 4: /*MAC16d*/ HASOPTION(XTENSAOPTIONMAC16); { enum { MAC16UMUL = 0x0, MAC16MUL = 0x4, MAC16MULA = 0x8, MAC16MULS = 0xc, MAC16NONE = 0xf, } op = OP1 & 0xc; bool ism1sr = (OP2 & 0x3) == 2; bool ism2sr = (OP2 & 0xc) == 0; uint32t ldoffset = 0; if (OP2 > 9) { RESERVED(); } switch (OP2 & 2) { case 0: /*MACI?/MACC?*/ ism1sr = true; ldoffset = (OP2 & 1) ? -4 : 4; if (OP2 >= 8) { /*MACI/MACC*/ if (OP1 == 0) { /*LDINC/LDDEC*/ op = MAC16NONE; } else { RESERVED(); } } else if (op != MAC16MULA) { /*MULA.*.*.LDINC/LDDEC*/ RESERVED(); } break; case 2: /*MACD?/MACA?*/ if (op == MAC16UMUL && OP2 != 7) { /*UMUL only in MACAA*/ RESERVED(); } break; } if (op != MAC16NONE) { if (!ism1sr && !genwindowcheck1(dc, RRRS)) { break; } if (!ism2sr && !genwindowcheck1(dc, RRRT)) { break; } } if (ldoffset && !genwindowcheck1(dc, RRRS)) { break; } { TCGvi32 vaddr = tcgtempnewi32(); TCGvi32 mem32 = tcgtempnewi32(); if (ldoffset) { tcggenaddii32(vaddr, cpuR[RRRS], ldoffset); genloadstorealignment(dc, 2, vaddr, false); tcggenqemuld32u(mem32, vaddr, dc->cring); } if (op != MAC16NONE) { TCGvi32 m1 = genmac16m( ism1sr ? cpuSR[MR + RRRX] : cpuR[RRRS], OP1 & 1, op == MAC16UMUL); TCGvi32 m2 = genmac16m( ism2sr ? cpuSR[MR + 2 + RRRY] : cpuR[RRRT], OP1 & 2, op == MAC16UMUL); if (op == MAC16MUL || op == MAC16UMUL) { tcggenmuli32(cpuSR[ACCLO], m1, m2); if (op == MAC16UMUL) { tcggenmovii32(cpuSR[ACCHI], 0); } else { tcggensarii32(cpuSR[ACCHI], cpuSR[ACCLO], 31); } } else { TCGvi32 lo = tcgtempnewi32(); TCGvi32 hi = tcgtempnewi32(); tcggenmuli32(lo, m1, m2); tcggensarii32(hi, lo, 31); if (op == MAC16MULA) { tcggenadd2i32(cpuSR[ACCLO], cpuSR[ACCHI], cpuSR[ACCLO], cpuSR[ACCHI], lo, hi); } else { tcggensub2i32(cpuSR[ACCLO], cpuSR[ACCHI], cpuSR[ACCLO], cpuSR[ACCHI], lo, hi); } tcggenext8si32(cpuSR[ACCHI], cpuSR[ACCHI]); tcgtempfreei32(lo); tcgtempfreei32(hi); } tcgtempfree(m1); tcgtempfree(m2); } if (ldoffset) { tcggenmovi32(cpuR[RRRS], vaddr); tcggenmovi32(cpuSR[MR + RRRW], mem32); } tcgtempfree(vaddr); tcgtempfree(mem32); } } break; case 5: /*CALLN*/ switch (CALLN) { case 0: /*CALL0*/ tcggenmovii32(cpuR[0], dc->nextpc); genjumpi(dc, (dc->pc & ~3) + (CALLOFFSETSE << 2) + 4, 0); break; case 1: /*CALL4w*/ case 2: /*CALL8w*/ case 3: /*CALL12w*/ HASOPTION(XTENSAOPTIONWINDOWEDREGISTER); if (genwindowcheck1(dc, CALLN << 2)) { gencallwi(dc, CALLN, (dc->pc & ~3) + (CALLOFFSETSE << 2) + 4, 0); } break; } break; case 6: /*SI*/ switch (CALLN) { case 0: /*J*/ genjumpi(dc, dc->pc + 4 + CALLOFFSETSE, 0); break; case 1: /*BZ*/ if (genwindowcheck1(dc, BRI12S)) { static const TCGCond cond[] = { TCGCONDEQ, /*BEQZ*/ TCGCONDNE, /*BNEZ*/ TCGCONDLT, /*BLTZ*/ TCGCONDGE, /*BGEZ*/ }; genbrcondi(dc, cond[BRI12M & 3], cpuR[BRI12S], 0, 4 + BRI12IMM12SE); } break; case 2: /*BI0*/ if (genwindowcheck1(dc, BRI8S)) { static const TCGCond cond[] = { TCGCONDEQ, /*BEQI*/ TCGCONDNE, /*BNEI*/ TCGCONDLT, /*BLTI*/ TCGCONDGE, /*BGEI*/ }; genbrcondi(dc, cond[BRI8M & 3], cpuR[BRI8S], B4CONST[BRI8R], 4 + BRI8IMM8SE); } break; case 3: /*BI1*/ switch (BRI8M) { case 0: /*ENTRYw*/ HASOPTION(XTENSAOPTIONWINDOWEDREGISTER); { TCGvi32 pc = tcgconsti32(dc->pc); TCGvi32 s = tcgconsti32(BRI12S); TCGvi32 imm = tcgconsti32(BRI12IMM12); genadvanceccount(dc); genhelperentry(cpuenv, pc, s, imm); tcgtempfree(imm); tcgtempfree(s); tcgtempfree(pc); /* This can change tb->flags, so exit tb */ genjumpicheckloopend(dc, -1); } break; case 1: /*B1*/ switch (BRI8R) { case 0: /*BFp*/ case 1: /*BTp*/ HASOPTION(XTENSAOPTIONBOOLEAN); { TCGvi32 tmp = tcgtempnewi32(); tcggenandii32(tmp, cpuSR[BR], 1 << RRI8S); genbrcondi(dc, BRI8R == 1 ? TCGCONDNE : TCGCONDEQ, tmp, 0, 4 + RRI8IMM8SE); tcgtempfree(tmp); } break; case 8: /*LOOP*/ case 9: /*LOOPNEZ*/ case 10: /*LOOPGTZ*/ HASOPTION(XTENSAOPTIONLOOP); if (genwindowcheck1(dc, RRI8S)) { uint32t lend = dc->pc + RRI8IMM8 + 4; TCGvi32 tmp = tcgconsti32(lend); tcggensubii32(cpuSR[LCOUNT], cpuR[RRI8S], 1); tcggenmovii32(cpuSR[LBEG], dc->nextpc); genhelperwsrlend(cpuenv, tmp); tcgtempfree(tmp); if (BRI8R > 8) { int label = gennewlabel(); tcggenbrcondii32( BRI8R == 9 ? TCGCONDNE : TCGCONDGT, cpuR[RRI8S], 0, label); genjumpi(dc, lend, 1); gensetlabel(label); } genjumpi(dc, dc->nextpc, 0); } break; default: /*reserved*/ RESERVED(); break; } break; case 2: /*BLTUI*/ case 3: /*BGEUI*/ if (genwindowcheck1(dc, BRI8S)) { genbrcondi(dc, BRI8M == 2 ? TCGCONDLTU : TCGCONDGEU, cpuR[BRI8S], B4CONSTU[BRI8R], 4 + BRI8IMM8SE); } break; } break; } break; case 7: /*B*/ { TCGCond eqne = (RRI8R & 8) ? TCGCONDNE : TCGCONDEQ; switch (RRI8R & 7) { case 0: /*BNONE*/ /*BANY*/ if (genwindowcheck2(dc, RRI8S, RRI8T)) { TCGvi32 tmp = tcgtempnewi32(); tcggenandi32(tmp, cpuR[RRI8S], cpuR[RRI8T]); genbrcondi(dc, eqne, tmp, 0, 4 + RRI8IMM8SE); tcgtempfree(tmp); } break; case 1: /*BEQ*/ /*BNE*/ case 2: /*BLT*/ /*BGE*/ case 3: /*BLTU*/ /*BGEU*/ if (genwindowcheck2(dc, RRI8S, RRI8T)) { static const TCGCond cond[] = { [1] = TCGCONDEQ, [2] = TCGCONDLT, [3] = TCGCONDLTU, [9] = TCGCONDNE, [10] = TCGCONDGE, [11] = TCGCONDGEU, }; genbrcond(dc, cond[RRI8R], cpuR[RRI8S], cpuR[RRI8T], 4 + RRI8IMM8SE); } break; case 4: /*BALL*/ /*BNALL*/ if (genwindowcheck2(dc, RRI8S, RRI8T)) { TCGvi32 tmp = tcgtempnewi32(); tcggenandi32(tmp, cpuR[RRI8S], cpuR[RRI8T]); genbrcond(dc, eqne, tmp, cpuR[RRI8T], 4 + RRI8IMM8SE); tcgtempfree(tmp); } break; case 5: /*BBC*/ /*BBS*/ if (genwindowcheck2(dc, RRI8S, RRI8T)) { #ifdef TARGETWORDSBIGENDIAN TCGvi32 bit = tcgconsti32(0x80000000); #else TCGvi32 bit = tcgconsti32(0x00000001); #endif TCGvi32 tmp = tcgtempnewi32(); tcggenandii32(tmp, cpuR[RRI8T], 0x1f); #ifdef TARGETWORDSBIGENDIAN tcggenshri32(bit, bit, tmp); #else tcggenshli32(bit, bit, tmp); #endif tcggenandi32(tmp, cpuR[RRI8S], bit); genbrcondi(dc, eqne, tmp, 0, 4 + RRI8IMM8SE); tcgtempfree(tmp); tcgtempfree(bit); } break; case 6: /*BBCI*/ /*BBSI*/ case 7: if (genwindowcheck1(dc, RRI8S)) { TCGvi32 tmp = tcgtempnewi32(); tcggenandii32(tmp, cpuR[RRI8S], #ifdef TARGETWORDSBIGENDIAN 0x80000000 >> (((RRI8R & 1) << 4) | RRI8T)); #else 0x00000001 << (((RRI8R & 1) << 4) | RRI8T)); #endif genbrcondi(dc, eqne, tmp, 0, 4 + RRI8IMM8SE); tcgtempfree(tmp); } break; } } break; #define gennarrowloadstore(type) do { \\ if (genwindowcheck2(dc, RRRNS, RRRNT)) { \\ TCGvi32 addr = tcgtempnewi32(); \\ tcggenaddii32(addr, cpuR[RRRNS], RRRNR << 2); \\ genloadstorealignment(dc, 2, addr, false); \\ tcggenqemu##type(cpuR[RRRNT], addr, dc->cring); \\ tcgtempfree(addr); \\ } \\ } while (0) case 8: /*L32I.Nn*/ gennarrowloadstore(ld32u); break; case 9: /*S32I.Nn*/ gennarrowloadstore(st32); break; #undef gennarrowloadstore case 10: /*ADD.Nn*/ if (genwindowcheck3(dc, RRRNR, RRRNS, RRRNT)) { tcggenaddi32(cpuR[RRRNR], cpuR[RRRNS], cpuR[RRRNT]); } break; case 11: /*ADDI.Nn*/ if (genwindowcheck2(dc, RRRNR, RRRNS)) { tcggenaddii32(cpuR[RRRNR], cpuR[RRRNS], RRRNT ? RRRNT : -1); } break; case 12: /*ST2n*/ if (!genwindowcheck1(dc, RRRNS)) { break; } if (RRRNT < 8) { /*MOVI.Nn*/ tcggenmovii32(cpuR[RRRNS], RRRNR | (RRRNT << 4) | ((RRRNT & 6) == 6 ? 0xffffff80 : 0)); } else { /*BEQZ.Nn*/ /*BNEZ.Nn*/ TCGCond eqne = (RRRNT & 4) ? TCGCONDNE : TCGCONDEQ; genbrcondi(dc, eqne, cpuR[RRRNS], 0, 4 + (RRRNR | ((RRRNT & 3) << 4))); } break; case 13: /*ST3n*/ switch (RRRNR) { case 0: /*MOV.Nn*/ if (genwindowcheck2(dc, RRRNS, RRRNT)) { tcggenmovi32(cpuR[RRRNT], cpuR[RRRNS]); } break; case 15: /*S3*/ switch (RRRNT) { case 0: /*RET.Nn*/ genjump(dc, cpuR[0]); break; case 1: /*RETW.Nn*/ HASOPTION(XTENSAOPTIONWINDOWEDREGISTER); { TCGvi32 tmp = tcgconsti32(dc->pc); genadvanceccount(dc); genhelperretw(tmp, cpuenv, tmp); genjump(dc, tmp); tcgtempfree(tmp); } break; case 2: /*BREAK.Nn*/ HASOPTION(XTENSAOPTIONDEBUG); if (dc->debug) { gendebugexception(dc, DEBUGCAUSEBN); } break; case 3: /*NOP.Nn*/ break; case 6: /*ILL.Nn*/ genexceptioncause(dc, ILLEGALINSTRUCTIONCAUSE); break; default: /*reserved*/ RESERVED(); break; } break; default: /*reserved*/ RESERVED(); break; } break; default: /*reserved*/ RESERVED(); break; } if (dc->isjmp == DISASNEXT) { gencheckloopend(dc, 0); } dc->pc = dc->nextpc; return; invalidopcode: qemulog(\"INVALID(pc = %08x)\\n\", dc->pc); genexceptioncause(dc, ILLEGALINSTRUCTIONCAUSE); #undef HASOPTION } ", "target": 0}
{"func": "static int endframe(AVFilterLink *inlink) { AVFilterContext *ctx = inlink->dst; FPSContext *s = ctx->priv; AVFilterLink *outlink = ctx->outputs[0]; AVFilterBufferRef *buf = inlink->curbuf; int64t delta; int i, ret; inlink->curbuf = NULL; s->framesin++; /* discard frames until we get the first timestamp */ if (s->pts == AVNOPTSVALUE) { if (buf->pts != AVNOPTSVALUE) { writetofifo(s->fifo, buf); s->firstpts = s->pts = buf->pts; } else { avlog(ctx, AVLOGWARNING, \"Discarding initial frame(s) with no \" \"timestamp.\\n\"); avfilterunrefbuffer(buf); s->drop++; } return 0; } /* now wait for the next timestamp */ if (buf->pts == AVNOPTSVALUE) { return writetofifo(s->fifo, buf); } /* number of output frames */ delta = avrescaleq(buf->pts - s->pts, inlink->timebase, outlink->timebase); if (delta < 1) { /* drop the frame and everything buffered except the first */ AVFilterBufferRef *tmp; int drop = avfifosize(s->fifo)/sizeof(AVFilterBufferRef*); avlog(ctx, AVLOGDEBUG, \"Dropping %d frame(s).\\n\", drop); s->drop += drop; avfifogenericread(s->fifo, &tmp, sizeof(tmp), NULL); flushfifo(s->fifo); ret = writetofifo(s->fifo, tmp); avfilterunrefbuffer(buf); return ret; } /* can output >= 1 frames */ for (i = 0; i < delta; i++) { AVFilterBufferRef *bufout; avfifogenericread(s->fifo, &bufout, sizeof(bufout), NULL); /* duplicate the frame if needed */ if (!avfifosize(s->fifo) && i < delta - 1) { avlog(ctx, AVLOGDEBUG, \"Duplicating frame.\\n\"); writetofifo(s->fifo, avfilterrefbuffer(bufout, AVPERMREAD)); s->dup++; } bufout->pts = avrescaleq(s->firstpts, inlink->timebase, outlink->timebase) + s->framesout; if ((ret = ffstartframe(outlink, bufout)) < 0 || (ret = ffdrawslice(outlink, 0, outlink->h, 1)) < 0 || (ret = ffendframe(outlink)) < 0) { avfilterunrefbufferp(&buf); return ret; } s->framesout++; } flushfifo(s->fifo); ret = writetofifo(s->fifo, buf); s->pts = s->firstpts + avrescaleq(s->framesout, outlink->timebase, inlink->timebase); return ret; } ", "target": 0}
{"func": "static int roqreadpacket(AVFormatContext *s, AVPacket *pkt) { RoqDemuxContext *roq = s->privdata; AVIOContext *pb = s->pb; int ret = 0; unsigned int chunksize; unsigned int chunktype; unsigned int codebooksize; unsigned char preamble[RoQCHUNKPREAMBLESIZE]; int packetread = 0; int64t codebookoffset; while (!packetread) { if (aviofeof(s->pb)) return AVERROR(EIO); /* get the next chunk preamble */ if ((ret = avioread(pb, preamble, RoQCHUNKPREAMBLESIZE)) != RoQCHUNKPREAMBLESIZE) return AVERROR(EIO); chunktype = AVRL16(&preamble[0]); chunksize = AVRL32(&preamble[2]); if(chunksize > INTMAX) return AVERRORINVALIDDATA; chunksize = ffiolimit(pb, chunksize); switch (chunktype) { case RoQINFO: if (roq->videostreamindex == -1) { AVStream *st = avformatnewstream(s, NULL); if (!st) return AVERROR(ENOMEM); avprivsetptsinfo(st, 63, 1, roq->framerate); roq->videostreamindex = st->index; st->codecpar->codectype = AVMEDIATYPEVIDEO; st->codecpar->codecid = AVCODECIDROQ; st->codecpar->codectag = 0; /* no fourcc */ if (avioread(pb, preamble, RoQCHUNKPREAMBLESIZE) != RoQCHUNKPREAMBLESIZE) return AVERROR(EIO); st->codecpar->width = roq->width = AVRL16(preamble); st->codecpar->height = roq->height = AVRL16(preamble + 2); break; } /* don't care about this chunk anymore */ avioskip(pb, RoQCHUNKPREAMBLESIZE); break; case RoQQUADCODEBOOK: if (roq->videostreamindex < 0) return AVERRORINVALIDDATA; /* packet needs to contain both this codebook and next VQ chunk */ codebookoffset = aviotell(pb) - RoQCHUNKPREAMBLESIZE; codebooksize = chunksize; avioskip(pb, codebooksize); if (avioread(pb, preamble, RoQCHUNKPREAMBLESIZE) != RoQCHUNKPREAMBLESIZE) return AVERROR(EIO); chunksize = AVRL32(&preamble[2]) + RoQCHUNKPREAMBLESIZE * 2 + codebooksize; if (chunksize > INTMAX) return AVERRORINVALIDDATA; /* rewind */ avioseek(pb, codebookoffset, SEEKSET); /* load up the packet */ ret= avgetpacket(pb, pkt, chunksize); if (ret != chunksize) return AVERROR(EIO); pkt->streamindex = roq->videostreamindex; pkt->pts = roq->videopts++; packetread = 1; break; case RoQSOUNDMONO: case RoQSOUNDSTEREO: if (roq->audiostreamindex == -1) { AVStream *st = avformatnewstream(s, NULL); if (!st) return AVERROR(ENOMEM); avprivsetptsinfo(st, 32, 1, RoQAUDIOSAMPLERATE); roq->audiostreamindex = st->index; st->codecpar->codectype = AVMEDIATYPEAUDIO; st->codecpar->codecid = AVCODECIDROQDPCM; st->codecpar->codectag = 0; /* no tag */ if (chunktype == RoQSOUNDSTEREO) { st->codecpar->channels = 2; st->codecpar->channellayout = AVCHLAYOUTSTEREO; } else { st->codecpar->channels = 1; st->codecpar->channellayout = AVCHLAYOUTMONO; } roq->audiochannels = st->codecpar->channels; st->codecpar->samplerate = RoQAUDIOSAMPLERATE; st->codecpar->bitspercodedsample = 16; st->codecpar->bitrate = st->codecpar->channels * st->codecpar->samplerate * st->codecpar->bitspercodedsample; st->codecpar->blockalign = st->codecpar->channels * st->codecpar->bitspercodedsample; } case RoQQUADVQ: if (chunktype == RoQQUADVQ) { if (roq->videostreamindex < 0) return AVERRORINVALIDDATA; } /* load up the packet */ if (avnewpacket(pkt, chunksize + RoQCHUNKPREAMBLESIZE)) return AVERROR(EIO); /* copy over preamble */ memcpy(pkt->data, preamble, RoQCHUNKPREAMBLESIZE); if (chunktype == RoQQUADVQ) { pkt->streamindex = roq->videostreamindex; pkt->pts = roq->videopts++; } else { pkt->streamindex = roq->audiostreamindex; pkt->pts = roq->audioframecount; roq->audioframecount += (chunksize / roq->audiochannels); } pkt->pos= aviotell(pb); ret = avioread(pb, pkt->data + RoQCHUNKPREAMBLESIZE, chunksize); if (ret != chunksize) ret = AVERROR(EIO); packetread = 1; break; default: avlog(s, AVLOGERROR, \" unknown RoQ chunk (%04X)\\n\", chunktype); return AVERRORINVALIDDATA; } } return ret; } ", "target": 1}
{"func": "static inline void RENAME(hScale)(int16t *dst, int dstW, uint8t *src, int srcW, int xInc, \t\t\t\t int16t *filter, int16t *filterPos, int filterSize) { #ifdef HAVEMMX \tassert(filterSize % 4 == 0 && filterSize>0); \tif(filterSize==4) // allways true for upscaling, sometimes for down too \t{ \t\tlong counter= -2*dstW; \t\tfilter-= counter*2; \t\tfilterPos-= counter/2; \t\tdst-= counter/2; \t\tasm volatile( \t\t\t\"pxor %%mm7, %%mm7\t\t\\n\\t\" \t\t\t\"movq \"MANGLE(w02)\", %%mm6\t\\n\\t\" \t\t\t\"push %%\"REGBP\"\t\t\\n\\t\" // we use 7 regs here ... \t\t\t\"mov %%\"REGa\", %%\"REGBP\"\t\\n\\t\" \t\t\t\".balign 16\t\t\t\\n\\t\" \t\t\t\"1:\t\t\t\t\\n\\t\" \t\t\t\"movzwl (%2, %%\"REGBP\"), %%eax\t\\n\\t\" \t\t\t\"movzwl 2(%2, %%\"REGBP\"), %%ebx\\n\\t\" \t\t\t\"movq (%1, %%\"REGBP\", 4), %%mm1\\n\\t\" \t\t\t\"movq 8(%1, %%\"REGBP\", 4), %%mm3\\n\\t\" \t\t\t\"movd (%3, %%\"REGa\"), %%mm0\t\\n\\t\" \t\t\t\"movd (%3, %%\"REGb\"), %%mm2\t\\n\\t\" \t\t\t\"punpcklbw %%mm7, %%mm0\t\t\\n\\t\" \t\t\t\"punpcklbw %%mm7, %%mm2\t\t\\n\\t\" \t\t\t\"pmaddwd %%mm1, %%mm0\t\t\\n\\t\" \t\t\t\"pmaddwd %%mm2, %%mm3\t\t\\n\\t\" \t\t\t\"psrad $8, %%mm0\t\t\\n\\t\" \t\t\t\"psrad $8, %%mm3\t\t\\n\\t\" \t\t\t\"packssdw %%mm3, %%mm0\t\t\\n\\t\" \t\t\t\"pmaddwd %%mm6, %%mm0\t\t\\n\\t\" \t\t\t\"packssdw %%mm0, %%mm0\t\t\\n\\t\" \t\t\t\"movd %%mm0, (%4, %%\"REGBP\")\t\\n\\t\" \t\t\t\"add $4, %%\"REGBP\"\t\t\\n\\t\" \t\t\t\" jnc 1b\t\t\t\\n\\t\" \t\t\t\"pop %%\"REGBP\"\t\t\t\\n\\t\" \t\t\t: \"+a\" (counter) \t\t\t: \"c\" (filter), \"d\" (filterPos), \"S\" (src), \"D\" (dst) \t\t\t: \"%\"REGb \t\t); \t} \telse if(filterSize==8) \t{ \t\tlong counter= -2*dstW; \t\tfilter-= counter*4; \t\tfilterPos-= counter/2; \t\tdst-= counter/2; \t\tasm volatile( \t\t\t\"pxor %%mm7, %%mm7\t\t\\n\\t\" \t\t\t\"movq \"MANGLE(w02)\", %%mm6\t\\n\\t\" \t\t\t\"push %%\"REGBP\"\t\t\\n\\t\" // we use 7 regs here ... \t\t\t\"mov %%\"REGa\", %%\"REGBP\"\t\\n\\t\" \t\t\t\".balign 16\t\t\t\\n\\t\" \t\t\t\"1:\t\t\t\t\\n\\t\" \t\t\t\"movzwl (%2, %%\"REGBP\"), %%eax\t\\n\\t\" \t\t\t\"movzwl 2(%2, %%\"REGBP\"), %%ebx\\n\\t\" \t\t\t\"movq (%1, %%\"REGBP\", 8), %%mm1\\n\\t\" \t\t\t\"movq 16(%1, %%\"REGBP\", 8), %%mm3\\n\\t\" \t\t\t\"movd (%3, %%\"REGa\"), %%mm0\t\\n\\t\" \t\t\t\"movd (%3, %%\"REGb\"), %%mm2\t\\n\\t\" \t\t\t\"punpcklbw %%mm7, %%mm0\t\t\\n\\t\" \t\t\t\"punpcklbw %%mm7, %%mm2\t\t\\n\\t\" \t\t\t\"pmaddwd %%mm1, %%mm0\t\t\\n\\t\" \t\t\t\"pmaddwd %%mm2, %%mm3\t\t\\n\\t\" \t\t\t\"movq 8(%1, %%\"REGBP\", 8), %%mm1\\n\\t\" \t\t\t\"movq 24(%1, %%\"REGBP\", 8), %%mm5\\n\\t\" \t\t\t\"movd 4(%3, %%\"REGa\"), %%mm4\t\\n\\t\" \t\t\t\"movd 4(%3, %%\"REGb\"), %%mm2\t\\n\\t\" \t\t\t\"punpcklbw %%mm7, %%mm4\t\t\\n\\t\" \t\t\t\"punpcklbw %%mm7, %%mm2\t\t\\n\\t\" \t\t\t\"pmaddwd %%mm1, %%mm4\t\t\\n\\t\" \t\t\t\"pmaddwd %%mm2, %%mm5\t\t\\n\\t\" \t\t\t\"paddd %%mm4, %%mm0\t\t\\n\\t\" \t\t\t\"paddd %%mm5, %%mm3\t\t\\n\\t\" \t\t\t\t\t\t \t\t\t\"psrad $8, %%mm0\t\t\\n\\t\" \t\t\t\"psrad $8, %%mm3\t\t\\n\\t\" \t\t\t\"packssdw %%mm3, %%mm0\t\t\\n\\t\" \t\t\t\"pmaddwd %%mm6, %%mm0\t\t\\n\\t\" \t\t\t\"packssdw %%mm0, %%mm0\t\t\\n\\t\" \t\t\t\"movd %%mm0, (%4, %%\"REGBP\")\t\\n\\t\" \t\t\t\"add $4, %%\"REGBP\"\t\t\\n\\t\" \t\t\t\" jnc 1b\t\t\t\\n\\t\" \t\t\t\"pop %%\"REGBP\"\t\t\t\\n\\t\" \t\t\t: \"+a\" (counter) \t\t\t: \"c\" (filter), \"d\" (filterPos), \"S\" (src), \"D\" (dst) \t\t\t: \"%\"REGb \t\t); \t} \telse \t{ \t\tuint8t *offset = src+filterSize; \t\tlong counter= -2*dstW; //\t\tfilter-= counter*filterSize/2; \t\tfilterPos-= counter/2; \t\tdst-= counter/2; \t\tasm volatile( \t\t\t\"pxor %%mm7, %%mm7\t\t\\n\\t\" \t\t\t\"movq \"MANGLE(w02)\", %%mm6\t\\n\\t\" \t\t\t\".balign 16\t\t\t\\n\\t\" \t\t\t\"1:\t\t\t\t\\n\\t\" \t\t\t\"mov %2, %%\"REGc\"\t\t\\n\\t\" \t\t\t\"movzwl (%%\"REGc\", %0), %%eax\t\\n\\t\" \t\t\t\"movzwl 2(%%\"REGc\", %0), %%ebx\t\\n\\t\" \t\t\t\"mov %5, %%\"REGc\"\t\t\\n\\t\" \t\t\t\"pxor %%mm4, %%mm4\t\t\\n\\t\" \t\t\t\"pxor %%mm5, %%mm5\t\t\\n\\t\" \t\t\t\"2:\t\t\t\t\\n\\t\" \t\t\t\"movq (%1), %%mm1\t\t\\n\\t\" \t\t\t\"movq (%1, %6), %%mm3\t\t\\n\\t\" \t\t\t\"movd (%%\"REGc\", %%\"REGa\"), %%mm0\\n\\t\" \t\t\t\"movd (%%\"REGc\", %%\"REGb\"), %%mm2\\n\\t\" \t\t\t\"punpcklbw %%mm7, %%mm0\t\t\\n\\t\" \t\t\t\"punpcklbw %%mm7, %%mm2\t\t\\n\\t\" \t\t\t\"pmaddwd %%mm1, %%mm0\t\t\\n\\t\" \t\t\t\"pmaddwd %%mm2, %%mm3\t\t\\n\\t\" \t\t\t\"paddd %%mm3, %%mm5\t\t\\n\\t\" \t\t\t\"paddd %%mm0, %%mm4\t\t\\n\\t\" \t\t\t\"add $8, %1\t\t\t\\n\\t\" \t\t\t\"add $4, %%\"REGc\"\t\t\\n\\t\" \t\t\t\"cmp %4, %%\"REGc\"\t\t\\n\\t\" \t\t\t\" jb 2b\t\t\t\t\\n\\t\" \t\t\t\"add %6, %1\t\t\t\\n\\t\" \t\t\t\"psrad $8, %%mm4\t\t\\n\\t\" \t\t\t\"psrad $8, %%mm5\t\t\\n\\t\" \t\t\t\"packssdw %%mm5, %%mm4\t\t\\n\\t\" \t\t\t\"pmaddwd %%mm6, %%mm4\t\t\\n\\t\" \t\t\t\"packssdw %%mm4, %%mm4\t\t\\n\\t\" \t\t\t\"mov %3, %%\"REGa\"\t\t\\n\\t\" \t\t\t\"movd %%mm4, (%%\"REGa\", %0)\t\\n\\t\" \t\t\t\"add $4, %0\t\t\t\\n\\t\" \t\t\t\" jnc 1b\t\t\t\\n\\t\" \t\t\t: \"+r\" (counter), \"+r\" (filter) \t\t\t: \"m\" (filterPos), \"m\" (dst), \"m\"(offset), \t\t\t \"m\" (src), \"r\" ((long)filterSize*2) \t\t\t: \"%\"REGb, \"%\"REGa, \"%\"REGc \t\t); \t} #else #ifdef HAVEALTIVEC \thScalealtivecreal(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize); #else \tint i; \tfor(i=0; i<dstW; i++) \t{ \t\tint j; \t\tint srcPos= filterPos[i]; \t\tint val=0; //\t\tprintf(\"filterPos: %d\\n\", filterPos[i]); \t\tfor(j=0; j<filterSize; j++) \t\t{ //\t\t\tprintf(\"filter: %d, src: %d\\n\", filter[i], src[srcPos + j]); \t\t\tval += ((int)src[srcPos + j])*filter[filterSize*i + j]; \t\t} //\t\tfilter += hFilterSize; \t\tdst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ... //\t\tdst[i] = val>>7; \t} #endif #endif } ", "target": 1}
{"func": "void qemufileseterror(QEMUFile *f, int ret) { if (f->lasterror == 0) { f->lasterror = ret; } } ", "target": 1}
{"func": "static int encodepicturelossless(AVCodecContext *avctx, unsigned char *buf, int bufsize, void *data){ MpegEncContext * const s = avctx->privdata; MJpegContext * const m = s->mjpegctx; AVFrame *pict = data; const int width= s->width; const int height= s->height; AVFrame * const p= (AVFrame*)&s->currentpicture; const int predictor= avctx->predictionmethod+1; initputbits(&s->pb, buf, bufsize); *p = *pict; p->picttype= FFITYPE; p->keyframe= 1; ffmjpegencodepictureheader(s); s->headerbits= putbitscount(&s->pb); if(avctx->pixfmt == PIXFMTRGB32){ int x, y, i; const int linesize= p->linesize[0]; uint16t (*buffer)[4]= (void *) s->rdscratchpad; int left[3], top[3], topleft[3]; for(i=0; i<3; i++){ buffer[0][i]= 1 << (9 - 1); } for(y = 0; y < height; y++) { const int modifiedpredictor= y ? predictor : 1; uint8t *ptr = p->data[0] + (linesize * y); if(s->pb.bufend - s->pb.buf - (putbitscount(&s->pb)>>3) < width*3*4){ avlog(s->avctx, AVLOGERROR, \"encoded frame too large\\n\"); return -1; } for(i=0; i<3; i++){ top[i]= left[i]= topleft[i]= buffer[0][i]; } for(x = 0; x < width; x++) { buffer[x][1] = ptr[4*x+0] - ptr[4*x+1] + 0x100; buffer[x][2] = ptr[4*x+2] - ptr[4*x+1] + 0x100; buffer[x][0] = (ptr[4*x+0] + 2*ptr[4*x+1] + ptr[4*x+2])>>2; for(i=0;i<3;i++) { int pred, diff; PREDICT(pred, topleft[i], top[i], left[i], modifiedpredictor); topleft[i]= top[i]; top[i]= buffer[x+1][i]; left[i]= buffer[x][i]; diff= ((left[i] - pred + 0x100)&0x1FF) - 0x100; if(i==0) ffmjpegencodedc(s, diff, m->huffsizedcluminance, m->huffcodedcluminance); //FIXME ugly else ffmjpegencodedc(s, diff, m->huffsizedcchrominance, m->huffcodedcchrominance); } } } }else{ int mbx, mby, i; const int mbwidth = (width + s->mjpeghsample[0] - 1) / s->mjpeghsample[0]; const int mbheight = (height + s->mjpegvsample[0] - 1) / s->mjpegvsample[0]; for(mby = 0; mby < mbheight; mby++) { if(s->pb.bufend - s->pb.buf - (putbitscount(&s->pb)>>3) < mbwidth * 4 * 3 * s->mjpeghsample[0] * s->mjpegvsample[0]){ avlog(s->avctx, AVLOGERROR, \"encoded frame too large\\n\"); return -1; } for(mbx = 0; mbx < mbwidth; mbx++) { if(mbx==0 || mby==0){ for(i=0;i<3;i++) { uint8t *ptr; int x, y, h, v, linesize; h = s->mjpeghsample[i]; v = s->mjpegvsample[i]; linesize= p->linesize[i]; for(y=0; y<v; y++){ for(x=0; x<h; x++){ int pred; ptr = p->data[i] + (linesize * (v * mby + y)) + (h * mbx + x); //FIXME optimize this crap if(y==0 && mby==0){ if(x==0 && mbx==0){ pred= 128; }else{ pred= ptr[-1]; } }else{ if(x==0 && mbx==0){ pred= ptr[-linesize]; }else{ PREDICT(pred, ptr[-linesize-1], ptr[-linesize], ptr[-1], predictor); } } if(i==0) ffmjpegencodedc(s, (int8t)(*ptr - pred), m->huffsizedcluminance, m->huffcodedcluminance); //FIXME ugly else ffmjpegencodedc(s, (int8t)(*ptr - pred), m->huffsizedcchrominance, m->huffcodedcchrominance); } } } }else{ for(i=0;i<3;i++) { uint8t *ptr; int x, y, h, v, linesize; h = s->mjpeghsample[i]; v = s->mjpegvsample[i]; linesize= p->linesize[i]; for(y=0; y<v; y++){ for(x=0; x<h; x++){ int pred; ptr = p->data[i] + (linesize * (v * mby + y)) + (h * mbx + x); //FIXME optimize this crap //printf(\"%d %d %d %d %8X\\n\", mbx, mby, x, y, ptr); PREDICT(pred, ptr[-linesize-1], ptr[-linesize], ptr[-1], predictor); if(i==0) ffmjpegencodedc(s, (int8t)(*ptr - pred), m->huffsizedcluminance, m->huffcodedcluminance); //FIXME ugly else ffmjpegencodedc(s, (int8t)(*ptr - pred), m->huffsizedcchrominance, m->huffcodedcchrominance); } } } } } } } emmsc(); ffmjpegencodepicturetrailer(s); s->picturenumber++; flushputbits(&s->pb); return pbBufPtr(&s->pb) - s->pb.buf; // return (putbitscount(&f->pb)+7)/8; } ", "target": 0}
{"func": "static int optinputfile(OptionsContext *o, const char *opt, const char *filename) { AVFormatContext *ic; AVInputFormat *fileiformat = NULL; int err, i, ret; int64t timestamp; uint8t buf[128]; AVDictionary **opts; int orignbstreams; // number of streams before avformatfindstreaminfo if (o->format) { if (!(fileiformat = avfindinputformat(o->format))) { avlog(NULL, AVLOGFATAL, \"Unknown input format: '%s'\\n\", o->format); exitprogram(1); } } if (!strcmp(filename, \"-\")) filename = \"pipe:\"; usingstdin |= !strncmp(filename, \"pipe:\", 5) || !strcmp(filename, \"/dev/stdin\"); /* get default parameters from command line */ ic = avformatalloccontext(); if (!ic) { printerror(filename, AVERROR(ENOMEM)); exitprogram(1); } if (o->nbaudiosamplerate) { snprintf(buf, sizeof(buf), \"%d\", o->audiosamplerate[o->nbaudiosamplerate - 1].u.i); avdictset(&formatopts, \"samplerate\", buf, 0); } if (o->nbaudiochannels) { snprintf(buf, sizeof(buf), \"%d\", o->audiochannels[o->nbaudiochannels - 1].u.i); avdictset(&formatopts, \"channels\", buf, 0); } if (o->nbframerates) { avdictset(&formatopts, \"framerate\", o->framerates[o->nbframerates - 1].u.str, 0); } if (o->nbframesizes) { avdictset(&formatopts, \"videosize\", o->framesizes[o->nbframesizes - 1].u.str, 0); } if (o->nbframepixfmts) avdictset(&formatopts, \"pixelformat\", o->framepixfmts[o->nbframepixfmts - 1].u.str, 0); ic->videocodecid = videocodecname ? findcodecordie(videocodecname , AVMEDIATYPEVIDEO , 0)->id : CODECIDNONE; ic->audiocodecid = audiocodecname ? findcodecordie(audiocodecname , AVMEDIATYPEAUDIO , 0)->id : CODECIDNONE; ic->subtitlecodecid= subtitlecodecname ? findcodecordie(subtitlecodecname, AVMEDIATYPESUBTITLE, 0)->id : CODECIDNONE; ic->flags |= AVFMTFLAGNONBLOCK; ic->interruptcallback = intcb; if (loopinput) { avlog(NULL, AVLOGWARNING, \"-loopinput is deprecated, use -loop 1\\n\"); ic->loopinput = loopinput; } /* open the input file with generic avformat function */ err = avformatopeninput(&ic, filename, fileiformat, &formatopts); if (err < 0) { printerror(filename, err); exitprogram(1); } assertavoptions(formatopts); /* apply forced codec ids */ for (i = 0; i < ic->nbstreams; i++) choosedecoder(o, ic, ic->streams[i]); /* Set AVCodecContext options for avformatfindstreaminfo */ opts = setupfindstreaminfoopts(ic, codecopts); orignbstreams = ic->nbstreams; /* If not enough info to get the stream parameters, we decode the first frames to get it. (used in mpeg case for example) */ ret = avformatfindstreaminfo(ic, opts); if (ret < 0) { avlog(NULL, AVLOGFATAL, \"%s: could not find codec parameters\\n\", filename); avcloseinputfile(ic); exitprogram(1); } timestamp = o->starttime; /* add the stream start time */ if (ic->starttime != AVNOPTSVALUE) timestamp += ic->starttime; /* if seeking requested, we execute it */ if (o->starttime != 0) { ret = avseekframe(ic, -1, timestamp, AVSEEKFLAGBACKWARD); if (ret < 0) { avlog(NULL, AVLOGWARNING, \"%s: could not seek to position %0.3f\\n\", filename, (double)timestamp / AVTIMEBASE); } } /* update the current parameters so that they match the one of the input stream */ addinputstreams(o, ic); /* dump the file content */ avdumpformat(ic, nbinputfiles, filename, 0); inputfiles = growarray(inputfiles, sizeof(*inputfiles), &nbinputfiles, nbinputfiles + 1); inputfiles[nbinputfiles - 1].ctx = ic; inputfiles[nbinputfiles - 1].istindex = nbinputstreams - ic->nbstreams; inputfiles[nbinputfiles - 1].tsoffset = o->inputtsoffset - (copyts ? 0 : timestamp); inputfiles[nbinputfiles - 1].nbstreams = ic->nbstreams; inputfiles[nbinputfiles - 1].rateemu = o->rateemu; for (i = 0; i < o->nbdumpattachment; i++) { int j; for (j = 0; j < ic->nbstreams; j++) { AVStream *st = ic->streams[j]; if (checkstreamspecifier(ic, st, o->dumpattachment[i].specifier) == 1) dumpattachment(st, o->dumpattachment[i].u.str); } } for (i = 0; i < orignbstreams; i++) avdictfree(&opts[i]); avfreep(&opts); resetoptions(o, 1); return 0; } ", "target": 0}
{"func": "uint64t helperefdctuidz (uint64t val) { CPUDoubleU u; u.ll = val; /* NaN are not treated the same way IEEE 754 does */ if (unlikely(float64isnan(u.d))) return 0; return float64touint64roundtozero(u.d, &env->vecstatus); } ", "target": 0}
{"func": "void bioslinkerloaderaddchecksum(BIOSLinker *linker, const char *filename, void *start, unsigned size, uint8t *checksum) { BiosLinkerLoaderEntry entry; const BiosLinkerFileEntry *file = bioslinkerfindfile(linker, filename); ptrdifft checksumoffset = (gchar *)checksum - file->blob->data; ptrdifft startoffset = (gchar *)start - file->blob->data; assert(checksumoffset >= 0); assert(startoffset >= 0); assert(checksumoffset + 1 <= file->blob->len); assert(startoffset + size <= file->blob->len); assert(*checksum == 0x0); memset(&entry, 0, sizeof entry); strncpy(entry.cksum.file, filename, sizeof entry.cksum.file - 1); entry.command = cputole32(BIOSLINKERLOADERCOMMANDADDCHECKSUM); entry.cksum.offset = cputole32(checksumoffset); entry.cksum.start = cputole32(startoffset); entry.cksum.length = cputole32(size); garrayappendvals(linker->cmdblob, &entry, sizeof entry); } ", "target": 0}
{"func": "void ffthreadreleasebuffer(AVCodecContext *avctx, ThreadFrame *f) { PerThreadContext *p = avctx->internal->threadctx; FrameThreadContext *fctx; AVFrame *dst, *tmp; FFDISABLEDEPRECATIONWARNINGS int candirectfree = !(avctx->activethreadtype & FFTHREADFRAME) || avctx->threadsafecallbacks || ( #if FFAPIGETBUFFER !avctx->getbuffer && #endif avctx->getbuffer2 == avcodecdefaultgetbuffer2); FFENABLEDEPRECATIONWARNINGS if (!f->f->buf[0]) return; if (avctx->debug & FFDEBUGBUFFERS) avlog(avctx, AVLOGDEBUG, \"threadreleasebuffer called on pic %p\\n\", f); avbufferunref(&f->progress); f->owner = NULL; if (candirectfree) { avframeunref(f->f); return; } fctx = p->parent; pthreadmutexlock(&fctx->buffermutex); if (p->numreleasedbuffers + 1 >= INTMAX / sizeof(*p->releasedbuffers)) goto fail; tmp = avfastrealloc(p->releasedbuffers, &p->releasedbuffersallocated, (p->numreleasedbuffers + 1) * sizeof(*p->releasedbuffers)); if (!tmp) goto fail; p->releasedbuffers = tmp; dst = &p->releasedbuffers[p->numreleasedbuffers]; avframemoveref(dst, f->f); p->numreleasedbuffers++; fail: pthreadmutexunlock(&fctx->buffermutex); } ", "target": 1}
{"func": "void ffschroqueuefree(FFSchroQueue *queue, void (*freefunc)(void *)) { while (queue->phead) freefunc(ffschroqueuepop(queue)); } ", "target": 1}
{"func": "void qemumutexlockiothread(void) { if (!tcgenabled()) { qemumutexlock(&qemuglobalmutex); } else { iothreadrequestingmutex = true; if (qemumutextrylock(&qemuglobalmutex)) { qemucpukickthread(firstcpu); qemumutexlock(&qemuglobalmutex); } iothreadrequestingmutex = false; qemucondbroadcast(&qemuioproceededcond); } } ", "target": 1}
{"func": "static inline void genopaddlESPim(int32t val) { tcggenldtl(cputmp0, cpuenv, offsetof(CPUState, regs[RESP])); tcggenadditl(cputmp0, cputmp0, val); #ifdef TARGETX8664 tcggenanditl(cputmp0, cputmp0, 0xffffffff); #endif tcggensttl(cputmp0, cpuenv, offsetof(CPUState, regs[RESP])); } ", "target": 0}
{"func": "static unsigned int decmovur(DisasContext *dc) { \tTCGv t0; \tint size = memsizez(dc); \tDIS(fprintf (logfile, \"movu.%c $r%u, $r%u\\n\", \t\t memsizechar(size), \t\t dc->op1, dc->op2)); \tcrisccmask(dc, CCMASKNZ); \tt0 = tcgtempnew(TCGTYPETL); \tdecprepmover(dc, dc->op1, dc->op2, size, 0, t0); \tcrisalu(dc, CCOPMOVE, cpuR[dc->op2], cpuR[dc->op2], t0, 4); \ttcgtempfree(t0); \treturn 2; } ", "target": 0}
{"func": "AVInputFormat *avfindinputformat(const char *shortname) { AVInputFormat *fmt = NULL; while ((fmt = aviformatnext(fmt))) if (matchformat(shortname, fmt->name)) return fmt; return NULL; } ", "target": 0}
{"func": "static avcold void dsputilinitsse2(DSPContext *c, AVCodecContext *avctx, int mmflags) { #if HAVESSE2INLINE const int highbitdepth = avctx->bitsperrawsample > 8; if (!highbitdepth && avctx->idctalgo == FFIDCTXVIDMMX) { c->idctput = ffidctxvidsse2put; c->idctadd = ffidctxvidsse2add; c->idct = ffidctxvidsse2; c->idctpermutationtype = FFSSE2IDCTPERM; } #endif /* HAVESSE2INLINE */ #if HAVESSE2EXTERNAL c->scalarproductint16 = ffscalarproductint16sse2; c->scalarproductandmaddint16 = ffscalarproductandmaddint16sse2; if (mmflags & AVCPUFLAGATOM) { c->vectorclipint32 = ffvectorclipint32intsse2; } else { c->vectorclipint32 = ffvectorclipint32sse2; } if (avctx->flags & CODECFLAGBITEXACT) { c->applywindowint16 = ffapplywindowint16sse2; } else if (!(mmflags & AVCPUFLAGSSE2SLOW)) { c->applywindowint16 = ffapplywindowint16roundsse2; } c->bswapbuf = ffbswap32bufsse2; #endif /* HAVESSE2EXTERNAL */ } ", "target": 1}
{"func": "static int auprobe(AVProbeData *p) { /* check file header */ if (p->bufsize <= 24) return 0; if (p->buf[0] == '.' && p->buf[1] == 's' && p->buf[2] == 'n' && p->buf[3] == 'd') return AVPROBESCOREMAX; else return 0; } ", "target": 0}
{"func": "static void pcfwaddpflashdrv(void) { QemuOpts *opts; QEMUMachine *machine; char *filename; if (biosname == NULL) { biosname = BIOSFILENAME; } filename = qemufindfile(QEMUFILETYPEBIOS, biosname); opts = driveadd(IFPFLASH, -1, filename, \"readonly=on\"); gfree(filename); if (opts == NULL) { return; } machine = finddefaultmachine(); if (machine == NULL) { return; } driveinit(opts, machine->usescsi); } ", "target": 1}
{"func": "void ffafqueueremove(AudioFrameQueue *afq, int nbsamples, int64t *pts, int *duration) { int64t outpts = AVNOPTSVALUE; int removedsamples = 0; #ifdef DEBUG ffafqueuelogstate(afq); #endif /* get output pts from the next frame or generated pts */ if (afq->framequeue) { if (afq->framequeue->pts != AVNOPTSVALUE) outpts = afq->framequeue->pts - afq->remainingdelay; } else { if (afq->nextpts != AVNOPTSVALUE) outpts = afq->nextpts - afq->remainingdelay; } if (pts) { if (outpts != AVNOPTSVALUE) *pts = ffsamplestotimebase(afq->avctx, outpts); else *pts = AVNOPTSVALUE; } /* if the delay is larger than the packet duration, we use up delay samples for the output packet and leave all frames in the queue */ if (afq->remainingdelay >= nbsamples) { removedsamples += nbsamples; afq->remainingdelay -= nbsamples; } /* remove frames from the queue until we have enough to cover the requested number of samples or until the queue is empty */ while (removedsamples < nbsamples && afq->framequeue) { removedsamples += afq->framequeue->duration; deletenextframe(afq); } afq->remainingsamples -= removedsamples; /* if there are no frames left and we have room for more samples, use any remaining delay samples */ if (removedsamples < nbsamples && afq->remainingsamples > 0) { int addsamples = FFMIN(afq->remainingsamples, nbsamples - removedsamples); removedsamples += addsamples; afq->remainingsamples -= addsamples; } if (removedsamples > nbsamples) avlog(afq->avctx, AVLOGWARNING, \"framesize is too large\\n\"); if (duration) *duration = ffsamplestotimebase(afq->avctx, removedsamples); } ", "target": 0}
{"func": "void streamstart(BlockDriverState *bs, BlockDriverState *base, const char *baseid, int64t speed, BlockDriverCompletionFunc *cb, void *opaque, Error **errp) { StreamBlockJob *s; Coroutine *co; s = blockjobcreate(&streamjobtype, bs, speed, cb, opaque, errp); if (!s) { return; } s->base = base; if (baseid) { pstrcpy(s->backingfileid, sizeof(s->backingfileid), baseid); } co = qemucoroutinecreate(streamrun); tracestreamstart(bs, base, s, co, opaque); qemucoroutineenter(co, s); } ", "target": 1}
{"func": "static double getdifflimitedq(MpegEncContext *s, RateControlEntry *rce, double q){ RateControlContext *rcc= &s->rccontext; AVCodecContext *a= s->avctx; const int picttype= rce->newpicttype; const double lastpq = rcc->lastqscalefor[PTYPE]; const double lastnonbq= rcc->lastqscalefor[rcc->lastnonbpicttype]; if (picttype==ITYPE && (a->iquantfactor>0.0 || rcc->lastnonbpicttype==PTYPE)) q= lastpq *FFABS(a->iquantfactor) + a->iquantoffset; else if(picttype==BTYPE && a->bquantfactor>0.0) q= lastnonbq* a->bquantfactor + a->bquantoffset; /* last qscale / qdiff stuff */ if(rcc->lastnonbpicttype==picttype || picttype!=ITYPE){ double lastq= rcc->lastqscalefor[picttype]; const int maxdiff= FFQP2LAMBDA * a->maxqdiff; if (q > lastq + maxdiff) q= lastq + maxdiff; else if(q < lastq - maxdiff) q= lastq - maxdiff; } rcc->lastqscalefor[picttype]= q; //Note we cannot do that after blurring if(picttype!=BTYPE) rcc->lastnonbpicttype= picttype; return q; }", "target": 1}
{"func": "static int movwritehdlrtag(AVIOContext *pb, MOVTrack *track) { const char *hdlr, *descr = NULL, *hdlrtype = NULL; int64t pos = aviotell(pb); if (!track) { /* no media --> data handler */ hdlr = \"dhlr\"; hdlrtype = \"url \"; descr = \"DataHandler\"; } else { hdlr = (track->mode == MODEMOV) ? \"mhlr\" : \"\\0\\0\\0\\0\"; if (track->enc->codectype == AVMEDIATYPEVIDEO) { hdlrtype = \"vide\"; descr = \"VideoHandler\"; } else if (track->enc->codectype == AVMEDIATYPEAUDIO) { hdlrtype = \"soun\"; descr = \"SoundHandler\"; } else if (track->enc->codectype == AVMEDIATYPESUBTITLE) { if (track->tag == MKTAG('t','x','3','g')) hdlrtype = \"sbtl\"; else hdlrtype = \"text\"; descr = \"SubtitleHandler\"; } else if (track->enc->codectag == MKTAG('r','t','p',' ')) { hdlrtype = \"hint\"; descr = \"HintHandler\"; } } aviowb32(pb, 0); /* size */ ffiowfourcc(pb, \"hdlr\"); aviowb32(pb, 0); /* Version & flags */ aviowrite(pb, hdlr, 4); /* handler */ ffiowfourcc(pb, hdlrtype); /* handler type */ aviowb32(pb, 0); /* reserved */ aviowb32(pb, 0); /* reserved */ aviowb32(pb, 0); /* reserved */ if (!track || track->mode == MODEMOV) aviow8(pb, strlen(descr)); /* pascal string */ aviowrite(pb, descr, strlen(descr)); /* handler description */ if (track && track->mode != MODEMOV) aviow8(pb, 0); /* c string */ return updatesize(pb, pos); } ", "target": 0}
{"func": "PPCOP(srawi) { T1 = T0; T0 = (Ts0 >> PARAM(1)); if (Ts1 < 0 && (Ts1 & PARAM(2)) != 0) { xerca = 1; } else { xerca = 0; } RETURN(); } ", "target": 1}
{"func": "void traceinitfile(const char *file) { #ifdef CONFIGTRACESIMPLE stsettracefile(file); #elif defined CONFIGTRACELOG /* If both the simple and the log backends are enabled, \"-trace file\" * only applies to the simple backend; use \"-D\" for the log backend. */ if (file) { qemusetlogfilename(file); } #else if (file) { fprintf(stderr, \"error: -trace file=...: \" \"option not supported by the selected tracing backends\\n\"); exit(1); } #endif } ", "target": 1}
{"func": "static int srtprobe(AVProbeData *p) { const unsigned char *ptr = p->buf; int i, v, num = 0; if (AVRB24(ptr) == 0xEFBBBF) ptr += 3; /* skip UTF-8 BOM */ while (*ptr == '\\r' || *ptr == '\\n') ptr++; for (i=0; i<2; i++) { if ((num == i || num + 1 == i) && sscanf(ptr, \"%*d:%*2d:%*2d%*1[,.]%*3d --> %*d:%*2d:%*2d%*1[,.]%3d\", &v) == 1) return AVPROBESCOREMAX; num = atoi(ptr); ptr += strcspn(ptr, \"\\n\") + 1; } return 0; } ", "target": 1}
{"func": "static void piix4updatehotplug(PIIX4PMState *s) { PCIDevice *dev = &s->dev; BusState *bus = qdevgetparentbus(&dev->qdev); DeviceState *qdev, *next; s->pci0hotplugenable = ~0; QTAILQFOREACHSAFE(qdev, &bus->children, sibling, next) { PCIDevice *pdev = PCIDEVICE(qdev); PCIDeviceClass *pc = PCIDEVICEGETCLASS(pdev); int slot = PCISLOT(pdev->devfn); if (pc->nohotplug) { s->pci0hotplugenable &= ~(1 << slot); } } } ", "target": 1}
{"func": "static void streamsetspeed(BlockJob *job, int64t speed, Error **errp) { StreamBlockJob *s = containerof(job, StreamBlockJob, common); if (speed < 0) { errorsetg(errp, QERRINVALIDPARAMETER, \"speed\"); return; } ratelimitsetspeed(&s->limit, speed / BDRVSECTORSIZE, SLICETIME); } ", "target": 1}
{"func": "static avcold int dnxhddecodeclose(AVCodecContext *avctx) { DNXHDContext *ctx = avctx->privdata; fffreevlc(&ctx->acvlc); fffreevlc(&ctx->dcvlc); fffreevlc(&ctx->runvlc); avfreep(&ctx->mbscanindex); avfreep(&ctx->rows); return 0; } ", "target": 1}
{"func": "int unixstartincomingmigration(const char *path) { struct sockaddrun un; int sock; dprintf(\"Attempting to start an incoming migration\\n\"); sock = socket(PFUNIX, SOCKSTREAM, 0); if (sock < 0) { fprintf(stderr, \"Could not open unix socket: %s\\n\", strerror(errno)); return -EINVAL; } memset(&un, 0, sizeof(un)); un.sunfamily = AFUNIX; snprintf(un.sunpath, sizeof(un.sunpath), \"%s\", path); unlink(un.sunpath); if (bind(sock, (struct sockaddr*) &un, sizeof(un)) < 0) { fprintf(stderr, \"bind(unix:%s): %s\\n\", un.sunpath, strerror(errno)); goto err; } if (listen(sock, 1) < 0) { fprintf(stderr, \"listen(unix:%s): %s\\n\", un.sunpath, strerror(errno)); goto err; } qemusetfdhandler2(sock, NULL, unixacceptincomingmigration, NULL, \t\t\t (void *)(unsigned long)sock); return 0; err: close(sock); return -EINVAL; } ", "target": 1}
{"func": "void bdrvrefreshlimits(BlockDriverState *bs, Error **errp) { BlockDriver *drv = bs->drv; Error *localerr = NULL; memset(&bs->bl, 0, sizeof(bs->bl)); if (!drv) { return; } /* Default alignment based on whether driver has byte interface */ bs->requestalignment = drv->bdrvcopreadv ? 1 : 512; /* Take some limits from the children as a default */ if (bs->file) { bdrvrefreshlimits(bs->file->bs, &localerr); if (localerr) { errorpropagate(errp, localerr); return; } bs->bl.opttransfer = bs->file->bs->bl.opttransfer; bs->bl.maxtransfer = bs->file->bs->bl.maxtransfer; bs->bl.minmemalignment = bs->file->bs->bl.minmemalignment; bs->bl.optmemalignment = bs->file->bs->bl.optmemalignment; bs->bl.maxiov = bs->file->bs->bl.maxiov; } else { bs->bl.minmemalignment = 512; bs->bl.optmemalignment = getpagesize(); /* Safe default since most protocols use readv()/writev()/etc */ bs->bl.maxiov = IOVMAX; } if (bs->backing) { bdrvrefreshlimits(bs->backing->bs, &localerr); if (localerr) { errorpropagate(errp, localerr); return; } bs->bl.opttransfer = MAX(bs->bl.opttransfer, bs->backing->bs->bl.opttransfer); bs->bl.maxtransfer = MINNONZERO(bs->bl.maxtransfer, bs->backing->bs->bl.maxtransfer); bs->bl.optmemalignment = MAX(bs->bl.optmemalignment, bs->backing->bs->bl.optmemalignment); bs->bl.minmemalignment = MAX(bs->bl.minmemalignment, bs->backing->bs->bl.minmemalignment); bs->bl.maxiov = MIN(bs->bl.maxiov, bs->backing->bs->bl.maxiov); } /* Then let the driver override it */ if (drv->bdrvrefreshlimits) { drv->bdrvrefreshlimits(bs, errp); } } ", "target": 0}
{"func": "static int checkrefblocks(BlockDriverState *bs, BdrvCheckResult *res, BdrvCheckMode fix, bool *rebuild, void **refcounttable, int64t *nbclusters) { BDRVQcow2State *s = bs->opaque; int64t i, size; int ret; for(i = 0; i < s->refcounttablesize; i++) { uint64t offset, cluster; offset = s->refcounttable[i]; cluster = offset >> s->clusterbits; /* Refcount blocks are cluster aligned */ if (offsetintocluster(s, offset)) { fprintf(stderr, \"ERROR refcount block %\" PRId64 \" is not \" \"cluster aligned; refcount table entry corrupted\\n\", i); res->corruptions++; *rebuild = true; continue; } if (cluster >= *nbclusters) { fprintf(stderr, \"%s refcount block %\" PRId64 \" is outside image\\n\", fix & BDRVFIXERRORS ? \"Repairing\" : \"ERROR\", i); if (fix & BDRVFIXERRORS) { int64t newnbclusters; Error *localerr = NULL; if (offset > INT64MAX - s->clustersize) { ret = -EINVAL; goto resizefail; } ret = bdrvtruncate(bs->file, offset + s->clustersize, &localerr); if (ret < 0) { errorreporterr(localerr); goto resizefail; } size = bdrvgetlength(bs->file->bs); if (size < 0) { ret = size; goto resizefail; } newnbclusters = sizetoclusters(s, size); assert(newnbclusters >= *nbclusters); ret = reallocrefcountarray(s, refcounttable, nbclusters, newnbclusters); if (ret < 0) { res->checkerrors++; return ret; } if (cluster >= *nbclusters) { ret = -EINVAL; goto resizefail; } res->corruptionsfixed++; ret = increfcounts(bs, res, refcounttable, nbclusters, offset, s->clustersize); if (ret < 0) { return ret; } /* No need to check whether the refcount is now greater than 1: * This area was just allocated and zeroed, so it can only be * exactly 1 after increfcounts() */ continue; resizefail: res->corruptions++; *rebuild = true; fprintf(stderr, \"ERROR could not resize image: %s\\n\", strerror(-ret)); } else { res->corruptions++; } continue; } if (offset != 0) { ret = increfcounts(bs, res, refcounttable, nbclusters, offset, s->clustersize); if (ret < 0) { return ret; } if (s->getrefcount(*refcounttable, cluster) != 1) { fprintf(stderr, \"ERROR refcount block %\" PRId64 \" refcount=%\" PRIu64 \"\\n\", i, s->getrefcount(*refcounttable, cluster)); res->corruptions++; *rebuild = true; } } } return 0; } ", "target": 0}
{"func": "DriveInfo *driveinit(QemuOpts *opts, BlockInterfaceType blockdefaulttype) { const char *buf; const char *file = NULL; const char *serial; const char *mediastr = \"\"; BlockInterfaceType type; enum { MEDIADISK, MEDIACDROM } media; int busid, unitid; int cyls, heads, secs, translation; BlockDriver *drv = NULL; int maxdevs; int index; int ro = 0; int bdrvflags = 0; int onreaderror, onwriteerror; const char *devaddr; DriveInfo *dinfo; BlockIOLimit iolimits; int snapshot = 0; bool copyonread; int ret; Error *error = NULL; translation = BIOSATATRANSLATIONAUTO; media = MEDIADISK; /* extract parameters */ busid = qemuoptgetnumber(opts, \"bus\", 0); unitid = qemuoptgetnumber(opts, \"unit\", -1); index = qemuoptgetnumber(opts, \"index\", -1); cyls = qemuoptgetnumber(opts, \"cyls\", 0); heads = qemuoptgetnumber(opts, \"heads\", 0); secs = qemuoptgetnumber(opts, \"secs\", 0); snapshot = qemuoptgetbool(opts, \"snapshot\", 0); ro = qemuoptgetbool(opts, \"readonly\", 0); copyonread = qemuoptgetbool(opts, \"copy-on-read\", false); file = qemuoptget(opts, \"file\"); serial = qemuoptget(opts, \"serial\"); if ((buf = qemuoptget(opts, \"if\")) != NULL) { for (type = 0; type < IFCOUNT && strcmp(buf, ifname[type]); type++) ; if (type == IFCOUNT) { errorreport(\"unsupported bus type '%s'\", buf); return NULL; \t} } else { type = blockdefaulttype; } maxdevs = ifmaxdevs[type]; if (cyls || heads || secs) { if (cyls < 1) { errorreport(\"invalid physical cyls number\"); \t return NULL; \t} if (heads < 1) { errorreport(\"invalid physical heads number\"); \t return NULL; \t} if (secs < 1) { errorreport(\"invalid physical secs number\"); \t return NULL; \t} } if ((buf = qemuoptget(opts, \"trans\")) != NULL) { if (!cyls) { errorreport(\"'%s' trans must be used with cyls, heads and secs\", buf); return NULL; } if (!strcmp(buf, \"none\")) translation = BIOSATATRANSLATIONNONE; else if (!strcmp(buf, \"lba\")) translation = BIOSATATRANSLATIONLBA; else if (!strcmp(buf, \"auto\")) translation = BIOSATATRANSLATIONAUTO; \telse { errorreport(\"'%s' invalid translation type\", buf); \t return NULL; \t} } if ((buf = qemuoptget(opts, \"media\")) != NULL) { if (!strcmp(buf, \"disk\")) { \t media = MEDIADISK; \t} else if (!strcmp(buf, \"cdrom\")) { if (cyls || secs || heads) { errorreport(\"CHS can't be set with media=%s\", buf); \t return NULL; } \t media = MEDIACDROM; \t} else { \t errorreport(\"'%s' invalid media\", buf); \t return NULL; \t} } if ((buf = qemuoptget(opts, \"discard\")) != NULL) { if (bdrvparsediscardflags(buf, &bdrvflags) != 0) { errorreport(\"invalid discard option\"); return NULL; } } bdrvflags |= BDRVOCACHEWB; if ((buf = qemuoptget(opts, \"cache\")) != NULL) { if (bdrvparsecacheflags(buf, &bdrvflags) != 0) { errorreport(\"invalid cache option\"); return NULL; } } #ifdef CONFIGLINUXAIO if ((buf = qemuoptget(opts, \"aio\")) != NULL) { if (!strcmp(buf, \"native\")) { bdrvflags |= BDRVONATIVEAIO; } else if (!strcmp(buf, \"threads\")) { /* this is the default */ } else { errorreport(\"invalid aio option\"); return NULL; } } #endif if ((buf = qemuoptget(opts, \"format\")) != NULL) { if (ishelpoption(buf)) { errorprintf(\"Supported formats:\"); bdrviterateformat(bdrvformatprint, NULL); errorprintf(\"\\n\"); return NULL; } drv = bdrvfindwhitelistedformat(buf); if (!drv) { errorreport(\"'%s' invalid format\", buf); return NULL; } } /* disk I/O throttling */ iolimits.bps[BLOCKIOLIMITTOTAL] = qemuoptgetnumber(opts, \"bps\", 0); iolimits.bps[BLOCKIOLIMITREAD] = qemuoptgetnumber(opts, \"bpsrd\", 0); iolimits.bps[BLOCKIOLIMITWRITE] = qemuoptgetnumber(opts, \"bpswr\", 0); iolimits.iops[BLOCKIOLIMITTOTAL] = qemuoptgetnumber(opts, \"iops\", 0); iolimits.iops[BLOCKIOLIMITREAD] = qemuoptgetnumber(opts, \"iopsrd\", 0); iolimits.iops[BLOCKIOLIMITWRITE] = qemuoptgetnumber(opts, \"iopswr\", 0); if (!docheckiolimits(&iolimits, &error)) { errorreport(\"%s\", errorgetpretty(error)); errorfree(error); return NULL; } if (qemuoptget(opts, \"boot\") != NULL) { fprintf(stderr, \"qemu-kvm: boot=on|off is deprecated and will be \" \"ignored. Future versions will reject this parameter. Please \" \"update your scripts.\\n\"); } onwriteerror = BLOCKDEVONERRORENOSPC; if ((buf = qemuoptget(opts, \"werror\")) != NULL) { if (type != IFIDE && type != IFSCSI && type != IFVIRTIO && type != IFNONE) { errorreport(\"werror is not supported by this bus type\"); return NULL; } onwriteerror = parseblockerroraction(buf, 0); if (onwriteerror < 0) { return NULL; } } onreaderror = BLOCKDEVONERRORREPORT; if ((buf = qemuoptget(opts, \"rerror\")) != NULL) { if (type != IFIDE && type != IFVIRTIO && type != IFSCSI && type != IFNONE) { errorreport(\"rerror is not supported by this bus type\"); return NULL; } onreaderror = parseblockerroraction(buf, 1); if (onreaderror < 0) { return NULL; } } if ((devaddr = qemuoptget(opts, \"addr\")) != NULL) { if (type != IFVIRTIO) { errorreport(\"addr is not supported by this bus type\"); return NULL; } } /* compute bus and unit according index */ if (index != -1) { if (busid != 0 || unitid != -1) { errorreport(\"index cannot be used with bus and unit\"); return NULL; } busid = driveindextobusid(type, index); unitid = driveindextounitid(type, index); } /* if user doesn't specify a unitid, * try to find the first free */ if (unitid == -1) { unitid = 0; while (driveget(type, busid, unitid) != NULL) { unitid++; if (maxdevs && unitid >= maxdevs) { unitid -= maxdevs; busid++; } } } /* check unit id */ if (maxdevs && unitid >= maxdevs) { errorreport(\"unit %d too big (max is %d)\", unitid, maxdevs - 1); return NULL; } /* * catch multiple definitions */ if (driveget(type, busid, unitid) != NULL) { errorreport(\"drive with bus=%d, unit=%d (index=%d) exists\", busid, unitid, index); return NULL; } /* init */ dinfo = gmalloc0(sizeof(*dinfo)); if ((buf = qemuoptsid(opts)) != NULL) { dinfo->id = gstrdup(buf); } else { /* no id supplied -> create one */ dinfo->id = gmalloc0(32); if (type == IFIDE || type == IFSCSI) mediastr = (media == MEDIACDROM) ? \"-cd\" : \"-hd\"; if (maxdevs) snprintf(dinfo->id, 32, \"%s%i%s%i\", ifname[type], busid, mediastr, unitid); else snprintf(dinfo->id, 32, \"%s%s%i\", ifname[type], mediastr, unitid); } dinfo->bdrv = bdrvnew(dinfo->id); dinfo->bdrv->openflags = snapshot ? BDRVOSNAPSHOT : 0; dinfo->bdrv->readonly = ro; dinfo->devaddr = devaddr; dinfo->type = type; dinfo->bus = busid; dinfo->unit = unitid; dinfo->cyls = cyls; dinfo->heads = heads; dinfo->secs = secs; dinfo->trans = translation; dinfo->opts = opts; dinfo->refcount = 1; dinfo->serial = serial; QTAILQINSERTTAIL(&drives, dinfo, next); bdrvsetonerror(dinfo->bdrv, onreaderror, onwriteerror); /* disk I/O throttling */ bdrvsetiolimits(dinfo->bdrv, &iolimits); switch(type) { case IFIDE: case IFSCSI: case IFXEN: case IFNONE: dinfo->mediacd = media == MEDIACDROM; break; case IFSD: case IFFLOPPY: case IFPFLASH: case IFMTD: break; case IFVIRTIO: /* add virtio block device */ opts = qemuoptscreatenofail(qemufindopts(\"device\")); if (archtype == QEMUARCHS390X) { qemuoptset(opts, \"driver\", \"virtio-blk-s390\"); } else { qemuoptset(opts, \"driver\", \"virtio-blk-pci\"); } qemuoptset(opts, \"drive\", dinfo->id); if (devaddr) qemuoptset(opts, \"addr\", devaddr); break; default: abort(); } if (!file || !*file) { return dinfo; } if (snapshot) { /* always use cache=unsafe with snapshot */ bdrvflags &= ~BDRVOCACHEMASK; bdrvflags |= (BDRVOSNAPSHOT|BDRVOCACHEWB|BDRVONOFLUSH); } if (copyonread) { bdrvflags |= BDRVOCOPYONREAD; } if (runstatecheck(RUNSTATEINMIGRATE)) { bdrvflags |= BDRVOINCOMING; } if (media == MEDIACDROM) { /* CDROM is fine for any interface, don't check. */ ro = 1; } else if (ro == 1) { if (type != IFSCSI && type != IFVIRTIO && type != IFFLOPPY && type != IFNONE && type != IFPFLASH) { errorreport(\"readonly not supported by this bus type\"); goto err; } } bdrvflags |= ro ? 0 : BDRVORDWR; if (ro && copyonread) { errorreport(\"warning: disabling copyonread on readonly drive\"); } ret = bdrvopen(dinfo->bdrv, file, NULL, bdrvflags, drv); if (ret < 0) { if (ret == -EMEDIUMTYPE) { errorreport(\"could not open disk image %s: not in %s format\", file, drv->formatname); } else { errorreport(\"could not open disk image %s: %s\", file, strerror(-ret)); } goto err; } if (bdrvkeyrequired(dinfo->bdrv)) autostart = 0; return dinfo; err: bdrvdelete(dinfo->bdrv); gfree(dinfo->id); QTAILQREMOVE(&drives, dinfo, next); gfree(dinfo); return NULL; } ", "target": 1}
{"func": "static const char *keyvalparseone(QDict *qdict, const char *params, const char *impliedkey, Error **errp) { const char *key, *keyend, *s; sizet len; char keyincur[128]; QDict *cur; int ret; QObject *next; QString *val; key = params; len = strcspn(params, \"=,\"); if (impliedkey && len && key[len] != '=') { /* Desugar implied key */ key = impliedkey; len = strlen(impliedkey); } keyend = key + len; /* * Loop over key fragments: @s points to current fragment, it * applies to @cur. @keyincur[] holds the previous fragment. */ cur = qdict; s = key; for (;;) { ret = parseqapiname(s, false); len = ret < 0 ? 0 : ret; assert(s + len <= keyend); if (!len || (s + len < keyend && s[len] != '.')) { assert(key != impliedkey); errorsetg(errp, \"Invalid parameter '%.*s'\", (int)(keyend - key), key); return NULL; } if (len >= sizeof(keyincur)) { assert(key != impliedkey); errorsetg(errp, \"Parameter%s '%.*s' is too long\", s != key || s + len != keyend ? \" fragment\" : \"\", (int)len, s); return NULL; } if (s != key) { next = keyvalparseput(cur, keyincur, NULL, key, s - 1, errp); if (!next) { return NULL; } cur = qobjecttoqdict(next); assert(cur); } memcpy(keyincur, s, len); keyincur[len] = 0; s += len; if (*s != '.') { break; } s++; } if (key == impliedkey) { assert(!*s); s = params; } else { if (*s != '=') { errorsetg(errp, \"Expected '=' after parameter '%.*s'\", (int)(s - key), key); return NULL; } s++; } val = qstringnew(); for (;;) { if (!*s) { break; } else if (*s == ',') { s++; if (*s != ',') { break; } } qstringappendchr(val, *s++); } if (!keyvalparseput(cur, keyincur, val, key, keyend, errp)) { return NULL; } return s; } ", "target": 1}
{"func": "static void mdcttest(AC3MDCTContext *mdct, AVLFG *lfg) { int16t input[MDCTSAMPLES]; int32t output[AC3MAXCOEFS]; float input1[MDCTSAMPLES]; float output1[AC3MAXCOEFS]; float s, a, err, e, emax; int i, k, n; for (i = 0; i < MDCTSAMPLES; i++) { input[i] = (avlfgget(lfg) % 65535 - 32767) * 9 / 10; input1[i] = input[i]; } mdct512(mdct, output, input); /* do it by hand */ for (k = 0; k < AC3MAXCOEFS; k++) { s = 0; for (n = 0; n < MDCTSAMPLES; n++) { a = (2*MPI*(2*n+1+MDCTSAMPLES/2)*(2*k+1) / (4 * MDCTSAMPLES)); s += input1[n] * cos(a); } output1[k] = -2 * s / MDCTSAMPLES; } err = 0; emax = 0; for (i = 0; i < AC3MAXCOEFS; i++) { avlog(NULL, AVLOGDEBUG, \"%3d: %7d %7.0f\\n\", i, output[i], output1[i]); e = output[i] - output1[i]; if (e > emax) emax = e; err += e * e; } avlog(NULL, AVLOGDEBUG, \"err2=%f emax=%f\\n\", err / AC3MAXCOEFS, emax); } ", "target": 0}
{"func": "static AVRational updatesar(int oldw, int oldh, AVRational sar, int neww, int newh) { // attempt to keep aspect during typical resolution switches if (!sar.num) sar = (AVRational){1, 1}; sar = avmulq(sar, (AVRational){newh * oldw, neww * oldh}); return sar; } ", "target": 1}
{"func": "static uint32t qpcipcconfigreadl(QPCIBus *bus, int devfn, uint8t offset) { outl(0xcf8, (1 << 31) | (devfn << 8) | offset); return inl(0xcfc); } ", "target": 1}
{"func": "static int decodeblock(BinkAudioContext *s, float **out, int usedct) { int ch, i, j, k; float q, quant[25]; int width, coeff; GetBitContext *gb = &s->gb; if (usedct) skipbits(gb, 2); for (ch = 0; ch < s->channels; ch++) { FFTSample *coeffs = out[ch]; if (s->versionb) { if (getbitsleft(gb) < 64) return AVERRORINVALIDDATA; coeffs[0] = avint2float(getbitslong(gb, 32)) * s->root; coeffs[1] = avint2float(getbitslong(gb, 32)) * s->root; } else { if (getbitsleft(gb) < 58) return AVERRORINVALIDDATA; coeffs[0] = getfloat(gb) * s->root; coeffs[1] = getfloat(gb) * s->root; } if (getbitsleft(gb) < s->numbands * 8) return AVERRORINVALIDDATA; for (i = 0; i < s->numbands; i++) { int value = getbits(gb, 8); quant[i] = quanttable[FFMIN(value, 95)]; } k = 0; q = quant[0]; // parse coefficients i = 2; while (i < s->framelen) { if (s->versionb) { j = i + 16; } else { int v; GETBITSSAFE(v, 1); if (v) { GETBITSSAFE(v, 4); j = i + rlelengthtab[v] * 8; } else { j = i + 8; } } j = FFMIN(j, s->framelen); GETBITSSAFE(width, 4); if (width == 0) { memset(coeffs + i, 0, (j - i) * sizeof(*coeffs)); i = j; while (s->bands[k] < i) q = quant[k++]; } else { while (i < j) { if (s->bands[k] == i) q = quant[k++]; GETBITSSAFE(coeff, width); if (coeff) { int v; GETBITSSAFE(v, 1); if (v) coeffs[i] = -q * coeff; else coeffs[i] = q * coeff; } else { coeffs[i] = 0.0f; } i++; } } } if (CONFIGBINKAUDIODCTDECODER && usedct) { coeffs[0] /= 0.5; s->trans.dct.dctcalc(&s->trans.dct, coeffs); } else if (CONFIGBINKAUDIORDFTDECODER) s->trans.rdft.rdftcalc(&s->trans.rdft, coeffs); } for (ch = 0; ch < s->channels; ch++) { int j; int count = s->overlaplen * s->channels; if (!s->first) { j = ch; for (i = 0; i < s->overlaplen; i++, j += s->channels) out[ch][i] = (s->previous[ch][i] * (count - j) + out[ch][i] * j) / count; } memcpy(s->previous[ch], &out[ch][s->framelen - s->overlaplen], s->overlaplen * sizeof(*s->previous[ch])); } s->first = 0; return 0; } ", "target": 1}
{"func": "static int loadnormalreset(S390CPU *cpu) { S390CPUClass *scc = S390CPUGETCLASS(cpu); pauseallvcpus(); cpusynchronizeallstates(); cpuresetall(); iosubsystemreset(); scc->initialcpureset(CPU(cpu)); scc->loadnormal(CPU(cpu)); cpusynchronizeallpostreset(); resumeallvcpus(); return 0; }", "target": 1}
{"func": "static void v9fspostlcreate(V9fsState *s, V9fsLcreateState *vs, int err) { if (err == 0) { v9fsstringcopy(&vs->fidp->path, &vs->fullname); stattoqid(&vs->stbuf, &vs->qid); vs->offset += pdumarshal(vs->pdu, vs->offset, \"Qd\", &vs->qid, &vs->iounit); err = vs->offset; } else { vs->fidp->fidtype = P9FIDNONE; close(vs->fidp->fs.fd); err = -errno; } completepdu(s, vs->pdu, err); v9fsstringfree(&vs->name); v9fsstringfree(&vs->fullname); qemufree(vs); } ", "target": 1}
{"func": "static void getxbzrlecachestats(MigrationInfo *info) { if (migrateusexbzrle()) { info->hasxbzrlecache = true; info->xbzrlecache = gmalloc0(sizeof(*info->xbzrlecache)); info->xbzrlecache->cachesize = migratexbzrlecachesize(); info->xbzrlecache->bytes = xbzrlemigbytestransferred(); info->xbzrlecache->pages = xbzrlemigpagestransferred(); info->xbzrlecache->cachemiss = xbzrlemigpagescachemiss(); info->xbzrlecache->cachemissrate = xbzrlemigcachemissrate(); info->xbzrlecache->overflow = xbzrlemigpagesoverflow(); } } ", "target": 1}
{"func": "static PowerPCCPU *ppc440initxilinx(ramaddrt *ramsize, int doinit, const char *cpumodel, uint32t sysclk) { PowerPCCPU *cpu; CPUPPCState *env; qemuirq *irqs; cpu = POWERPCCPU(cpugenericinit(TYPEPOWERPCCPU, cpumodel)); if (cpu == NULL) { fprintf(stderr, \"Unable to initialize CPU!\\n\"); exit(1); } env = &cpu->env; ppcbooketimersinit(cpu, sysclk, 0/* no flags */); ppcdcrinit(env, NULL, NULL); /* interrupt controller */ irqs = gmalloc0(sizeof(qemuirq) * PPCUICOUTPUTNB); irqs[PPCUICOUTPUTINT] = ((qemuirq *)env->irqinputs)[PPC40xINPUTINT]; irqs[PPCUICOUTPUTCINT] = ((qemuirq *)env->irqinputs)[PPC40xINPUTCINT]; ppcuicinit(env, irqs, 0x0C0, 0, 1); return cpu; } ", "target": 1}
{"func": "static void createdefaultqtables(uint8t *qtables, uint8t q) { int factor = q; int i; factor = avclip(q, 1, 99); if (q < 50) q = 5000 / factor; else q = 200 - factor * 2; for (i = 0; i < 128; i++) { int val = (defaultquantizers[i] * q + 50) / 100; /* Limit the quantizers to 1 <= q <= 255. */ val = avclip(val, 1, 255); qtables[i] = val; } } ", "target": 1}
{"func": "void ffafqueueclose(AudioFrameQueue *afq) { /* remove/free any remaining frames */ while (afq->framequeue) deletenextframe(afq); memset(afq, 0, sizeof(*afq)); } ", "target": 0}
{"func": "static void lumRangeToJpeg16c(int16t *dst, int width) { int i; int32t *dst = (int32t *) dst; for (i = 0; i < width; i++) dst[i] = (FFMIN(dst[i],30189<<4)*19077 - (39057361<<4))>>14; } ", "target": 1}
{"func": "static void fillcodingmethodarray(sbint8array tonelevelidx, sbint8array tonelevelidxtemp, sbint8array codingmethod, int nbchannels, int c, int superblocktype23, int cmtableselect) { int ch, sb, j; int tmp, acc, esp40, comp; int add1, add2, add3, add4; int64t multres; if (!superblocktype23) { /* This case is untested, no samples available */ SAMPLESNEEDED for (ch = 0; ch < nbchannels; ch++) for (sb = 0; sb < 30; sb++) { for (j = 1; j < 63; j++) { // The loop only iterates to 63 so the code doesn't overflow the buffer add1 = tonelevelidx[ch][sb][j] - 10; if (add1 < 0) add1 = 0; add2 = add3 = add4 = 0; if (sb > 1) { add2 = tonelevelidx[ch][sb - 2][j] + tonelevelidxoffsettable[sb][0] - 6; if (add2 < 0) add2 = 0; } if (sb > 0) { add3 = tonelevelidx[ch][sb - 1][j] + tonelevelidxoffsettable[sb][1] - 6; if (add3 < 0) add3 = 0; } if (sb < 29) { add4 = tonelevelidx[ch][sb + 1][j] + tonelevelidxoffsettable[sb][3] - 6; if (add4 < 0) add4 = 0; } tmp = tonelevelidx[ch][sb][j + 1] * 2 - add4 - add3 - add2 - add1; if (tmp < 0) tmp = 0; tonelevelidxtemp[ch][sb][j + 1] = tmp & 0xff; } tonelevelidxtemp[ch][sb][0] = tonelevelidxtemp[ch][sb][1]; } acc = 0; for (ch = 0; ch < nbchannels; ch++) for (sb = 0; sb < 30; sb++) for (j = 0; j < 64; j++) acc += tonelevelidxtemp[ch][sb][j]; multres = 0x66666667 * (acc * 10); esp40 = (multres >> 32) / 8 + ((multres & 0xffffffff) >> 31); for (ch = 0; ch < nbchannels; ch++) for (sb = 0; sb < 30; sb++) for (j = 0; j < 64; j++) { comp = tonelevelidxtemp[ch][sb][j]* esp40 * 10; if (comp < 0) comp += 0xff; comp /= 256; // signed shift switch(sb) { case 0: if (comp < 30) comp = 30; comp += 15; break; case 1: if (comp < 24) comp = 24; comp += 10; break; case 2: case 3: case 4: if (comp < 16) comp = 16; } if (comp <= 5) tmp = 0; else if (comp <= 10) tmp = 10; else if (comp <= 16) tmp = 16; else if (comp <= 24) tmp = -1; else tmp = 0; codingmethod[ch][sb][j] = ((tmp & 0xfffa) + 30 )& 0xff; } for (sb = 0; sb < 30; sb++) fixcodingmethodarray(sb, nbchannels, codingmethod); for (ch = 0; ch < nbchannels; ch++) for (sb = 0; sb < 30; sb++) for (j = 0; j < 64; j++) if (sb >= 10) { if (codingmethod[ch][sb][j] < 10) codingmethod[ch][sb][j] = 10; } else { if (sb >= 2) { if (codingmethod[ch][sb][j] < 16) codingmethod[ch][sb][j] = 16; } else { if (codingmethod[ch][sb][j] < 30) codingmethod[ch][sb][j] = 30; } } } else { // superblocktype23 != 0 for (ch = 0; ch < nbchannels; ch++) for (sb = 0; sb < 30; sb++) for (j = 0; j < 64; j++) codingmethod[ch][sb][j] = codingmethodtable[cmtableselect][sb]; } } ", "target": 1}
{"func": "static void findmotion(DeshakeContext *deshake, uint8t *src1, uint8t *src2, int width, int height, int stride, Transform *t) { int x, y; IntMotionVector mv = {0, 0}; int counts[128][128]; int countmaxvalue = 0; int contrast; int pos; double *angles = avmalloc(sizeof(*angles) * width * height / (16 * deshake->blocksize)); int centerx = 0, centery = 0; double px, py; // Reset counts to zero for (x = 0; x < deshake->rx * 2 + 1; x++) { for (y = 0; y < deshake->ry * 2 + 1; y++) { counts[x][y] = 0; } } pos = 0; // Find motion for every block and store the motion vector in the counts for (y = deshake->ry; y < height - deshake->ry - (deshake->blocksize * 2); y += deshake->blocksize * 2) { // We use a width of 16 here to match the libavcodec sad functions for (x = deshake->rx; x < width - deshake->rx - 16; x += 16) { // If the contrast is too low, just skip this block as it probably // won't be very useful to us. contrast = blockcontrast(src2, x, y, stride, deshake->blocksize); if (contrast > deshake->contrast) { //avlog(NULL, AVLOGERROR, \"%d\\n\", contrast); findblockmotion(deshake, src1, src2, x, y, stride, &mv); if (mv.x != -1 && mv.y != -1) { counts[mv.x + deshake->rx][mv.y + deshake->ry] += 1; if (x > deshake->rx && y > deshake->ry) angles[pos++] = blockangle(x, y, 0, 0, &mv); centerx += mv.x; centery += mv.y; } } } } pos = FFMAX(1, pos); centerx /= pos; centery /= pos; t->angle = cleanmean(angles, pos); if (t->angle < 0.001) t->angle = 0; // Find the most common motion vector in the frame and use it as the gmv for (y = deshake->ry * 2; y >= 0; y--) { for (x = 0; x < deshake->rx * 2 + 1; x++) { //avlog(NULL, AVLOGERROR, \"%5d \", counts[x][y]); if (counts[x][y] > countmaxvalue) { t->vector.x = x - deshake->rx; t->vector.y = y - deshake->ry; countmaxvalue = counts[x][y]; } } //avlog(NULL, AVLOGERROR, \"\\n\"); } px = (centerx - width / 2); py = (centery - height / 2); t->vector.x += (cos(t->angle)-1)*px - sin(t->angle)*py; t->vector.y += sin(t->angle)*px + (cos(t->angle)-1)*py; // Clamp max shift & rotation? t->vector.x = avclipf(t->vector.x, -deshake->rx * 2, deshake->rx * 2); t->vector.y = avclipf(t->vector.y, -deshake->ry * 2, deshake->ry * 2); t->angle = avclipf(t->angle, -0.1, 0.1); //avlog(NULL, AVLOGERROR, \"%d x %d\\n\", avg->x, avg->y); avfree(angles); } ", "target": 1}
{"func": "static int diracdecodeframe(AVCodecContext *avctx, void *data, int *gotframe, AVPacket *pkt) { DiracContext *s = avctx->privdata; AVFrame *picture = data; uint8t *buf = pkt->data; int bufsize = pkt->size; int i, dataunitsize, bufidx = 0; int ret; /* release unused frames */ for (i = 0; i < MAXFRAMES; i++) if (s->allframes[i].avframe->data[0] && !s->allframes[i].avframe->reference) { avframeunref(s->allframes[i].avframe); memset(s->allframes[i].interpolated, 0, sizeof(s->allframes[i].interpolated)); } s->currentpicture = NULL; *gotframe = 0; /* end of stream, so flush delayed pics */ if (bufsize == 0) return getdelayedpic(s, (AVFrame *)data, gotframe); for (;;) { /*[DIRACSTD] Here starts the code from parseinfo() defined in 9.6 [DIRACSTD] PARSEINFOPREFIX = \"BBCD\" as defined in ISO/IEC 646 BBCD start code search */ for (; bufidx + DATAUNITHEADERSIZE < bufsize; bufidx++) { if (buf[bufidx ] == 'B' && buf[bufidx+1] == 'B' && buf[bufidx+2] == 'C' && buf[bufidx+3] == 'D') break; } /* BBCD found or end of data */ if (bufidx + DATAUNITHEADERSIZE >= bufsize) break; dataunitsize = AVRB32(buf+bufidx+5); if (bufidx + dataunitsize > bufsize || !dataunitsize) { if(bufidx + dataunitsize > bufsize) avlog(s->avctx, AVLOGERROR, \"Data unit with size %d is larger than input buffer, discarding\\n\", dataunitsize); bufidx += 4; continue; } /* [DIRACSTD] diracdecodedataunit makes reference to the while defined in 9.3 inside the function parsesequence() */ if (diracdecodedataunit(avctx, buf+bufidx, dataunitsize)) { avlog(s->avctx, AVLOGERROR,\"Error in diracdecodedataunit\\n\"); return -1; } bufidx += dataunitsize; } if (!s->currentpicture) return bufsize; if (s->currentpicture->avframe->displaypicturenumber > s->framenumber) { DiracFrame *delayedframe = removeframe(s->delayframes, s->framenumber); s->currentpicture->avframe->reference |= DELAYEDPICREF; if (addframe(s->delayframes, MAXDELAY, s->currentpicture)) { int minnum = s->delayframes[0]->avframe->displaypicturenumber; /* Too many delayed frames, so we display the frame with the lowest pts */ avlog(avctx, AVLOGERROR, \"Delay frame overflow\\n\"); for (i = 1; s->delayframes[i]; i++) if (s->delayframes[i]->avframe->displaypicturenumber < minnum) minnum = s->delayframes[i]->avframe->displaypicturenumber; delayedframe = removeframe(s->delayframes, minnum); addframe(s->delayframes, MAXDELAY, s->currentpicture); } if (delayedframe) { delayedframe->avframe->reference ^= DELAYEDPICREF; if((ret=avframeref(data, delayedframe->avframe)) < 0) return ret; *gotframe = 1; } } else if (s->currentpicture->avframe->displaypicturenumber == s->framenumber) { /* The right frame at the right time :-) */ if((ret=avframeref(data, s->currentpicture->avframe)) < 0) return ret; *gotframe = 1; } if (*gotframe) s->framenumber = picture->displaypicturenumber + 1; return bufidx; } ", "target": 1}
{"func": "static TCGv genea(CPUM68KState *env, DisasContext *s, uint16t insn, int opsize, TCGv val, TCGv *addrp, eawhat what) { TCGv reg; TCGv result; uint32t offset; switch ((insn >> 3) & 7) { case 0: /* Data register direct. */ reg = DREG(insn, 0); if (what == EASTORE) { genpartsetreg(opsize, reg, val); return storedummy; } else { return genextend(reg, opsize, what == EALOADS); } case 1: /* Address register direct. */ reg = AREG(insn, 0); if (what == EASTORE) { tcggenmovi32(reg, val); return storedummy; } else { return genextend(reg, opsize, what == EALOADS); } case 2: /* Indirect register */ reg = AREG(insn, 0); return genldst(s, opsize, reg, val, what); case 3: /* Indirect postincrement. */ reg = AREG(insn, 0); result = genldst(s, opsize, reg, val, what); /* ??? This is not exception safe. The instruction may still fault after this point. */ if (what == EASTORE || !addrp) tcggenaddii32(reg, reg, opsizebytes(opsize)); return result; case 4: /* Indirect predecrememnt. */ { TCGv tmp; if (addrp && what == EASTORE) { tmp = *addrp; } else { tmp = genlea(env, s, insn, opsize); if (ISNULLQREG(tmp)) return tmp; if (addrp) *addrp = tmp; } result = genldst(s, opsize, tmp, val, what); /* ??? This is not exception safe. The instruction may still fault after this point. */ if (what == EASTORE || !addrp) { reg = AREG(insn, 0); tcggenmovi32(reg, tmp); } } return result; case 5: /* Indirect displacement. */ case 6: /* Indirect index + displacement. */ return geneaonce(env, s, insn, opsize, val, addrp, what); case 7: /* Other */ switch (insn & 7) { case 0: /* Absolute short. */ case 1: /* Absolute long. */ case 2: /* pc displacement */ case 3: /* pc index+displacement. */ return geneaonce(env, s, insn, opsize, val, addrp, what); case 4: /* Immediate. */ /* Sign extend values for consistency. */ switch (opsize) { case OSBYTE: if (what == EALOADS) { offset = cpuldsbcode(env, s->pc + 1); } else { offset = cpuldubcode(env, s->pc + 1); } s->pc += 2; break; case OSWORD: if (what == EALOADS) { offset = cpuldswcode(env, s->pc); } else { offset = cpulduwcode(env, s->pc); } s->pc += 2; break; case OSLONG: offset = readim32(env, s); break; default: qemuassert(0, \"Bad immediate operand\"); } return tcgconsti32(offset); default: return NULLQREG; } } /* Should never happen. */ return NULLQREG; } ", "target": 1}
{"func": "static avcold void nvencsetupratecontrol(AVCodecContext *avctx) { NvencContext *ctx = avctx->privdata; if (avctx->bitrate > 0) { ctx->encodeconfig.rcParams.averageBitRate = avctx->bitrate; } else if (ctx->encodeconfig.rcParams.averageBitRate > 0) { ctx->encodeconfig.rcParams.maxBitRate = ctx->encodeconfig.rcParams.averageBitRate; } if (avctx->rcmaxrate > 0) ctx->encodeconfig.rcParams.maxBitRate = avctx->rcmaxrate; if (ctx->rc < 0) { if (ctx->flags & NVENCONEPASS) ctx->twopass = 0; if (ctx->flags & NVENCTWOPASSES) ctx->twopass = 1; if (ctx->twopass < 0) ctx->twopass = (ctx->flags & NVENCLOWLATENCY) != 0; if (ctx->cbr) { if (ctx->twopass) { ctx->rc = NVENCPARAMSRC2PASSQUALITY; } else { ctx->rc = NVENCPARAMSRCCBR; } } else if (avctx->globalquality > 0) { ctx->rc = NVENCPARAMSRCCONSTQP; } else if (ctx->twopass) { ctx->rc = NVENCPARAMSRC2PASSVBR; } else if (avctx->qmin >= 0 && avctx->qmax >= 0) { ctx->rc = NVENCPARAMSRCVBRMINQP; } } if (ctx->flags & NVENCLOSSLESS) { setlossless(avctx); } else if (ctx->rc > 0) { nvencoverrideratecontrol(avctx); } else { ctx->encodeconfig.rcParams.rateControlMode = NVENCPARAMSRCVBR; setvbr(avctx); } if (avctx->rcbuffersize > 0) { ctx->encodeconfig.rcParams.vbvBufferSize = avctx->rcbuffersize; } else if (ctx->encodeconfig.rcParams.averageBitRate > 0) { ctx->encodeconfig.rcParams.vbvBufferSize = 2 * ctx->encodeconfig.rcParams.averageBitRate; } } ", "target": 1}
{"func": "static avcold int vp3decodeend(AVCodecContext *avctx) { Vp3DecodeContext *s = avctx->privdata; int i; if (avctx->iscopy && !s->currentframe.data[0]) return 0; avfree(s->superblockcoding); avfree(s->allfragments); avfree(s->codedfragmentlist[0]); avfree(s->dcttokensbase); avfree(s->superblockfragments); avfree(s->macroblockcoding); avfree(s->motionval[0]); avfree(s->motionval[1]); avfree(s->edgeemubuffer); if (avctx->iscopy) return 0; for (i = 0; i < 16; i++) { freevlc(&s->dcvlc[i]); freevlc(&s->acvlc1[i]); freevlc(&s->acvlc2[i]); freevlc(&s->acvlc3[i]); freevlc(&s->acvlc4[i]); } freevlc(&s->superblockrunlengthvlc); freevlc(&s->fragmentrunlengthvlc); freevlc(&s->modecodevlc); freevlc(&s->motionvectorvlc); /* release all frames */ if (s->goldenframe.data[0]) ffthreadreleasebuffer(avctx, &s->goldenframe); if (s->lastframe.data[0] && s->lastframe.type != FFBUFFERTYPECOPY) ffthreadreleasebuffer(avctx, &s->lastframe); /* no need to release the currentframe since it will always be pointing * to the same frame as either the golden or last frame */ return 0; } ", "target": 1}
{"func": "static void vncdisconnectfinish(VncState *vs) { vncqmpevent(vs, QEVENTVNCDISCONNECTED); bufferfree(&vs->input); bufferfree(&vs->output); qobjectdecref(vs->info); #ifdef CONFIGVNCTLS vnctlsclientcleanup(vs); #endif /* CONFIGVNCTLS */ #ifdef CONFIGVNCSASL vncsaslclientcleanup(vs); #endif /* CONFIGVNCSASL */ audiodel(vs); QTAILQREMOVE(&vs->vd->clients, vs, next); if (QTAILQEMPTY(&vs->vd->clients)) { dcl->idle = 1; } qemuremovemousemodechangenotifier(&vs->mousemodenotifier); vncremovetimer(vs->vd); if (vs->vd->lockkeysync) qemuremoveledeventhandler(vs->led); qemufree(vs); }", "target": 1}
{"func": "void qemuoptsprint(QemuOpts *opts) { QemuOpt *opt; QemuOptDesc *desc = opts->list->desc; if (desc[0].name == NULL) { QTAILQFOREACH(opt, &opts->head, next) { printf(\"%s=\\\"%s\\\" \", opt->name, opt->str); } return; } for (; desc && desc->name; desc++) { const char *value; QemuOpt *opt = qemuoptfind(opts, desc->name); value = opt ? opt->str : desc->defvaluestr; if (!value) { continue; } if (desc->type == QEMUOPTSTRING) { printf(\"%s='%s' \", desc->name, value); } else if ((desc->type == QEMUOPTSIZE || desc->type == QEMUOPTNUMBER) && opt) { printf(\"%s=%\" PRId64 \" \", desc->name, opt->value.uint); } else { printf(\"%s=%s \", desc->name, value); } } } ", "target": 0}
{"func": "static uint32t nvicreadl(nvicstate *s, uint32t offset) { ARMCPU *cpu; uint32t val; int irq; switch (offset) { case 4: /* Interrupt Control Type. */ return (s->numirq / 32) - 1; case 0x10: /* SysTick Control and Status. */ val = s->systick.control; s->systick.control &= ~SYSTICKCOUNTFLAG; return val; case 0x14: /* SysTick Reload Value. */ return s->systick.reload; case 0x18: /* SysTick Current Value. */ { int64t t; if ((s->systick.control & SYSTICKENABLE) == 0) return 0; t = qemuclockgetns(QEMUCLOCKVIRTUAL); if (t >= s->systick.tick) return 0; val = ((s->systick.tick - (t + 1)) / systickscale(s)) + 1; /* The interrupt in triggered when the timer reaches zero. However the counter is not reloaded until the next clock tick. This is a hack to return zero during the first tick. */ if (val > s->systick.reload) val = 0; return val; } case 0x1c: /* SysTick Calibration Value. */ return 10000; case 0xd00: /* CPUID Base. */ cpu = ARMCPU(currentcpu); return cpu->env.cp15.c0cpuid; case 0xd04: /* Interrupt Control State. */ /* VECTACTIVE */ val = s->gic.runningirq[0]; if (val == 1023) { val = 0; } else if (val >= 32) { val -= 16; } /* RETTOBASE */ if (s->gic.runningirq[0] == 1023 || s->gic.lastactive[s->gic.runningirq[0]][0] == 1023) { val |= (1 << 11); } /* VECTPENDING */ if (s->gic.currentpending[0] != 1023) val |= (s->gic.currentpending[0] << 12); /* ISRPENDING */ for (irq = 32; irq < s->numirq; irq++) { if (s->gic.irqstate[irq].pending) { val |= (1 << 22); break; } } /* PENDSTSET */ if (s->gic.irqstate[ARMV7MEXCPSYSTICK].pending) val |= (1 << 26); /* PENDSVSET */ if (s->gic.irqstate[ARMV7MEXCPPENDSV].pending) val |= (1 << 28); /* NMIPENDSET */ if (s->gic.irqstate[ARMV7MEXCPNMI].pending) val |= (1 << 31); return val; case 0xd08: /* Vector Table Offset. */ cpu = ARMCPU(currentcpu); return cpu->env.v7m.vecbase; case 0xd0c: /* Application Interrupt/Reset Control. */ return 0xfa05000; case 0xd10: /* System Control. */ /* TODO: Implement SLEEPONEXIT. */ return 0; case 0xd14: /* Configuration Control. */ /* TODO: Implement Configuration Control bits. */ return 0; case 0xd24: /* System Handler Status. */ val = 0; if (s->gic.irqstate[ARMV7MEXCPMEM].active) val |= (1 << 0); if (s->gic.irqstate[ARMV7MEXCPBUS].active) val |= (1 << 1); if (s->gic.irqstate[ARMV7MEXCPUSAGE].active) val |= (1 << 3); if (s->gic.irqstate[ARMV7MEXCPSVC].active) val |= (1 << 7); if (s->gic.irqstate[ARMV7MEXCPDEBUG].active) val |= (1 << 8); if (s->gic.irqstate[ARMV7MEXCPPENDSV].active) val |= (1 << 10); if (s->gic.irqstate[ARMV7MEXCPSYSTICK].active) val |= (1 << 11); if (s->gic.irqstate[ARMV7MEXCPUSAGE].pending) val |= (1 << 12); if (s->gic.irqstate[ARMV7MEXCPMEM].pending) val |= (1 << 13); if (s->gic.irqstate[ARMV7MEXCPBUS].pending) val |= (1 << 14); if (s->gic.irqstate[ARMV7MEXCPSVC].pending) val |= (1 << 15); if (s->gic.irqstate[ARMV7MEXCPMEM].enabled) val |= (1 << 16); if (s->gic.irqstate[ARMV7MEXCPBUS].enabled) val |= (1 << 17); if (s->gic.irqstate[ARMV7MEXCPUSAGE].enabled) val |= (1 << 18); return val; case 0xd28: /* Configurable Fault Status. */ /* TODO: Implement Fault Status. */ qemulogmask(LOGUNIMP, \"Configurable Fault Status unimplemented\\n\"); return 0; case 0xd2c: /* Hard Fault Status. */ case 0xd30: /* Debug Fault Status. */ case 0xd34: /* Mem Manage Address. */ case 0xd38: /* Bus Fault Address. */ case 0xd3c: /* Aux Fault Status. */ /* TODO: Implement fault status registers. */ qemulogmask(LOGUNIMP, \"Fault status registers unimplemented\\n\"); return 0; case 0xd40: /* PFR0. */ return 0x00000030; case 0xd44: /* PRF1. */ return 0x00000200; case 0xd48: /* DFR0. */ return 0x00100000; case 0xd4c: /* AFR0. */ return 0x00000000; case 0xd50: /* MMFR0. */ return 0x00000030; case 0xd54: /* MMFR1. */ return 0x00000000; case 0xd58: /* MMFR2. */ return 0x00000000; case 0xd5c: /* MMFR3. */ return 0x00000000; case 0xd60: /* ISAR0. */ return 0x01141110; case 0xd64: /* ISAR1. */ return 0x02111000; case 0xd68: /* ISAR2. */ return 0x21112231; case 0xd6c: /* ISAR3. */ return 0x01111110; case 0xd70: /* ISAR4. */ return 0x01310102; /* TODO: Implement debug registers. */ default: qemulogmask(LOGGUESTERROR, \"NVIC: Bad read offset 0x%x\\n\", offset); return 0; } } ", "target": 0}
{"func": "static int gxfwriteheader(AVFormatContext *s) { AVIOContext *pb = s->pb; GXFContext *gxf = s->privdata; GXFStreamContext *vsc = NULL; uint8t tracks[255] = {0}; int i, mediainfo = 0; if (!pb->seekable) { avlog(s, AVLOGERROR, \"gxf muxer does not support streamed output, patch welcome\"); return -1; } gxf->flags |= 0x00080000; /* material is simple clip */ for (i = 0; i < s->nbstreams; ++i) { AVStream *st = s->streams[i]; GXFStreamContext *sc = avmallocz(sizeof(*sc)); if (!sc) return AVERROR(ENOMEM); st->privdata = sc; sc->mediatype = ffcodecgettag(gxfmediatypes, st->codecpar->codecid); if (st->codecpar->codectype == AVMEDIATYPEAUDIO) { if (st->codecpar->codecid != AVCODECIDPCMS16LE) { avlog(s, AVLOGERROR, \"only 16 BIT PCM LE allowed for now\\n\"); return -1; } if (st->codecpar->samplerate != 48000) { avlog(s, AVLOGERROR, \"only 48000hz sampling rate is allowed\\n\"); return -1; } if (st->codecpar->channels != 1) { avlog(s, AVLOGERROR, \"only mono tracks are allowed\\n\"); return -1; } sc->tracktype = 2; sc->samplerate = st->codecpar->samplerate; avprivsetptsinfo(st, 64, 1, sc->samplerate); sc->samplesize = 16; sc->framerateindex = -2; sc->linesindex = -2; sc->fields = -2; gxf->audiotracks++; gxf->flags |= 0x04000000; /* audio is 16 bit pcm */ mediainfo = 'A'; } else if (st->codecpar->codectype == AVMEDIATYPEVIDEO) { if (i != 0) { avlog(s, AVLOGERROR, \"video stream must be the first track\\n\"); return -1; } /* FIXME check from timebase ? */ if (st->codecpar->height == 480 || st->codecpar->height == 512) { /* NTSC or NTSC+VBI */ sc->framerateindex = 5; sc->samplerate = 60; gxf->flags |= 0x00000080; gxf->timebase = (AVRational){ 1001, 60000 }; } else if (st->codecpar->height == 576 || st->codecpar->height == 608) { /* PAL or PAL+VBI */ sc->framerateindex = 6; sc->mediatype++; sc->samplerate = 50; gxf->flags |= 0x00000040; gxf->timebase = (AVRational){ 1, 50 }; } else { avlog(s, AVLOGERROR, \"unsupported video resolution, \" \"gxf muxer only accepts PAL or NTSC resolutions currently\\n\"); return -1; } avprivsetptsinfo(st, 64, gxf->timebase.num, gxf->timebase.den); if (gxffindlinesindex(st) < 0) sc->linesindex = -1; sc->samplesize = st->codecpar->bitrate; sc->fields = 2; /* interlaced */ vsc = sc; switch (st->codecpar->codecid) { case AVCODECIDMJPEG: sc->tracktype = 1; gxf->flags |= 0x00004000; mediainfo = 'J'; break; case AVCODECIDMPEG1VIDEO: sc->tracktype = 9; gxf->mpegtracks++; mediainfo = 'L'; break; case AVCODECIDMPEG2VIDEO: sc->firstgopclosed = -1; sc->tracktype = 4; gxf->mpegtracks++; gxf->flags |= 0x00008000; mediainfo = 'M'; break; case AVCODECIDDVVIDEO: if (st->codecpar->format == AVPIXFMTYUV422P) { sc->mediatype += 2; sc->tracktype = 6; gxf->flags |= 0x00002000; mediainfo = 'E'; } else { sc->tracktype = 5; gxf->flags |= 0x00001000; mediainfo = 'D'; } break; default: avlog(s, AVLOGERROR, \"video codec not supported\\n\"); return -1; } } /* FIXME first 10 audio tracks are 0 to 9 next 22 are A to V */ sc->mediainfo = mediainfo<<8 | ('0'+tracks[mediainfo]++); sc->order = s->nbstreams - st->index; } if (ffaudiointerleaveinit(s, GXFsamplesperframe, (AVRational){ 1, 48000 }) < 0) return -1; gxfinittimecodetrack(&gxf->timecodetrack, vsc); gxf->flags |= 0x200000; // time code track is non-drop frame gxfwritemappacket(s, 0); gxfwritefltpacket(s); gxfwriteumfpacket(s); gxf->packetcount = 3; avioflush(pb); return 0; } ", "target": 0}
{"func": "static void qxlrenderupdateareaunlocked(PCIQXLDevice *qxl) { VGACommonState *vga = &qxl->vga; int i; if (qxl->guestprimary.resized) { qxl->guestprimary.resized = 0; qxl->guestprimary.data = memoryregiongetramptr(&qxl->vga.vram); qxlsetrecttosurface(qxl, &qxl->dirty[0]); qxl->numdirtyrects = 1; traceqxlrenderguestprimaryresized( qxl->guestprimary.surface.width, qxl->guestprimary.surface.height, qxl->guestprimary.qxlstride, qxl->guestprimary.bytespp, qxl->guestprimary.bitspp); if (qxl->guestprimary.qxlstride > 0) { qemufreedisplaysurface(vga->ds); qemucreatedisplaysurfacefrom(qxl->guestprimary.surface.width, qxl->guestprimary.surface.height, qxl->guestprimary.bitspp, qxl->guestprimary.absstride, qxl->guestprimary.data); } else { qemuresizedisplaysurface(vga->ds, qxl->guestprimary.surface.width, qxl->guestprimary.surface.height); } dpygfxresize(vga->ds); } for (i = 0; i < qxl->numdirtyrects; i++) { if (qemuspicerectisempty(qxl->dirty+i)) { break; } qxlblit(qxl, qxl->dirty+i); dpygfxupdate(vga->ds, qxl->dirty[i].left, qxl->dirty[i].top, qxl->dirty[i].right - qxl->dirty[i].left, qxl->dirty[i].bottom - qxl->dirty[i].top); } qxl->numdirtyrects = 0; } ", "target": 0}
{"func": "static void pageinit(void) { /* NOTE: we can always suppose that qemuhostpagesize >= TARGETPAGESIZE */ #ifdef WIN32 { SYSTEMINFO systeminfo; GetSystemInfo(&systeminfo); qemurealhostpagesize = systeminfo.dwPageSize; } #else qemurealhostpagesize = getpagesize(); #endif if (qemuhostpagesize == 0) { qemuhostpagesize = qemurealhostpagesize; } if (qemuhostpagesize < TARGETPAGESIZE) { qemuhostpagesize = TARGETPAGESIZE; } qemuhostpagemask = ~(qemuhostpagesize - 1); #if defined(CONFIGBSD) && defined(CONFIGUSERONLY) { #ifdef HAVEKINFOGETVMMAP struct kinfovmentry *freep; int i, cnt; freep = kinfogetvmmap(getpid(), &cnt); if (freep) { mmaplock(); for (i = 0; i < cnt; i++) { unsigned long startaddr, endaddr; startaddr = freep[i].kvestart; endaddr = freep[i].kveend; if (h2gvalid(startaddr)) { startaddr = h2g(startaddr) & TARGETPAGEMASK; if (h2gvalid(endaddr)) { endaddr = h2g(endaddr); pagesetflags(startaddr, endaddr, PAGERESERVED); } else { #if TARGETABIBITS <= L1MAPADDRSPACEBITS endaddr = ~0ul; pagesetflags(startaddr, endaddr, PAGERESERVED); #endif } } } free(freep); mmapunlock(); } #else FILE *f; lastbrk = (unsigned long)sbrk(0); f = fopen(\"/compat/linux/proc/self/maps\", \"r\"); if (f) { mmaplock(); do { unsigned long startaddr, endaddr; int n; n = fscanf(f, \"%lx-%lx %*[^\\n]\\n\", &startaddr, &endaddr); if (n == 2 && h2gvalid(startaddr)) { startaddr = h2g(startaddr) & TARGETPAGEMASK; if (h2gvalid(endaddr)) { endaddr = h2g(endaddr); } else { endaddr = ~0ul; } pagesetflags(startaddr, endaddr, PAGERESERVED); } } while (!feof(f)); fclose(f); mmapunlock(); } #endif } #endif } ", "target": 0}
{"func": "static SocketAddress *tcpbuildaddress(const char *hostport, Error **errp) { InetSocketAddress *iaddr = gnew(InetSocketAddress, 1); SocketAddress *saddr; if (inetparse(iaddr, hostport, errp)) { qapifreeInetSocketAddress(iaddr); return NULL; } saddr = gnew0(SocketAddress, 1); saddr->type = SOCKETADDRESSKINDINET; saddr->u.inet.data = iaddr; return saddr; } ", "target": 0}
{"func": "static void nbdclose(BlockDriverState *bs) { BDRVNBDState *s = bs->opaque; qemuoptsdel(s->socketopts); nbdclientsessionclose(&s->client); } ", "target": 0}
{"func": "static void reset(DeviceState *d) { sPAPRDRConnector *drc = SPAPRDRCONNECTOR(d); sPAPRDRConnectorClass *drck = SPAPRDRCONNECTORGETCLASS(drc); tracespaprdrcreset(spaprdrcindex(drc)); gfree(drc->ccs); drc->ccs = NULL; /* immediately upon reset we can safely assume DRCs whose devices * are pending removal can be safely removed, and that they will * subsequently be left in an ISOLATED state. move the DRC to this * state in these cases (which will in turn complete any pending * device removals) */ if (drc->awaitingrelease) { drck->setisolationstate(drc, SPAPRDRISOLATIONSTATEISOLATED); /* generally this should also finalize the removal, but if the device * hasn't yet been configured we normally defer removal under the * assumption that this transition is taking place as part of device * configuration. so check if we're still waiting after this, and * force removal if we are */ if (drc->awaitingrelease) { spaprdrcdetach(drc, DEVICE(drc->dev), NULL); } /* non-PCI devices may be awaiting a transition to UNUSABLE */ if (spaprdrctype(drc) != SPAPRDRCONNECTORTYPEPCI && drc->awaitingrelease) { drck->setallocationstate(drc, SPAPRDRALLOCATIONSTATEUNUSABLE); } } } ", "target": 0}
{"func": "int kvmremovebreakpoint(CPUState *currentenv, targetulong addr, targetulong len, int type) { struct kvmswbreakpoint *bp; CPUState *env; int err; if (type == GDBBREAKPOINTSW) { bp = kvmfindswbreakpoint(currentenv, addr); if (!bp) return -ENOENT; if (bp->usecount > 1) { bp->usecount--; return 0; } err = kvmarchremoveswbreakpoint(currentenv, bp); if (err) return err; QTAILQREMOVE(&currentenv->kvmstate->kvmswbreakpoints, bp, entry); qemufree(bp); } else { err = kvmarchremovehwbreakpoint(addr, len, type); if (err) return err; } for (env = firstcpu; env != NULL; env = env->nextcpu) { err = kvmupdateguestdebug(env, 0); if (err) return err; } return 0; } ", "target": 0}
{"func": "void helperfcmpgtDT(CPUSH4State *env, float64 t0, float64 t1) { int relation; setfloatexceptionflags(0, &env->fpstatus); relation = float64compare(t0, t1, &env->fpstatus); if (unlikely(relation == floatrelationunordered)) { updatefpscr(env, GETPC()); } else { env->srt = (relation == floatrelationgreater); } } ", "target": 0}
{"func": "static int imginfo(int argc, char **argv) { int c; OutputFormat outputformat = OFORMATHUMAN; const char *filename, *fmt, *output; BlockDriverState *bs; ImageInfo *info; fmt = NULL; output = NULL; for(;;) { int optionindex = 0; static const struct option longoptions[] = { {\"help\", noargument, 0, 'h'}, {\"format\", requiredargument, 0, 'f'}, {\"output\", requiredargument, 0, OPTIONOUTPUT}, {0, 0, 0, 0} }; c = getoptlong(argc, argv, \"f:h\", longoptions, &optionindex); if (c == -1) { break; } switch(c) { case '?': case 'h': help(); break; case 'f': fmt = optarg; break; case OPTIONOUTPUT: output = optarg; break; } } if (optind >= argc) { help(); } filename = argv[optind++]; if (output && !strcmp(output, \"json\")) { outputformat = OFORMATJSON; } else if (output && !strcmp(output, \"human\")) { outputformat = OFORMATHUMAN; } else if (output) { errorreport(\"--output must be used with human or json as argument.\"); return 1; } bs = bdrvnewopen(filename, fmt, BDRVOFLAGS | BDRVONOBACKING); if (!bs) { return 1; } info = gnew0(ImageInfo, 1); collectimageinfo(bs, info, filename, fmt); switch (outputformat) { case OFORMATHUMAN: dumphumanimageinfo(info); dumpsnapshots(bs); break; case OFORMATJSON: collectsnapshots(bs, info); dumpjsonimageinfo(info); break; } qapifreeImageInfo(info); bdrvdelete(bs); return 0; } ", "target": 0}
{"func": "int qiodnsresolverlookupsync(QIODNSResolver *resolver, SocketAddressLegacy *addr, sizet *naddrs, SocketAddressLegacy ***addrs, Error **errp) { switch (addr->type) { case SOCKETADDRESSLEGACYKINDINET: return qiodnsresolverlookupsyncinet(resolver, addr, naddrs, addrs, errp); case SOCKETADDRESSLEGACYKINDUNIX: case SOCKETADDRESSLEGACYKINDVSOCK: case SOCKETADDRESSLEGACYKINDFD: return qiodnsresolverlookupsyncnop(resolver, addr, naddrs, addrs, errp); default: abort(); } } ", "target": 0}
{"func": "static coroutinefn int qcowcoreadv(BlockDriverState *bs, int64t sectornum, int nbsectors, QEMUIOVector *qiov) { BDRVQcowState *s = bs->opaque; int indexincluster; int ret = 0, n; uint64t clusteroffset; struct iovec hdiov; QEMUIOVector hdqiov; uint8t *buf; void *origbuf; Error *err = NULL; if (qiov->niov > 1) { buf = origbuf = qemutryblockalign(bs, qiov->size); if (buf == NULL) { return -ENOMEM; } } else { origbuf = NULL; buf = (uint8t *)qiov->iov->iovbase; } qemucomutexlock(&s->lock); while (nbsectors != 0) { /* prepare next request */ clusteroffset = getclusteroffset(bs, sectornum << 9, 0, 0, 0, 0); indexincluster = sectornum & (s->clustersectors - 1); n = s->clustersectors - indexincluster; if (n > nbsectors) { n = nbsectors; } if (!clusteroffset) { if (bs->backing) { /* read from the base image */ hdiov.iovbase = (void *)buf; hdiov.iovlen = n * 512; qemuiovecinitexternal(&hdqiov, &hdiov, 1); qemucomutexunlock(&s->lock); ret = bdrvcoreadv(bs->backing, sectornum, n, &hdqiov); qemucomutexlock(&s->lock); if (ret < 0) { goto fail; } } else { /* Note: in this case, no need to wait */ memset(buf, 0, 512 * n); } } else if (clusteroffset & QCOWOFLAGCOMPRESSED) { /* add AIO support for compressed blocks ? */ if (decompresscluster(bs, clusteroffset) < 0) { goto fail; } memcpy(buf, s->clustercache + indexincluster * 512, 512 * n); } else { if ((clusteroffset & 511) != 0) { goto fail; } hdiov.iovbase = (void *)buf; hdiov.iovlen = n * 512; qemuiovecinitexternal(&hdqiov, &hdiov, 1); qemucomutexunlock(&s->lock); ret = bdrvcoreadv(bs->file, (clusteroffset >> 9) + indexincluster, n, &hdqiov); qemucomutexlock(&s->lock); if (ret < 0) { break; } if (bs->encrypted) { assert(s->cipher); if (encryptsectors(s, sectornum, buf, n, false, &err) < 0) { goto fail; } } } ret = 0; nbsectors -= n; sectornum += n; buf += n * 512; } done: qemucomutexunlock(&s->lock); if (qiov->niov > 1) { qemuiovecfrombuf(qiov, 0, origbuf, qiov->size); qemuvfree(origbuf); } return ret; fail: errorfree(err); ret = -EIO; goto done; } ", "target": 0}
{"func": "static int mpeg4decodegopheader(MpegEncContext *s, GetBitContext *gb) { int hours, minutes, seconds; if (!showbits(gb, 23)) { avlog(s->avctx, AVLOGWARNING, \"GOP header invalid\\n\"); return -1; } hours = getbits(gb, 5); minutes = getbits(gb, 6); skipbits1(gb); seconds = getbits(gb, 6); s->timebase = seconds + 60*(minutes + 60*hours); skipbits1(gb); skipbits1(gb); return 0; } ", "target": 0}
{"func": "static int ftprestart(FTPContext *s, int64t pos) { char command[CONTROLBUFFERSIZE]; const int restcodes[] = {350, 0}; snprintf(command, sizeof(command), \"REST %\"PRId64\"\\r\\n\", pos); if (!ftpsendcommand(s, command, restcodes, NULL)) return AVERROR(EIO); return 0; } ", "target": 0}
{"func": "static int coroutinefn bdrvcodocopyonreadv(BdrvChild *child, int64t offset, unsigned int bytes, QEMUIOVector *qiov) { BlockDriverState *bs = child->bs; /* Perform I/O through a temporary buffer so that users who scribble over * their read buffer while the operation is in progress do not end up * modifying the image file. This is critical for zero-copy guest I/O * where anything might happen inside guest memory. */ void *bouncebuffer; BlockDriver *drv = bs->drv; struct iovec iov; QEMUIOVector bounceqiov; int64t clusteroffset; unsigned int clusterbytes; sizet skipbytes; int ret; /* FIXME We cannot require callers to have write permissions when all they * are doing is a read request. If we did things right, write permissions * would be obtained anyway, but internally by the copy-on-read code. As * long as it is implemented here rather than in a separate filter driver, * the copy-on-read code doesn't have its own BdrvChild, however, for which * it could request permissions. Therefore we have to bypass the permission * system for the moment. */ // assert(child->perm & (BLKPERMWRITEUNCHANGED | BLKPERMWRITE)); /* Cover entire cluster so no additional backing file I/O is required when * allocating cluster in the image file. */ bdrvroundtoclusters(bs, offset, bytes, &clusteroffset, &clusterbytes); tracebdrvcodocopyonreadv(bs, offset, bytes, clusteroffset, clusterbytes); iov.iovlen = clusterbytes; iov.iovbase = bouncebuffer = qemutryblockalign(bs, iov.iovlen); if (bouncebuffer == NULL) { ret = -ENOMEM; goto err; } qemuiovecinitexternal(&bounceqiov, &iov, 1); ret = bdrvdriverpreadv(bs, clusteroffset, clusterbytes, &bounceqiov, 0); if (ret < 0) { goto err; } bdrvdebugevent(bs, BLKDBGCORWRITE); if (drv->bdrvcopwritezeroes && bufferiszero(bouncebuffer, iov.iovlen)) { /* FIXME: Should we (perhaps conditionally) be setting * BDRVREQMAYUNMAP, if it will allow for a sparser copy * that still correctly reads as zero? */ ret = bdrvcodopwritezeroes(bs, clusteroffset, clusterbytes, 0); } else { /* This does not change the data on the disk, it is not necessary * to flush even in cache=writethrough mode. */ ret = bdrvdriverpwritev(bs, clusteroffset, clusterbytes, &bounceqiov, 0); } if (ret < 0) { /* It might be okay to ignore write errors for guest requests. If this * is a deliberate copy-on-read then we don't want to ignore the error. * Simply report it in all cases. */ goto err; } skipbytes = offset - clusteroffset; qemuiovecfrombuf(qiov, 0, bouncebuffer + skipbytes, bytes); err: qemuvfree(bouncebuffer); return ret; } ", "target": 0}
{"func": "int kvmioctl(KVMState *s, int type, ...) { int ret; void *arg; valist ap; vastart(ap, type); arg = vaarg(ap, void *); vaend(ap); ret = ioctl(s->fd, type, arg); if (ret == -1) ret = -errno; return ret; } ", "target": 0}
{"func": "static uint64t exynos4210mctread(void *opaque, targetphysaddrt offset, unsigned size) { Exynos4210MCTState *s = (Exynos4210MCTState *)opaque; int index; int shift; uint64t count; uint32t value; int lti; switch (offset) { case MCTCFG: value = s->regmctcfg; break; case GCNTL: case GCNTU: shift = 8 * (offset & 0x4); count = exynos4210gfrcgetcount(&s->gtimer); value = UINT32MAX & (count >> shift); DPRINTF(\"read FRC=0x%llx\\n\", count); break; case GCNTWSTAT: value = s->gtimer.reg.cntwstat; break; case GCOMPL(0): case GCOMPL(1): case GCOMPL(2): case GCOMPL(3): case GCOMPU(0): case GCOMPU(1): case GCOMPU(2): case GCOMPU(3): index = GETGCOMPIDX(offset); shift = 8 * (offset & 0x4); value = UINT32MAX & (s->gtimer.reg.comp[index] >> shift); break; case GTCON: value = s->gtimer.reg.tcon; break; case GINTCSTAT: value = s->gtimer.reg.intcstat; break; case GINTENB: value = s->gtimer.reg.intenb; break; break; case GWSTAT: value = s->gtimer.reg.wstat; break; case GCOMP0ADDINCR: case GCOMP1ADDINCR: case GCOMP2ADDINCR: case GCOMP3ADDINCR: value = s->gtimer.reg.compaddincr[GETGCOMPADDINCRIDX(offset)]; break; /* Local timers */ case L0TCNTB: case L0ICNTB: case L0FRCNTB: case L1TCNTB: case L1ICNTB: case L1FRCNTB: lti = GETLTIMERIDX(offset); index = GETLTIMERCNTREGIDX(offset, lti); value = s->ltimer[lti].reg.cnt[index]; break; case L0TCNTO: case L1TCNTO: lti = GETLTIMERIDX(offset); value = exynos4210ltickcntgetcnto(&s->ltimer[lti].ticktimer); DPRINTF(\"local timer[%d] read TCNTO %x\\n\", lti, value); break; case L0ICNTO: case L1ICNTO: lti = GETLTIMERIDX(offset); value = exynos4210ltickintgetcnto(&s->ltimer[lti].ticktimer); DPRINTF(\"local timer[%d] read ICNTO %x\\n\", lti, value); break; case L0FRCNTO: case L1FRCNTO: lti = GETLTIMERIDX(offset); value = exynos4210lfrcgetcount(&s->ltimer[lti]); break; case L0TCON: case L1TCON: lti = ((offset & 0xF00) - L0TCNTB) / 0x100; value = s->ltimer[lti].reg.tcon; break; case L0INTCSTAT: case L1INTCSTAT: lti = ((offset & 0xF00) - L0TCNTB) / 0x100; value = s->ltimer[lti].reg.intcstat; break; case L0INTENB: case L1INTENB: lti = ((offset & 0xF00) - L0TCNTB) / 0x100; value = s->ltimer[lti].reg.intenb; break; case L0WSTAT: case L1WSTAT: lti = ((offset & 0xF00) - L0TCNTB) / 0x100; value = s->ltimer[lti].reg.wstat; break; default: hwerror(\"exynos4210.mct: bad read offset \" TARGETFMTplx \"\\n\", offset); break; } return value; } ", "target": 0}
{"func": "theoragptopts(AVFormatContext *ctx, int idx, uint64t gp, int64t *dts) { struct ogg *ogg = ctx->privdata; struct oggstream *os = ogg->streams + idx; struct theoraparams *thp = os->private; uint64t iframe = gp >> thp->gpshift; uint64t pframe = gp & thp->gpmask; if (thp->version < 0x030201) iframe++; if(!pframe) os->pflags |= AVPKTFLAGKEY; if (dts) *dts = iframe + pframe; return iframe + pframe; } ", "target": 0}
{"func": "static void avbuildindexraw(AVFormatContext *s) { AVPacket pkt1, *pkt = &pkt1; int ret; AVStream *st; st = s->streams[0]; avreadframeflush(s); urlfseek(&s->pb, s->dataoffset, SEEKSET); for(;;) { ret = avreadframe(s, pkt); if (ret < 0) break; if (pkt->streamindex == 0 && st->parser && (pkt->flags & PKTFLAGKEY)) { addindexentry(st, st->parser->frameoffset, pkt->dts, AVINDEXKEYFRAME); } avfreepacket(pkt); } } ", "target": 0}
{"func": "static FWCfgState *bochsbiosinit(void) { FWCfgState *fwcfg; uint8t *smbiostables, *smbiosanchor; sizet smbiostableslen, smbiosanchorlen; uint64t *numafwcfg; int i, j; unsigned int apicidlimit = pcapicidlimit(maxcpus); fwcfg = fwcfginitio(BIOSCFGIOPORT); /* FWCFGMAXCPUS is a bit confusing/problematic on x86: * * SeaBIOS needs FWCFGMAXCPUS for CPU hotplug, but the CPU hotplug * QEMU<->SeaBIOS interface is not based on the \"CPU index\", but on the APIC * ID of hotplugged CPUs[1]. This means that FWCFGMAXCPUS is not the * \"maximum number of CPUs\", but the \"limit to the APIC ID values SeaBIOS * may see\". * * So, this means we must not use maxcpus, here, but the maximum possible * APIC ID value, plus one. * * [1] The only kind of \"CPU identifier\" used between SeaBIOS and QEMU is * the APIC ID, not the \"CPU index\" */ fwcfgaddi16(fwcfg, FWCFGMAXCPUS, (uint16t)apicidlimit); fwcfgaddi32(fwcfg, FWCFGID, 1); fwcfgaddi64(fwcfg, FWCFGRAMSIZE, (uint64t)ramsize); fwcfgaddbytes(fwcfg, FWCFGACPITABLES, acpitables, acpitableslen); fwcfgaddi32(fwcfg, FWCFGIRQ0OVERRIDE, kvmallowsirq0override()); smbiostables = smbiosgettablelegacy(&smbiostableslen); if (smbiostables) { fwcfgaddbytes(fwcfg, FWCFGSMBIOSENTRIES, smbiostables, smbiostableslen); } smbiosgettables(&smbiostables, &smbiostableslen, &smbiosanchor, &smbiosanchorlen); if (smbiosanchor) { fwcfgaddfile(fwcfg, \"etc/smbios/smbios-tables\", smbiostables, smbiostableslen); fwcfgaddfile(fwcfg, \"etc/smbios/smbios-anchor\", smbiosanchor, smbiosanchorlen); } fwcfgaddbytes(fwcfg, FWCFGE820TABLE, &e820reserve, sizeof(e820reserve)); fwcfgaddfile(fwcfg, \"etc/e820\", e820table, sizeof(struct e820entry) * e820entries); fwcfgaddbytes(fwcfg, FWCFGHPET, &hpetcfg, sizeof(hpetcfg)); /* allocate memory for the NUMA channel: one (64bit) word for the number * of nodes, one word for each VCPU->node and one word for each node to * hold the amount of memory. */ numafwcfg = gnew0(uint64t, 1 + apicidlimit + nbnumanodes); numafwcfg[0] = cputole64(nbnumanodes); for (i = 0; i < maxcpus; i++) { unsigned int apicid = x86cpuapicidfromindex(i); assert(apicid < apicidlimit); for (j = 0; j < nbnumanodes; j++) { if (testbit(i, numainfo[j].nodecpu)) { numafwcfg[apicid + 1] = cputole64(j); break; } } } for (i = 0; i < nbnumanodes; i++) { numafwcfg[apicidlimit + 1 + i] = cputole64(numainfo[i].nodemem); } fwcfgaddbytes(fwcfg, FWCFGNUMA, numafwcfg, (1 + apicidlimit + nbnumanodes) * sizeof(*numafwcfg)); return fwcfg; } ", "target": 0}
{"func": "int mmutranslate(CPUS390XState *env, targetulong vaddr, int rw, uint64t asc, targetulong *raddr, int *flags) { int r = -1; uint8t *sk; *flags = PAGEREAD | PAGEWRITE | PAGEEXEC; vaddr &= TARGETPAGEMASK; if (!(env->psw.mask & PSWMASKDAT)) { *raddr = vaddr; r = 0; goto out; } switch (asc) { case PSWASCPRIMARY: case PSWASCHOME: r = mmutranslateasc(env, vaddr, asc, raddr, flags, rw); break; case PSWASCSECONDARY: /* * Instruction: Primary * Data: Secondary */ if (rw == 2) { r = mmutranslateasc(env, vaddr, PSWASCPRIMARY, raddr, flags, rw); *flags &= ~(PAGEREAD | PAGEWRITE); } else { r = mmutranslateasc(env, vaddr, PSWASCSECONDARY, raddr, flags, rw); *flags &= ~(PAGEEXEC); } break; case PSWASCACCREG: default: hwerror(\"guest switched to unknown asc mode\\n\"); break; } out: /* Convert real address -> absolute address */ *raddr = mmureal2abs(env, *raddr); if (*raddr <= ramsize) { sk = &env->storagekeys[*raddr / TARGETPAGESIZE]; if (*flags & PAGEREAD) { *sk |= SKR; } if (*flags & PAGEWRITE) { *sk |= SKC; } } return r; } ", "target": 0}
{"func": "static inline int decodeaccoeffs(GetBitContext *gb, int16t *out, int blocksperslice, int planesizefactor, const uint8t *scan) { int pos, blockmask, run, level, sign, runcbindex, levcbindex; int maxcoeffs, bitsleft; /* set initial prediction values */ run = 4; level = 2; maxcoeffs = blocksperslice << 6; blockmask = blocksperslice - 1; for (pos = blocksperslice - 1; pos < maxcoeffs;) { runcbindex = ffproresruntocbindex[FFMIN(run, 15)]; levcbindex = ffproreslevtocbindex[FFMIN(level, 9)]; bitsleft = getbitsleft(gb); if (bitsleft <= 0 || (bitsleft <= 8 && !showbits(gb, bitsleft))) return 0; run = decodevlccodeword(gb, ffproresaccodebook[runcbindex]); if (run < 0) return AVERRORINVALIDDATA; bitsleft = getbitsleft(gb); if (bitsleft <= 0 || (bitsleft <= 8 && !showbits(gb, bitsleft))) return AVERRORINVALIDDATA; level = decodevlccodeword(gb, ffproresaccodebook[levcbindex]) + 1; if (level < 0) return AVERRORINVALIDDATA; pos += run + 1; if (pos >= maxcoeffs) break; sign = getsbits(gb, 1); out[((pos & blockmask) << 6) + scan[pos >> planesizefactor]] = (level ^ sign) - sign; } return 0; } ", "target": 0}
{"func": "static int localopendir(FsContext *ctx, V9fsPath *fspath, V9fsFidOpenState *fs) { int dirfd; DIR *stream; dirfd = localopendirnofollow(ctx, fspath->data); if (dirfd == -1) { return -1; } stream = fdopendir(dirfd); if (!stream) { return -1; } fs->dir.stream = stream; return 0; }", "target": 1}
{"func": "static int mpegmuxinit(AVFormatContext *ctx) { MpegMuxContext *s = ctx->privdata; int bitrate, i, mpaid, mpvid, ac3id; AVStream *st; StreamInfo *stream; s->packetnumber = 0; s->isvcd = (ctx->oformat == &mpeg1vcdmux); s->ismpeg2 = (ctx->oformat == &mpeg2vobmux); if (s->isvcd) s->packetsize = 2324; /* VCD packet size */ else s->packetsize = 2048; /* startcode(4) + length(2) + flags(1) */ s->packetdatamaxsize = s->packetsize - 7; if (s->ismpeg2) s->packetdatamaxsize -= 2; s->audiobound = 0; s->videobound = 0; mpaid = AUDIOID; ac3id = 0x80; mpvid = VIDEOID; s->scrstreamindex = -1; for(i=0;i<ctx->nbstreams;i++) { st = ctx->streams[i]; stream = avmallocz(sizeof(StreamInfo)); if (!stream) goto fail; st->privdata = stream; switch(st->codec.codectype) { case CODECTYPEAUDIO: if (st->codec.codecid == CODECIDAC3) stream->id = ac3id++; else stream->id = mpaid++; stream->maxbuffersize = 4 * 1024; s->audiobound++; break; case CODECTYPEVIDEO: /* by default, video is used for the SCR computation */ if (s->scrstreamindex == -1) s->scrstreamindex = i; stream->id = mpvid++; stream->maxbuffersize = 46 * 1024; s->videobound++; break; default: avabort(); } } /* if no SCR, use first stream (audio) */ if (s->scrstreamindex == -1) s->scrstreamindex = 0; /* we increase slightly the bitrate to take into account the headers. XXX: compute it exactly */ bitrate = 2000; for(i=0;i<ctx->nbstreams;i++) { st = ctx->streams[i]; bitrate += st->codec.bitrate; } s->muxrate = (bitrate + (8 * 50) - 1) / (8 * 50); if (s->isvcd || s->ismpeg2) /* every packet */ s->packheaderfreq = 1; else /* every 2 seconds */ s->packheaderfreq = 2 * bitrate / s->packetsize / 8; /* the above seems to make packheaderfreq zero sometimes */ if (s->packheaderfreq == 0) s->packheaderfreq = 1; if (s->ismpeg2) /* every 200 packets. Need to look at the spec. */ s->systemheaderfreq = s->packheaderfreq * 40; else if (s->isvcd) /* every 40 packets, this is my invention */ s->systemheaderfreq = s->packheaderfreq * 40; else s->systemheaderfreq = s->packheaderfreq * 5; for(i=0;i<ctx->nbstreams;i++) { stream = ctx->streams[i]->privdata; stream->bufferptr = 0; stream->packetnumber = 0; stream->startpts = AVNOPTSVALUE; stream->startdts = AVNOPTSVALUE; } s->lastscr = 0; return 0; fail: for(i=0;i<ctx->nbstreams;i++) { avfree(ctx->streams[i]->privdata); } return -ENOMEM; } ", "target": 1}
{"func": "static int mxfreadheader(AVFormatContext *s) { MXFContext *mxf = s->privdata; KLVPacket klv; int64t essenceoffset = 0; int ret; mxf->lastforwardtell = INT64MAX; mxf->editunitsperpacket = 1; if (!mxfreadsync(s->pb, mxfheaderpartitionpackkey, 14)) { avlog(s, AVLOGERROR, \"could not find header partition pack key\\n\"); return AVERRORINVALIDDATA; } avioseek(s->pb, -14, SEEKCUR); mxf->fc = s; mxf->runin = aviotell(s->pb); while (!urlfeof(s->pb)) { const MXFMetadataReadTableEntry *metadata; if (klvreadpacket(&klv, s->pb) < 0) { /* EOF - seek to previous partition or stop */ if(mxfparsehandlepartitionoreof(mxf) <= 0) break; else continue; } PRINTKEY(s, \"read header\", klv.key); avdlog(s, \"size %\"PRIu64\" offset %#\"PRIx64\"\\n\", klv.length, klv.offset); if (ISKLVKEY(klv.key, mxfencryptedtripletkey) || ISKLVKEY(klv.key, mxfessenceelementkey) || ISKLVKEY(klv.key, mxfavidessenceelementkey) || ISKLVKEY(klv.key, mxfsystemitemkey)) { if (!mxf->currentpartition) { avlog(mxf->fc, AVLOGERROR, \"found essence prior to first PartitionPack\\n\"); return AVERRORINVALIDDATA; } if (!mxf->currentpartition->essenceoffset) { /* for OP1a we compute essenceoffset * for OPAtom we point essenceoffset after the KL (usually op1aessenceoffset + 20 or 25) * TODO: for OP1a we could eliminate this entire if statement, always stopping parsing at op1aessenceoffset * for OPAtom we still need the actual essenceoffset though (the KL's length can vary) */ int64t op1aessenceoffset = roundtokag(mxf->currentpartition->thispartition + mxf->currentpartition->packlength, mxf->currentpartition->kagsize) + roundtokag(mxf->currentpartition->headerbytecount, mxf->currentpartition->kagsize) + roundtokag(mxf->currentpartition->indexbytecount, mxf->currentpartition->kagsize); if (mxf->op == OPAtom) { /* point essenceoffset to the actual data * OPAtom has all the essence in one big KLV */ mxf->currentpartition->essenceoffset = aviotell(s->pb); mxf->currentpartition->essencelength = klv.length; } else { /* NOTE: op1aessenceoffset may be less than to klv.offset (C0023S01.mxf) */ mxf->currentpartition->essenceoffset = op1aessenceoffset; } } if (!essenceoffset) essenceoffset = klv.offset; /* seek to footer, previous partition or stop */ if (mxfparsehandleessence(mxf) <= 0) break; continue; } else if (!memcmp(klv.key, mxfheaderpartitionpackkey, 13) && klv.key[13] >= 2 && klv.key[13] <= 4 && mxf->currentpartition) { /* next partition pack - keep going, seek to previous partition or stop */ if(mxfparsehandlepartitionoreof(mxf) <= 0) break; else if (mxf->parsingbackward) continue; /* we're still parsing forward. proceed to parsing this partition pack */ } for (metadata = mxfmetadatareadtable; metadata->read; metadata++) { if (ISKLVKEY(klv.key, metadata->key)) { int res; if (klv.key[5] == 0x53) { res = mxfreadlocaltags(mxf, &klv, metadata->read, metadata->ctxsize, metadata->type); } else { uint64t next = aviotell(s->pb) + klv.length; res = metadata->read(mxf, s->pb, 0, klv.length, klv.key, klv.offset); /* only seek forward, else this can loop for a long time */ if (aviotell(s->pb) > next) { avlog(s, AVLOGERROR, \"read past end of KLV @ %#\"PRIx64\"\\n\", klv.offset); return AVERRORINVALIDDATA; } avioseek(s->pb, next, SEEKSET); } if (res < 0) { avlog(s, AVLOGERROR, \"error reading header metadata\\n\"); return res; } break; } } if (!metadata->read) avioskip(s->pb, klv.length); } /* FIXME avoid seek */ if (!essenceoffset) { avlog(s, AVLOGERROR, \"no essence\\n\"); return AVERRORINVALIDDATA; } avioseek(s->pb, essenceoffset, SEEKSET); mxfcomputeessencecontainers(mxf); /* we need to do this before computing the index tables * to be able to fill in zero IndexDurations with st->duration */ if ((ret = mxfparsestructuralmetadata(mxf)) < 0) return ret; if ((ret = mxfcomputeindextables(mxf)) < 0) return ret; if (mxf->nbindextables > 1) { /* TODO: look up which IndexSID to use via EssenceContainerData */ avlog(mxf->fc, AVLOGINFO, \"got %i index tables - only the first one (IndexSID %i) will be used\\n\", mxf->nbindextables, mxf->indextables[0].indexsid); } else if (mxf->nbindextables == 0 && mxf->op == OPAtom) { avlog(mxf->fc, AVLOGERROR, \"cannot demux OPAtom without an index\\n\"); return AVERRORINVALIDDATA; } mxfhandlesmalleubc(s); return 0; } ", "target": 1}
{"func": "getneterrormessage(gint error) { HMODULE module = NULL; gchar *retval = NULL; wchart *msg = NULL; int flags; sizet nchars; flags = FORMATMESSAGEALLOCATEBUFFER | FORMATMESSAGEIGNOREINSERTS | FORMATMESSAGEFROMSYSTEM; if (error >= NERRBASE && error <= MAXNERR) { module = LoadLibraryExW(L\"netmsg.dll\", NULL, LOADLIBRARYASDATAFILE); if (module != NULL) { flags |= FORMATMESSAGEFROMHMODULE; } } FormatMessageW(flags, module, error, 0, (LPWSTR)&msg, 0, NULL); if (msg != NULL) { nchars = wcslen(msg); if (nchars > 2 && msg[nchars - 1] == L'\\n' && msg[nchars - 2] == L'\\r') { msg[nchars - 2] = L'\\0'; } retval = gutf16toutf8(msg, -1, NULL, NULL, NULL); LocalFree(msg); } if (module != NULL) { FreeLibrary(module); } return retval; } ", "target": 1}
{"func": "static void kqemurecordflush(void) { PCRecord *r, *rnext; int h; for(h = 0; h < PCRECHASHSIZE; h++) { for(r = pcrechash[h]; r != NULL; r = rnext) { rnext = r->next; free(r); } pcrechash[h] = NULL; } nbpcrecords = 0; } ", "target": 0}
{"func": "static void iscsiallocationmapset(IscsiLun *iscsilun, int64t sectornum, int nbsectors) { int64t clusternum, nbclusters; if (iscsilun->allocationmap == NULL) { return; } clusternum = sectornum / iscsilun->clustersectors; nbclusters = DIVROUNDUP(sectornum + nbsectors, iscsilun->clustersectors) - clusternum; bitmapset(iscsilun->allocationmap, clusternum, nbclusters); } ", "target": 0}
{"func": "int cpuexec(CPUArchState *env) { CPUState *cpu = ENVGETCPU(env); CPUClass *cc = CPUGETCLASS(cpu); #ifdef TARGETI386 X86CPU *x86cpu = X86CPU(cpu); #endif int ret, interruptrequest; TranslationBlock *tb; uint8t *tcptr; uintptrt nexttb; SyncClocks sc; /* This must be volatile so it is not trashed by longjmp() */ volatile bool havetblock = false; if (cpu->halted) { if (!cpuhaswork(cpu)) { return EXCPHALTED; } cpu->halted = 0; } currentcpu = cpu; /* As long as currentcpu is null, up to the assignment just above, * requests by other threads to exit the execution loop are expected to * be issued using the exitrequest global. We must make sure that our * evaluation of the global value is performed past the currentcpu * value transition point, which requires a memory barrier as well as * an instruction scheduling constraint on modern architectures. */ smpmb(); if (unlikely(exitrequest)) { cpu->exitrequest = 1; } cc->cpuexecenter(cpu); cpu->exceptionindex = -1; /* Calculate difference between guest clock and host clock. * This delay includes the delay of the last cycle, so * what we have to do is sleep until it is 0. As for the * advance/delay we gain here, we try to fix it next time. */ initdelayparams(&sc, cpu); /* prepare setjmp context for exception handling */ for(;;) { if (sigsetjmp(cpu->jmpenv, 0) == 0) { /* if an exception is pending, we execute it here */ if (cpu->exceptionindex >= 0) { if (cpu->exceptionindex >= EXCPINTERRUPT) { /* exit request from the cpu execution loop */ ret = cpu->exceptionindex; if (ret == EXCPDEBUG) { cpuhandledebugexception(env); } break; } else { #if defined(CONFIGUSERONLY) /* if user mode only, we simulate a fake exception which will be handled outside the cpu execution loop */ #if defined(TARGETI386) cc->dointerrupt(cpu); #endif ret = cpu->exceptionindex; break; #else cc->dointerrupt(cpu); cpu->exceptionindex = -1; #endif } } nexttb = 0; /* force lookup of first TB */ for(;;) { interruptrequest = cpu->interruptrequest; if (unlikely(interruptrequest)) { if (unlikely(cpu->singlestepenabled & SSTEPNOIRQ)) { /* Mask out external interrupts for this step. */ interruptrequest &= ~CPUINTERRUPTSSTEPMASK; } if (interruptrequest & CPUINTERRUPTDEBUG) { cpu->interruptrequest &= ~CPUINTERRUPTDEBUG; cpu->exceptionindex = EXCPDEBUG; cpuloopexit(cpu); } if (interruptrequest & CPUINTERRUPTHALT) { cpu->interruptrequest &= ~CPUINTERRUPTHALT; cpu->halted = 1; cpu->exceptionindex = EXCPHLT; cpuloopexit(cpu); } #if defined(TARGETI386) if (interruptrequest & CPUINTERRUPTINIT) { cpusvmcheckinterceptparam(env, SVMEXITINIT, 0); docpuinit(x86cpu); cpu->exceptionindex = EXCPHALTED; cpuloopexit(cpu); } #else if (interruptrequest & CPUINTERRUPTRESET) { cpureset(cpu); } #endif /* The target hook has 3 exit conditions: False when the interrupt isn't processed, True when it is, and we should restart on a new TB, and via longjmp via cpuloopexit. */ if (cc->cpuexecinterrupt(cpu, interruptrequest)) { nexttb = 0; } /* Don't use the cached interruptrequest value, dointerrupt may have updated the EXITTB flag. */ if (cpu->interruptrequest & CPUINTERRUPTEXITTB) { cpu->interruptrequest &= ~CPUINTERRUPTEXITTB; /* ensure that no TB jump will be modified as the program flow was changed */ nexttb = 0; } } if (unlikely(cpu->exitrequest)) { cpu->exitrequest = 0; cpu->exceptionindex = EXCPINTERRUPT; cpuloopexit(cpu); } spinlock(&tcgctx.tbctx.tblock); havetblock = true; tb = tbfindfast(env); /* Note: we do it here to avoid a gcc bug on Mac OS X when doing it in tbfindslow */ if (tcgctx.tbctx.tbinvalidatedflag) { /* as some TB could have been invalidated because of memory exceptions while generating the code, we must recompute the hash index here */ nexttb = 0; tcgctx.tbctx.tbinvalidatedflag = 0; } if (qemuloglevelmask(CPULOGEXEC)) { qemulog(\"Trace %p [\" TARGETFMTlx \"] %s\\n\", tb->tcptr, tb->pc, lookupsymbol(tb->pc)); } /* see if we can patch the calling TB. When the TB spans two pages, we cannot safely do a direct jump. */ if (nexttb != 0 && tb->pageaddr[1] == -1) { tbaddjump((TranslationBlock *)(nexttb & ~TBEXITMASK), nexttb & TBEXITMASK, tb); } havetblock = false; spinunlock(&tcgctx.tbctx.tblock); /* cpuinterrupt might be called while translating the TB, but before it is linked into a potentially infinite loop and becomes env->currenttb. Avoid starting execution if there is a pending interrupt. */ cpu->currenttb = tb; barrier(); if (likely(!cpu->exitrequest)) { traceexectb(tb, tb->pc); tcptr = tb->tcptr; /* execute the generated code */ nexttb = cputbexec(cpu, tcptr); switch (nexttb & TBEXITMASK) { case TBEXITREQUESTED: /* Something asked us to stop executing * chained TBs; just continue round the main * loop. Whatever requested the exit will also * have set something else (eg exitrequest or * interruptrequest) which we will handle * next time around the loop. */ tb = (TranslationBlock *)(nexttb & ~TBEXITMASK); nexttb = 0; break; case TBEXITICOUNTEXPIRED: { /* Instruction counter expired. */ int insnsleft; tb = (TranslationBlock *)(nexttb & ~TBEXITMASK); insnsleft = cpu->icountdecr.u32; if (cpu->icountextra && insnsleft >= 0) { /* Refill decrementer and continue execution. */ cpu->icountextra += insnsleft; if (cpu->icountextra > 0xffff) { insnsleft = 0xffff; } else { insnsleft = cpu->icountextra; } cpu->icountextra -= insnsleft; cpu->icountdecr.u16.low = insnsleft; } else { if (insnsleft > 0) { /* Execute remaining instructions. */ cpuexecnocache(env, insnsleft, tb); alignclocks(&sc, cpu); } cpu->exceptionindex = EXCPINTERRUPT; nexttb = 0; cpuloopexit(cpu); } break; } default: break; } } cpu->currenttb = NULL; /* Try to align the host and virtual clocks if the guest is in advance */ alignclocks(&sc, cpu); /* reset soft MMU for next block (it can currently only be set by a memory fault) */ } /* for(;;) */ } else { /* Reload env after longjmp - the compiler may have smashed all * local variables as longjmp is marked 'noreturn'. */ cpu = currentcpu; env = cpu->envptr; cc = CPUGETCLASS(cpu); #ifdef TARGETI386 x86cpu = X86CPU(cpu); #endif if (havetblock) { spinunlock(&tcgctx.tbctx.tblock); havetblock = false; } } } /* for(;;) */ cc->cpuexecexit(cpu); /* fail safe : never use currentcpu outside cpuexec() */ currentcpu = NULL; return ret; } ", "target": 0}
{"func": "static void testqemustrtoszmetric(void) { const char *str = \"12345k\"; char *endptr = NULL; int64t res; res = qemustrtoszmetric(str, &endptr); gassertcmpint(res, ==, 12345000); gassert(endptr == str + 6); } ", "target": 0}
{"func": "static inline void RENAME(yuv422ptoyuy2)(const uint8t *ysrc, const uint8t *usrc, const uint8t *vsrc, uint8t *dst, long width, long height, long lumStride, long chromStride, long dstStride) { RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1); } ", "target": 0}
{"func": "int ffh263decodemb(MpegEncContext *s, int16t block[6][64]) { int cbpc, cbpy, i, cbp, predx, predy, mx, my, dquant; int16t *motval; const int xy= s->mbx + s->mby * s->mbstride; int cbpb = 0, pbmvcount = 0; avassert2(!s->h263pred); if (s->picttype == AVPICTURETYPEP) { do{ if (getbits1(&s->gb)) { /* skip mb */ s->mbintra = 0; for(i=0;i<6;i++) s->blocklastindex[i] = -1; s->mvdir = MVDIRFORWARD; s->mvtype = MVTYPE16X16; s->currentpicture.mbtype[xy] = MBTYPESKIP | MBTYPE16x16 | MBTYPEL0; s->mv[0][0][0] = 0; s->mv[0][0][1] = 0; s->mbskipped = !(s->obmc | s->loopfilter); goto end; cbpc = getvlc2(&s->gb, ffh263interMCBPCvlc.table, INTERMCBPCVLCBITS, 2); if (cbpc < 0){ avlog(s->avctx, AVLOGERROR, \"cbpc damaged at %d %d\\n\", s->mbx, s->mby); }while(cbpc == 20); s->bdsp.clearblocks(s->block[0]); dquant = cbpc & 8; s->mbintra = ((cbpc & 4) != 0); if (s->mbintra) goto intra; if(s->pbframe && getbits1(&s->gb)) pbmvcount = h263getmodb(&s->gb, s->pbframe, &cbpb); cbpy = getvlc2(&s->gb, ffh263cbpyvlc.table, CBPYVLCBITS, 1); if(s->altintervlc==0 || (cbpc & 3)!=3) cbpy ^= 0xF; cbp = (cbpc & 3) | (cbpy << 2); if (dquant) { h263decodedquant(s); s->mvdir = MVDIRFORWARD; if ((cbpc & 16) == 0) { s->currentpicture.mbtype[xy] = MBTYPE16x16 | MBTYPEL0; /* 16x16 motion prediction */ s->mvtype = MVTYPE16X16; ffh263predmotion(s, 0, 0, &predx, &predy); if (s->umvplus) mx = h263pdecodeumotion(s, predx); else mx = ffh263decodemotion(s, predx, 1); if (mx >= 0xffff) if (s->umvplus) my = h263pdecodeumotion(s, predy); else my = ffh263decodemotion(s, predy, 1); if (my >= 0xffff) s->mv[0][0][0] = mx; s->mv[0][0][1] = my; if (s->umvplus && (mx - predx) == 1 && (my - predy) == 1) skipbits1(&s->gb); /* Bit stuffing to prevent PSC */ } else { s->currentpicture.mbtype[xy] = MBTYPE8x8 | MBTYPEL0; s->mvtype = MVTYPE8X8; for(i=0;i<4;i++) { motval = ffh263predmotion(s, i, 0, &predx, &predy); if (s->umvplus) mx = h263pdecodeumotion(s, predx); else mx = ffh263decodemotion(s, predx, 1); if (mx >= 0xffff) if (s->umvplus) my = h263pdecodeumotion(s, predy); else my = ffh263decodemotion(s, predy, 1); if (my >= 0xffff) s->mv[0][i][0] = mx; s->mv[0][i][1] = my; if (s->umvplus && (mx - predx) == 1 && (my - predy) == 1) skipbits1(&s->gb); /* Bit stuffing to prevent PSC */ motval[0] = mx; motval[1] = my; } else if(s->picttype==AVPICTURETYPEB) { int mbtype; const int stride= s->b8stride; int16t *motval0 = s->currentpicture.motionval[0][2 * (s->mbx + s->mby * stride)]; int16t *motval1 = s->currentpicture.motionval[1][2 * (s->mbx + s->mby * stride)]; // const int mvxy= s->mbx + 1 + s->mby * s->mbstride; //FIXME ugly motval0[0 ]= motval0[2 ]= motval0[0+2*stride]= motval0[2+2*stride]= motval0[1 ]= motval0[3 ]= motval0[1+2*stride]= motval0[3+2*stride]= motval1[0 ]= motval1[2 ]= motval1[0+2*stride]= motval1[2+2*stride]= motval1[1 ]= motval1[3 ]= motval1[1+2*stride]= motval1[3+2*stride]= 0; do{ mbtype= getvlc2(&s->gb, h263mbtypebvlc.table, H263MBTYPEBVLCBITS, 2); if (mbtype < 0){ avlog(s->avctx, AVLOGERROR, \"b mbtype damaged at %d %d\\n\", s->mbx, s->mby); mbtype= h263mbtypebmap[ mbtype ]; }while(!mbtype); s->mbintra = ISINTRA(mbtype); if(HASCBP(mbtype)){ s->bdsp.clearblocks(s->block[0]); cbpc = getvlc2(&s->gb, cbpcbvlc.table, CBPCBVLCBITS, 1); if(s->mbintra){ dquant = ISQUANT(mbtype); goto intra; cbpy = getvlc2(&s->gb, ffh263cbpyvlc.table, CBPYVLCBITS, 1); if (cbpy < 0){ avlog(s->avctx, AVLOGERROR, \"b cbpy damaged at %d %d\\n\", s->mbx, s->mby); if(s->altintervlc==0 || (cbpc & 3)!=3) cbpy ^= 0xF; cbp = (cbpc & 3) | (cbpy << 2); }else cbp=0; avassert2(!s->mbintra); if(ISQUANT(mbtype)){ h263decodedquant(s); if(ISDIRECT(mbtype)){ s->mvdir = MVDIRFORWARD | MVDIRBACKWARD | MVDIRECT; mbtype |= setdirectmv(s); }else{ s->mvdir = 0; s->mvtype= MVTYPE16X16; //FIXME UMV if(USESLIST(mbtype, 0)){ int16t *motval= ffh263predmotion(s, 0, 0, &predx, &predy); s->mvdir = MVDIRFORWARD; if (s->umvplus) mx = h263pdecodeumotion(s, predx); else mx = ffh263decodemotion(s, predx, 1); if (mx >= 0xffff) if (s->umvplus) my = h263pdecodeumotion(s, predy); else my = ffh263decodemotion(s, predy, 1); if (my >= 0xffff) if (s->umvplus && (mx - predx) == 1 && (my - predy) == 1) skipbits1(&s->gb); /* Bit stuffing to prevent PSC */ s->mv[0][0][0] = mx; s->mv[0][0][1] = my; motval[0 ]= motval[2 ]= motval[0+2*stride]= motval[2+2*stride]= mx; motval[1 ]= motval[3 ]= motval[1+2*stride]= motval[3+2*stride]= my; if(USESLIST(mbtype, 1)){ int16t *motval= ffh263predmotion(s, 0, 1, &predx, &predy); s->mvdir |= MVDIRBACKWARD; if (s->umvplus) mx = h263pdecodeumotion(s, predx); else mx = ffh263decodemotion(s, predx, 1); if (mx >= 0xffff) if (s->umvplus) my = h263pdecodeumotion(s, predy); else my = ffh263decodemotion(s, predy, 1); if (my >= 0xffff) if (s->umvplus && (mx - predx) == 1 && (my - predy) == 1) skipbits1(&s->gb); /* Bit stuffing to prevent PSC */ s->mv[1][0][0] = mx; s->mv[1][0][1] = my; motval[0 ]= motval[2 ]= motval[0+2*stride]= motval[2+2*stride]= mx; motval[1 ]= motval[3 ]= motval[1+2*stride]= motval[3+2*stride]= my; s->currentpicture.mbtype[xy] = mbtype; } else { /* I-Frame */ do{ cbpc = getvlc2(&s->gb, ffh263intraMCBPCvlc.table, INTRAMCBPCVLCBITS, 2); if (cbpc < 0){ avlog(s->avctx, AVLOGERROR, \"I cbpc damaged at %d %d\\n\", s->mbx, s->mby); }while(cbpc == 8); s->bdsp.clearblocks(s->block[0]); dquant = cbpc & 4; s->mbintra = 1; intra: s->currentpicture.mbtype[xy] = MBTYPEINTRA; if (s->h263aic) { s->acpred = getbits1(&s->gb); if(s->acpred){ s->currentpicture.mbtype[xy] = MBTYPEINTRA | MBTYPEACPRED; s->h263aicdir = getbits1(&s->gb); }else s->acpred = 0; if(s->pbframe && getbits1(&s->gb)) pbmvcount = h263getmodb(&s->gb, s->pbframe, &cbpb); cbpy = getvlc2(&s->gb, ffh263cbpyvlc.table, CBPYVLCBITS, 1); if(cbpy<0){ avlog(s->avctx, AVLOGERROR, \"I cbpy damaged at %d %d\\n\", s->mbx, s->mby); cbp = (cbpc & 3) | (cbpy << 2); if (dquant) { h263decodedquant(s); pbmvcount += !!s->pbframe; while(pbmvcount--){ ffh263decodemotion(s, 0, 1); ffh263decodemotion(s, 0, 1); /* decode each block */ for (i = 0; i < 6; i++) { if (h263decodeblock(s, block[i], i, cbp&32) < 0) return -1; cbp+=cbp; if(s->pbframe && h263skipbpart(s, cbpb) < 0) return -1; if(s->obmc && !s->mbintra){ if(s->picttype == AVPICTURETYPEP && s->mbx+1<s->mbwidth && s->mbnumleft != 1) previewobmc(s); end: /* per-MB end of slice check */ { int v= showbits(&s->gb, 16); if (getbitsleft(&s->gb) < 16) { v >>= 16 - getbitsleft(&s->gb); if(v==0) return SLICEEND; return SLICEOK;", "target": 1}
{"func": "static void DEF(put, pixels16x2)(uint8t *block, const uint8t *pixels, ptrdifft linesize, int h) { MOVQBFE(mm6); asm volatile( \"lea (%3, %3), %%\"REGa\" \\n\\t\" \".p2align 3 \\n\\t\" \"1: \\n\\t\" \"movq (%1), %%mm0 \\n\\t\" \"movq 1(%1), %%mm1 \\n\\t\" \"movq (%1, %3), %%mm2 \\n\\t\" \"movq 1(%1, %3), %%mm3 \\n\\t\" PAVGBP(%%mm0, %%mm1, %%mm4, %%mm2, %%mm3, %%mm5) \"movq %%mm4, (%2) \\n\\t\" \"movq %%mm5, (%2, %3) \\n\\t\" \"movq 8(%1), %%mm0 \\n\\t\" \"movq 9(%1), %%mm1 \\n\\t\" \"movq 8(%1, %3), %%mm2 \\n\\t\" \"movq 9(%1, %3), %%mm3 \\n\\t\" PAVGBP(%%mm0, %%mm1, %%mm4, %%mm2, %%mm3, %%mm5) \"movq %%mm4, 8(%2) \\n\\t\" \"movq %%mm5, 8(%2, %3) \\n\\t\" \"add %%\"REGa\", %1 \\n\\t\" \"add %%\"REGa\", %2 \\n\\t\" \"movq (%1), %%mm0 \\n\\t\" \"movq 1(%1), %%mm1 \\n\\t\" \"movq (%1, %3), %%mm2 \\n\\t\" \"movq 1(%1, %3), %%mm3 \\n\\t\" PAVGBP(%%mm0, %%mm1, %%mm4, %%mm2, %%mm3, %%mm5) \"movq %%mm4, (%2) \\n\\t\" \"movq %%mm5, (%2, %3) \\n\\t\" \"movq 8(%1), %%mm0 \\n\\t\" \"movq 9(%1), %%mm1 \\n\\t\" \"movq 8(%1, %3), %%mm2 \\n\\t\" \"movq 9(%1, %3), %%mm3 \\n\\t\" PAVGBP(%%mm0, %%mm1, %%mm4, %%mm2, %%mm3, %%mm5) \"movq %%mm4, 8(%2) \\n\\t\" \"movq %%mm5, 8(%2, %3) \\n\\t\" \"add %%\"REGa\", %1 \\n\\t\" \"add %%\"REGa\", %2 \\n\\t\" \"subl $4, %0 \\n\\t\" \"jnz 1b \\n\\t\" :\"+g\"(h), \"+S\"(pixels), \"+D\"(block) :\"r\"((x86reg)linesize) :REGa, \"memory\"); } ", "target": 0}
{"func": "int registersavevm(const char *idstr, int instanceid, int versionid, SaveStateHandler *savestate, LoadStateHandler *loadstate, void *opaque) { SaveStateEntry *se, **pse; se = qemumalloc(sizeof(SaveStateEntry)); if (!se) return -1; pstrcpy(se->idstr, sizeof(se->idstr), idstr); se->instanceid = (instanceid == -1) ? 0 : instanceid; se->versionid = versionid; se->savestate = savestate; se->loadstate = loadstate; se->opaque = opaque; se->next = NULL; /* add at the end of list */ pse = &firstse; while (*pse != NULL) { if (instanceid == -1 && strcmp(se->idstr, (*pse)->idstr) == 0 && se->instanceid <= (*pse)->instanceid) se->instanceid = (*pse)->instanceid + 1; pse = &(*pse)->next; } *pse = se; return 0; } ", "target": 1}
{"func": "static void armmptimerclassinit(ObjectClass *klass, void *data) { DeviceClass *dc = DEVICECLASS(klass); dc->realize = armmptimerrealize; dc->vmsd = &vmstatearmmptimer; dc->reset = armmptimerreset; dc->nouser = 1; dc->props = armmptimerproperties; } ", "target": 1}
{"func": "static int decodembcavlc(H264Context *h){ MpegEncContext * const s = &h->s; const int mbxy= s->mbx + s->mby*s->mbstride; int partitioncount; unsigned int mbtype, cbp; int dct8x8allowed= h->pps.transform8x8mode; s->dsp.clearblocks(h->mb); //FIXME avoid if already clear (move after skip handlong? tprintf(s->avctx, \"pic:%d mb:%d/%d\\n\", h->framenum, s->mbx, s->mby); cbp = 0; /* avoid warning. FIXME: find a solution without slowing down the code */ if(h->slicetype != ITYPE && h->slicetype != SITYPE){ if(s->mbskiprun==-1) s->mbskiprun= getuegolomb(&s->gb); if (s->mbskiprun--) { if(FRAMEMBAFF && (s->mby&1) == 0){ if(s->mbskiprun==0) h->mbmbaff = h->mbfielddecodingflag = getbits1(&s->gb); else predictfielddecodingflag(h); } decodembskip(h); return 0; } } if(FRAMEMBAFF){ if( (s->mby&1) == 0 ) h->mbmbaff = h->mbfielddecodingflag = getbits1(&s->gb); }else h->mbfielddecodingflag= (s->picturestructure!=PICTFRAME); h->prevmbskipped= 0; mbtype= getuegolomb(&s->gb); if(h->slicetype == BTYPE){ if(mbtype < 23){ partitioncount= bmbtypeinfo[mbtype].partitioncount; mbtype= bmbtypeinfo[mbtype].type; }else{ mbtype -= 23; goto decodeintramb; } }else if(h->slicetype == PTYPE /*|| h->slicetype == SPTYPE */){ if(mbtype < 5){ partitioncount= pmbtypeinfo[mbtype].partitioncount; mbtype= pmbtypeinfo[mbtype].type; }else{ mbtype -= 5; goto decodeintramb; } }else{ assert(h->slicetype == ITYPE); decodeintramb: if(mbtype > 25){ avlog(h->s.avctx, AVLOGERROR, \"mbtype %d in %c slice too large at %d %d\\n\", mbtype, avgetpicttypechar(h->slicetype), s->mbx, s->mby); return -1; } partitioncount=0; cbp= imbtypeinfo[mbtype].cbp; h->intra16x16predmode= imbtypeinfo[mbtype].predmode; mbtype= imbtypeinfo[mbtype].type; } if(MBFIELD) mbtype |= MBTYPEINTERLACED; h->slicetable[ mbxy ]= h->slicenum; if(ISINTRAPCM(mbtype)){ unsigned int x, y; // We assume these blocks are very rare so we do not optimize it. aligngetbits(&s->gb); // The pixels are stored in the same order as levels in h->mb array. for(y=0; y<16; y++){ const int index= 4*(y&3) + 32*((y>>2)&1) + 128*(y>>3); for(x=0; x<16; x++){ tprintf(s->avctx, \"LUMA ICPM LEVEL (%3d)\\n\", showbits(&s->gb, 8)); h->mb[index + (x&3) + 16*((x>>2)&1) + 64*(x>>3)]= getbits(&s->gb, 8); } } for(y=0; y<8; y++){ const int index= 256 + 4*(y&3) + 32*(y>>2); for(x=0; x<8; x++){ tprintf(s->avctx, \"CHROMA U ICPM LEVEL (%3d)\\n\", showbits(&s->gb, 8)); h->mb[index + (x&3) + 16*(x>>2)]= getbits(&s->gb, 8); } } for(y=0; y<8; y++){ const int index= 256 + 64 + 4*(y&3) + 32*(y>>2); for(x=0; x<8; x++){ tprintf(s->avctx, \"CHROMA V ICPM LEVEL (%3d)\\n\", showbits(&s->gb, 8)); h->mb[index + (x&3) + 16*(x>>2)]= getbits(&s->gb, 8); } } // In deblocking, the quantizer is 0 s->currentpicture.qscaletable[mbxy]= 0; h->chromaqp = getchromaqp(h->pps.chromaqpindexoffset, 0); // All coeffs are present memset(h->nonzerocount[mbxy], 16, 16); s->currentpicture.mbtype[mbxy]= mbtype; return 0; } if(MBMBAFF){ h->refcount[0] <<= 1; h->refcount[1] <<= 1; } fillcaches(h, mbtype, 0); //mbpred if(ISINTRA(mbtype)){ int predmode; // inittopleftavailability(h); if(ISINTRA4x4(mbtype)){ int i; int di = 1; if(dct8x8allowed && getbits1(&s->gb)){ mbtype |= MBTYPE8x8DCT; di = 4; } // fillintra4x4predtable(h); for(i=0; i<16; i+=di){ int mode= predintramode(h, i); if(!getbits1(&s->gb)){ const int remmode= getbits(&s->gb, 3); mode = remmode + (remmode >= mode); } if(di==4) fillrectangle( &h->intra4x4predmodecache[ scan8[i] ], 2, 2, 8, mode, 1 ); else h->intra4x4predmodecache[ scan8[i] ] = mode; } writebackintrapredmode(h); if( checkintra4x4predmode(h) < 0) return -1; }else{ h->intra16x16predmode= checkintrapredmode(h, h->intra16x16predmode); if(h->intra16x16predmode < 0) return -1; } predmode= checkintrapredmode(h, getuegolomb(&s->gb)); if(predmode < 0) return -1; h->chromapredmode= predmode; }else if(partitioncount==4){ int i, j, subpartitioncount[4], list, ref[2][4]; if(h->slicetype == BTYPE){ for(i=0; i<4; i++){ h->submbtype[i]= getuegolomb(&s->gb); if(h->submbtype[i] >=13){ avlog(h->s.avctx, AVLOGERROR, \"B submbtype %u out of range at %d %d\\n\", h->submbtype[i], s->mbx, s->mby); return -1; } subpartitioncount[i]= bsubmbtypeinfo[ h->submbtype[i] ].partitioncount; h->submbtype[i]= bsubmbtypeinfo[ h->submbtype[i] ].type; } if( ISDIRECT(h->submbtype[0]) || ISDIRECT(h->submbtype[1]) || ISDIRECT(h->submbtype[2]) || ISDIRECT(h->submbtype[3])) { preddirectmotion(h, &mbtype); h->refcache[0][scan8[4]] = h->refcache[1][scan8[4]] = h->refcache[0][scan8[12]] = h->refcache[1][scan8[12]] = PARTNOTAVAILABLE; } }else{ assert(h->slicetype == PTYPE || h->slicetype == SPTYPE); //FIXME SP correct ? for(i=0; i<4; i++){ h->submbtype[i]= getuegolomb(&s->gb); if(h->submbtype[i] >=4){ avlog(h->s.avctx, AVLOGERROR, \"P submbtype %u out of range at %d %d\\n\", h->submbtype[i], s->mbx, s->mby); return -1; } subpartitioncount[i]= psubmbtypeinfo[ h->submbtype[i] ].partitioncount; h->submbtype[i]= psubmbtypeinfo[ h->submbtype[i] ].type; } } for(list=0; list<h->listcount; list++){ int refcount= ISREF0(mbtype) ? 1 : h->refcount[list]; for(i=0; i<4; i++){ if(ISDIRECT(h->submbtype[i])) continue; if(ISDIR(h->submbtype[i], 0, list)){ unsigned int tmp = gette0golomb(&s->gb, refcount); //FIXME init to 0 before and skip? if(tmp>=refcount){ avlog(h->s.avctx, AVLOGERROR, \"ref %u overflow\\n\", tmp); return -1; } ref[list][i]= tmp; }else{ //FIXME ref[list][i] = -1; } } } if(dct8x8allowed) dct8x8allowed = getdct8x8allowed(h); for(list=0; list<h->listcount; list++){ for(i=0; i<4; i++){ if(ISDIRECT(h->submbtype[i])) { h->refcache[list][ scan8[4*i] ] = h->refcache[list][ scan8[4*i]+1 ]; continue; } h->refcache[list][ scan8[4*i] ]=h->refcache[list][ scan8[4*i]+1 ]= h->refcache[list][ scan8[4*i]+8 ]=h->refcache[list][ scan8[4*i]+9 ]= ref[list][i]; if(ISDIR(h->submbtype[i], 0, list)){ const int submbtype= h->submbtype[i]; const int blockwidth= (submbtype & (MBTYPE16x16|MBTYPE16x8)) ? 2 : 1; for(j=0; j<subpartitioncount[i]; j++){ int mx, my; const int index= 4*i + blockwidth*j; int16t (* mvcache)[2]= &h->mvcache[list][ scan8[index] ]; predmotion(h, index, blockwidth, list, h->refcache[list][ scan8[index] ], &mx, &my); mx += getsegolomb(&s->gb); my += getsegolomb(&s->gb); tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my); if(ISSUB8X8(submbtype)){ mvcache[ 1 ][0]= mvcache[ 8 ][0]= mvcache[ 9 ][0]= mx; mvcache[ 1 ][1]= mvcache[ 8 ][1]= mvcache[ 9 ][1]= my; }else if(ISSUB8X4(submbtype)){ mvcache[ 1 ][0]= mx; mvcache[ 1 ][1]= my; }else if(ISSUB4X8(submbtype)){ mvcache[ 8 ][0]= mx; mvcache[ 8 ][1]= my; } mvcache[ 0 ][0]= mx; mvcache[ 0 ][1]= my; } }else{ uint32t *p= (uint32t *)&h->mvcache[list][ scan8[4*i] ][0]; p[0] = p[1]= p[8] = p[9]= 0; } } } }else if(ISDIRECT(mbtype)){ preddirectmotion(h, &mbtype); dct8x8allowed &= h->sps.direct8x8inferenceflag; }else{ int list, mx, my, i; //FIXME we should set refidxl? to 0 if we use that later ... if(IS16X16(mbtype)){ for(list=0; list<h->listcount; list++){ unsigned int val; if(ISDIR(mbtype, 0, list)){ val= gette0golomb(&s->gb, h->refcount[list]); if(val >= h->refcount[list]){ avlog(h->s.avctx, AVLOGERROR, \"ref %u overflow\\n\", val); return -1; } }else val= LISTNOTUSED&0xFF; fillrectangle(&h->refcache[list][ scan8[0] ], 4, 4, 8, val, 1); } for(list=0; list<h->listcount; list++){ unsigned int val; if(ISDIR(mbtype, 0, list)){ predmotion(h, 0, 4, list, h->refcache[list][ scan8[0] ], &mx, &my); mx += getsegolomb(&s->gb); my += getsegolomb(&s->gb); tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my); val= pack16to32(mx,my); }else val=0; fillrectangle(h->mvcache[list][ scan8[0] ], 4, 4, 8, val, 4); } } else if(IS16X8(mbtype)){ for(list=0; list<h->listcount; list++){ for(i=0; i<2; i++){ unsigned int val; if(ISDIR(mbtype, i, list)){ val= gette0golomb(&s->gb, h->refcount[list]); if(val >= h->refcount[list]){ avlog(h->s.avctx, AVLOGERROR, \"ref %u overflow\\n\", val); return -1; } }else val= LISTNOTUSED&0xFF; fillrectangle(&h->refcache[list][ scan8[0] + 16*i ], 4, 2, 8, val, 1); } } for(list=0; list<h->listcount; list++){ for(i=0; i<2; i++){ unsigned int val; if(ISDIR(mbtype, i, list)){ pred16x8motion(h, 8*i, list, h->refcache[list][scan8[0] + 16*i], &mx, &my); mx += getsegolomb(&s->gb); my += getsegolomb(&s->gb); tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my); val= pack16to32(mx,my); }else val=0; fillrectangle(h->mvcache[list][ scan8[0] + 16*i ], 4, 2, 8, val, 4); } } }else{ assert(IS8X16(mbtype)); for(list=0; list<h->listcount; list++){ for(i=0; i<2; i++){ unsigned int val; if(ISDIR(mbtype, i, list)){ //FIXME optimize val= gette0golomb(&s->gb, h->refcount[list]); if(val >= h->refcount[list]){ avlog(h->s.avctx, AVLOGERROR, \"ref %u overflow\\n\", val); return -1; } }else val= LISTNOTUSED&0xFF; fillrectangle(&h->refcache[list][ scan8[0] + 2*i ], 2, 4, 8, val, 1); } } for(list=0; list<h->listcount; list++){ for(i=0; i<2; i++){ unsigned int val; if(ISDIR(mbtype, i, list)){ pred8x16motion(h, i*4, list, h->refcache[list][ scan8[0] + 2*i ], &mx, &my); mx += getsegolomb(&s->gb); my += getsegolomb(&s->gb); tprintf(s->avctx, \"final mv:%d %d\\n\", mx, my); val= pack16to32(mx,my); }else val=0; fillrectangle(h->mvcache[list][ scan8[0] + 2*i ], 2, 4, 8, val, 4); } } } } if(ISINTER(mbtype)) writebackmotion(h, mbtype); if(!ISINTRA16x16(mbtype)){ cbp= getuegolomb(&s->gb); if(cbp > 47){ avlog(h->s.avctx, AVLOGERROR, \"cbp too large (%u) at %d %d\\n\", cbp, s->mbx, s->mby); return -1; } if(ISINTRA4x4(mbtype)) cbp= golombtointra4x4cbp[cbp]; else cbp= golombtointercbp[cbp]; } h->cbp = cbp; if(dct8x8allowed && (cbp&15) && !ISINTRA(mbtype)){ if(getbits1(&s->gb)) mbtype |= MBTYPE8x8DCT; } s->currentpicture.mbtype[mbxy]= mbtype; if(cbp || ISINTRA16x16(mbtype)){ int i8x8, i4x4, chromaidx; int chromaqp, dquant; GetBitContext *gb= ISINTRA(mbtype) ? h->intragbptr : h->intergbptr; const uint8t *scan, *scan8x8, *dcscan; // fillnonzerocountcache(h); if(ISINTERLACED(mbtype)){ scan8x8= s->qscale ? h->fieldscan8x8cavlc : h->fieldscan8x8cavlcq0; scan= s->qscale ? h->fieldscan : h->fieldscanq0; dcscan= lumadcfieldscan; }else{ scan8x8= s->qscale ? h->zigzagscan8x8cavlc : h->zigzagscan8x8cavlcq0; scan= s->qscale ? h->zigzagscan : h->zigzagscanq0; dcscan= lumadczigzagscan; } dquant= getsegolomb(&s->gb); if( dquant > 25 || dquant < -26 ){ avlog(h->s.avctx, AVLOGERROR, \"dquant out of range (%d) at %d %d\\n\", dquant, s->mbx, s->mby); return -1; } s->qscale += dquant; if(((unsigned)s->qscale) > 51){ if(s->qscale<0) s->qscale+= 52; else s->qscale-= 52; } h->chromaqp= chromaqp= getchromaqp(h->pps.chromaqpindexoffset, s->qscale); if(ISINTRA16x16(mbtype)){ if( decoderesidual(h, h->intragbptr, h->mb, LUMADCBLOCKINDEX, dcscan, h->dequant4coeff[0][s->qscale], 16) < 0){ return -1; //FIXME continue if partitioned and other return -1 too } assert((cbp&15) == 0 || (cbp&15) == 15); if(cbp&15){ for(i8x8=0; i8x8<4; i8x8++){ for(i4x4=0; i4x4<4; i4x4++){ const int index= i4x4 + 4*i8x8; if( decoderesidual(h, h->intragbptr, h->mb + 16*index, index, scan + 1, h->dequant4coeff[0][s->qscale], 15) < 0 ){ return -1; } } } }else{ fillrectangle(&h->nonzerocountcache[scan8[0]], 4, 4, 8, 0, 1); } }else{ for(i8x8=0; i8x8<4; i8x8++){ if(cbp & (1<<i8x8)){ if(IS8x8DCT(mbtype)){ DCTELEM *buf = &h->mb[64*i8x8]; uint8t *nnz; for(i4x4=0; i4x4<4; i4x4++){ if( decoderesidual(h, gb, buf, i4x4+4*i8x8, scan8x8+16*i4x4, h->dequant8coeff[ISINTRA( mbtype ) ? 0:1][s->qscale], 16) <0 ) return -1; } nnz= &h->nonzerocountcache[ scan8[4*i8x8] ]; nnz[0] += nnz[1] + nnz[8] + nnz[9]; }else{ for(i4x4=0; i4x4<4; i4x4++){ const int index= i4x4 + 4*i8x8; if( decoderesidual(h, gb, h->mb + 16*index, index, scan, h->dequant4coeff[ISINTRA( mbtype ) ? 0:3][s->qscale], 16) <0 ){ return -1; } } } }else{ uint8t * const nnz= &h->nonzerocountcache[ scan8[4*i8x8] ]; nnz[0] = nnz[1] = nnz[8] = nnz[9] = 0; } } } if(cbp&0x30){ for(chromaidx=0; chromaidx<2; chromaidx++) if( decoderesidual(h, gb, h->mb + 256 + 16*4*chromaidx, CHROMADCBLOCKINDEX, chromadcscan, NULL, 4) < 0){ return -1; } } if(cbp&0x20){ for(chromaidx=0; chromaidx<2; chromaidx++){ const uint32t *qmul = h->dequant4coeff[chromaidx+1+(ISINTRA( mbtype ) ? 0:3)][chromaqp]; for(i4x4=0; i4x4<4; i4x4++){ const int index= 16 + 4*chromaidx + i4x4; if( decoderesidual(h, gb, h->mb + 16*index, index, scan + 1, qmul, 15) < 0){ return -1; } } } }else{ uint8t * const nnz= &h->nonzerocountcache[0]; nnz[ scan8[16]+0 ] = nnz[ scan8[16]+1 ] =nnz[ scan8[16]+8 ] =nnz[ scan8[16]+9 ] = nnz[ scan8[20]+0 ] = nnz[ scan8[20]+1 ] =nnz[ scan8[20]+8 ] =nnz[ scan8[20]+9 ] = 0; } }else{ uint8t * const nnz= &h->nonzerocountcache[0]; fillrectangle(&nnz[scan8[0]], 4, 4, 8, 0, 1); nnz[ scan8[16]+0 ] = nnz[ scan8[16]+1 ] =nnz[ scan8[16]+8 ] =nnz[ scan8[16]+9 ] = nnz[ scan8[20]+0 ] = nnz[ scan8[20]+1 ] =nnz[ scan8[20]+8 ] =nnz[ scan8[20]+9 ] = 0; } s->currentpicture.qscaletable[mbxy]= s->qscale; writebacknonzerocount(h); if(MBMBAFF){ h->refcount[0] >>= 1; h->refcount[1] >>= 1; } return 0; } ", "target": 1}
{"func": "void pcidefaultwriteconfig(PCIDevice *d, uint32t address, uint32t val, int len) { int canwrite, i; uint32t end, addr; if (len == 4 && ((address >= 0x10 && address < 0x10 + 4 * 6) || (address >= 0x30 && address < 0x34))) { PCIIORegion *r; int reg; if ( address >= 0x30 ) { reg = PCIROMSLOT; }else{ reg = (address - 0x10) >> 2; } r = &d->ioregions[reg]; if (r->size == 0) goto defaultconfig; /* compute the stored value */ if (reg == PCIROMSLOT) { /* keep ROM enable bit */ val &= (~(r->size - 1)) | 1; } else { val &= ~(r->size - 1); val |= r->type; } *(uint32t *)(d->config + address) = cputole32(val); pciupdatemappings(d); return; } defaultconfig: /* not efficient, but simple */ addr = address; for(i = 0; i < len; i++) { /* default read/write accesses */ switch(d->config[0x0e]) { case 0x00: case 0x80: switch(addr) { case 0x00: case 0x01: case 0x02: case 0x03: case 0x08: case 0x09: case 0x0a: case 0x0b: case 0x0e: case 0x10 ... 0x27: /* base */ case 0x30 ... 0x33: /* rom */ case 0x3d: canwrite = 0; break; default: canwrite = 1; break; } break; default: case 0x01: switch(addr) { case 0x00: case 0x01: case 0x02: case 0x03: case 0x08: case 0x09: case 0x0a: case 0x0b: case 0x0e: case 0x38 ... 0x3b: /* rom */ case 0x3d: canwrite = 0; break; default: canwrite = 1; break; } break; } if (canwrite) { d->config[addr] = val; } addr++; val >>= 8; } end = address + len; if (end > PCICOMMAND && address < (PCICOMMAND + 2)) { /* if the command register is modified, we must modify the mappings */ pciupdatemappings(d); } } ", "target": 1}
{"func": "static int decodetrnschunk(AVCodecContext *avctx, PNGDecContext *s, uint32t length) { int v, i; if (s->colortype == PNGCOLORTYPEPALETTE) { if (length > 256 || !(s->state & PNGPLTE)) return AVERRORINVALIDDATA; for (i = 0; i < length; i++) { v = bytestream2getbyte(&s->gb); s->palette[i] = (s->palette[i] & 0x00ffffff) | (v << 24); } } else if (s->colortype == PNGCOLORTYPEGRAY || s->colortype == PNGCOLORTYPERGB) { if ((s->colortype == PNGCOLORTYPEGRAY && length != 2) || (s->colortype == PNGCOLORTYPERGB && length != 6)) return AVERRORINVALIDDATA; for (i = 0; i < length / 2; i++) { /* only use the least significant bits */ v = avmoduintp2(bytestream2getbe16(&s->gb), s->bitdepth); if (s->bitdepth > 8) AVWB16(&s->transparentcolorbe[2 * i], v); else s->transparentcolorbe[i] = v; } } else { return AVERRORINVALIDDATA; } bytestream2skip(&s->gb, 4); /* crc */ s->hastrns = 1; return 0; } ", "target": 1}
{"func": "static inline int wvgetvalueinteger(WavpackFrameContext *s, uint32t *crc, int S) { unsigned bit; if (s->extrabits) { S <<= s->extrabits; if (s->gotextrabits && getbitsleft(&s->gbextrabits) >= s->extrabits) { S |= getbitslong(&s->gbextrabits, s->extrabits); *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16); } } bit = (S & s->and) | s->or; bit = ((S + bit) << s->shift) - bit; if (s->hybrid) bit = avclip(bit, s->hybridminclip, s->hybridmaxclip); return bit << s->postshift; } ", "target": 1}
{"func": "targetulong helperldl(CPUMIPSState *env, targetulong arg1, targetulong arg2, int memidx) { uint64t tmp; tmp = dolbu(env, arg2, memidx); arg1 = (arg1 & 0x00FFFFFFFFFFFFFFULL) | (tmp << 56); if (GETLMASK64(arg2) <= 6) { tmp = dolbu(env, GETOFFSET(arg2, 1), memidx); arg1 = (arg1 & 0xFF00FFFFFFFFFFFFULL) | (tmp << 48); } if (GETLMASK64(arg2) <= 5) { tmp = dolbu(env, GETOFFSET(arg2, 2), memidx); arg1 = (arg1 & 0xFFFF00FFFFFFFFFFULL) | (tmp << 40); } if (GETLMASK64(arg2) <= 4) { tmp = dolbu(env, GETOFFSET(arg2, 3), memidx); arg1 = (arg1 & 0xFFFFFF00FFFFFFFFULL) | (tmp << 32); } if (GETLMASK64(arg2) <= 3) { tmp = dolbu(env, GETOFFSET(arg2, 4), memidx); arg1 = (arg1 & 0xFFFFFFFF00FFFFFFULL) | (tmp << 24); } if (GETLMASK64(arg2) <= 2) { tmp = dolbu(env, GETOFFSET(arg2, 5), memidx); arg1 = (arg1 & 0xFFFFFFFFFF00FFFFULL) | (tmp << 16); } if (GETLMASK64(arg2) <= 1) { tmp = dolbu(env, GETOFFSET(arg2, 6), memidx); arg1 = (arg1 & 0xFFFFFFFFFFFF00FFULL) | (tmp << 8); } if (GETLMASK64(arg2) == 0) { tmp = dolbu(env, GETOFFSET(arg2, 7), memidx); arg1 = (arg1 & 0xFFFFFFFFFFFFFF00ULL) | tmp; } return arg1; } ", "target": 1}
{"func": "static int loadmatrix(MpegEncContext *s, uint16t matrix0[64], uint16t matrix1[64], int intra) { int i; for (i = 0; i < 64; i++) { int j = s->dsp.idctpermutation[ffzigzagdirect[i]]; int v = getbits(&s->gb, 8); if (v == 0) { avlog(s->avctx, AVLOGERROR, \"matrix damaged\\n\"); return -1; } if (intra && i == 0 && v != 8) { avlog(s->avctx, AVLOGERROR, \"intra matrix specifies invalid DC quantizer %d, ignoring\\n\", v); v = 8; // needed by pink.mpg / issue1046 } matrix0[j] = v; if (matrix1) matrix1[j] = v; } return 0; } ", "target": 0}
{"func": "static void childhandler(int sig) { int status; while (waitpid(-1, &status, WNOHANG) > 0) /* NOTHING */; } ", "target": 1}
{"func": "static int copyfrom(IpvideoContext *s, AVFrame *src, AVFrame *dst, int deltax, int deltay) { int currentoffset = s->pixelptr - dst->data[0]; int motionoffset = currentoffset + deltay * dst->linesize[0] + deltax * (1 + s->is16bpp); if (motionoffset < 0) { avlog(s->avctx, AVLOGERROR, \" Interplay video: motion offset < 0 (%d)\\n\", motionoffset); return AVERRORINVALIDDATA; } else if (motionoffset > s->uppermotionlimitoffset) { avlog(s->avctx, AVLOGERROR, \" Interplay video: motion offset above limit (%d >= %d)\\n\", motionoffset, s->uppermotionlimitoffset); return AVERRORINVALIDDATA; } if (src->data[0] == NULL) { avlog(s->avctx, AVLOGERROR, \"Invalid decode type, corrupted header?\\n\"); return AVERROR(EINVAL); } s->hdsp.putpixelstab[!s->is16bpp][0](s->pixelptr, src->data[0] + motionoffset, dst->linesize[0], 8); return 0; } ", "target": 0}
{"func": "static void imxepitreset(DeviceState *dev) { IMXEPITState *s = IMXEPIT(dev); /* * Soft reset doesn't touch some bits; hard reset clears them */ s->cr &= (CREN|CRENMOD|CRSTOPEN|CRDOZEN|CRWAITEN|CRDBGEN); s->sr = 0; s->lr = TIMERMAX; s->cmp = 0; s->cnt = 0; /* stop both timers */ ptimerstop(s->timercmp); ptimerstop(s->timerreload); /* compute new frequency */ imxepitsetfreq(s); /* init both timers to TIMERMAX */ ptimersetlimit(s->timercmp, TIMERMAX, 1); ptimersetlimit(s->timerreload, TIMERMAX, 1); if (s->freq && (s->cr & CREN)) { /* if the timer is still enabled, restart it */ ptimerrun(s->timerreload, 0); } } ", "target": 0}
{"func": "static void quittimers(void) { alarmtimer->stop(alarmtimer); alarmtimer = NULL; } ", "target": 0}
{"func": "static int coroutinefn bdrvalignedpwritev(BdrvChild *child, BdrvTrackedRequest *req, int64t offset, unsigned int bytes, int64t align, QEMUIOVector *qiov, int flags) { BlockDriverState *bs = child->bs; BlockDriver *drv = bs->drv; bool waited; int ret; int64t endsector = DIVROUNDUP(offset + bytes, BDRVSECTORSIZE); uint64t bytesremaining = bytes; int maxtransfer; if (bdrvhasreadonlybitmaps(bs)) { return -EPERM; assert(ispowerof2(align)); assert((offset & (align - 1)) == 0); assert((bytes & (align - 1)) == 0); assert(!qiov || bytes == qiov->size); assert((bs->openflags & BDRVONOIO) == 0); assert(!(flags & ~BDRVREQMASK)); maxtransfer = QEMUALIGNDOWN(MINNONZERO(bs->bl.maxtransfer, INTMAX), align); waited = waitserialisingrequests(req); assert(!waited || !req->serialising); assert(req->overlapoffset <= offset); assert(offset + bytes <= req->overlapoffset + req->overlapbytes); assert(child->perm & BLKPERMWRITE); assert(endsector <= bs->totalsectors || child->perm & BLKPERMRESIZE); ret = notifierwithreturnlistnotify(&bs->beforewritenotifiers, req); if (!ret && bs->detectzeroes != BLOCKDEVDETECTZEROESOPTIONSOFF && !(flags & BDRVREQZEROWRITE) && drv->bdrvcopwritezeroes && qemuioveciszero(qiov)) { flags |= BDRVREQZEROWRITE; if (bs->detectzeroes == BLOCKDEVDETECTZEROESOPTIONSUNMAP) { flags |= BDRVREQMAYUNMAP; if (ret < 0) { /* Do nothing, write notifier decided to fail this request */ } else if (flags & BDRVREQZEROWRITE) { bdrvdebugevent(bs, BLKDBGPWRITEVZERO); ret = bdrvcodopwritezeroes(bs, offset, bytes, flags); } else if (flags & BDRVREQWRITECOMPRESSED) { ret = bdrvdriverpwritevcompressed(bs, offset, bytes, qiov); } else if (bytes <= maxtransfer) { bdrvdebugevent(bs, BLKDBGPWRITEV); ret = bdrvdriverpwritev(bs, offset, bytes, qiov, flags); } else { bdrvdebugevent(bs, BLKDBGPWRITEV); while (bytesremaining) { int num = MIN(bytesremaining, maxtransfer); QEMUIOVector localqiov; int localflags = flags; assert(num); if (num < bytesremaining && (flags & BDRVREQFUA) && !(bs->supportedwriteflags & BDRVREQFUA)) { /* If FUA is going to be emulated by flush, we only * need to flush on the last iteration */ localflags &= ~BDRVREQFUA; qemuiovecinit(&localqiov, qiov->niov); qemuiovecconcat(&localqiov, qiov, bytes - bytesremaining, num); ret = bdrvdriverpwritev(bs, offset + bytes - bytesremaining, num, &localqiov, localflags); qemuiovecdestroy(&localqiov); if (ret < 0) { break; bytesremaining -= num; bdrvdebugevent(bs, BLKDBGPWRITEVDONE); atomicinc(&bs->writegen); bdrvsetdirty(bs, offset, bytes); stat64max(&bs->wrhighestoffset, offset + bytes); if (ret >= 0) { bs->totalsectors = MAX(bs->totalsectors, endsector); ret = 0; return ret;", "target": 1}
{"func": "static BlockDriverAIOCB *rawaioread(BlockDriverState *bs, int64t sectornum, uint8t *buf, int nbsectors, BlockDriverCompletionFunc *cb, void *opaque) { RawAIOCB *acb; /* * If ODIRECT is used and the buffer is not aligned fall back * to synchronous IO. */ BDRVRawState *s = bs->opaque; if (unlikely(s->alignedbuf != NULL && ((uintptrt) buf % 512))) { QEMUBH *bh; acb = qemuaioget(bs, cb, opaque); acb->ret = rawpread(bs, 512 * sectornum, buf, 512 * nbsectors); bh = qemubhnew(rawaioemcb, acb); qemubhschedule(bh); return &acb->common; } acb = rawaiosetup(bs, sectornum, buf, nbsectors, cb, opaque); if (!acb) return NULL; if (aioread(&acb->aiocb) < 0) { qemuaiorelease(acb); return NULL; } return &acb->common; } ", "target": 0}
{"func": "static int coroutinefn bdrvcodoreadv(BdrvChild *child, int64t sectornum, int nbsectors, QEMUIOVector *qiov, BdrvRequestFlags flags) { if (nbsectors < 0 || nbsectors > BDRVREQUESTMAXSECTORS) { return -EINVAL; } return bdrvcopreadv(child->bs, sectornum << BDRVSECTORBITS, nbsectors << BDRVSECTORBITS, qiov, flags); } ", "target": 0}
{"func": "static void sigchldhandler(int signal) { qemubhschedule(sigchldbh); } ", "target": 0}
{"func": "static PESContext *addpesstream(MpegTSContext *ts, int pid, int pcrpid, int streamtype) { MpegTSFilter *tss; PESContext *pes; /* if no pid found, then add a pid context */ pes = avmallocz(sizeof(PESContext)); if (!pes) return 0; pes->ts = ts; pes->stream = ts->stream; pes->pid = pid; pes->pcrpid = pcrpid; pes->streamtype = streamtype; pes->state = MPEGTSSKIP; pes->pts = AVNOPTSVALUE; pes->dts = AVNOPTSVALUE; tss = mpegtsopenpesfilter(ts, pid, mpegtspushdata, pes); if (!tss) { avfree(pes); return 0; } return pes; } ", "target": 0}
{"func": "void mpegmotioninternal(MpegEncContext *s, uint8t *desty, uint8t *destcb, uint8t *destcr, int fieldbased, int bottomfield, int fieldselect, uint8t **refpicture, oppixelsfunc (*pixop)[4], int motionx, int motiony, int h, int ismpeg12, int mby) { uint8t *ptry, *ptrcb, *ptrcr; int dxy, uvdxy, mx, my, srcx, srcy, uvsrcx, uvsrcy, vedgepos; emuedgelinesizetype uvlinesize, linesize; #if 0 if(s->quartersample) { motionx>>=1; motiony>>=1; } #endif vedgepos = s->vedgepos >> fieldbased; linesize = s->currentpicture.f.linesize[0] << fieldbased; uvlinesize = s->currentpicture.f.linesize[1] << fieldbased; dxy = ((motiony & 1) << 1) | (motionx & 1); srcx = s->mbx* 16 + (motionx >> 1); srcy =( mby<<(4-fieldbased)) + (motiony >> 1); if (!ismpeg12 && s->outformat == FMTH263) { if((s->workaroundbugs & FFBUGHPELCHROMA) && fieldbased){ mx = (motionx>>1)|(motionx&1); my = motiony >>1; uvdxy = ((my & 1) << 1) | (mx & 1); uvsrcx = s->mbx* 8 + (mx >> 1); uvsrcy =( mby<<(3-fieldbased))+ (my >> 1); }else{ uvdxy = dxy | (motiony & 2) | ((motionx & 2) >> 1); uvsrcx = srcx>>1; uvsrcy = srcy>>1; } }else if(!ismpeg12 && s->outformat == FMTH261){//even chroma mv's are full pel in H261 mx = motionx / 4; my = motiony / 4; uvdxy = 0; uvsrcx = s->mbx*8 + mx; uvsrcy = mby*8 + my; } else { if(s->chromayshift){ mx = motionx / 2; my = motiony / 2; uvdxy = ((my & 1) << 1) | (mx & 1); uvsrcx = s->mbx* 8 + (mx >> 1); uvsrcy =( mby<<(3-fieldbased))+ (my >> 1); } else { if(s->chromaxshift){ //Chroma422 mx = motionx / 2; uvdxy = ((motiony & 1) << 1) | (mx & 1); uvsrcx = s->mbx* 8 + (mx >> 1); uvsrcy = srcy; } else { //Chroma444 uvdxy = dxy; uvsrcx = srcx; uvsrcy = srcy; } } } ptry = refpicture[0] + srcy * linesize + srcx; ptrcb = refpicture[1] + uvsrcy * uvlinesize + uvsrcx; ptrcr = refpicture[2] + uvsrcy * uvlinesize + uvsrcx; if( (unsigned)srcx > FFMAX(s->hedgepos - (motionx&1) - 16, 0) || (unsigned)srcy > FFMAX( vedgepos - (motiony&1) - h , 0)){ if(ismpeg12 || s->codecid == AVCODECIDMPEG2VIDEO || s->codecid == AVCODECIDMPEG1VIDEO){ avlog(s->avctx,AVLOGDEBUG, \"MPEG motion vector out of boundary (%d %d)\\n\", srcx, srcy); return; } s->vdsp.emulatededgemc(s->edgeemubuffer, ptry, s->linesize, 17, 17+fieldbased, srcx, srcy<<fieldbased, s->hedgepos, s->vedgepos); ptry = s->edgeemubuffer; if(!CONFIGGRAY || !(s->flags&CODECFLAGGRAY)){ uint8t *uvbuf= s->edgeemubuffer+18*s->linesize; s->vdsp.emulatededgemc(uvbuf , ptrcb, s->uvlinesize, 9, 9+fieldbased, uvsrcx, uvsrcy<<fieldbased, s->hedgepos>>1, s->vedgepos>>1); s->vdsp.emulatededgemc(uvbuf+16, ptrcr, s->uvlinesize, 9, 9+fieldbased, uvsrcx, uvsrcy<<fieldbased, s->hedgepos>>1, s->vedgepos>>1); ptrcb= uvbuf; ptrcr= uvbuf+16; } } if(bottomfield){ //FIXME use this for field pix too instead of the obnoxious hack which changes picture.data desty += s->linesize; destcb+= s->uvlinesize; destcr+= s->uvlinesize; } if(fieldselect){ ptry += s->linesize; ptrcb+= s->uvlinesize; ptrcr+= s->uvlinesize; } pixop[0][dxy](desty, ptry, linesize, h); if(!CONFIGGRAY || !(s->flags&CODECFLAGGRAY)){ pixop[s->chromaxshift][uvdxy] (destcb, ptrcb, uvlinesize, h >> s->chromayshift); pixop[s->chromaxshift][uvdxy] (destcr, ptrcr, uvlinesize, h >> s->chromayshift); } if(!ismpeg12 && (CONFIGH261ENCODER || CONFIGH261DECODER) && s->outformat == FMTH261){ ffh261loopfilter(s); } } ", "target": 1}
{"func": "static void s390virtioirq(S390CPU *cpu, int configchange, uint64t token) { if (kvmenabled()) { kvms390virtioirq(cpu, configchange, token); } else { cpuinjectext(cpu, VIRTIOEXTCODE, configchange, token); } } ", "target": 0}
{"func": "static int vbleunpack(VBLEContext *ctx, GetBitContext *gb) { int i; static const uint8t LUT[256] = { 8,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0, 5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0, 6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0, 5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0, 7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0, 5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0, 6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0, 5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0, }; /* Read all the lengths in first */ for (i = 0; i < ctx->size; i++) { /* At most we need to read 9 bits total to get indices up to 8 */ int val = showbits(gb, 8); // read reverse unary if (val) { val = LUT[val]; skipbits(gb, val + 1); ctx->len[i] = val; } else { skipbits(gb, 8); if (!getbits1(gb)) return -1; ctx->len[i] = 8; } } /* For any values that have length 0 */ memset(ctx->val, 0, ctx->size); for (i = 0; i < ctx->size; i++) { /* Check we have enough bits left */ if (getbitsleft(gb) < ctx->len[i]) return -1; /* getbits can't take a length of 0 */ if (ctx->len[i]) ctx->val[i] = (1 << ctx->len[i]) + getbits(gb, ctx->len[i]) - 1; } return 0; } ", "target": 0}
{"func": "int ffurlalloc(URLContext **puc, const char *filename, int flags, const AVIOInterruptCB *intcb) { URLProtocol *up = NULL; char protostr[128], protonested[128], *ptr; sizet protolen = strspn(filename, URLSCHEMECHARS); if (filename[protolen] != ':' || isdospath(filename)) strcpy(protostr, \"file\"); else avstrlcpy(protostr, filename, FFMIN(protolen + 1, sizeof(protostr))); avstrlcpy(protonested, protostr, sizeof(protonested)); if ((ptr = strchr(protonested, '+'))) *ptr = '\\0'; while (up = ffurlprotocolnext(up)) { if (!strcmp(protostr, up->name)) return urlallocforprotocol(puc, up, filename, flags, intcb); if (up->flags & URLPROTOCOLFLAGNESTEDSCHEME && !strcmp(protonested, up->name)) return urlallocforprotocol(puc, up, filename, flags, intcb); } *puc = NULL; return AVERRORPROTOCOLNOTFOUND; } ", "target": 0}
{"func": "BlockDriverState *bdrvnext(BlockDriverState *bs) { if (!bs) { return QTAILQFIRST(&bdrvstates); } return QTAILQNEXT(bs, devicelist); } ", "target": 0}
{"func": "void mcfuartwrite(void *opaque, targetphysaddrt addr, uint64t val, unsigned size) { mcfuartstate *s = (mcfuartstate *)opaque; switch (addr & 0x3f) { case 0x00: s->mr[s->currentmr] = val; s->currentmr = 1; break; case 0x04: /* CSR is ignored. */ break; case 0x08: /* Command Register. */ mcfdocommand(s, val); break; case 0x0c: /* Transmit Buffer. */ s->sr &= ~MCFUARTTxEMP; s->tb = val; mcfuartdotx(s); break; case 0x10: /* ACR is ignored. */ break; case 0x14: s->imr = val; break; default: break; } mcfuartupdate(s); } ", "target": 0}
{"func": "MemTxAttrs kvmarchpostrun(CPUState *cs, struct kvmrun *run) { ARMCPU *cpu; uint32t switchedlevel; if (kvmirqchipinkernel()) { /* * We only need to sync timer states with user-space interrupt * controllers, so return early and save cycles if we don't. */ return MEMTXATTRSUNSPECIFIED; } cpu = ARMCPU(cs); /* Synchronize our shadowed in-kernel device irq lines with the kvm ones */ if (run->s.regs.deviceirqlevel != cpu->deviceirqlevel) { switchedlevel = cpu->deviceirqlevel ^ run->s.regs.deviceirqlevel; qemumutexlockiothread(); if (switchedlevel & KVMARMDEVEL1VTIMER) { qemusetirq(cpu->gttimeroutputs[GTIMERVIRT], !!(run->s.regs.deviceirqlevel & KVMARMDEVEL1VTIMER)); switchedlevel &= ~KVMARMDEVEL1VTIMER; } if (switchedlevel & KVMARMDEVEL1PTIMER) { qemusetirq(cpu->gttimeroutputs[GTIMERPHYS], !!(run->s.regs.deviceirqlevel & KVMARMDEVEL1PTIMER)); switchedlevel &= ~KVMARMDEVEL1PTIMER; } /* XXX PMU IRQ is missing */ if (switchedlevel) { qemulogmask(LOGUNIMP, \"%s: unhandled in-kernel device IRQ %x\\n\", func, switchedlevel); } /* We also mark unknown levels as processed to not waste cycles */ cpu->deviceirqlevel = run->s.regs.deviceirqlevel; qemumutexunlockiothread(); } return MEMTXATTRSUNSPECIFIED; } ", "target": 0}
{"func": "static int aviwritetrailer(AVFormatContext *s) { AVIContext *avi = s->privdata; AVIOContext *pb = s->pb; int res = 0; int i, j, n, nbframes; int64t filesize; if (pb->seekable) { if (avi->riffid == 1) { ffendtag(pb, avi->movilist); res = aviwriteidx1(s); ffendtag(pb, avi->riffstart); } else { aviwriteix(s); ffendtag(pb, avi->movilist); ffendtag(pb, avi->riffstart); filesize = aviotell(pb); avioseek(pb, avi->odmllist - 8, SEEKSET); ffiowfourcc(pb, \"LIST\"); /* Making this AVI OpenDML one */ avioskip(pb, 16); for (n = nbframes = 0; n < s->nbstreams; n++) { AVCodecParameters *par = s->streams[n]->codecpar; AVIStream *avist = s->streams[n]->privdata; if (par->codectype == AVMEDIATYPEVIDEO) { if (nbframes < avist->packetcount) nbframes = avist->packetcount; } else { if (par->codecid == AVCODECIDMP2 || par->codecid == AVCODECIDMP3) nbframes += avist->packetcount; } } aviowl32(pb, nbframes); avioseek(pb, filesize, SEEKSET); aviwritecounters(s, avi->riffid); } } for (i = 0; i < s->nbstreams; i++) { AVIStream *avist = s->streams[i]->privdata; for (j = 0; j < avist->indexes.entsallocated / AVIINDEXCLUSTERSIZE; j++) avfree(avist->indexes.cluster[j]); avfreep(&avist->indexes.cluster); avist->indexes.entsallocated = avist->indexes.entry = 0; } return res; } ", "target": 0}
{"func": "static uint64t omapmpuiioread(void *opaque, targetphysaddrt addr, unsigned size) { if (size != 2) { return omapbadwidthread16(opaque, addr); } if (addr == OMAPMPUIBASE)\t/* CMR */ return 0xfe4d; OMAPBADREG(addr); return 0; } ", "target": 0}
{"func": "static void namwriteb (void *opaque, uint32t addr, uint32t val) { PCIAC97LinkState *d = opaque; AC97LinkState *s = &d->ac97; dolog (\"U nam writeb %#x <- %#x\\n\", addr, val); s->cas = 0; } ", "target": 0}
{"func": "static void s390fliccommonrealize(DeviceState *dev, Error **errp) { S390FLICState *fs = S390FLICCOMMON(dev); uint32t maxbatch = fs->adapterroutesmaxbatch; if (maxbatch > ADAPTERROUTESMAXGSI) { errorsetg(errp, \"flic property adapterroutesmaxbatch too big\" \" (%d > %d)\", maxbatch, ADAPTERROUTESMAXGSI); } fs->aissupported = true; } ", "target": 0}
{"func": "static int dxva2getbuffer(AVCodecContext *s, AVFrame *frame, int flags) { InputStream *ist = s->opaque; DXVA2Context *ctx = ist->hwaccelctx; return avhwframegetbuffer(ctx->hwframesctx, frame, 0); } ", "target": 0}
{"func": "void ffh264idct8addc(uint8t *dst, DCTELEM *block, int stride){ int i; uint8t *cm = ffcropTbl + MAXNEGCROP; block[0] += 32; for( i = 0; i < 8; i++ ) { const int a0 = block[0+i*8] + block[4+i*8]; const int a2 = block[0+i*8] - block[4+i*8]; const int a4 = (block[2+i*8]>>1) - block[6+i*8]; const int a6 = (block[6+i*8]>>1) + block[2+i*8]; const int b0 = a0 + a6; const int b2 = a2 + a4; const int b4 = a2 - a4; const int b6 = a0 - a6; const int a1 = -block[3+i*8] + block[5+i*8] - block[7+i*8] - (block[7+i*8]>>1); const int a3 = block[1+i*8] + block[7+i*8] - block[3+i*8] - (block[3+i*8]>>1); const int a5 = -block[1+i*8] + block[7+i*8] + block[5+i*8] + (block[5+i*8]>>1); const int a7 = block[3+i*8] + block[5+i*8] + block[1+i*8] + (block[1+i*8]>>1); const int b1 = (a7>>2) + a1; const int b3 = a3 + (a5>>2); const int b5 = (a3>>2) - a5; const int b7 = a7 - (a1>>2); block[0+i*8] = b0 + b7; block[7+i*8] = b0 - b7; block[1+i*8] = b2 + b5; block[6+i*8] = b2 - b5; block[2+i*8] = b4 + b3; block[5+i*8] = b4 - b3; block[3+i*8] = b6 + b1; block[4+i*8] = b6 - b1; } for( i = 0; i < 8; i++ ) { const int a0 = block[i+0*8] + block[i+4*8]; const int a2 = block[i+0*8] - block[i+4*8]; const int a4 = (block[i+2*8]>>1) - block[i+6*8]; const int a6 = (block[i+6*8]>>1) + block[i+2*8]; const int b0 = a0 + a6; const int b2 = a2 + a4; const int b4 = a2 - a4; const int b6 = a0 - a6; const int a1 = -block[i+3*8] + block[i+5*8] - block[i+7*8] - (block[i+7*8]>>1); const int a3 = block[i+1*8] + block[i+7*8] - block[i+3*8] - (block[i+3*8]>>1); const int a5 = -block[i+1*8] + block[i+7*8] + block[i+5*8] + (block[i+5*8]>>1); const int a7 = block[i+3*8] + block[i+5*8] + block[i+1*8] + (block[i+1*8]>>1); const int b1 = (a7>>2) + a1; const int b3 = a3 + (a5>>2); const int b5 = (a3>>2) - a5; const int b7 = a7 - (a1>>2); dst[i + 0*stride] = cm[ dst[i + 0*stride] + ((b0 + b7) >> 6) ]; dst[i + 1*stride] = cm[ dst[i + 1*stride] + ((b2 + b5) >> 6) ]; dst[i + 2*stride] = cm[ dst[i + 2*stride] + ((b4 + b3) >> 6) ]; dst[i + 3*stride] = cm[ dst[i + 3*stride] + ((b6 + b1) >> 6) ]; dst[i + 4*stride] = cm[ dst[i + 4*stride] + ((b6 - b1) >> 6) ]; dst[i + 5*stride] = cm[ dst[i + 5*stride] + ((b4 - b3) >> 6) ]; dst[i + 6*stride] = cm[ dst[i + 6*stride] + ((b2 - b5) >> 6) ]; dst[i + 7*stride] = cm[ dst[i + 7*stride] + ((b0 - b7) >> 6) ]; } } ", "target": 0}
{"func": "void doloaddcr (void) { targetulong val; if (unlikely(env->dcrenv == NULL)) { if (loglevel != 0) { fprintf(logfile, \"No DCR environment\\n\"); } doraiseexceptionerr(EXCPPROGRAM, EXCPINVAL | EXCPINVALINVAL); } else if (unlikely(ppcdcrread(env->dcrenv, T0, &val) != 0)) { if (loglevel != 0) { fprintf(logfile, \"DCR read error %d %03x\\n\", (int)T0, (int)T0); } doraiseexceptionerr(EXCPPROGRAM, EXCPINVAL | EXCPPRIVREG); } else { T0 = val; } } ", "target": 0}
{"func": "void tlbsetpage(CPUArchState *env, targetulong vaddr, targetphysaddrt paddr, int prot, int mmuidx, targetulong size) { MemoryRegionSection *section; unsigned int index; targetulong address; targetulong codeaddress; uintptrt addend; CPUTLBEntry *te; targetphysaddrt iotlb; assert(size >= TARGETPAGESIZE); if (size != TARGETPAGESIZE) { tlbaddlargepage(env, vaddr, size); } section = physpagefind(paddr >> TARGETPAGEBITS); #if defined(DEBUGTLB) printf(\"tlbsetpage: vaddr=\" TARGETFMTlx \" paddr=0x\" TARGETFMTplx \" prot=%x idx=%d pd=0x%08lx\\n\", vaddr, paddr, prot, mmuidx, pd); #endif address = vaddr; if (!(memoryregionisram(section->mr) || memoryregionisromd(section->mr))) { /* IO memory case (romd handled later) */ address |= TLBMMIO; } if (memoryregionisram(section->mr) || memoryregionisromd(section->mr)) { addend = (uintptrt)memoryregiongetramptr(section->mr) + memoryregionsectionaddr(section, paddr); } else { addend = 0; } codeaddress = address; iotlb = memoryregionsectiongetiotlb(env, section, vaddr, paddr, prot, &address); index = (vaddr >> TARGETPAGEBITS) & (CPUTLBSIZE - 1); env->iotlb[mmuidx][index] = iotlb - vaddr; te = &env->tlbtable[mmuidx][index]; te->addend = addend - vaddr; if (prot & PAGEREAD) { te->addrread = address; } else { te->addrread = -1; } if (prot & PAGEEXEC) { te->addrcode = codeaddress; } else { te->addrcode = -1; } if (prot & PAGEWRITE) { if ((memoryregionisram(section->mr) && section->readonly) || memoryregionisromd(section->mr)) { /* Write access calls the I/O callback. */ te->addrwrite = address | TLBMMIO; } else if (memoryregionisram(section->mr) && !cpuphysicalmemoryisdirty( section->mr->ramaddr + memoryregionsectionaddr(section, paddr))) { te->addrwrite = address | TLBNOTDIRTY; } else { te->addrwrite = address; } } else { te->addrwrite = -1; } } ", "target": 0}
{"func": "static void rtl8139iowriteb(void *opaque, uint8t addr, uint32t val) { RTL8139State *s = opaque; addr &= 0xff; switch (addr) { case MAC0 ... MAC0+5: s->phys[addr - MAC0] = val; break; case MAC0+6 ... MAC0+7: /* reserved */ break; case MAR0 ... MAR0+7: s->mult[addr - MAR0] = val; break; case ChipCmd: rtl8139ChipCmdwrite(s, val); break; case Cfg9346: rtl8139Cfg9346write(s, val); break; case TxConfig: /* windows driver sometimes writes using byte-lenth call */ rtl8139TxConfigwriteb(s, val); break; case Config0: rtl8139Config0write(s, val); break; case Config1: rtl8139Config1write(s, val); break; case Config3: rtl8139Config3write(s, val); break; case Config4: rtl8139Config4write(s, val); break; case Config5: rtl8139Config5write(s, val); break; case MediaStatus: /* ignore */ DPRINTF(\"not implemented write(b) to MediaStatus val=0x%02x\\n\", val); break; case HltClk: DPRINTF(\"HltClk write val=0x%08x\\n\", val); if (val == 'R') { s->clockenabled = 1; } else if (val == 'H') { s->clockenabled = 0; } break; case TxThresh: DPRINTF(\"C+ TxThresh write(b) val=0x%02x\\n\", val); s->TxThresh = val; break; case TxPoll: DPRINTF(\"C+ TxPoll write(b) val=0x%02x\\n\", val); if (val & (1 << 7)) { DPRINTF(\"C+ TxPoll high priority transmission (not \" \"implemented)\\n\"); //rtl8139cplustransmit(s); } if (val & (1 << 6)) { DPRINTF(\"C+ TxPoll normal priority transmission\\n\"); rtl8139cplustransmit(s); } break; default: DPRINTF(\"not implemented write(b) addr=0x%x val=0x%02x\\n\", addr, val); break; } } ", "target": 1}
{"func": "static void rv40hweakloopfilter(uint8t *src, const int stride, const int filterp1, const int filterq1, const int alpha, const int beta, const int limp0q0, const int limq1, const int limp1) { rv40weakloopfilter(src, stride, 1, filterp1, filterq1, alpha, beta, limp0q0, limq1, limp1); } ", "target": 1}
{"func": "static int decodesubframe(WmallDecodeCtx *s) { int offset = s->samplesperframe; int subframelen = s->samplesperframe; int totalsamples = s->samplesperframe * s->numchannels; int i, j, rawpcmtile, paddingzeroes, res; s->subframeoffset = getbitscount(&s->gb); /* reset channel context and find the next block offset and size == the next block of the channel with the smallest number of decoded samples */ for (i = 0; i < s->numchannels; i++) { if (offset > s->channel[i].decodedsamples) { offset = s->channel[i].decodedsamples; subframelen = s->channel[i].subframelen[s->channel[i].cursubframe]; } } /* get a list of all channels that contain the estimated block */ s->channelsforcursubframe = 0; for (i = 0; i < s->numchannels; i++) { const int cursubframe = s->channel[i].cursubframe; /* subtract already processed samples */ totalsamples -= s->channel[i].decodedsamples; /* and count if there are multiple subframes that match our profile */ if (offset == s->channel[i].decodedsamples && subframelen == s->channel[i].subframelen[cursubframe]) { totalsamples -= s->channel[i].subframelen[cursubframe]; s->channel[i].decodedsamples += s->channel[i].subframelen[cursubframe]; s->channelindexesforcursubframe[s->channelsforcursubframe] = i; ++s->channelsforcursubframe; } } /* check if the frame will be complete after processing the estimated block */ if (!totalsamples) s->parsedallsubframes = 1; s->seekabletile = getbits1(&s->gb); if (s->seekabletile) { clearcodecbuffers(s); s->doarithcoding = getbits1(&s->gb); if (s->doarithcoding) { avprivrequestsample(s->avctx, \"Arithmetic coding\"); return AVERRORPATCHWELCOME; } s->doacfilter = getbits1(&s->gb); s->dointerchdecorr = getbits1(&s->gb); s->domclms = getbits1(&s->gb); if (s->doacfilter) decodeacfilter(s); if (s->domclms) decodemclms(s); if ((res = decodecdlms(s)) < 0) return res; s->movavescaling = getbits(&s->gb, 3); s->quantstepsize = getbits(&s->gb, 8) + 1; resetcodec(s); } else if (!s->cdlms[0][0].order) { avlog(s->avctx, AVLOGDEBUG, \"Waiting for seekable tile\\n\"); s->frame.nbsamples = 0; return -1; } rawpcmtile = getbits1(&s->gb); for (i = 0; i < s->numchannels; i++) s->ischannelcoded[i] = 1; if (!rawpcmtile) { for (i = 0; i < s->numchannels; i++) s->ischannelcoded[i] = getbits1(&s->gb); if (s->bV3RTM) { // LPC s->dolpc = getbits1(&s->gb); if (s->dolpc) { decodelpc(s); avprivrequestsample(s->avctx, \"Expect wrong output since \" \"inverse LPC filter\"); } } else s->dolpc = 0; } if (getbits1(&s->gb)) paddingzeroes = getbits(&s->gb, 5); else paddingzeroes = 0; if (rawpcmtile) { int bits = s->bitspersample - paddingzeroes; if (bits <= 0) { avlog(s->avctx, AVLOGERROR, \"Invalid number of padding bits in raw PCM tile\\n\"); return AVERRORINVALIDDATA; } avdlog(s->avctx, \"RAWPCM %d bits per sample. \" \"total %d bits, remain=%d\\n\", bits, bits * s->numchannels * subframelen, getbitscount(&s->gb)); for (i = 0; i < s->numchannels; i++) for (j = 0; j < subframelen; j++) s->channelcoeffs[i][j] = getsbits(&s->gb, bits); } else { for (i = 0; i < s->numchannels; i++) if (s->ischannelcoded[i]) { decodechannelresidues(s, i, subframelen); if (s->seekabletile) usehighupdatespeed(s, i); else usenormalupdatespeed(s, i); revertcdlms(s, i, 0, subframelen); } else { memset(s->channelresidues[i], 0, sizeof(**s->channelresidues) * subframelen); } } if (s->domclms) revertmclms(s, subframelen); if (s->dointerchdecorr) revertinterchdecorr(s, subframelen); if (s->doacfilter) revertacfilter(s, subframelen); /* Dequantize */ if (s->quantstepsize != 1) for (i = 0; i < s->numchannels; i++) for (j = 0; j < subframelen; j++) s->channelresidues[i][j] *= s->quantstepsize; /* Write to proper output buffer depending on bit-depth */ for (i = 0; i < s->channelsforcursubframe; i++) { int c = s->channelindexesforcursubframe[i]; int subframelen = s->channel[c].subframelen[s->channel[c].cursubframe]; for (j = 0; j < subframelen; j++) { if (s->bitspersample == 16) { *s->samples16[c]++ = (int16t) s->channelresidues[c][j] << paddingzeroes; } else { *s->samples32[c]++ = s->channelresidues[c][j] << paddingzeroes; } } } /* handled one subframe */ for (i = 0; i < s->channelsforcursubframe; i++) { int c = s->channelindexesforcursubframe[i]; if (s->channel[c].cursubframe >= s->channel[c].numsubframes) { avlog(s->avctx, AVLOGERROR, \"broken subframe\\n\"); return AVERRORINVALIDDATA; } ++s->channel[c].cursubframe; } return 0; } ", "target": 1}
{"func": "static void RENAME(yuv2rgb5651)(SwsContext *c, const int16t *buf0, const int16t *ubuf[2], const int16t *bguf[2], const int16t *abuf0, uint8t *dest, int dstW, int uvalpha, int y) { const int16t *ubuf0 = ubuf[0], *ubuf1 = ubuf[1]; const int16t *buf1= buf0; //FIXME needed for RGB1/BGR1 if (uvalpha < 2048) { // note this is not correct (shifts chrominance by 0.5 pixels) but it is a bit faster asm volatile( \"mov %%\"REGb\", \"ESPOFFSET\"(%5) \\n\\t\" \"mov %4, %%\"REGb\" \\n\\t\" \"push %%\"REGBP\" \\n\\t\" YSCALEYUV2RGB1(%%REGBP, %5) \"pxor %%mm7, %%mm7 \\n\\t\" /* mm2=B, %%mm4=G, %%mm5=R, %%mm7=0 */ #ifdef DITHER1XBPP \"paddusb \"BLUEDITHER\"(%5), %%mm2 \\n\\t\" \"paddusb \"GREENDITHER\"(%5), %%mm4 \\n\\t\" \"paddusb \"REDDITHER\"(%5), %%mm5 \\n\\t\" #endif WRITERGB16(%%REGb, 8280(%5), %%REGBP) \"pop %%\"REGBP\" \\n\\t\" \"mov \"ESPOFFSET\"(%5), %%\"REGb\" \\n\\t\" :: \"c\" (buf0), \"d\" (buf1), \"S\" (ubuf0), \"D\" (ubuf1), \"m\" (dest), \"a\" (&c->redDither) ); } else { asm volatile( \"mov %%\"REGb\", \"ESPOFFSET\"(%5) \\n\\t\" \"mov %4, %%\"REGb\" \\n\\t\" \"push %%\"REGBP\" \\n\\t\" YSCALEYUV2RGB1b(%%REGBP, %5) \"pxor %%mm7, %%mm7 \\n\\t\" /* mm2=B, %%mm4=G, %%mm5=R, %%mm7=0 */ #ifdef DITHER1XBPP \"paddusb \"BLUEDITHER\"(%5), %%mm2 \\n\\t\" \"paddusb \"GREENDITHER\"(%5), %%mm4 \\n\\t\" \"paddusb \"REDDITHER\"(%5), %%mm5 \\n\\t\" #endif WRITERGB16(%%REGb, 8280(%5), %%REGBP) \"pop %%\"REGBP\" \\n\\t\" \"mov \"ESPOFFSET\"(%5), %%\"REGb\" \\n\\t\" :: \"c\" (buf0), \"d\" (buf1), \"S\" (ubuf0), \"D\" (ubuf1), \"m\" (dest), \"a\" (&c->redDither) ); } } ", "target": 1}
{"func": "void hmpmemcharwrite(Monitor *mon, const QDict *qdict) { uint32t size; const char *chardev = qdictgetstr(qdict, \"device\"); const char *data = qdictgetstr(qdict, \"data\"); Error *errp = NULL; size = strlen(data); qmpmemcharwrite(chardev, size, data, false, 0, &errp); hmphandleerror(mon, &errp); } ", "target": 1}
{"func": "static int dobitallocation(AC3DecodeContext *ctx, int flags) { ac3audioblock *ab = &ctx->audioblock; int i, snroffst = 0; if (!flags) /* bit allocation is not required */ return 0; if (ab->flags & AC3ABSNROFFSTE) { /* check whether snroffsts are zero */ snroffst += ab->csnroffst; if (ab->flags & AC3ABCPLINU) snroffst += ab->cplfsnroffst; for (i = 0; i < ctx->bsi.nfchans; i++) snroffst += ab->fsnroffst[i]; if (ctx->bsi.flags & AC3BSILFEON) snroffst += ab->lfefsnroffst; if (!snroffst) { memset(ab->cplbap, 0, sizeof (ab->cplbap)); for (i = 0; i < ctx->bsi.nfchans; i++) memset(ab->bap[i], 0, sizeof (ab->bap[i])); memset(ab->lfebap, 0, sizeof (ab->lfebap)); return 0; } } /* perform bit allocation */ if ((ab->flags & AC3ABCPLINU) && (flags & 64)) if (dobitallocation(ctx, 5)) return -1; for (i = 0; i < ctx->bsi.nfchans; i++) if (flags & (1 << i)) if (dobitallocation(ctx, i)) return -1; if ((ctx->bsi.flags & AC3BSILFEON) && (flags & 32)) if (dobitallocation(ctx, 6)) return -1; return 0; } ", "target": 0}
{"func": "void qmpdrivebackup(const char *device, const char *target, bool hasformat, const char *format, enum MirrorSyncMode sync, bool hasmode, enum NewImageMode mode, bool hasspeed, int64t speed, bool hasonsourceerror, BlockdevOnError onsourceerror, bool hasontargeterror, BlockdevOnError ontargeterror, Error **errp) { BlockDriverState *bs; BlockDriverState *targetbs; BlockDriverState *source = NULL; BlockDriver *drv = NULL; Error *localerr = NULL; int flags; int64t size; int ret; if (!hasspeed) { speed = 0; } if (!hasonsourceerror) { onsourceerror = BLOCKDEVONERRORREPORT; } if (!hasontargeterror) { ontargeterror = BLOCKDEVONERRORREPORT; } if (!hasmode) { mode = NEWIMAGEMODEABSOLUTEPATHS; } bs = bdrvfind(device); if (!bs) { errorset(errp, QERRDEVICENOTFOUND, device); return; } if (!bdrvisinserted(bs)) { errorset(errp, QERRDEVICEHASNOMEDIUM, device); return; } if (!hasformat) { format = mode == NEWIMAGEMODEEXISTING ? NULL : bs->drv->formatname; } if (format) { drv = bdrvfindformat(format); if (!drv) { errorset(errp, QERRINVALIDBLOCKFORMAT, format); return; } } if (bdrvopisblocked(bs, BLOCKOPTYPEBACKUPSOURCE, errp)) { return; } flags = bs->openflags | BDRVORDWR; /* See if we have a backing HD we can use to create our new image * on top of. */ if (sync == MIRRORSYNCMODETOP) { source = bs->backinghd; if (!source) { sync = MIRRORSYNCMODEFULL; } } if (sync == MIRRORSYNCMODENONE) { source = bs; } size = bdrvgetlength(bs); if (size < 0) { errorsetgerrno(errp, -size, \"bdrvgetlength failed\"); return; } if (mode != NEWIMAGEMODEEXISTING) { assert(format && drv); if (source) { bdrvimgcreate(target, format, source->filename, source->drv->formatname, NULL, size, flags, &localerr, false); } else { bdrvimgcreate(target, format, NULL, NULL, NULL, size, flags, &localerr, false); } } if (localerr) { errorpropagate(errp, localerr); return; } targetbs = NULL; ret = bdrvopen(&targetbs, target, NULL, NULL, flags, drv, &localerr); if (ret < 0) { errorpropagate(errp, localerr); return; } backupstart(bs, targetbs, speed, sync, onsourceerror, ontargeterror, blockjobcb, bs, &localerr); if (localerr != NULL) { bdrvunref(targetbs); errorpropagate(errp, localerr); return; } } ", "target": 0}
{"func": "static void maltafpgawrite(void *opaque, hwaddr addr, uint64t val, unsigned size) { MaltaFPGAState *s = opaque; uint32t saddr; saddr = (addr & 0xfffff); switch (saddr) { /* SWITCH Register */ case 0x00200: break; /* JMPRS Register */ case 0x00210: break; /* LEDBAR Register */ case 0x00408: s->leds = val & 0xff; maltafpgaupdatedisplay(s); break; /* ASCIIWORD Register */ case 0x00410: snprintf(s->displaytext, 9, \"%08X\", (uint32t)val); maltafpgaupdatedisplay(s); break; /* ASCIIPOS0 to ASCIIPOS7 Registers */ case 0x00418: case 0x00420: case 0x00428: case 0x00430: case 0x00438: case 0x00440: case 0x00448: case 0x00450: s->displaytext[(saddr - 0x00418) >> 3] = (char) val; maltafpgaupdatedisplay(s); break; /* SOFTRES Register */ case 0x00500: if (val == 0x42) qemusystemresetrequest (); break; /* BRKRES Register */ case 0x00508: s->brk = val & 0xff; break; /* UART Registers are handled directly by the serial device */ /* GPOUT Register */ case 0x00a00: s->gpout = val & 0xff; break; /* I2COE Register */ case 0x00b08: s->i2coe = val & 0x03; break; /* I2COUT Register */ case 0x00b10: eeprom24c0xwrite(val & 0x02, val & 0x01); s->i2cout = val; break; /* I2CSEL Register */ case 0x00b18: s->i2csel = val & 0x01; break; default: #if 0 printf (\"maltafpgawrite: Bad register offset 0x\" TARGETFMTlx \"\\n\", addr); #endif break; } } ", "target": 0}
{"func": "static int revertchannelcorrelation(ALSDecContext *ctx, ALSBlockData *bd, ALSChannelData **cd, int *reverted, unsigned int offset, int c) { ALSChannelData *ch = cd[c]; unsigned int dep = 0; unsigned int channels = ctx->avctx->channels; if (reverted[c]) return 0; reverted[c] = 1; while (dep < channels && !ch[dep].stopflag) { revertchannelcorrelation(ctx, bd, cd, reverted, offset, ch[dep].masterchannel); dep++; } if (dep == channels) { avlog(ctx->avctx, AVLOGWARNING, \"Invalid channel correlation!\\n\"); return AVERRORINVALIDDATA; } bd->constblock = ctx->constblock + c; bd->shiftlsbs = ctx->shiftlsbs + c; bd->optorder = ctx->optorder + c; bd->storeprevsamples = ctx->storeprevsamples + c; bd->useltp = ctx->useltp + c; bd->ltplag = ctx->ltplag + c; bd->ltpgain = ctx->ltpgain[c]; bd->lpccof = ctx->lpccof[c]; bd->quantcof = ctx->quantcof[c]; bd->rawsamples = ctx->rawsamples[c] + offset; dep = 0; while (!ch[dep].stopflag) { unsigned int smp; unsigned int begin = 1; unsigned int end = bd->blocklength - 1; int64t y; int32t *master = ctx->rawsamples[ch[dep].masterchannel] + offset; if (ch[dep].timediffflag) { int t = ch[dep].timediffindex; if (ch[dep].timediffsign) { t = -t; begin -= t; } else { end -= t; } for (smp = begin; smp < end; smp++) { y = (1 << 6) + MUL64(ch[dep].weighting[0], master[smp - 1 ]) + MUL64(ch[dep].weighting[1], master[smp ]) + MUL64(ch[dep].weighting[2], master[smp + 1 ]) + MUL64(ch[dep].weighting[3], master[smp - 1 + t]) + MUL64(ch[dep].weighting[4], master[smp + t]) + MUL64(ch[dep].weighting[5], master[smp + 1 + t]); bd->rawsamples[smp] += y >> 7; } } else { for (smp = begin; smp < end; smp++) { y = (1 << 6) + MUL64(ch[dep].weighting[0], master[smp - 1]) + MUL64(ch[dep].weighting[1], master[smp ]) + MUL64(ch[dep].weighting[2], master[smp + 1]); bd->rawsamples[smp] += y >> 7; } } dep++; } return 0; } ", "target": 0}
{"func": "buildhpet(GArray *tabledata, GArray *linker) { Acpi20Hpet *hpet; hpet = acpidatapush(tabledata, sizeof(*hpet)); /* Note timerblockid value must be kept in sync with value advertised by * emulated hpet */ hpet->timerblockid = cputole32(0x8086a201); hpet->addr.address = cputole64(HPETBASE); buildheader(linker, tabledata, (void *)hpet, \"HPET\", sizeof(*hpet), 1, NULL); } ", "target": 0}
{"func": "static inline void downmix3f1rtomono(float *samples) { int i; for (i = 0; i < 256; i++) { samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768]); samples[i + 256] = samples[i + 512] = samples[i + 768] = 0; } } ", "target": 0}
{"func": "static int qsvdecodeinit(AVCodecContext *avctx, QSVContext *q) { const AVPixFmtDescriptor *desc; mfxSession session = NULL; int iopattern = 0; mfxVideoParam param = { { 0 } }; int framewidth = avctx->codedwidth; int frameheight = avctx->codedheight; int ret; desc = avpixfmtdescget(avctx->swpixfmt); if (!desc) return AVERRORBUG; if (!q->asyncfifo) { q->asyncfifo = avfifoalloc((1 + q->asyncdepth) * (sizeof(mfxSyncPoint*) + sizeof(QSVFrame*))); if (!q->asyncfifo) return AVERROR(ENOMEM); } if (avctx->pixfmt == AVPIXFMTQSV && avctx->hwaccelcontext) { AVQSVContext *userctx = avctx->hwaccelcontext; session = userctx->session; iopattern = userctx->iopattern; q->extbuffers = userctx->extbuffers; q->nbextbuffers = userctx->nbextbuffers; } if (avctx->hwframesctx) { AVHWFramesContext *framesctx = (AVHWFramesContext*)avctx->hwframesctx->data; AVQSVFramesContext *frameshwctx = framesctx->hwctx; if (!iopattern) { if (frameshwctx->frametype & MFXMEMTYPEOPAQUEFRAME) iopattern = MFXIOPATTERNOUTOPAQUEMEMORY; else if (frameshwctx->frametype & MFXMEMTYPEVIDEOMEMORYDECODERTARGET) iopattern = MFXIOPATTERNOUTVIDEOMEMORY; } framewidth = frameshwctx->surfaces[0].Info.Width; frameheight = frameshwctx->surfaces[0].Info.Height; } if (!iopattern) iopattern = MFXIOPATTERNOUTSYSTEMMEMORY; q->iopattern = iopattern; ret = qsvinitsession(avctx, q, session, avctx->hwframesctx); if (ret < 0) { avlog(avctx, AVLOGERROR, \"Error initializing an MFX session\\n\"); return ret; } ret = ffqsvcodecidtomfx(avctx->codecid); if (ret < 0) return ret; param.mfx.CodecId = ret; param.mfx.CodecProfile = avctx->profile; param.mfx.CodecLevel = avctx->level; param.mfx.FrameInfo.BitDepthLuma = desc->comp[0].depth; param.mfx.FrameInfo.BitDepthChroma = desc->comp[0].depth; param.mfx.FrameInfo.Shift = desc->comp[0].depth > 8; param.mfx.FrameInfo.FourCC = q->fourcc; param.mfx.FrameInfo.Width = framewidth; param.mfx.FrameInfo.Height = frameheight; param.mfx.FrameInfo.ChromaFormat = MFXCHROMAFORMATYUV420; param.IOPattern = q->iopattern; param.AsyncDepth = q->asyncdepth; param.ExtParam = q->extbuffers; param.NumExtParam = q->nbextbuffers; ret = MFXVideoDECODEInit(q->session, &param); if (ret < 0) return ffqsvprinterror(avctx, ret, \"Error initializing the MFX video decoder\"); q->frameinfo = param.mfx.FrameInfo; return 0; } ", "target": 0}
{"func": "static void virtiopcimodernregionmap(VirtIOPCIProxy *proxy, VirtIOPCIRegion *region, struct virtiopcicap *cap) { memoryregionaddsubregion(&proxy->modernbar, region->offset, &region->mr); cap->cfgtype = region->type; cap->offset = cputole32(region->offset); cap->length = cputole32(memoryregionsize(&region->mr)); virtiopciaddmemcap(proxy, cap); } ", "target": 0}
{"func": "static void mixerreset (AC97LinkState *s) { uint8t active[LASTINDEX]; dolog (\"mixerreset\\n\"); memset (s->mixerdata, 0, sizeof (s->mixerdata)); memset (active, 0, sizeof (active)); mixerstore (s, AC97Reset , 0x0000); /* 6940 */ mixerstore (s, AC97MasterVolumeMonoMute , 0x8000); mixerstore (s, AC97PCBEEPVolumeMute , 0x0000); mixerstore (s, AC97PhoneVolumeMute , 0x8008); mixerstore (s, AC97MicVolumeMute , 0x8008); mixerstore (s, AC97CDVolumeMute , 0x8808); mixerstore (s, AC97AuxVolumeMute , 0x8808); mixerstore (s, AC97RecordGainMicMute , 0x8000); mixerstore (s, AC97GeneralPurpose , 0x0000); mixerstore (s, AC973DControl , 0x0000); mixerstore (s, AC97PowerdownCtrlStat , 0x000f); /* * Sigmatel 9700 (STAC9700) */ mixerstore (s, AC97VendorID1 , 0x8384); mixerstore (s, AC97VendorID2 , 0x7600); /* 7608 */ mixerstore (s, AC97ExtendedAudioID , 0x0809); mixerstore (s, AC97ExtendedAudioCtrlStat, 0x0009); mixerstore (s, AC97PCMFrontDACRate , 0xbb80); mixerstore (s, AC97PCMSurroundDACRate , 0xbb80); mixerstore (s, AC97PCMLFEDACRate , 0xbb80); mixerstore (s, AC97PCMLRADCRate , 0xbb80); mixerstore (s, AC97MICADCRate , 0xbb80); recordselect (s, 0); setvolume (s, AC97MasterVolumeMute, 0x8000); setvolume (s, AC97PCMOutVolumeMute, 0x8808); setvolume (s, AC97LineInVolumeMute, 0x8808); resetvoices (s, active); } ", "target": 0}
{"func": "int bdrvpdiscard(BlockDriverState *bs, int64t offset, int count) { Coroutine *co; DiscardCo rwco = { .bs = bs, .offset = offset, .count = count, .ret = NOTDONE, }; if (qemuincoroutine()) { /* Fast-path if already in coroutine context */ bdrvpdiscardcoentry(&rwco); } else { AioContext *aiocontext = bdrvgetaiocontext(bs); co = qemucoroutinecreate(bdrvpdiscardcoentry, &rwco); qemucoroutineenter(co); while (rwco.ret == NOTDONE) { aiopoll(aiocontext, true); } } return rwco.ret; } ", "target": 0}
{"func": "void HELPER(stbyb)(CPUHPPAState *env, targetulong addr, targetulong val) { uintptrt ra = GETPC(); switch (addr & 3) { case 3: cpustbdatara(env, addr, val, ra); break; case 2: cpustwdatara(env, addr, val, ra); break; case 1: /* The 3 byte store must appear atomic. */ if (parallelcpus) { atomicstore3(env, addr, val, 0x00ffffffu, ra); } else { cpustbdatara(env, addr, val >> 16, ra); cpustwdatara(env, addr + 1, val, ra); } break; default: cpustldatara(env, addr, val, ra); break; } } ", "target": 0}
{"func": "int avimagechecksar(unsigned int w, unsigned int h, AVRational sar) { int64t scaleddim; if (!sar.den) return AVERROR(EINVAL); if (!sar.num || sar.num == sar.den) return 0; if (sar.num < sar.den) scaleddim = avrescalernd(w, sar.num, sar.den, AVROUNDZERO); else scaleddim = avrescalernd(h, sar.den, sar.num, AVROUNDZERO); if (scaleddim > 0) return 0; return AVERROR(EINVAL); } ", "target": 1}
{"func": "static void decodegraybitstream(HYuvContext *s, int count) { int i; OPENREADER(re, &s->gb); count /= 2; if (count >= (getbitsleft(&s->gb)) / (32 * 2)) { for (i = 0; i < count && getbitsleft(&s->gb) > 0; i++) { READ2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0); } } else { for (i = 0; i < count; i++) { READ2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0); } } CLOSEREADER(re, &s->gb); } ", "target": 1}
{"func": "static void memoryregiondestructoralias(MemoryRegion *mr) { memoryregionunref(mr->alias); } ", "target": 1}
{"func": "int ppchash64handlemmufault(PowerPCCPU *cpu, targetulong eaddr, int rwx, int mmuidx) { CPUState *cs = CPU(cpu); CPUPPCState *env = &cpu->env; ppcslbt *slb; hwaddr pteoffset; ppchashpte64t pte; int ppprot, amrprot, prot; uint64t newpte1; const int needprot[] = {PAGEREAD, PAGEWRITE, PAGEEXEC}; hwaddr raddr; assert((rwx == 0) || (rwx == 1) || (rwx == 2)); /* 1. Handle real mode accesses */ if (((rwx == 2) && (msrir == 0)) || ((rwx != 2) && (msrdr == 0))) { /* Translation is off */ /* In real mode the top 4 effective address bits are ignored */ raddr = eaddr & 0x0FFFFFFFFFFFFFFFULL; tlbsetpage(cs, eaddr & TARGETPAGEMASK, raddr & TARGETPAGEMASK, PAGEREAD | PAGEWRITE | PAGEEXEC, mmuidx, TARGETPAGESIZE); return 0; } /* 2. Translation is on, so look up the SLB */ slb = slblookup(cpu, eaddr); if (!slb) { if (rwx == 2) { cs->exceptionindex = POWERPCEXCPISEG; env->errorcode = 0; } else { cs->exceptionindex = POWERPCEXCPDSEG; env->errorcode = 0; env->spr[SPRDAR] = eaddr; } return 1; } /* 3. Check for segment level no-execute violation */ if ((rwx == 2) && (slb->vsid & SLBVSIDN)) { cs->exceptionindex = POWERPCEXCPISI; env->errorcode = 0x10000000; return 1; } /* 4. Locate the PTE in the hash table */ pteoffset = ppchash64htablookup(cpu, slb, eaddr, &pte); if (pteoffset == -1) { if (rwx == 2) { cs->exceptionindex = POWERPCEXCPISI; env->errorcode = 0x40000000; } else { cs->exceptionindex = POWERPCEXCPDSI; env->errorcode = 0; env->spr[SPRDAR] = eaddr; if (rwx == 1) { env->spr[SPRDSISR] = 0x42000000; } else { env->spr[SPRDSISR] = 0x40000000; } } return 1; } qemulogmask(CPULOGMMU, \"found PTE at offset %08\" HWADDRPRIx \"\\n\", pteoffset); /* 5. Check access permissions */ ppprot = ppchash64pteprot(cpu, slb, pte); amrprot = ppchash64amrprot(cpu, pte); prot = ppprot & amrprot; if ((needprot[rwx] & ~prot) != 0) { /* Access right violation */ qemulogmask(CPULOGMMU, \"PTE access rejected\\n\"); if (rwx == 2) { cs->exceptionindex = POWERPCEXCPISI; env->errorcode = 0x08000000; } else { targetulong dsisr = 0; cs->exceptionindex = POWERPCEXCPDSI; env->errorcode = 0; env->spr[SPRDAR] = eaddr; if (needprot[rwx] & ~ppprot) { dsisr |= 0x08000000; } if (rwx == 1) { dsisr |= 0x02000000; } if (needprot[rwx] & ~amrprot) { dsisr |= 0x00200000; } env->spr[SPRDSISR] = dsisr; } return 1; } qemulogmask(CPULOGMMU, \"PTE access granted !\\n\"); /* 6. Update PTE referenced and changed bits if necessary */ newpte1 = pte.pte1 | HPTE64RR; /* set referenced bit */ if (rwx == 1) { newpte1 |= HPTE64RC; /* set changed (dirty) bit */ } else { /* Treat the page as read-only for now, so that a later write * will pass through this function again to set the C bit */ prot &= ~PAGEWRITE; } if (newpte1 != pte.pte1) { ppchash64storehpte(cpu, pteoffset / HASHPTESIZE64, pte.pte0, newpte1); } /* 7. Determine the real address from the PTE */ raddr = deposit64(pte.pte1 & HPTE64RRPN, 0, slb->sps->pageshift, eaddr); tlbsetpage(cs, eaddr & TARGETPAGEMASK, raddr & TARGETPAGEMASK, prot, mmuidx, TARGETPAGESIZE); return 0; } ", "target": 1}
{"func": "static int pcxdecodeframe(AVCodecContext *avctx, void *data, int *datasize, AVPacket *avpkt) { const uint8t *buf = avpkt->data; int bufsize = avpkt->size; PCXContext * const s = avctx->privdata; AVFrame *picture = data; AVFrame * const p = &s->picture; int compressed, xmin, ymin, xmax, ymax; unsigned int w, h, bitsperpixel, bytesperline, nplanes, stride, y, x, bytesperscanline; uint8t *ptr; uint8t const *bufstart = buf; uint8t *scanline; int ret = -1; if (buf[0] != 0x0a || buf[1] > 5) { avlog(avctx, AVLOGERROR, \"this is not PCX encoded data\\n\"); return AVERRORINVALIDDATA; } compressed = buf[2]; xmin = AVRL16(buf+ 4); ymin = AVRL16(buf+ 6); xmax = AVRL16(buf+ 8); ymax = AVRL16(buf+10); if (xmax < xmin || ymax < ymin) { avlog(avctx, AVLOGERROR, \"invalid image dimensions\\n\"); return AVERRORINVALIDDATA; } w = xmax - xmin + 1; h = ymax - ymin + 1; bitsperpixel = buf[3]; bytesperline = AVRL16(buf+66); nplanes = buf[65]; bytesperscanline = nplanes * bytesperline; if (bytesperscanline < w * bitsperpixel * nplanes / 8) { avlog(avctx, AVLOGERROR, \"PCX data is corrupted\\n\"); return AVERRORINVALIDDATA; } switch ((nplanes<<8) + bitsperpixel) { case 0x0308: avctx->pixfmt = AVPIXFMTRGB24; break; case 0x0108: case 0x0104: case 0x0102: case 0x0101: case 0x0401: case 0x0301: case 0x0201: avctx->pixfmt = AVPIXFMTPAL8; break; default: avlog(avctx, AVLOGERROR, \"invalid PCX file\\n\"); return AVERRORINVALIDDATA; } buf += 128; if (p->data[0]) avctx->releasebuffer(avctx, p); if (avimagechecksize(w, h, 0, avctx)) return AVERRORINVALIDDATA; if (w != avctx->width || h != avctx->height) avcodecsetdimensions(avctx, w, h); if ((ret = avctx->getbuffer(avctx, p)) < 0) { avlog(avctx, AVLOGERROR, \"getbuffer() failed\\n\"); return ret; } p->picttype = AVPICTURETYPEI; ptr = p->data[0]; stride = p->linesize[0]; scanline = avmalloc(bytesperscanline); if (!scanline) return AVERROR(ENOMEM); if (nplanes == 3 && bitsperpixel == 8) { for (y=0; y<h; y++) { buf = pcxrledecode(buf, scanline, bytesperscanline, compressed); for (x=0; x<w; x++) { ptr[3*x ] = scanline[x ]; ptr[3*x+1] = scanline[x+ bytesperline ]; ptr[3*x+2] = scanline[x+(bytesperline<<1)]; } ptr += stride; } } else if (nplanes == 1 && bitsperpixel == 8) { const uint8t *palstart = bufstart + bufsize - 769; for (y=0; y<h; y++, ptr+=stride) { buf = pcxrledecode(buf, scanline, bytesperscanline, compressed); memcpy(ptr, scanline, w); } if (buf != palstart) { avlog(avctx, AVLOGWARNING, \"image data possibly corrupted\\n\"); buf = palstart; } if (*buf++ != 12) { avlog(avctx, AVLOGERROR, \"expected palette after image data\\n\"); ret = AVERRORINVALIDDATA; goto end; } } else if (nplanes == 1) { /* all packed formats, max. 16 colors */ GetBitContext s; for (y=0; y<h; y++) { initgetbits(&s, scanline, bytesperscanline<<3); buf = pcxrledecode(buf, scanline, bytesperscanline, compressed); for (x=0; x<w; x++) ptr[x] = getbits(&s, bitsperpixel); ptr += stride; } } else { /* planar, 4, 8 or 16 colors */ int i; for (y=0; y<h; y++) { buf = pcxrledecode(buf, scanline, bytesperscanline, compressed); for (x=0; x<w; x++) { int m = 0x80 >> (x&7), v = 0; for (i=nplanes - 1; i>=0; i--) { v <<= 1; v += !!(scanline[i*bytesperline + (x>>3)] & m); } ptr[x] = v; } ptr += stride; } } if (nplanes == 1 && bitsperpixel == 8) { pcxpalette(&buf, (uint32t *) p->data[1], 256); } else if (bitsperpixel * nplanes == 1) { AVWN32A(p->data[1] , 0xFF000000); AVWN32A(p->data[1]+4, 0xFFFFFFFF); } else if (bitsperpixel < 8) { const uint8t *palette = bufstart+16; pcxpalette(&palette, (uint32t *) p->data[1], 16); } *picture = s->picture; *datasize = sizeof(AVFrame); ret = buf - bufstart; end: avfree(scanline); return ret; } ", "target": 1}
{"func": "QemuOpts *qemuoptsfromqdict(QemuOptsList *list, const QDict *qdict) { QemuOpts *opts; opts = qemuoptscreate(list, qdictgettrystr(qdict, \"id\"), 1); if (opts == NULL) return NULL; qdictiter(qdict, qemuoptsfromqdict1, opts); return opts; } ", "target": 1}
{"func": "static void conditionalbranch(DBDMAchannel *ch) { dbdmacmd *current = &ch->current; uint16t br; uint16t selmask, selvalue; uint32t status; int cond; DBDMADPRINTF(\"conditionalbranch\\n\"); /* check if we must branch */ br = le16tocpu(current->command) & BRMASK; switch(br) { case BRNEVER: /* don't branch */ next(ch); return; case BRALWAYS: /* always branch */ branch(ch); return; } status = be32tocpu(ch->regs[DBDMASTATUS]) & DEVSTAT; selmask = (be32tocpu(ch->regs[DBDMABRANCHSEL]) >> 16) & 0x0f; selvalue = be32tocpu(ch->regs[DBDMABRANCHSEL]) & 0x0f; cond = (status & selmask) == (selvalue & selmask); switch(br) { case BRIFSET: /* branch if condition bit is 1 */ if (cond) branch(ch); else next(ch); return; case BRIFCLR: /* branch if condition bit is 0 */ if (!cond) branch(ch); else next(ch); return; } } ", "target": 0}
{"func": "static void dequantizationint(int x, int y, Jpeg2000Cblk *cblk, Jpeg2000Component *comp, Jpeg2000T1Context *t1, Jpeg2000Band *band) { int i, j; int w = cblk->coord[0][1] - cblk->coord[0][0]; for (j = 0; j < (cblk->coord[1][1] - cblk->coord[1][0]); ++j) { int32t *datap = &comp->idata[(comp->coord[0][1] - comp->coord[0][0]) * (y + j) + x]; int *src = t1->data[j]; if (band->istepsize == 16384) { for (i = 0; i < w; ++i) datap[i] = src[i] / 2; } else { // This should be VERY uncommon for (i = 0; i < w; ++i) datap[i] = (src[i] * (int64t)band->istepsize) / 32768; } } } ", "target": 0}
{"func": "static void gdbaccept(void) { GDBState *s; struct sockaddrin sockaddr; socklent len; int fd; for(;;) { len = sizeof(sockaddr); fd = accept(gdbserverfd, (struct sockaddr *)&sockaddr, &len); if (fd < 0 && errno != EINTR) { perror(\"accept\"); return; } else if (fd >= 0) { #ifndef WIN32 fcntl(fd, FSETFD, FDCLOEXEC); #endif break; } } /* set short latency */ socketsetnodelay(fd); s = gmalloc0(sizeof(GDBState)); s->ccpu = firstcpu; s->gcpu = firstcpu; s->fd = fd; gdbhasxml = false; gdbserverstate = s; fcntl(fd, FSETFL, ONONBLOCK); } ", "target": 0}
{"func": "static int vaapiencodeh265initsequenceparams(AVCodecContext *avctx) { VAAPIEncodeContext *ctx = avctx->privdata; VAEncSequenceParameterBufferHEVC *vseq = ctx->codecsequenceparams; VAEncPictureParameterBufferHEVC *vpic = ctx->codecpictureparams; VAAPIEncodeH265Context *priv = ctx->privdata; VAAPIEncodeH265MiscSequenceParams *mseq = &priv->miscsequenceparams; int i; { // generalprofilespace == 0. vseq->generalprofileidc = 1; // Main profile (ctx->codecprofile?) vseq->generaltierflag = 0; vseq->generallevelidc = avctx->level * 3; vseq->intraperiod = 0; vseq->intraidrperiod = 0; vseq->ipperiod = 0; vseq->picwidthinlumasamples = ctx->alignedwidth; vseq->picheightinlumasamples = ctx->alignedheight; vseq->seqfields.bits.chromaformatidc = 1; // 4:2:0. vseq->seqfields.bits.separatecolourplaneflag = 0; vseq->seqfields.bits.bitdepthlumaminus8 = 0; // 8-bit luma. vseq->seqfields.bits.bitdepthchromaminus8 = 0; // 8-bit chroma. // Other misc flags all zero. // These have to come from the capabilities of the encoder. We have // no way to query it, so just hardcode ones which worked for me... // CTB size from 8x8 to 32x32. vseq->log2minlumacodingblocksizeminus3 = 0; vseq->log2diffmaxminlumacodingblocksize = 2; // Transform size from 4x4 to 32x32. vseq->log2mintransformblocksizeminus2 = 0; vseq->log2diffmaxmintransformblocksize = 3; // Full transform hierarchy allowed (2-5). vseq->maxtransformhierarchydepthinter = 3; vseq->maxtransformhierarchydepthintra = 3; vseq->vuiparameterspresentflag = 0; vseq->bitspersecond = avctx->bitrate; if (avctx->framerate.num > 0 && avctx->framerate.den > 0) { vseq->vuinumunitsintick = avctx->framerate.num; vseq->vuitimescale = avctx->framerate.den; } else { vseq->vuinumunitsintick = avctx->timebase.num; vseq->vuitimescale = avctx->timebase.den; } vseq->intraperiod = ctx->pperi * (ctx->bperp + 1); vseq->intraidrperiod = vseq->intraperiod; vseq->ipperiod = ctx->bperp + 1; } { vpic->decodedcurrpic.pictureid = VAINVALIDID; vpic->decodedcurrpic.flags = VAPICTUREHEVCINVALID; for (i = 0; i < FFARRAYELEMS(vpic->referenceframes); i++) { vpic->referenceframes[i].pictureid = VAINVALIDID; vpic->referenceframes[i].flags = VAPICTUREHEVCINVALID; } vpic->collocatedrefpicindex = 0xff; vpic->lastpicture = 0; vpic->picinitqp = priv->fixedqpidr; vpic->diffcuqpdeltadepth = 0; vpic->ppscbqpoffset = 0; vpic->ppscrqpoffset = 0; // tilesenabledflag == 0, so ignore numtile(rows|columns)minus1. vpic->log2parallelmergelevelminus2 = 0; // No limit on size. vpic->ctumaxbitsizeallowed = 0; vpic->numrefidxl0defaultactiveminus1 = 0; vpic->numrefidxl1defaultactiveminus1 = 0; vpic->slicepicparametersetid = 0; vpic->picfields.bits.screencontentflag = 0; vpic->picfields.bits.enablegpuweightedprediction = 0; // Per-CU QP changes are required for non-constant-QP modes. vpic->picfields.bits.cuqpdeltaenabledflag = ctx->varcmode != VARCCQP; } { mseq->videoparametersetid = 5; mseq->seqparametersetid = 5; mseq->vpsmaxlayersminus1 = 0; mseq->vpsmaxsublayersminus1 = 0; mseq->vpstemporalidnestingflag = 1; mseq->spsmaxsublayersminus1 = 0; mseq->spstemporalidnestingflag = 1; for (i = 0; i < 32; i++) { mseq->generalprofilecompatibilityflag[i] = (i == vseq->generalprofileidc); } mseq->generalprogressivesourceflag = 1; mseq->generalinterlacedsourceflag = 0; mseq->generalnonpackedconstraintflag = 0; mseq->generalframeonlyconstraintflag = 1; mseq->generalinbldflag = 0; mseq->log2maxpicordercntlsbminus4 = 8; mseq->vpssublayerorderinginfopresentflag = 0; mseq->vpsmaxdecpicbufferingminus1[0] = 1; mseq->vpsmaxnumreorderpics[0] = ctx->bperp; mseq->vpsmaxlatencyincreaseplus1[0] = 0; mseq->spssublayerorderinginfopresentflag = 0; mseq->spsmaxdecpicbufferingminus1[0] = 1; mseq->spsmaxnumreorderpics[0] = ctx->bperp; mseq->spsmaxlatencyincreaseplus1[0] = 0; mseq->vpstiminginfopresentflag = 1; mseq->vpsnumunitsintick = avctx->timebase.num; mseq->vpstimescale = avctx->timebase.den; mseq->vpspocproportionaltotimingflag = 1; mseq->vpsnumtickspocdiffminus1 = 0; if (ctx->inputwidth != ctx->alignedwidth || ctx->inputheight != ctx->alignedheight) { mseq->conformancewindowflag = 1; mseq->confwinleftoffset = 0; mseq->confwinrightoffset = (ctx->alignedwidth - ctx->inputwidth) / 2; mseq->confwintopoffset = 0; mseq->confwinbottomoffset = (ctx->alignedheight - ctx->inputheight) / 2; } else { mseq->conformancewindowflag = 0; } mseq->numshorttermrefpicsets = 0; // STRPSs should ideally be here rather than repeated in each slice. mseq->vuiparameterspresentflag = 1; if (avctx->sampleaspectratio.num != 0) { mseq->aspectratioinfopresentflag = 1; if (avctx->sampleaspectratio.num == avctx->sampleaspectratio.den) { mseq->aspectratioidc = 1; } else { mseq->aspectratioidc = 255; // Extended SAR. mseq->sarwidth = avctx->sampleaspectratio.num; mseq->sarheight = avctx->sampleaspectratio.den; } } if (1) { // Should this be conditional on some of these being set? mseq->videosignaltypepresentflag = 1; mseq->videoformat = 5; // Unspecified. mseq->videofullrangeflag = 0; mseq->colourdescriptionpresentflag = 1; mseq->colourprimaries = avctx->colorprimaries; mseq->transfercharacteristics = avctx->colortrc; mseq->matrixcoeffs = avctx->colorspace; } } return 0; } ", "target": 0}
{"func": "static void rdftcalcc(RDFTContext *s, FFTSample *data) { int i, i1, i2; FFTComplex ev, od; const int n = 1 << s->nbits; const float k1 = 0.5; const float k2 = 0.5 - s->inverse; const FFTSample *tcos = s->tcos; const FFTSample *tsin = s->tsin; if (!s->inverse) { s->fft.fftpermute(&s->fft, (FFTComplex*)data); s->fft.fftcalc(&s->fft, (FFTComplex*)data); } /* i=0 is a special case because of packing, the DC term is real, so we are going to throw the N/2 term (also real) in with it. */ ev.re = data[0]; data[0] = ev.re+data[1]; data[1] = ev.re-data[1]; for (i = 1; i < (n>>2); i++) { i1 = 2*i; i2 = n-i1; /* Separate even and odd FFTs */ ev.re = k1*(data[i1 ]+data[i2 ]); od.im = -k2*(data[i1 ]-data[i2 ]); ev.im = k1*(data[i1+1]-data[i2+1]); od.re = k2*(data[i1+1]+data[i2+1]); /* Apply twiddle factors to the odd FFT and add to the even FFT */ data[i1 ] = ev.re + od.re*tcos[i] - od.im*tsin[i]; data[i1+1] = ev.im + od.im*tcos[i] + od.re*tsin[i]; data[i2 ] = ev.re - od.re*tcos[i] + od.im*tsin[i]; data[i2+1] = -ev.im + od.im*tcos[i] + od.re*tsin[i]; } data[2*i+1]=s->signconvention*data[2*i+1]; if (s->inverse) { data[0] *= k1; data[1] *= k1; s->fft.fftpermute(&s->fft, (FFTComplex*)data); s->fft.fftcalc(&s->fft, (FFTComplex*)data); } } ", "target": 0}
{"func": "static avcold int g726init(AVCodecContext * avctx) { AVG726Context* c = (AVG726Context*)avctx->privdata; unsigned int index= (avctx->bitrate + avctx->samplerate/2) / avctx->samplerate - 2; if ( (avctx->bitrate != 16000 && avctx->bitrate != 24000 && avctx->bitrate != 32000 && avctx->bitrate != 40000)) { avlog(avctx, AVLOGERROR, \"G726: unsupported audio format\\n\"); return -1; } if (avctx->samplerate != 8000 && avctx->strictstdcompliance>FFCOMPLIANCEINOFFICIAL) { avlog(avctx, AVLOGERROR, \"G726: unsupported audio format\\n\"); return -1; } if(avctx->channels != 1){ avlog(avctx, AVLOGERROR, \"Only mono is supported\\n\"); return -1; } if(index>3){ avlog(avctx, AVLOGERROR, \"Unsupported number of bits %d\\n\", index+2); return -1; } g726reset(&c->c, index); c->codesize = c->c.tbls->bits; c->bitbuffer = 0; c->bitsleft = 0; avctx->codedframe = avcodecallocframe(); if (!avctx->codedframe) return AVERROR(ENOMEM); avctx->codedframe->keyframe = 1; return 0; } ", "target": 0}
{"func": "unsigned long findnextzerobit(const unsigned long *addr, unsigned long size, \t\t\t\t unsigned long offset) { const unsigned long *p = addr + BITOPWORD(offset); unsigned long result = offset & ~(BITSPERLONG-1); unsigned long tmp; if (offset >= size) { return size; } size -= result; offset %= BITSPERLONG; if (offset) { tmp = *(p++); tmp |= ~0UL >> (BITSPERLONG - offset); if (size < BITSPERLONG) { goto foundfirst; } if (~tmp) { goto foundmiddle; } size -= BITSPERLONG; result += BITSPERLONG; } while (size & ~(BITSPERLONG-1)) { if (~(tmp = *(p++))) { goto foundmiddle; } result += BITSPERLONG; size -= BITSPERLONG; } if (!size) { return result; } tmp = *p; foundfirst: tmp |= ~0UL << size; if (tmp == ~0UL) {\t/* Are any bits zero? */ return result + size;\t/* Nope. */ } foundmiddle: return result + ffz(tmp); } ", "target": 1}
{"func": "void visitendimplicitstruct(Visitor *v, Error **errp) { assert(!errorisset(errp)); if (v->endimplicitstruct) { v->endimplicitstruct(v, errp); } } ", "target": 1}
{"func": "static int nbdrejectlength(NBDClient *client, bool fatal, Error **errp) { int ret; assert(client->optlen); if (nbddrop(client->ioc, client->optlen, errp) < 0) { return -EIO; } ret = nbdnegotiatesendreperr(client, NBDREPERRINVALID, errp, \"option '%s' should have zero length\", nbdoptlookup(client->opt)); if (fatal && !ret) { errorsetg(errp, \"option '%s' should have zero length\", nbdoptlookup(client->opt)); return -EINVAL; } return ret; } ", "target": 1}
{"func": "static int kvmppcreadhostproperty(const char *nodepath, const char *prop, void *val, sizet len) { char *path; FILE *f; int ret; int pathlen; pathlen = snprintf(NULL, 0, \"%s/%s/%s\", PROCDEVTREEPATH, nodepath, prop) + 1; path = qemumalloc(pathlen); if (path == NULL) { ret = -ENOMEM; goto out; } snprintf(path, pathlen, \"%s/%s/%s\", PROCDEVTREEPATH, nodepath, prop); f = fopen(path, \"rb\"); if (f == NULL) { ret = errno; goto free; } len = fread(val, len, 1, f); if (len != 1) { ret = ferror(f); goto close; } close: fclose(f); free: free(path); out: return ret; } ", "target": 1}
{"func": "static void tcgoutqemuld(TCGContext *s, TCGReg data, TCGReg addr, TCGMemOpIdx oi, bool is64) { TCGMemOp memop = getmemop(oi); #ifdef CONFIGSOFTMMU unsigned memi = getmmuidx(oi); TCGReg addrz, param; tcginsnunit *func; tcginsnunit *labelptr; addrz = tcgouttlbload(s, addr, memi, memop, offsetof(CPUTLBEntry, addrread)); /* The fast path is exactly one insn. Thus we can perform the entire TLB Hit in the (annulled) delay slot of the branch over the TLB Miss case. */ /* beq,a,pt %[xi]cc, label0 */ labelptr = s->codeptr; tcgoutbpcc0(s, CONDE, BPCCA | BPCCPT | (TARGETLONGBITS == 64 ? BPCCXCC : BPCCICC), 0); /* delay slot */ tcgoutldstrr(s, data, addrz, TCGREGO1, qemuldopc[memop & (MOBSWAP | MOSSIZE)]); /* TLB Miss. */ param = TCGREGO1; if (!SPARC64 && TARGETLONGBITS == 64) { /* Skip the high-part; we'll perform the extract in the trampoline. */ param++; } tcgoutmov(s, TCGTYPEREG, param++, addr); /* We use the helpers to extend SB and SW data, leaving the case of SL needing explicit extending below. */ if ((memop & MOSSIZE) == MOSL) { func = qemuldtrampoline[memop & (MOBSWAP | MOSIZE)]; } else { func = qemuldtrampoline[memop & (MOBSWAP | MOSSIZE)]; } tcgdebugassert(func != NULL); tcgoutcallnodelay(s, func); /* delay slot */ tcgoutmovi(s, TCGTYPEI32, param, oi); /* Recall that all of the helpers return 64-bit results. Which complicates things for sparcv8plus. */ if (SPARC64) { /* We let the helper sign-extend SB and SW, but leave SL for here. */ if (is64 && (memop & MOSSIZE) == MOSL) { tcgoutarithi(s, data, TCGREGO0, 0, SHIFTSRA); } else { tcgoutmov(s, TCGTYPEREG, data, TCGREGO0); } } else { if ((memop & MOSIZE) == MO64) { tcgoutarithi(s, TCGREGO0, TCGREGO0, 32, SHIFTSLLX); tcgoutarithi(s, TCGREGO1, TCGREGO1, 0, SHIFTSRL); tcgoutarith(s, data, TCGREGO0, TCGREGO1, ARITHOR); } else if (is64) { /* Re-extend from 32-bit rather than reassembling when we know the high register must be an extension. */ tcgoutarithi(s, data, TCGREGO1, 0, memop & MOSIGN ? SHIFTSRA : SHIFTSRL); } else { tcgoutmov(s, TCGTYPEI32, data, TCGREGO1); } } *labelptr |= INSNOFF19(tcgptrbytediff(s->codeptr, labelptr)); #else if (SPARC64 && TARGETLONGBITS == 32) { tcgoutarithi(s, TCGREGT1, addr, 0, SHIFTSRL); addr = TCGREGT1; } tcgoutldstrr(s, data, addr, (guestbase ? TCGGUESTBASEREG : TCGREGG0), qemuldopc[memop & (MOBSWAP | MOSSIZE)]); #endif /* CONFIGSOFTMMU */ } ", "target": 1}
{"func": "optsvisitorcleanup(OptsVisitor *ov) { if (ov->unprocessedopts != NULL) { ghashtabledestroy(ov->unprocessedopts); } gfree(ov->fakeidopt); memset(ov, '\\0', sizeof *ov); } ", "target": 1}
{"func": "static int usbhostopen(USBHostDevice *s, libusbdevice *dev) { USBDevice *udev = USBDEVICE(s); int busnum = libusbgetbusnumber(dev); int addr = libusbgetdeviceaddress(dev); int rc; traceusbhostopenstarted(busnum, addr); if (s->dh != NULL) { goto fail; } rc = libusbopen(dev, &s->dh); if (rc != 0) { goto fail; } s->dev = dev; s->busnum = busnum; s->addr = addr; usbhostdetachkernel(s); libusbgetdevicedescriptor(dev, &s->ddesc); usbhostgetport(s->dev, s->port, sizeof(s->port)); usbepinit(udev); usbhostepupdate(s); udev->speed = speedmap[libusbgetdevicespeed(dev)]; usbhostspeedcompat(s); if (s->ddesc.iProduct) { libusbgetstringdescriptorascii(s->dh, s->ddesc.iProduct, (unsigned char *)udev->productdesc, sizeof(udev->productdesc)); } else { snprintf(udev->productdesc, sizeof(udev->productdesc), \"host:%d.%d\", busnum, addr); } rc = usbdeviceattach(udev); if (rc) { goto fail; } traceusbhostopensuccess(busnum, addr); return 0; fail: traceusbhostopenfailure(busnum, addr); if (s->dh != NULL) { libusbclose(s->dh); s->dh = NULL; s->dev = NULL; } return -1; } ", "target": 0}
{"func": "int64t xbzrlecacheresize(int64t newsize, Error **errp) { PageCache *newcache; int64t ret; /* Check for truncation */ if (newsize != (sizet)newsize) { errorsetg(errp, QERRINVALIDPARAMETERVALUE, \"cache size\", \"exceeding address space\"); return -1; } /* Cache should not be larger than guest ram size */ if (newsize > rambytestotal()) { errorsetg(errp, QERRINVALIDPARAMETERVALUE, \"cache size\", \"exceeds guest ram size\"); return -1; } XBZRLEcachelock(); if (XBZRLE.cache != NULL) { if (pow2floor(newsize) == migratexbzrlecachesize()) { goto outnewsize; } newcache = cacheinit(newsize, TARGETPAGESIZE, errp); if (!newcache) { ret = -1; goto out; } cachefini(XBZRLE.cache); XBZRLE.cache = newcache; } outnewsize: ret = pow2floor(newsize); out: XBZRLEcacheunlock(); return ret; } ", "target": 0}
{"func": "static void setuprtframe(int sig, struct targetsigaction *ka, targetsiginfot *info, targetsigsett *set, CPUAlphaState *env) { abiulong frameaddr, r26; struct targetrtsigframe *frame; int i, err = 0; frameaddr = getsigframe(ka, env, sizeof(*frame)); if (!lockuserstruct(VERIFYWRITE, frame, frameaddr, 0)) { goto givesigsegv; } err |= copysiginfotouser(&frame->info, info); putuser(0, &frame->uc.tucflags); putuser(0, &frame->uc.tuclink); putuser(set->sig[0], &frame->uc.tucosfsigmask); putuser(targetsigaltstackused.sssp, &frame->uc.tucstack.sssp); putuser(sasssflags(env->ir[IRSP]), &frame->uc.tucstack.ssflags); putuser(targetsigaltstackused.sssize, &frame->uc.tucstack.sssize); err |= setupsigcontext(&frame->uc.tucmcontext, env, frameaddr, set); for (i = 0; i < TARGETNSIGWORDS; ++i) { putuser(set->sig[i], &frame->uc.tucsigmask.sig[i]); } if (ka->sarestorer) { r26 = ka->sarestorer; } else { putuser(INSNMOVR30R16, &frame->retcode[0]); putuser(INSNLDIR0 + TARGETNRrtsigreturn, &frame->retcode[1]); putuser(INSNCALLSYS, &frame->retcode[2]); /* imb(); */ r26 = frameaddr; } if (err) { givesigsegv: if (sig == TARGETSIGSEGV) { ka->sahandler = TARGETSIGDFL; } forcesig(TARGETSIGSEGV); } env->ir[IRRA] = r26; env->ir[IRPV] = env->pc = ka->sahandler; env->ir[IRA0] = sig; env->ir[IRA1] = frameaddr + offsetof(struct targetrtsigframe, info); env->ir[IRA2] = frameaddr + offsetof(struct targetrtsigframe, uc); env->ir[IRSP] = frameaddr; } ", "target": 0}
{"func": "static void imxgptreset(DeviceState *dev) { IMXGPTState *s = IMXGPT(dev); /* stop timer */ ptimerstop(s->timer); /* * Soft reset doesn't touch some bits; hard reset clears them */ s->cr &= ~(GPTCREN|GPTCRENMOD|GPTCRSTOPEN|GPTCRDOZEN| GPTCRWAITEN|GPTCRDBGEN); s->sr = 0; s->pr = 0; s->ir = 0; s->cnt = 0; s->ocr1 = TIMERMAX; s->ocr2 = TIMERMAX; s->ocr3 = TIMERMAX; s->icr1 = 0; s->icr2 = 0; s->nexttimeout = TIMERMAX; s->nextint = 0; /* compute new freq */ imxgptsetfreq(s); /* reset the limit to TIMERMAX */ ptimersetlimit(s->timer, TIMERMAX, 1); /* if the timer is still enabled, restart it */ if (s->freq && (s->cr & GPTCREN)) { ptimerrun(s->timer, 1); } } ", "target": 0}
{"func": "static int dynticksstarttimer(struct qemualarmtimer *t) { struct sigevent ev; timert hosttimer; struct sigaction act; sigfillset(&act.samask); act.saflags = 0; act.sahandler = hostalarmhandler; sigaction(SIGALRM, &act, NULL); ev.sigevvalue.sivalint = 0; ev.sigevnotify = SIGEVSIGNAL; ev.sigevsigno = SIGALRM; if (timercreate(CLOCKREALTIME, &ev, &hosttimer)) { perror(\"timercreate\"); /* disable dynticks */ fprintf(stderr, \"Dynamic Ticks disabled\\n\"); return -1; } t->priv = (void *)(long)hosttimer; return 0; }", "target": 1}
{"func": "static void s390pcigenerateevent(uint8t cc, uint16t pec, uint32t fh, uint32t fid, uint64t faddr, uint32t e) { SeiContainer *seicont = gmalloc0(sizeof(SeiContainer)); S390pciState *s = S390PCIHOSTBRIDGE( objectresolvepath(TYPES390PCIHOSTBRIDGE, NULL)); if (!s) { return; } seicont->fh = fh; seicont->fid = fid; seicont->cc = cc; seicont->pec = pec; seicont->faddr = faddr; seicont->e = e; QTAILQINSERTTAIL(&s->pendingsei, seicont, link); cssgeneratecsscrws(0); } ", "target": 1}
{"func": "void cpsrwrite(CPUARMState *env, uint32t val, uint32t mask, CPSRWriteType writetype) { uint32t changeddaif; if (mask & CPSRNZCV) { env->ZF = (~val) & CPSRZ; env->NF = val; env->CF = (val >> 29) & 1; env->VF = (val << 3) & 0x80000000; } if (mask & CPSRQ) env->QF = ((val & CPSRQ) != 0); if (mask & CPSRT) env->thumb = ((val & CPSRT) != 0); if (mask & CPSRIT01) { env->condexecbits &= ~3; env->condexecbits |= (val >> 25) & 3; } if (mask & CPSRIT27) { env->condexecbits &= 3; env->condexecbits |= (val >> 8) & 0xfc; } if (mask & CPSRGE) { env->GE = (val >> 16) & 0xf; } /* In a V7 implementation that includes the security extensions but does * not include Virtualization Extensions the SCR.FW and SCR.AW bits control * whether non-secure software is allowed to change the CPSRF and CPSRA * bits respectively. * * In a V8 implementation, it is permitted for privileged software to * change the CPSR A/F bits regardless of the SCR.AW/FW bits. */ if (writetype != CPSRWriteRaw && !armfeature(env, ARMFEATUREV8) && armfeature(env, ARMFEATUREEL3) && !armfeature(env, ARMFEATUREEL2) && !armissecure(env)) { changeddaif = (env->daif ^ val) & mask; if (changeddaif & CPSRA) { /* Check to see if we are allowed to change the masking of async * abort exceptions from a non-secure state. */ if (!(env->cp15.screl3 & SCRAW)) { qemulogmask(LOGGUESTERROR, \"Ignoring attempt to switch CPSRA flag from \" \"non-secure world with SCR.AW bit clear\\n\"); mask &= ~CPSRA; } } if (changeddaif & CPSRF) { /* Check to see if we are allowed to change the masking of FIQ * exceptions from a non-secure state. */ if (!(env->cp15.screl3 & SCRFW)) { qemulogmask(LOGGUESTERROR, \"Ignoring attempt to switch CPSRF flag from \" \"non-secure world with SCR.FW bit clear\\n\"); mask &= ~CPSRF; } /* Check whether non-maskable FIQ (NMFI) support is enabled. * If this bit is set software is not allowed to mask * FIQs, but is allowed to set CPSRF to 0. */ if ((A32BANKEDCURRENTREGGET(env, sctlr) & SCTLRNMFI) && (val & CPSRF)) { qemulogmask(LOGGUESTERROR, \"Ignoring attempt to enable CPSRF flag \" \"(non-maskable FIQ [NMFI] support enabled)\\n\"); mask &= ~CPSRF; } } } env->daif &= ~(CPSRAIF & mask); env->daif |= val & CPSRAIF & mask; if (writetype != CPSRWriteRaw && (env->uncachedcpsr & CPSRM) != CPSRUSER && ((env->uncachedcpsr ^ val) & mask & CPSRM)) { if (badmodeswitch(env, val & CPSRM)) { /* Attempt to switch to an invalid mode: this is UNPREDICTABLE. * We choose to ignore the attempt and leave the CPSR M field * untouched. */ mask &= ~CPSRM; } else { switchmode(env, val & CPSRM); } } mask &= ~CACHEDCPSRBITS; env->uncachedcpsr = (env->uncachedcpsr & ~mask) | (val & mask); } ", "target": 1}
{"func": "static void vfioprobenvidiabar0quirk(VFIOPCIDevice *vdev, int nr) { VFIOQuirk *quirk; VFIOConfigMirrorQuirk *mirror; if (!vfiopciis(vdev, PCIVENDORIDNVIDIA, PCIANYID) || !vfioisvga(vdev) || nr != 0) { return; } quirk = gmalloc0(sizeof(*quirk)); mirror = quirk->data = gmalloc0(sizeof(*mirror)); mirror->mem = quirk->mem = gmalloc0(sizeof(MemoryRegion)); quirk->nrmem = 1; mirror->vdev = vdev; mirror->offset = 0x88000; mirror->bar = nr; memoryregioninitio(mirror->mem, OBJECT(vdev), &vfionvidiamirrorquirk, mirror, \"vfio-nvidia-bar0-88000-mirror-quirk\", PCIECONFIGSPACESIZE); memoryregionaddsubregionoverlap(&vdev->bars[nr].region.mem, mirror->offset, mirror->mem, 1); QLISTINSERTHEAD(&vdev->bars[nr].quirks, quirk, next); /* The 0x1800 offset mirror only seems to get used by legacy VGA */ if (vdev->hasvga) { quirk = gmalloc0(sizeof(*quirk)); mirror = quirk->data = gmalloc0(sizeof(*mirror)); mirror->mem = quirk->mem = gmalloc0(sizeof(MemoryRegion)); quirk->nrmem = 1; mirror->vdev = vdev; mirror->offset = 0x1800; mirror->bar = nr; memoryregioninitio(mirror->mem, OBJECT(vdev), &vfionvidiamirrorquirk, mirror, \"vfio-nvidia-bar0-1800-mirror-quirk\", PCICONFIGSPACESIZE); memoryregionaddsubregionoverlap(&vdev->bars[nr].region.mem, mirror->offset, mirror->mem, 1); QLISTINSERTHEAD(&vdev->bars[nr].quirks, quirk, next); } tracevfioquirknvidiabar0probe(vdev->vbasedev.name); } ", "target": 1}
{"func": "static inline void genoparithcomputeov(DisasContext *ctx, TCGv arg0, TCGv arg1, TCGv arg2, int sub) { TCGv t0 = tcgtempnew(); tcggenxortl(cpuov, arg0, arg1); tcggenxortl(t0, arg1, arg2); if (sub) { tcggenandtl(cpuov, cpuov, t0); } else { tcggenandctl(cpuov, cpuov, t0); } tcgtempfree(t0); if (NARROWMODE(ctx)) { tcggenext32stl(cpuov, cpuov); } tcggenshritl(cpuov, cpuov, TARGETLONGBITS - 1); tcggenortl(cpuso, cpuso, cpuov); } ", "target": 1}
{"func": "static int decodeframe(AVCodecContext *avctx, void *data, int *datasize, uint8t *buf, int bufsize) { H264Context *h = avctx->privdata; MpegEncContext *s = &h->s; AVFrame *pict = data; int bufindex; s->flags= avctx->flags; s->flags2= avctx->flags2; /* no supplementary picture */ if (bufsize == 0) { return 0; } if(s->flags&CODECFLAGTRUNCATED){ int next= findframeend(h, buf, bufsize); if( ffcombineframe(&s->parsecontext, next, &buf, &bufsize) < 0 ) return bufsize; //printf(\"next:%d bufsize:%d lastindex:%d\\n\", next, bufsize, s->parsecontext.lastindex); } if(h->isavc && !h->gotavcC) { int i, cnt, nalsize; unsigned char *p = avctx->extradata; if(avctx->extradatasize < 7) { avlog(avctx, AVLOGERROR, \"avcC too short\\n\"); return -1; } if(*p != 1) { avlog(avctx, AVLOGERROR, \"Unknown avcC version %d\\n\", *p); return -1; } /* sps and pps in the avcC always have length coded with 2 bytes, so put a fake nallengthsize = 2 while parsing them */ h->nallengthsize = 2; // Decode sps from avcC cnt = *(p+5) & 0x1f; // Number of sps p += 6; for (i = 0; i < cnt; i++) { nalsize = BE16(p) + 2; if(decodenalunits(h, p, nalsize) < 0) { avlog(avctx, AVLOGERROR, \"Decoding sps %d from avcC failed\\n\", i); return -1; } p += nalsize; } // Decode pps from avcC cnt = *(p++); // Number of pps for (i = 0; i < cnt; i++) { nalsize = BE16(p) + 2; if(decodenalunits(h, p, nalsize) != nalsize) { avlog(avctx, AVLOGERROR, \"Decoding pps %d from avcC failed\\n\", i); return -1; } p += nalsize; } // Now store right nal length size, that will be use to parse all other nals h->nallengthsize = ((*(((char*)(avctx->extradata))+4))&0x03)+1; // Do not reparse avcC h->gotavcC = 1; } if(!h->isavc && s->avctx->extradatasize && s->picturenumber==0){ if(decodenalunits(h, s->avctx->extradata, s->avctx->extradatasize) < 0) return -1; } bufindex=decodenalunits(h, buf, bufsize); if(bufindex < 0) return -1; //FIXME do something with unavailable reference frames // if(ret==FRAMESKIPPED) return getconsumedbytes(s, bufindex, bufsize); if(!s->currentpictureptr){ avlog(h->s.avctx, AVLOGDEBUG, \"error, NO frame\\n\"); return -1; } { Picture *out = s->currentpictureptr; #if 0 //decode order *datasize = sizeof(AVFrame); #else /* Sort B-frames into display order */ Picture *cur = s->currentpictureptr; Picture *prev = h->delayedoutputpic; int outidx = 0; int pics = 0; int outoforder; int crossidr = 0; int droppedframe = 0; int i; if(h->sps.bitstreamrestrictionflag && s->avctx->hasbframes < h->sps.numreorderframes){ s->avctx->hasbframes = h->sps.numreorderframes; s->lowdelay = 0; } while(h->delayedpic[pics]) pics++; h->delayedpic[pics++] = cur; if(cur->reference == 0) cur->reference = 1; for(i=0; h->delayedpic[i]; i++) if(h->delayedpic[i]->keyframe || h->delayedpic[i]->poc==0) crossidr = 1; out = h->delayedpic[0]; for(i=1; h->delayedpic[i] && !h->delayedpic[i]->keyframe; i++) if(h->delayedpic[i]->poc < out->poc){ out = h->delayedpic[i]; outidx = i; } outoforder = !crossidr && prev && out->poc < prev->poc; if(prev && pics <= s->avctx->hasbframes) out = prev; else if((outoforder && pics-1 == s->avctx->hasbframes) || (s->lowdelay && ((!crossidr && prev && out->poc > prev->poc + 2) || cur->picttype == BTYPE))) { s->lowdelay = 0; s->avctx->hasbframes++; out = prev; } else if(outoforder) out = prev; if(outoforder || pics > s->avctx->hasbframes){ droppedframe = (out != h->delayedpic[outidx]); for(i=outidx; h->delayedpic[i]; i++) h->delayedpic[i] = h->delayedpic[i+1]; } if(prev == out && !droppedframe) *datasize = 0; else *datasize = sizeof(AVFrame); if(prev && prev != out && prev->reference == 1) prev->reference = 0; h->delayedoutputpic = out; #endif *pict= *(AVFrame*)out; } assert(pict->data[0]); ffprintdebuginfo(s, pict); //printf(\"out %d\\n\", (int)pict->data[0]); #if 0 //? /* Return the Picture timestamp as the frame number */ /* we substract 1 because it is added on utils.c */ avctx->framenumber = s->picturenumber - 1; #endif return getconsumedbytes(s, bufindex, bufsize); } ", "target": 1}
{"func": "static void cpucommonreset(CPUState *cpu) { CPUClass *cc = CPUGETCLASS(cpu); if (qemuloglevelmask(CPULOGRESET)) { qemulog(\"CPU Reset (CPU %d)\\n\", cpu->cpuindex); logcpustate(cpu, cc->resetdumpflags); } cpu->interruptrequest = 0; cpu->halted = 0; cpu->memiopc = 0; cpu->memiovaddr = 0; cpu->icountextra = 0; cpu->icountdecr.u32 = 0; cpu->candoio = 1; cpu->exceptionindex = -1; cpu->crashoccurred = false; if (tcgenabled()) { cputbjmpcacheclear(cpu); #ifdef CONFIGSOFTMMU tlbflush(cpu, 0); #endif } } ", "target": 0}
{"func": "int qemuoptsforeach(QemuOptsList *list, qemuoptsloopfunc func, void *opaque, int abortonfailure) { QemuOpts *opts; int rc = 0; TAILQFOREACH(opts, &list->head, next) { rc = func(opts, opaque); if (abortonfailure && rc != 0) break; } return rc; } ", "target": 0}
{"func": "static void subpagewrite(void *opaque, targetphysaddrt addr, uint64t value, unsigned len) { subpaget *mmio = opaque; unsigned int idx = SUBPAGEIDX(addr); MemoryRegionSection *section; #if defined(DEBUGSUBPAGE) printf(\"%s: subpage %p len %d addr \" TARGETFMTplx \" idx %d value %\"PRIx64\"\\n\", func, mmio, len, addr, idx, value); #endif section = &physsections[mmio->subsection[idx]]; addr += mmio->base; addr -= section->offsetwithinaddressspace; addr += section->offsetwithinregion; iomemwrite(section->mr, addr, value, len); } ", "target": 0}
{"func": "static int nvencfindfreeregresource(AVCodecContext *avctx) { NvencContext *ctx = avctx->privdata; NvencDynLoadFunctions *dlfn = &ctx->nvencdloadfuncs; NVENCODEAPIFUNCTIONLIST *pnvenc = &dlfn->nvencfuncs; int i; if (ctx->nbregisteredframes == FFARRAYELEMS(ctx->registeredframes)) { for (i = 0; i < ctx->nbregisteredframes; i++) { if (!ctx->registeredframes[i].mapped) { if (ctx->registeredframes[i].regptr) { pnvenc->nvEncUnregisterResource(ctx->nvencoder, ctx->registeredframes[i].regptr); ctx->registeredframes[i].regptr = NULL; } return i; } } } else { return ctx->nbregisteredframes++; } avlog(avctx, AVLOGERROR, \"Too many registered CUDA frames\\n\"); return AVERROR(ENOMEM); } ", "target": 0}
{"func": "void tbflushjmpcache(CPUState *cpu, targetulong addr) { unsigned int i; /* Discard jump cache entries for any tb which might potentially overlap the flushed page. */ i = tbjmpcachehashpage(addr - TARGETPAGESIZE); memset(&cpu->tbjmpcache[i], 0, TBJMPPAGESIZE * sizeof(TranslationBlock *)); i = tbjmpcachehashpage(addr); memset(&cpu->tbjmpcache[i], 0, TBJMPPAGESIZE * sizeof(TranslationBlock *)); } ", "target": 1}
{"func": "DeviceState *bdrvgetattached(BlockDriverState *bs) { return bs->peer; } ", "target": 0}
{"func": "static void qapideallocpush(QapiDeallocVisitor *qov, void *value) { StackEntry *e = gmalloc0(sizeof(*e)); e->value = value; /* see if we're just pushing a list head tracker */ if (value == NULL) { e->islisthead = true; } QTAILQINSERTHEAD(&qov->stack, e, node); } ", "target": 0}
{"func": "void *vnczlibzalloc(void *x, unsigned items, unsigned size) { void *p; size *= items; size = (size + ZALLOCALIGNMENT - 1) & ~(ZALLOCALIGNMENT - 1); p = qemumallocz(size); return (p); } ", "target": 0}
{"func": "static int sendpngrect(VncState *vs, int x, int y, int w, int h, VncPalette *palette) { pngbyte colortype; pngstructp pngptr; pnginfop infoptr; pngcolorp pngpalette = NULL; pixmanimaget *linebuf; int level = tightpngconf[vs->tight.compression].pngzliblevel; int filters = tightpngconf[vs->tight.compression].pngfilters; uint8t *buf; int dy; pngptr = pngcreatewritestruct2(PNGLIBPNGVERSTRING, NULL, NULL, NULL, NULL, vncpngmalloc, vncpngfree); if (pngptr == NULL) return -1; infoptr = pngcreateinfostruct(pngptr); if (infoptr == NULL) { pngdestroywritestruct(&pngptr, NULL); return -1; } pngsetwritefn(pngptr, (void *) vs, pngwritedata, pngflushdata); pngsetcompressionlevel(pngptr, level); pngsetfilter(pngptr, PNGFILTERTYPEDEFAULT, filters); if (palette) { colortype = PNGCOLORTYPEPALETTE; } else { colortype = PNGCOLORTYPERGB; } pngsetIHDR(pngptr, infoptr, w, h, 8, colortype, PNGINTERLACENONE, PNGCOMPRESSIONTYPEDEFAULT, PNGFILTERTYPEDEFAULT); if (colortype == PNGCOLORTYPEPALETTE) { struct palettecbpriv priv; pngpalette = pngmalloc(pngptr, sizeof(*pngpalette) * palettesize(palette)); priv.vs = vs; priv.pngpalette = pngpalette; paletteiter(palette, writepngpalette, &priv); pngsetPLTE(pngptr, infoptr, pngpalette, palettesize(palette)); if (vs->clientpf.bytesperpixel == 4) { tightencodeindexedrect32(vs->tight.tight.buffer, w * h, palette); } else { tightencodeindexedrect16(vs->tight.tight.buffer, w * h, palette); } } pngwriteinfo(pngptr, infoptr); bufferreserve(&vs->tight.png, 2048); linebuf = qemupixmanlinebufcreate(PIXMANBEr8g8b8, w); buf = (uint8t *)pixmanimagegetdata(linebuf); for (dy = 0; dy < h; dy++) { if (colortype == PNGCOLORTYPEPALETTE) { memcpy(buf, vs->tight.tight.buffer + (dy * w), w); } else { qemupixmanlinebuffill(linebuf, vs->vd->server, w, dy); } pngwriterow(pngptr, buf); } qemupixmanimageunref(linebuf); pngwriteend(pngptr, NULL); if (colortype == PNGCOLORTYPEPALETTE) { pngfree(pngptr, pngpalette); } pngdestroywritestruct(&pngptr, &infoptr); vncwriteu8(vs, VNCTIGHTPNG << 4); tightsendcompactsize(vs, vs->tight.png.offset); vncwrite(vs, vs->tight.png.buffer, vs->tight.png.offset); bufferreset(&vs->tight.png); return 1; } ", "target": 0}
{"func": "void nvdimminitacpistate(AcpiNVDIMMState *state, MemoryRegion *io, FWCfgState *fwcfg, Object *owner) { memoryregioninitio(&state->iomr, owner, &nvdimmdsmops, state, \"nvdimm-acpi-io\", NVDIMMACPIIOLEN); memoryregionaddsubregion(io, NVDIMMACPIIOBASE, &state->iomr); state->dsmmem = garraynew(false, true /* clear */, 1); acpidatapush(state->dsmmem, TARGETPAGESIZE); fwcfgaddfile(fwcfg, NVDIMMDSMMEMFILE, state->dsmmem->data, state->dsmmem->len); } ", "target": 0}
{"func": "static int calculaterefcounts(BlockDriverState *bs, BdrvCheckResult *res, BdrvCheckMode fix, bool *rebuild, void **refcounttable, int64t *nbclusters) { BDRVQcow2State *s = bs->opaque; int64t i; QCowSnapshot *sn; int ret; if (!*refcounttable) { int64t oldsize = 0; ret = reallocrefcountarray(s, refcounttable, &oldsize, *nbclusters); if (ret < 0) { res->checkerrors++; return ret; } } /* header */ ret = increfcounts(bs, res, refcounttable, nbclusters, 0, s->clustersize); if (ret < 0) { return ret; } /* current L1 table */ ret = checkrefcountsl1(bs, res, refcounttable, nbclusters, s->l1tableoffset, s->l1size, CHECKFRAGINFO); if (ret < 0) { return ret; } /* snapshots */ for (i = 0; i < s->nbsnapshots; i++) { sn = s->snapshots + i; ret = checkrefcountsl1(bs, res, refcounttable, nbclusters, sn->l1tableoffset, sn->l1size, 0); if (ret < 0) { return ret; } } ret = increfcounts(bs, res, refcounttable, nbclusters, s->snapshotsoffset, s->snapshotssize); if (ret < 0) { return ret; } /* refcount data */ ret = increfcounts(bs, res, refcounttable, nbclusters, s->refcounttableoffset, s->refcounttablesize * sizeof(uint64t)); if (ret < 0) { return ret; } /* encryption */ if (s->cryptoheader.length) { ret = increfcounts(bs, res, refcounttable, nbclusters, s->cryptoheader.offset, s->cryptoheader.length); if (ret < 0) { return ret; } } return checkrefblocks(bs, res, fix, rebuild, refcounttable, nbclusters); } ", "target": 0}
{"func": "static void ehcitraceqtd(EHCIQueue *q, targetphysaddrt addr, EHCIqtd *qtd) { traceusbehciqtd(q, addr, qtd->next, qtd->altnext, getfield(qtd->token, QTDTOKENTBYTES), getfield(qtd->token, QTDTOKENCPAGE), getfield(qtd->token, QTDTOKENCERR), getfield(qtd->token, QTDTOKENPID), (bool)(qtd->token & QTDTOKENIOC), (bool)(qtd->token & QTDTOKENACTIVE), (bool)(qtd->token & QTDTOKENHALT), (bool)(qtd->token & QTDTOKENBABBLE), (bool)(qtd->token & QTDTOKENXACTERR)); } ", "target": 1}
{"func": "static void megasasscsiuninit(PCIDevice *d) { MegasasState *s = MEGASAS(d); if (megasasusemsix(s)) { msixuninit(d, &s->mmioio, &s->mmioio); } if (megasasusemsi(s)) { msiuninit(d); } } ", "target": 1}
{"func": "static int jpeg2000decodeframe(AVCodecContext *avctx, void *data, int *gotframe, AVPacket *avpkt) { Jpeg2000DecoderContext *s = avctx->privdata; ThreadFrame frame = { .f = data }; AVFrame *picture = data; int tileno, ret; s->avctx = avctx; s->buf = s->bufstart = avpkt->data; s->bufend = s->bufstart + avpkt->size; s->curtileno = 0; // TODO: only one tile in DCI JP2K. to implement for more tiles // reduction factor, i.e number of resolution levels to skip s->reductionfactor = s->lowres; ffjpeg2000inittier1luts(); if (s->bufend - s->buf < 2) return AVERROR(EINVAL); // check if the image is in jp2 format if ((AVRB32(s->buf) == 12) && (AVRB32(s->buf + 4) == JP2SIGTYPE) && (AVRB32(s->buf + 8) == JP2SIGVALUE)) { if (!jp2findcodestream(s)) { avlog(avctx, AVLOGERROR, \"couldn't find jpeg2k codestream atom\\n\"); return -1; } } if (bytestreamgetbe16(&s->buf) != JPEG2000SOC) { avlog(avctx, AVLOGERROR, \"SOC marker not present\\n\"); return -1; } if (ret = jpeg2000readmainheaders(s)) goto end; /* get picture buffer */ if ((ret = ffthreadgetbuffer(avctx, &frame, 0)) < 0) { avlog(avctx, AVLOGERROR, \"ffthreadgetbuffer() failed.\\n\"); goto end; } picture->picttype = AVPICTURETYPEI; picture->keyframe = 1; if (ret = jpeg2000readbitstreampackets(s)) goto end; for (tileno = 0; tileno < s->numXtiles * s->numYtiles; tileno++) if (ret = jpeg2000decodetile(s, s->tile + tileno, picture)) goto end; *gotframe = 1; end: jpeg2000deccleanup(s); return ret ? ret : s->buf - s->bufstart; } ", "target": 0}
{"func": "static void vfioplatformeoi(VFIODevice *vbasedev) { VFIOINTp *intp; VFIOPlatformDevice *vdev = containerof(vbasedev, VFIOPlatformDevice, vbasedev); qemumutexlock(&vdev->intpmutex); QLISTFOREACH(intp, &vdev->intplist, next) { if (intp->state == VFIOIRQACTIVE) { tracevfioplatformeoi(intp->pin, eventnotifiergetfd(&intp->interrupt)); intp->state = VFIOIRQINACTIVE; /* deassert the virtual IRQ */ qemusetirq(intp->qemuirq, 0); if (intp->flags & VFIOIRQINFOAUTOMASKED) { /* unmasks the physical level-sensitive IRQ */ vfiounmasksingleirqindex(vbasedev, intp->pin); } /* a single IRQ can be active at a time */ break; } } /* in case there are pending IRQs, handle the first one */ if (!QSIMPLEQEMPTY(&vdev->pendingintpqueue)) { intp = QSIMPLEQFIRST(&vdev->pendingintpqueue); vfiointpinjectpendinglockheld(intp); QSIMPLEQREMOVEHEAD(&vdev->pendingintpqueue, pqnext); } qemumutexunlock(&vdev->intpmutex); } ", "target": 0}
{"func": "static void genstoreqreg(DisasContext *s, int rlow, int rhigh, TCGv val) { TCGv tmp; tmp = newtmp(); tcggentrunci64i32(tmp, val); storereg(s, rlow, tmp); tmp = newtmp(); tcggenshrii64(val, val, 32); tcggentrunci64i32(tmp, val); storereg(s, rhigh, tmp); } ", "target": 0}
{"func": "static void varargnumber(void) { QObject *obj; QInt *qint; QFloat *qfloat; int value = 0x2342; int64t value64 = 0x2342342343LL; double valuef = 2.323423423; obj = qobjectfromjsonf(\"%d\", value); gassert(obj != NULL); gassert(qobjecttype(obj) == QTYPEQINT); qint = qobjecttoqint(obj); gassert(qintgetint(qint) == value); QDECREF(qint); obj = qobjectfromjsonf(\"%\" PRId64, value64); gassert(obj != NULL); gassert(qobjecttype(obj) == QTYPEQINT); qint = qobjecttoqint(obj); gassert(qintgetint(qint) == value64); QDECREF(qint); obj = qobjectfromjsonf(\"%f\", valuef); gassert(obj != NULL); gassert(qobjecttype(obj) == QTYPEQFLOAT); qfloat = qobjecttoqfloat(obj); gassert(qfloatgetdouble(qfloat) == valuef); QDECREF(qfloat); } ", "target": 0}
{"func": "static int ohciserviceedlist(OHCIState *ohci, uint32t head, int completion) { struct ohcied ed; uint32t nexted; uint32t cur; int active; active = 0; if (head == 0) return 0; for (cur = head; cur; cur = nexted) { if (ohcireaded(ohci, cur, &ed)) { traceusbohciedreaderror(cur); ohcidie(ohci); return 0; } nexted = ed.next & OHCIDPTRMASK; if ((ed.head & OHCIEDH) || (ed.flags & OHCIEDK)) { uint32t addr; /* Cancel pending packets for ED that have been paused. */ addr = ed.head & OHCIDPTRMASK; if (ohci->asynctd && addr == ohci->asynctd) { usbcancelpacket(&ohci->usbpacket); ohci->asynctd = 0; usbdeviceepstopped(ohci->usbpacket.ep->dev, ohci->usbpacket.ep); } continue; } while ((ed.head & OHCIDPTRMASK) != ed.tail) { traceusbohciedpkt(cur, (ed.head & OHCIEDH) != 0, (ed.head & OHCIEDC) != 0, ed.head & OHCIDPTRMASK, ed.tail & OHCIDPTRMASK, ed.next & OHCIDPTRMASK); traceusbohciedpktflags( OHCIBM(ed.flags, EDFA), OHCIBM(ed.flags, EDEN), OHCIBM(ed.flags, EDD), (ed.flags & OHCIEDS)!= 0, (ed.flags & OHCIEDK) != 0, (ed.flags & OHCIEDF) != 0, OHCIBM(ed.flags, EDMPS)); active = 1; if ((ed.flags & OHCIEDF) == 0) { if (ohciservicetd(ohci, &ed)) break; } else { /* Handle isochronous endpoints */ if (ohciserviceisotd(ohci, &ed, completion)) break; } } if (ohciputed(ohci, cur, &ed)) { ohcidie(ohci); return 0; } } return active; } ", "target": 0}
{"func": "void s390pciiommudisable(S390PCIBusDevice *pbdev) { memoryregiondelsubregion(&pbdev->mr, &pbdev->iommumr); objectunparent(OBJECT(&pbdev->iommumr)); pbdev->iommuenabled = false; } ", "target": 0}
{"func": "int ffurlconnect(URLContext *uc, AVDictionary **options) { int err = uc->prot->urlopen2 ? uc->prot->urlopen2(uc, uc->filename, uc->flags, options) : uc->prot->urlopen(uc, uc->filename, uc->flags); if (err) return err; uc->isconnected = 1; /* We must be careful here as ffurlseek() could be slow, * for example for http */ if ((uc->flags & AVIOFLAGWRITE) || !strcmp(uc->prot->name, \"file\")) if (!uc->isstreamed && ffurlseek(uc, 0, SEEKSET) < 0) uc->isstreamed = 1; return 0; } ", "target": 0}
{"func": "uint8t sdreaddata(SDState *sd) { /* TODO: Append CRCs */ uint8t ret; int iolen; if (!sd->bdrv || !bdrvisinserted(sd->bdrv) || !sd->enable) return 0x00; if (sd->state != sdsendingdatastate) { fprintf(stderr, \"sdreaddata: not in Sending-Data state\\n\"); return 0x00; } if (sd->cardstatus & (ADDRESSERROR | WPVIOLATION)) return 0x00; iolen = (sd->ocr & (1 << 30)) ? 512 : sd->blklen; switch (sd->currentcmd) { case 6:\t/* CMD6: SWITCHFUNCTION */ ret = sd->data[sd->dataoffset ++]; if (sd->dataoffset >= 64) sd->state = sdtransferstate; break; case 9:\t/* CMD9: SENDCSD */ case 10:\t/* CMD10: SENDCID */ ret = sd->data[sd->dataoffset ++]; if (sd->dataoffset >= 16) sd->state = sdtransferstate; break; case 11:\t/* CMD11: READDATUNTILSTOP */ if (sd->dataoffset == 0) BLKREADBLOCK(sd->datastart, iolen); ret = sd->data[sd->dataoffset ++]; if (sd->dataoffset >= iolen) { sd->datastart += iolen; sd->dataoffset = 0; if (sd->datastart + iolen > sd->size) { sd->cardstatus |= ADDRESSERROR; break; } } break; case 13:\t/* ACMD13: SDSTATUS */ ret = sd->sdstatus[sd->dataoffset ++]; if (sd->dataoffset >= sizeof(sd->sdstatus)) sd->state = sdtransferstate; break; case 17:\t/* CMD17: READSINGLEBLOCK */ if (sd->dataoffset == 0) BLKREADBLOCK(sd->datastart, iolen); ret = sd->data[sd->dataoffset ++]; if (sd->dataoffset >= iolen) sd->state = sdtransferstate; break; case 18:\t/* CMD18: READMULTIPLEBLOCK */ if (sd->dataoffset == 0) BLKREADBLOCK(sd->datastart, iolen); ret = sd->data[sd->dataoffset ++]; if (sd->dataoffset >= iolen) { sd->datastart += iolen; sd->dataoffset = 0; if (sd->datastart + iolen > sd->size) { sd->cardstatus |= ADDRESSERROR; break; } } break; case 22:\t/* ACMD22: SENDNUMWRBLOCKS */ ret = sd->data[sd->dataoffset ++]; if (sd->dataoffset >= 4) sd->state = sdtransferstate; break; case 30:\t/* CMD30: SENDWRITEPROT */ ret = sd->data[sd->dataoffset ++]; if (sd->dataoffset >= 4) sd->state = sdtransferstate; break; case 51:\t/* ACMD51: SENDSCR */ ret = sd->scr[sd->dataoffset ++]; if (sd->dataoffset >= sizeof(sd->scr)) sd->state = sdtransferstate; break; case 56:\t/* CMD56: GENCMD */ if (sd->dataoffset == 0) APPREADBLOCK(sd->datastart, sd->blklen); ret = sd->data[sd->dataoffset ++]; if (sd->dataoffset >= sd->blklen) sd->state = sdtransferstate; break; default: fprintf(stderr, \"sdreaddata: unknown command\\n\"); return 0x00; } return ret; } ", "target": 0}
{"func": "static void testvisitoroutint(TestOutputVisitorData *data, const void *unused) { int64t value = -42; QObject *obj; visittypeint(data->ov, NULL, &value, &errorabort); obj = visitorget(data); gassert(qobjecttype(obj) == QTYPEQINT); gassertcmpint(qintgetint(qobjecttoqint(obj)), ==, value); } ", "target": 0}
{"func": "void netslirphostfwdremove(Monitor *mon, const char *srcstr) { struct inaddr hostaddr = { .saddr = INADDRANY }; int hostport; char buf[256] = \"\"; const char *p = srcstr; int isudp = 0; int n; if (!slirpinited) { monitorprintf(mon, \"user mode network stack not in use\\n\"); return; } if (!srcstr || !srcstr[0]) goto failsyntax; getstrsep(buf, sizeof(buf), &p, ':'); if (!strcmp(buf, \"tcp\") || buf[0] == '\\0') { isudp = 0; } else if (!strcmp(buf, \"udp\")) { isudp = 1; } else { goto failsyntax; } if (getstrsep(buf, sizeof(buf), &p, ':') < 0) { goto failsyntax; } if (buf[0] != '\\0' && !inetaton(buf, &hostaddr)) { goto failsyntax; } hostport = atoi(p); n = slirpremovehostfwd(isudp, hostaddr, hostport); monitorprintf(mon, \"removed %d host forwarding rules for %s\\n\", n, srcstr); return; failsyntax: monitorprintf(mon, \"invalid format\\n\"); } ", "target": 0}
{"func": "static int qcow2coreadv(BlockDriverState *bs, int64t sectornum, int remainingsectors, QEMUIOVector *qiov) { BDRVQcowState *s = bs->opaque; int indexincluster, n1; int ret; int curnrsectors; /* number of sectors in current iteration */ uint64t clusteroffset = 0; uint64t bytesdone = 0; QEMUIOVector hdqiov; uint8t *clusterdata = NULL; qemuiovecinit(&hdqiov, qiov->niov); qemucomutexlock(&s->lock); while (remainingsectors != 0) { /* prepare next request */ curnrsectors = remainingsectors; if (s->cryptmethod) { curnrsectors = MIN(curnrsectors, QCOWMAXCRYPTCLUSTERS * s->clustersectors); } ret = qcow2getclusteroffset(bs, sectornum << 9, &curnrsectors, &clusteroffset); if (ret < 0) { goto fail; } indexincluster = sectornum & (s->clustersectors - 1); qemuiovecreset(&hdqiov); qemuioveccopy(&hdqiov, qiov, bytesdone, curnrsectors * 512); if (!clusteroffset) { if (bs->backinghd) { /* read from the base image */ n1 = qcow2backingread1(bs->backinghd, &hdqiov, sectornum, curnrsectors); if (n1 > 0) { BLKDBGEVENT(bs->file, BLKDBGREADBACKINGAIO); qemucomutexunlock(&s->lock); ret = bdrvcoreadv(bs->backinghd, sectornum, n1, &hdqiov); qemucomutexlock(&s->lock); if (ret < 0) { goto fail; } } } else { /* Note: in this case, no need to wait */ qemuiovecmemset(&hdqiov, 0, 512 * curnrsectors); } } else if (clusteroffset & QCOWOFLAGCOMPRESSED) { /* add AIO support for compressed blocks ? */ ret = qcow2decompresscluster(bs, clusteroffset); if (ret < 0) { goto fail; } qemuiovecfrombuffer(&hdqiov, s->clustercache + indexincluster * 512, 512 * curnrsectors); } else { if ((clusteroffset & 511) != 0) { ret = -EIO; goto fail; } if (s->cryptmethod) { /* * For encrypted images, read everything into a temporary * contiguous buffer on which the AES functions can work. */ if (!clusterdata) { clusterdata = gmalloc0(QCOWMAXCRYPTCLUSTERS * s->clustersize); } assert(curnrsectors <= QCOWMAXCRYPTCLUSTERS * s->clustersectors); qemuiovecreset(&hdqiov); qemuiovecadd(&hdqiov, clusterdata, 512 * curnrsectors); } BLKDBGEVENT(bs->file, BLKDBGREADAIO); qemucomutexunlock(&s->lock); ret = bdrvcoreadv(bs->file, (clusteroffset >> 9) + indexincluster, curnrsectors, &hdqiov); qemucomutexlock(&s->lock); if (ret < 0) { goto fail; } if (s->cryptmethod) { qcow2encryptsectors(s, sectornum, clusterdata, clusterdata, curnrsectors, 0, &s->aesdecryptkey); qemuiovecreset(&hdqiov); qemuioveccopy(&hdqiov, qiov, bytesdone, curnrsectors * 512); qemuiovecfrombuffer(&hdqiov, clusterdata, 512 * curnrsectors); } } remainingsectors -= curnrsectors; sectornum += curnrsectors; bytesdone += curnrsectors * 512; } ret = 0; fail: qemucomutexunlock(&s->lock); qemuiovecdestroy(&hdqiov); return ret; }", "target": 1}
{"func": "static int readkukichunk(AVFormatContext *s, int64t size) { AVIOContext *pb = s->pb; AVStream *st = s->streams[0]; if (size < 0 || size > INTMAX - FFINPUTBUFFERPADDINGSIZE) return -1; if (st->codec->codecid == AVCODECIDAAC) { /* The magic cookie format for AAC is an mp4 esds atom. The lavc AAC decoder requires the data from the codec specific description as extradata input. */ int strt, skip; MOVAtom atom; strt = aviotell(pb); ffmovreadesds(s, pb, atom); skip = size - (aviotell(pb) - strt); if (skip < 0 || !st->codec->extradata || st->codec->codecid != AVCODECIDAAC) { avlog(s, AVLOGERROR, \"invalid AAC magic cookie\\n\"); return AVERRORINVALIDDATA; } avioskip(pb, skip); } else if (st->codec->codecid == AVCODECIDALAC) { #define ALACPREAMBLE 12 #define ALACHEADER 36 #define ALACNEWKUKI 24 uint8t preamble[12]; if (size < ALACNEWKUKI) { avlog(s, AVLOGERROR, \"invalid ALAC magic cookie\\n\"); avioskip(pb, size); return AVERRORINVALIDDATA; } avioread(pb, preamble, ALACPREAMBLE); st->codec->extradata = avmallocz(ALACHEADER + FFINPUTBUFFERPADDINGSIZE); if (!st->codec->extradata) return AVERROR(ENOMEM); /* For the old style cookie, we skip 12 bytes, then read 36 bytes. * The new style cookie only contains the last 24 bytes of what was * 36 bytes in the old style cookie, so we fabricate the first 12 bytes * in that case to maintain compatibility. */ if (!memcmp(&preamble[4], \"frmaalac\", 8)) { if (size < ALACPREAMBLE + ALACHEADER) { avlog(s, AVLOGERROR, \"invalid ALAC magic cookie\\n\"); avfreep(&st->codec->extradata); return AVERRORINVALIDDATA; } avioread(pb, st->codec->extradata, ALACHEADER); avioskip(pb, size - ALACPREAMBLE - ALACHEADER); } else { AVWB32(st->codec->extradata, 36); memcpy(&st->codec->extradata[4], \"alac\", 4); AVWB32(&st->codec->extradata[8], 0); memcpy(&st->codec->extradata[12], preamble, 12); avioread(pb, &st->codec->extradata[24], ALACNEWKUKI - 12); avioskip(pb, size - ALACNEWKUKI); } st->codec->extradatasize = ALACHEADER; } else { st->codec->extradata = avmallocz(size + FFINPUTBUFFERPADDINGSIZE); if (!st->codec->extradata) return AVERROR(ENOMEM); avioread(pb, st->codec->extradata, size); st->codec->extradatasize = size; } return 0; } ", "target": 1}
{"func": "static void *qemufopenrdma(RDMAContext *rdma, const char *mode) { QEMUFileRDMA *r = gmalloc0(sizeof(QEMUFileRDMA)); if (qemufilemodeisnotvalid(mode)) { return NULL; } r->rdma = rdma; if (mode[0] == 'w') { r->file = qemufopenops(r, &rdmawriteops); } else { r->file = qemufopenops(r, &rdmareadops); } return r->file; } ", "target": 1}
{"func": "static int decodecodestream(J2kDecoderContext *s) { J2kCodingStyle *codsty = s->codsty; J2kQuantStyle *qntsty = s->qntsty; uint8t *properties = s->properties; for (;;){ int marker, len, ret = 0; const uint8t *oldbuf; if (s->bufend - s->buf < 2){ avlog(s->avctx, AVLOGERROR, \"Missing EOC\\n\"); break; } marker = bytestreamgetbe16(&s->buf); if(s->avctx->debug & FFDEBUGSTARTCODE) avlog(s->avctx, AVLOGDEBUG, \"marker 0x%.4X at pos 0x%tx\\n\", marker, s->buf - s->bufstart - 4); oldbuf = s->buf; if (marker == J2KSOD){ J2kTile *tile = s->tile + s->curtileno; if (ret = inittile(s, s->curtileno)) return ret; if (ret = decodepackets(s, tile)) return ret; continue; } if (marker == J2KEOC) break; if (s->bufend - s->buf < 2) return AVERROR(EINVAL); len = bytestreamgetbe16(&s->buf); switch(marker){ case J2KSIZ: ret = getsiz(s); break; case J2KCOC: ret = getcoc(s, codsty, properties); break; case J2KCOD: ret = getcod(s, codsty, properties); break; case J2KQCC: ret = getqcc(s, len, qntsty, properties); break; case J2KQCD: ret = getqcd(s, len, qntsty, properties); break; case J2KSOT: if (!(ret = getsot(s))){ codsty = s->tile[s->curtileno].codsty; qntsty = s->tile[s->curtileno].qntsty; properties = s->tile[s->curtileno].properties; } break; case J2KCOM: // the comment is ignored s->buf += len - 2; break; default: avlog(s->avctx, AVLOGERROR, \"unsupported marker 0x%.4X at pos 0x%tx\\n\", marker, s->buf - s->bufstart - 4); s->buf += len - 2; break; } if (s->buf - oldbuf != len || ret){ avlog(s->avctx, AVLOGERROR, \"error during processing marker segment %.4x\\n\", marker); return ret ? ret : -1; } } return 0; } ", "target": 1}
{"func": "static avcold int assdecodeinit(AVCodecContext *avctx) { avctx->subtitleheader = avmalloc(avctx->extradatasize); if (!avctx->extradata) return AVERROR(ENOMEM); memcpy(avctx->subtitleheader, avctx->extradata, avctx->extradatasize); avctx->subtitleheadersize = avctx->extradatasize; return 0; } ", "target": 0}
{"func": "int v9fsdevicerealizecommon(V9fsState *s, Error **errp) { int i, len; struct stat stat; FsDriverEntry *fse; V9fsPath path; int rc = 1; /* initialize pdu allocator */ QLISTINIT(&s->freelist); QLISTINIT(&s->activelist); for (i = 0; i < (MAXREQ - 1); i++) { QLISTINSERTHEAD(&s->freelist, &s->pdus[i], next); s->pdus[i].s = s; s->pdus[i].idx = i; } v9fspathinit(&path); fse = getfsdevfsentry(s->fsconf.fsdevid); if (!fse) { /* We don't have a fsdev identified by fsdevid */ errorsetg(errp, \"9pfs device couldn't find fsdev with the \" \"id = %s\", s->fsconf.fsdevid ? s->fsconf.fsdevid : \"NULL\"); goto out; } if (!s->fsconf.tag) { /* we haven't specified a mounttag */ errorsetg(errp, \"fsdev with id %s needs mounttag arguments\", s->fsconf.fsdevid); goto out; } s->ctx.exportflags = fse->exportflags; s->ctx.fsroot = gstrdup(fse->path); s->ctx.exops.getstgen = NULL; len = strlen(s->fsconf.tag); if (len > MAXTAGLEN - 1) { errorsetg(errp, \"mount tag '%s' (%d bytes) is longer than \" \"maximum (%d bytes)\", s->fsconf.tag, len, MAXTAGLEN - 1); goto out; } s->tag = gstrdup(s->fsconf.tag); s->ctx.uid = -1; s->ops = fse->ops; s->fidlist = NULL; qemucorwlockinit(&s->renamelock); if (s->ops->init(&s->ctx) < 0) { errorsetg(errp, \"9pfs Failed to initialize fs-driver with id:%s\" \" and export path:%s\", s->fsconf.fsdevid, s->ctx.fsroot); goto out; } /* * Check details of export path, We need to use fs driver * call back to do that. Since we are in the init path, we don't * use co-routines here. */ if (s->ops->nametopath(&s->ctx, NULL, \"/\", &path) < 0) { errorsetg(errp, \"error in converting name to path %s\", strerror(errno)); goto out; } if (s->ops->lstat(&s->ctx, &path, &stat)) { errorsetg(errp, \"share path %s does not exist\", fse->path); goto out; } else if (!SISDIR(stat.stmode)) { errorsetg(errp, \"share path %s is not a directory\", fse->path); goto out; } v9fspathfree(&path); rc = 0; out: if (rc) { if (s->ops->cleanup && s->ctx.private) { s->ops->cleanup(&s->ctx); } gfree(s->tag); gfree(s->ctx.fsroot); v9fspathfree(&path); } return rc; } ", "target": 1}
{"func": "static int wsdreadheader(AVFormatContext *s) { AVIOContext *pb = s->pb; AVStream *st; int version; uint32t textoffset, dataoffset, channelassign; char playbacktime[AVTIMECODESTRSIZE]; st = avformatnewstream(s, NULL); if (!st) return AVERROR(ENOMEM); avioskip(pb, 8); version = avior8(pb); avlog(s, AVLOGDEBUG, \"version: %i.%i\\n\", version >> 4, version & 0xF); avioskip(pb, 11); if (version < 0x10) { textoffset = 0x80; dataoffset = 0x800; avioskip(pb, 8); } else { textoffset = aviorb32(pb); dataoffset = aviorb32(pb); } avioskip(pb, 4); avtimecodemakesmptetcstring(playbacktime, aviorb32(pb), 0); avdictset(&s->metadata, \"playbacktime\", playbacktime, 0); st->codecpar->codectype = AVMEDIATYPEAUDIO; st->codecpar->codecid = s->iformat->rawcodecid; st->codecpar->samplerate = aviorb32(pb) / 8; avioskip(pb, 4); st->codecpar->channels = avior8(pb) & 0xF; st->codecpar->bitrate = st->codecpar->channels * st->codecpar->samplerate * 8LL; if (!st->codecpar->channels) return AVERRORINVALIDDATA; avioskip(pb, 3); channelassign = aviorb32(pb); if (!(channelassign & 1)) { int i; for (i = 1; i < 32; i++) if (channelassign & (1 << i)) st->codecpar->channellayout |= wsdtoavchannellayoyt(s, i); } avioskip(pb, 16); if (aviorb32(pb)) avprivrequestsample(s, \"emphasis\"); if (avioseek(pb, textoffset, SEEKSET) >= 0) { getmetadata(s, \"title\", 128); getmetadata(s, \"composer\", 128); getmetadata(s, \"songwriter\", 128); getmetadata(s, \"artist\", 128); getmetadata(s, \"album\", 128); getmetadata(s, \"genre\", 32); getmetadata(s, \"date\", 32); getmetadata(s, \"location\", 32); getmetadata(s, \"comment\", 512); getmetadata(s, \"user\", 512); } return avioseek(pb, dataoffset, SEEKSET); } ", "target": 1}
{"func": "x11grabreadheader(AVFormatContext *s1) { struct x11grab *x11grab = s1->privdata; Display *dpy; AVStream *st = NULL; enum AVPixelFormat inputpixfmt; XImage *image; int xoff = 0; int yoff = 0; int screen; int useshm; char *dpyname, *offset; int ret = 0; Colormap colormap; XColor color[256]; int i; dpyname = avstrdup(s1->filename); if (!dpyname) goto out; offset = strchr(dpyname, '+'); if (offset) { sscanf(offset, \"%d,%d\", &xoff, &yoff); if (strstr(offset, \"nomouse\")) { avlog(s1, AVLOGWARNING, \"'nomouse' specification in argument is deprecated: \" \"use 'drawmouse' option with value 0 instead\\n\"); x11grab->drawmouse = 0; } *offset= 0; } avlog(s1, AVLOGINFO, \"device: %s -> display: %s x: %d y: %d width: %d height: %d\\n\", s1->filename, dpyname, xoff, yoff, x11grab->width, x11grab->height); dpy = XOpenDisplay(dpyname); avfreep(&dpyname); if(!dpy) { avlog(s1, AVLOGERROR, \"Could not open X display.\\n\"); ret = AVERROR(EIO); goto out; } st = avformatnewstream(s1, NULL); if (!st) { ret = AVERROR(ENOMEM); goto out; } avprivsetptsinfo(st, 64, 1, 1000000); /* 64 bits pts in us */ screen = DefaultScreen(dpy); if (x11grab->followmouse) { int screenw, screenh; Window w; screenw = DisplayWidth(dpy, screen); screenh = DisplayHeight(dpy, screen); XQueryPointer(dpy, RootWindow(dpy, screen), &w, &w, &xoff, &yoff, &ret, &ret, &ret); xoff -= x11grab->width / 2; yoff -= x11grab->height / 2; xoff = FFMIN(FFMAX(xoff, 0), screenw - x11grab->width); yoff = FFMIN(FFMAX(yoff, 0), screenh - x11grab->height); avlog(s1, AVLOGINFO, \"followmouse is enabled, resetting grabbing region to x: %d y: %d\\n\", xoff, yoff); } useshm = XShmQueryExtension(dpy); avlog(s1, AVLOGINFO, \"shared memory extension%s found\\n\", useshm ? \"\" : \" not\"); if(useshm) { int scr = XDefaultScreen(dpy); image = XShmCreateImage(dpy, DefaultVisual(dpy, scr), DefaultDepth(dpy, scr), ZPixmap, NULL, &x11grab->shminfo, x11grab->width, x11grab->height); x11grab->shminfo.shmid = shmget(IPCPRIVATE, image->bytesperline * image->height, IPCCREAT|0777); if (x11grab->shminfo.shmid == -1) { avlog(s1, AVLOGERROR, \"Fatal: Can't get shared memory!\\n\"); ret = AVERROR(ENOMEM); goto out; } x11grab->shminfo.shmaddr = image->data = shmat(x11grab->shminfo.shmid, 0, 0); x11grab->shminfo.readOnly = False; if (!XShmAttach(dpy, &x11grab->shminfo)) { avlog(s1, AVLOGERROR, \"Fatal: Failed to attach shared memory!\\n\"); /* needs some better error subroutine :) */ ret = AVERROR(EIO); goto out; } } else { image = XGetImage(dpy, RootWindow(dpy, screen), xoff,yoff, x11grab->width, x11grab->height, AllPlanes, ZPixmap); } switch (image->bitsperpixel) { case 8: avlog (s1, AVLOGDEBUG, \"8 bit palette\\n\"); inputpixfmt = AVPIXFMTPAL8; colormap = DefaultColormap(dpy, screen); for (i = 0; i < 256; ++i) color[i].pixel = i; XQueryColors(dpy, colormap, color, 256); for (i = 0; i < 256; ++i) x11grab->palette[i] = (color[i].red & 0xFF00) << 8 | (color[i].green & 0xFF00) | (color[i].blue & 0xFF00) >> 8; x11grab->palettechanged = 1; break; case 16: if ( image->redmask == 0xf800 && image->greenmask == 0x07e0 && image->bluemask == 0x001f ) { avlog (s1, AVLOGDEBUG, \"16 bit RGB565\\n\"); inputpixfmt = AVPIXFMTRGB565; } else if (image->redmask == 0x7c00 && image->greenmask == 0x03e0 && image->bluemask == 0x001f ) { avlog(s1, AVLOGDEBUG, \"16 bit RGB555\\n\"); inputpixfmt = AVPIXFMTRGB555; } else { avlog(s1, AVLOGERROR, \"RGB ordering at image depth %i not supported ... aborting\\n\", image->bitsperpixel); avlog(s1, AVLOGERROR, \"color masks: r 0x%.6lx g 0x%.6lx b 0x%.6lx\\n\", image->redmask, image->greenmask, image->bluemask); ret = AVERRORPATCHWELCOME; goto out; } break; case 24: if ( image->redmask == 0xff0000 && image->greenmask == 0x00ff00 && image->bluemask == 0x0000ff ) { inputpixfmt = AVPIXFMTBGR24; } else if ( image->redmask == 0x0000ff && image->greenmask == 0x00ff00 && image->bluemask == 0xff0000 ) { inputpixfmt = AVPIXFMTRGB24; } else { avlog(s1, AVLOGERROR,\"rgb ordering at image depth %i not supported ... aborting\\n\", image->bitsperpixel); avlog(s1, AVLOGERROR, \"color masks: r 0x%.6lx g 0x%.6lx b 0x%.6lx\\n\", image->redmask, image->greenmask, image->bluemask); ret = AVERRORPATCHWELCOME; goto out; } break; case 32: inputpixfmt = AVPIXFMT0RGB32; break; default: avlog(s1, AVLOGERROR, \"image depth %i not supported ... aborting\\n\", image->bitsperpixel); ret = AVERRORPATCHWELCOME; goto out; } x11grab->framesize = x11grab->width * x11grab->height * image->bitsperpixel/8; x11grab->dpy = dpy; x11grab->timebase = avinvq(x11grab->framerate); x11grab->timeframe = avgettime() / avq2d(x11grab->timebase); x11grab->xoff = xoff; x11grab->yoff = yoff; x11grab->image = image; x11grab->useshm = useshm; st->codec->codectype = AVMEDIATYPEVIDEO; st->codec->codecid = AVCODECIDRAWVIDEO; st->codec->width = x11grab->width; st->codec->height = x11grab->height; st->codec->pixfmt = inputpixfmt; st->codec->timebase = x11grab->timebase; st->codec->bitrate = x11grab->framesize * 1/avq2d(x11grab->timebase) * 8; out: avfree(dpyname); return ret; } ", "target": 0}
{"func": "static void vp8hloopfiltersimplec(uint8t *dst, ptrdifft stride, int flim) { int i; for (i = 0; i < 16; i++) if (simplelimit(dst+i*stride, 1, flim)) filtercommon(dst+i*stride, 1, 1); } ", "target": 0}
{"func": "void bdrvdrain(BlockDriverState *bs) { bool busy = true; bdrvdrainrecurse(bs); while (busy) { /* Keep iterating */ bdrvflushioqueue(bs); busy = bdrvrequestspending(bs); busy |= aiopoll(bdrvgetaiocontext(bs), busy); ", "target": 1}
{"func": "static void mainloop(void) { bool nonblocking; int lastio attribute ((unused)) = 0; #ifdef CONFIGPROFILER int64t ti; #endif int r; qemumainloopstart(); for (;;) { #ifdef CONFIGIOTHREAD nonblocking = !kvmenabled() && lastio > 0; #else nonblocking = cpuexecall(); if (vmrequestpending()) { nonblocking = true; } #endif #ifdef CONFIGPROFILER ti = profilegetclock(); #endif lastio = mainloopwait(nonblocking); #ifdef CONFIGPROFILER devtime += profilegetclock() - ti; #endif if (qemudebugrequested()) { vmstop(VMSTOPDEBUG); } if (qemushutdownrequested()) { qemukillreport(); monitorprotocolevent(QEVENTSHUTDOWN, NULL); if (noshutdown) { vmstop(VMSTOPSHUTDOWN); } else break; } if (qemuresetrequested()) { pauseallvcpus(); cpusynchronizeallstates(); qemusystemreset(VMRESETREPORT); resumeallvcpus(); } if (qemupowerdownrequested()) { monitorprotocolevent(QEVENTPOWERDOWN, NULL); qemuirqraise(qemusystempowerdown); } if ((r = qemuvmstoprequested())) { vmstop(r); } } bdrvcloseall(); pauseallvcpus(); } ", "target": 1}
{"func": "static void bootpreply(const struct bootpt *bp) { BOOTPClient *bc = NULL; struct mbuf *m; struct bootpt *rbp; struct sockaddrin saddr, daddr; struct inaddr dnsaddr; const struct inaddr *preqaddr; int dhcpmsgtype, val; uint8t *q; /* extract exact DHCP msg type */ dhcpdecode(bp, &dhcpmsgtype, &preqaddr); dprintf(\"bootp packet op=%d msgtype=%d\", bp->bpop, dhcpmsgtype); if (preqaddr) dprintf(\" reqaddr=%08x\\n\", ntohl(preqaddr->saddr)); else dprintf(\"\\n\"); if (dhcpmsgtype == 0) dhcpmsgtype = DHCPREQUEST; /* Force reply for old BOOTP clients */ if (dhcpmsgtype != DHCPDISCOVER && dhcpmsgtype != DHCPREQUEST) return; /* XXX: this is a hack to get the client mac address */ memcpy(clientethaddr, bp->bphwaddr, 6); if ((m = mget()) == NULL) return; m->mdata += IFMAXLINKHDR; rbp = (struct bootpt *)m->mdata; m->mdata += sizeof(struct udpiphdr); memset(rbp, 0, sizeof(struct bootpt)); if (dhcpmsgtype == DHCPDISCOVER) { if (preqaddr) { bc = requestaddr(preqaddr, clientethaddr); if (bc) { daddr.sinaddr = *preqaddr; } } if (!bc) { newaddr: bc = getnewaddr(&daddr.sinaddr); if (!bc) { dprintf(\"no address left\\n\"); return; } } memcpy(bc->macaddr, clientethaddr, 6); } else if (preqaddr) { bc = requestaddr(preqaddr, clientethaddr); if (bc) { daddr.sinaddr = *preqaddr; memcpy(bc->macaddr, clientethaddr, 6); } else { daddr.sinaddr.saddr = 0; } } else { bc = findaddr(&daddr.sinaddr, bp->bphwaddr); if (!bc) { /* if never assigned, behaves as if it was already assigned (windows fix because it remembers its address) */ goto newaddr; } } saddr.sinaddr.saddr = htonl(ntohl(specialaddr.saddr) | CTLALIAS); saddr.sinport = htons(BOOTPSERVER); daddr.sinport = htons(BOOTPCLIENT); rbp->bpop = BOOTPREPLY; rbp->bpxid = bp->bpxid; rbp->bphtype = 1; rbp->bphlen = 6; memcpy(rbp->bphwaddr, bp->bphwaddr, 6); rbp->bpyiaddr = daddr.sinaddr; /* Client IP address */ rbp->bpsiaddr = saddr.sinaddr; /* Server IP address */ q = rbp->bpvend; memcpy(q, rfc1533cookie, 4); q += 4; if (bc) { dprintf(\"%s addr=%08x\\n\", (dhcpmsgtype == DHCPDISCOVER) ? \"offered\" : \"ack'ed\", ntohl(daddr.sinaddr.saddr)); if (dhcpmsgtype == DHCPDISCOVER) { *q++ = RFC2132MSGTYPE; *q++ = 1; *q++ = DHCPOFFER; } else /* DHCPREQUEST */ { *q++ = RFC2132MSGTYPE; *q++ = 1; *q++ = DHCPACK; } if (bootpfilename) snprintf((char *)rbp->bpfile, sizeof(rbp->bpfile), \"%s\", bootpfilename); *q++ = RFC2132SRVID; *q++ = 4; memcpy(q, &saddr.sinaddr, 4); q += 4; *q++ = RFC1533NETMASK; *q++ = 4; *q++ = 0xff; *q++ = 0xff; *q++ = 0xff; *q++ = 0x00; if (!slirprestrict) { *q++ = RFC1533GATEWAY; *q++ = 4; memcpy(q, &saddr.sinaddr, 4); q += 4; *q++ = RFC1533DNS; *q++ = 4; dnsaddr.saddr = htonl(ntohl(specialaddr.saddr) | CTLDNS); memcpy(q, &dnsaddr, 4); q += 4; } *q++ = RFC2132LEASETIME; *q++ = 4; val = htonl(LEASETIME); memcpy(q, &val, 4); q += 4; if (*slirphostname) { val = strlen(slirphostname); *q++ = RFC1533HOSTNAME; *q++ = val; memcpy(q, slirphostname, val); q += val; } } else { static const char nakmsg[] = \"requested address not available\"; dprintf(\"nak'ed addr=%08x\\n\", ntohl(preqaddr->saddr)); *q++ = RFC2132MSGTYPE; *q++ = 1; *q++ = DHCPNAK; *q++ = RFC2132MESSAGE; *q++ = sizeof(nakmsg) - 1; memcpy(q, nakmsg, sizeof(nakmsg) - 1); q += sizeof(nakmsg) - 1; } *q++ = RFC1533END; daddr.sinaddr.saddr = 0xffffffffu; m->mlen = sizeof(struct bootpt) - sizeof(struct ip) - sizeof(struct udphdr); udpoutput2(NULL, m, &saddr, &daddr, IPTOSLOWDELAY); } ", "target": 0}
{"func": "static void printfeatures(FILE *f, int (*cpufprintf)(FILE *f, const char *fmt, ...), uint32t features, const char *prefix) { unsigned int i; for (i = 0; i < ARRAYSIZE(featurename); i++) if (featurename[i] && (features & (1 << i))) { if (prefix) (*cpufprintf)(f, \"%s\", prefix); (*cpufprintf)(f, \"%s \", featurename[i]); } } ", "target": 0}
{"func": "int cpux86gencode(uint8t *gencodebuf, int maxcodesize, int *gencodesizeptr, uint8t *pcstart, int flags) { DisasContext dc1, *dc = &dc1; uint8t *gencodeend, *pcptr; long ret; #ifdef DEBUGDISAS struct disassembleinfo disasminfo; #endif dc->code32 = (flags >> GENFLAGCODE32SHIFT) & 1; dc->addseg = (flags >> GENFLAGADDSEGSHIFT) & 1; dc->fst = (flags >> GENFLAGSTSHIFT) & 7; dc->ccop = CCOPDYNAMIC; gencodeptr = gencodebuf; gencodeend = gencodebuf + maxcodesize - 4096; genstart(); dc->isjmp = 0; pcptr = pcstart; do { ret = disasinsn(dc, pcptr); if (ret == -1) error(\"unknown instruction at PC=0x%x B=%02x %02x\", pcptr, pcptr[0], pcptr[1]); pcptr = (void *)ret; } while (!dc->isjmp && gencodeptr < gencodeend); /* we must store the eflags state if it is not already done */ if (dc->ccop != CCOPDYNAMIC) genopsetccop(dc->ccop); if (dc->isjmp != 1) { /* we add an additionnal jmp to update the simulated PC */ genopjmpim(ret); } genend(); *gencodesizeptr = gencodeptr - gencodebuf; #ifdef DEBUGDISAS if (loglevel) { uint8t *pc; int count; INITDISASSEMBLEINFO(disasminfo, logfile, fprintf); #if 0 disasminfo.flavour = bfdgetflavour (abfd); disasminfo.arch = bfdgetarch (abfd); disasminfo.mach = bfdgetmach (abfd); #endif #ifdef WORDSBIGENDIAN disasminfo.endian = BFDENDIANBIG; #else disasminfo.endian = BFDENDIANLITTLE; #endif fprintf(logfile, \"IN:\\n\"); disasminfo.buffer = pcstart; disasminfo.buffervma = (unsigned long)pcstart; disasminfo.bufferlength = pcptr - pcstart; pc = pcstart; while (pc < pcptr) { fprintf(logfile, \"0x%08lx: \", (long)pc); count = printinsni386((unsigned long)pc, &disasminfo); fprintf(logfile, \"\\n\"); pc += count; } fprintf(logfile, \"\\n\"); pc = gencodebuf; disasminfo.buffer = pc; disasminfo.buffervma = (unsigned long)pc; disasminfo.bufferlength = *gencodesizeptr; fprintf(logfile, \"OUT: [size=%d]\\n\", *gencodesizeptr); while (pc < gencodeptr) { fprintf(logfile, \"0x%08lx: \", (long)pc); count = printinsni386((unsigned long)pc, &disasminfo); fprintf(logfile, \"\\n\"); pc += count; } fprintf(logfile, \"\\n\"); } #endif return 0; } ", "target": 0}
{"func": "static const char *qobjectinputgetkeyval(QObjectInputVisitor *qiv, const char *name, Error **errp) { QObject *qobj; QString *qstr; qobj = qobjectinputgetobject(qiv, name, true, errp); if (!qobj) { return NULL; } qstr = qobjecttoqstring(qobj); if (!qstr) { errorsetg(errp, QERRINVALIDPARAMETERTYPE, fullname(qiv, name), \"string\"); return NULL; } return qstringgetstr(qstr); } ", "target": 1}
{"func": "static void qiochannelsocketfinalize(Object *obj) { QIOChannelSocket *ioc = QIOCHANNELSOCKET(obj); if (ioc->fd != -1) { #ifdef WIN32 WSAEventSelect(ioc->fd, NULL, 0); #endif closesocket(ioc->fd); ioc->fd = -1;", "target": 1}
{"func": "bool ftraceinit(void) { char mountpoint[PATHMAX]; char path[PATHMAX]; int debugfsfound; int tracefd = -1; debugfsfound = findmount(mountpoint, \"debugfs\"); if (debugfsfound) { snprintf(path, PATHMAX, \"%s/tracing/tracingon\", mountpoint); tracefd = open(path, OWRONLY); if (tracefd < 0) { if (errno == EACCES) { tracemarkerfd = open(\"/dev/null\", OWRONLY); if (tracemarkerfd != -1) { return true; } } perror(\"Could not open ftrace 'tracingon' file\"); return false; } else { if (write(tracefd, \"1\", 1) < 0) { perror(\"Could not write to 'tracingon' file\"); close(tracefd); return false; } close(tracefd); } snprintf(path, PATHMAX, \"%s/tracing/tracemarker\", mountpoint); tracemarkerfd = open(path, OWRONLY); if (tracemarkerfd < 0) { perror(\"Could not open ftrace 'tracemarker' file\"); return false; } } else { fprintf(stderr, \"debugfs is not mounted\\n\"); return false; } return true; } ", "target": 1}
{"func": "yuv2rgba641ctemplate(SwsContext *c, const int32t *buf0, const int32t *ubuf[2], const int32t *vbuf[2], const int32t *abuf0, uint16t *dest, int dstW, int uvalpha, int y, enum AVPixelFormat target, int hasAlpha, int eightbytes) { const int32t *ubuf0 = ubuf[0], *vbuf0 = vbuf[0]; int i; int A1 = 0xffff<<14, A2= 0xffff<<14; if (uvalpha < 2048) { for (i = 0; i < ((dstW + 1) >> 1); i++) { int Y1 = (buf0[i * 2] ) >> 2; int Y2 = (buf0[i * 2 + 1]) >> 2; int U = (ubuf0[i] + (-128 << 11)) >> 2; int V = (vbuf0[i] + (-128 << 11)) >> 2; int R, G, B; Y1 -= c->yuv2rgbyoffset; Y2 -= c->yuv2rgbyoffset; Y1 *= c->yuv2rgbycoeff; Y2 *= c->yuv2rgbycoeff; Y1 += 1 << 13; Y2 += 1 << 13; if (hasAlpha) { A1 = abuf0[i * 2 ] << 11; A2 = abuf0[i * 2 + 1] << 11; A1 += 1 << 13; A2 += 1 << 13; } R = V * c->yuv2rgbv2rcoeff; G = V * c->yuv2rgbv2gcoeff + U * c->yuv2rgbu2gcoeff; B = U * c->yuv2rgbu2bcoeff; outputpixel(&dest[0], avclipuintp2(RB + Y1, 30) >> 14); outputpixel(&dest[1], avclipuintp2( G + Y1, 30) >> 14); outputpixel(&dest[2], avclipuintp2(BR + Y1, 30) >> 14); if (eightbytes) { outputpixel(&dest[3], avclipuintp2(A1 , 30) >> 14); outputpixel(&dest[4], avclipuintp2(RB + Y2, 30) >> 14); outputpixel(&dest[5], avclipuintp2( G + Y2, 30) >> 14); outputpixel(&dest[6], avclipuintp2(BR + Y2, 30) >> 14); outputpixel(&dest[7], avclipuintp2(A2 , 30) >> 14); dest += 8; } else { outputpixel(&dest[3], avclipuintp2(RB + Y2, 30) >> 14); outputpixel(&dest[4], avclipuintp2( G + Y2, 30) >> 14); outputpixel(&dest[5], avclipuintp2(BR + Y2, 30) >> 14); dest += 6; } } } else { const int32t *ubuf1 = ubuf[1], *vbuf1 = vbuf[1]; int A1 = 0xffff<<14, A2 = 0xffff<<14; for (i = 0; i < ((dstW + 1) >> 1); i++) { int Y1 = (buf0[i * 2] ) >> 2; int Y2 = (buf0[i * 2 + 1]) >> 2; int U = (ubuf0[i] + ubuf1[i] + (-128 << 12)) >> 3; int V = (vbuf0[i] + vbuf1[i] + (-128 << 12)) >> 3; int R, G, B; Y1 -= c->yuv2rgbyoffset; Y2 -= c->yuv2rgbyoffset; Y1 *= c->yuv2rgbycoeff; Y2 *= c->yuv2rgbycoeff; Y1 += 1 << 13; Y2 += 1 << 13; if (hasAlpha) { A1 = abuf0[i * 2 ] << 11; A2 = abuf0[i * 2 + 1] << 11; A1 += 1 << 13; A2 += 1 << 13; } R = V * c->yuv2rgbv2rcoeff; G = V * c->yuv2rgbv2gcoeff + U * c->yuv2rgbu2gcoeff; B = U * c->yuv2rgbu2bcoeff; outputpixel(&dest[0], avclipuintp2(RB + Y1, 30) >> 14); outputpixel(&dest[1], avclipuintp2( G + Y1, 30) >> 14); outputpixel(&dest[2], avclipuintp2(BR + Y1, 30) >> 14); if (eightbytes) { outputpixel(&dest[3], avclipuintp2(A1 , 30) >> 14); outputpixel(&dest[4], avclipuintp2(RB + Y2, 30) >> 14); outputpixel(&dest[5], avclipuintp2( G + Y2, 30) >> 14); outputpixel(&dest[6], avclipuintp2(BR + Y2, 30) >> 14); outputpixel(&dest[7], avclipuintp2(A2 , 30) >> 14); dest += 8; } else { outputpixel(&dest[3], avclipuintp2(RB + Y2, 30) >> 14); outputpixel(&dest[4], avclipuintp2( G + Y2, 30) >> 14); outputpixel(&dest[5], avclipuintp2(BR + Y2, 30) >> 14); dest += 6; } } } } ", "target": 0}
{"func": "void visittypeint(Visitor *v, int64t *obj, const char *name, Error **errp) { if (!errorisset(errp)) { v->typeint(v, obj, name, errp); } } ", "target": 1}
{"func": "static void avclumamid8wmsa(const uint8t *src, int32t srcstride, uint8t *dst, int32t dststride, int32t height) { uint32t loopcnt; v16i8 src0, src1, src2, src3, src4; v16i8 mask0, mask1, mask2; v8i16 hzout0, hzout1, hzout2, hzout3; v8i16 hzout4, hzout5, hzout6, hzout7, hzout8; v8i16 dst0, dst1, dst2, dst3; v16u8 out0, out1; LDSB3(&lumamaskarr[0], 16, mask0, mask1, mask2); LDSB5(src, srcstride, src0, src1, src2, src3, src4); XORIB5128SB(src0, src1, src2, src3, src4); src += (5 * srcstride); hzout0 = AVCHORZFILTERSH(src0, src0, mask0, mask1, mask2); hzout1 = AVCHORZFILTERSH(src1, src1, mask0, mask1, mask2); hzout2 = AVCHORZFILTERSH(src2, src2, mask0, mask1, mask2); hzout3 = AVCHORZFILTERSH(src3, src3, mask0, mask1, mask2); hzout4 = AVCHORZFILTERSH(src4, src4, mask0, mask1, mask2); for (loopcnt = (height >> 2); loopcnt--;) { LDSB4(src, srcstride, src0, src1, src2, src3); XORIB4128SB(src0, src1, src2, src3); src += (4 * srcstride); hzout5 = AVCHORZFILTERSH(src0, src0, mask0, mask1, mask2); hzout6 = AVCHORZFILTERSH(src1, src1, mask0, mask1, mask2); hzout7 = AVCHORZFILTERSH(src2, src2, mask0, mask1, mask2); hzout8 = AVCHORZFILTERSH(src3, src3, mask0, mask1, mask2); dst0 = AVCCALCDPADDH6PIX2COEFFSH(hzout0, hzout1, hzout2, hzout3, hzout4, hzout5); dst1 = AVCCALCDPADDH6PIX2COEFFSH(hzout1, hzout2, hzout3, hzout4, hzout5, hzout6); dst2 = AVCCALCDPADDH6PIX2COEFFSH(hzout2, hzout3, hzout4, hzout5, hzout6, hzout7); dst3 = AVCCALCDPADDH6PIX2COEFFSH(hzout3, hzout4, hzout5, hzout6, hzout7, hzout8); out0 = PCKEVXORI128UB(dst0, dst1); out1 = PCKEVXORI128UB(dst2, dst3); ST8x4UB(out0, out1, dst, dststride); dst += (4 * dststride); hzout3 = hzout7; hzout1 = hzout5; hzout5 = hzout4; hzout4 = hzout8; hzout2 = hzout6; hzout0 = hzout5; } } ", "target": 0}
{"func": "static avcold int pamencodeclose(AVCodecContext *avctx) { avframefree(&avctx->codedframe); return 0; } ", "target": 0}
{"func": "static avcold int oggvorbisinitencoder(vorbisinfo *vi, AVCodecContext *avccontext) { OggVorbisContext *context = avccontext->privdata; double cfreq; if (avccontext->flags & CODECFLAGQSCALE) { /* variable bitrate */ if (vorbisencodesetupvbr(vi, avccontext->channels, avccontext->samplerate, avccontext->globalquality / (float)FFQP2LAMBDA / 10.0)) return -1; } else { int minrate = avccontext->rcminrate > 0 ? avccontext->rcminrate : -1; int maxrate = avccontext->rcminrate > 0 ? avccontext->rcmaxrate : -1; /* constant bitrate */ if (vorbisencodesetupmanaged(vi, avccontext->channels, avccontext->samplerate, minrate, avccontext->bitrate, maxrate)) return -1; /* variable bitrate by estimate, disable slow rate management */ if (minrate == -1 && maxrate == -1) if (vorbisencodectl(vi, OVECTLRATEMANAGE2SET, NULL)) return -1; } /* cutoff frequency */ if (avccontext->cutoff > 0) { cfreq = avccontext->cutoff / 1000.0; if (vorbisencodectl(vi, OVECTLLOWPASSSET, &cfreq)) return -1; } if (context->iblock) { vorbisencodectl(vi, OVECTLIBLOCKSET, &context->iblock); } return vorbisencodesetupinit(vi); } ", "target": 0}
{"func": "static int encodeframe(AVCodecContext *avctx, AVPacket *avpkt, const AVFrame *frame, int *gotpacketptr) { NellyMoserEncodeContext *s = avctx->privdata; int ret; if (s->lastframe) return 0; memcpy(s->buf, s->buf + NELLYSAMPLES, NELLYBUFLEN * sizeof(*s->buf)); if (frame) { memcpy(s->buf + NELLYBUFLEN, frame->data[0], frame->nbsamples * sizeof(*s->buf)); if (frame->nbsamples < NELLYSAMPLES) { memset(s->buf + NELLYBUFLEN + avctx->framesize, 0, (NELLYSAMPLES - frame->nbsamples) * sizeof(*s->buf)); if (frame->nbsamples >= NELLYBUFLEN) s->lastframe = 1; } if ((ret = ffafqueueadd(&s->afq, frame) < 0)) return ret; } else { memset(s->buf + NELLYBUFLEN, 0, NELLYSAMPLES * sizeof(*s->buf)); s->lastframe = 1; } if ((ret = ffallocpacket(avpkt, NELLYBLOCKLEN))) { avlog(avctx, AVLOGERROR, \"Error getting output packet\\n\"); return ret; } encodeblock(s, avpkt->data, avpkt->size); /* Get the next frame pts/duration */ ffafqueueremove(&s->afq, avctx->framesize, &avpkt->pts, &avpkt->duration); *gotpacketptr = 1; return 0; } ", "target": 1}
{"func": "static void imdctandwindowing(AACContext *ac, SingleChannelElement *sce, float bias) { IndividualChannelStream *ics = &sce->ics; float *in = sce->coeffs; float *out = sce->ret; float *saved = sce->saved; const float *swindow = ics->usekbwindow[0] ? ffaackbdshort128 : ffsine128; const float *lwindowprev = ics->usekbwindow[1] ? ffaackbdlong1024 : ffsine1024; const float *swindowprev = ics->usekbwindow[1] ? ffaackbdshort128 : ffsine128; float *buf = ac->bufmdct; float *temp = ac->temp; int i; // imdct if (ics->windowsequence[0] == EIGHTSHORTSEQUENCE) { if (ics->windowsequence[1] == ONLYLONGSEQUENCE || ics->windowsequence[1] == LONGSTOPSEQUENCE) avlog(ac->avctx, AVLOGWARNING, \"Transition from an ONLYLONG or LONGSTOP to an EIGHTSHORT sequence detected. \" \"If you heard an audible artifact, please submit the sample to the FFmpeg developers.\\n\"); for (i = 0; i < 1024; i += 128) ffimdcthalf(&ac->mdctsmall, buf + i, in + i); } else ffimdcthalf(&ac->mdct, buf, in); /* window overlapping * NOTE: To simplify the overlapping code, all 'meaningless' short to long * and long to short transitions are considered to be short to short * transitions. This leaves just two cases (long to long and short to short) * with a little special sauce for EIGHTSHORTSEQUENCE. */ if ((ics->windowsequence[1] == ONLYLONGSEQUENCE || ics->windowsequence[1] == LONGSTOPSEQUENCE) && (ics->windowsequence[0] == ONLYLONGSEQUENCE || ics->windowsequence[0] == LONGSTARTSEQUENCE)) { ac->dsp.vectorfmulwindow( out, saved, buf, lwindowprev, bias, 512); } else { for (i = 0; i < 448; i++) out[i] = saved[i] + bias; if (ics->windowsequence[0] == EIGHTSHORTSEQUENCE) { ac->dsp.vectorfmulwindow(out + 448 + 0*128, saved + 448, buf + 0*128, swindowprev, bias, 64); ac->dsp.vectorfmulwindow(out + 448 + 1*128, buf + 0*128 + 64, buf + 1*128, swindow, bias, 64); ac->dsp.vectorfmulwindow(out + 448 + 2*128, buf + 1*128 + 64, buf + 2*128, swindow, bias, 64); ac->dsp.vectorfmulwindow(out + 448 + 3*128, buf + 2*128 + 64, buf + 3*128, swindow, bias, 64); ac->dsp.vectorfmulwindow(temp, buf + 3*128 + 64, buf + 4*128, swindow, bias, 64); memcpy( out + 448 + 4*128, temp, 64 * sizeof(float)); } else { ac->dsp.vectorfmulwindow(out + 448, saved + 448, buf, swindowprev, bias, 64); for (i = 576; i < 1024; i++) out[i] = buf[i-512] + bias; } } // buffer update if (ics->windowsequence[0] == EIGHTSHORTSEQUENCE) { for (i = 0; i < 64; i++) saved[i] = temp[64 + i] - bias; ac->dsp.vectorfmulwindow(saved + 64, buf + 4*128 + 64, buf + 5*128, swindow, 0, 64); ac->dsp.vectorfmulwindow(saved + 192, buf + 5*128 + 64, buf + 6*128, swindow, 0, 64); ac->dsp.vectorfmulwindow(saved + 320, buf + 6*128 + 64, buf + 7*128, swindow, 0, 64); memcpy( saved + 448, buf + 7*128 + 64, 64 * sizeof(float)); } else if (ics->windowsequence[0] == LONGSTARTSEQUENCE) { memcpy( saved, buf + 512, 448 * sizeof(float)); memcpy( saved + 448, buf + 7*128 + 64, 64 * sizeof(float)); } else { // LONGSTOP or ONLYLONG memcpy( saved, buf + 512, 512 * sizeof(float)); } } ", "target": 1}
{"func": "void ffdsputilinitalpha(DSPContext* c, AVCodecContext *avctx) { const int highbitdepth = avctx->bitsperrawsample > 8; if (!highbitdepth) { c->putpixelstab[0][0] = putpixels16axpasm; c->putpixelstab[0][1] = putpixels16x2axp; c->putpixelstab[0][2] = putpixels16y2axp; c->putpixelstab[0][3] = putpixels16xy2axp; c->putnorndpixelstab[0][0] = putpixels16axpasm; c->putnorndpixelstab[0][1] = putnorndpixels16x2axp; c->putnorndpixelstab[0][2] = putnorndpixels16y2axp; c->putnorndpixelstab[0][3] = putnorndpixels16xy2axp; c->avgpixelstab[0][0] = avgpixels16axp; c->avgpixelstab[0][1] = avgpixels16x2axp; c->avgpixelstab[0][2] = avgpixels16y2axp; c->avgpixelstab[0][3] = avgpixels16xy2axp; c->avgnorndpixelstab[0][0] = avgnorndpixels16axp; c->avgnorndpixelstab[0][1] = avgnorndpixels16x2axp; c->avgnorndpixelstab[0][2] = avgnorndpixels16y2axp; c->avgnorndpixelstab[0][3] = avgnorndpixels16xy2axp; c->putpixelstab[1][0] = putpixelsaxpasm; c->putpixelstab[1][1] = putpixelsx2axp; c->putpixelstab[1][2] = putpixelsy2axp; c->putpixelstab[1][3] = putpixelsxy2axp; c->putnorndpixelstab[1][0] = putpixelsaxpasm; c->putnorndpixelstab[1][1] = putnorndpixelsx2axp; c->putnorndpixelstab[1][2] = putnorndpixelsy2axp; c->putnorndpixelstab[1][3] = putnorndpixelsxy2axp; c->avgpixelstab[1][0] = avgpixelsaxp; c->avgpixelstab[1][1] = avgpixelsx2axp; c->avgpixelstab[1][2] = avgpixelsy2axp; c->avgpixelstab[1][3] = avgpixelsxy2axp; c->avgnorndpixelstab[1][0] = avgnorndpixelsaxp; c->avgnorndpixelstab[1][1] = avgnorndpixelsx2axp; c->avgnorndpixelstab[1][2] = avgnorndpixelsy2axp; c->avgnorndpixelstab[1][3] = avgnorndpixelsxy2axp; c->clearblocks = clearblocksaxp; } /* amask clears all bits that correspond to present features. */ if (amask(AMASKMVI) == 0) { c->putpixelsclamped = putpixelsclampedmviasm; c->addpixelsclamped = addpixelsclampedmviasm; if (!highbitdepth) c->getpixels = getpixelsmvi; c->diffpixels = diffpixelsmvi; c->sad[0] = pixabs16x16mviasm; c->sad[1] = pixabs8x8mvi; c->pixabs[0][0] = pixabs16x16mviasm; c->pixabs[1][0] = pixabs8x8mvi; c->pixabs[0][1] = pixabs16x16x2mvi; c->pixabs[0][2] = pixabs16x16y2mvi; c->pixabs[0][3] = pixabs16x16xy2mvi; } putpixelsclampedaxpp = c->putpixelsclamped; addpixelsclampedaxpp = c->addpixelsclamped; if (avctx->bitsperrawsample <= 8 && (avctx->idctalgo == FFIDCTAUTO || avctx->idctalgo == FFIDCTSIMPLEALPHA)) { c->idctput = ffsimpleidctputaxp; c->idctadd = ffsimpleidctaddaxp; c->idct = ffsimpleidctaxp; } } ", "target": 0}
{"func": "static char *checknansuffix(char *s) { char *start = s; if (*s++ != '(') return start; while ((*s >= 'a' && *s <= 'z') || (*s >= 'A' && *s <= 'Z') || (*s >= '0' && *s <= '9') || *s == '') s++; return *s == ')' ? s + 1 : start; } ", "target": 0}
{"func": "static void diffbytesc(uint8t *dst, uint8t *src1, uint8t *src2, int w){ long i; #if !HAVEFASTUNALIGNED if((long)src2 & (sizeof(long)-1)){ for(i=0; i+7<w; i+=8){ dst[i+0] = src1[i+0]-src2[i+0]; dst[i+1] = src1[i+1]-src2[i+1]; dst[i+2] = src1[i+2]-src2[i+2]; dst[i+3] = src1[i+3]-src2[i+3]; dst[i+4] = src1[i+4]-src2[i+4]; dst[i+5] = src1[i+5]-src2[i+5]; dst[i+6] = src1[i+6]-src2[i+6]; dst[i+7] = src1[i+7]-src2[i+7]; } }else #endif for(i=0; i<=w-sizeof(long); i+=sizeof(long)){ long a = *(long*)(src1+i); long b = *(long*)(src2+i); *(long*)(dst+i) = ((a|pb80) - (b&pb7f)) ^ ((a^b^pb80)&pb80); } for(; i<w; i++) dst[i+0] = src1[i+0]-src2[i+0]; } ", "target": 1}
{"func": "static int decodeframe(AVCodecContext *avctx, void *data, int *gotframe, AVPacket *avpkt) { const uint8t *buf = avpkt->data; int bufsize = avpkt->size; DPXContext *const s = avctx->privdata; AVFrame *picture = data; AVFrame *const p = &s->picture; uint8t *ptr[AVNUMDATAPOINTERS]; unsigned int offset; int magicnum, endian; int x, y, i, ret; int w, h, bitspercolor, descriptor, elements, packing, totalsize; unsigned int rgbBuffer = 0; int ndatum = 0; if (avpkt->size <= 1634) { avlog(avctx, AVLOGERROR, \"Packet too small for DPX header\\n\"); return AVERRORINVALIDDATA; } magicnum = AVRB32(buf); buf += 4; /* Check if the files \"magic number\" is \"SDPX\" which means it uses * big-endian or XPDS which is for little-endian files */ if (magicnum == AVRL32(\"SDPX\")) { endian = 0; } else if (magicnum == AVRB32(\"SDPX\")) { endian = 1; } else { avlog(avctx, AVLOGERROR, \"DPX marker not found\\n\"); return AVERRORINVALIDDATA; } offset = read32(&buf, endian); if (avpkt->size <= offset) { avlog(avctx, AVLOGERROR, \"Invalid data start offset\\n\"); return AVERRORINVALIDDATA; } // Need to end in 0x304 offset from start of file buf = avpkt->data + 0x304; w = read32(&buf, endian); h = read32(&buf, endian); if ((ret = avimagechecksize(w, h, 0, avctx)) < 0) return ret; if (w != avctx->width || h != avctx->height) avcodecsetdimensions(avctx, w, h); // Need to end in 0x320 to read the descriptor buf += 20; descriptor = buf[0]; // Need to end in 0x323 to read the bits per color buf += 3; avctx->bitsperrawsample = bitspercolor = buf[0]; buf++; packing = *((uint16t*)buf); buf += 824; avctx->sampleaspectratio.num = read32(&buf, endian); avctx->sampleaspectratio.den = read32(&buf, endian); if (avctx->sampleaspectratio.num > 0 && avctx->sampleaspectratio.den > 0) avreduce(&avctx->sampleaspectratio.num, &avctx->sampleaspectratio.den, avctx->sampleaspectratio.num, avctx->sampleaspectratio.den, 0x10000); else avctx->sampleaspectratio = (AVRational){ 0, 1 }; switch (descriptor) { case 51: // RGBA elements = 4; break; case 50: // RGB elements = 3; break; default: avlog(avctx, AVLOGERROR, \"Unsupported descriptor %d\\n\", descriptor); return AVERRORINVALIDDATA; } switch (bitspercolor) { case 8: if (elements == 4) { avctx->pixfmt = AVPIXFMTRGBA; } else { avctx->pixfmt = AVPIXFMTRGB24; } totalsize = avctx->width * avctx->height * elements; break; case 10: if (!packing) { avlog(avctx, AVLOGERROR, \"Packing to 32bit required\\n\"); return -1; } avctx->pixfmt = AVPIXFMTGBRP10; totalsize = (avctx->width * avctx->height * elements + 2) / 3 * 4; break; case 12: if (!packing) { avlog(avctx, AVLOGERROR, \"Packing to 16bit required\\n\"); return -1; } if (endian) { avctx->pixfmt = AVPIXFMTGBRP12BE; } else { avctx->pixfmt = AVPIXFMTGBRP12LE; } totalsize = 2 * avctx->width * avctx->height * elements; break; case 16: if (endian) { avctx->pixfmt = elements == 4 ? AVPIXFMTRGBA64BE : AVPIXFMTRGB48BE; } else { avctx->pixfmt = elements == 4 ? AVPIXFMTRGBA64LE : AVPIXFMTRGB48LE; } totalsize = 2 * avctx->width * avctx->height * elements; break; default: avlog(avctx, AVLOGERROR, \"Unsupported color depth : %d\\n\", bitspercolor); return AVERRORINVALIDDATA; } if (s->picture.data[0]) avctx->releasebuffer(avctx, &s->picture); if ((ret = ffgetbuffer(avctx, p)) < 0) { avlog(avctx, AVLOGERROR, \"getbuffer() failed\\n\"); return ret; } // Move pointer to offset from start of file buf = avpkt->data + offset; for (i=0; i<AVNUMDATAPOINTERS; i++) ptr[i] = p->data[i]; if (totalsize > avpkt->size) { avlog(avctx, AVLOGERROR, \"Overread buffer. Invalid header?\\n\"); return AVERRORINVALIDDATA; } switch (bitspercolor) { case 10: for (x = 0; x < avctx->height; x++) { uint16t *dst[3] = {(uint16t*)ptr[0], (uint16t*)ptr[1], (uint16t*)ptr[2]}; for (y = 0; y < avctx->width; y++) { *dst[2]++ = read10in32(&buf, &rgbBuffer, &ndatum, endian); *dst[0]++ = read10in32(&buf, &rgbBuffer, &ndatum, endian); *dst[1]++ = read10in32(&buf, &rgbBuffer, &ndatum, endian); // For 10 bit, ignore alpha if (elements == 4) read10in32(&buf, &rgbBuffer, &ndatum, endian); } for (i = 0; i < 3; i++) ptr[i] += p->linesize[i]; } break; case 12: for (x = 0; x < avctx->height; x++) { uint16t *dst[3] = {(uint16t*)ptr[0], (uint16t*)ptr[1], (uint16t*)ptr[2]}; for (y = 0; y < avctx->width; y++) { *dst[2] = *((uint16t*)buf); *dst[2] = (*dst[2] >> 4) | (*dst[2] << 12); dst[2]++; buf += 2; *dst[0] = *((uint16t*)buf); *dst[0] = (*dst[0] >> 4) | (*dst[0] << 12); dst[0]++; buf += 2; *dst[1] = *((uint16t*)buf); *dst[1] = (*dst[1] >> 4) | (*dst[1] << 12); dst[1]++; buf += 2; // For 12 bit, ignore alpha if (elements == 4) buf += 2; } for (i = 0; i < 3; i++) ptr[i] += p->linesize[i]; } break; case 16: elements *= 2; case 8: for (x = 0; x < avctx->height; x++) { memcpy(ptr[0], buf, elements*avctx->width); ptr[0] += p->linesize[0]; buf += elements*avctx->width; } break; } *picture = s->picture; *gotframe = 1; return bufsize; } ", "target": 0}
{"func": "static void genpool16cinsn(DisasContext *ctx, int *isbranch) { int rd = mmreg((ctx->opcode >> 3) & 0x7); int rs = mmreg(ctx->opcode & 0x7); int opc; switch (((ctx->opcode) >> 4) & 0x3f) { case NOT16 + 0: case NOT16 + 1: case NOT16 + 2: case NOT16 + 3: genlogic(ctx, OPCNOR, rd, rs, 0); break; case XOR16 + 0: case XOR16 + 1: case XOR16 + 2: case XOR16 + 3: genlogic(ctx, OPCXOR, rd, rd, rs); break; case AND16 + 0: case AND16 + 1: case AND16 + 2: case AND16 + 3: genlogic(ctx, OPCAND, rd, rd, rs); break; case OR16 + 0: case OR16 + 1: case OR16 + 2: case OR16 + 3: genlogic(ctx, OPCOR, rd, rd, rs); break; case LWM16 + 0: case LWM16 + 1: case LWM16 + 2: case LWM16 + 3: { static const int lwmconvert[] = { 0x11, 0x12, 0x13, 0x14 }; int offset = ZIMM(ctx->opcode, 0, 4); genldstmultiple(ctx, LWM32, lwmconvert[(ctx->opcode >> 4) & 0x3], 29, offset << 2); } break; case SWM16 + 0: case SWM16 + 1: case SWM16 + 2: case SWM16 + 3: { static const int swmconvert[] = { 0x11, 0x12, 0x13, 0x14 }; int offset = ZIMM(ctx->opcode, 0, 4); genldstmultiple(ctx, SWM32, swmconvert[(ctx->opcode >> 4) & 0x3], 29, offset << 2); } break; case JR16 + 0: case JR16 + 1: { int reg = ctx->opcode & 0x1f; gencomputebranch(ctx, OPCJR, 2, reg, 0, 0); } *isbranch = 1; break; case JRC16 + 0: case JRC16 + 1: { int reg = ctx->opcode & 0x1f; gencomputebranch(ctx, OPCJR, 2, reg, 0, 0); /* Let normal delay slot handling in our caller take us to the branch target. */ } break; case JALR16 + 0: case JALR16 + 1: opc = OPCJALR; goto dojalr; case JALR16S + 0: case JALR16S + 1: opc = OPCJALRS; dojalr: { int reg = ctx->opcode & 0x1f; gencomputebranch(ctx, opc, 2, reg, 31, 0); } *isbranch = 1; break; case MFHI16 + 0: case MFHI16 + 1: genHILO(ctx, OPCMFHI, 0, uMIPSRS5(ctx->opcode)); break; case MFLO16 + 0: case MFLO16 + 1: genHILO(ctx, OPCMFLO, 0, uMIPSRS5(ctx->opcode)); break; case BREAK16: generateexception(ctx, EXCPBREAK); break; case SDBBP16: /* XXX: not clear which exception should be raised * when in debug mode... */ checkinsn(ctx, ISAMIPS32); if (!(ctx->hflags & MIPSHFLAGDM)) { generateexception(ctx, EXCPDBp); } else { generateexception(ctx, EXCPDBp); } break; case JRADDIUSP + 0: case JRADDIUSP + 1: { int imm = ZIMM(ctx->opcode, 0, 5); gencomputebranch(ctx, OPCJR, 2, 31, 0, 0); genarithimm(ctx, OPCADDIU, 29, 29, imm << 2); /* Let normal delay slot handling in our caller take us to the branch target. */ } break; default: generateexception(ctx, EXCPRI); break; } } ", "target": 1}
{"func": "int fffilterframe(AVFilterLink *link, AVFrame *frame) { int (*filterframe)(AVFilterLink *, AVFrame *); AVFilterPad *dst = link->dstpad; AVFrame *out; FFDPRINTFSTART(NULL, filterframe); ffdloglink(NULL, link, 1); if (!(filterframe = dst->filterframe)) filterframe = defaultfilterframe; /* copy the frame if needed */ if (dst->needswritable && !avframeiswritable(frame)) { avlog(link->dst, AVLOGDEBUG, \"Copying data in avfilter.\\n\"); switch (link->type) { case AVMEDIATYPEVIDEO: out = ffgetvideobuffer(link, link->w, link->h); break; case AVMEDIATYPEAUDIO: out = ffgetaudiobuffer(link, frame->nbsamples); break; default: return AVERROR(EINVAL); } if (!out) { avframefree(&frame); return AVERROR(ENOMEM); } avframecopyprops(out, frame); switch (link->type) { case AVMEDIATYPEVIDEO: avimagecopy(out->data, out->linesize, frame->data, frame->linesize, frame->format, frame->width, frame->height); break; case AVMEDIATYPEAUDIO: avsamplescopy(out->extendeddata, frame->extendeddata, 0, 0, frame->nbsamples, avgetchannellayoutnbchannels(frame->channellayout), frame->format); break; default: return AVERROR(EINVAL); } avframefree(&frame); } else out = frame; return filterframe(link, out); } ", "target": 1}
{"func": "static ssizet vnctlspush(gnutlstransportptrt transport, const void *data, sizet len) { VncState *vs = (VncState *)transport; int ret; retry: ret = send(vs->csock, data, len, 0); if (ret < 0) { if (errno == EINTR) goto retry; return -1; } return ret; } ", "target": 1}
{"func": "static void propertysetenum(Object *obj, Visitor *v, void *opaque, const char *name, Error **errp) { EnumProperty *prop = opaque; int value; visittypeenum(v, &value, prop->strings, NULL, name, errp); prop->set(obj, value, errp); } ", "target": 1}
{"func": "void ffh264filtermbfast(const H264Context *h, H264SliceContext *sl, int mbx, int mby, uint8t *imgy, uint8t *imgcb, uint8t *imgcr, unsigned int linesize, unsigned int uvlinesize) { assert(!FRAMEMBAFF(h)); if(!h->h264dsp.h264loopfilterstrength || h->pps.chromaqpdiff) { ffh264filtermb(h, sl, mbx, mby, imgy, imgcb, imgcr, linesize, uvlinesize); return; } #if CONFIGSMALL h264filtermbfastinternal(h, sl, mbx, mby, imgy, imgcb, imgcr, linesize, uvlinesize, h->pixelshift); #else if(h->pixelshift){ h264filtermbfastinternal(h, sl, mbx, mby, imgy, imgcb, imgcr, linesize, uvlinesize, 1); }else{ h264filtermbfastinternal(h, sl, mbx, mby, imgy, imgcb, imgcr, linesize, uvlinesize, 0); } #endif } ", "target": 0}
{"func": "void qmpeject(const char *device, bool hasforce, bool force, Error **errp) { Error *localerr = NULL; int rc; if (!hasforce) { force = false; } rc = doopentray(device, force, &localerr); if (localerr) { errorpropagate(errp, localerr); return; } if (rc == EINPROGRESS) { errorsetg(errp, \"Device '%s' is locked and force was not specified, \" \"wait for tray to open and try again\", device); return; } qmpxblockdevremovemedium(device, errp); } ", "target": 0}
{"func": "int checkprot(int prot, int rw, int accesstype) { int ret; if (accesstype == ACCESSCODE) { if (prot & PAGEEXEC) { ret = 0; } else { ret = -2; } } else if (rw) { if (prot & PAGEWRITE) { ret = 0; } else { ret = -2; } } else { if (prot & PAGEREAD) { ret = 0; } else { ret = -2; } } return ret; } ", "target": 0}
{"func": "static int vmdkwriteextent(VmdkExtent *extent, int64t clusteroffset, int64t offsetincluster, QEMUIOVector *qiov, uint64t qiovoffset, uint64t nbytes, uint64t offset) { int ret; VmdkGrainMarker *data = NULL; uLongf buflen; QEMUIOVector localqiov; struct iovec iov; int64t writeoffset; int64t writeendsector; if (extent->compressed) { void *compresseddata; if (!extent->hasmarker) { ret = -EINVAL; goto out; } buflen = (extent->clustersectors << 9) * 2; data = gmalloc(buflen + sizeof(VmdkGrainMarker)); compresseddata = gmalloc(nbytes); qemuiovectobuf(qiov, qiovoffset, compresseddata, nbytes); ret = compress(data->data, &buflen, compresseddata, nbytes); gfree(compresseddata); if (ret != ZOK || buflen == 0) { ret = -EINVAL; goto out; } data->lba = offset >> BDRVSECTORBITS; data->size = buflen; nbytes = buflen + sizeof(VmdkGrainMarker); iov = (struct iovec) { .iovbase = data, .iovlen = nbytes, }; qemuiovecinitexternal(&localqiov, &iov, 1); } else { qemuiovecinit(&localqiov, qiov->niov); qemuiovecconcat(&localqiov, qiov, qiovoffset, nbytes); } writeoffset = clusteroffset + offsetincluster, ret = bdrvcopwritev(extent->file, writeoffset, nbytes, &localqiov, 0); writeendsector = DIVROUNDUP(writeoffset + nbytes, BDRVSECTORSIZE); if (extent->compressed) { extent->nextclustersector = writeendsector; } else { extent->nextclustersector = MAX(extent->nextclustersector, writeendsector); } if (ret < 0) { goto out; } ret = 0; out: gfree(data); if (!extent->compressed) { qemuiovecdestroy(&localqiov); } return ret; } ", "target": 1}
{"func": "static int httpserver(void) { int serverfd, ret, rtspserverfd, delay, delay1; struct pollfd polltable[HTTPMAXCONNECTIONS + 2], *pollentry; HTTPContext *c, *cnext; serverfd = socketopenlisten(&myhttpaddr); if (serverfd < 0) return -1; rtspserverfd = socketopenlisten(&myrtspaddr); if (rtspserverfd < 0) return -1; httplog(\"ffserver started.\\n\"); startchildren(firstfeed); firsthttpctx = NULL; nbconnections = 0; firsthttpctx = NULL; startmulticast(); for(;;) { pollentry = polltable; pollentry->fd = serverfd; pollentry->events = POLLIN; pollentry++; pollentry->fd = rtspserverfd; pollentry->events = POLLIN; pollentry++; /* wait for events on each HTTP handle */ c = firsthttpctx; delay = 1000; while (c != NULL) { int fd; fd = c->fd; switch(c->state) { case HTTPSTATESENDHEADER: case RTSPSTATESENDREPLY: case RTSPSTATESENDPACKET: c->pollentry = pollentry; pollentry->fd = fd; pollentry->events = POLLOUT; pollentry++; break; case HTTPSTATESENDDATAHEADER: case HTTPSTATESENDDATA: case HTTPSTATESENDDATATRAILER: if (!c->ispacketized) { /* for TCP, we output as much as we can (may need to put a limit) */ c->pollentry = pollentry; pollentry->fd = fd; pollentry->events = POLLOUT; pollentry++; } else { /* not strictly correct, but currently cannot add more than one fd in poll entry */ delay = 0; } break; case HTTPSTATEWAITREQUEST: case HTTPSTATERECEIVEDATA: case HTTPSTATEWAITFEED: case RTSPSTATEWAITREQUEST: /* need to catch errors */ c->pollentry = pollentry; pollentry->fd = fd; pollentry->events = POLLIN;/* Maybe this will work */ pollentry++; break; case HTTPSTATEWAIT: c->pollentry = NULL; delay1 = computesenddelay(c); if (delay1 < delay) delay = delay1; break; case HTTPSTATEWAITSHORT: c->pollentry = NULL; delay1 = 10; /* one tick wait XXX: 10 ms assumed */ if (delay1 < delay) delay = delay1; break; default: c->pollentry = NULL; break; } c = c->next; } /* wait for an event on one connection. We poll at least every second to handle timeouts */ do { ret = poll(polltable, pollentry - polltable, delay); } while (ret == -1); curtime = gettimems(); if (needtostartchildren) { needtostartchildren = 0; startchildren(firstfeed); } /* now handle the events */ for(c = firsthttpctx; c != NULL; c = cnext) { cnext = c->next; if (handleconnection(c) < 0) { /* close and free the connection */ logconnection(c); closeconnection(c); } } pollentry = polltable; /* new HTTP connection request ? */ if (pollentry->revents & POLLIN) { newconnection(serverfd, 0); } pollentry++; /* new RTSP connection request ? */ if (pollentry->revents & POLLIN) { newconnection(rtspserverfd, 1); } } } ", "target": 1}
{"func": "static int dnxhddecodeheader(DNXHDContext *ctx, AVFrame *frame, const uint8t *buf, int bufsize, int firstfield) { static const uint8t headerprefix[] = { 0x00, 0x00, 0x02, 0x80, 0x01 }; static const uint8t headerprefix444[] = { 0x00, 0x00, 0x02, 0x80, 0x02 }; int i, cid, ret; if (bufsize < 0x280) return AVERRORINVALIDDATA; if (memcmp(buf, headerprefix, 5) && memcmp(buf, headerprefix444, 5)) { avlog(ctx->avctx, AVLOGERROR, \"error in header\\n\"); return AVERRORINVALIDDATA; } if (buf[5] & 2) { /* interlaced */ ctx->curfield = buf[5] & 1; frame->interlacedframe = 1; frame->topfieldfirst = firstfield ^ ctx->curfield; avlog(ctx->avctx, AVLOGDEBUG, \"interlaced %d, cur field %d\\n\", buf[5] & 3, ctx->curfield); } ctx->height = AVRB16(buf + 0x18); ctx->width = AVRB16(buf + 0x1a); avdlog(ctx->avctx, \"width %d, height %d\\n\", ctx->width, ctx->height); ctx->is444 = 0; if (buf[0x4] == 0x2) { ctx->avctx->pixfmt = AVPIXFMTYUV444P10; ctx->avctx->bitsperrawsample = 10; if (ctx->bitdepth != 10) { ffblockdspinit(&ctx->bdsp, ctx->avctx); ffidctdspinit(&ctx->idsp, ctx->avctx); ctx->bitdepth = 10; ctx->decodedctblock = dnxhddecodedctblock10444; } ctx->is444 = 1; } else if (buf[0x21] & 0x40) { ctx->avctx->pixfmt = AVPIXFMTYUV422P10; ctx->avctx->bitsperrawsample = 10; if (ctx->bitdepth != 10) { ffblockdspinit(&ctx->bdsp, ctx->avctx); ffidctdspinit(&ctx->idsp, ctx->avctx); ctx->bitdepth = 10; ctx->decodedctblock = dnxhddecodedctblock10; } } else { ctx->avctx->pixfmt = AVPIXFMTYUV422P; ctx->avctx->bitsperrawsample = 8; if (ctx->bitdepth != 8) { ffblockdspinit(&ctx->bdsp, ctx->avctx); ffidctdspinit(&ctx->idsp, ctx->avctx); ctx->bitdepth = 8; ctx->decodedctblock = dnxhddecodedctblock8; } } cid = AVRB32(buf + 0x28); avdlog(ctx->avctx, \"compression id %d\\n\", cid); if ((ret = dnxhdinitvlc(ctx, cid)) < 0) return ret; if (bufsize < ctx->cidtable->codingunitsize) { avlog(ctx->avctx, AVLOGERROR, \"incorrect frame size\\n\"); return AVERRORINVALIDDATA; } ctx->mbwidth = ctx->width >> 4; ctx->mbheight = buf[0x16d]; avdlog(ctx->avctx, \"mb width %d, mb height %d\\n\", ctx->mbwidth, ctx->mbheight); if ((ctx->height + 15) >> 4 == ctx->mbheight && frame->interlacedframe) ctx->height <<= 1; if (ctx->mbheight > 68 || (ctx->mbheight << frame->interlacedframe) > (ctx->height + 15) >> 4) { avlog(ctx->avctx, AVLOGERROR, \"mb height too big: %d\\n\", ctx->mbheight); return AVERRORINVALIDDATA; } for (i = 0; i < ctx->mbheight; i++) { ctx->mbscanindex[i] = AVRB32(buf + 0x170 + (i << 2)); avdlog(ctx->avctx, \"mb scan index %d\\n\", ctx->mbscanindex[i]); if (bufsize < ctx->mbscanindex[i] + 0x280LL) { avlog(ctx->avctx, AVLOGERROR, \"invalid mb scan index\\n\"); return AVERRORINVALIDDATA; } } return 0; } ", "target": 0}
{"func": "static int getmonitordef(targetlong *pval, const char *name) { const MonitorDef *md; void *ptr; for(md = monitordefs; md->name != NULL; md++) { if (comparecmd(name, md->name)) { if (md->getvalue) { *pval = md->getvalue(md, md->offset); } else { CPUState *env = mongetcpu(); if (!env) return -2; ptr = (uint8t *)env + md->offset; switch(md->type) { case MDI32: *pval = *(int32t *)ptr; break; case MDTLONG: *pval = *(targetlong *)ptr; break; default: *pval = 0; break; } } return 0; } } return -1; } ", "target": 1}
{"func": "static int dosigframereturnv2(CPUState *env, targetulong frameaddr, struct targetucontextv2 *uc) { sigsett hostset; abiulong *regspace; targettohostsigset(&hostset, &uc->tucsigmask); sigprocmask(SIGSETMASK, &hostset, NULL); if (restoresigcontext(env, &uc->tucmcontext)) if (dosigaltstack(frameaddr + offsetof(struct targetucontextv2, tucstack), 0, getspfromcpustate(env)) == -EFAULT) #if 0 /* Send SIGTRAP if we're single-stepping */ if (ptracecancelbpt(current)) sendsig(SIGTRAP, current, 1); #endif return 0;", "target": 1}
{"func": "FWCfgState *pcmemoryinit(MemoryRegion *systemmemory, const char *kernelfilename, const char *kernelcmdline, const char *initrdfilename, ramaddrt below4gmemsize, ramaddrt above4gmemsize, MemoryRegion *rommemory, MemoryRegion **rammemory, PcGuestInfo *guestinfo) { int linuxboot, i; MemoryRegion *ram, *optionrommr; MemoryRegion *rambelow4g, *ramabove4g; FWCfgState *fwcfg; linuxboot = (kernelfilename != NULL); /* Allocate RAM. We allocate it as a single memory region and use * aliases to address portions of it, mostly for backwards compatibility * with older qemus that used qemuramalloc(). */ ram = gmalloc(sizeof(*ram)); memoryregioninitram(ram, NULL, \"pc.ram\", below4gmemsize + above4gmemsize); vmstateregisterramglobal(ram); *rammemory = ram; rambelow4g = gmalloc(sizeof(*rambelow4g)); memoryregioninitalias(rambelow4g, NULL, \"ram-below-4g\", ram, 0, below4gmemsize); memoryregionaddsubregion(systemmemory, 0, rambelow4g); e820addentry(0, below4gmemsize, E820RAM); if (above4gmemsize > 0) { ramabove4g = gmalloc(sizeof(*ramabove4g)); memoryregioninitalias(ramabove4g, NULL, \"ram-above-4g\", ram, below4gmemsize, above4gmemsize); memoryregionaddsubregion(systemmemory, 0x100000000ULL, ramabove4g); e820addentry(0x100000000ULL, above4gmemsize, E820RAM); } /* Initialize PC system firmware */ pcsystemfirmwareinit(rommemory, guestinfo->isapcramfw); optionrommr = gmalloc(sizeof(*optionrommr)); memoryregioninitram(optionrommr, NULL, \"pc.rom\", PCROMSIZE); vmstateregisterramglobal(optionrommr); memoryregionaddsubregionoverlap(rommemory, PCROMMINVGA, optionrommr, 1); fwcfg = bochsbiosinit(); romsetfw(fwcfg); if (linuxboot) { loadlinux(fwcfg, kernelfilename, initrdfilename, kernelcmdline, below4gmemsize); } for (i = 0; i < nboptionroms; i++) { romaddoption(optionrom[i].name, optionrom[i].bootindex); } guestinfo->fwcfg = fwcfg; return fwcfg; } ", "target": 0}
{"func": "static void presskey(VncState *vs, int keysym) { int keycode = keysym2scancode(vs->vd->kbdlayout, keysym) & SCANCODEKEYMASK; qemuinputeventsendkeynumber(vs->vd->dcl.con, keycode, true); qemuinputeventsendkeydelay(0); qemuinputeventsendkeynumber(vs->vd->dcl.con, keycode, false); qemuinputeventsendkeydelay(0); } ", "target": 0}
{"func": "static void s390virtiodevicesync(VirtIOS390Device *dev) { VirtIOS390Bus *bus = DOUPCAST(VirtIOS390Bus, bus, dev->qdev.parentbus); ramaddrt curoffs; uint8t numvq; int i; virtioreset(dev->vdev); /* Sync dev space */ stbphys(dev->devoffs + VIRTIODEVOFFSTYPE, dev->vdev->deviceid); stbphys(dev->devoffs + VIRTIODEVOFFSNUMVQ, s390virtiodevicenumvq(dev)); stbphys(dev->devoffs + VIRTIODEVOFFSFEATURELEN, dev->featlen); stbphys(dev->devoffs + VIRTIODEVOFFSCONFIGLEN, dev->vdev->configlen); numvq = s390virtiodevicenumvq(dev); stbphys(dev->devoffs + VIRTIODEVOFFSNUMVQ, numvq); /* Sync virtqueues */ for (i = 0; i < numvq; i++) { ramaddrt vq = (dev->devoffs + VIRTIODEVOFFSCONFIG) + (i * VIRTIOVQCONFIGLEN); ramaddrt vring; vring = s390virtionextring(bus); virtioqueuesetaddr(dev->vdev, i, vring); virtioqueuesetvector(dev->vdev, i, i); stqphys(vq + VIRTIOVQCONFIGOFFSADDRESS, vring); stwphys(vq + VIRTIOVQCONFIGOFFSNUM, virtioqueuegetnum(dev->vdev, i)); } curoffs = dev->devoffs; curoffs += VIRTIODEVOFFSCONFIG; curoffs += numvq * VIRTIOVQCONFIGLEN; /* Sync feature bitmap */ if (dev->vdev->getfeatures) { stlphys(curoffs, dev->vdev->getfeatures(dev->vdev)); } dev->featoffs = curoffs + dev->featlen; curoffs += dev->featlen * 2; /* Sync config space */ if (dev->vdev->getconfig) { dev->vdev->getconfig(dev->vdev, dev->vdev->config); } cpuphysicalmemoryrw(curoffs, dev->vdev->config, dev->vdev->configlen, 1); curoffs += dev->vdev->configlen; } ", "target": 0}
{"func": "static void FUNCC(pred8x8leftdc)(uint8t *src, int stride){ int i; int dc0, dc2; pixel4 dc0splat, dc2splat; pixel *src = (pixel*)src; stride /= sizeof(pixel); dc0=dc2=0; for(i=0;i<4; i++){ dc0+= src[-1+i*stride]; dc2+= src[-1+(i+4)*stride]; } dc0splat = PIXELSPLATX4((dc0 + 2)>>2); dc2splat = PIXELSPLATX4((dc2 + 2)>>2); for(i=0; i<4; i++){ ((pixel4*)(src+i*stride))[0]= ((pixel4*)(src+i*stride))[1]= dc0splat; } for(i=4; i<8; i++){ ((pixel4*)(src+i*stride))[0]= ((pixel4*)(src+i*stride))[1]= dc2splat; } } ", "target": 1}
{"func": "static void allocandcopy(uint8t **poutbuf, int *poutbufsize, const uint8t *spspps, uint32t spsppssize, const uint8t *in, uint32t insize) { uint32t offset = *poutbufsize; uint8t nalheadersize = offset ? 3 : 4; *poutbufsize += spsppssize+insize+nalheadersize; *poutbuf = avrealloc(*poutbuf, *poutbufsize); if (spspps) memcpy(*poutbuf+offset, spspps, spsppssize); memcpy(*poutbuf+spsppssize+nalheadersize+offset, in, insize); if (!offset) AVWB32(*poutbuf+spsppssize, 1); else { (*poutbuf+offset)[0] = (*poutbuf+offset)[1] = 0; (*poutbuf+offset)[2] = 1; } } ", "target": 1}
{"func": "void aioseteventnotifier(AioContext *ctx, EventNotifier *e, EventNotifierHandler *ionotify, AioFlushEventNotifierHandler *ioflush) { AioHandler *node; QLISTFOREACH(node, &ctx->aiohandlers, node) { if (node->e == e && !node->deleted) { break; } } /* Are we deleting the fd handler? */ if (!ionotify) { if (node) { gsourceremovepoll(&ctx->source, &node->pfd); /* If the lock is held, just mark the node as deleted */ if (ctx->walkinghandlers) { node->deleted = 1; node->pfd.revents = 0; } else { /* Otherwise, delete it for real. We can't just mark it as * deleted because deleted nodes are only cleaned up after * releasing the walkinghandlers lock. */ QLISTREMOVE(node, node); gfree(node); } } } else { if (node == NULL) { /* Alloc and insert if it's not already there */ node = gmalloc0(sizeof(AioHandler)); node->e = e; node->pfd.fd = (uintptrt)eventnotifiergethandle(e); node->pfd.events = GIOIN; QLISTINSERTHEAD(&ctx->aiohandlers, node, node); gsourceaddpoll(&ctx->source, &node->pfd); } /* Update handler with latest information */ node->ionotify = ionotify; node->ioflush = ioflush; } aionotify(ctx); } ", "target": 1}
{"func": "int floatnearulp(float a, float b, unsigned maxulp) { union avintfloat32 x, y; x.f = a; y.f = b; if (isnegative(x) != isnegative(y)) { // handle -0.0 == +0.0 return a == b; } if (abs(x.i - y.i) <= maxulp) return 1; return 0; } ", "target": 0}
{"func": "static avcold int roqdpcmencodeinit(AVCodecContext *avctx) { ROQDPCMContext *context = avctx->privdata; if (avctx->channels > 2) { avlog(avctx, AVLOGERROR, \"Audio must be mono or stereo\\n\"); return -1; } if (avctx->samplerate != 22050) { avlog(avctx, AVLOGERROR, \"Audio must be 22050 Hz\\n\"); return -1; } if (avctx->samplefmt != AVSAMPLEFMTS16) { avlog(avctx, AVLOGERROR, \"Audio must be signed 16-bit\\n\"); return -1; } avctx->framesize = ROQFIRSTFRAMESIZE; context->lastSample[0] = context->lastSample[1] = 0; avctx->codedframe= avcodecallocframe(); return 0; }", "target": 1}
{"func": "static void spaprpopulatecpudt(CPUState *cs, void *fdt, int offset, sPAPRMachineState *spapr) { PowerPCCPU *cpu = POWERPCCPU(cs); CPUPPCState *env = &cpu->env; PowerPCCPUClass *pcc = POWERPCCPUGETCLASS(cs); int index = ppcgetvcpudtid(cpu); uint32t segs[] = {cputobe32(28), cputobe32(40), 0xffffffff, 0xffffffff}; uint32t tbfreq = kvmenabled() ? kvmppcgettbfreq() : SPAPRTIMEBASEFREQ; uint32t cpufreq = kvmenabled() ? kvmppcgetclockfreq() : 1000000000; uint32t pagesizesprop[64]; sizet pagesizespropsize; uint32t vcpuspersocket = smpthreads * smpcores; uint32t pftsizeprop[] = {0, cputobe32(spapr->htabshift)}; int compatsmt = MIN(smpthreads, ppccompatmaxthreads(cpu)); sPAPRDRConnector *drc; sPAPRDRConnectorClass *drck; int drcindex; uint32t radixAPencodings[PPCPAGESIZESMAXSZ]; int i; drc = spaprdrconnectorbyid(SPAPRDRCONNECTORTYPECPU, index); if (drc) { drck = SPAPRDRCONNECTORGETCLASS(drc); drcindex = drck->getindex(drc); FDT((fdtsetpropcell(fdt, offset, \"ibm,my-drc-index\", drcindex))); } FDT((fdtsetpropcell(fdt, offset, \"reg\", index))); FDT((fdtsetpropstring(fdt, offset, \"devicetype\", \"cpu\"))); FDT((fdtsetpropcell(fdt, offset, \"cpu-version\", env->spr[SPRPVR]))); FDT((fdtsetpropcell(fdt, offset, \"d-cache-block-size\", env->dcachelinesize))); FDT((fdtsetpropcell(fdt, offset, \"d-cache-line-size\", env->dcachelinesize))); FDT((fdtsetpropcell(fdt, offset, \"i-cache-block-size\", env->icachelinesize))); FDT((fdtsetpropcell(fdt, offset, \"i-cache-line-size\", env->icachelinesize))); if (pcc->l1dcachesize) { FDT((fdtsetpropcell(fdt, offset, \"d-cache-size\", pcc->l1dcachesize))); } else { errorreport(\"Warning: Unknown L1 dcache size for cpu\"); } if (pcc->l1icachesize) { FDT((fdtsetpropcell(fdt, offset, \"i-cache-size\", pcc->l1icachesize))); } else { errorreport(\"Warning: Unknown L1 icache size for cpu\"); } FDT((fdtsetpropcell(fdt, offset, \"timebase-frequency\", tbfreq))); FDT((fdtsetpropcell(fdt, offset, \"clock-frequency\", cpufreq))); FDT((fdtsetpropcell(fdt, offset, \"slb-size\", env->slbnr))); FDT((fdtsetpropcell(fdt, offset, \"ibm,slb-size\", env->slbnr))); FDT((fdtsetpropstring(fdt, offset, \"status\", \"okay\"))); FDT((fdtsetprop(fdt, offset, \"64-bit\", NULL, 0))); if (env->sprcb[SPRPURR].oearead) { FDT((fdtsetprop(fdt, offset, \"ibm,purr\", NULL, 0))); } if (env->mmumodel & POWERPCMMU1TSEG) { FDT((fdtsetprop(fdt, offset, \"ibm,processor-segment-sizes\", segs, sizeof(segs)))); } /* Advertise VMX/VSX (vector extensions) if available * 0 / no property == no vector extensions * 1 == VMX / Altivec available * 2 == VSX available */ if (env->insnsflags & PPCALTIVEC) { uint32t vmx = (env->insnsflags2 & PPC2VSX) ? 2 : 1; FDT((fdtsetpropcell(fdt, offset, \"ibm,vmx\", vmx))); } /* Advertise DFP (Decimal Floating Point) if available * 0 / no property == no DFP * 1 == DFP available */ if (env->insnsflags2 & PPC2DFP) { FDT((fdtsetpropcell(fdt, offset, \"ibm,dfp\", 1))); } pagesizespropsize = ppccreatepagesizesprop(env, pagesizesprop, sizeof(pagesizesprop)); if (pagesizespropsize) { FDT((fdtsetprop(fdt, offset, \"ibm,segment-page-sizes\", pagesizesprop, pagesizespropsize))); } spaprpopulatepafeatures(env, fdt, offset); FDT((fdtsetpropcell(fdt, offset, \"ibm,chip-id\", cs->cpuindex / vcpuspersocket))); FDT((fdtsetprop(fdt, offset, \"ibm,pft-size\", pftsizeprop, sizeof(pftsizeprop)))); FDT(spaprfixupcpunumadt(fdt, offset, cs)); FDT(spaprfixupcpusmtdt(fdt, offset, cpu, compatsmt)); if (pcc->radixpageinfo) { for (i = 0; i < pcc->radixpageinfo->count; i++) { radixAPencodings[i] = cputobe32(pcc->radixpageinfo->entries[i]); } FDT((fdtsetprop(fdt, offset, \"ibm,processor-radix-AP-encodings\", radixAPencodings, pcc->radixpageinfo->count * sizeof(radixAPencodings[0])))); } } ", "target": 1}
{"func": "static void testfunction(const TestStruct testsample) { int ret, i; void **outputdata = NULL; AVAudioFifo *afifo = avaudiofifoalloc(testsample.format, testsample.nbch, testsample.nbsamplespch); if (!afifo) { ERROR(\"ERROR: avaudiofifoalloc returned NULL!\"); } ret = writesamplestoaudiofifo(afifo, testsample, testsample.nbsamplespch, 0); if (ret < 0){ ERROR(\"ERROR: avaudiofifowrite failed!\"); } printf(\"written: %d\\n\", ret); ret = writesamplestoaudiofifo(afifo, testsample, testsample.nbsamplespch, 0); if (ret < 0){ ERROR(\"ERROR: avaudiofifowrite failed!\"); } printf(\"written: %d\\n\", ret); printf(\"remaining samples in audiofifo: %d\\n\\n\", avaudiofifosize(afifo)); ret = readsamplesfromaudiofifo(afifo, &outputdata, testsample.nbsamplespch); if (ret < 0){ ERROR(\"ERROR: avaudiofiforead failed!\"); } printf(\"read: %d\\n\", ret); printaudiobytes(&testsample, outputdata, ret); printf(\"remaining samples in audiofifo: %d\\n\\n\", avaudiofifosize(afifo)); /* test avaudiofifopeek */ ret = avaudiofifopeek(afifo, outputdata, afifo->nbsamples); if (ret < 0){ ERROR(\"ERROR: avaudiofifopeek failed!\"); } printf(\"peek:\\n\"); printaudiobytes(&testsample, outputdata, ret); printf(\"\\n\"); /* test avaudiofifopeekat */ printf(\"peekat:\\n\"); for (i = 0; i < afifo->nbsamples; ++i){ ret = avaudiofifopeekat(afifo, outputdata, 1, i); if (ret < 0){ ERROR(\"ERROR: avaudiofifopeekat failed!\"); } printf(\"%d:\\n\", i); printaudiobytes(&testsample, outputdata, ret); } printf(\"\\n\"); /* test avaudiofifodrain */ ret = avaudiofifodrain(afifo, afifo->nbsamples); if (ret < 0){ ERROR(\"ERROR: avaudiofifodrain failed!\"); } if (afifo->nbsamples){ ERROR(\"drain failed to flush all samples in audiofifo!\"); } /* deallocate */ for (i = 0; i < afifo->nbbuffers; ++i){ avfreep(&outputdata[i]); } avfreep(&outputdata); avaudiofifofree(afifo); } ", "target": 1}
{"func": "static void ffwmv2idctputc(uint8t *dest, int linesize, DCTELEM *block) { ffwmv2idctc(block); putpixelsclampedc(block, dest, linesize); } ", "target": 1}
{"func": "static void decodeinterframev4(AVCodecContext *avctx, uint8t *src, uint32t size) { Hnm4VideoContext *hnm = avctx->privdata; GetByteContext gb; uint32t writeoffset = 0, count, left, offset; uint8t tag, previous, backline, backward, swap; bytestream2init(&gb, src, size); while (bytestream2tell(&gb) < size) { count = bytestream2peekbyte(&gb) & 0x1F; if (count == 0) { tag = bytestream2getbyte(&gb) & 0xE0; tag = tag >> 5; if (tag == 0) { hnm->current[writeoffset++] = bytestream2getbyte(&gb); hnm->current[writeoffset++] = bytestream2getbyte(&gb); } else if (tag == 1) { writeoffset += bytestream2getbyte(&gb) * 2; } else if (tag == 2) { count = bytestream2getle16(&gb); count *= 2; writeoffset += count; } else if (tag == 3) { count = bytestream2getbyte(&gb) * 2; while (count > 0) { hnm->current[writeoffset++] = bytestream2peekbyte(&gb); count--; } bytestream2skip(&gb, 1); } else { break; } } else { previous = bytestream2peekbyte(&gb) & 0x20; backline = bytestream2peekbyte(&gb) & 0x40; backward = bytestream2peekbyte(&gb) & 0x80; bytestream2skip(&gb, 1); swap = bytestream2peekbyte(&gb) & 0x01; offset = bytestream2getle16(&gb); offset = (offset >> 1) & 0x7FFF; offset = writeoffset + (offset * 2) - 0x8000; left = count; if (!backward && offset + count >= hnm->width * hnm->height) { avlog(avctx, AVLOGERROR, \"Attempting to read out of bounds\"); break; } else if (backward && offset >= hnm->width * hnm->height) { avlog(avctx, AVLOGERROR, \"Attempting to read out of bounds\"); break; } else if (writeoffset + count >= hnm->width * hnm->height) { avlog(avctx, AVLOGERROR, \"Attempting to write out of bounds\"); break; } if (previous) { while (left > 0) { if (backline) { hnm->current[writeoffset++] = hnm->previous[offset - (2 * hnm->width) + 1]; hnm->current[writeoffset++] = hnm->previous[offset++]; offset++; } else { hnm->current[writeoffset++] = hnm->previous[offset++]; hnm->current[writeoffset++] = hnm->previous[offset++]; } if (backward) offset -= 4; left--; } } else { while (left > 0) { if (backline) { hnm->current[writeoffset++] = hnm->current[offset - (2 * hnm->width) + 1]; hnm->current[writeoffset++] = hnm->current[offset++]; offset++; } else { hnm->current[writeoffset++] = hnm->current[offset++]; hnm->current[writeoffset++] = hnm->current[offset++]; } if (backward) offset -= 4; left--; } } if (swap) { left = count; writeoffset -= count * 2; while (left > 0) { swap = hnm->current[writeoffset]; hnm->current[writeoffset] = hnm->current[writeoffset + 1]; hnm->current[writeoffset + 1] = swap; left--; writeoffset += 2; } } } } } ", "target": 0}
{"func": "static void setupframe(int sig, struct emulatedsigaction *ka, \t\t\ttargetsigsett *set, CPUX86State *env) { \tstruct sigframe *frame; \tint err = 0; \tframe = getsigframe(ka, env, sizeof(*frame)); #if 0 \tif (!accessok(VERIFYWRITE, frame, sizeof(*frame))) \t\tgoto givesigsegv; #endif \terr |= putuser((/*current->execdomain \t\t && current->execdomain->signalinvmap \t\t && sig < 32 \t\t ? current->execdomain->signalinvmap[sig] \t\t : */ sig), \t\t &frame->sig); \tif (err) \t\tgoto givesigsegv; \tsetupsigcontext(&frame->sc, &frame->fpstate, env, set->sig[0]); \tif (err) \t\tgoto givesigsegv; \tif (TARGETNSIGWORDS > 1) { \t\terr |= copytouser(frame->extramask, &set->sig[1], \t\t\t\t sizeof(frame->extramask)); \t} \tif (err) \t\tgoto givesigsegv; \t/* Set up to return from userspace. If provided, use a stub \t already in userspace. */ \tif (ka->sa.saflags & TARGETSARESTORER) { \t\terr |= putuser(ka->sa.sarestorer, &frame->pretcode); \t} else { \t\terr |= putuser(frame->retcode, &frame->pretcode); \t\t/* This is popl %eax ; movl $,%eax ; int $0x80 */ \t\terr |= putuser(0xb858, (short *)(frame->retcode+0)); \t\terr |= putuser(TARGETNRsigreturn, (int *)(frame->retcode+2)); \t\terr |= putuser(0x80cd, (short *)(frame->retcode+6)); \t} \tif (err) \t\tgoto givesigsegv; \t/* Set up registers for signal handler */ \tenv->regs[RESP] = (unsigned long) frame; \tenv->eip = (unsigned long) ka->sa.sahandler; cpux86loadseg(env, RDS, USERDS); cpux86loadseg(env, RES, USERDS); cpux86loadseg(env, RSS, USERDS); cpux86loadseg(env, RCS, USERCS); \tenv->eflags &= ~TFMASK; \treturn; givesigsegv: \tif (sig == TARGETSIGSEGV) \t\tka->sa.sahandler = TARGETSIGDFL; \tforcesig(TARGETSIGSEGV /* , current */); } ", "target": 0}
{"func": "static void writetargetclose(BlockDriverState *bs) { BDRVVVFATState* s = *((BDRVVVFATState**) bs->opaque); bdrvdelete(s->qcow); free(s->qcowfilename); } ", "target": 1}
{"func": "static int aiffreadpacket(AVFormatContext *s, AVPacket *pkt) { AVStream *st = s->streams[0]; AIFFInputContext *aiff = s->privdata; int64t maxsize; int res, size; /* calculate size of remaining data */ maxsize = aiff->dataend - aviotell(s->pb); if (maxsize <= 0) return AVERROREOF; /* Now for that packet */ switch (st->codecpar->codecid) { case AVCODECIDADPCMIMAQT: case AVCODECIDGSM: case AVCODECIDQDM2: case AVCODECIDQCELP: size = st->codecpar->blockalign; break; default: size = st->codecpar->blockalign ? (MAXSIZE / st->codecpar->blockalign) * st->codecpar->blockalign : MAXSIZE; size = FFMIN(maxsize, size); res = avgetpacket(s->pb, pkt, size); if (res < 0) return res; if (size >= st->codecpar->blockalign) pkt->flags &= ~AVPKTFLAGCORRUPT; /* Only one stream in an AIFF file */ pkt->streamindex = 0; pkt->duration = (res / st->codecpar->blockalign) * aiff->blockduration; return 0;", "target": 1}
{"func": "uint64t helperfnmsub (uint64t arg1, uint64t arg2, uint64t arg3) { CPUDoubleU farg1, farg2, farg3; farg1.ll = arg1; farg2.ll = arg2; farg3.ll = arg3; if (unlikely(float64issignalingnan(farg1.d) || float64issignalingnan(farg2.d) || float64issignalingnan(farg3.d))) { /* sNaN operation */ farg1.ll = floadinvalidopexcp(POWERPCEXCPFPVXSNAN); } else if (unlikely((float64isinfinity(farg1.d) && float64iszero(farg2.d)) || (float64iszero(farg1.d) && float64isinfinity(farg2.d)))) { /* Multiplication of zero by infinity */ farg1.ll = floadinvalidopexcp(POWERPCEXCPFPVXIMZ); } else { #if USEPRECISEEMULATION #ifdef FLOAT128 /* This is the way the PowerPC specification defines it */ float128 ft0128, ft1128; ft0128 = float64tofloat128(farg1.d, &env->fpstatus); ft1128 = float64tofloat128(farg2.d, &env->fpstatus); ft0128 = float128mul(ft0128, ft1128, &env->fpstatus); if (unlikely(float128isinfinity(ft0128) && float64isinfinity(farg3.d) && float128isneg(ft0128) == float64isneg(farg3.d))) { /* Magnitude subtraction of infinities */ farg1.ll = floadinvalidopexcp(POWERPCEXCPFPVXISI); } else { ft1128 = float64tofloat128(farg3.d, &env->fpstatus); ft0128 = float128sub(ft0128, ft1128, &env->fpstatus); farg1.d = float128tofloat64(ft0128, &env->fpstatus); } #else /* This is OK on x86 hosts */ farg1.d = (farg1.d * farg2.d) - farg3.d; #endif #else farg1.d = float64mul(farg1.d, farg2.d, &env->fpstatus); farg1.d = float64sub(farg1.d, farg3.d, &env->fpstatus); #endif if (likely(!float64isnan(farg1.d))) farg1.d = float64chs(farg1.d); } return farg1.ll; } ", "target": 0}
{"func": "static void decmodu(DisasContext *dc) { int l1; LOGDIS(\"modu r%d, r%d, %d\\n\", dc->r2, dc->r0, dc->r1); if (!(dc->features & LM32FEATUREDIVIDE)) { qemulogmask(LOGGUESTERROR, \"hardware divider is not available\\n\"); tgenillegalinsn(dc); return; } l1 = gennewlabel(); tcggenbrconditl(TCGCONDNE, cpuR[dc->r1], 0, l1); tcggenmovitl(cpupc, dc->pc); tgenraiseexception(dc, EXCPDIVIDEBYZERO); gensetlabel(l1); tcggenremutl(cpuR[dc->r2], cpuR[dc->r0], cpuR[dc->r1]); } ", "target": 0}
{"func": "static void omapl4iowriteb(void *opaque, targetphysaddrt addr, uint32t value) { unsigned int i = (addr - OMAP2L4BASE) >> TARGETPAGEBITS; return omapl4iowritebfn[i](omapl4ioopaque[i], addr, value); } ", "target": 0}
{"func": "static void v9fscreatepostlstat(V9fsState *s, V9fsCreateState *vs, int err) { if (err == 0 || errno != ENOENT) { err = -errno; goto out; } if (vs->perm & P9STATMODEDIR) { err = v9fsdomkdir(s, vs); v9fscreatepostmkdir(s, vs, err); } else if (vs->perm & P9STATMODESYMLINK) { err = v9fsdosymlink(s, vs); v9fscreatepostperms(s, vs, err); } else if (vs->perm & P9STATMODELINK) { int32t nfid = atoi(vs->extension.data); V9fsFidState *nfidp = lookupfid(s, nfid); if (nfidp == NULL) { err = -errno; v9fspostcreate(s, vs, err); } err = v9fsdolink(s, &nfidp->path, &vs->fullname); v9fscreatepostperms(s, vs, err); } else if (vs->perm & P9STATMODEDEVICE) { char ctype; uint32t major, minor; modet nmode = 0; if (sscanf(vs->extension.data, \"%c %u %u\", &ctype, &major, &minor) != 3) { err = -errno; v9fspostcreate(s, vs, err); } switch (ctype) { case 'c': nmode = SIFCHR; break; case 'b': nmode = SIFBLK; break; default: err = -EIO; v9fspostcreate(s, vs, err); } nmode |= vs->perm & 0777; err = v9fsdomknod(s, vs, nmode, makedev(major, minor)); v9fscreatepostperms(s, vs, err); } else if (vs->perm & P9STATMODENAMEDPIPE) { err = v9fsdomknod(s, vs, SIFIFO | (vs->perm & 0777), 0); v9fspostcreate(s, vs, err); } else if (vs->perm & P9STATMODESOCKET) { err = v9fsdomksock(s, &vs->fullname); v9fscreatepostmksock(s, vs, err); } else { vs->fidp->fd = v9fsdoopen2(s, vs); v9fscreatepostopen2(s, vs, err); } return; out: v9fspostcreate(s, vs, err); } ", "target": 0}
{"func": "void palinit (CPUState *env) { } ", "target": 0}
{"func": "targetulong spaprrtascall(sPAPREnvironment *spapr, uint32t token, uint32t nargs, targetulong args, uint32t nret, targetulong rets) { if ((token >= TOKENBASE) && ((token - TOKENBASE) < TOKENMAX)) { struct rtascall *call = rtastable + (token - TOKENBASE); if (call->fn) { call->fn(spapr, token, nargs, args, nret, rets); return HSUCCESS; } } /* HACK: Some Linux early debug code uses RTAS display-character, * but assumes the token value is 0xa (which it is on some real * machines) without looking it up in the device tree. This * special case makes this work */ if (token == 0xa) { rtasdisplaycharacter(spapr, 0xa, nargs, args, nret, rets); return HSUCCESS; } hcalldprintf(\"Unknown RTAS token 0x%x\\n\", token); rtasst(rets, 0, -3); return HPARAMETER; } ", "target": 0}
{"func": "static void applytnsfilter(float *out, float *in, int order, int direction, float *tnscoefs, int ltpused, int w, int filt, int starti, int len) { int i, j, inc, start = starti; float tmp[TNSMAXORDER+1]; if (direction) { inc = -1; start = (start + len) - 1; } else { inc = 1; } if (!ltpused) { /* AR filter */ for (i = 0; i < len; i++, start += inc) out[i] = in[start]; for (j = 1; j <= FFMIN(i, order); j++) out[i] += tnscoefs[j]*in[start - j*inc]; } else { /* MA filter */ for (i = 0; i < len; i++, start += inc) { tmp[0] = out[i] = in[start]; for (j = 1; j <= FFMIN(i, order); j++) out[i] += tmp[j]*tnscoefs[j]; for (j = order; j > 0; j--) tmp[j] = tmp[j - 1]; } } } ", "target": 0}
{"func": "static int mkvwriteassblocks(AVFormatContext *s, AVIOContext *pb, AVPacket *pkt) { MatroskaMuxContext *mkv = s->privdata; int i, layer = 0, maxduration = 0, size, linesize, datasize = pkt->size; uint8t *start, *end, *data = pkt->data; ebmlmaster blockgroup; char buffer[2048]; while (datasize) { int duration = assgetduration(data); maxduration = FFMAX(duration, maxduration); end = memchr(data, '\\n', datasize); size = linesize = end ? end - data + 1 : datasize; size -= end ? (end[-1] == '\\r') + 1 : 0; start = data; for (i = 0; i < 3; i++, start++) if (!(start = memchr(start, ',', size - (start - data)))) return maxduration; size -= start - data; sscanf(data, \"Dialogue: %d,\", &layer); i = snprintf(buffer, sizeof(buffer), \"%\" PRId64 \",%d,\", s->streams[pkt->streamindex]->nbframes, layer); size = FFMIN(i + size, sizeof(buffer)); memcpy(buffer + i, start, size - i); avlog(s, AVLOGDEBUG, \"Writing block at offset %\" PRIu64 \", size %d, \" \"pts %\" PRId64 \", duration %d\\n\", aviotell(pb), size, pkt->pts, duration); blockgroup = startebmlmaster(pb, MATROSKAIDBLOCKGROUP, mkvblockgroupsize(size)); putebmlid(pb, MATROSKAIDBLOCK); putebmlnum(pb, size + 4, 0); // this assumes streamindex is less than 126 aviow8(pb, 0x80 | (pkt->streamindex + 1)); aviowb16(pb, pkt->pts - mkv->clusterpts); aviow8(pb, 0); aviowrite(pb, buffer, size); putebmluint(pb, MATROSKAIDBLOCKDURATION, duration); endebmlmaster(pb, blockgroup); data += linesize; datasize -= linesize; } return maxduration; } ", "target": 0}
{"func": "static int ramblockenablenotify(const char *blockname, void *hostaddr, ramaddrt offset, ramaddrt length, void *opaque) { MigrationIncomingState *mis = opaque; struct uffdioregister regstruct; regstruct.range.start = (uintptrt)hostaddr; regstruct.range.len = length; regstruct.mode = UFFDIOREGISTERMODEMISSING; /* Now tell our userfaultfd that it's responsible for this area */ if (ioctl(mis->userfaultfd, UFFDIOREGISTER, &regstruct)) { errorreport(\"%s userfault register: %s\", func, strerror(errno)); return 0; ", "target": 1}
{"func": "static void drawbaryuv(AVFrame *out, const float *h, const float *rcph, const ColorFloat *c, int barh) { int x, y, yh, w = out->width; float mul, ht, rcpbarh = 1.0f / barh; uint8t *vy = out->data[0], *vu = out->data[1], *vv = out->data[2]; uint8t *lpy, *lpu, *lpv; int lsy = out->linesize[0], lsu = out->linesize[1], lsv = out->linesize[2]; int fmt = out->format; for (y = 0; y < barh; y += 2) { yh = (fmt == AVPIXFMTYUV420P) ? y / 2 : y; ht = (barh - y) * rcpbarh; lpy = vy + y * lsy; lpu = vu + yh * lsu; lpv = vv + yh * lsv; for (x = 0; x < w; x += 2) { if (h[x] <= ht) { *lpy++ = 16; *lpu++ = 128; *lpv++ = 128; } else { mul = (h[x] - ht) * rcph[x]; *lpy++ = mul * c[x].yuv.y + (1.0f - mul) * 16.0f + 0.5f; *lpu++ = mul * c[x].yuv.u + (1.0f - mul) * 128.0f + 0.5f; *lpv++ = mul * c[x].yuv.v + (1.0f - mul) * 128.0f + 0.5f; } /* u and v are skipped on yuv422p and yuv420p */ if (fmt == AVPIXFMTYUV444P) { if (h[x+1] <= ht) { *lpy++ = 16; *lpu++ = 128; *lpv++ = 128; } else { mul = (h[x+1] - ht) * rcph[x+1]; *lpy++ = mul * c[x+1].yuv.y + (1.0f - mul) * 16.0f + 0.5f; *lpu++ = mul * c[x+1].yuv.u + (1.0f - mul) * 128.0f + 0.5f; *lpv++ = mul * c[x+1].yuv.v + (1.0f - mul) * 128.0f + 0.5f; } } else { if (h[x+1] <= ht) { *lpy++ = 16; } else { mul = (h[x+1] - ht) * rcph[x+1]; *lpy++ = mul * c[x+1].yuv.y + (1.0f - mul) * 16.0f + 0.5f; } } } ht = (barh - (y+1)) * rcpbarh; lpy = vy + (y+1) * lsy; lpu = vu + (y+1) * lsu; lpv = vv + (y+1) * lsv; for (x = 0; x < w; x += 2) { /* u and v are skipped on yuv420p */ if (fmt != AVPIXFMTYUV420P) { if (h[x] <= ht) { *lpy++ = 16; *lpu++ = 128; *lpv++ = 128; } else { mul = (h[x] - ht) * rcph[x]; *lpy++ = mul * c[x].yuv.y + (1.0f - mul) * 16.0f + 0.5f; *lpu++ = mul * c[x].yuv.u + (1.0f - mul) * 128.0f + 0.5f; *lpv++ = mul * c[x].yuv.v + (1.0f - mul) * 128.0f + 0.5f; } } else { if (h[x] <= ht) { *lpy++ = 16; } else { mul = (h[x] - ht) * rcph[x]; *lpy++ = mul * c[x].yuv.y + (1.0f - mul) * 16.0f + 0.5f; } } /* u and v are skipped on yuv422p and yuv420p */ if (out->format == AVPIXFMTYUV444P) { if (h[x+1] <= ht) { *lpy++ = 16; *lpu++ = 128; *lpv++ = 128; } else { mul = (h[x+1] - ht) * rcph[x+1]; *lpy++ = mul * c[x+1].yuv.y + (1.0f - mul) * 16.0f + 0.5f; *lpu++ = mul * c[x+1].yuv.u + (1.0f - mul) * 128.0f + 0.5f; *lpv++ = mul * c[x+1].yuv.v + (1.0f - mul) * 128.0f + 0.5f; } } else { if (h[x+1] <= ht) { *lpy++ = 16; } else { mul = (h[x+1] - ht) * rcph[x+1]; *lpy++ = mul * c[x+1].yuv.y + (1.0f - mul) * 16.0f + 0.5f; } } } } } ", "target": 0}
{"func": "static int qemuchropenwinfileout(QemuOpts *opts, CharDriverState **chr) { const char *fileout = qemuoptget(opts, \"path\"); HANDLE fdout; fdout = CreateFile(fileout, GENERICWRITE, FILESHAREREAD, NULL, OPENALWAYS, FILEATTRIBUTENORMAL, NULL); if (fdout == INVALIDHANDLEVALUE) { return -EIO; } return qemuchropenwinfile(fdout, chr); } ", "target": 1}
{"func": "int ffh264filldefaultreflist(H264Context *h, H264SliceContext *sl) { int i, len; if (sl->slicetypenos == AVPICTURETYPEB) { H264Picture *sorted[32]; int curpoc, list; int lens[2]; if (FIELDPICTURE(h)) curpoc = h->curpicptr->fieldpoc[h->picturestructure == PICTBOTTOMFIELD]; else curpoc = h->curpicptr->poc; for (list = 0; list < 2; list++) { len = addsorted(sorted, h->shortref, h->shortrefcount, curpoc, 1 ^ list); len += addsorted(sorted + len, h->shortref, h->shortrefcount, curpoc, 0 ^ list); avassert0(len <= 32); len = builddeflist(h->defaultreflist[list], FFARRAYELEMS(h->defaultreflist[0]), sorted, len, 0, h->picturestructure); len += builddeflist(h->defaultreflist[list] + len, FFARRAYELEMS(h->defaultreflist[0]) - len, h->longref, 16, 1, h->picturestructure); avassert0(len <= 32); if (len < sl->refcount[list]) memset(&h->defaultreflist[list][len], 0, sizeof(H264Ref) * (sl->refcount[list] - len)); lens[list] = len; } if (lens[0] == lens[1] && lens[1] > 1) { for (i = 0; i < lens[0] && h->defaultreflist[0][i].parent->f.buf[0]->buffer == h->defaultreflist[1][i].parent->f.buf[0]->buffer; i++); if (i == lens[0]) { FFSWAP(H264Ref, h->defaultreflist[1][0], h->defaultreflist[1][1]); } } } else { len = builddeflist(h->defaultreflist[0], FFARRAYELEMS(h->defaultreflist[0]), h->shortref, h->shortrefcount, 0, h->picturestructure); len += builddeflist(h->defaultreflist[0] + len, FFARRAYELEMS(h->defaultreflist[0]) - len, h-> longref, 16, 1, h->picturestructure); avassert0(len <= 32); if (len < sl->refcount[0]) memset(&h->defaultreflist[0][len], 0, sizeof(H264Ref) * (sl->refcount[0] - len)); } #ifdef TRACE for (i = 0; i < sl->refcount[0]; i++) { tprintf(h->avctx, \"List0: %s fn:%d 0x%p\\n\", (h->defaultreflist[0][i].parent->longref ? \"LT\" : \"ST\"), h->defaultreflist[0][i].picid, h->defaultreflist[0][i].parent->f.data[0]); } if (sl->slicetypenos == AVPICTURETYPEB) { for (i = 0; i < sl->refcount[1]; i++) { tprintf(h->avctx, \"List1: %s fn:%d 0x%p\\n\", (h->defaultreflist[1][i].parent->longref ? \"LT\" : \"ST\"), h->defaultreflist[1][i].picid, h->defaultreflist[1][i].parent->f.data[0]); } } #endif return 0; } ", "target": 1}
{"func": "static void vtdinit(IntelIOMMUState *s) { X86IOMMUState *x86iommu = X86IOMMUDEVICE(s); memset(s->csr, 0, DMARREGSIZE); memset(s->wmask, 0, DMARREGSIZE); memset(s->w1cmask, 0, DMARREGSIZE); memset(s->womask, 0, DMARREGSIZE); s->iommuops.translate = vtdiommutranslate; s->iommuops.notifystarted = vtdiommunotifystarted; s->root = 0; s->rootextended = false; s->dmarenabled = false; s->iqhead = 0; s->iqtail = 0; s->iq = 0; s->iqsize = 0; s->qienabled = false; s->iqlastdesctype = VTDINVDESCNONE; s->nextfrcdreg = 0; s->cap = VTDCAPFRO | VTDCAPNFR | VTDCAPND | VTDCAPMGAW | VTDCAPSAGAW | VTDCAPMAMV | VTDCAPPSI | VTDCAPSLLPS; s->ecap = VTDECAPQI | VTDECAPIRO; if (x86iommu->intrsupported) { s->ecap |= VTDECAPIR | VTDECAPEIM; } vtdresetcontextcache(s); vtdresetiotlb(s); /* Define registers with default values and bit semantics */ vtddefinelong(s, DMARVERREG, 0x10UL, 0, 0); vtddefinequad(s, DMARCAPREG, s->cap, 0, 0); vtddefinequad(s, DMARECAPREG, s->ecap, 0, 0); vtddefinelong(s, DMARGCMDREG, 0, 0xff800000UL, 0); vtddefinelongwo(s, DMARGCMDREG, 0xff800000UL); vtddefinelong(s, DMARGSTSREG, 0, 0, 0); vtddefinequad(s, DMARRTADDRREG, 0, 0xfffffffffffff000ULL, 0); vtddefinequad(s, DMARCCMDREG, 0, 0xe0000003ffffffffULL, 0); vtddefinequadwo(s, DMARCCMDREG, 0x3ffff0000ULL); /* Advanced Fault Logging not supported */ vtddefinelong(s, DMARFSTSREG, 0, 0, 0x11UL); vtddefinelong(s, DMARFECTLREG, 0x80000000UL, 0x80000000UL, 0); vtddefinelong(s, DMARFEDATAREG, 0, 0x0000ffffUL, 0); vtddefinelong(s, DMARFEADDRREG, 0, 0xfffffffcUL, 0); /* Treated as RsvdZ when EIM in ECAPREG is not supported * vtddefinelong(s, DMARFEUADDRREG, 0, 0xffffffffUL, 0); */ vtddefinelong(s, DMARFEUADDRREG, 0, 0, 0); /* Treated as RO for implementations that PLMR and PHMR fields reported * as Clear in the CAPREG. * vtddefinelong(s, DMARPMENREG, 0, 0x80000000UL, 0); */ vtddefinelong(s, DMARPMENREG, 0, 0, 0); vtddefinequad(s, DMARIQHREG, 0, 0, 0); vtddefinequad(s, DMARIQTREG, 0, 0x7fff0ULL, 0); vtddefinequad(s, DMARIQAREG, 0, 0xfffffffffffff007ULL, 0); vtddefinelong(s, DMARICSREG, 0, 0, 0x1UL); vtddefinelong(s, DMARIECTLREG, 0x80000000UL, 0x80000000UL, 0); vtddefinelong(s, DMARIEDATAREG, 0, 0xffffffffUL, 0); vtddefinelong(s, DMARIEADDRREG, 0, 0xfffffffcUL, 0); /* Treadted as RsvdZ when EIM in ECAPREG is not supported */ vtddefinelong(s, DMARIEUADDRREG, 0, 0, 0); /* IOTLB registers */ vtddefinequad(s, DMARIOTLBREG, 0, 0Xb003ffff00000000ULL, 0); vtddefinequad(s, DMARIVAREG, 0, 0xfffffffffffff07fULL, 0); vtddefinequadwo(s, DMARIVAREG, 0xfffffffffffff07fULL); /* Fault Recording Registers, 128-bit */ vtddefinequad(s, DMARFRCDREG00, 0, 0, 0); vtddefinequad(s, DMARFRCDREG02, 0, 0, 0x8000000000000000ULL); /* * Interrupt remapping registers. */ vtddefinequad(s, DMARIRTAREG, 0, 0xfffffffffffff80fULL, 0); } ", "target": 1}
{"func": "const uint8t *ffh263findresyncmarker(const uint8t *avrestrict p, const uint8t *avrestrict end) { avassert2(p < end); end-=2; p++; for(;p<end; p+=2){ if(!*p){ if (!p[-1] && p[1]) return p - 1; else if(!p[ 1] && p[2]) return p; } } return end+2; } ", "target": 0}
{"func": "void helperctc1(CPUMIPSState *env, targetulong arg1, uint32t reg) { switch(reg) { case 25: if (arg1 & 0xffffff00) return; env->activefpu.fcr31 = (env->activefpu.fcr31 & 0x017fffff) | ((arg1 & 0xfe) << 24) | ((arg1 & 0x1) << 23); break; case 26: if (arg1 & 0x007c0000) return; env->activefpu.fcr31 = (env->activefpu.fcr31 & 0xfffc0f83) | (arg1 & 0x0003f07c); break; case 28: if (arg1 & 0x007c0000) return; env->activefpu.fcr31 = (env->activefpu.fcr31 & 0xfefff07c) | (arg1 & 0x00000f83) | ((arg1 & 0x4) << 22); break; case 31: if (arg1 & 0x007c0000) return; env->activefpu.fcr31 = arg1; break; default: return; } /* set rounding mode */ restoreroundingmode(env); /* set flush-to-zero mode */ restoreflushmode(env); setfloatexceptionflags(0, &env->activefpu.fpstatus); if ((GETFPENABLE(env->activefpu.fcr31) | 0x20) & GETFPCAUSE(env->activefpu.fcr31)) doraiseexception(env, EXCPFPE, GETPC()); } ", "target": 0}
{"func": "static void cpusetirq(void *opaque, int irq, int level) { CPUState *env = opaque; if (level) { CPUIRQDPRINTF(\"Raise CPU IRQ %d\\n\", irq); env->halted = 0; env->pilin |= 1 << irq; cpucheckirqs(env); } else { CPUIRQDPRINTF(\"Lower CPU IRQ %d\\n\", irq); env->pilin &= ~(1 << irq); cpucheckirqs(env); } } ", "target": 0}
{"func": "static int getstreamblocksize(BlockDriverState *bdrv) { uint8t cmd[6]; uint8t buf[12]; uint8t sensebuf[8]; sgiohdrt ioheader; int ret; memset(cmd, 0, sizeof(cmd)); memset(buf, 0, sizeof(buf)); cmd[0] = MODESENSE; cmd[4] = sizeof(buf); memset(&ioheader, 0, sizeof(ioheader)); ioheader.interfaceid = 'S'; ioheader.dxferdirection = SGDXFERFROMDEV; ioheader.dxferlen = sizeof(buf); ioheader.dxferp = buf; ioheader.cmdp = cmd; ioheader.cmdlen = sizeof(cmd); ioheader.mxsblen = sizeof(sensebuf); ioheader.sbp = sensebuf; ioheader.timeout = 6000; /* XXX */ ret = bdrvioctl(bdrv, SGIO, &ioheader); if (ret < 0 || ioheader.driverstatus || ioheader.hoststatus) { return -1; } return (buf[9] << 16) | (buf[10] << 8) | buf[11]; } ", "target": 0}
{"func": "int qcow2prewriteoverlapcheck(BlockDriverState *bs, int ign, int64t offset, int64t size) { int ret = qcow2checkmetadataoverlap(bs, ign, offset, size); if (ret < 0) { return ret; } else if (ret > 0) { int metadataolbitnr = ffs(ret) - 1; assert(metadataolbitnr < QCOW2OLMAXBITNR); qcow2signalcorruption(bs, true, offset, size, \"Preventing invalid \" \"write on metadata (overlaps with %s)\", metadataolnames[metadataolbitnr]); return -EIO; } return 0; } ", "target": 0}
{"func": "int ffMPVframestart(MpegEncContext *s, AVCodecContext *avctx) { int i, ret; Picture *pic; s->mbskipped = 0; if (!ffthreadcanstartframe(avctx)) { avlog(avctx, AVLOGERROR, \"Attempt to start a frame outside SETUP state\\n\"); return -1; } /* mark & release old frames */ if (s->picttype != AVPICTURETYPEB && s->lastpictureptr && s->lastpictureptr != s->nextpictureptr && s->lastpictureptr->f.buf[0]) { ffmpegunrefpicture(s, s->lastpictureptr); } /* release forgotten pictures */ /* if (mpeg124/h263) */ for (i = 0; i < MAXPICTURECOUNT; i++) { if (&s->picture[i] != s->lastpictureptr && &s->picture[i] != s->nextpictureptr && s->picture[i].reference && !s->picture[i].needsrealloc) { if (!(avctx->activethreadtype & FFTHREADFRAME)) avlog(avctx, AVLOGERROR, \"releasing zombie picture\\n\"); ffmpegunrefpicture(s, &s->picture[i]); } } ffmpegunrefpicture(s, &s->currentpicture); releaseunusedpictures(s); if (s->currentpictureptr && s->currentpictureptr->f.buf[0] == NULL) { // we already have a unused image // (maybe it was set before reading the header) pic = s->currentpictureptr; } else { i = fffindunusedpicture(s, 0); if (i < 0) { avlog(s->avctx, AVLOGERROR, \"no frame buffer available\\n\"); return i; } pic = &s->picture[i]; } pic->reference = 0; if (!s->droppable) { if (s->picttype != AVPICTURETYPEB) pic->reference = 3; } pic->f.codedpicturenumber = s->codedpicturenumber++; if (ffallocpicture(s, pic, 0) < 0) return -1; s->currentpictureptr = pic; // FIXME use only the vars from currentpic s->currentpictureptr->f.topfieldfirst = s->topfieldfirst; if (s->codecid == AVCODECIDMPEG1VIDEO || s->codecid == AVCODECIDMPEG2VIDEO) { if (s->picturestructure != PICTFRAME) s->currentpictureptr->f.topfieldfirst = (s->picturestructure == PICTTOPFIELD) == s->firstfield; } s->currentpictureptr->f.interlacedframe = !s->progressiveframe && !s->progressivesequence; s->currentpictureptr->fieldpicture = s->picturestructure != PICTFRAME; s->currentpictureptr->f.picttype = s->picttype; // if (s->flags && CODECFLAGQSCALE) // s->currentpictureptr->quality = s->newpictureptr->quality; s->currentpictureptr->f.keyframe = s->picttype == AVPICTURETYPEI; if ((ret = ffmpegrefpicture(s, &s->currentpicture, s->currentpictureptr)) < 0) return ret; if (s->picttype != AVPICTURETYPEB) { s->lastpictureptr = s->nextpictureptr; if (!s->droppable) s->nextpictureptr = s->currentpictureptr; } avdlog(s->avctx, \"L%p N%p C%p L%p N%p C%p type:%d drop:%d\\n\", s->lastpictureptr, s->nextpictureptr,s->currentpictureptr, s->lastpictureptr ? s->lastpictureptr->f.data[0] : NULL, s->nextpictureptr ? s->nextpictureptr->f.data[0] : NULL, s->currentpictureptr ? s->currentpictureptr->f.data[0] : NULL, s->picttype, s->droppable); if ((s->lastpictureptr == NULL || s->lastpictureptr->f.buf[0] == NULL) && (s->picttype != AVPICTURETYPEI || s->picturestructure != PICTFRAME)) { int hchromashift, vchromashift; avpixfmtgetchromasubsample(s->avctx->pixfmt, &hchromashift, &vchromashift); if (s->picttype == AVPICTURETYPEB && s->nextpictureptr && s->nextpictureptr->f.buf[0]) avlog(avctx, AVLOGDEBUG, \"allocating dummy last picture for B frame\\n\"); else if (s->picttype != AVPICTURETYPEI) avlog(avctx, AVLOGERROR, \"warning: first frame is no keyframe\\n\"); else if (s->picturestructure != PICTFRAME) avlog(avctx, AVLOGDEBUG, \"allocate dummy last picture for field based first keyframe\\n\"); /* Allocate a dummy frame */ i = fffindunusedpicture(s, 0); if (i < 0) { avlog(s->avctx, AVLOGERROR, \"no frame buffer available\\n\"); return i; } s->lastpictureptr = &s->picture[i]; s->lastpictureptr->reference = 3; s->lastpictureptr->f.keyframe = 0; s->lastpictureptr->f.picttype = AVPICTURETYPEP; if (ffallocpicture(s, s->lastpictureptr, 0) < 0) { s->lastpictureptr = NULL; return -1; } memset(s->lastpictureptr->f.data[0], 0x80, avctx->height * s->lastpictureptr->f.linesize[0]); memset(s->lastpictureptr->f.data[1], 0x80, (avctx->height >> vchromashift) * s->lastpictureptr->f.linesize[1]); memset(s->lastpictureptr->f.data[2], 0x80, (avctx->height >> vchromashift) * s->lastpictureptr->f.linesize[2]); if(s->codecid == AVCODECIDFLV1 || s->codecid == AVCODECIDH263){ for(i=0; i<avctx->height; i++) memset(s->lastpictureptr->f.data[0] + s->lastpictureptr->f.linesize[0]*i, 16, avctx->width); } ffthreadreportprogress(&s->lastpictureptr->tf, INTMAX, 0); ffthreadreportprogress(&s->lastpictureptr->tf, INTMAX, 1); } if ((s->nextpictureptr == NULL || s->nextpictureptr->f.buf[0] == NULL) && s->picttype == AVPICTURETYPEB) { /* Allocate a dummy frame */ i = fffindunusedpicture(s, 0); if (i < 0) { avlog(s->avctx, AVLOGERROR, \"no frame buffer available\\n\"); return i; } s->nextpictureptr = &s->picture[i]; s->nextpictureptr->reference = 3; s->nextpictureptr->f.keyframe = 0; s->nextpictureptr->f.picttype = AVPICTURETYPEP; if (ffallocpicture(s, s->nextpictureptr, 0) < 0) { s->nextpictureptr = NULL; return -1; } ffthreadreportprogress(&s->nextpictureptr->tf, INTMAX, 0); ffthreadreportprogress(&s->nextpictureptr->tf, INTMAX, 1); } #if 0 // BUFREF-FIXME memset(s->lastpicture.f.data, 0, sizeof(s->lastpicture.f.data)); memset(s->nextpicture.f.data, 0, sizeof(s->nextpicture.f.data)); #endif if (s->lastpictureptr) { ffmpegunrefpicture(s, &s->lastpicture); if (s->lastpictureptr->f.buf[0] && (ret = ffmpegrefpicture(s, &s->lastpicture, s->lastpictureptr)) < 0) return ret; } if (s->nextpictureptr) { ffmpegunrefpicture(s, &s->nextpicture); if (s->nextpictureptr->f.buf[0] && (ret = ffmpegrefpicture(s, &s->nextpicture, s->nextpictureptr)) < 0) return ret; } avassert0(s->picttype == AVPICTURETYPEI || (s->lastpictureptr && s->lastpictureptr->f.buf[0])); if (s->picturestructure!= PICTFRAME) { int i; for (i = 0; i < 4; i++) { if (s->picturestructure == PICTBOTTOMFIELD) { s->currentpicture.f.data[i] += s->currentpicture.f.linesize[i]; } s->currentpicture.f.linesize[i] *= 2; s->lastpicture.f.linesize[i] *= 2; s->nextpicture.f.linesize[i] *= 2; } } s->errrecognition = avctx->errrecognition; /* set dequantizer, we can't do it during init as * it might change for mpeg4 and we can't do it in the header * decode as init is not called for mpeg4 there yet */ if (s->mpegquant || s->codecid == AVCODECIDMPEG2VIDEO) { s->dctunquantizeintra = s->dctunquantizempeg2intra; s->dctunquantizeinter = s->dctunquantizempeg2inter; } else if (s->outformat == FMTH263 || s->outformat == FMTH261) { s->dctunquantizeintra = s->dctunquantizeh263intra; s->dctunquantizeinter = s->dctunquantizeh263inter; } else { s->dctunquantizeintra = s->dctunquantizempeg1intra; s->dctunquantizeinter = s->dctunquantizempeg1inter; } return 0; } ", "target": 0}
{"func": "static void cowriterequest(void *opaque) { BDRVSheepdogState *s = opaque; qemucoroutineenter(s->cosend, NULL); } ", "target": 1}
{"func": "static int decodeframeilbm(AVCodecContext *avctx, void *data, int *datasize, AVPacket *avpkt) { IffContext *s = avctx->privdata; const uint8t *buf = avpkt->size >= 2 ? avpkt->data + AVRB16(avpkt->data) : NULL; const int bufsize = avpkt->size >= 2 ? avpkt->size - AVRB16(avpkt->data) : 0; const uint8t *bufend = buf+bufsize; int y, plane, res; if ((res = extractheader(avctx, avpkt)) < 0) return res; if (s->init) { if ((res = avctx->regetbuffer(avctx, &s->frame)) < 0) { avlog(avctx, AVLOGERROR, \"regetbuffer() failed\\n\"); return res; } } else if ((res = avctx->getbuffer(avctx, &s->frame)) < 0) { avlog(avctx, AVLOGERROR, \"getbuffer() failed\\n\"); return res; } else if (avctx->bitspercodedsample <= 8 && avctx->pixfmt != PIXFMTGRAY8) { if ((res = ffcmapreadpalette(avctx, (uint32t*)s->frame.data[1])) < 0) return res; } s->init = 1; if (avctx->codectag == MKTAG('A','C','B','M')) { if (avctx->pixfmt == PIXFMTPAL8 || avctx->pixfmt == PIXFMTGRAY8) { memset(s->frame.data[0], 0, avctx->height * s->frame.linesize[0]); for (plane = 0; plane < s->bpp; plane++) { for(y = 0; y < avctx->height && buf < bufend; y++ ) { uint8t *row = &s->frame.data[0][ y*s->frame.linesize[0] ]; decodeplane8(row, buf, FFMIN(s->planesize, bufend - buf), plane); buf += s->planesize; } } } else if (s->ham) { // HAM to PIXFMTBGR32 memset(s->frame.data[0], 0, avctx->height * s->frame.linesize[0]); for(y = 0; y < avctx->height; y++) { uint8t *row = &s->frame.data[0][y * s->frame.linesize[0]]; memset(s->hambuf, 0, s->planesize * 8); for (plane = 0; plane < s->bpp; plane++) { const uint8t * start = buf + (plane * avctx->height + y) * s->planesize; if (start >= bufend) break; decodeplane8(s->hambuf, start, FFMIN(s->planesize, bufend - start), plane); } decodehamplane32((uint32t *) row, s->hambuf, s->hampalbuf, s->planesize); } } } else if (avctx->codectag == MKTAG('D','E','E','P')) { int rawwidth = avctx->width * (avgetbitsperpixel(&avpixfmtdescriptors[avctx->pixfmt]) >> 3); int x; for(y = 0; y < avctx->height && buf < bufend; y++ ) { uint8t *row = &s->frame.data[0][y * s->frame.linesize[0]]; memcpy(row, buf, FFMIN(rawwidth, bufend - buf)); buf += rawwidth; if (avctx->pixfmt == PIXFMTBGR32) { for(x = 0; x < avctx->width; x++) row[4 * x + 3] = row[4 * x + 3] & 0xF0 | (row[4 * x + 3] >> 4); } } } else if (avctx->codectag == MKTAG('I','L','B','M')) { // interleaved if (avctx->pixfmt == PIXFMTPAL8 || avctx->pixfmt == PIXFMTGRAY8) { for(y = 0; y < avctx->height; y++ ) { uint8t *row = &s->frame.data[0][ y*s->frame.linesize[0] ]; memset(row, 0, avctx->width); for (plane = 0; plane < s->bpp && buf < bufend; plane++) { decodeplane8(row, buf, FFMIN(s->planesize, bufend - buf), plane); buf += s->planesize; } } } else if (s->ham) { // HAM to PIXFMTBGR32 for (y = 0; y < avctx->height; y++) { uint8t *row = &s->frame.data[0][ y*s->frame.linesize[0] ]; memset(s->hambuf, 0, s->planesize * 8); for (plane = 0; plane < s->bpp && buf < bufend; plane++) { decodeplane8(s->hambuf, buf, FFMIN(s->planesize, bufend - buf), plane); buf += s->planesize; } decodehamplane32((uint32t *) row, s->hambuf, s->hampalbuf, s->planesize); } } else { // PIXFMTBGR32 for(y = 0; y < avctx->height; y++ ) { uint8t *row = &s->frame.data[0][y*s->frame.linesize[0]]; memset(row, 0, avctx->width << 2); for (plane = 0; plane < s->bpp && buf < bufend; plane++) { decodeplane32((uint32t *) row, buf, FFMIN(s->planesize, bufend - buf), plane); buf += s->planesize; } } } } else if (avctx->codectag == MKTAG('P','B','M',' ')) { // IFF-PBM if (avctx->pixfmt == PIXFMTPAL8 || avctx->pixfmt == PIXFMTGRAY8) { for(y = 0; y < avctx->height; y++ ) { uint8t *row = &s->frame.data[0][y * s->frame.linesize[0]]; memcpy(row, buf, FFMIN(avctx->width, bufend - buf)); buf += avctx->width + (avctx->width % 2); // padding if odd } } else if (s->ham) { // IFF-PBM: HAM to PIXFMTBGR32 for (y = 0; y < avctx->height; y++) { uint8t *row = &s->frame.data[0][ y*s->frame.linesize[0] ]; memcpy(s->hambuf, buf, FFMIN(avctx->width, bufend - buf)); buf += avctx->width + (avctx->width & 1); // padding if odd decodehamplane32((uint32t *) row, s->hambuf, s->hampalbuf, s->planesize); } } else { avlogaskforsample(avctx, \"unsupported bpp\\n\"); return AVERRORINVALIDDATA; } } *datasize = sizeof(AVFrame); *(AVFrame*)data = s->frame; return bufsize; } ", "target": 1}
{"func": "udplisten(Slirp *slirp, uint32t haddr, uint hport, uint32t laddr, uint lport, int flags) { \tstruct sockaddrin addr; \tstruct socket *so; \tsocklent addrlen = sizeof(struct sockaddrin), opt = 1; \tso = socreate(slirp); \tif (!so) { \t return NULL; \t} \tso->s = socket(AFINET,SOCKDGRAM,0); \tso->soexpire = curtime + SOEXPIRE; \tinsque(so, &slirp->udb); \taddr.sinfamily = AFINET; \taddr.sinaddr.saddr = haddr; \taddr.sinport = hport; \tif (bind(so->s,(struct sockaddr *)&addr, addrlen) < 0) { \t\tudpdetach(so); \t\treturn NULL; \t} \tsetsockopt(so->s,SOLSOCKET,SOREUSEADDR,(char *)&opt,sizeof(int)); \tgetsockname(so->s,(struct sockaddr *)&addr,&addrlen); \tso->sofport = addr.sinport; \tif (addr.sinaddr.saddr == 0 || \t addr.sinaddr.saddr == loopbackaddr.saddr) { \t so->sofaddr = slirp->vhostaddr; \t} else { \t so->sofaddr = addr.sinaddr; \t} \tso->solport = lport; \tso->soladdr.saddr = laddr; \tif (flags != SSFACCEPTONCE) \t so->soexpire = 0; \tso->sostate &= SSPERSISTENTMASK; \tso->sostate |= SSISFCONNECTED | flags; \treturn so; } ", "target": 1}
{"func": "static uint32t grlibirqmpreadl(void *opaque, targetphysaddrt addr) { IRQMP *irqmp = opaque; IRQMPState *state; assert(irqmp != NULL); state = irqmp->state; assert(state != NULL); addr &= 0xff; /* global registers */ switch (addr) { case LEVELOFFSET: return state->level; case PENDINGOFFSET: return state->pending; case FORCE0OFFSET: /* This register is an \"alias\" for the force register of CPU 0 */ return state->force[0]; case CLEAROFFSET: case MPSTATUSOFFSET: /* Always read as 0 */ return 0; case BROADCASTOFFSET: return state->broadcast; default: break; } /* mask registers */ if (addr >= MASKOFFSET && addr < FORCEOFFSET) { int cpu = (addr - MASKOFFSET) / 4; assert(cpu >= 0 && cpu < IRQMPMAXCPU); return state->mask[cpu]; } /* force registers */ if (addr >= FORCEOFFSET && addr < EXTENDEDOFFSET) { int cpu = (addr - FORCEOFFSET) / 4; assert(cpu >= 0 && cpu < IRQMPMAXCPU); return state->force[cpu]; } /* extended (not supported) */ if (addr >= EXTENDEDOFFSET && addr < IRQMPREGSIZE) { int cpu = (addr - EXTENDEDOFFSET) / 4; assert(cpu >= 0 && cpu < IRQMPMAXCPU); return state->extended[cpu]; } tracegrlibirqmpunknownregister(\"read\", addr); return 0; } ", "target": 1}
{"func": "void qemusglistdestroy(QEMUSGList *qsg) { gfree(qsg->sg); }", "target": 1}
{"func": "static int virtio9pdeviceinit(VirtIODevice *vdev) { V9fsState *s = VIRTIO9P(vdev); int i, len; struct stat stat; FsDriverEntry *fse; V9fsPath path; virtioinit(VIRTIODEVICE(s), \"virtio-9p\", VIRTIOID9P, sizeof(struct virtio9pconfig) + MAXTAGLEN); /* initialize pdu allocator */ QLISTINIT(&s->freelist); QLISTINIT(&s->activelist); for (i = 0; i < (MAXREQ - 1); i++) { QLISTINSERTHEAD(&s->freelist, &s->pdus[i], next); } s->vq = virtioaddqueue(vdev, MAXREQ, handle9poutput); fse = getfsdevfsentry(s->fsconf.fsdevid); if (!fse) { /* We don't have a fsdev identified by fsdevid */ fprintf(stderr, \"Virtio-9p device couldn't find fsdev with the \" \"id = %s\\n\", s->fsconf.fsdevid ? s->fsconf.fsdevid : \"NULL\"); goto out; } if (!s->fsconf.tag) { /* we haven't specified a mounttag */ fprintf(stderr, \"fsdev with id %s needs mounttag arguments\\n\", s->fsconf.fsdevid); goto out; } s->ctx.exportflags = fse->exportflags; s->ctx.fsroot = gstrdup(fse->path); s->ctx.exops.getstgen = NULL; len = strlen(s->fsconf.tag); if (len > MAXTAGLEN - 1) { fprintf(stderr, \"mount tag '%s' (%d bytes) is longer than \" \"maximum (%d bytes)\", s->fsconf.tag, len, MAXTAGLEN - 1); goto out; } s->tag = gstrdup(s->fsconf.tag); s->ctx.uid = -1; s->ops = fse->ops; s->configsize = sizeof(struct virtio9pconfig) + len; s->fidlist = NULL; qemucorwlockinit(&s->renamelock); if (s->ops->init(&s->ctx) < 0) { fprintf(stderr, \"Virtio-9p Failed to initialize fs-driver with id:%s\" \" and export path:%s\\n\", s->fsconf.fsdevid, s->ctx.fsroot); goto out; } if (v9fsinitworkerthreads() < 0) { fprintf(stderr, \"worker thread initialization failed\\n\"); goto out; } /* * Check details of export path, We need to use fs driver * call back to do that. Since we are in the init path, we don't * use co-routines here. */ v9fspathinit(&path); if (s->ops->nametopath(&s->ctx, NULL, \"/\", &path) < 0) { fprintf(stderr, \"error in converting name to path %s\", strerror(errno)); goto out; } if (s->ops->lstat(&s->ctx, &path, &stat)) { fprintf(stderr, \"share path %s does not exist\\n\", fse->path); goto out; } else if (!SISDIR(stat.stmode)) { fprintf(stderr, \"share path %s is not a directory\\n\", fse->path); goto out; } v9fspathfree(&path); return 0; out: gfree(s->ctx.fsroot); gfree(s->tag); virtiocleanup(vdev); v9fspathfree(&path); return -1; } ", "target": 1}
{"func": "static int v9fsrequest(V9fsProxy *proxy, int type, void *response, const char *fmt, ...) { devt rdev; valist ap; int size = 0; int retval = 0; uint64t offset; ProxyHeader header = { 0, 0}; struct timespec spec[2]; int flags, mode, uid, gid; V9fsString *name, *value; V9fsString *path, *oldpath; struct iovec *iovec = NULL, *reply = NULL; qemumutexlock(&proxy->mutex); if (proxy->sockfd == -1) { retval = -EIO; goto errout; } iovec = &proxy->outiovec; reply = &proxy->iniovec; vastart(ap, fmt); switch (type) { case TOPEN: path = vaarg(ap, V9fsString *); flags = vaarg(ap, int); retval = proxymarshal(iovec, PROXYHDRSZ, \"sd\", path, flags); if (retval > 0) { header.size = retval; header.type = TOPEN; } break; case TCREATE: path = vaarg(ap, V9fsString *); flags = vaarg(ap, int); mode = vaarg(ap, int); uid = vaarg(ap, int); gid = vaarg(ap, int); retval = proxymarshal(iovec, PROXYHDRSZ, \"sdddd\", path, flags, mode, uid, gid); if (retval > 0) { header.size = retval; header.type = TCREATE; } break; case TMKNOD: path = vaarg(ap, V9fsString *); mode = vaarg(ap, int); rdev = vaarg(ap, long int); uid = vaarg(ap, int); gid = vaarg(ap, int); retval = proxymarshal(iovec, PROXYHDRSZ, \"ddsdq\", uid, gid, path, mode, rdev); if (retval > 0) { header.size = retval; header.type = TMKNOD; } break; case TMKDIR: path = vaarg(ap, V9fsString *); mode = vaarg(ap, int); uid = vaarg(ap, int); gid = vaarg(ap, int); retval = proxymarshal(iovec, PROXYHDRSZ, \"ddsd\", uid, gid, path, mode); if (retval > 0) { header.size = retval; header.type = TMKDIR; } break; case TSYMLINK: oldpath = vaarg(ap, V9fsString *); path = vaarg(ap, V9fsString *); uid = vaarg(ap, int); gid = vaarg(ap, int); retval = proxymarshal(iovec, PROXYHDRSZ, \"ddss\", uid, gid, oldpath, path); if (retval > 0) { header.size = retval; header.type = TSYMLINK; } break; case TLINK: oldpath = vaarg(ap, V9fsString *); path = vaarg(ap, V9fsString *); retval = proxymarshal(iovec, PROXYHDRSZ, \"ss\", oldpath, path); if (retval > 0) { header.size = retval; header.type = TLINK; } break; case TLSTAT: path = vaarg(ap, V9fsString *); retval = proxymarshal(iovec, PROXYHDRSZ, \"s\", path); if (retval > 0) { header.size = retval; header.type = TLSTAT; } break; case TREADLINK: path = vaarg(ap, V9fsString *); size = vaarg(ap, int); retval = proxymarshal(iovec, PROXYHDRSZ, \"sd\", path, size); if (retval > 0) { header.size = retval; header.type = TREADLINK; } break; case TSTATFS: path = vaarg(ap, V9fsString *); retval = proxymarshal(iovec, PROXYHDRSZ, \"s\", path); if (retval > 0) { header.size = retval; header.type = TSTATFS; } break; case TCHMOD: path = vaarg(ap, V9fsString *); mode = vaarg(ap, int); retval = proxymarshal(iovec, PROXYHDRSZ, \"sd\", path, mode); if (retval > 0) { header.size = retval; header.type = TCHMOD; } break; case TCHOWN: path = vaarg(ap, V9fsString *); uid = vaarg(ap, int); gid = vaarg(ap, int); retval = proxymarshal(iovec, PROXYHDRSZ, \"sdd\", path, uid, gid); if (retval > 0) { header.size = retval; header.type = TCHOWN; } break; case TTRUNCATE: path = vaarg(ap, V9fsString *); offset = vaarg(ap, uint64t); retval = proxymarshal(iovec, PROXYHDRSZ, \"sq\", path, offset); if (retval > 0) { header.size = retval; header.type = TTRUNCATE; } break; case TUTIME: path = vaarg(ap, V9fsString *); spec[0].tvsec = vaarg(ap, long); spec[0].tvnsec = vaarg(ap, long); spec[1].tvsec = vaarg(ap, long); spec[1].tvnsec = vaarg(ap, long); retval = proxymarshal(iovec, PROXYHDRSZ, \"sqqqq\", path, spec[0].tvsec, spec[1].tvnsec, spec[1].tvsec, spec[1].tvnsec); if (retval > 0) { header.size = retval; header.type = TUTIME; } break; case TRENAME: oldpath = vaarg(ap, V9fsString *); path = vaarg(ap, V9fsString *); retval = proxymarshal(iovec, PROXYHDRSZ, \"ss\", oldpath, path); if (retval > 0) { header.size = retval; header.type = TRENAME; } break; case TREMOVE: path = vaarg(ap, V9fsString *); retval = proxymarshal(iovec, PROXYHDRSZ, \"s\", path); if (retval > 0) { header.size = retval; header.type = TREMOVE; } break; case TLGETXATTR: size = vaarg(ap, int); path = vaarg(ap, V9fsString *); name = vaarg(ap, V9fsString *); retval = proxymarshal(iovec, PROXYHDRSZ, \"dss\", size, path, name); if (retval > 0) { header.size = retval; header.type = TLGETXATTR; } break; case TLLISTXATTR: size = vaarg(ap, int); path = vaarg(ap, V9fsString *); retval = proxymarshal(iovec, PROXYHDRSZ, \"ds\", size, path); if (retval > 0) { header.size = retval; header.type = TLLISTXATTR; } break; case TLSETXATTR: path = vaarg(ap, V9fsString *); name = vaarg(ap, V9fsString *); value = vaarg(ap, V9fsString *); size = vaarg(ap, int); flags = vaarg(ap, int); retval = proxymarshal(iovec, PROXYHDRSZ, \"sssdd\", path, name, value, size, flags); if (retval > 0) { header.size = retval; header.type = TLSETXATTR; } break; case TLREMOVEXATTR: path = vaarg(ap, V9fsString *); name = vaarg(ap, V9fsString *); retval = proxymarshal(iovec, PROXYHDRSZ, \"ss\", path, name); if (retval > 0) { header.size = retval; header.type = TLREMOVEXATTR; } break; case TGETVERSION: path = vaarg(ap, V9fsString *); retval = proxymarshal(iovec, PROXYHDRSZ, \"s\", path); if (retval > 0) { header.size = retval; header.type = TGETVERSION; } break; default: errorreport(\"Invalid type %d\", type); retval = -EINVAL; break; } vaend(ap); if (retval < 0) { goto errout; } /* marshal the header details */ proxymarshal(iovec, 0, \"dd\", header.type, header.size); header.size += PROXYHDRSZ; retval = qemuwritefull(proxy->sockfd, iovec->iovbase, header.size); if (retval != header.size) { goto closeerror; } switch (type) { case TOPEN: case TCREATE: /* * A file descriptor is returned as response for * TOPEN,TCREATE on success */ if (v9fsreceivefd(proxy->sockfd, &retval) < 0) { goto closeerror; } break; case TMKNOD: case TMKDIR: case TSYMLINK: case TLINK: case TCHMOD: case TCHOWN: case TRENAME: case TTRUNCATE: case TUTIME: case TREMOVE: case TLSETXATTR: case TLREMOVEXATTR: if (v9fsreceivestatus(proxy, reply, &retval) < 0) { goto closeerror; } break; case TLSTAT: case TREADLINK: case TSTATFS: case TGETVERSION: if (v9fsreceiveresponse(proxy, type, &retval, response) < 0) { goto closeerror; } break; case TLGETXATTR: case TLLISTXATTR: if (!size) { if (v9fsreceivestatus(proxy, reply, &retval) < 0) { goto closeerror; } } else { if (v9fsreceiveresponse(proxy, type, &retval, response) < 0) { goto closeerror; } } break; } errout: qemumutexunlock(&proxy->mutex); return retval; closeerror: close(proxy->sockfd); proxy->sockfd = -1; qemumutexunlock(&proxy->mutex); return -EIO; } ", "target": 0}
{"func": "static void scsireqsetstatus(SCSIDiskReq *r, int status, int sensecode) { SCSIDiskState *s = DOUPCAST(SCSIDiskState, qdev, r->req.dev); r->req.status = status; scsidisksetsense(s, sensecode); } ", "target": 1}
{"func": "static inline void sdhciblkgapwrite(SDHCIState *s, uint8t value) { if ((value & SDHCSTOPATGAPREQ) && (s->blkgap & SDHCSTOPATGAPREQ)) { return; } s->blkgap = value & SDHCSTOPATGAPREQ; if ((value & SDHCCONTINUEREQ) && s->stoppedstate && (s->blkgap & SDHCSTOPATGAPREQ) == 0) { if (s->stoppedstate == sdhcgapread) { s->prnsts |= SDHCDATLINEACTIVE | SDHCDOINGREAD; SDHCIGETCLASS(s)->readblockfromcard(s); } else { s->prnsts |= SDHCDATLINEACTIVE | SDHCDOINGWRITE; SDHCIGETCLASS(s)->writeblocktocard(s); } s->stoppedstate = sdhcnotstopped; } else if (!s->stoppedstate && (value & SDHCSTOPATGAPREQ)) { if (s->prnsts & SDHCDOINGREAD) { s->stoppedstate = sdhcgapread; } else if (s->prnsts & SDHCDOINGWRITE) { s->stoppedstate = sdhcgapwrite; } } } ", "target": 0}
{"func": "static void qemuchrparsevc(QemuOpts *opts, ChardevBackend *backend, Error **errp) { int val; backend->vc = gnew0(ChardevVC, 1); val = qemuoptgetnumber(opts, \"width\", 0); if (val != 0) { backend->vc->haswidth = true; backend->vc->width = val; } val = qemuoptgetnumber(opts, \"height\", 0); if (val != 0) { backend->vc->hasheight = true; backend->vc->height = val; } val = qemuoptgetnumber(opts, \"cols\", 0); if (val != 0) { backend->vc->hascols = true; backend->vc->cols = val; } val = qemuoptgetnumber(opts, \"rows\", 0); if (val != 0) { backend->vc->hasrows = true; backend->vc->rows = val; } } ", "target": 0}
{"func": "static unsigned int findbest(struct vfinstance *vf){ int isformatokay = vf->next->queryformat(vf->next, IMGFMTYV12); if ((isformatokay & VFCAPCSPSUPPORTEDBYHW) || (isformatokay & VFCAPCSPSUPPORTED)) return IMGFMTYV12; else return 0; } ", "target": 1}
{"func": "void helperidivlEAXT0(void) { int den, q, r; int64t num; num = ((uint32t)EAX) | ((uint64t)((uint32t)EDX) << 32); den = T0; if (den == 0) { raiseexception(EXCP00DIVZ); } #ifdef BUGGYGCCDIV64 r = idiv32(&q, num, den); #else q = (num / den); r = (num % den); #endif EAX = (uint32t)q; EDX = (uint32t)r; } ", "target": 1}
{"func": "static inline void idctcol(int16t *blk, const uint8t *quant) { int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF; int t10, t11, t12, t13; int s0, s1, s2, s3, s4, s5, s6, s7; s0 = (int) blk[0 * 8] * quant[0 * 8]; s1 = (int) blk[1 * 8] * quant[1 * 8]; s2 = (int) blk[2 * 8] * quant[2 * 8]; s3 = (int) blk[3 * 8] * quant[3 * 8]; s4 = (int) blk[4 * 8] * quant[4 * 8]; s5 = (int) blk[5 * 8] * quant[5 * 8]; s6 = (int) blk[6 * 8] * quant[6 * 8]; s7 = (int) blk[7 * 8] * quant[7 * 8]; t0 = (s3 * 19266 + s5 * 12873) >> 15; t1 = (s5 * 19266 - s3 * 12873) >> 15; t2 = ((s7 * 4520 + s1 * 22725) >> 15) - t0; t3 = ((s1 * 4520 - s7 * 22725) >> 15) - t1; t4 = t0 * 2 + t2; t5 = t1 * 2 + t3; t6 = t2 - t3; t7 = t3 * 2 + t6; t8 = (t6 * 11585) >> 14; t9 = (t7 * 11585) >> 14; tA = (s2 * 8867 - s6 * 21407) >> 14; tB = (s6 * 8867 + s2 * 21407) >> 14; tC = (s0 >> 1) - (s4 >> 1); tD = (s4 >> 1) * 2 + tC; tE = tC - (tA >> 1); tF = tD - (tB >> 1); t10 = tF - t5; t11 = tE - t8; t12 = tE + (tA >> 1) * 2 - t9; t13 = tF + (tB >> 1) * 2 - t4; blk[0 * 8] = t13 + t4 * 2; blk[1 * 8] = t12 + t9 * 2; blk[2 * 8] = t11 + t8 * 2; blk[3 * 8] = t10 + t5 * 2; blk[4 * 8] = t10; blk[5 * 8] = t11; blk[6 * 8] = t12; blk[7 * 8] = t13; } ", "target": 1}
{"func": "static int fourxmprobe(AVProbeData *p) { if (p->bufsize < 12) return 0; if ((AVRL32(&p->buf[0]) != RIFFTAG) || (AVRL32(&p->buf[8]) != 4XMVTAG)) return 0; return AVPROBESCOREMAX; } ", "target": 0}
{"func": "static void jpegtableheader(AVCodecContext *avctx, PutBitContext *p, ScanTable *intrascantable, uint16t lumaintramatrix[64], uint16t chromaintramatrix[64], int hsample[3]) { int i, j, size; uint8t *ptr; MpegEncContext *s = avctx->privdata; if (avctx->codecid != AVCODECIDLJPEG) { int matrixcount = 1 + !!memcmp(lumaintramatrix, chromaintramatrix, sizeof(lumaintramatrix[0]) * 64); if (s->forceduplicatedmatrix) matrixcount = 2; /* quant matrixes */ putmarker(p, DQT); putbits(p, 16, 2 + matrixcount * (1 + 64)); putbits(p, 4, 0); /* 8 bit precision */ putbits(p, 4, 0); /* table 0 */ for(i=0;i<64;i++) { j = intrascantable->permutated[i]; putbits(p, 8, lumaintramatrix[j]); } if (matrixcount > 1) { putbits(p, 4, 0); /* 8 bit precision */ putbits(p, 4, 1); /* table 1 */ for(i=0;i<64;i++) { j = intrascantable->permutated[i]; putbits(p, 8, chromaintramatrix[j]); } } } if(avctx->activethreadtype & FFTHREADSLICE){ putmarker(p, DRI); putbits(p, 16, 4); putbits(p, 16, (avctx->width-1)/(8*hsample[0]) + 1); } /* huffman table */ putmarker(p, DHT); flushputbits(p); ptr = putbitsptr(p); putbits(p, 16, 0); /* patched later */ size = 2; // Only MJPEG can have a variable Huffman variable. All other // formats use the default Huffman table. if (s->outformat == FMTMJPEG && s->huffman == HUFFMANTABLEOPTIMAL) { size += puthuffmantable(p, 0, 0, s->mjpegctx->bitsdcluminance, s->mjpegctx->valdcluminance); size += puthuffmantable(p, 0, 1, s->mjpegctx->bitsdcchrominance, s->mjpegctx->valdcchrominance); size += puthuffmantable(p, 1, 0, s->mjpegctx->bitsacluminance, s->mjpegctx->valacluminance); size += puthuffmantable(p, 1, 1, s->mjpegctx->bitsacchrominance, s->mjpegctx->valacchrominance); } else { size += puthuffmantable(p, 0, 0, avprivmjpegbitsdcluminance, avprivmjpegvaldc); size += puthuffmantable(p, 0, 1, avprivmjpegbitsdcchrominance, avprivmjpegvaldc); size += puthuffmantable(p, 1, 0, avprivmjpegbitsacluminance, avprivmjpegvalacluminance); size += puthuffmantable(p, 1, 1, avprivmjpegbitsacchrominance, avprivmjpegvalacchrominance); } AVWB16(ptr, size); } ", "target": 0}
{"func": "static void ppcspaprinit(MachineState *machine) { sPAPRMachineState *spapr = SPAPRMACHINE(machine); sPAPRMachineClass *smc = SPAPRMACHINEGETCLASS(machine); const char *kernelfilename = machine->kernelfilename; const char *kernelcmdline = machine->kernelcmdline; const char *initrdfilename = machine->initrdfilename; PowerPCCPU *cpu; PCIHostState *phb; int i; MemoryRegion *sysmem = getsystemmemory(); MemoryRegion *ram = gnew(MemoryRegion, 1); MemoryRegion *rmaregion; void *rma = NULL; hwaddr rmaallocsize; hwaddr node0size = spaprnode0size(); uint32t initrdbase = 0; long kernelsize = 0, initrdsize = 0; long loadlimit, fwsize; bool kernelle = false; char *filename; msisupported = true; QLISTINIT(&spapr->phbs); cpuppchypercall = emulatespaprhypercall; /* Allocate RMA if necessary */ rmaallocsize = kvmppcallocrma(&rma); if (rmaallocsize == -1) { errorreport(\"Unable to create RMA\"); exit(1); } if (rmaallocsize && (rmaallocsize < node0size)) { spapr->rmasize = rmaallocsize; } else { spapr->rmasize = node0size; /* With KVM, we don't actually know whether KVM supports an * unbounded RMA (PR KVM) or is limited by the hash table size * (HV KVM using VRMA), so we always assume the latter * * In that case, we also limit the initial allocations for RTAS * etc... to 256M since we have no way to know what the VRMA size * is going to be as it depends on the size of the hash table * isn't determined yet. */ if (kvmenabled()) { spapr->vrmaadjust = 1; spapr->rmasize = MIN(spapr->rmasize, 0x10000000); } } if (spapr->rmasize > node0size) { errorreport(\"Numa node 0 has to span the RMA (%#08\"HWADDRPRIx\")\", spapr->rmasize); exit(1); } /* Setup a load limit for the ramdisk leaving room for SLOF and FDT */ loadlimit = MIN(spapr->rmasize, RTASMAXADDR) - FWOVERHEAD; /* We aim for a hash table of size 1/128 the size of RAM. The * normal rule of thumb is 1/64 the size of RAM, but that's much * more than needed for the Linux guests we support. */ spapr->htabshift = 18; /* Minimum architected size */ while (spapr->htabshift <= 46) { if ((1ULL << (spapr->htabshift + 7)) >= machine->maxramsize) { break; } spapr->htabshift++; } spaprallochtab(spapr); /* Set up Interrupt Controller before we create the VCPUs */ spapr->icp = xicssysteminit(machine, DIVROUNDUP(maxcpus * kvmppcsmtthreads(), smpthreads), XICSIRQS, &errorfatal); if (smc->drlmbenabled) { spaprvalidatenodememory(machine, &errorfatal); } /* init CPUs */ if (machine->cpumodel == NULL) { machine->cpumodel = kvmenabled() ? \"host\" : \"POWER7\"; } for (i = 0; i < smpcpus; i++) { cpu = cpuppcinit(machine->cpumodel); if (cpu == NULL) { errorreport(\"Unable to find PowerPC CPU definition\"); exit(1); } spaprcpuinit(spapr, cpu, &errorfatal); } if (kvmenabled()) { /* Enable HLOGICALCI* so SLOF can talk to in-kernel devices */ kvmppcenablelogicalcihcalls(); kvmppcenablesetmodehcall(); } /* allocate RAM */ memoryregionallocatesystemmemory(ram, NULL, \"ppcspapr.ram\", machine->ramsize); memoryregionaddsubregion(sysmem, 0, ram); if (rmaallocsize && rma) { rmaregion = gnew(MemoryRegion, 1); memoryregioninitramptr(rmaregion, NULL, \"ppcspapr.rma\", rmaallocsize, rma); vmstateregisterramglobal(rmaregion); memoryregionaddsubregion(sysmem, 0, rmaregion); } /* initialize hotplug memory address space */ if (machine->ramsize < machine->maxramsize) { ramaddrt hotplugmemsize = machine->maxramsize - machine->ramsize; if (machine->ramslots > SPAPRMAXRAMSLOTS) { errorreport(\"Specified number of memory slots %\" PRIu64\" exceeds max supported %d\", machine->ramslots, SPAPRMAXRAMSLOTS); exit(1); } spapr->hotplugmemory.base = ROUNDUP(machine->ramsize, SPAPRHOTPLUGMEMALIGN); memoryregioninit(&spapr->hotplugmemory.mr, OBJECT(spapr), \"hotplug-memory\", hotplugmemsize); memoryregionaddsubregion(sysmem, spapr->hotplugmemory.base, &spapr->hotplugmemory.mr); } if (smc->drlmbenabled) { spaprcreatelmbdrconnectors(spapr); } filename = qemufindfile(QEMUFILETYPEBIOS, \"spapr-rtas.bin\"); if (!filename) { errorreport(\"Could not find LPAR rtas '%s'\", \"spapr-rtas.bin\"); exit(1); } spapr->rtassize = getimagesize(filename); spapr->rtasblob = gmalloc(spapr->rtassize); if (loadimagesize(filename, spapr->rtasblob, spapr->rtassize) < 0) { errorreport(\"Could not load LPAR rtas '%s'\", filename); exit(1); } if (spapr->rtassize > RTASMAXSIZE) { errorreport(\"RTAS too big ! 0x%zx bytes (max is 0x%x)\", (sizet)spapr->rtassize, RTASMAXSIZE); exit(1); } gfree(filename); /* Set up EPOW events infrastructure */ spapreventsinit(spapr); /* Set up the RTC RTAS interfaces */ spaprrtccreate(spapr); /* Set up VIO bus */ spapr->viobus = spaprviobusinit(); for (i = 0; i < MAXSERIALPORTS; i++) { if (serialhds[i]) { spaprvtycreate(spapr->viobus, serialhds[i]); } } /* We always have at least the nvram device on VIO */ spaprcreatenvram(spapr); /* Set up PCI */ spaprpcirtasinit(); phb = spaprcreatephb(spapr, 0); for (i = 0; i < nbnics; i++) { NICInfo *nd = &ndtable[i]; if (!nd->model) { nd->model = gstrdup(\"ibmveth\"); } if (strcmp(nd->model, \"ibmveth\") == 0) { spaprvlancreate(spapr->viobus, nd); } else { pcinicinitnofail(&ndtable[i], phb->bus, nd->model, NULL); } } for (i = 0; i <= drivegetmaxbus(IFSCSI); i++) { spaprvscsicreate(spapr->viobus); } /* Graphics */ if (spaprvgainit(phb->bus, &errorfatal)) { spapr->hasgraphics = true; machine->usb |= defaultsenabled() && !machine->usbdisabled; } if (machine->usb) { if (smc->useohcibydefault) { pcicreatesimple(phb->bus, -1, \"pci-ohci\"); } else { pcicreatesimple(phb->bus, -1, \"nec-usb-xhci\"); } if (spapr->hasgraphics) { USBBus *usbbus = usbbusfind(-1); usbcreatesimple(usbbus, \"usb-kbd\"); usbcreatesimple(usbbus, \"usb-mouse\"); } } if (spapr->rmasize < (MINRMASLOF << 20)) { errorreport( \"pSeries SLOF firmware requires >= %ldM guest RMA (Real Mode Area memory)\", MINRMASLOF); exit(1); } if (kernelfilename) { uint64t lowaddr = 0; kernelsize = loadelf(kernelfilename, translatekerneladdress, NULL, NULL, &lowaddr, NULL, 1, PPCELFMACHINE, 0); if (kernelsize == ELFLOADWRONGENDIAN) { kernelsize = loadelf(kernelfilename, translatekerneladdress, NULL, NULL, &lowaddr, NULL, 0, PPCELFMACHINE, 0); kernelle = kernelsize > 0; } if (kernelsize < 0) { errorreport(\"error loading %s: %s\", kernelfilename, loadelfstrerror(kernelsize)); exit(1); } /* load initrd */ if (initrdfilename) { /* Try to locate the initrd in the gap between the kernel * and the firmware. Add a bit of space just in case */ initrdbase = (KERNELLOADADDR + kernelsize + 0x1ffff) & ~0xffff; initrdsize = loadimagetargphys(initrdfilename, initrdbase, loadlimit - initrdbase); if (initrdsize < 0) { errorreport(\"could not load initial ram disk '%s'\", initrdfilename); exit(1); } } else { initrdbase = 0; initrdsize = 0; } } if (biosname == NULL) { biosname = FWFILENAME; } filename = qemufindfile(QEMUFILETYPEBIOS, biosname); if (!filename) { errorreport(\"Could not find LPAR firmware '%s'\", biosname); exit(1); } fwsize = loadimagetargphys(filename, 0, FWMAXSIZE); if (fwsize <= 0) { errorreport(\"Could not load LPAR firmware '%s'\", filename); exit(1); } gfree(filename); /* FIXME: Should register things through the MachineState's qdev * interface, this is a legacy from the sPAPREnvironment structure * which predated MachineState but had a similar function */ vmstateregister(NULL, 0, &vmstatespapr, spapr); registersavevmlive(NULL, \"spapr/htab\", -1, 1, &savevmhtabhandlers, spapr); /* Prepare the device tree */ spapr->fdtskel = spaprcreatefdtskel(initrdbase, initrdsize, kernelsize, kernelle, kernelcmdline, spapr->checkexceptionirq); assert(spapr->fdtskel != NULL); /* used by RTAS */ QTAILQINIT(&spapr->ccslist); qemuregisterreset(spaprccsresethook, spapr); qemuregisterbootset(spaprbootset, spapr); } ", "target": 0}
{"func": "static void n8x0nandsetup(struct n800s *s) { char *otpregion; DriveInfo *dinfo; s->nand = qdevcreate(NULL, \"onenand\"); qdevpropsetuint16(s->nand, \"manufacturerid\", NANDMFRSAMSUNG); /* Either 0x40 or 0x48 are OK for the device ID */ qdevpropsetuint16(s->nand, \"deviceid\", 0x48); qdevpropsetuint16(s->nand, \"versionid\", 0); qdevpropsetint32(s->nand, \"shift\", 1); dinfo = driveget(IFMTD, 0, 0); if (dinfo) { qdevpropsetdrivenofail(s->nand, \"drive\", blkbs(blkbylegacydinfo(dinfo))); } qdevinitnofail(s->nand); sysbusconnectirq(SYSBUSDEVICE(s->nand), 0, qdevgetgpioin(s->mpu->gpio, N8X0ONENANDGPIO)); omapgpmcattach(s->mpu->gpmc, N8X0ONENANDCS, sysbusmmiogetregion(SYSBUSDEVICE(s->nand), 0)); otpregion = onenandrawotp(s->nand); memcpy(otpregion + 0x000, n8x0calwlanmac, sizeof(n8x0calwlanmac)); memcpy(otpregion + 0x800, n8x0calbtid, sizeof(n8x0calbtid)); /* XXX: in theory should also update the OOB for both pages */ } ", "target": 0}
{"func": "void cpudumpstate (CPUState *env, FILE *f, int (*cpufprintf)(FILE *f, const char *fmt, ...), int flags) { uint32t c0status; int i; cpufprintf(f, \"pc=0x\" TARGETFMTlx \" HI=0x\" TARGETFMTlx \" LO=0x\" TARGETFMTlx \" ds %04x \" TARGETFMTlx \" %d\\n\", env->PC, env->HI, env->LO, env->hflags, env->btarget, env->bcond); for (i = 0; i < 32; i++) { if ((i & 3) == 0) cpufprintf(f, \"GPR%02d:\", i); cpufprintf(f, \" %s \" TARGETFMTlx, regnames[i], env->gpr[i]); if ((i & 3) == 3) cpufprintf(f, \"\\n\"); } c0status = env->CP0Status; cpufprintf(f, \"CP0 Status 0x%08x Cause 0x%08x EPC 0x\" TARGETFMTlx \"\\n\", c0status, env->CP0Cause, env->CP0EPC); cpufprintf(f, \" Config0 0x%08x Config1 0x%08x LLAddr 0x\" TARGETFMTlx \"\\n\", env->CP0Config0, env->CP0Config1, env->CP0LLAddr); if (c0status & (1 << CP0StCU1)) fpudumpstate(env, f, cpufprintf, flags); #if defined(TARGETMIPS64) && defined(MIPSDEBUGSIGNEXTENSIONS) cpumipschecksignextensions(env, f, cpufprintf, flags); #endif } ", "target": 0}
{"func": "static int aacsync(uint64t state, AACAC3ParseContext *hdrinfo, int *neednextheader, int *newframestart) { GetBitContext bits; AACADTSHeaderInfo hdr; int size; union { uint64t u64; uint8t u8[8]; } tmp; tmp.u64 = avbe2ne64(state); initgetbits(&bits, tmp.u8+8-AACADTSHEADERSIZE, AACADTSHEADERSIZE * 8); if ((size = avprivaacparseheader(&bits, &hdr)) < 0) return 0; *neednextheader = 0; *newframestart = 1; hdrinfo->samplerate = hdr.samplerate; hdrinfo->channels = ffmpeg4audiochannels[hdr.chanconfig]; hdrinfo->samples = hdr.samples; hdrinfo->bitrate = hdr.bitrate; return size; } ", "target": 1}
{"func": "uint64t helperldasi(CPUSPARCState *env, targetulong addr, int asi, int size, int sign) { uint64t ret = 0; #if defined(DEBUGASI) targetulong lastaddr = addr; #endif if (asi < 0x80) { helperraiseexception(env, TTPRIVACT); } helpercheckalign(env, addr, size - 1); addr = asiaddressmask(env, asi, addr); switch (asi) { case 0x82: /* Primary no-fault */ case 0x8a: /* Primary no-fault LE */ if (pagecheckrange(addr, size, PAGEREAD) == -1) { #ifdef DEBUGASI dumpasi(\"read \", lastaddr, asi, size, ret); #endif return 0; } /* Fall through */ case 0x80: /* Primary */ case 0x88: /* Primary LE */ { switch (size) { case 1: ret = ldubraw(addr); break; case 2: ret = lduwraw(addr); break; case 4: ret = ldlraw(addr); break; default: case 8: ret = ldqraw(addr); break; } } break; case 0x83: /* Secondary no-fault */ case 0x8b: /* Secondary no-fault LE */ if (pagecheckrange(addr, size, PAGEREAD) == -1) { #ifdef DEBUGASI dumpasi(\"read \", lastaddr, asi, size, ret); #endif return 0; } /* Fall through */ case 0x81: /* Secondary */ case 0x89: /* Secondary LE */ /* XXX */ break; default: break; } /* Convert from little endian */ switch (asi) { case 0x88: /* Primary LE */ case 0x89: /* Secondary LE */ case 0x8a: /* Primary no-fault LE */ case 0x8b: /* Secondary no-fault LE */ switch (size) { case 2: ret = bswap16(ret); break; case 4: ret = bswap32(ret); break; case 8: ret = bswap64(ret); break; default: break; } default: break; } /* Convert to signed number */ if (sign) { switch (size) { case 1: ret = (int8t) ret; break; case 2: ret = (int16t) ret; break; case 4: ret = (int32t) ret; break; default: break; } } #ifdef DEBUGASI dumpasi(\"read \", lastaddr, asi, size, ret); #endif return ret; } ", "target": 1}
{"func": "static avcold int vc2encodeinit(AVCodecContext *avctx) { Plane *p; SubBand *b; int i, j, level, o, shift, ret; const AVPixFmtDescriptor *fmt = avpixfmtdescget(avctx->pixfmt); const int depth = fmt->comp[0].depth; VC2EncContext *s = avctx->privdata; s->picturenumber = 0; /* Total allowed quantization range */ s->qceil = DIRACMAXQUANTINDEX; s->ver.major = 2; s->ver.minor = 0; s->profile = 3; s->level = 3; s->basevf = -1; s->strictcompliance = 1; s->qavg = 0; s->slicemaxbytes = 0; s->sliceminbytes = 0; /* Mark unknown as progressive */ s->interlaced = !((avctx->fieldorder == AVFIELDUNKNOWN) || (avctx->fieldorder == AVFIELDPROGRESSIVE)); for (i = 0; i < basevideofmtslen; i++) { const VC2BaseVideoFormat *fmt = &basevideofmts[i]; if (avctx->pixfmt != fmt->pixfmt) continue; if (avctx->timebase.num != fmt->timebase.num) continue; if (avctx->timebase.den != fmt->timebase.den) continue; if (avctx->width != fmt->width) continue; if (avctx->height != fmt->height) continue; if (s->interlaced != fmt->interlaced) continue; s->basevf = i; s->level = basevideofmts[i].level; break; } if (s->interlaced) avlog(avctx, AVLOGWARNING, \"Interlacing enabled!\\n\"); if ((s->slicewidth & (s->slicewidth - 1)) || (s->sliceheight & (s->sliceheight - 1))) { avlog(avctx, AVLOGERROR, \"Slice size is not a power of two!\\n\"); return AVERRORUNKNOWN; } if ((s->slicewidth > avctx->width) || (s->sliceheight > avctx->height)) { avlog(avctx, AVLOGERROR, \"Slice size is bigger than the image!\\n\"); return AVERRORUNKNOWN; } if (s->basevf <= 0) { if (avctx->strictstdcompliance < FFCOMPLIANCESTRICT) { s->strictcompliance = s->basevf = 0; avlog(avctx, AVLOGWARNING, \"Format does not strictly comply with VC2 specs\\n\"); } else { avlog(avctx, AVLOGWARNING, \"Given format does not strictly comply with \" \"the specifications, decrease strictness to use it.\\n\"); return AVERRORUNKNOWN; } } else { avlog(avctx, AVLOGINFO, \"Selected base video format = %i (%s)\\n\", s->basevf, basevideofmts[s->basevf].name); } /* Chroma subsampling */ ret = avpixfmtgetchromasubsample(avctx->pixfmt, &s->chromaxshift, &s->chromayshift); if (ret) return ret; /* Bit depth and color range index */ if (depth == 8 && avctx->colorrange == AVCOLRANGEJPEG) { s->bpp = 1; s->bppidx = 1; s->diffoffset = 128; } else if (depth == 8 && (avctx->colorrange == AVCOLRANGEMPEG || avctx->colorrange == AVCOLRANGEUNSPECIFIED)) { s->bpp = 1; s->bppidx = 2; s->diffoffset = 128; } else if (depth == 10) { s->bpp = 2; s->bppidx = 3; s->diffoffset = 512; } else { s->bpp = 2; s->bppidx = 4; s->diffoffset = 2048; } /* Planes initialization */ for (i = 0; i < 3; i++) { int w, h; p = &s->plane[i]; p->width = avctx->width >> (i ? s->chromaxshift : 0); p->height = avctx->height >> (i ? s->chromayshift : 0); if (s->interlaced) p->height >>= 1; p->dwtwidth = w = FFALIGN(p->width, (1 << s->waveletdepth)); p->dwtheight = h = FFALIGN(p->height, (1 << s->waveletdepth)); p->coefstride = FFALIGN(p->dwtwidth, 32); p->coefbuf = avmalloc(p->coefstride*p->dwtheight*sizeof(dwtcoef)); if (!p->coefbuf) goto allocfail; for (level = s->waveletdepth-1; level >= 0; level--) { w = w >> 1; h = h >> 1; for (o = 0; o < 4; o++) { b = &p->band[level][o]; b->width = w; b->height = h; b->stride = p->coefstride; shift = (o > 1)*b->height*b->stride + (o & 1)*b->width; b->buf = p->coefbuf + shift; } } /* DWT init */ if (ffvc2encinittransforms(&s->transformargs[i].t, s->plane[i].coefstride, s->plane[i].dwtheight)) goto allocfail; } /* Slices */ s->numx = s->plane[0].dwtwidth/s->slicewidth; s->numy = s->plane[0].dwtheight/s->sliceheight; s->sliceargs = avcalloc(s->numx*s->numy, sizeof(SliceArgs)); if (!s->sliceargs) goto allocfail; /* Lookup tables */ s->coeflutlen = avmalloc(COEFLUTTAB*(s->qceil+1)*sizeof(*s->coeflutlen)); if (!s->coeflutlen) goto allocfail; s->coeflutval = avmalloc(COEFLUTTAB*(s->qceil+1)*sizeof(*s->coeflutval)); if (!s->coeflutval) goto allocfail; for (i = 0; i < s->qceil; i++) { uint8t *lenlut = &s->coeflutlen[i*COEFLUTTAB]; uint32t *vallut = &s->coeflutval[i*COEFLUTTAB]; for (j = 0; j < COEFLUTTAB; j++) { getvc2ueuint(QUANT(j, ffdiracqscaletab[i]), &lenlut[j], &vallut[j]); if (lenlut[j] != 1) { lenlut[j] += 1; vallut[j] <<= 1; } else { vallut[j] = 1; } } } return 0; allocfail: vc2encodeend(avctx); avlog(avctx, AVLOGERROR, \"Unable to allocate memory!\\n\"); return AVERROR(ENOMEM); } ", "target": 1}
{"func": "static avcold int rv40decodeinit(AVCodecContext *avctx) { RV34DecContext *r = avctx->privdata; r->rv30 = 0; ffrv34decodeinit(avctx); if(!aictopvlc.bits) rv40inittables(); r->parsesliceheader = rv40parsesliceheader; r->decodeintratypes = rv40decodeintratypes; r->decodembinfo = rv40decodembinfo; r->loopfilter = rv40loopfilter; r->lumadcquanti = rv40lumadcquant[0]; r->lumadcquantp = rv40lumadcquant[1]; return 0; } ", "target": 1}
{"func": "static void sprwritedbatuh (void *opaque, int sprn) { DisasContext *ctx = opaque; genopstoredbatu((sprn - SPRDBAT4U) / 2); RETSTOP(ctx); } ", "target": 0}
{"func": "sprintflen(char *string, const char *format, ...) #else sprintflen(vaalist) vadcl #endif { \tvalist args; #ifdef STDC \tvastart(args, format); #else \tchar *string; \tchar *format; \tvastart(args); \tstring = vaarg(args, char *); \tformat = vaarg(args, char *); #endif \tvsprintf(string, format, args); \treturn strlen(string); } ", "target": 0}
{"func": "static int extractextradatah2645(AVBSFContext *ctx, AVPacket *pkt, uint8t **data, int *size) { static const int extradatanaltypeshevc[] = { HEVCNALVPS, HEVCNALSPS, HEVCNALPPS, }; static const int extradatanaltypesh264[] = { H264NALSPS, H264NALPPS, }; ExtractExtradataContext *s = ctx->privdata; H2645Packet h2645pkt = { 0 }; int extradatasize = 0; const int *extradatanaltypes; int nbextradatanaltypes; int i, hassps = 0, hasvps = 0, ret = 0; if (ctx->parin->codecid == AVCODECIDHEVC) { extradatanaltypes = extradatanaltypeshevc; nbextradatanaltypes = FFARRAYELEMS(extradatanaltypeshevc); } else { extradatanaltypes = extradatanaltypesh264; nbextradatanaltypes = FFARRAYELEMS(extradatanaltypesh264); } ret = ffh2645packetsplit(&h2645pkt, pkt->data, pkt->size, ctx, 0, 0, ctx->parin->codecid, 1); if (ret < 0) return ret; for (i = 0; i < h2645pkt.nbnals; i++) { H2645NAL *nal = &h2645pkt.nals[i]; if (valinarray(extradatanaltypes, nbextradatanaltypes, nal->type)) { extradatasize += nal->rawsize + 3; if (ctx->parin->codecid == AVCODECIDHEVC) { if (nal->type == HEVCNALSPS) hassps = 1; if (nal->type == HEVCNALVPS) hasvps = 1; } else { if (nal->type == H264NALSPS) hassps = 1; } } } if (extradatasize && ((ctx->parin->codecid == AVCODECIDHEVC && hassps && hasvps) || (ctx->parin->codecid == AVCODECIDH264 && hassps))) { AVBufferRef *filteredbuf; uint8t *extradata, *filtereddata; if (s->remove) { filteredbuf = avbufferalloc(pkt->size + AVINPUTBUFFERPADDINGSIZE); if (!filteredbuf) { ret = AVERROR(ENOMEM); goto fail; } filtereddata = filteredbuf->data; } extradata = avmalloc(extradatasize + AVINPUTBUFFERPADDINGSIZE); if (!extradata) { avbufferunref(&filteredbuf); ret = AVERROR(ENOMEM); goto fail; } *data = extradata; *size = extradatasize; for (i = 0; i < h2645pkt.nbnals; i++) { H2645NAL *nal = &h2645pkt.nals[i]; if (valinarray(extradatanaltypes, nbextradatanaltypes, nal->type)) { AVWB24(extradata, 1); // startcode memcpy(extradata + 3, nal->rawdata, nal->rawsize); extradata += 3 + nal->rawsize; } else if (s->remove) { AVWB24(filtereddata, 1); // startcode memcpy(filtereddata + 3, nal->rawdata, nal->rawsize); filtereddata += 3 + nal->rawsize; } } if (s->remove) { avbufferunref(&pkt->buf); pkt->buf = filteredbuf; pkt->data = filteredbuf->data; pkt->size = filtereddata - filteredbuf->data; } } fail: ffh2645packetuninit(&h2645pkt); return ret; } ", "target": 1}
{"func": "static void FUNC(puthevcepelbiwh)(uint8t *dst, ptrdifft dststride, uint8t *src, ptrdifft srcstride, int16t *src2, int height, int denom, int wx0, int wx1, int ox0, int ox1, intptrt mx, intptrt my, int width) { int x, y; pixel *src = (pixel *)src; ptrdifft srcstride = srcstride / sizeof(pixel); pixel *dst = (pixel *)dst; ptrdifft dststride = dststride / sizeof(pixel); const int8t *filter = ffhevcepelfilters[mx - 1]; int shift = 14 + 1 - BITDEPTH; int log2Wd = denom + shift - 1; ox0 = ox0 * (1 << (BITDEPTH - 8)); ox1 = ox1 * (1 << (BITDEPTH - 8)); for (y = 0; y < height; y++) { for (x = 0; x < width; x++) dst[x] = avclippixel(((EPELFILTER(src, 1) >> (BITDEPTH - 8)) * wx1 + src2[x] * wx0 + ((ox0 + ox1 + 1) << log2Wd)) >> (log2Wd + 1)); src += srcstride; dst += dststride; src2 += MAXPBSIZE; } } ", "target": 1}
{"func": "void sdl2glscanout(DisplayChangeListener *dcl, uint32t backingid, bool backingy0top, uint32t x, uint32t y, uint32t w, uint32t h) { struct sdl2console *scon = containerof(dcl, struct sdl2console, dcl); assert(scon->opengl); scon->x = x; scon->y = y; scon->w = w; scon->h = h; scon->texid = backingid; scon->y0top = backingy0top; SDLGLMakeCurrent(scon->realwindow, scon->winctx); if (scon->texid == 0 || scon->w == 0 || scon->h == 0) { sdl2setscanoutmode(scon, false); return; } sdl2setscanoutmode(scon, true); if (!scon->fboid) { glGenFramebuffers(1, &scon->fboid); } glBindFramebuffer(GLFRAMEBUFFEREXT, scon->fboid); glFramebufferTexture2DEXT(GLFRAMEBUFFEREXT, GLCOLORATTACHMENT0EXT, GLTEXTURE2D, scon->texid, 0); }", "target": 1}
{"func": "static void mmstoptimer(struct qemualarmtimer *t) { timeKillEvent(mmtimer); timeEndPeriod(mmperiod); } ", "target": 1}
{"func": "static void tcgoutqemust(TCGContext *s, TCGReg data, TCGReg addr, TCGMemOpIdx oi) { TCGMemOp memop = getmemop(oi); #ifdef CONFIGSOFTMMU unsigned memi = getmmuidx(oi); TCGReg addrz, param; tcginsnunit *func; tcginsnunit *labelptr; addrz = tcgouttlbload(s, addr, memi, memop, offsetof(CPUTLBEntry, addrwrite)); /* The fast path is exactly one insn. Thus we can perform the entire TLB Hit in the (annulled) delay slot of the branch over TLB Miss. */ /* beq,a,pt %[xi]cc, label0 */ labelptr = s->codeptr; tcgoutbpcc0(s, CONDE, BPCCA | BPCCPT | (TARGETLONGBITS == 64 ? BPCCXCC : BPCCICC), 0); /* delay slot */ tcgoutldstrr(s, data, addrz, TCGREGO1, qemustopc[memop & (MOBSWAP | MOSIZE)]); /* TLB Miss. */ param = TCGREGO1; if (!SPARC64 && TARGETLONGBITS == 64) { /* Skip the high-part; we'll perform the extract in the trampoline. */ param++; } tcgoutmov(s, TCGTYPEREG, param++, addr); if (!SPARC64 && (memop & MOSIZE) == MO64) { /* Skip the high-part; we'll perform the extract in the trampoline. */ param++; } tcgoutmov(s, TCGTYPEREG, param++, data); func = qemusttrampoline[memop & (MOBSWAP | MOSIZE)]; tcgdebugassert(func != NULL); tcgoutcallnodelay(s, func); /* delay slot */ tcgoutmovi(s, TCGTYPEI32, param, oi); *labelptr |= INSNOFF19(tcgptrbytediff(s->codeptr, labelptr)); #else if (SPARC64 && TARGETLONGBITS == 32) { tcgoutarithi(s, TCGREGT1, addr, 0, SHIFTSRL); addr = TCGREGT1; } tcgoutldstrr(s, data, addr, (guestbase ? TCGGUESTBASEREG : TCGREGG0), qemustopc[memop & (MOBSWAP | MOSIZE)]); #endif /* CONFIGSOFTMMU */ } ", "target": 1}
{"func": "QEMUFile *qemufopenfd(int fd) { QEMUFileFD *s = qemumallocz(sizeof(QEMUFileFD)); if (s == NULL) return NULL; s->fd = fd; s->file = qemufopenops(s, fdputbuffer, fdgetbuffer, fdclose, NULL); return s->file; } ", "target": 0}
{"func": "static void predspatialdirectmotion(const H264Context *const h, H264SliceContext *sl, int *mbtype) { int b8stride = 2; int b4stride = h->bstride; int mbxy = sl->mbxy, mby = sl->mby; int mbtypecol[2]; const int16t (*l1mv0)[2], (*l1mv1)[2]; const int8t *l1ref0, *l1ref1; const int isb8x8 = IS8X8(*mbtype); unsigned int submbtype = MBTYPEL0L1; int i8, i4; int ref[2]; int mv[2]; int list; assert(sl->reflist[1][0].reference & 3); awaitreferencembrow(h, sl->reflist[1][0].parent, sl->mby + !!ISINTERLACED(*mbtype)); #define MBTYPE16x16ORINTRA (MBTYPE16x16 | MBTYPEINTRA4x4 | \\ MBTYPEINTRA16x16 | MBTYPEINTRAPCM) /* ref = min(neighbors) */ for (list = 0; list < 2; list++) { int leftref = sl->refcache[list][scan8[0] - 1]; int topref = sl->refcache[list][scan8[0] - 8]; int refc = sl->refcache[list][scan8[0] - 8 + 4]; const int16t *C = sl->mvcache[list][scan8[0] - 8 + 4]; if (refc == PARTNOTAVAILABLE) { refc = sl->refcache[list][scan8[0] - 8 - 1]; C = sl->mvcache[list][scan8[0] - 8 - 1]; } ref[list] = FFMIN3((unsigned)leftref, (unsigned)topref, (unsigned)refc); if (ref[list] >= 0) { /* This is just predmotion() but with the cases removed that * cannot happen for direct blocks. */ const int16t *const A = sl->mvcache[list][scan8[0] - 1]; const int16t *const B = sl->mvcache[list][scan8[0] - 8]; int matchcount = (leftref == ref[list]) + (topref == ref[list]) + (refc == ref[list]); if (matchcount > 1) { // most common mv[list] = pack16to32(midpred(A[0], B[0], C[0]), midpred(A[1], B[1], C[1])); } else { assert(matchcount == 1); if (leftref == ref[list]) mv[list] = AVRN32A(A); else if (topref == ref[list]) mv[list] = AVRN32A(B); else mv[list] = AVRN32A(C); } } else { int mask = ~(MBTYPEL0 << (2 * list)); mv[list] = 0; ref[list] = -1; if (!isb8x8) *mbtype &= mask; submbtype &= mask; } } if (ref[0] < 0 && ref[1] < 0) { ref[0] = ref[1] = 0; if (!isb8x8) *mbtype |= MBTYPEL0L1; submbtype |= MBTYPEL0L1; } if (!(isb8x8 | mv[0] | mv[1])) { fillrectangle(&sl->refcache[0][scan8[0]], 4, 4, 8, (uint8t)ref[0], 1); fillrectangle(&sl->refcache[1][scan8[0]], 4, 4, 8, (uint8t)ref[1], 1); fillrectangle(&sl->mvcache[0][scan8[0]], 4, 4, 8, 0, 4); fillrectangle(&sl->mvcache[1][scan8[0]], 4, 4, 8, 0, 4); *mbtype = (*mbtype & ~(MBTYPE8x8 | MBTYPE16x8 | MBTYPE8x16 | MBTYPEP1L0 | MBTYPEP1L1)) | MBTYPE16x16 | MBTYPEDIRECT2; return; } if (ISINTERLACED(sl->reflist[1][0].parent->mbtype[mbxy])) { // AFL/AFR/FR/FL -> AFL/FL if (!ISINTERLACED(*mbtype)) { // AFR/FR -> AFL/FL mby = (sl->mby & ~1) + sl->colparity; mbxy = sl->mbx + ((sl->mby & ~1) + sl->colparity) * h->mbstride; b8stride = 0; } else { mby += sl->colfieldoff; mbxy += h->mbstride * sl->colfieldoff; // non-zero for FL -> FL & differ parity } goto singlecol; } else { // AFL/AFR/FR/FL -> AFR/FR if (ISINTERLACED(*mbtype)) { // AFL /FL -> AFR/FR mby = sl->mby & ~1; mbxy = (sl->mby & ~1) * h->mbstride + sl->mbx; mbtypecol[0] = sl->reflist[1][0].parent->mbtype[mbxy]; mbtypecol[1] = sl->reflist[1][0].parent->mbtype[mbxy + h->mbstride]; b8stride = 2 + 4 * h->mbstride; b4stride *= 6; if (ISINTERLACED(mbtypecol[0]) != ISINTERLACED(mbtypecol[1])) { mbtypecol[0] &= ~MBTYPEINTERLACED; mbtypecol[1] &= ~MBTYPEINTERLACED; } submbtype |= MBTYPE16x16 | MBTYPEDIRECT2; /* BSUB8x8 */ if ((mbtypecol[0] & MBTYPE16x16ORINTRA) && (mbtypecol[1] & MBTYPE16x16ORINTRA) && !isb8x8) { *mbtype |= MBTYPE16x8 | MBTYPEDIRECT2; /* B16x8 */ } else { *mbtype |= MBTYPE8x8; } } else { // AFR/FR -> AFR/FR singlecol: mbtypecol[0] = mbtypecol[1] = sl->reflist[1][0].parent->mbtype[mbxy]; submbtype |= MBTYPE16x16 | MBTYPEDIRECT2; /* BSUB8x8 */ if (!isb8x8 && (mbtypecol[0] & MBTYPE16x16ORINTRA)) { *mbtype |= MBTYPE16x16 | MBTYPEDIRECT2; /* B16x16 */ } else if (!isb8x8 && (mbtypecol[0] & (MBTYPE16x8 | MBTYPE8x16))) { *mbtype |= MBTYPEDIRECT2 | (mbtypecol[0] & (MBTYPE16x8 | MBTYPE8x16)); } else { if (!h->ps.sps->direct8x8inferenceflag) { /* FIXME: Save sub mb types from previous frames (or derive * from MVs) so we know exactly what block size to use. */ submbtype += (MBTYPE8x8 - MBTYPE16x16); /* BSUB4x4 */ } *mbtype |= MBTYPE8x8; } } } awaitreferencembrow(h, sl->reflist[1][0].parent, mby); l1mv0 = &sl->reflist[1][0].parent->motionval[0][h->mb2bxy[mbxy]]; l1mv1 = &sl->reflist[1][0].parent->motionval[1][h->mb2bxy[mbxy]]; l1ref0 = &sl->reflist[1][0].parent->refindex[0][4 * mbxy]; l1ref1 = &sl->reflist[1][0].parent->refindex[1][4 * mbxy]; if (!b8stride) { if (sl->mby & 1) { l1ref0 += 2; l1ref1 += 2; l1mv0 += 2 * b4stride; l1mv1 += 2 * b4stride; } } if (ISINTERLACED(*mbtype) != ISINTERLACED(mbtypecol[0])) { int n = 0; for (i8 = 0; i8 < 4; i8++) { int x8 = i8 & 1; int y8 = i8 >> 1; int xy8 = x8 + y8 * b8stride; int xy4 = x8 * 3 + y8 * b4stride; int a, b; if (isb8x8 && !ISDIRECT(sl->submbtype[i8])) continue; sl->submbtype[i8] = submbtype; fillrectangle(&sl->refcache[0][scan8[i8 * 4]], 2, 2, 8, (uint8t)ref[0], 1); fillrectangle(&sl->refcache[1][scan8[i8 * 4]], 2, 2, 8, (uint8t)ref[1], 1); if (!ISINTRA(mbtypecol[y8]) && !sl->reflist[1][0].parent->longref && ((l1ref0[xy8] == 0 && FFABS(l1mv0[xy4][0]) <= 1 && FFABS(l1mv0[xy4][1]) <= 1) || (l1ref0[xy8] < 0 && l1ref1[xy8] == 0 && FFABS(l1mv1[xy4][0]) <= 1 && FFABS(l1mv1[xy4][1]) <= 1))) { a = b = 0; if (ref[0] > 0) a = mv[0]; if (ref[1] > 0) b = mv[1]; n++; } else { a = mv[0]; b = mv[1]; } fillrectangle(&sl->mvcache[0][scan8[i8 * 4]], 2, 2, 8, a, 4); fillrectangle(&sl->mvcache[1][scan8[i8 * 4]], 2, 2, 8, b, 4); } if (!isb8x8 && !(n & 3)) *mbtype = (*mbtype & ~(MBTYPE8x8 | MBTYPE16x8 | MBTYPE8x16 | MBTYPEP1L0 | MBTYPEP1L1)) | MBTYPE16x16 | MBTYPEDIRECT2; } else if (IS16X16(*mbtype)) { int a, b; fillrectangle(&sl->refcache[0][scan8[0]], 4, 4, 8, (uint8t)ref[0], 1); fillrectangle(&sl->refcache[1][scan8[0]], 4, 4, 8, (uint8t)ref[1], 1); if (!ISINTRA(mbtypecol[0]) && !sl->reflist[1][0].parent->longref && ((l1ref0[0] == 0 && FFABS(l1mv0[0][0]) <= 1 && FFABS(l1mv0[0][1]) <= 1) || (l1ref0[0] < 0 && !l1ref1[0] && FFABS(l1mv1[0][0]) <= 1 && FFABS(l1mv1[0][1]) <= 1 && h->sei.unregistered.x264build > 33U))) { a = b = 0; if (ref[0] > 0) a = mv[0]; if (ref[1] > 0) b = mv[1]; } else { a = mv[0]; b = mv[1]; } fillrectangle(&sl->mvcache[0][scan8[0]], 4, 4, 8, a, 4); fillrectangle(&sl->mvcache[1][scan8[0]], 4, 4, 8, b, 4); } else { int n = 0; for (i8 = 0; i8 < 4; i8++) { const int x8 = i8 & 1; const int y8 = i8 >> 1; if (isb8x8 && !ISDIRECT(sl->submbtype[i8])) continue; sl->submbtype[i8] = submbtype; fillrectangle(&sl->mvcache[0][scan8[i8 * 4]], 2, 2, 8, mv[0], 4); fillrectangle(&sl->mvcache[1][scan8[i8 * 4]], 2, 2, 8, mv[1], 4); fillrectangle(&sl->refcache[0][scan8[i8 * 4]], 2, 2, 8, (uint8t)ref[0], 1); fillrectangle(&sl->refcache[1][scan8[i8 * 4]], 2, 2, 8, (uint8t)ref[1], 1); assert(b8stride == 2); /* colzeroflag */ if (!ISINTRA(mbtypecol[0]) && !sl->reflist[1][0].parent->longref && (l1ref0[i8] == 0 || (l1ref0[i8] < 0 && l1ref1[i8] == 0 && h->sei.unregistered.x264build > 33U))) { const int16t (*l1mv)[2] = l1ref0[i8] == 0 ? l1mv0 : l1mv1; if (ISSUB8X8(submbtype)) { const int16t *mvcol = l1mv[x8 * 3 + y8 * 3 * b4stride]; if (FFABS(mvcol[0]) <= 1 && FFABS(mvcol[1]) <= 1) { if (ref[0] == 0) fillrectangle(&sl->mvcache[0][scan8[i8 * 4]], 2, 2, 8, 0, 4); if (ref[1] == 0) fillrectangle(&sl->mvcache[1][scan8[i8 * 4]], 2, 2, 8, 0, 4); n += 4; } } else { int m = 0; for (i4 = 0; i4 < 4; i4++) { const int16t *mvcol = l1mv[x8 * 2 + (i4 & 1) + (y8 * 2 + (i4 >> 1)) * b4stride]; if (FFABS(mvcol[0]) <= 1 && FFABS(mvcol[1]) <= 1) { if (ref[0] == 0) AVZERO32(sl->mvcache[0][scan8[i8 * 4 + i4]]); if (ref[1] == 0) AVZERO32(sl->mvcache[1][scan8[i8 * 4 + i4]]); m++; } } if (!(m & 3)) sl->submbtype[i8] += MBTYPE16x16 - MBTYPE8x8; n += m; } } } if (!isb8x8 && !(n & 15)) *mbtype = (*mbtype & ~(MBTYPE8x8 | MBTYPE16x8 | MBTYPE8x16 | MBTYPEP1L0 | MBTYPEP1L1)) | MBTYPE16x16 | MBTYPEDIRECT2; } } ", "target": 1}
{"func": "static void bostonlcdevent(void *opaque, int event) { BostonState *s = opaque; if (event == CHREVENTOPENED && !s->lcdinited) { qemuchrfeprintf(&s->lcddisplay, \" \"); s->lcdinited = true; } } ", "target": 1}
{"func": "void addcommand(const cmdinfot *ci) { cmdtab = realloc((void *)cmdtab, ++ncmds * sizeof(*cmdtab)); cmdtab[ncmds - 1] = *ci; qsort(cmdtab, ncmds, sizeof(*cmdtab), compare); } ", "target": 1}
{"func": "static void openpicupdateirq(OpenPICState *opp, int nIRQ) { IRQsrct *src; int i; src = &opp->src[nIRQ]; if (!src->pending) { /* no irq pending */ DPRINTF(\"%s: IRQ %d is not pending\\n\", func, nIRQ); return; } if (src->ipvp & IPVPMASKMASK) { /* Interrupt source is disabled */ DPRINTF(\"%s: IRQ %d is disabled\\n\", func, nIRQ); return; } if (IPVPPRIORITY(src->ipvp) == 0) { /* Priority set to zero */ DPRINTF(\"%s: IRQ %d has 0 priority\\n\", func, nIRQ); return; } if (src->ipvp & IPVPACTIVITYMASK) { /* IRQ already active */ DPRINTF(\"%s: IRQ %d is already active\\n\", func, nIRQ); return; } if (src->ide == 0) { /* No target */ DPRINTF(\"%s: IRQ %d has no target\\n\", func, nIRQ); return; } if (src->ide == (1 << src->lastcpu)) { /* Only one CPU is allowed to receive this IRQ */ IRQlocalpipe(opp, src->lastcpu, nIRQ); } else if (!(src->ipvp & IPVPMODEMASK)) { /* Directed delivery mode */ for (i = 0; i < opp->nbcpus; i++) { if (src->ide & (1 << i)) { IRQlocalpipe(opp, i, nIRQ); } } } else { /* Distributed delivery mode */ for (i = src->lastcpu + 1; i != src->lastcpu; i++) { if (i == opp->nbcpus) i = 0; if (src->ide & (1 << i)) { IRQlocalpipe(opp, i, nIRQ); src->lastcpu = i; break; } } } } ", "target": 1}
{"func": "static inline void usbbtfifooutenqueue(struct USBBtState *s, struct usbhcioutfifos *fifo, void (*send)(struct HCIInfo *, const uint8t *, int), int (*complete)(const uint8t *, int), const uint8t *data, int len) { if (fifo->len) { memcpy(fifo->data + fifo->len, data, len); fifo->len += len; if (complete(fifo->data, fifo->len)) { send(s->hci, fifo->data, fifo->len); fifo->len = 0; } } else if (complete(data, len)) send(s->hci, data, len); else { memcpy(fifo->data, data, len); fifo->len = len; } /* TODO: do we need to loop? */ } ", "target": 1}
{"func": "static void computestatus(HTTPContext *c) { HTTPContext *c1; FFStream *stream; char *p; timet ti; int i, len; AVIOContext *pb; if (avioopendynbuf(&pb) < 0) { /* XXX: return an error ? */ c->bufferptr = c->buffer; c->bufferend = c->buffer; return; } avioprintf(pb, \"HTTP/1.0 200 OK\\r\\n\"); avioprintf(pb, \"Content-type: %s\\r\\n\", \"text/html\"); avioprintf(pb, \"Pragma: no-cache\\r\\n\"); avioprintf(pb, \"\\r\\n\"); avioprintf(pb, \"<html><head><title>%s Status</title>\\n\", programname); if (c->stream->feedfilename[0]) avioprintf(pb, \"<link rel=\\\"shortcut icon\\\" href=\\\"%s\\\">\\n\", c->stream->feedfilename); avioprintf(pb, \"</head>\\n<body>\"); avioprintf(pb, \"<h1>%s Status</h1>\\n\", programname); /* format status */ avioprintf(pb, \"<h2>Available Streams</h2>\\n\"); avioprintf(pb, \"<table cellspacing=0 cellpadding=4>\\n\"); avioprintf(pb, \"<tr><th valign=top>Path<th align=left>Served<br>Conns<th><br>bytes<th valign=top>Format<th>Bit rate<br>kbits/s<th align=left>Video<br>kbits/s<th><br>Codec<th align=left>Audio<br>kbits/s<th><br>Codec<th align=left valign=top>Feed\\n\"); stream = firststream; while (stream != NULL) { char sfilename[1024]; char *eosf; if (stream->feed != stream) { avstrlcpy(sfilename, stream->filename, sizeof(sfilename) - 10); eosf = sfilename + strlen(sfilename); if (eosf - sfilename >= 4) { if (strcmp(eosf - 4, \".asf\") == 0) strcpy(eosf - 4, \".asx\"); else if (strcmp(eosf - 3, \".rm\") == 0) strcpy(eosf - 3, \".ram\"); else if (stream->fmt && !strcmp(stream->fmt->name, \"rtp\")) { /* generate a sample RTSP director if unicast. Generate an SDP redirector if multicast */ eosf = strrchr(sfilename, '.'); if (!eosf) eosf = sfilename + strlen(sfilename); if (stream->ismulticast) strcpy(eosf, \".sdp\"); else strcpy(eosf, \".rtsp\"); } } avioprintf(pb, \"<tr><td><a href=\\\"/%s\\\">%s</a> \", sfilename, stream->filename); avioprintf(pb, \"<td align=right> %d <td align=right> \", stream->connsserved); fmtbytecount(pb, stream->bytesserved); switch(stream->streamtype) { case STREAMTYPELIVE: { int audiobitrate = 0; int videobitrate = 0; const char *audiocodecname = \"\"; const char *videocodecname = \"\"; const char *audiocodecnameextra = \"\"; const char *videocodecnameextra = \"\"; for(i=0;i<stream->nbstreams;i++) { AVStream *st = stream->streams[i]; AVCodec *codec = avcodecfindencoder(st->codec->codecid); switch(st->codec->codectype) { case AVMEDIATYPEAUDIO: audiobitrate += st->codec->bitrate; if (codec) { if (*audiocodecname) audiocodecnameextra = \"...\"; audiocodecname = codec->name; } break; case AVMEDIATYPEVIDEO: videobitrate += st->codec->bitrate; if (codec) { if (*videocodecname) videocodecnameextra = \"...\"; videocodecname = codec->name; } break; case AVMEDIATYPEDATA: videobitrate += st->codec->bitrate; break; default: abort(); } } avioprintf(pb, \"<td align=center> %s <td align=right> %d <td align=right> %d <td> %s %s <td align=right> %d <td> %s %s\", stream->fmt->name, stream->bandwidth, videobitrate / 1000, videocodecname, videocodecnameextra, audiobitrate / 1000, audiocodecname, audiocodecnameextra); if (stream->feed) avioprintf(pb, \"<td>%s\", stream->feed->filename); else avioprintf(pb, \"<td>%s\", stream->feedfilename); avioprintf(pb, \"\\n\"); } break; default: avioprintf(pb, \"<td align=center> - <td align=right> - <td align=right> - <td><td align=right> - <td>\\n\"); break; } } stream = stream->next; } avioprintf(pb, \"</table>\\n\"); stream = firststream; while (stream != NULL) { if (stream->feed == stream) { avioprintf(pb, \"<h2>Feed %s</h2>\", stream->filename); if (stream->pid) { avioprintf(pb, \"Running as pid %d.\\n\", stream->pid); #if defined(linux) && !defined(CONFIGNOCUTILS) { FILE *pidstat; char pscmd[64]; /* This is somewhat linux specific I guess */ snprintf(pscmd, sizeof(pscmd), \"ps -o \\\"%%cpu,cputime\\\" --no-headers %d\", stream->pid); pidstat = popen(pscmd, \"r\"); if (pidstat) { char cpuperc[10]; char cpuused[64]; if (fscanf(pidstat, \"%9s %63s\", cpuperc, cpuused) == 2) { avioprintf(pb, \"Currently using %s%% of the cpu. Total time used %s.\\n\", cpuperc, cpuused); } fclose(pidstat); } } #endif avioprintf(pb, \"<p>\"); } avioprintf(pb, \"<table cellspacing=0 cellpadding=4><tr><th>Stream<th>type<th>kbits/s<th align=left>codec<th align=left>Parameters\\n\"); for (i = 0; i < stream->nbstreams; i++) { AVStream *st = stream->streams[i]; AVCodec *codec = avcodecfindencoder(st->codec->codecid); const char *type = \"unknown\"; char parameters[64]; parameters[0] = 0; switch(st->codec->codectype) { case AVMEDIATYPEAUDIO: type = \"audio\"; snprintf(parameters, sizeof(parameters), \"%d channel(s), %d Hz\", st->codec->channels, st->codec->samplerate); break; case AVMEDIATYPEVIDEO: type = \"video\"; snprintf(parameters, sizeof(parameters), \"%dx%d, q=%d-%d, fps=%d\", st->codec->width, st->codec->height, st->codec->qmin, st->codec->qmax, st->codec->timebase.den / st->codec->timebase.num); break; default: abort(); } avioprintf(pb, \"<tr><td align=right>%d<td>%s<td align=right>%d<td>%s<td>%s\\n\", i, type, st->codec->bitrate/1000, codec ? codec->name : \"\", parameters); } avioprintf(pb, \"</table>\\n\"); } stream = stream->next; } /* connection status */ avioprintf(pb, \"<h2>Connection Status</h2>\\n\"); avioprintf(pb, \"Number of connections: %d / %d<br>\\n\", nbconnections, nbmaxconnections); avioprintf(pb, \"Bandwidth in use: %\"PRIu64\"k / %\"PRIu64\"k<br>\\n\", currentbandwidth, maxbandwidth); avioprintf(pb, \"<table>\\n\"); avioprintf(pb, \"<tr><th>#<th>File<th>IP<th>Proto<th>State<th>Target bits/sec<th>Actual bits/sec<th>Bytes transferred\\n\"); c1 = firsthttpctx; i = 0; while (c1 != NULL) { int bitrate; int j; bitrate = 0; if (c1->stream) { for (j = 0; j < c1->stream->nbstreams; j++) { if (!c1->stream->feed) bitrate += c1->stream->streams[j]->codec->bitrate; else if (c1->feedstreams[j] >= 0) bitrate += c1->stream->feed->streams[c1->feedstreams[j]]->codec->bitrate; } } i++; p = inetntoa(c1->fromaddr.sinaddr); avioprintf(pb, \"<tr><td><b>%d</b><td>%s%s<td>%s<td>%s<td>%s<td align=right>\", i, c1->stream ? c1->stream->filename : \"\", c1->state == HTTPSTATERECEIVEDATA ? \"(input)\" : \"\", p, c1->protocol, httpstate[c1->state]); fmtbytecount(pb, bitrate); avioprintf(pb, \"<td align=right>\"); fmtbytecount(pb, computedatarate(&c1->datarate, c1->datacount) * 8); avioprintf(pb, \"<td align=right>\"); fmtbytecount(pb, c1->datacount); avioprintf(pb, \"\\n\"); c1 = c1->next; } avioprintf(pb, \"</table>\\n\"); /* date */ ti = time(NULL); p = ctime(&ti); avioprintf(pb, \"<hr size=1 noshade>Generated at %s\", p); avioprintf(pb, \"</body>\\n</html>\\n\"); len = avioclosedynbuf(pb, &c->pbbuffer); c->bufferptr = c->pbbuffer; c->bufferend = c->pbbuffer + len; } ", "target": 0}
{"func": "static int ramsavecompressedpage(QEMUFile *f, PageSearchStatus *pss, bool laststage, uint64t *bytestransferred) { int pages = -1; uint64t bytesxmit; uint8t *p; int ret; RAMBlock *block = pss->block; ramaddrt offset = pss->offset; p = block->host + offset; bytesxmit = 0; ret = ramcontrolsavepage(f, block->offset, offset, TARGETPAGESIZE, &bytesxmit); if (bytesxmit) { *bytestransferred += bytesxmit; pages = 1; } if (block == lastsentblock) { offset |= RAMSAVEFLAGCONTINUE; } if (ret != RAMSAVECONTROLNOTSUPP) { if (ret != RAMSAVECONTROLDELAYED) { if (bytesxmit > 0) { acctinfo.normpages++; } else if (bytesxmit == 0) { acctinfo.duppages++; } } } else { /* When starting the process of a new block, the first page of * the block should be sent out before other pages in the same * block, and all the pages in last block should have been sent * out, keeping this order is important, because the 'cont' flag * is used to avoid resending the block name. */ if (block != lastsentblock) { flushcompresseddata(f); pages = savezeropage(f, block, offset, p, bytestransferred); if (pages == -1) { setcompressparams(&compparam[0], block, offset); /* Use the qemu thread to compress the data to make sure the * first page is sent out before other pages */ bytesxmit = docompressrampage(&compparam[0]); acctinfo.normpages++; qemuputqemufile(f, compparam[0].file); *bytestransferred += bytesxmit; pages = 1; } } else { pages = savezeropage(f, block, offset, p, bytestransferred); if (pages == -1) { pages = compresspagewithmultithread(f, block, offset, bytestransferred); } } } return pages; } ", "target": 0}
{"func": "void qmpblockstream(bool hasjobid, const char *jobid, const char *device, bool hasbase, const char *base, bool hasbackingfile, const char *backingfile, bool hasspeed, int64t speed, bool hasonerror, BlockdevOnError onerror, Error **errp) { BlockDriverState *bs; BlockDriverState *basebs = NULL; AioContext *aiocontext; Error *localerr = NULL; const char *basename = NULL; if (!hasonerror) { onerror = BLOCKDEVONERRORREPORT; } bs = qmpgetrootbs(device, errp); if (!bs) { return; } aiocontext = bdrvgetaiocontext(bs); aiocontextacquire(aiocontext); if (bdrvopisblocked(bs, BLOCKOPTYPESTREAM, errp)) { goto out; } if (hasbase) { basebs = bdrvfindbackingimage(bs, base); if (basebs == NULL) { errorsetg(errp, QERRBASENOTFOUND, base); goto out; } assert(bdrvgetaiocontext(basebs) == aiocontext); basename = base; } /* if we are streaming the entire chain, the result will have no backing * file, and specifying one is therefore an error */ if (basebs == NULL && hasbackingfile) { errorsetg(errp, \"backing file specified, but streaming the \" \"entire chain\"); goto out; } /* backingfile string overrides base bs filename */ basename = hasbackingfile ? backingfile : basename; streamstart(hasjobid ? jobid : NULL, bs, basebs, basename, hasspeed ? speed : 0, onerror, blockjobcb, bs, &localerr); if (localerr) { errorpropagate(errp, localerr); goto out; } traceqmpblockstream(bs, bs->job); out: aiocontextrelease(aiocontext); } ", "target": 0}
{"func": "int ffdxva2commitbuffer(AVCodecContext *avctx, AVDXVAContext *ctx, DECODERBUFFERDESC *dsc, unsigned type, const void *data, unsigned size, unsigned mbcount) { void *dxvadata; unsigned dxvasize; int result; HRESULT hr; #if CONFIGD3D11VA if (avctx->pixfmt == AVPIXFMTD3D11VAVLD) hr = ID3D11VideoContextGetDecoderBuffer(D3D11VACONTEXT(ctx)->videocontext, D3D11VACONTEXT(ctx)->decoder, type, &dxvasize, &dxvadata); #endif #if CONFIGDXVA2 if (avctx->pixfmt == AVPIXFMTDXVA2VLD) hr = IDirectXVideoDecoderGetBuffer(DXVA2CONTEXT(ctx)->decoder, type, &dxvadata, &dxvasize); #endif if (FAILED(hr)) { avlog(avctx, AVLOGERROR, \"Failed to get a buffer for %u: 0x%x\\n\", type, hr); return -1; } if (size <= dxvasize) { memcpy(dxvadata, data, size); #if CONFIGD3D11VA if (avctx->pixfmt == AVPIXFMTD3D11VAVLD) { D3D11VIDEODECODERBUFFERDESC *dsc11 = dsc; memset(dsc11, 0, sizeof(*dsc11)); dsc11->BufferType = type; dsc11->DataSize = size; dsc11->NumMBsInBuffer = mbcount; } #endif #if CONFIGDXVA2 if (avctx->pixfmt == AVPIXFMTDXVA2VLD) { DXVA2DecodeBufferDesc *dsc2 = dsc; memset(dsc2, 0, sizeof(*dsc2)); dsc2->CompressedBufferType = type; dsc2->DataSize = size; dsc2->NumMBsInBuffer = mbcount; } #endif result = 0; } else { avlog(avctx, AVLOGERROR, \"Buffer for type %u was too small\\n\", type); result = -1; } #if CONFIGD3D11VA if (avctx->pixfmt == AVPIXFMTD3D11VAVLD) hr = ID3D11VideoContextReleaseDecoderBuffer(D3D11VACONTEXT(ctx)->videocontext, D3D11VACONTEXT(ctx)->decoder, type); #endif #if CONFIGDXVA2 if (avctx->pixfmt == AVPIXFMTDXVA2VLD) hr = IDirectXVideoDecoderReleaseBuffer(DXVA2CONTEXT(ctx)->decoder, type); #endif if (FAILED(hr)) { avlog(avctx, AVLOGERROR, \"Failed to release buffer type %u: 0x%x\\n\", type, hr); result = -1; } return result; } ", "target": 0}
{"func": "static int inetlistensaddr(InetSocketAddress *saddr, int portoffset, bool updateaddr, Error **errp) { struct addrinfo ai,*res,*e; char port[33]; char uaddr[INET6ADDRSTRLEN+1]; char uport[33]; int slisten, rc, portmin, portmax, p; Error *err = NULL; memset(&ai,0, sizeof(ai)); ai.aiflags = AIPASSIVE; if (saddr->hasnumeric && saddr->numeric) { ai.aiflags |= AINUMERICHOST | AINUMERICSERV; } ai.aifamily = inetaifamilyfromaddress(saddr, &err); ai.aisocktype = SOCKSTREAM; if (err) { errorpropagate(errp, err); return -1; } if (saddr->host == NULL) { errorsetg(errp, \"host not specified\"); return -1; } if (saddr->port != NULL) { pstrcpy(port, sizeof(port), saddr->port); } else { port[0] = '\\0'; } /* lookup */ if (portoffset) { unsigned long long baseport; if (strlen(port) == 0) { errorsetg(errp, \"port not specified\"); return -1; } if (parseuintfull(port, &baseport, 10) < 0) { errorsetg(errp, \"can't convert to a number: %s\", port); return -1; } if (baseport > 65535 || baseport + portoffset > 65535) { errorsetg(errp, \"port %s out of range\", port); return -1; } snprintf(port, sizeof(port), \"%d\", (int)baseport + portoffset); } rc = getaddrinfo(strlen(saddr->host) ? saddr->host : NULL, strlen(port) ? port : NULL, &ai, &res); if (rc != 0) { errorsetg(errp, \"address resolution failed for %s:%s: %s\", saddr->host, port, gaistrerror(rc)); return -1; } /* create socket + bind */ for (e = res; e != NULL; e = e->ainext) { getnameinfo((struct sockaddr*)e->aiaddr,e->aiaddrlen, \t\t uaddr,INET6ADDRSTRLEN,uport,32, \t\t NINUMERICHOST | NINUMERICSERV); slisten = qemusocket(e->aifamily, e->aisocktype, e->aiprotocol); if (slisten < 0) { if (!e->ainext) { errorsetgerrno(errp, errno, \"Failed to create socket\"); } continue; } socketsetfastreuse(slisten); portmin = inetgetport(e); portmax = saddr->hasto ? saddr->to + portoffset : portmin; for (p = portmin; p <= portmax; p++) { inetsetport(e, p); if (trybind(slisten, saddr, e) >= 0) { goto listen; } if (p == portmax) { if (!e->ainext) { errorsetgerrno(errp, errno, \"Failed to bind socket\"); } } } closesocket(slisten); } freeaddrinfo(res); return -1; listen: if (listen(slisten,1) != 0) { errorsetgerrno(errp, errno, \"Failed to listen on socket\"); closesocket(slisten); freeaddrinfo(res); return -1; } if (updateaddr) { gfree(saddr->host); saddr->host = gstrdup(uaddr); gfree(saddr->port); saddr->port = gstrdupprintf(\"%d\", inetgetport(e) - portoffset); saddr->hasipv6 = saddr->ipv6 = e->aifamily == PFINET6; saddr->hasipv4 = saddr->ipv4 = e->aifamily != PFINET6; } freeaddrinfo(res); return slisten; } ", "target": 0}
{"func": "static int movreadares(MOVContext *c, AVIOContext *pb, MOVAtom atom) { AVCodecContext *codec = c->fc->streams[c->fc->nbstreams-1]->codec; if (codec->codectag == MKTAG('A', 'V', 'i', 'n') && codec->codecid == AVCODECIDH264 && atom.size > 11) { avioskip(pb, 10); /* For AVID AVCI50, force width of 1440 to be able to select the correct SPS and PPS */ if (aviorb16(pb) == 0xd4d) codec->width = 1440; return 0; } return movreadavid(c, pb, atom); } ", "target": 0}
{"func": "void vmstateunregister(const VMStateDescription *vmsd, void *opaque) { SaveStateEntry *se, *newse; TAILQFOREACHSAFE(se, &savevmhandlers, entry, newse) { if (se->vmsd == vmsd && se->opaque == opaque) { TAILQREMOVE(&savevmhandlers, se, entry); qemufree(se); } } } ", "target": 0}
{"func": "static int virtionethandlemac(VirtIONet *n, uint8t cmd, struct iovec *iov, unsigned int iovcnt) { struct virtionetctrlmac macdata; sizet s; NetClientState *nc = qemugetqueue(n->nic); if (cmd == VIRTIONETCTRLMACADDRSET) { if (iovsize(iov, iovcnt) != sizeof(n->mac)) { return VIRTIONETERR; } s = iovtobuf(iov, iovcnt, 0, &n->mac, sizeof(n->mac)); assert(s == sizeof(n->mac)); qemuformatnicinfostr(qemugetqueue(n->nic), n->mac); rxfilternotify(nc); return VIRTIONETOK; } if (cmd != VIRTIONETCTRLMACTABLESET) { return VIRTIONETERR; } int inuse = 0; int firstmulti = 0; uint8t unioverflow = 0; uint8t multioverflow = 0; uint8t *macs = gmalloc0(MACTABLEENTRIES * ETHALEN); s = iovtobuf(iov, iovcnt, 0, &macdata.entries, sizeof(macdata.entries)); macdata.entries = ldlp(&macdata.entries); if (s != sizeof(macdata.entries)) { goto error; } iovdiscardfront(&iov, &iovcnt, s); if (macdata.entries * ETHALEN > iovsize(iov, iovcnt)) { goto error; } if (macdata.entries <= MACTABLEENTRIES) { s = iovtobuf(iov, iovcnt, 0, macs, macdata.entries * ETHALEN); if (s != macdata.entries * ETHALEN) { goto error; } inuse += macdata.entries; } else { unioverflow = 1; } iovdiscardfront(&iov, &iovcnt, macdata.entries * ETHALEN); firstmulti = inuse; s = iovtobuf(iov, iovcnt, 0, &macdata.entries, sizeof(macdata.entries)); macdata.entries = ldlp(&macdata.entries); if (s != sizeof(macdata.entries)) { goto error; } iovdiscardfront(&iov, &iovcnt, s); if (macdata.entries * ETHALEN != iovsize(iov, iovcnt)) { goto error; } if (inuse + macdata.entries <= MACTABLEENTRIES) { s = iovtobuf(iov, iovcnt, 0, &macs[inuse * ETHALEN], macdata.entries * ETHALEN); if (s != macdata.entries * ETHALEN) { goto error; } inuse += macdata.entries; } else { multioverflow = 1; } n->mactable.inuse = inuse; n->mactable.firstmulti = firstmulti; n->mactable.unioverflow = unioverflow; n->mactable.multioverflow = multioverflow; memcpy(n->mactable.macs, macs, MACTABLEENTRIES * ETHALEN); gfree(macs); rxfilternotify(nc); return VIRTIONETOK; error: gfree(macs); return VIRTIONETERR; } ", "target": 1}
{"func": "static avcold int ffmmalinitdecoder(AVCodecContext *avctx) { MMALDecodeContext *ctx = avctx->privdata; MMALSTATUST status; MMALESFORMATT *formatin; MMALCOMPONENTT *decoder; char tmp[32]; int ret = 0; bcmhostinit(); if (mmalvcinit()) { avlog(avctx, AVLOGERROR, \"Cannot initialize MMAL VC driver!\\n\"); return AVERROR(ENOSYS); if ((ret = ffgetformat(avctx, avctx->codec->pixfmts)) < 0) return ret; avctx->pixfmt = ret; if ((status = mmalcomponentcreate(MMALCOMPONENTDEFAULTVIDEODECODER, &ctx->decoder))) goto fail; decoder = ctx->decoder; formatin = decoder->input[0]->format; formatin->type = MMALESTYPEVIDEO; switch (avctx->codecid) { case AVCODECIDMPEG2VIDEO: formatin->encoding = MMALENCODINGMP2V; break; case AVCODECIDMPEG4: formatin->encoding = MMALENCODINGMP4V; break; case AVCODECIDVC1: formatin->encoding = MMALENCODINGWVC1; break; case AVCODECIDH264: default: formatin->encoding = MMALENCODINGH264; break; formatin->es->video.width = FFALIGN(avctx->width, 32); formatin->es->video.height = FFALIGN(avctx->height, 16); formatin->es->video.crop.width = avctx->width; formatin->es->video.crop.height = avctx->height; formatin->es->video.framerate.num = 24000; formatin->es->video.framerate.den = 1001; formatin->es->video.par.num = avctx->sampleaspectratio.num; formatin->es->video.par.den = avctx->sampleaspectratio.den; formatin->flags = MMALESFORMATFLAGFRAMED; avgetcodectagstring(tmp, sizeof(tmp), formatin->encoding); avlog(avctx, AVLOGDEBUG, \"Using MMAL %s encoding.\\n\", tmp); if ((status = mmalportformatcommit(decoder->input[0]))) goto fail; decoder->input[0]->buffernum = FFMAX(decoder->input[0]->buffernummin, 20); decoder->input[0]->buffersize = FFMAX(decoder->input[0]->buffersizemin, 512 * 1024); ctx->poolin = mmalpoolcreate(decoder->input[0]->buffernum, 0); if (!ctx->poolin) { ret = AVERROR(ENOMEM); goto fail; if ((ret = ffmalupdateformat(avctx)) < 0) goto fail; ctx->queuedecodedframes = mmalqueuecreate(); if (!ctx->queuedecodedframes) goto fail; decoder->input[0]->userdata = (void*)avctx; decoder->output[0]->userdata = (void*)avctx; decoder->control->userdata = (void*)avctx; if ((status = mmalportenable(decoder->control, controlportcb))) goto fail; if ((status = mmalportenable(decoder->input[0], inputcallback))) goto fail; if ((status = mmalportenable(decoder->output[0], outputcallback))) goto fail; if ((status = mmalcomponentenable(decoder))) goto fail; return 0; fail: ffmmalclosedecoder(avctx); return ret < 0 ? ret : AVERRORUNKNOWN;", "target": 1}
{"func": "static int ogggetlength(AVFormatContext *s) { struct ogg *ogg = s->privdata; int i; int64t size, end; int streamsleft=0; if(!s->pb->seekable) return 0; // already set if (s->duration != AVNOPTSVALUE) return 0; size = aviosize(s->pb); if(size < 0) return 0; end = size > MAXPAGESIZE? size - MAXPAGESIZE: 0; oggsave (s); avioseek (s->pb, end, SEEKSET); while (!oggreadpage (s, &i)){ if (ogg->streams[i].granule != -1 && ogg->streams[i].granule != 0 && ogg->streams[i].codec) { s->streams[i]->duration = ogggptopts (s, i, ogg->streams[i].granule, NULL); if (s->streams[i]->starttime != AVNOPTSVALUE){ s->streams[i]->duration -= s->streams[i]->starttime; streamsleft-= (ogg->streams[i].gotstart==-1); ogg->streams[i].gotstart= 1; }else if(!ogg->streams[i].gotstart){ ogg->streams[i].gotstart= -1; streamsleft++; } } } oggrestore (s, 0); oggsave (s); avioseek (s->pb, s->dataoffset, SEEKSET); oggreset(s); while (!oggpacket(s, &i, NULL, NULL, NULL)) { int64t pts = oggcalcpts(s, i, NULL); if (pts != AVNOPTSVALUE && s->streams[i]->starttime == AVNOPTSVALUE && !ogg->streams[i].gotstart){ s->streams[i]->duration -= pts; ogg->streams[i].gotstart= 1; streamsleft--; }else if(s->streams[i]->starttime != AVNOPTSVALUE && !ogg->streams[i].gotstart){ ogg->streams[i].gotstart= 1; streamsleft--; } } if(streamsleft<=0) break; } oggrestore (s, 0); return 0; }", "target": 1}
{"func": "static int mimicdecodeframe(AVCodecContext *avctx, void *data, int *datasize, AVPacket *avpkt) { const uint8t *buf = avpkt->data; int bufsize = avpkt->size; MimicContext *ctx = avctx->privdata; GetByteContext gb; int ispframe; int width, height; int quality, numcoeffs; int swapbufsize = bufsize - MIMICHEADERSIZE; if (bufsize <= MIMICHEADERSIZE) { avlog(avctx, AVLOGERROR, \"insufficient data\\n\"); return -1; } bytestream2init(&gb, buf, MIMICHEADERSIZE); bytestream2skip(&gb, 2); /* some constant (always 256) */ quality = bytestream2getle16u(&gb); width = bytestream2getle16u(&gb); height = bytestream2getle16u(&gb); bytestream2skip(&gb, 4); /* some constant */ ispframe = bytestream2getle32u(&gb); numcoeffs = bytestream2getbyteu(&gb); bytestream2skip(&gb, 3); /* some constant */ if(!ctx->avctx) { int i; if(!(width == 160 && height == 120) && !(width == 320 && height == 240)) { avlog(avctx, AVLOGERROR, \"invalid width/height!\\n\"); return -1; } ctx->avctx = avctx; avctx->width = width; avctx->height = height; avctx->pixfmt = PIXFMTYUV420P; for(i = 0; i < 3; i++) { ctx->numvblocks[i] = -((-height) >> (3 + !!i)); ctx->numhblocks[i] = width >> (3 + !!i) ; } } else if(width != ctx->avctx->width || height != ctx->avctx->height) { avlog(avctx, AVLOGERROR, \"resolution changing is not supported\\n\"); return -1; } if(ispframe && !ctx->bufptrs[ctx->previndex].data[0]) { avlog(avctx, AVLOGERROR, \"decoding must start with keyframe\\n\"); return -1; } ctx->bufptrs[ctx->curindex].reference = 1; ctx->bufptrs[ctx->curindex].picttype = ispframe ? AVPICTURETYPEP:AVPICTURETYPEI; if(ffthreadgetbuffer(avctx, &ctx->bufptrs[ctx->curindex])) { avlog(avctx, AVLOGERROR, \"getbuffer() failed\\n\"); return -1; } ctx->nextprevindex = ctx->curindex; ctx->nextcurindex = (ctx->curindex - 1) & 15; prepareavpic(ctx, &ctx->flippedptrs[ctx->curindex], (AVPicture*) &ctx->bufptrs[ctx->curindex]); ffthreadfinishsetup(avctx); avfastmalloc(&ctx->swapbuf, &ctx->swapbufsize, swapbufsize + FFINPUTBUFFERPADDINGSIZE); if(!ctx->swapbuf) return AVERROR(ENOMEM); ctx->dsp.bswapbuf(ctx->swapbuf, (const uint32t*) (buf + MIMICHEADERSIZE), swapbufsize>>2); initgetbits(&ctx->gb, ctx->swapbuf, swapbufsize << 3); if(!decode(ctx, quality, numcoeffs, !ispframe)) { if (avctx->activethreadtype&FFTHREADFRAME) ffthreadreportprogress(&ctx->bufptrs[ctx->curindex], INTMAX, 0); else { ffthreadreleasebuffer(avctx, &ctx->bufptrs[ctx->curindex]); return -1; } } *(AVFrame*)data = ctx->bufptrs[ctx->curindex]; *datasize = sizeof(AVFrame); ctx->previndex = ctx->nextprevindex; ctx->curindex = ctx->nextcurindex; /* Only release frames that aren't used for backreferences anymore */ if(ctx->bufptrs[ctx->curindex].data[0]) ffthreadreleasebuffer(avctx, &ctx->bufptrs[ctx->curindex]); return bufsize; } ", "target": 1}
{"func": "static int ipvideodecodeblockopcode0x8(IpvideoContext *s) { int x, y; unsigned char P[2]; unsigned int flags = 0; /* 2-color encoding for each 4x4 quadrant, or 2-color encoding on * either top and bottom or left and right halves */ CHECKSTREAMPTR(2); P[0] = *s->streamptr++; P[1] = *s->streamptr++; if (P[0] <= P[1]) { CHECKSTREAMPTR(14); s->streamptr -= 2; for (y = 0; y < 16; y++) { // new values for each 4x4 block if (!(y & 3)) { P[0] = *s->streamptr++; P[1] = *s->streamptr++; flags = bytestreamgetle16(&s->streamptr); } for (x = 0; x < 4; x++, flags >>= 1) *s->pixelptr++ = P[flags & 1]; s->pixelptr += s->stride - 4; // switch to right half if (y == 7) s->pixelptr -= 8 * s->stride - 4; } } else { /* need 10 more bytes */ CHECKSTREAMPTR(10); if (s->streamptr[4] <= s->streamptr[5]) { flags = bytestreamgetle32(&s->streamptr); /* vertical split; left & right halves are 2-color encoded */ for (y = 0; y < 16; y++) { for (x = 0; x < 4; x++, flags >>= 1) *s->pixelptr++ = P[flags & 1]; s->pixelptr += s->stride - 4; // switch to right half if (y == 7) { s->pixelptr -= 8 * s->stride - 4; P[0] = *s->streamptr++; P[1] = *s->streamptr++; flags = bytestreamgetle32(&s->streamptr); } } } else { /* horizontal split; top & bottom halves are 2-color encoded */ for (y = 0; y < 8; y++) { if (y == 4) { P[0] = *s->streamptr++; P[1] = *s->streamptr++; } flags = *s->streamptr++ | 0x100; for (; flags != 1; flags >>= 1) *s->pixelptr++ = P[flags & 1]; s->pixelptr += s->lineinc; } } } /* report success */ return 0; } ", "target": 0}
{"func": "static int gdbsetavrreg(CPUState *env, uint8t *membuf, int n) { if (n < 32) { #ifdef WORDSBIGENDIAN env->avr[n].u64[0] = ldqp(membuf); env->avr[n].u64[1] = ldqp(membuf+8); #else env->avr[n].u64[1] = ldqp(membuf); env->avr[n].u64[0] = ldqp(membuf+8); #endif return 16; } if (n == 33) { env->vscr = ldlp(membuf); return 4; } if (n == 34) { env->spr[SPRVRSAVE] = (targetulong)ldlp(membuf); return 4; } return 0; } ", "target": 1}
{"func": "static void vgadrawtext(VGACommonState *s, int fullupdate) { DisplaySurface *surface = qemuconsolesurface(s->con); int cx, cy, cheight, cw, ch, cattr, height, width, chattr; int cxmin, cxmax, linesize, xincr, line, line1; uint32t offset, fgcol, bgcol, v, cursoroffset; uint8t *d1, *d, *src, *dest, *cursorptr; const uint8t *fontptr, *fontbase[2]; int dup9, lineoffset; uint32t *palette; uint32t *chattrptr; int64t now = qemuclockgetms(QEMUCLOCKVIRTUAL); /* compute font data address (in plane 2) */ v = s->sr[VGASEQCHARACTERMAP]; offset = (((v >> 4) & 1) | ((v << 1) & 6)) * 8192 * 4 + 2; if (offset != s->fontoffsets[0]) { s->fontoffsets[0] = offset; fullupdate = 1; } fontbase[0] = s->vramptr + offset; offset = (((v >> 5) & 1) | ((v >> 1) & 6)) * 8192 * 4 + 2; fontbase[1] = s->vramptr + offset; if (offset != s->fontoffsets[1]) { s->fontoffsets[1] = offset; fullupdate = 1; } if (s->planeupdated & (1 << 2) || s->haschain4alias) { /* if the plane 2 was modified since the last display, it indicates the font may have been modified */ s->planeupdated = 0; fullupdate = 1; } fullupdate |= updatebasicparams(s); lineoffset = s->lineoffset; vgagettextresolution(s, &width, &height, &cw, &cheight); if ((height * width) <= 1) { /* better than nothing: exit if transient size is too small */ return; } if ((height * width) > CHATTRSIZE) { /* better than nothing: exit if transient size is too big */ return; } if (width != s->lastwidth || height != s->lastheight || cw != s->lastcw || cheight != s->lastch || s->lastdepth) { s->lastscrwidth = width * cw; s->lastscrheight = height * cheight; qemuconsoleresize(s->con, s->lastscrwidth, s->lastscrheight); surface = qemuconsolesurface(s->con); dpytextresize(s->con, width, height); s->lastdepth = 0; s->lastwidth = width; s->lastheight = height; s->lastch = cheight; s->lastcw = cw; fullupdate = 1; } fullupdate |= updatepalette16(s); palette = s->lastpalette; xincr = cw * surfacebytesperpixel(surface); if (fullupdate) { s->fullupdatetext = 1; } if (s->fullupdategfx) { s->fullupdategfx = 0; fullupdate |= 1; } cursoroffset = ((s->cr[VGACRTCCURSORHI] << 8) | s->cr[VGACRTCCURSORLO]) - s->startaddr; if (cursoroffset != s->cursoroffset || s->cr[VGACRTCCURSORSTART] != s->cursorstart || s->cr[VGACRTCCURSOREND] != s->cursorend) { /* if the cursor position changed, we update the old and new chars */ if (s->cursoroffset < CHATTRSIZE) s->lastchattr[s->cursoroffset] = -1; if (cursoroffset < CHATTRSIZE) s->lastchattr[cursoroffset] = -1; s->cursoroffset = cursoroffset; s->cursorstart = s->cr[VGACRTCCURSORSTART]; s->cursorend = s->cr[VGACRTCCURSOREND]; } cursorptr = s->vramptr + (s->startaddr + cursoroffset) * 4; if (now >= s->cursorblinktime) { s->cursorblinktime = now + VGATEXTCURSORPERIODMS / 2; s->cursorvisiblephase = !s->cursorvisiblephase; } dest = surfacedata(surface); linesize = surfacestride(surface); chattrptr = s->lastchattr; line = 0; offset = s->startaddr * 4; for(cy = 0; cy < height; cy++) { d1 = dest; src = s->vramptr + offset; cxmin = width; cxmax = -1; for(cx = 0; cx < width; cx++) { chattr = *(uint16t *)src; if (fullupdate || chattr != *chattrptr || src == cursorptr) { if (cx < cxmin) cxmin = cx; if (cx > cxmax) cxmax = cx; *chattrptr = chattr; #ifdef HOSTWORDSBIGENDIAN ch = chattr >> 8; cattr = chattr & 0xff; #else ch = chattr & 0xff; cattr = chattr >> 8; #endif fontptr = fontbase[(cattr >> 3) & 1]; fontptr += 32 * 4 * ch; bgcol = palette[cattr >> 4]; fgcol = palette[cattr & 0x0f]; if (cw == 16) { vgadrawglyph16(d1, linesize, fontptr, cheight, fgcol, bgcol); } else if (cw != 9) { vgadrawglyph8(d1, linesize, fontptr, cheight, fgcol, bgcol); } else { dup9 = 0; if (ch >= 0xb0 && ch <= 0xdf && (s->ar[VGAATCMODE] & 0x04)) { dup9 = 1; } vgadrawglyph9(d1, linesize, fontptr, cheight, fgcol, bgcol, dup9); } if (src == cursorptr && !(s->cr[VGACRTCCURSORSTART] & 0x20) && s->cursorvisiblephase) { int linestart, linelast, h; /* draw the cursor */ linestart = s->cr[VGACRTCCURSORSTART] & 0x1f; linelast = s->cr[VGACRTCCURSOREND] & 0x1f; /* XXX: check that */ if (linelast > cheight - 1) linelast = cheight - 1; if (linelast >= linestart && linestart < cheight) { h = linelast - linestart + 1; d = d1 + linesize * linestart; if (cw == 16) { vgadrawglyph16(d, linesize, cursorglyph, h, fgcol, bgcol); } else if (cw != 9) { vgadrawglyph8(d, linesize, cursorglyph, h, fgcol, bgcol); } else { vgadrawglyph9(d, linesize, cursorglyph, h, fgcol, bgcol, 1); } } } } d1 += xincr; src += 4; chattrptr++; } if (cxmax != -1) { dpygfxupdate(s->con, cxmin * cw, cy * cheight, (cxmax - cxmin + 1) * cw, cheight); } dest += linesize * cheight; line1 = line + cheight; offset += lineoffset; if (line < s->linecompare && line1 >= s->linecompare) { offset = 0; } line = line1; } } ", "target": 1}
{"func": "int64t qemuftell(QEMUFile *f) { qemufflush(f); return f->pos; } ", "target": 1}
{"func": "static int libquvireadpacket(AVFormatContext *s, AVPacket *pkt) { LibQuviContext *qc = s->privdata; return avreadframe(qc->fmtctx, pkt); } ", "target": 1}
{"func": "static PCIDevice *qemupcihotaddstorage(Monitor *mon, const char *devaddr, const char *opts) { PCIDevice *dev; DriveInfo *dinfo = NULL; int type = -1; char buf[128]; PCIBus *bus; int devfn; if (getparamvalue(buf, sizeof(buf), \"if\", opts)) { if (!strcmp(buf, \"scsi\")) type = IFSCSI; else if (!strcmp(buf, \"virtio\")) { type = IFVIRTIO; } else { monitorprintf(mon, \"type %s not a hotpluggable PCI device.\\n\", buf); return NULL; } } else { monitorprintf(mon, \"no if= specified\\n\"); return NULL; } if (getparamvalue(buf, sizeof(buf), \"file\", opts)) { dinfo = addinitdrive(opts); if (!dinfo) return NULL; if (dinfo->devaddr) { monitorprintf(mon, \"Parameter addr not supported\\n\"); return NULL; } } else { dinfo = NULL; } bus = pcigetbusdevfn(&devfn, devaddr); if (!bus) { monitorprintf(mon, \"Invalid PCI device address %s\\n\", devaddr); return NULL; } switch (type) { case IFSCSI: if (!dinfo) { monitorprintf(mon, \"scsi requires a backing file/device.\\n\"); return NULL; } dev = pcicreate(bus, devfn, \"lsi53c895a\"); if (qdevinit(&dev->qdev) < 0) dev = NULL; if (dev) { BusState *scsibus = QLISTFIRST(&dev->qdev.childbus); scsibuslegacyadddrive(DOUPCAST(SCSIBus, qbus, scsibus), dinfo, dinfo->unit); } break; case IFVIRTIO: if (!dinfo) { monitorprintf(mon, \"virtio requires a backing file/device.\\n\"); return NULL; } dev = pcicreate(bus, devfn, \"virtio-blk-pci\"); qdevpropsetdrive(&dev->qdev, \"drive\", dinfo); if (qdevinit(&dev->qdev) < 0) dev = NULL; break; default: dev = NULL; } return dev; } ", "target": 1}
{"func": "uint16t eeprom93xxread(eepromt *eeprom) { /* Return status of pin DO (0 or 1). */ logout(\"CS=%u DO=%u\\n\", eeprom->eecs, eeprom->eedo); return (eeprom->eedo); } ", "target": 0}
{"func": "static void sysctlwrite(void *opaque, targetphysaddrt addr, uint32t value) { MilkymistSysctlState *s = opaque; tracemilkymistsysctlmemorywrite(addr, value); addr >>= 2; switch (addr) { case RGPIOOUT: case RGPIOINTEN: case RTIMER0COUNTER: if (value > s->regs[RTIMER0COUNTER]) { value = s->regs[RTIMER0COUNTER]; errorreport(\"milkymistsysctl: timer0: trying to write a \" \"value greater than the limit. Clipping.\"); } /* milkymist timer counts up */ value = s->regs[RTIMER0COUNTER] - value; ptimersetcount(s->ptimer0, value); break; case RTIMER1COUNTER: if (value > s->regs[RTIMER1COUNTER]) { value = s->regs[RTIMER1COUNTER]; errorreport(\"milkymistsysctl: timer1: trying to write a \" \"value greater than the limit. Clipping.\"); } /* milkymist timer counts up */ value = s->regs[RTIMER1COUNTER] - value; ptimersetcount(s->ptimer1, value); break; case RTIMER0COMPARE: ptimersetlimit(s->ptimer0, value, 0); s->regs[addr] = value; break; case RTIMER1COMPARE: ptimersetlimit(s->ptimer1, value, 0); s->regs[addr] = value; break; case RTIMER0CONTROL: s->regs[addr] = value; if (s->regs[RTIMER0CONTROL] & CTRLENABLE) { tracemilkymistsysctlstarttimer1(); ptimerrun(s->ptimer0, 0); } else { tracemilkymistsysctlstoptimer1(); ptimerstop(s->ptimer0); } break; case RTIMER1CONTROL: s->regs[addr] = value; if (s->regs[RTIMER1CONTROL] & CTRLENABLE) { tracemilkymistsysctlstarttimer1(); ptimerrun(s->ptimer1, 0); } else { tracemilkymistsysctlstoptimer1(); ptimerstop(s->ptimer1); } break; case RICAP: sysctlicapwrite(s, value); break; case RSYSTEMID: qemusystemresetrequest(); break; case RGPIOIN: case RCAPABILITIES: errorreport(\"milkymistsysctl: write to read-only register 0x\" TARGETFMTplx, addr << 2); break; default: errorreport(\"milkymistsysctl: write access to unkown register 0x\" TARGETFMTplx, addr << 2); break; } } ", "target": 0}
{"func": "AVFrame *avcodecallocframe(void) { AVFrame *frame = avmallocz(sizeof(AVFrame)); if (frame == NULL) return NULL; FFDISABLEDEPRECATIONWARNINGS avcodecgetframedefaults(frame); FFENABLEDEPRECATIONWARNINGS return frame; } ", "target": 0}
{"func": "static int addhfyuleftpredictionint16c(uint16t *dst, const uint16t *src, unsigned mask, int w, int acc){ int i; for(i=0; i<w-1; i++){ acc+= src[i]; dst[i]= acc & mask; i++; acc+= src[i]; dst[i]= acc & mask; } for(; i<w; i++){ acc+= src[i]; dst[i]= acc & mask; } return acc; } ", "target": 1}
{"func": "qemuirq *pxa2xxpicinit(targetphysaddrt base, CPUState *env) { PXA2xxPICState *s; int iomemtype; qemuirq *qi; s = (PXA2xxPICState *) qemumallocz(sizeof(PXA2xxPICState)); if (!s) return NULL; s->cpuenv = env; s->intpending[0] = 0; s->intpending[1] = 0; s->intenabled[0] = 0; s->intenabled[1] = 0; s->isfiq[0] = 0; s->isfiq[1] = 0; qi = qemuallocateirqs(pxa2xxpicsetirq, s, PXA2XXPICSRCS); /* Enable IC memory-mapped registers access. */ iomemtype = cpuregisteriomemory(pxa2xxpicreadfn, pxa2xxpicwritefn, s, DEVICENATIVEENDIAN); cpuregisterphysicalmemory(base, 0x00100000, iomemtype); /* Enable IC coprocessor access. */ cpuarmsetcpio(env, 6, pxa2xxpiccpread, pxa2xxpiccpwrite, s); registersavevm(NULL, \"pxa2xxpic\", 0, 0, pxa2xxpicsave, pxa2xxpicload, s); return qi; } ", "target": 0}
{"func": "int netinitvde(QemuOpts *opts, const NetClientOptions *newopts, const char *name, VLANState *vlan) { const char *sock; const char *group; int port, mode; sock = qemuoptget(opts, \"sock\"); group = qemuoptget(opts, \"group\"); port = qemuoptgetnumber(opts, \"port\", 0); mode = qemuoptgetnumber(opts, \"mode\", 0700); if (netvdeinit(vlan, \"vde\", name, sock, port, group, mode) == -1) { return -1; } return 0; } ", "target": 0}
{"func": "static const ID3v2EMFunc *getextrametafunc(const char *tag, int isv34) { int i = 0; while (ffid3v2extrametafuncs[i].tag3) { if (!memcmp(tag, (isv34 ? ffid3v2extrametafuncs[i].tag4 : ffid3v2extrametafuncs[i].tag3), (isv34 ? 4 : 3))) return &ffid3v2extrametafuncs[i]; i++; } return NULL; } ", "target": 1}
{"func": "int avbuffersrcaddref(AVFilterContext *bufferfilter, AVFilterBufferRef *picref, int flags) { BufferSourceContext *c = bufferfilter->priv; AVFilterBufferRef *buf; int ret; if (!picref) { c->eof = 1; return 0; } else if (c->eof) return AVERROR(EINVAL); if (!avfifospace(c->fifo) && (ret = avfiforealloc2(c->fifo, avfifosize(c->fifo) + sizeof(buf))) < 0) return ret; if (!(flags & AVBUFFERSRCFLAGNOCHECKFORMAT)) { ret = checkformatchange(bufferfilter, picref); if (ret < 0) return ret; } if (flags & AVBUFFERSRCFLAGNOCOPY) buf = picref; else buf = copybufferref(bufferfilter, picref); if ((ret = avfifogenericwrite(c->fifo, &buf, sizeof(buf), NULL)) < 0) { if (buf != picref) avfilterunrefbuffer(buf); return ret; } c->nbfailedrequests = 0; return 0; }", "target": 1}
{"func": "static void qstringdestroyobj(QObject *obj) { QString *qs; assert(obj != NULL); qs = qobjecttoqstring(obj); gfree(qs->string); gfree(qs); } ", "target": 0}
{"func": "bool aiopending(AioContext *ctx) { AioHandler *node; bool result = false; /* * We have to walk very carefully in case aiosetfdhandler is * called while we're walking. */ qemulockcntinc(&ctx->listlock); QLISTFOREACHRCU(node, &ctx->aiohandlers, node) { if (node->pfd.revents && node->ionotify) { result = true; break; } if ((node->pfd.revents & GIOIN) && node->ioread) { result = true; break; } if ((node->pfd.revents & GIOOUT) && node->iowrite) { result = true; break; } } qemulockcntdec(&ctx->listlock); return result; } ", "target": 0}
{"func": "static sizet getrequestsize(VirtQueue *vq) { unsigned int in, out; virtqueuegetavailbytes(vq, &in, &out); return in; } ", "target": 0}
{"func": "static void doquit(int argc, const char **argv) { exit(0); } ", "target": 0}
{"func": "static void pcinit1(ramaddrt ramsize, const char *bootdevice, const char *kernelfilename, const char *kernelcmdline, const char *initrdfilename, const char *cpumodel, int pcienabled, int kvmclockenabled) { int i; ramaddrt below4gmemsize, above4gmemsize; PCIBus *pcibus; PCII440FXState *i440fxstate; int piix3devfn = -1; qemuirq *cpuirq; qemuirq *isairq; qemuirq *i8259; qemuirq *cmoss3; qemuirq *smiirq; IsaIrqState *isairqstate; DriveInfo *hd[MAXIDEBUS * MAXIDEDEVS]; FDCtrl *floppycontroller; BusState *idebus[MAXIDEBUS]; ISADevice *rtcstate; pccpusinit(cpumodel); if (kvmclockenabled) { kvmclockcreate(); } /* allocate ram and load rom/bios */ pcmemoryinit(ramsize, kernelfilename, kernelcmdline, initrdfilename, &below4gmemsize, &above4gmemsize); cpuirq = pcallocatecpuirq(); i8259 = i8259init(cpuirq[0]); isairqstate = qemumallocz(sizeof(*isairqstate)); isairqstate->i8259 = i8259; if (pcienabled) { ioapicinit(isairqstate); } isairq = qemuallocateirqs(isairqhandler, isairqstate, 24); if (pcienabled) { pcibus = i440fxinit(&i440fxstate, &piix3devfn, isairq, ramsize); } else { pcibus = NULL; i440fxstate = NULL; isabusnew(NULL); } isabusirqs(isairq); pcregisterferrirq(isareserveirq(13)); pcvgainit(pcienabled? pcibus: NULL); /* init basic PC hardware */ pcbasicdeviceinit(isairq, &floppycontroller, &rtcstate); for(i = 0; i < nbnics; i++) { NICInfo *nd = &ndtable[i]; if (!pcienabled || (nd->model && strcmp(nd->model, \"ne2kisa\") == 0)) pcinitne2kisa(nd); else pcinicinitnofail(nd, \"e1000\", NULL); } if (drivegetmaxbus(IFIDE) >= MAXIDEBUS) { fprintf(stderr, \"qemu: too many IDE bus\\n\"); exit(1); } for(i = 0; i < MAXIDEBUS * MAXIDEDEVS; i++) { hd[i] = driveget(IFIDE, i / MAXIDEDEVS, i % MAXIDEDEVS); } if (pcienabled) { PCIDevice *dev; dev = pcipiix3ideinit(pcibus, hd, piix3devfn + 1); idebus[0] = qdevgetchildbus(&dev->qdev, \"ide.0\"); idebus[1] = qdevgetchildbus(&dev->qdev, \"ide.1\"); } else { for(i = 0; i < MAXIDEBUS; i++) { ISADevice *dev; dev = isaideinit(ideiobase[i], ideiobase2[i], ideirq[i], hd[MAXIDEDEVS * i], hd[MAXIDEDEVS * i + 1]); idebus[i] = qdevgetchildbus(&dev->qdev, \"ide.0\"); } } audioinit(isairq, pcienabled ? pcibus : NULL); pccmosinit(below4gmemsize, above4gmemsize, bootdevice, idebus[0], idebus[1], floppycontroller, rtcstate); if (pcienabled && usbenabled) { usbuhcipiix3init(pcibus, piix3devfn + 2); } if (pcienabled && acpienabled) { uint8t *eeprombuf = qemumallocz(8 * 256); /* XXX: make this persistent */ i2cbus *smbus; cmoss3 = qemuallocateirqs(pccmossets3resume, rtcstate, 1); smiirq = qemuallocateirqs(pcacpismiinterrupt, firstcpu, 1); /* TODO: Populate SPD eeprom data. */ smbus = piix4pminit(pcibus, piix3devfn + 3, 0xb100, isareserveirq(9), *cmoss3, *smiirq, kvmenabled()); for (i = 0; i < 8; i++) { DeviceState *eeprom; eeprom = qdevcreate((BusState *)smbus, \"smbus-eeprom\"); qdevpropsetuint8(eeprom, \"address\", 0x50 + i); qdevpropsetptr(eeprom, \"data\", eeprombuf + (i * 256)); qdevinitnofail(eeprom); } } if (i440fxstate) { i440fxinitmemorymappings(i440fxstate); } if (pcienabled) { pcpcideviceinit(pcibus); } } ", "target": 0}
{"func": "static avcold int roqdecodeinit(AVCodecContext *avctx) { RoqContext *s = avctx->privdata; s->avctx = avctx; if (avctx->width % 16 || avctx->height % 16) { avlog(avctx, AVLOGERROR, \"Dimensions must be a multiple of 16\\n\"); return AVERRORPATCHWELCOME; } s->width = avctx->width; s->height = avctx->height; s->lastframe = avframealloc(); s->currentframe = avframealloc(); if (!s->currentframe || !s->lastframe) { avframefree(&s->currentframe); avframefree(&s->lastframe); return AVERROR(ENOMEM); } avctx->pixfmt = AVPIXFMTYUV444P; return 0; } ", "target": 0}
{"func": "static int usbbthandledata(USBDevice *dev, USBPacket *p) { struct USBBtState *s = (struct USBBtState *) dev->opaque; int ret = 0; if (!s->config) goto fail; switch (p->pid) { case USBTOKENIN: switch (p->devep & 0xf) { case USBEVTEP: ret = usbbtfifodequeue(&s->evt, p); break; case USBACLEP: ret = usbbtfifodequeue(&s->acl, p); break; case USBSCOEP: ret = usbbtfifodequeue(&s->sco, p); break; default: goto fail; } break; case USBTOKENOUT: switch (p->devep & 0xf) { case USBACLEP: usbbtfifooutenqueue(s, &s->outacl, s->hci->aclsend, usbbthciaclcomplete, p->data, p->len); break; case USBSCOEP: usbbtfifooutenqueue(s, &s->outsco, s->hci->scosend, usbbthciscocomplete, p->data, p->len); break; default: goto fail; } break; default: fail: ret = USBRETSTALL; break; } return ret; } ", "target": 1}
{"func": "static void rtasibmreadslotresetstate2(PowerPCCPU *cpu, sPAPREnvironment *spapr, uint32t token, uint32t nargs, targetulong args, uint32t nret, targetulong rets) { sPAPRPHBState *sphb; sPAPRPHBClass *spc; uint64t buid; int state, ret; if ((nargs != 3) || (nret != 4 && nret != 5)) { goto paramerrorexit; } buid = ((uint64t)rtasld(args, 1) << 32) | rtasld(args, 2); sphb = findphb(spapr, buid); if (!sphb) { goto paramerrorexit; } spc = SPAPRPCIHOSTBRIDGEGETCLASS(sphb); if (!spc->eehgetstate) { goto paramerrorexit; } ret = spc->eehgetstate(sphb, &state); rtasst(rets, 0, ret); if (ret != RTASOUTSUCCESS) { return; } rtasst(rets, 1, state); rtasst(rets, 2, RTASEEHSUPPORT); rtasst(rets, 3, RTASEEHPEUNAVAILINFO); if (nret >= 5) { rtasst(rets, 4, RTASEEHPERECOVERINFO); } return; paramerrorexit: rtasst(rets, 0, RTASOUTPARAMERROR); } ", "target": 0}
{"func": "void qmpmigratesetcachesize(int64t value, Error **errp) { MigrationState *s = migrategetcurrent(); /* Check for truncation */ if (value != (sizet)value) { errorset(errp, QERRINVALIDPARAMETERVALUE, \"cache size\", \"exceeding address space\"); return; } s->xbzrlecachesize = xbzrlecacheresize(value); } ", "target": 0}
{"func": "int pathisabsolute(const char *path) { const char *p; #ifdef WIN32 /* specific case for names like: \"\\\\.\\d:\" */ if (*path == '/' || *path == '\\\\') return 1; #endif p = strchr(path, ':'); if (p) p++; else p = path; #ifdef WIN32 return (*p == '/' || *p == '\\\\'); #else return (*p == '/'); #endif } ", "target": 1}
{"func": "optsendstruct(Visitor *v, Error **errp) { OptsVisitor *ov = toov(v); GHashTableIter iter; GQueue *any; if (--ov->depth > 0) { return; } /* we should have processed all (distinct) QemuOpt instances */ ghashtableiterinit(&iter, ov->unprocessedopts); if (ghashtableiternext(&iter, NULL, (void **)&any)) { const QemuOpt *first; first = gqueuepeekhead(any); errorsetg(errp, QERRINVALIDPARAMETER, first->name); } ghashtabledestroy(ov->unprocessedopts); ov->unprocessedopts = NULL; if (ov->fakeidopt) { gfree(ov->fakeidopt->name); gfree(ov->fakeidopt->str); gfree(ov->fakeidopt); } ov->fakeidopt = NULL; } ", "target": 1}
{"func": "static avcold int shortendecodeclose(AVCodecContext *avctx) { ShortenContext *s = avctx->privdata; int i; for (i = 0; i < s->channels; i++) { s->decoded[i] -= s->nwrap; avfreep(&s->decoded[i]); avfreep(&s->offset[i]); } avfreep(&s->bitstream); avfreep(&s->coeffs); return 0; } ", "target": 1}
{"func": "void ffavgh264qpel4mc13msa(uint8t *dst, const uint8t *src, ptrdifft stride) { avclumahvqrtandaverdst4x4msa(src + stride - 2, src - (stride * 2), stride, dst, stride); } ", "target": 0}
{"func": "static uint32t apicmemreadl(void *opaque, targetphysaddrt addr) { DeviceState *d; APICCommonState *s; uint32t val; int index; d = cpugetcurrentapic(); if (!d) { return 0; } s = DOUPCAST(APICCommonState, busdev.qdev, d); index = (addr >> 4) & 0xff; switch(index) { case 0x02: /* id */ val = s->id << 24; break; case 0x03: /* version */ val = 0x11 | ((APICLVTNB - 1) << 16); /* version 0x11 */ break; case 0x08: apicsyncvapic(s, SYNCFROMVAPIC); if (apicreporttpraccess) { cpureporttpraccess(s->cpuenv, TPRACCESSREAD); } val = s->tpr; break; case 0x09: val = apicgetarbpri(s); break; case 0x0a: /* ppr */ val = apicgetppr(s); break; case 0x0b: val = 0; break; case 0x0d: val = s->logdest << 24; break; case 0x0e: val = s->destmode << 28; break; case 0x0f: val = s->spuriousvec; break; case 0x10 ... 0x17: val = s->isr[index & 7]; break; case 0x18 ... 0x1f: val = s->tmr[index & 7]; break; case 0x20 ... 0x27: val = s->irr[index & 7]; break; case 0x28: val = s->esr; break; case 0x30: case 0x31: val = s->icr[index & 1]; break; case 0x32 ... 0x37: val = s->lvt[index - 0x32]; break; case 0x38: val = s->initialcount; break; case 0x39: val = apicgetcurrentcount(s); break; case 0x3e: val = s->divideconf; break; default: s->esr |= ESRILLEGALADDRESS; val = 0; break; } traceapicmemreadl(addr, val); return val; } ", "target": 0}
{"func": "static SocketAddressLegacy *tcpbuildaddress(const char *hostport, Error **errp) { InetSocketAddress *iaddr = gnew(InetSocketAddress, 1); SocketAddressLegacy *saddr; if (inetparse(iaddr, hostport, errp)) { qapifreeInetSocketAddress(iaddr); return NULL; } saddr = gnew0(SocketAddressLegacy, 1); saddr->type = SOCKETADDRESSLEGACYKINDINET; saddr->u.inet.data = iaddr; return saddr; } ", "target": 0}
{"func": "static void renderline(int x0, uint8t y0, int x1, int y1, float *buf) { int dy = y1 - y0; int adx = x1 - x0; int ady = FFABS(dy); int sy = dy < 0 ? -1 : 1; buf[x0] = ffvorbisfloor1inversedbtable[y0]; if (ady*2 <= adx) { // optimized common case renderlineunrolled(x0, y0, x1, sy, ady, adx, buf); } else { int base = dy / adx; int x = x0; uint8t y = y0; int err = -adx; ady -= FFABS(base) * adx; while (++x < x1) { y += base; err += ady; if (err >= 0) { err -= adx; y += sy; } buf[x] = ffvorbisfloor1inversedbtable[y]; } } } ", "target": 1}
{"func": "static const QObject *qmpinputgetobject(QmpInputVisitor *qiv, const char *name) { const QObject *qobj; if (qiv->nbstack == 0) { qobj = qiv->obj; } else { qobj = qiv->stack[qiv->nbstack - 1].obj; } if (name && qobjecttype(qobj) == QTYPEQDICT) { return qdictget(qobjecttoqdict(qobj), name); } else if (qiv->nbstack > 0 && qobjecttype(qobj) == QTYPEQLIST) { return qlistentryobj(qiv->stack[qiv->nbstack - 1].entry); } return qobj; } ", "target": 1}
{"func": "static BufferPoolEntry *getpool(AVBufferPool *pool) { BufferPoolEntry *cur = NULL, *last = NULL; do { FFSWAP(BufferPoolEntry*, cur, last); cur = avprivatomicptrcas((void * volatile *)&pool->pool, last, NULL); if (!cur) return NULL; } while (cur != last); return cur; } ", "target": 1}
{"func": "static void switchbuffer(MPADecodeContext *s, int *pos, int *endpos, int *endpos2) { if (s->ingb.buffer && *pos >= s->gb.sizeinbits) { s->gb = s->ingb; s->ingb.buffer = NULL; assert((getbitscount(&s->gb) & 7) == 0); skipbitslong(&s->gb, *pos - *endpos); *endpos2 = *endpos = *endpos2 + getbitscount(&s->gb) - *pos; *pos = getbitscount(&s->gb); } } ", "target": 1}
{"func": "static int vpcwrite(BlockDriverState *bs, int64t sectornum, const uint8t *buf, int nbsectors) { BDRVVPCState *s = bs->opaque; int64t offset; int64t sectors, sectorsperblock; int ret; VHDFooter *footer = (VHDFooter *) s->footerbuf; if (cputobe32(footer->type) == VHDFIXED) { return bdrvwrite(bs->file, sectornum, buf, nbsectors); } while (nbsectors > 0) { offset = getsectoroffset(bs, sectornum, 1); sectorsperblock = s->blocksize >> BDRVSECTORBITS; sectors = sectorsperblock - (sectornum % sectorsperblock); if (sectors > nbsectors) { sectors = nbsectors; } if (offset == -1) { offset = allocblock(bs, sectornum); if (offset < 0) return -1; } ret = bdrvpwrite(bs->file, offset, buf, sectors * BDRVSECTORSIZE); if (ret != sectors * BDRVSECTORSIZE) { return -1; } nbsectors -= sectors; sectornum += sectors; buf += sectors * BDRVSECTORSIZE; } return 0; } ", "target": 1}
{"func": "static int readoldhuffmantables(HYuvContext *s){ #if 1 GetBitContext gb; int i; initgetbits(&gb, classicshiftluma, sizeof(classicshiftluma)*8); if(readlentable(s->len[0], &gb)<0) return -1; initgetbits(&gb, classicshiftchroma, sizeof(classicshiftchroma)*8); if(readlentable(s->len[1], &gb)<0) return -1; for(i=0; i<256; i++) s->bits[0][i] = classicaddluma [i]; for(i=0; i<256; i++) s->bits[1][i] = classicaddchroma[i]; if(s->bitstreambpp >= 24){ memcpy(s->bits[1], s->bits[0], 256*sizeof(uint32t)); memcpy(s->len[1] , s->len [0], 256*sizeof(uint8t)); } memcpy(s->bits[2], s->bits[1], 256*sizeof(uint32t)); memcpy(s->len[2] , s->len [1], 256*sizeof(uint8t)); for(i=0; i<3; i++){ fffreevlc(&s->vlc[i]); initvlc(&s->vlc[i], VLCBITS, 256, s->len[i], 1, 1, s->bits[i], 4, 4, 0); } generatejointtables(s); return 0; #else avlog(s->avctx, AVLOGDEBUG, \"v1 huffyuv is not supported \\n\"); return -1; #endif } ", "target": 1}
{"func": "exynos4boardsinitcommon(MachineState *machine, Exynos4BoardType boardtype) { Exynos4BoardState *s = gnew(Exynos4BoardState, 1); MachineClass *mc = MACHINEGETCLASS(machine); if (smpcpus != EXYNOS4210NCPUS && !qtestenabled()) { errorreport(\"%s board supports only %d CPU cores, ignoring smpcpus\" \" value\", mc->name, EXYNOS4210NCPUS); } exynos4boardbinfo.ramsize = exynos4boardramsize[boardtype]; exynos4boardbinfo.boardid = exynos4boardid[boardtype]; exynos4boardbinfo.smpbootregaddr = exynos4boardsmpbootregaddr[boardtype]; exynos4boardbinfo.kernelfilename = machine->kernelfilename; exynos4boardbinfo.initrdfilename = machine->initrdfilename; exynos4boardbinfo.kernelcmdline = machine->kernelcmdline; exynos4boardbinfo.giccpuifaddr = EXYNOS4210SMPPRIVATEBASEADDR + 0x100; PRINTDEBUG(\"\\n ramsize: %luMiB [0x%08lx]\\n\" \" kernelfilename: %s\\n\" \" kernelcmdline: %s\\n\" \" initrdfilename: %s\\n\", exynos4boardramsize[boardtype] / 1048576, exynos4boardramsize[boardtype], machine->kernelfilename, machine->kernelcmdline, machine->initrdfilename); exynos4boardsinitram(s, getsystemmemory(), exynos4boardramsize[boardtype]); s->soc = exynos4210init(getsystemmemory()); return s; } ", "target": 0}
{"func": "static void jsonprintsectionheader(WriterContext *wctx) { JSONContext *json = wctx->priv; AVBPrint buf; const struct section *section = wctx->section[wctx->level]; const struct section *parentsection = wctx->level ? wctx->section[wctx->level-1] : NULL; if (wctx->level && wctx->nbitem[wctx->level-1]) printf(\",\\n\"); if (section->flags & SECTIONFLAGISWRAPPER) { printf(\"{\\n\"); json->indentlevel++; } else { avbprintinit(&buf, 1, AVBPRINTSIZEUNLIMITED); jsonescapestr(&buf, section->name, wctx); JSONINDENT(); json->indentlevel++; if (section->flags & SECTIONFLAGISARRAY) { printf(\"\\\"%s\\\": [\\n\", buf.str); } else if (!(parentsection->flags & SECTIONFLAGISARRAY)) { printf(\"\\\"%s\\\": {%s\", buf.str, json->itemstartend); } else { printf(\"{%s\", json->itemstartend); /* this is required so the parser can distinguish between packets and frames */ if (parentsection->id == SECTIONIDPACKETSANDFRAMES) { if (!json->compact) JSONINDENT(); printf(\"\\\"type\\\": \\\"%s\\\"%s\", section->name, json->itemsep); } } avbprintfinalize(&buf, NULL); } } ", "target": 1}
{"func": "buildmadt(GArray *tabledata, BIOSLinker *linker, VirtGuestInfo *guestinfo) { int madtstart = tabledata->len; const MemMapEntry *memmap = guestinfo->memmap; const int *irqmap = guestinfo->irqmap; AcpiMultipleApicTable *madt; AcpiMadtGenericDistributor *gicd; AcpiMadtGenericMsiFrame *gicmsi; int i; madt = acpidatapush(tabledata, sizeof *madt); gicd = acpidatapush(tabledata, sizeof *gicd); gicd->type = ACPIAPICGENERICDISTRIBUTOR; gicd->length = sizeof(*gicd); gicd->baseaddress = memmap[VIRTGICDIST].base; gicd->version = guestinfo->gicversion; for (i = 0; i < guestinfo->smpcpus; i++) { AcpiMadtGenericInterrupt *gicc = acpidatapush(tabledata, sizeof *gicc); ARMCPU *armcpu = ARMCPU(qemugetcpu(i)); gicc->type = ACPIAPICGENERICINTERRUPT; gicc->length = sizeof(*gicc); if (guestinfo->gicversion == 2) { gicc->baseaddress = memmap[VIRTGICCPU].base; } gicc->cpuinterfacenumber = i; gicc->armmpidr = armcpu->mpaffinity; gicc->uid = i; gicc->flags = cputole32(ACPIGICCENABLED); if (armcpu->haspmu) { gicc->performanceinterrupt = cputole32(PPI(VIRTUALPMUIRQ)); } } if (guestinfo->gicversion == 3) { AcpiMadtGenericTranslator *gicits; AcpiMadtGenericRedistributor *gicr = acpidatapush(tabledata, sizeof *gicr); gicr->type = ACPIAPICGENERICREDISTRIBUTOR; gicr->length = sizeof(*gicr); gicr->baseaddress = cputole64(memmap[VIRTGICREDIST].base); gicr->rangelength = cputole32(memmap[VIRTGICREDIST].size); if (itsclassname()) { gicits = acpidatapush(tabledata, sizeof *gicits); gicits->type = ACPIAPICGENERICTRANSLATOR; gicits->length = sizeof(*gicits); gicits->translationid = 0; gicits->baseaddress = cputole64(memmap[VIRTGICITS].base); } } else { gicmsi = acpidatapush(tabledata, sizeof *gicmsi); gicmsi->type = ACPIAPICGENERICMSIFRAME; gicmsi->length = sizeof(*gicmsi); gicmsi->gicmsiframeid = 0; gicmsi->baseaddress = cputole64(memmap[VIRTGICV2M].base); gicmsi->flags = cputole32(1); gicmsi->spicount = cputole16(NUMGICV2MSPIS); gicmsi->spibase = cputole16(irqmap[VIRTGICV2M] + ARMSPIBASE); } buildheader(linker, tabledata, (void *)(tabledata->data + madtstart), \"APIC\", tabledata->len - madtstart, 3, NULL, NULL); } ", "target": 0}
{"func": "int slirpcanoutput(void) { return !slirpvc || qemucansendpacket(slirpvc); } ", "target": 0}
{"func": "static void usbtabletclassinitfn(ObjectClass *klass, void *data) { USBDeviceClass *uc = USBDEVICECLASS(klass); uc->init = usbtabletinitfn; uc->productdesc = \"QEMU USB Tablet\"; uc->usbdesc = &desctablet; uc->handlepacket = usbgenerichandlepacket; uc->handlereset = usbhidhandlereset; uc->handlecontrol = usbhidhandlecontrol; uc->handledata = usbhidhandledata; uc->handledestroy = usbhidhandledestroy; } ", "target": 0}
{"func": "static int pixletdecodeframe(AVCodecContext *avctx, void *data, int *gotframe, AVPacket *avpkt) { PixletContext *ctx = avctx->privdata; int i, w, h, width, height, ret, version; AVFrame *p = data; ThreadFrame frame = { .f = data }; uint32t pktsize; bytestream2init(&ctx->gb, avpkt->data, avpkt->size); pktsize = bytestream2getbe32(&ctx->gb); if (pktsize <= 44 || pktsize - 4 > bytestream2getbytesleft(&ctx->gb)) { avlog(avctx, AVLOGERROR, \"Invalid packet size %\"PRIu32\"\\n\", pktsize); } version = bytestream2getle32(&ctx->gb); if (version != 1) avprivrequestsample(avctx, \"Version %d\", version); bytestream2skip(&ctx->gb, 4); if (bytestream2getbe32(&ctx->gb) != 1) bytestream2skip(&ctx->gb, 4); width = bytestream2getbe32(&ctx->gb); height = bytestream2getbe32(&ctx->gb); w = FFALIGN(width, 1 << (NBLEVELS + 1)); h = FFALIGN(height, 1 << (NBLEVELS + 1)); ctx->levels = bytestream2getbe32(&ctx->gb); if (ctx->levels != NBLEVELS) ctx->depth = bytestream2getbe32(&ctx->gb); if (ctx->depth < 8 || ctx->depth > 15) { avprivrequestsample(avctx, \"Depth %d\", ctx->depth); } ret = ffsetdimensions(avctx, w, h); if (ret < 0) return ret; avctx->width = width; avctx->height = height; if (ctx->w != w || ctx->h != h) { freebuffers(avctx); ctx->w = w; ctx->h = h; ret = initdecoder(avctx); if (ret < 0) { freebuffers(avctx); ctx->w = 0; ctx->h = 0; return ret; } } bytestream2skip(&ctx->gb, 8); p->picttype = AVPICTURETYPEI; p->keyframe = 1; p->colorrange = AVCOLRANGEJPEG; ret = ffthreadgetbuffer(avctx, &frame, 0); if (ret < 0) return ret; for (i = 0; i < 3; i++) { ret = decodeplane(avctx, i, avpkt, frame.f); if (ret < 0) return ret; if (avctx->flags & AVCODECFLAGGRAY) break; } postprocessluma(frame.f, ctx->w, ctx->h, ctx->depth); postprocesschroma(frame.f, ctx->w >> 1, ctx->h >> 1, ctx->depth); *gotframe = 1; return pktsize; }", "target": 1}
{"func": "static void ccwmachine29classoptions(MachineClass *mc) { S390CcwMachineClass *s390mc = S390MACHINECLASS(mc); s390mc->gsallowed = false; ccwmachine210classoptions(mc); SETMACHINECOMPAT(mc, CCWCOMPAT29); s390mc->cssmigrationenabled = false; } ", "target": 1}
{"func": "static int matroskareadheader(AVFormatContext *s) { MatroskaDemuxContext *matroska = s->privdata; EbmlList *attachementslist = &matroska->attachments; MatroskaAttachement *attachements; EbmlList *chapterslist = &matroska->chapters; MatroskaChapter *chapters; MatroskaTrack *tracks; uint64t maxstart = 0; int64t pos; Ebml ebml = { 0 }; AVStream *st; int i, j, k, res; matroska->ctx = s; /* First read the EBML header. */ if (ebmlparse(matroska, ebmlsyntax, &ebml) || ebml.version > EBMLVERSION || ebml.maxsize > sizeof(uint64t) || ebml.idlength > sizeof(uint32t) || ebml.doctypeversion > 3) { avlog(matroska->ctx, AVLOGERROR, \"EBML header using unsupported features\\n\" \"(EBML version %\"PRIu64\", doctype %s, doc version %\"PRIu64\")\\n\", ebml.version, ebml.doctype, ebml.doctypeversion); ebmlfree(ebmlsyntax, &ebml); return AVERRORPATCHWELCOME; } else if (ebml.doctypeversion == 3) { avlog(matroska->ctx, AVLOGWARNING, \"EBML header using unsupported features\\n\" \"(EBML version %\"PRIu64\", doctype %s, doc version %\"PRIu64\")\\n\", ebml.version, ebml.doctype, ebml.doctypeversion); } for (i = 0; i < FFARRAYELEMS(matroskadoctypes); i++) if (!strcmp(ebml.doctype, matroskadoctypes[i])) break; if (i >= FFARRAYELEMS(matroskadoctypes)) { avlog(s, AVLOGWARNING, \"Unknown EBML doctype '%s'\\n\", ebml.doctype); } ebmlfree(ebmlsyntax, &ebml); /* The next thing is a segment. */ pos = aviotell(matroska->ctx->pb); res = ebmlparse(matroska, matroskasegments, matroska); // try resyncing until we find a EBMLSTOP type element. while (res != 1) { res = matroskaresync(matroska, pos); if (res < 0) return res; pos = aviotell(matroska->ctx->pb); res = ebmlparse(matroska, matroskasegment, matroska); } matroskaexecuteseekhead(matroska); if (!matroska->timescale) matroska->timescale = 1000000; if (matroska->duration) matroska->ctx->duration = matroska->duration * matroska->timescale * 1000 / AVTIMEBASE; avdictset(&s->metadata, \"title\", matroska->title, 0); if (matroska->dateutc.size == 8) matroskametadatacreationtime(&s->metadata, AVRB64(matroska->dateutc.data)); tracks = matroska->tracks.elem; for (i=0; i < matroska->tracks.nbelem; i++) { MatroskaTrack *track = &tracks[i]; enum CodecID codecid = CODECIDNONE; EbmlList *encodingslist = &track->encodings; MatroskaTrackEncoding *encodings = encodingslist->elem; uint8t *extradata = NULL; int extradatasize = 0; int extradataoffset = 0; uint32t fourcc = 0; AVIOContext b; /* Apply some sanity checks. */ if (track->type != MATROSKATRACKTYPEVIDEO && track->type != MATROSKATRACKTYPEAUDIO && track->type != MATROSKATRACKTYPESUBTITLE) { avlog(matroska->ctx, AVLOGINFO, \"Unknown or unsupported track type %\"PRIu64\"\\n\", track->type); continue; } if (track->codecid == NULL) continue; if (track->type == MATROSKATRACKTYPEVIDEO) { if (!track->defaultduration) track->defaultduration = 1000000000/track->video.framerate; if (!track->video.displaywidth) track->video.displaywidth = track->video.pixelwidth; if (!track->video.displayheight) track->video.displayheight = track->video.pixelheight; if (track->video.colorspace.size == 4) fourcc = AVRL32(track->video.colorspace.data); } else if (track->type == MATROSKATRACKTYPEAUDIO) { if (!track->audio.outsamplerate) track->audio.outsamplerate = track->audio.samplerate; } if (encodingslist->nbelem > 1) { avlog(matroska->ctx, AVLOGERROR, \"Multiple combined encodings not supported\"); } else if (encodingslist->nbelem == 1) { if (encodings[0].type || (encodings[0].compression.algo != MATROSKATRACKENCODINGCOMPHEADERSTRIP && #if CONFIGZLIB encodings[0].compression.algo != MATROSKATRACKENCODINGCOMPZLIB && #endif #if CONFIGBZLIB encodings[0].compression.algo != MATROSKATRACKENCODINGCOMPBZLIB && #endif encodings[0].compression.algo != MATROSKATRACKENCODINGCOMPLZO)) { encodings[0].scope = 0; avlog(matroska->ctx, AVLOGERROR, \"Unsupported encoding type\"); } else if (track->codecpriv.size && encodings[0].scope&2) { uint8t *codecpriv = track->codecpriv.data; int offset = matroskadecodebuffer(&track->codecpriv.data, &track->codecpriv.size, track); if (offset < 0) { track->codecpriv.data = NULL; track->codecpriv.size = 0; avlog(matroska->ctx, AVLOGERROR, \"Failed to decode codec private data\\n\"); } else if (offset > 0) { track->codecpriv.data = avmalloc(track->codecpriv.size + offset); memcpy(track->codecpriv.data, encodings[0].compression.settings.data, offset); memcpy(track->codecpriv.data+offset, codecpriv, track->codecpriv.size); track->codecpriv.size += offset; } if (codecpriv != track->codecpriv.data) avfree(codecpriv); } } for(j=0; ffmkvcodectags[j].id != CODECIDNONE; j++){ if(!strncmp(ffmkvcodectags[j].str, track->codecid, strlen(ffmkvcodectags[j].str))){ codecid= ffmkvcodectags[j].id; break; } } st = track->stream = avformatnewstream(s, NULL); if (st == NULL) return AVERROR(ENOMEM); if (!strcmp(track->codecid, \"VMS/VFW/FOURCC\") && track->codecpriv.size >= 40 && track->codecpriv.data != NULL) { track->mscompat = 1; fourcc = AVRL32(track->codecpriv.data + 16); codecid = ffcodecgetid(ffcodecbmptags, fourcc); extradataoffset = 40; } else if (!strcmp(track->codecid, \"AMS/ACM\") && track->codecpriv.size >= 14 && track->codecpriv.data != NULL) { int ret; ffioinitcontext(&b, track->codecpriv.data, track->codecpriv.size, AVIOFLAGREAD, NULL, NULL, NULL, NULL); ret = ffgetwavheader(&b, st->codec, track->codecpriv.size); if (ret < 0) return ret; codecid = st->codec->codecid; extradataoffset = FFMIN(track->codecpriv.size, 18); } else if (!strcmp(track->codecid, \"VQUICKTIME\") && (track->codecpriv.size >= 86) && (track->codecpriv.data != NULL)) { fourcc = AVRL32(track->codecpriv.data); codecid = ffcodecgetid(ffcodecmovvideotags, fourcc); } else if (codecid == CODECIDPCMS16BE) { switch (track->audio.bitdepth) { case 8: codecid = CODECIDPCMU8; break; case 24: codecid = CODECIDPCMS24BE; break; case 32: codecid = CODECIDPCMS32BE; break; } } else if (codecid == CODECIDPCMS16LE) { switch (track->audio.bitdepth) { case 8: codecid = CODECIDPCMU8; break; case 24: codecid = CODECIDPCMS24LE; break; case 32: codecid = CODECIDPCMS32LE; break; } } else if (codecid==CODECIDPCMF32LE && track->audio.bitdepth==64) { codecid = CODECIDPCMF64LE; } else if (codecid == CODECIDAAC && !track->codecpriv.size) { int profile = matroskaaacprofile(track->codecid); int sri = matroskaaacsri(track->audio.samplerate); extradata = avmallocz(5 + FFINPUTBUFFERPADDINGSIZE); if (extradata == NULL) return AVERROR(ENOMEM); extradata[0] = (profile << 3) | ((sri&0x0E) >> 1); extradata[1] = ((sri&0x01) << 7) | (track->audio.channels<<3); if (strstr(track->codecid, \"SBR\")) { sri = matroskaaacsri(track->audio.outsamplerate); extradata[2] = 0x56; extradata[3] = 0xE5; extradata[4] = 0x80 | (sri<<3); extradatasize = 5; } else extradatasize = 2; } else if (codecid == CODECIDTTA) { extradatasize = 30; extradata = avmallocz(extradatasize + FFINPUTBUFFERPADDINGSIZE); if (extradata == NULL) return AVERROR(ENOMEM); ffioinitcontext(&b, extradata, extradatasize, 1, NULL, NULL, NULL, NULL); aviowrite(&b, \"TTA1\", 4); aviowl16(&b, 1); aviowl16(&b, track->audio.channels); aviowl16(&b, track->audio.bitdepth); aviowl32(&b, track->audio.outsamplerate); aviowl32(&b, matroska->ctx->duration * track->audio.outsamplerate); } else if (codecid == CODECIDRV10 || codecid == CODECIDRV20 || codecid == CODECIDRV30 || codecid == CODECIDRV40) { extradataoffset = 26; } else if (codecid == CODECIDRA144) { track->audio.outsamplerate = 8000; track->audio.channels = 1; } else if (codecid == CODECIDRA288 || codecid == CODECIDCOOK || codecid == CODECIDATRAC3 || codecid == CODECIDSIPR) { int flavor; ffioinitcontext(&b, track->codecpriv.data,track->codecpriv.size, 0, NULL, NULL, NULL, NULL); avioskip(&b, 22); flavor = aviorb16(&b); track->audio.codedframesize = aviorb32(&b); avioskip(&b, 12); track->audio.subpacketh = aviorb16(&b); track->audio.framesize = aviorb16(&b); track->audio.subpacketsize = aviorb16(&b); track->audio.buf = avmalloc(track->audio.framesize * track->audio.subpacketh); if (codecid == CODECIDRA288) { st->codec->blockalign = track->audio.codedframesize; track->codecpriv.size = 0; } else { if (codecid == CODECIDSIPR && flavor < 4) { const int siprbitrate[4] = { 6504, 8496, 5000, 16000 }; track->audio.subpacketsize = ffsiprsubpksize[flavor]; st->codec->bitrate = siprbitrate[flavor]; } st->codec->blockalign = track->audio.subpacketsize; extradataoffset = 78; } } track->codecpriv.size -= extradataoffset; if (codecid == CODECIDNONE) avlog(matroska->ctx, AVLOGINFO, \"Unknown/unsupported CodecID %s.\\n\", track->codecid); if (track->timescale < 0.01) track->timescale = 1.0; avprivsetptsinfo(st, 64, matroska->timescale*track->timescale, 1000*1000*1000); /* 64 bit pts in ns */ st->codec->codecid = codecid; st->starttime = 0; if (strcmp(track->language, \"und\")) avdictset(&st->metadata, \"language\", track->language, 0); avdictset(&st->metadata, \"title\", track->name, 0); if (track->flagdefault) st->disposition |= AVDISPOSITIONDEFAULT; if (track->flagforced) st->disposition |= AVDISPOSITIONFORCED; if (!st->codec->extradata) { if(extradata){ st->codec->extradata = extradata; st->codec->extradatasize = extradatasize; } else if(track->codecpriv.data && track->codecpriv.size > 0){ st->codec->extradata = avmallocz(track->codecpriv.size + FFINPUTBUFFERPADDINGSIZE); if(st->codec->extradata == NULL) return AVERROR(ENOMEM); st->codec->extradatasize = track->codecpriv.size; memcpy(st->codec->extradata, track->codecpriv.data + extradataoffset, track->codecpriv.size); } } if (track->type == MATROSKATRACKTYPEVIDEO) { MatroskaTrackPlane *planes = track->operation.combineplanes.elem; st->codec->codectype = AVMEDIATYPEVIDEO; st->codec->codectag = fourcc; st->codec->width = track->video.pixelwidth; st->codec->height = track->video.pixelheight; avreduce(&st->sampleaspectratio.num, &st->sampleaspectratio.den, st->codec->height * track->video.displaywidth, st->codec-> width * track->video.displayheight, 255); st->needparsing = AVSTREAMPARSEHEADERS; if (track->defaultduration) st->avgframerate = avd2q(1000000000.0/track->defaultduration, INTMAX); /* export stereo mode flag as metadata tag */ if (track->video.stereomode && track->video.stereomode < MATROSKAVIDEOSTEREOMODECOUNT) avdictset(&st->metadata, \"stereomode\", matroskavideostereomode[track->video.stereomode], 0); /* if we have virtual track, mark the real tracks */ for (j=0; j < track->operation.combineplanes.nbelem; j++) { char buf[32]; if (planes[j].type >= MATROSKAVIDEOSTEREOPLANECOUNT) continue; snprintf(buf, sizeof(buf), \"%s%d\", matroskavideostereoplane[planes[j].type], i); for (k=0; k < matroska->tracks.nbelem; k++) if (planes[j].uid == tracks[k].uid) { avdictset(&s->streams[k]->metadata, \"stereomode\", buf, 0); break; } } } else if (track->type == MATROSKATRACKTYPEAUDIO) { st->codec->codectype = AVMEDIATYPEAUDIO; st->codec->samplerate = track->audio.outsamplerate; st->codec->channels = track->audio.channels; if (st->codec->codecid != CODECIDAAC) st->needparsing = AVSTREAMPARSEHEADERS; } else if (track->type == MATROSKATRACKTYPESUBTITLE) { st->codec->codectype = AVMEDIATYPESUBTITLE; } } attachements = attachementslist->elem; for (j=0; j<attachementslist->nbelem; j++) { if (!(attachements[j].filename && attachements[j].mime && attachements[j].bin.data && attachements[j].bin.size > 0)) { avlog(matroska->ctx, AVLOGERROR, \"incomplete attachment\\n\"); } else { AVStream *st = avformatnewstream(s, NULL); if (st == NULL) break; avdictset(&st->metadata, \"filename\",attachements[j].filename, 0); avdictset(&st->metadata, \"mimetype\", attachements[j].mime, 0); st->codec->codecid = CODECIDNONE; st->codec->codectype = AVMEDIATYPEATTACHMENT; st->codec->extradata = avmalloc(attachements[j].bin.size + FFINPUTBUFFERPADDINGSIZE); if(st->codec->extradata == NULL) break; st->codec->extradatasize = attachements[j].bin.size; memcpy(st->codec->extradata, attachements[j].bin.data, attachements[j].bin.size); for (i=0; ffmkvmimetags[i].id != CODECIDNONE; i++) { if (!strncmp(ffmkvmimetags[i].str, attachements[j].mime, strlen(ffmkvmimetags[i].str))) { st->codec->codecid = ffmkvmimetags[i].id; break; } } attachements[j].stream = st; } } chapters = chapterslist->elem; for (i=0; i<chapterslist->nbelem; i++) if (chapters[i].start != AVNOPTSVALUE && chapters[i].uid && (maxstart==0 || chapters[i].start > maxstart)) { chapters[i].chapter = avprivnewchapter(s, chapters[i].uid, (AVRational){1, 1000000000}, chapters[i].start, chapters[i].end, chapters[i].title); avdictset(&chapters[i].chapter->metadata, \"title\", chapters[i].title, 0); maxstart = chapters[i].start; } matroskaaddindexentries(matroska); matroskaconverttags(s); return 0; } ", "target": 1}
{"func": "static int filterframe(AVFilterLink *inlink, AVFrame *picref) { AVFilterContext *ctx = inlink->dst; SignatureContext *sic = ctx->priv; StreamContext *sc = &(sic->streamcontexts[FFINLINKIDX(inlink)]); FineSignature* fs; static const uint8t pot3[5] = { 3*3*3*3, 3*3*3, 3*3, 3, 1 }; /* indexes of words : 210,217,219,274,334 44,175,233,270,273 57,70,103,237,269 100,285,295,337,354 101,102,111,275,296 s2usw = sorted to unsorted wordvec: 44 is at index 5, 57 at index 10... */ static const unsigned int wordvec[25] = {44,57,70,100,101,102,103,111,175,210,217,219,233,237,269,270,273,274,275,285,295,296,334,337,354}; static const uint8t s2usw[25] = { 5,10,11, 15, 20, 21, 12, 22, 6, 0, 1, 2, 7, 13, 14, 8, 9, 3, 23, 16, 17, 24, 4, 18, 19}; uint8t wordt2b[5] = { 0, 0, 0, 0, 0 }; /* word ternary to binary */ uint64t intpic[32][32]; uint64t rowcount; uint8t *p = picref->data[0]; int inti, intj; int *intjlut; uint64t conflist[DIFFELEMSIZE]; int f = 0, g = 0, w = 0; int32t dh1 = 1, dh2 = 1, dw1 = 1, dw2 = 1, a, b; int64t denom; int i, j, k, ternary; uint64t blocksum; int blocksize; int64t th; /* threshold */ int64t sum; int64t precfactor = (sc->divide) ? 65536 : BLOCKLCM; /* initialize fs */ if (sc->curfinesig) { fs = avmallocz(sizeof(FineSignature)); if (!fs) return AVERROR(ENOMEM); sc->curfinesig->next = fs; fs->prev = sc->curfinesig; sc->curfinesig = fs; } else { fs = sc->curfinesig = sc->finesiglist; sc->curcoarsesig1->first = fs; } fs->pts = picref->pts; fs->index = sc->lastindex++; memset(intpic, 0, sizeof(uint64t)*32*32); intjlut = avmallocarray(inlink->w, sizeof(int)); if (!intjlut) return AVERROR(ENOMEM); for (i = 0; i < inlink->w; i++) { intjlut[i] = (i*32)/inlink->w; } for (i = 0; i < inlink->h; i++) { inti = (i*32)/inlink->h; for (j = 0; j < inlink->w; j++) { intj = intjlut[j]; intpic[inti][intj] += p[j]; } p += picref->linesize[0]; } avfreep(&intjlut); /* The following calculates a summed area table (intpic) and brings the numbers * in intpic to the same denominator. * So you only have to handle the numinator in the following sections. */ dh1 = inlink->h / 32; if (inlink->h % 32) dh2 = dh1 + 1; dw1 = inlink->w / 32; if (inlink->w % 32) dw2 = dw1 + 1; denom = (sc->divide) ? dh1 * dh2 * dw1 * dw2 : 1; for (i = 0; i < 32; i++) { rowcount = 0; a = 1; if (dh2 > 1) { a = ((inlink->h*(i+1))%32 == 0) ? (inlink->h*(i+1))/32 - 1 : (inlink->h*(i+1))/32; a -= ((inlink->h*i)%32 == 0) ? (inlink->h*i)/32 - 1 : (inlink->h*i)/32; a = (a == dh1)? dh2 : dh1; } for (j = 0; j < 32; j++) { b = 1; if (dw2 > 1) { b = ((inlink->w*(j+1))%32 == 0) ? (inlink->w*(j+1))/32 - 1 : (inlink->w*(j+1))/32; b -= ((inlink->w*j)%32 == 0) ? (inlink->w*j)/32 - 1 : (inlink->w*j)/32; b = (b == dw1)? dw2 : dw1; } rowcount += intpic[i][j] * a * b * precfactor / denom; if (i > 0) { intpic[i][j] = intpic[i-1][j] + rowcount; } else { intpic[i][j] = rowcount; } } } denom = (sc->divide) ? 1 : dh1 * dh2 * dw1 * dw2; for (i = 0; i < ELEMENTCOUNT; i++) { const ElemCat* elemcat = elements[i]; int64t* elemsignature; uint64t* sortsignature; elemsignature = avmallocarray(elemcat->elemcount, sizeof(int64t)); if (!elemsignature) return AVERROR(ENOMEM); sortsignature = avmallocarray(elemcat->elemcount, sizeof(int64t)); if (!sortsignature) return AVERROR(ENOMEM); for (j = 0; j < elemcat->elemcount; j++) { blocksum = 0; blocksize = 0; for (k = 0; k < elemcat->leftcount; k++) { blocksum += getblocksum(sc, intpic, &elemcat->blocks[j*elemcat->blockcount+k]); blocksize += getblocksize(&elemcat->blocks[j*elemcat->blockcount+k]); } sum = blocksum / blocksize; if (elemcat->avelem) { sum -= 128 * precfactor * denom; } else { blocksum = 0; blocksize = 0; for (; k < elemcat->blockcount; k++) { blocksum += getblocksum(sc, intpic, &elemcat->blocks[j*elemcat->blockcount+k]); blocksize += getblocksize(&elemcat->blocks[j*elemcat->blockcount+k]); } sum -= blocksum / blocksize; conflist[g++] = FFABS(sum * 8 / (precfactor * denom)); } elemsignature[j] = sum; sortsignature[j] = FFABS(sum); } /* get threshold */ qsort(sortsignature, elemcat->elemcount, sizeof(uint64t), (void*) cmp); th = sortsignature[(int) (elemcat->elemcount*0.333)]; /* ternarize */ for (j = 0; j < elemcat->elemcount; j++) { if (elemsignature[j] < -th) { ternary = 0; } else if (elemsignature[j] <= th) { ternary = 1; } else { ternary = 2; } fs->framesig[f/5] += ternary * pot3[f%5]; if (f == wordvec[w]) { fs->words[s2usw[w]/5] += ternary * pot3[wordt2b[s2usw[w]/5]++]; if (w < 24) w++; } f++; } avfreep(&elemsignature); avfreep(&sortsignature); } /* confidence */ qsort(conflist, DIFFELEMSIZE, sizeof(uint64t), (void*) cmp); fs->confidence = FFMIN(conflist[DIFFELEMSIZE/2], 255); /* coarsesignature */ if (sc->coarsecount == 0) { if (sc->curcoarsesig2) { sc->curcoarsesig1 = avmallocz(sizeof(CoarseSignature)); if (!sc->curcoarsesig1) return AVERROR(ENOMEM); sc->curcoarsesig1->first = fs; sc->curcoarsesig2->next = sc->curcoarsesig1; sc->coarseend = sc->curcoarsesig1; } } if (sc->coarsecount == 45) { sc->midcoarse = 1; sc->curcoarsesig2 = avmallocz(sizeof(CoarseSignature)); if (!sc->curcoarsesig2) return AVERROR(ENOMEM); sc->curcoarsesig2->first = fs; sc->curcoarsesig1->next = sc->curcoarsesig2; sc->coarseend = sc->curcoarsesig2; } for (i = 0; i < 5; i++) { setbit(sc->curcoarsesig1->data[i], fs->words[i]); } /* assuming the actual frame is the last */ sc->curcoarsesig1->last = fs; if (sc->midcoarse) { for (i = 0; i < 5; i++) { setbit(sc->curcoarsesig2->data[i], fs->words[i]); } sc->curcoarsesig2->last = fs; } sc->coarsecount = (sc->coarsecount+1)%90; /* debug printing finesignature */ if (avloggetlevel() == AVLOGDEBUG) { avlog(ctx, AVLOGDEBUG, \"input %d, confidence: %d\\n\", FFINLINKIDX(inlink), fs->confidence); avlog(ctx, AVLOGDEBUG, \"words:\"); for (i = 0; i < 5; i++) { avlog(ctx, AVLOGDEBUG, \" %d:\", fs->words[i] ); avlog(ctx, AVLOGDEBUG, \" %d\", fs->words[i] / pot3[0] ); for (j = 1; j < 5; j++) avlog(ctx, AVLOGDEBUG, \",%d\", fs->words[i] % pot3[j-1] / pot3[j] ); avlog(ctx, AVLOGDEBUG, \";\"); } avlog(ctx, AVLOGDEBUG, \"\\n\"); avlog(ctx, AVLOGDEBUG, \"framesignature:\"); for (i = 0; i < SIGELEMSIZE/5; i++) { avlog(ctx, AVLOGDEBUG, \" %d\", fs->framesig[i] / pot3[0] ); for (j = 1; j < 5; j++) avlog(ctx, AVLOGDEBUG, \",%d\", fs->framesig[i] % pot3[j-1] / pot3[j] ); } avlog(ctx, AVLOGDEBUG, \"\\n\"); } if (FFINLINKIDX(inlink) == 0) return fffilterframe(inlink->dst->outputs[0], picref); return 1; } ", "target": 1}
{"func": "static void testdmafragmented(void) { AHCIQState *ahci; AHCICommand *cmd; uint8t px; sizet bufsize = 4096; unsigned char *tx = gmalloc(bufsize); unsigned char *rx = gmalloc0(bufsize); uint64t ptr; ahci = ahcibootandenable(NULL); px = ahciportselect(ahci); ahciportclear(ahci, px); /* create pattern */ generatepattern(tx, bufsize, AHCISECTORSIZE); /* Create a DMA buffer in guest memory, and write our pattern to it. */ ptr = guestalloc(ahci->parent->alloc, bufsize); gassert(ptr); bufwrite(ptr, tx, bufsize); cmd = ahcicommandcreate(CMDWRITEDMA); ahcicommandadjust(cmd, 0, ptr, bufsize, 32); ahcicommandcommit(ahci, cmd, px); ahcicommandissue(ahci, cmd); ahcicommandverify(ahci, cmd); gfree(cmd); cmd = ahcicommandcreate(CMDREADDMA); ahcicommandadjust(cmd, 0, ptr, bufsize, 32); ahcicommandcommit(ahci, cmd, px); ahcicommandissue(ahci, cmd); ahcicommandverify(ahci, cmd); gfree(cmd); /* Read back the guest's receive buffer into local memory */ bufread(ptr, rx, bufsize); guestfree(ahci->parent->alloc, ptr); gassertcmphex(memcmp(tx, rx, bufsize), ==, 0); ahcishutdown(ahci); gfree(rx); gfree(tx); } ", "target": 1}
{"func": "static uint32t pcihotplugread(void *opaque, uint32t addr) { uint32t val = 0; struct pcistatus *g = opaque; switch (addr) { case PCIBASE: val = g->up; break; case PCIBASE + 4: val = g->down; break; default: break; } PIIX4DPRINTF(\"pcihotplug read %x == %x\\n\", addr, val); return val; } ", "target": 1}
{"func": "static int w64readheader(AVFormatContext *s, AVFormatParameters *ap) { int64t size; AVIOContext *pb = s->pb; WAVContext *wav = s->privdata; AVStream *st; uint8t guid[16]; avioread(pb, guid, 16); if (memcmp(guid, guidriff, 16)) return -1; if (aviorl64(pb) < 16 + 8 + 16 + 8 + 16 + 8) /* riff + wave + fmt + sizes */ return -1; avioread(pb, guid, 16); if (memcmp(guid, guidwave, 16)) { avlog(s, AVLOGERROR, \"could not find wave guid\\n\"); return -1; } size = findguid(pb, guidfmt); if (size < 0) { avlog(s, AVLOGERROR, \"could not find fmt guid\\n\"); return -1; } st = avnewstream(s, 0); if (!st) return AVERROR(ENOMEM); /* subtract chunk header size - normal wav file doesn't count it */ ffgetwavheader(pb, st->codec, size - 24); avioskip(pb, FFALIGN(size, INT64C(8)) - size); st->needparsing = AVSTREAMPARSEFULL; avsetptsinfo(st, 64, 1, st->codec->samplerate); size = findguid(pb, guiddata); if (size < 0) { avlog(s, AVLOGERROR, \"could not find data guid\\n\"); return -1; } wav->dataend = aviotell(pb) + size - 24; wav->w64 = 1; return 0; } ", "target": 1}
{"func": "void rgb15tobgr15(const uint8t *src, uint8t *dst, long srcsize) { \tlong i; \tlong numpixels = srcsize >> 1; \tfor(i=0; i<numpixels; i++) \t{ \t unsigned b,g,r; \t register uint16t rgb; \t rgb = src[2*i]; \t r = rgb&0x1F; \t g = (rgb&0x3E0)>>5; \t b = (rgb&0x7C00)>>10; \t dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10); \t} } ", "target": 1}
{"func": "int vncjobaddrect(VncJob *job, int x, int y, int w, int h) { VncRectEntry *entry = gmalloc0(sizeof(VncRectEntry)); entry->rect.x = x; entry->rect.y = y; entry->rect.w = w; entry->rect.h = h; vnclockqueue(queue); QLISTINSERTHEAD(&job->rectangles, entry, next); vncunlockqueue(queue); return 1; } ", "target": 1}
{"func": "static void uhciasynccompletepacket(USBPacket * packet, void *opaque) { UHCIState *s = opaque; UHCIQH qh; UHCITD td; uint32t link; uint32t oldtdctrl; uint32t val; uint32t frameaddr; int ret; /* Handle async isochronous packet completion */ frameaddr = s->asyncframeaddr; if (frameaddr) { cpuphysicalmemoryread(frameaddr, (uint8t *)&link, 4); le32tocpus(&link); cpuphysicalmemoryread(link & ~0xf, (uint8t *)&td, sizeof(td)); le32tocpus(&td.link); le32tocpus(&td.ctrl); le32tocpus(&td.token); le32tocpus(&td.buffer); oldtdctrl = td.ctrl; ret = uhcihandletd(s, &td, &s->pendingintmask, 1); /* update the status bits of the TD */ if (oldtdctrl != td.ctrl) { val = cputole32(td.ctrl); cpuphysicalmemorywrite((link & ~0xf) + 4, (const uint8t *)&val, sizeof(val)); } if (ret == 2) { s->asyncframeaddr = frameaddr; } else if (ret == 0) { /* update qh element link */ val = cputole32(td.link); cpuphysicalmemorywrite(frameaddr, (const uint8t *)&val, sizeof(val)); } return; } link = s->asyncqh; if (!link) { /* This should never happen. It means a TD somehow got removed without cancelling the associated async IO request. */ return; } cpuphysicalmemoryread(link & ~0xf, (uint8t *)&qh, sizeof(qh)); le32tocpus(&qh.link); le32tocpus(&qh.ellink); /* Re-process the queue containing the async packet. */ while (1) { cpuphysicalmemoryread(qh.ellink & ~0xf, (uint8t *)&td, sizeof(td)); le32tocpus(&td.link); le32tocpus(&td.ctrl); le32tocpus(&td.token); le32tocpus(&td.buffer); oldtdctrl = td.ctrl; ret = uhcihandletd(s, &td, &s->pendingintmask, 1); /* update the status bits of the TD */ if (oldtdctrl != td.ctrl) { val = cputole32(td.ctrl); cpuphysicalmemorywrite((qh.ellink & ~0xf) + 4, (const uint8t *)&val, sizeof(val)); } if (ret < 0) break; /* interrupted frame */ if (ret == 2) { s->asyncqh = link; break; } else if (ret == 0) { /* update qh element link */ qh.ellink = td.link; val = cputole32(qh.ellink); cpuphysicalmemorywrite((link & ~0xf) + 4, (const uint8t *)&val, sizeof(val)); if (!(qh.ellink & 4)) break; } break; } } ", "target": 0}
{"func": "static void trackedrequestend(BdrvTrackedRequest *req) { if (req->serialising) { req->bs->serialisinginflight--; } QLISTREMOVE(req, list); qemucoqueuerestartall(&req->waitqueue); } ", "target": 0}
{"func": "static int adpcmdecodeframe(AVCodecContext *avctx, void *data, int *datasize, AVPacket *avpkt) { const uint8t *buf = avpkt->data; int bufsize = avpkt->size; ADPCMDecodeContext *c = avctx->privdata; ADPCMChannelStatus *cs; int n, m, channel, i; int blockpredictor[2]; short *samples; short *samplesend; const uint8t *src; int st; /* stereo */ /* DK3 ADPCM accounting variables */ unsigned char lastbyte = 0; unsigned char nibble; int decodetopnibblenext = 0; int diffchannel; /* EA ADPCM state variables */ uint32t samplesinchunk; int32t previousleftsample, previousrightsample; int32t currentleftsample, currentrightsample; int32t nextleftsample, nextrightsample; int32t coeff1l, coeff2l, coeff1r, coeff2r; uint8t shiftleft, shiftright; int count1, count2; int coeff[2][2], shift[2];//used in EA MAXIS ADPCM if (!bufsize) return 0; //should protect all 4bit ADPCM variants //8 is needed for CODECIDADPCMIMAWAV with 2 channels // if(*datasize/4 < bufsize + 8) return -1; samples = data; samplesend= samples + *datasize/2; *datasize= 0; src = buf; st = avctx->channels == 2 ? 1 : 0; switch(avctx->codec->id) { case CODECIDADPCMIMAQT: n = bufsize - 2*avctx->channels; for (channel = 0; channel < avctx->channels; channel++) { int16t predictor; int stepindex; cs = &(c->status[channel]); /* (pppppp) (piiiiiii) */ /* Bits 15-7 are the top 9 bits of the 16-bit initial predictor value */ predictor = AVRB16(src); stepindex = predictor & 0x7F; predictor &= 0xFF80; src += 2; if (cs->stepindex == stepindex) { int diff = (int)predictor - cs->predictor; if (diff < 0) diff = - diff; if (diff > 0x7f) goto update; } else { update: cs->stepindex = stepindex; cs->predictor = predictor; } if (cs->stepindex > 88){ avlog(avctx, AVLOGERROR, \"ERROR: stepindex = %i\\n\", cs->stepindex); cs->stepindex = 88; } samples = (short*)data + channel; for(m=32; n>0 && m>0; n--, m--) { /* in QuickTime, IMA is encoded by chuncks of 34 bytes (=64 samples) */ *samples = adpcmimaqtexpandnibble(cs, src[0] & 0x0F, 3); samples += avctx->channels; *samples = adpcmimaqtexpandnibble(cs, src[0] >> 4 , 3); samples += avctx->channels; src ++; } } if (st) samples--; break; case CODECIDADPCMIMAWAV: if (avctx->blockalign != 0 && bufsize > avctx->blockalign) bufsize = avctx->blockalign; // samplesperblock= (blockalign-4*chanels)*8 / (bitspersample * chanels) + 1; for(i=0; i<avctx->channels; i++){ cs = &(c->status[i]); cs->predictor = *samples++ = (int16t)bytestreamgetle16(&src); cs->stepindex = *src++; if (cs->stepindex > 88){ avlog(avctx, AVLOGERROR, \"ERROR: stepindex = %i\\n\", cs->stepindex); cs->stepindex = 88; } if (*src++) avlog(avctx, AVLOGERROR, \"unused byte should be null but is %d!!\\n\", src[-1]); /* unused */ } while(src < buf + bufsize){ for(m=0; m<4; m++){ for(i=0; i<=st; i++) *samples++ = adpcmimaexpandnibble(&c->status[i], src[4*i] & 0x0F, 3); for(i=0; i<=st; i++) *samples++ = adpcmimaexpandnibble(&c->status[i], src[4*i] >> 4 , 3); src++; } src += 4*st; } break; case CODECIDADPCM4XM: cs = &(c->status[0]); c->status[0].predictor= (int16t)bytestreamgetle16(&src); if(st){ c->status[1].predictor= (int16t)bytestreamgetle16(&src); } c->status[0].stepindex= (int16t)bytestreamgetle16(&src); if(st){ c->status[1].stepindex= (int16t)bytestreamgetle16(&src); } if (cs->stepindex < 0) cs->stepindex = 0; if (cs->stepindex > 88) cs->stepindex = 88; m= (bufsize - (src - buf))>>st; for(i=0; i<m; i++) { *samples++ = adpcmimaexpandnibble(&c->status[0], src[i] & 0x0F, 4); if (st) *samples++ = adpcmimaexpandnibble(&c->status[1], src[i+m] & 0x0F, 4); *samples++ = adpcmimaexpandnibble(&c->status[0], src[i] >> 4, 4); if (st) *samples++ = adpcmimaexpandnibble(&c->status[1], src[i+m] >> 4, 4); } src += m<<st; break; case CODECIDADPCMMS: if (avctx->blockalign != 0 && bufsize > avctx->blockalign) bufsize = avctx->blockalign; n = bufsize - 7 * avctx->channels; if (n < 0) return -1; blockpredictor[0] = avclip(*src++, 0, 6); blockpredictor[1] = 0; if (st) blockpredictor[1] = avclip(*src++, 0, 6); c->status[0].idelta = (int16t)bytestreamgetle16(&src); if (st){ c->status[1].idelta = (int16t)bytestreamgetle16(&src); } c->status[0].coeff1 = ffadpcmAdaptCoeff1[blockpredictor[0]]; c->status[0].coeff2 = ffadpcmAdaptCoeff2[blockpredictor[0]]; c->status[1].coeff1 = ffadpcmAdaptCoeff1[blockpredictor[1]]; c->status[1].coeff2 = ffadpcmAdaptCoeff2[blockpredictor[1]]; c->status[0].sample1 = bytestreamgetle16(&src); if (st) c->status[1].sample1 = bytestreamgetle16(&src); c->status[0].sample2 = bytestreamgetle16(&src); if (st) c->status[1].sample2 = bytestreamgetle16(&src); *samples++ = c->status[0].sample2; if (st) *samples++ = c->status[1].sample2; *samples++ = c->status[0].sample1; if (st) *samples++ = c->status[1].sample1; for(;n>0;n--) { *samples++ = adpcmmsexpandnibble(&c->status[0 ], src[0] >> 4 ); *samples++ = adpcmmsexpandnibble(&c->status[st], src[0] & 0x0F); src ++; } break; case CODECIDADPCMIMADK4: if (avctx->blockalign != 0 && bufsize > avctx->blockalign) bufsize = avctx->blockalign; c->status[0].predictor = (int16t)bytestreamgetle16(&src); c->status[0].stepindex = *src++; src++; *samples++ = c->status[0].predictor; if (st) { c->status[1].predictor = (int16t)bytestreamgetle16(&src); c->status[1].stepindex = *src++; src++; *samples++ = c->status[1].predictor; } while (src < buf + bufsize) { uint8t v = *src++; *samples++ = adpcmimaexpandnibble(&c->status[0 ], v >> 4 , 3); *samples++ = adpcmimaexpandnibble(&c->status[st], v & 0x0F, 3); } break; case CODECIDADPCMIMADK3: if (avctx->blockalign != 0 && bufsize > avctx->blockalign) bufsize = avctx->blockalign; if(bufsize + 16 > (samplesend - samples)*3/8) return -1; c->status[0].predictor = (int16t)AVRL16(src + 10); c->status[1].predictor = (int16t)AVRL16(src + 12); c->status[0].stepindex = src[14]; c->status[1].stepindex = src[15]; /* sign extend the predictors */ src += 16; diffchannel = c->status[1].predictor; /* the DK3GETNEXTNIBBLE macro issues the break statement when * the buffer is consumed */ while (1) { /* for this algorithm, c->status[0] is the sum channel and * c->status[1] is the diff channel */ /* process the first predictor of the sum channel */ DK3GETNEXTNIBBLE(); adpcmimaexpandnibble(&c->status[0], nibble, 3); /* process the diff channel predictor */ DK3GETNEXTNIBBLE(); adpcmimaexpandnibble(&c->status[1], nibble, 3); /* process the first pair of stereo PCM samples */ diffchannel = (diffchannel + c->status[1].predictor) / 2; *samples++ = c->status[0].predictor + c->status[1].predictor; *samples++ = c->status[0].predictor - c->status[1].predictor; /* process the second predictor of the sum channel */ DK3GETNEXTNIBBLE(); adpcmimaexpandnibble(&c->status[0], nibble, 3); /* process the second pair of stereo PCM samples */ diffchannel = (diffchannel + c->status[1].predictor) / 2; *samples++ = c->status[0].predictor + c->status[1].predictor; *samples++ = c->status[0].predictor - c->status[1].predictor; } break; case CODECIDADPCMIMAISS: c->status[0].predictor = (int16t)AVRL16(src + 0); c->status[0].stepindex = src[2]; src += 4; if(st) { c->status[1].predictor = (int16t)AVRL16(src + 0); c->status[1].stepindex = src[2]; src += 4; } while (src < buf + bufsize) { uint8t v1, v2; uint8t v = *src++; /* nibbles are swapped for mono */ if (st) { v1 = v >> 4; v2 = v & 0x0F; } else { v2 = v >> 4; v1 = v & 0x0F; } *samples++ = adpcmimaexpandnibble(&c->status[0 ], v1, 3); *samples++ = adpcmimaexpandnibble(&c->status[st], v2, 3); } break; case CODECIDADPCMIMAWS: while (src < buf + bufsize) { uint8t v = *src++; *samples++ = adpcmimaexpandnibble(&c->status[0], v >> 4 , 3); *samples++ = adpcmimaexpandnibble(&c->status[st], v & 0x0F, 3); } break; case CODECIDADPCMXA: while (bufsize >= 128) { xadecode(samples, src, &c->status[0], &c->status[1], avctx->channels); src += 128; samples += 28 * 8; bufsize -= 128; } break; case CODECIDADPCMIMAEAEACS: samplesinchunk = bytestreamgetle32(&src) >> (1-st); if (samplesinchunk > bufsize-4-(8<<st)) { src += bufsize - 4; break; } for (i=0; i<=st; i++) c->status[i].stepindex = bytestreamgetle32(&src); for (i=0; i<=st; i++) c->status[i].predictor = bytestreamgetle32(&src); for (; samplesinchunk; samplesinchunk--, src++) { *samples++ = adpcmimaexpandnibble(&c->status[0], *src>>4, 3); *samples++ = adpcmimaexpandnibble(&c->status[st], *src&0x0F, 3); } break; case CODECIDADPCMIMAEASEAD: for (; src < buf+bufsize; src++) { *samples++ = adpcmimaexpandnibble(&c->status[0], src[0] >> 4, 6); *samples++ = adpcmimaexpandnibble(&c->status[st],src[0]&0x0F, 6); } break; case CODECIDADPCMEA: /* Each EA ADPCM frame has a 12-byte header followed by 30-byte pieces, each coding 28 stereo samples. */ if (bufsize < 12) { avlog(avctx, AVLOGERROR, \"frame too small\\n\"); return AVERROR(EINVAL); } samplesinchunk = AVRL32(src); if (samplesinchunk / 28 > (bufsize - 12) / 30) { avlog(avctx, AVLOGERROR, \"invalid frame\\n\"); return AVERROR(EINVAL); } src += 4; currentleftsample = (int16t)bytestreamgetle16(&src); previousleftsample = (int16t)bytestreamgetle16(&src); currentrightsample = (int16t)bytestreamgetle16(&src); previousrightsample = (int16t)bytestreamgetle16(&src); for (count1 = 0; count1 < samplesinchunk/28;count1++) { coeff1l = eaadpcmtable[ *src >> 4 ]; coeff2l = eaadpcmtable[(*src >> 4 ) + 4]; coeff1r = eaadpcmtable[*src & 0x0F]; coeff2r = eaadpcmtable[(*src & 0x0F) + 4]; src++; shiftleft = (*src >> 4 ) + 8; shiftright = (*src & 0x0F) + 8; src++; for (count2 = 0; count2 < 28; count2++) { nextleftsample = (int32t)((*src & 0xF0) << 24) >> shiftleft; nextrightsample = (int32t)((*src & 0x0F) << 28) >> shiftright; src++; nextleftsample = (nextleftsample + (currentleftsample * coeff1l) + (previousleftsample * coeff2l) + 0x80) >> 8; nextrightsample = (nextrightsample + (currentrightsample * coeff1r) + (previousrightsample * coeff2r) + 0x80) >> 8; previousleftsample = currentleftsample; currentleftsample = avclipint16(nextleftsample); previousrightsample = currentrightsample; currentrightsample = avclipint16(nextrightsample); *samples++ = (unsigned short)currentleftsample; *samples++ = (unsigned short)currentrightsample; } } if (src - buf == bufsize - 2) src += 2; // Skip terminating 0x0000 break; case CODECIDADPCMEAMAXISXA: for(channel = 0; channel < avctx->channels; channel++) { for (i=0; i<2; i++) coeff[channel][i] = eaadpcmtable[(*src >> 4) + 4*i]; shift[channel] = (*src & 0x0F) + 8; src++; } for (count1 = 0; count1 < (bufsize - avctx->channels) / avctx->channels; count1++) { for(i = 4; i >= 0; i-=4) { /* Pairwise samples LL RR (st) or LL LL (mono) */ for(channel = 0; channel < avctx->channels; channel++) { int32t sample = (int32t)(((*(src+channel) >> i) & 0x0F) << 0x1C) >> shift[channel]; sample = (sample + c->status[channel].sample1 * coeff[channel][0] + c->status[channel].sample2 * coeff[channel][1] + 0x80) >> 8; c->status[channel].sample2 = c->status[channel].sample1; c->status[channel].sample1 = avclipint16(sample); *samples++ = c->status[channel].sample1; } } src+=avctx->channels; } break; case CODECIDADPCMEAR1: case CODECIDADPCMEAR2: case CODECIDADPCMEAR3: { /* channel numbering 2chan: 0=fl, 1=fr 4chan: 0=fl, 1=rl, 2=fr, 3=rr 6chan: 0=fl, 1=c, 2=fr, 3=rl, 4=rr, 5=sub */ const int bigendian = avctx->codec->id == CODECIDADPCMEAR3; int32t previoussample, currentsample, nextsample; int32t coeff1, coeff2; uint8t shift; unsigned int channel; uint16t *samplesC; const uint8t *srcC; const uint8t *srcend = buf + bufsize; samplesinchunk = (bigendian ? bytestreamgetbe32(&src) : bytestreamgetle32(&src)) / 28; if (samplesinchunk > UINT32MAX/(28*avctx->channels) || 28*samplesinchunk*avctx->channels > samplesend-samples) { src += bufsize - 4; break; } for (channel=0; channel<avctx->channels; channel++) { int32t offset = (bigendian ? bytestreamgetbe32(&src) : bytestreamgetle32(&src)) + (avctx->channels-channel-1) * 4; if ((offset < 0) || (offset >= srcend - src - 4)) break; srcC = src + offset; samplesC = samples + channel; if (avctx->codec->id == CODECIDADPCMEAR1) { currentsample = (int16t)bytestreamgetle16(&srcC); previoussample = (int16t)bytestreamgetle16(&srcC); } else { currentsample = c->status[channel].predictor; previoussample = c->status[channel].prevsample; } for (count1=0; count1<samplesinchunk; count1++) { if (*srcC == 0xEE) { /* only seen in R2 and R3 */ srcC++; if (srcC > srcend - 30*2) break; currentsample = (int16t)bytestreamgetbe16(&srcC); previoussample = (int16t)bytestreamgetbe16(&srcC); for (count2=0; count2<28; count2++) { *samplesC = (int16t)bytestreamgetbe16(&srcC); samplesC += avctx->channels; } } else { coeff1 = eaadpcmtable[ *srcC>>4 ]; coeff2 = eaadpcmtable[(*srcC>>4) + 4]; shift = (*srcC++ & 0x0F) + 8; if (srcC > srcend - 14) break; for (count2=0; count2<28; count2++) { if (count2 & 1) nextsample = (int32t)((*srcC++ & 0x0F) << 28) >> shift; else nextsample = (int32t)((*srcC & 0xF0) << 24) >> shift; nextsample += (currentsample * coeff1) + (previoussample * coeff2); nextsample = avclipint16(nextsample >> 8); previoussample = currentsample; currentsample = nextsample; *samplesC = currentsample; samplesC += avctx->channels; } } } if (avctx->codec->id != CODECIDADPCMEAR1) { c->status[channel].predictor = currentsample; c->status[channel].prevsample = previoussample; } } src = src + bufsize - (4 + 4*avctx->channels); samples += 28 * samplesinchunk * avctx->channels; break; } case CODECIDADPCMEAXAS: if (samplesend-samples < 32*4*avctx->channels || bufsize < (4+15)*4*avctx->channels) { src += bufsize; break; } for (channel=0; channel<avctx->channels; channel++) { int coeff[2][4], shift[4]; short *s2, *s = &samples[channel]; for (n=0; n<4; n++, s+=32*avctx->channels) { for (i=0; i<2; i++) coeff[i][n] = eaadpcmtable[(src[0]&0x0F)+4*i]; shift[n] = (src[2]&0x0F) + 8; for (s2=s, i=0; i<2; i++, src+=2, s2+=avctx->channels) s2[0] = (src[0]&0xF0) + (src[1]<<8); } for (m=2; m<32; m+=2) { s = &samples[m*avctx->channels + channel]; for (n=0; n<4; n++, src++, s+=32*avctx->channels) { for (s2=s, i=0; i<8; i+=4, s2+=avctx->channels) { int level = (int32t)((*src & (0xF0>>i)) << (24+i)) >> shift[n]; int pred = s2[-1*avctx->channels] * coeff[0][n] + s2[-2*avctx->channels] * coeff[1][n]; s2[0] = avclipint16((level + pred + 0x80) >> 8); } } } } samples += 32*4*avctx->channels; break; case CODECIDADPCMIMAAMV: case CODECIDADPCMIMASMJPEG: c->status[0].predictor = (int16t)bytestreamgetle16(&src); c->status[0].stepindex = bytestreamgetle16(&src); if (avctx->codec->id == CODECIDADPCMIMAAMV) src+=4; while (src < buf + bufsize) { char hi, lo; lo = *src & 0x0F; hi = *src >> 4; if (avctx->codec->id == CODECIDADPCMIMAAMV) FFSWAP(char, hi, lo); *samples++ = adpcmimaexpandnibble(&c->status[0], lo, 3); *samples++ = adpcmimaexpandnibble(&c->status[0], hi, 3); src++; } break; case CODECIDADPCMCT: while (src < buf + bufsize) { uint8t v = *src++; *samples++ = adpcmctexpandnibble(&c->status[0 ], v >> 4 ); *samples++ = adpcmctexpandnibble(&c->status[st], v & 0x0F); } break; case CODECIDADPCMSBPRO4: case CODECIDADPCMSBPRO3: case CODECIDADPCMSBPRO2: if (!c->status[0].stepindex) { /* the first byte is a raw sample */ *samples++ = 128 * (*src++ - 0x80); if (st) *samples++ = 128 * (*src++ - 0x80); c->status[0].stepindex = 1; } if (avctx->codec->id == CODECIDADPCMSBPRO4) { while (src < buf + bufsize) { *samples++ = adpcmsbproexpandnibble(&c->status[0], src[0] >> 4, 4, 0); *samples++ = adpcmsbproexpandnibble(&c->status[st], src[0] & 0x0F, 4, 0); src++; } } else if (avctx->codec->id == CODECIDADPCMSBPRO3) { while (src < buf + bufsize && samples + 2 < samplesend) { *samples++ = adpcmsbproexpandnibble(&c->status[0], src[0] >> 5 , 3, 0); *samples++ = adpcmsbproexpandnibble(&c->status[0], (src[0] >> 2) & 0x07, 3, 0); *samples++ = adpcmsbproexpandnibble(&c->status[0], src[0] & 0x03, 2, 0); src++; } } else { while (src < buf + bufsize && samples + 3 < samplesend) { *samples++ = adpcmsbproexpandnibble(&c->status[0], src[0] >> 6 , 2, 2); *samples++ = adpcmsbproexpandnibble(&c->status[st], (src[0] >> 4) & 0x03, 2, 2); *samples++ = adpcmsbproexpandnibble(&c->status[0], (src[0] >> 2) & 0x03, 2, 2); *samples++ = adpcmsbproexpandnibble(&c->status[st], src[0] & 0x03, 2, 2); src++; } } break; case CODECIDADPCMSWF: { GetBitContext gb; const int *table; int k0, signmask, nbbits, count; int size = bufsize*8; initgetbits(&gb, buf, size); //read bits & initial values nbbits = getbits(&gb, 2)+2; //avlog(NULL,AVLOGINFO,\"nbbits: %d\\n\", nbbits); table = swfindextables[nbbits-2]; k0 = 1 << (nbbits-2); signmask = 1 << (nbbits-1); while (getbitscount(&gb) <= size - 22*avctx->channels) { for (i = 0; i < avctx->channels; i++) { *samples++ = c->status[i].predictor = getsbits(&gb, 16); c->status[i].stepindex = getbits(&gb, 6); } for (count = 0; getbitscount(&gb) <= size - nbbits*avctx->channels && count < 4095; count++) { int i; for (i = 0; i < avctx->channels; i++) { // similar to IMA adpcm int delta = getbits(&gb, nbbits); int step = ffadpcmsteptable[c->status[i].stepindex]; long vpdiff = 0; // vpdiff = (delta+0.5)*step/4 int k = k0; do { if (delta & k) vpdiff += step; step >>= 1; k >>= 1; } while(k); vpdiff += step; if (delta & signmask) c->status[i].predictor -= vpdiff; else c->status[i].predictor += vpdiff; c->status[i].stepindex += table[delta & (~signmask)]; c->status[i].stepindex = avclip(c->status[i].stepindex, 0, 88); c->status[i].predictor = avclipint16(c->status[i].predictor); *samples++ = c->status[i].predictor; if (samples >= samplesend) { avlog(avctx, AVLOGERROR, \"allocated output buffer is too small\\n\"); return -1; } } } } src += bufsize; break; } case CODECIDADPCMYAMAHA: while (src < buf + bufsize) { uint8t v = *src++; *samples++ = adpcmyamahaexpandnibble(&c->status[0 ], v & 0x0F); *samples++ = adpcmyamahaexpandnibble(&c->status[st], v >> 4 ); } break; case CODECIDADPCMTHP: { int table[2][16]; unsigned int samplecnt; int prev[2][2]; int ch; if (bufsize < 80) { avlog(avctx, AVLOGERROR, \"frame too small\\n\"); return -1; } src+=4; samplecnt = bytestreamgetbe32(&src); for (i = 0; i < 32; i++) table[0][i] = (int16t)bytestreamgetbe16(&src); /* Initialize the previous sample. */ for (i = 0; i < 4; i++) prev[0][i] = (int16t)bytestreamgetbe16(&src); if (samplecnt >= (samplesend - samples) / (st + 1)) { avlog(avctx, AVLOGERROR, \"allocated output buffer is too small\\n\"); return -1; } for (ch = 0; ch <= st; ch++) { samples = (unsigned short *) data + ch; /* Read in every sample for this channel. */ for (i = 0; i < samplecnt / 14; i++) { int index = (*src >> 4) & 7; unsigned int exp = 28 - (*src++ & 15); int factor1 = table[ch][index * 2]; int factor2 = table[ch][index * 2 + 1]; /* Decode 14 samples. */ for (n = 0; n < 14; n++) { int32t sampledat; if(n&1) sampledat= *src++ <<28; else sampledat= (*src&0xF0)<<24; sampledat = ((prev[ch][0]*factor1 + prev[ch][1]*factor2) >> 11) + (sampledat>>exp); *samples = avclipint16(sampledat); prev[ch][1] = prev[ch][0]; prev[ch][0] = *samples++; /* In case of stereo, skip one sample, this sample is for the other channel. */ samples += st; } } } /* In the previous loop, in case stereo is used, samples is increased exactly one time too often. */ samples -= st; break; } default: return -1; } *datasize = (uint8t *)samples - (uint8t *)data; return src - buf; } ", "target": 0}
{"func": "static int smackerdecodeheadertree(SmackVContext *smk, GetBitContext *gb, int **recodes, int *last, int size) { int res; HuffContext huff; HuffContext tmp1, tmp2; VLC vlc[2] = { { 0 } }; int escapes[3]; DBCtx ctx; int err = 0; if(size >= UINTMAX>>4){ // (((size + 3) >> 2) + 3) << 2 must not overflow avlog(smk->avctx, AVLOGERROR, \"size too large\\n\"); return AVERRORINVALIDDATA; } tmp1.length = 256; tmp1.maxlength = 0; tmp1.current = 0; tmp1.bits = avmallocz(256 * 4); tmp1.lengths = avmallocz(256 * sizeof(int)); tmp1.values = avmallocz(256 * sizeof(int)); tmp2.length = 256; tmp2.maxlength = 0; tmp2.current = 0; tmp2.bits = avmallocz(256 * 4); tmp2.lengths = avmallocz(256 * sizeof(int)); tmp2.values = avmallocz(256 * sizeof(int)); if(getbits1(gb)) { smackerdecodetree(gb, &tmp1, 0, 0); skipbits1(gb); if(tmp1.current > 1) { res = initvlc(&vlc[0], SMKTREEBITS, tmp1.length, tmp1.lengths, sizeof(int), sizeof(int), tmp1.bits, sizeof(uint32t), sizeof(uint32t), INITVLCLE); if(res < 0) { avlog(smk->avctx, AVLOGERROR, \"Cannot build VLC table\\n\"); return AVERRORINVALIDDATA; } } } if (!vlc[0].table) { avlog(smk->avctx, AVLOGERROR, \"Skipping low bytes tree\\n\"); } if(getbits1(gb)){ smackerdecodetree(gb, &tmp2, 0, 0); skipbits1(gb); if(tmp2.current > 1) { res = initvlc(&vlc[1], SMKTREEBITS, tmp2.length, tmp2.lengths, sizeof(int), sizeof(int), tmp2.bits, sizeof(uint32t), sizeof(uint32t), INITVLCLE); if(res < 0) { avlog(smk->avctx, AVLOGERROR, \"Cannot build VLC table\\n\"); return AVERRORINVALIDDATA; } } } if (!vlc[1].table) { avlog(smk->avctx, AVLOGERROR, \"Skipping high bytes tree\\n\"); } escapes[0] = getbits(gb, 16); escapes[1] = getbits(gb, 16); escapes[2] = getbits(gb, 16); last[0] = last[1] = last[2] = -1; ctx.escapes[0] = escapes[0]; ctx.escapes[1] = escapes[1]; ctx.escapes[2] = escapes[2]; ctx.v1 = &vlc[0]; ctx.v2 = &vlc[1]; ctx.recode1 = tmp1.values; ctx.recode2 = tmp2.values; ctx.last = last; huff.length = ((size + 3) >> 2) + 3; huff.maxlength = 0; huff.current = 0; huff.values = avmallocz(huff.length * sizeof(int)); if (smackerdecodebigtree(gb, &huff, &ctx) < 0) err = -1; skipbits1(gb); if(ctx.last[0] == -1) ctx.last[0] = huff.current++; if(ctx.last[1] == -1) ctx.last[1] = huff.current++; if(ctx.last[2] == -1) ctx.last[2] = huff.current++; if(huff.current > huff.length){ ctx.last[0] = ctx.last[1] = ctx.last[2] = 1; avlog(smk->avctx, AVLOGERROR, \"bigtree damaged\\n\"); return AVERRORINVALIDDATA; } *recodes = huff.values; if(vlc[0].table) fffreevlc(&vlc[0]); if(vlc[1].table) fffreevlc(&vlc[1]); avfree(tmp1.bits); avfree(tmp1.lengths); avfree(tmp1.values); avfree(tmp2.bits); avfree(tmp2.lengths); avfree(tmp2.values); return err; } ", "target": 0}
{"func": "static int standarddecodepictureprimaryheader(VC9Context *v) { GetBitContext *gb = &v->s.gb; int status = 0; if (v->finterpflag) v->interpfrm = getbits(gb, 1); skipbits(gb, 2); //framecnt unused if (v->rangered) v->rangeredfrm = getbits(gb, 1); v->s.picttype = getbits(gb, 1); if (v->s.avctx->maxbframes) { if (!v->s.picttype) { if (getbits(gb, 1)) v->s.picttype = ITYPE; else v->s.picttype = BTYPE; } else v->s.picttype = PTYPE; } else v->s.picttype++; switch (v->s.picttype) { case ITYPE: status = decodeipictureheader(v); break; case PTYPE: status = decodeppictureprimaryheader(v); break; case BITYPE: case BTYPE: status = decodebpictureprimaryheader(v); break; } if (status == FRAMESKIPED) { avlog(v->s.avctx, AVLOGINFO, \"Skipping frame...\\n\"); return status; } return 0; } ", "target": 1}
{"func": "static FFServerIPAddressACL* parsedynamicacl(FFServerStream *stream, HTTPContext *c) { FILE* f; char line[1024]; char cmd[1024]; FFServerIPAddressACL *acl = NULL; int linenum = 0; const char *p; f = fopen(stream->dynamicacl, \"r\"); if (!f) { perror(stream->dynamicacl); return NULL; } acl = avmallocz(sizeof(FFServerIPAddressACL)); /* Build ACL */ for(;;) { if (fgets(line, sizeof(line), f) == NULL) break; linenum++; p = line; while (avisspace(*p)) p++; if (*p == '\\0' || *p == '#') continue; ffservergetarg(cmd, sizeof(cmd), &p); if (!avstrcasecmp(cmd, \"ACL\")) ffserverparseaclrow(NULL, NULL, acl, p, stream->dynamicacl, linenum); } fclose(f); return acl; } ", "target": 0}
{"func": "static int discardf(BlockBackend *blk, int argc, char **argv) { struct timeval t1, t2; int Cflag = 0, qflag = 0; int c, ret; int64t offset, count; while ((c = getopt(argc, argv, \"Cq\")) != -1) { switch (c) { case 'C': Cflag = 1; break; case 'q': qflag = 1; break; default: return qemuiocommandusage(&discardcmd); } } if (optind != argc - 2) { return qemuiocommandusage(&discardcmd); } offset = cvtnum(argv[optind]); if (offset < 0) { printcvtnumerr(offset, argv[optind]); return 0; } optind++; count = cvtnum(argv[optind]); if (count < 0) { printcvtnumerr(count, argv[optind]); return 0; } else if (count >> BDRVSECTORBITS > INTMAX) { printf(\"length cannot exceed %\"PRIu64\", given %s\\n\", (uint64t)INTMAX << BDRVSECTORBITS, argv[optind]); return 0; } gettimeofday(&t1, NULL); ret = blkdiscard(blk, offset >> BDRVSECTORBITS, count >> BDRVSECTORBITS); gettimeofday(&t2, NULL); if (ret < 0) { printf(\"discard failed: %s\\n\", strerror(-ret)); goto out; } /* Finally, report back -- -C gives a parsable format */ if (!qflag) { t2 = tsub(t2, t1); printreport(\"discard\", &t2, offset, count, count, 1, Cflag); } out: return 0; } ", "target": 0}
{"func": "void memoryregionsetdirty(MemoryRegion *mr, hwaddr addr, hwaddr size) { assert(mr->terminates); cpuphysicalmemorysetdirtyrange(mr->ramaddr + addr, size, memoryregiongetdirtylogmask(mr)); } ", "target": 0}
{"func": "static void vncdisplayprintlocaladdr(VncDisplay *vd) { SocketAddressLegacy *addr; Error *err = NULL; if (!vd->nlsock) { return; } addr = qiochannelsocketgetlocaladdress(vd->lsock[0], &err); if (!addr) { return; } if (addr->type != SOCKETADDRESSLEGACYKINDINET) { qapifreeSocketAddressLegacy(addr); return; } errorprintfunlessqmp(\"VNC server running on %s:%s\\n\", addr->u.inet.data->host, addr->u.inet.data->port); qapifreeSocketAddressLegacy(addr); } ", "target": 0}
{"func": "static int v9fssynthlstat(FsContext *fsctx, V9fsPath *fspath, struct stat *stbuf) { V9fsSynthNode *node = *(V9fsSynthNode **)fspath->data; v9fssynthfillstatbuf(node, stbuf); return 0; } ", "target": 0}
{"func": "static avcold int qsvdecodeclose(AVCodecContext *avctx) { QSVOtherContext *s = avctx->privdata; ffqsvdecodeclose(&s->qsv); qsvclearbuffers(s); avfifofree(s->packetfifo); return 0; }", "target": 1}
{"func": "int ffasssplitoverridecodes(const ASSCodesCallbacks *callbacks, void *priv, const char *buf) { const char *text = NULL; char newline[2]; int textlen = 0; while (*buf) { if (text && callbacks->text && (sscanf(buf, \"\\\\%1[nN]\", newline) == 1 || !strncmp(buf, \"{\\\\\", 2))) { callbacks->text(priv, text, textlen); text = NULL; } if (sscanf(buf, \"\\\\%1[nN]\", newline) == 1) { if (callbacks->newline) callbacks->newline(priv, newline[0] == 'N'); buf += 2; } else if (!strncmp(buf, \"{\\\\\", 2)) { buf++; while (*buf == '\\\\') { char style[2], c[2], sep[2], cnum[2] = \"0\", tmp[128] = {0}; unsigned int color = 0xFFFFFFFF; int len, size = -1, an = -1, alpha = -1; int x1, y1, x2, y2, t1 = -1, t2 = -1; if (sscanf(buf, \"\\\\%1[bisu]%1[01\\\\}]%n\", style, c, &len) > 1) { int close = c[0] == '0' ? 1 : c[0] == '1' ? 0 : -1; len += close != -1; if (callbacks->style) callbacks->style(priv, style[0], close); } else if (sscanf(buf, \"\\\\c%1[\\\\}]%n\", sep, &len) > 0 || sscanf(buf, \"\\\\c&H%X&%1[\\\\}]%n\", &color, sep, &len) > 1 || sscanf(buf, \"\\\\%1[1234]c%1[\\\\}]%n\", cnum, sep, &len) > 1 || sscanf(buf, \"\\\\%1[1234]c&H%X&%1[\\\\}]%n\", cnum, &color, sep, &len) > 2) { if (callbacks->color) callbacks->color(priv, color, cnum[0] - '0'); } else if (sscanf(buf, \"\\\\alpha%1[\\\\}]%n\", sep, &len) > 0 || sscanf(buf, \"\\\\alpha&H%2X&%1[\\\\}]%n\", &alpha, sep, &len) > 1 || sscanf(buf, \"\\\\%1[1234]a%1[\\\\}]%n\", cnum, sep, &len) > 1 || sscanf(buf, \"\\\\%1[1234]a&H%2X&%1[\\\\}]%n\", cnum, &alpha, sep, &len) > 2) { if (callbacks->alpha) callbacks->alpha(priv, alpha, cnum[0] - '0'); } else if (sscanf(buf, \"\\\\fn%1[\\\\}]%n\", sep, &len) > 0 || sscanf(buf, \"\\\\fn%127[^\\\\}]%1[\\\\}]%n\", tmp, sep, &len) > 1) { if (callbacks->fontname) callbacks->fontname(priv, tmp[0] ? tmp : NULL); } else if (sscanf(buf, \"\\\\fs%1[\\\\}]%n\", sep, &len) > 0 || sscanf(buf, \"\\\\fs%u%1[\\\\}]%n\", &size, sep, &len) > 1) { if (callbacks->fontsize) callbacks->fontsize(priv, size); } else if (sscanf(buf, \"\\\\a%1[\\\\}]%n\", sep, &len) > 0 || sscanf(buf, \"\\\\a%2u%1[\\\\}]%n\", &an, sep, &len) > 1 || sscanf(buf, \"\\\\an%1[\\\\}]%n\", sep, &len) > 0 || sscanf(buf, \"\\\\an%1u%1[\\\\}]%n\", &an, sep, &len) > 1) { if (an != -1 && buf[2] != 'n') an = (an&3) + (an&4 ? 6 : an&8 ? 3 : 0); if (callbacks->alignment) callbacks->alignment(priv, an); } else if (sscanf(buf, \"\\\\r%1[\\\\}]%n\", sep, &len) > 0 || sscanf(buf, \"\\\\r%127[^\\\\}]%1[\\\\}]%n\", tmp, sep, &len) > 1) { if (callbacks->canceloverrides) callbacks->canceloverrides(priv, tmp); } else if (sscanf(buf, \"\\\\move(%d,%d,%d,%d)%1[\\\\}]%n\", &x1, &y1, &x2, &y2, sep, &len) > 4 || sscanf(buf, \"\\\\move(%d,%d,%d,%d,%d,%d)%1[\\\\}]%n\", &x1, &y1, &x2, &y2, &t1, &t2, sep, &len) > 6) { if (callbacks->move) callbacks->move(priv, x1, y1, x2, y2, t1, t2); } else if (sscanf(buf, \"\\\\pos(%d,%d)%1[\\\\}]%n\", &x1, &y1, sep, &len) > 2) { if (callbacks->move) callbacks->move(priv, x1, y1, x1, y1, -1, -1); } else if (sscanf(buf, \"\\\\org(%d,%d)%1[\\\\}]%n\", &x1, &y1, sep, &len) > 2) { if (callbacks->origin) callbacks->origin(priv, x1, y1); } else { len = strcspn(buf+1, \"\\\\}\") + 2; /* skip unknown code */ } buf += len - 1; } if (*buf++ != '}') return AVERRORINVALIDDATA; } else { if (!text) { text = buf; textlen = 1; } else textlen++; buf++; } } if (text && callbacks->text) callbacks->text(priv, text, textlen); if (callbacks->end) callbacks->end(priv); return 0; } ", "target": 1}
{"func": "static void computescalefactors(unsigned char scalecode[SBLIMIT], unsigned char scalefactors[SBLIMIT][3], int sbsamples[3][12][SBLIMIT], int sblimit) { int *p, vmax, v, n, i, j, k, code; int index, d1, d2; unsigned char *sf = &scalefactors[0][0]; for(j=0;j<sblimit;j++) { for(i=0;i<3;i++) { /* find the max absolute value */ p = &sbsamples[i][0][j]; vmax = abs(*p); for(k=1;k<12;k++) { p += SBLIMIT; v = abs(*p); if (v > vmax) vmax = v; } /* compute the scale factor index using log 2 computations */ if (vmax > 0) { n = avlog2(vmax); /* n is the position of the MSB of vmax. now use at most 2 compares to find the index */ index = (21 - n) * 3 - 3; if (index >= 0) { while (vmax <= scalefactortable[index+1]) index++; } else { index = 0; /* very unlikely case of overflow */ } } else { index = 62; /* value 63 is not allowed */ } #if 0 printf(\"%2d:%d in=%x %x %d\\n\", j, i, vmax, scalefactortable[index], index); #endif /* store the scale factor */ assert(index >=0 && index <= 63); sf[i] = index; } /* compute the transmission factor : look if the scale factors are close enough to each other */ d1 = scaledifftable[sf[0] - sf[1] + 64]; d2 = scaledifftable[sf[1] - sf[2] + 64]; /* handle the 25 cases */ switch(d1 * 5 + d2) { case 0*5+0: case 0*5+4: case 3*5+4: case 4*5+0: case 4*5+4: code = 0; break; case 0*5+1: case 0*5+2: case 4*5+1: case 4*5+2: code = 3; sf[2] = sf[1]; break; case 0*5+3: case 4*5+3: code = 3; sf[1] = sf[2]; break; case 1*5+0: case 1*5+4: case 2*5+4: code = 1; sf[1] = sf[0]; break; case 1*5+1: case 1*5+2: case 2*5+0: case 2*5+1: case 2*5+2: code = 2; sf[1] = sf[2] = sf[0]; break; case 2*5+3: case 3*5+3: code = 2; sf[0] = sf[1] = sf[2]; break; case 3*5+0: case 3*5+1: case 3*5+2: code = 2; sf[0] = sf[2] = sf[1]; break; case 1*5+3: code = 2; if (sf[0] > sf[2]) sf[0] = sf[2]; sf[1] = sf[2] = sf[0]; break; default: assert(0); //cannot happen code = 0; /* kill warning */ } #if 0 printf(\"%d: %2d %2d %2d %d %d -> %d\\n\", j, sf[0], sf[1], sf[2], d1, d2, code); #endif scalecode[j] = code; sf += 3; } } ", "target": 1}
{"func": "static void armv7mnvicclearpending(void *opaque, int irq) { NVICState *s = (NVICState *)opaque; VecInfo *vec; assert(irq > ARMV7MEXCPRESET && irq < s->numirq); vec = &s->vectors[irq]; tracenvicclearpending(irq, vec->enabled, vec->prio); if (vec->pending) { vec->pending = 0; nvicirqupdate(s); } } ", "target": 0}
{"func": "static void varargstring(void) { int i; struct { const char *decoded; } testcases[] = { { \"hello world\" }, { \"the quick brown fox jumped over the fence\" }, {} }; for (i = 0; testcases[i].decoded; i++) { QObject *obj; QString *str; obj = qobjectfromjsonf(\"%s\", testcases[i].decoded); gassert(obj != NULL); gassert(qobjecttype(obj) == QTYPEQSTRING); str = qobjecttoqstring(obj); gassert(strcmp(qstringgetstr(str), testcases[i].decoded) == 0); QDECREF(str); } } ", "target": 0}
{"func": "static int scsiqdevexit(DeviceState *qdev) { SCSIDevice *dev = SCSIDEVICE(qdev); if (dev->vmsentry) { qemudelvmchangestatehandler(dev->vmsentry); } scsidevicedestroy(dev); return 0; } ", "target": 0}
{"func": "static int gensubbitmap(TeletextContext *ctx, AVSubtitleRect *subrect, vbipage *page, int choptop) { int resx = page->columns * BITMAPCHARWIDTH; int resy = (page->rows - choptop) * BITMAPCHARHEIGHT; uint8t ci, cmax = 0; int ret; vbichar *vc = page->text + (choptop * page->columns); vbichar *vcend = page->text + (page->rows * page->columns); for (; vc < vcend; vc++) { if (vc->opacity != VBITRANSPARENTSPACE) { cmax = VBINBCOLORS; break; } } if (cmax == 0) { avlog(ctx, AVLOGDEBUG, \"dropping empty page %3x\\n\", page->pgno); subrect->type = SUBTITLENONE; return 0; } if ((ret = avpicturealloc(&subrect->pict, AVPIXFMTPAL8, resx, resy)) < 0) return ret; // Yes, we want to allocate the palette on our own because AVSubtitle works this way subrect->pict.data[1] = NULL; vbidrawvtpageregion(page, VBIPIXFMTPAL8, subrect->pict.data[0], subrect->pict.linesize[0], 0, choptop, page->columns, page->rows - choptop, /*reveal*/ 1, /*flash*/ 1); fixtransparency(ctx, subrect, page, choptop, cmax, resx, resy); subrect->x = ctx->xoffset; subrect->y = ctx->yoffset + choptop * BITMAPCHARHEIGHT; subrect->w = resx; subrect->h = resy; subrect->nbcolors = (int)cmax + 1; subrect->pict.data[1] = avmallocz(AVPALETTESIZE); if (!subrect->pict.data[1]) { avfreep(&subrect->pict.data[0]); return AVERROR(ENOMEM); } for (ci = 0; ci < cmax; ci++) { int r, g, b, a; r = VBIR(page->colormap[ci]); g = VBIG(page->colormap[ci]); b = VBIB(page->colormap[ci]); a = VBIA(page->colormap[ci]); ((uint32t *)subrect->pict.data[1])[ci] = RGBA(r, g, b, a); avdlog(ctx, \"palette %0x\\n\", ((uint32t *)subrect->pict.data[1])[ci]); } ((uint32t *)subrect->pict.data[1])[cmax] = RGBA(0, 0, 0, 0); subrect->type = SUBTITLEBITMAP; return 0; } ", "target": 0}
{"func": "int optdefault(const char *opt, const char *arg) { const AVOption *oc, *of, *os, *oswr; char optstripped[128]; const char *p; const AVClass *cc = avcodecgetclass(), *fc = avformatgetclass(), *sc, *swrclass; if (!(p = strchr(opt, ':'))) p = opt + strlen(opt); avstrlcpy(optstripped, opt, FFMIN(sizeof(optstripped), p - opt + 1)); if ((oc = avoptfind(&cc, optstripped, NULL, 0, AVOPTSEARCHCHILDREN | AVOPTSEARCHFAKEOBJ)) || ((opt[0] == 'v' || opt[0] == 'a' || opt[0] == 's') && (oc = avoptfind(&cc, opt + 1, NULL, 0, AVOPTSEARCHFAKEOBJ)))) avdictset(&codecopts, opt, arg, FLAGS(oc)); if ((of = avoptfind(&fc, opt, NULL, 0, AVOPTSEARCHCHILDREN | AVOPTSEARCHFAKEOBJ))) avdictset(&formatopts, opt, arg, FLAGS(of)); #if CONFIGSWSCALE sc = swsgetclass(); if ((os = avoptfind(&sc, opt, NULL, 0, AVOPTSEARCHCHILDREN | AVOPTSEARCHFAKEOBJ))) { // XXX we only support swsflags, not arbitrary sws options int ret = avoptset(swsopts, opt, arg, 0); if (ret < 0) { avlog(NULL, AVLOGERROR, \"Error setting option %s.\\n\", opt); return ret; } } #endif swrclass = swrgetclass(); if (!oc && !of && !os && (oswr = avoptfind(&swrclass, opt, NULL, 0, AVOPTSEARCHCHILDREN | AVOPTSEARCHFAKEOBJ))) { int ret = avoptset(swropts, opt, arg, 0); if (ret < 0) { avlog(NULL, AVLOGERROR, \"Error setting option %s.\\n\", opt); return ret; } } if (oc || of || os || oswr) return 0; avlog(NULL, AVLOGERROR, \"Unrecognized option '%s'\\n\", opt); return AVERROROPTIONNOTFOUND; } ", "target": 1}
{"func": "static void slaviomiscinit(targetphysaddrt base, targetphysaddrt aux1base, targetphysaddrt aux2base, qemuirq irq, qemuirq fdctc) { DeviceState *dev; SysBusDevice *s; dev = qdevcreate(NULL, \"slaviomisc\"); qdevinit(dev); s = sysbusfromqdev(dev); if (base) { /* 8 bit registers */ /* Slavio control */ sysbusmmiomap(s, 0, base + MISCCFG); /* Diagnostics */ sysbusmmiomap(s, 1, base + MISCDIAG); /* Modem control */ sysbusmmiomap(s, 2, base + MISCMDM); /* 16 bit registers */ /* ss600mp diag LEDs */ sysbusmmiomap(s, 3, base + MISCLEDS); /* 32 bit registers */ /* System control */ sysbusmmiomap(s, 4, base + MISCSYS); } if (aux1base) { /* AUX 1 (Misc System Functions) */ sysbusmmiomap(s, 5, aux1base); } if (aux2base) { /* AUX 2 (Software Powerdown Control) */ sysbusmmiomap(s, 6, aux2base); } sysbusconnectirq(s, 0, irq); sysbusconnectirq(s, 1, fdctc); qemusystempowerdown = qdevgetgpioin(dev, 0); } ", "target": 1}
{"func": "int checktmpred4x4mode(int mode, int mbx, int mby) { if (!mbx) { return mby ? VERTVP8PRED : DC129PRED; } else { return mby ? mode : HORVP8PRED; } } ", "target": 1}
{"func": "static struct ResampleContext *create(struct ResampleContext *c, int outrate, int inrate, int filtersize, int phaseshift, int linear, double cutoff, enum AVSampleFormat format, enum SwrFilterType filtertype, double kaiserbeta, double precision, int cheby, int exactrational){ soxrerrort error; soxrdatatypet type = format == AVSAMPLEFMTS16P? SOXRINT16S : format == AVSAMPLEFMTS16 ? SOXRINT16I : format == AVSAMPLEFMTS32P? SOXRINT32S : format == AVSAMPLEFMTS32 ? SOXRINT32I : format == AVSAMPLEFMTFLTP? SOXRFLOAT32S : format == AVSAMPLEFMTFLT ? SOXRFLOAT32I : format == AVSAMPLEFMTDBLP? SOXRFLOAT64S : format == AVSAMPLEFMTDBL ? SOXRFLOAT64I : (soxrdatatypet)-1; soxriospect iospec = soxriospec(type, type); soxrqualityspect qspec = soxrqualityspec((int)((precision-2)/4), (SOXRHIPRECCLOCK|SOXRROLLOFFNONE)*!!cheby); qspec.precision = linear? 0 : precision; #if !defined SOXRVERSION /* Deprecated @ March 2013: */ qspec.bwpc = cutoff? FFMAX(FFMIN(cutoff,.995),.8)*100 : qspec.bwpc; #else qspec.passbandend = cutoff? FFMAX(FFMIN(cutoff,.995),.8) : qspec.passbandend; #endif soxrdelete((soxrt)c); c = (struct ResampleContext *) soxrcreate(inrate, outrate, 0, &error, &iospec, &qspec, 0); if (!c) avlog(NULL, AVLOGERROR, \"soxrcreate: %s\\n\", error); return c; } ", "target": 1}
{"func": "static void bdrvputbuffer(void *opaque, const uint8t *buf, int64t pos, int size) { QEMUFileBdrv *s = opaque; bdrvpwrite(s->bs, s->baseoffset + pos, buf, size); } ", "target": 0}
{"func": "static void qemuclockinit(QEMUClockType type) { QEMUClock *clock = qemuclockptr(type); /* Assert that the clock of type TYPE has not been initialized yet. */ assert(mainlooptlg.tl[type] == NULL); clock->type = type; clock->enabled = (type == QEMUCLOCKVIRTUAL ? false : true); clock->last = INT64MIN; QLISTINIT(&clock->timerlists); notifierlistinit(&clock->resetnotifiers); mainlooptlg.tl[type] = timerlistnew(type, NULL, NULL); } ", "target": 0}
{"func": "static CharDriverState *qemuchropenpty(QemuOpts *opts) { CharDriverState *chr; PtyCharDriver *s; struct termios tty; int masterfd, slavefd, len; #if defined(OpenBSD) || defined(DragonFly) char ptyname[PATHMAX]; #define qptsname(x) ptyname #else char *ptyname = NULL; #define qptsname(x) ptsname(x) #endif if (openpty(&masterfd, &slavefd, ptyname, NULL, NULL) < 0) { return NULL; } /* Set raw attributes on the pty. */ tcgetattr(slavefd, &tty); cfmakeraw(&tty); tcsetattr(slavefd, TCSAFLUSH, &tty); close(slavefd); chr = gmalloc0(sizeof(CharDriverState)); len = strlen(qptsname(masterfd)) + 5; chr->filename = gmalloc(len); snprintf(chr->filename, len, \"pty:%s\", qptsname(masterfd)); qemuoptset(opts, \"path\", qptsname(masterfd)); fprintf(stderr, \"char device redirected to %s\\n\", qptsname(masterfd)); s = gmalloc0(sizeof(PtyCharDriver)); chr->opaque = s; chr->chrwrite = ptychrwrite; chr->chrupdatereadhandler = ptychrupdatereadhandler; chr->chrclose = ptychrclose; s->fd = masterfd; s->timer = qemunewtimerms(rtclock, ptychrtimer, chr); return chr; } ", "target": 1}
{"func": "uint32t HELPER(sigp)(CPUS390XState *env, uint64t ordercode, uint32t r1, uint64t cpuaddr) { int cc = SIGPCCORDERCODEACCEPTED; HELPERLOG(\"%s: %016\" PRIx64 \" %08x %016\" PRIx64 \"\\n\", func, ordercode, r1, cpuaddr); /* Remember: Use \"R1 or R1 + 1, whichever is the odd-numbered register\" as parameter (input). Status (output) is always R1. */ switch (ordercode) { case SIGPSETARCH: /* switch arch */ break; case SIGPSENSE: /* enumerate CPU status */ if (cpuaddr) { /* XXX implement when SMP comes */ return 3; } env->regs[r1] &= 0xffffffff00000000ULL; cc = 1; break; #if !defined(CONFIGUSERONLY) case SIGPRESTART: qemusystemresetrequest(); cpuloopexit(CPU(s390envgetcpu(env))); break; case SIGPSTOP: qemusystemshutdownrequest(); cpuloopexit(CPU(s390envgetcpu(env))); break; #endif default: /* unknown sigp */ fprintf(stderr, \"XXX unknown sigp: 0x%\" PRIx64 \"\\n\", ordercode); cc = SIGPCCNOTOPERATIONAL; } return cc; } ", "target": 0}
{"func": "yuv2rgb1ctemplate(SwsContext *c, const uint16t *buf0, const uint16t *ubuf0, const uint16t *ubuf1, const uint16t *vbuf0, const uint16t *vbuf1, const uint16t *abuf0, uint8t *dest, int dstW, int uvalpha, enum PixelFormat dstFormat, int flags, int y, enum PixelFormat target, int hasAlpha) { int i; if (uvalpha < 2048) { for (i = 0; i < (dstW >> 1); i++) { int Y1 = buf0[i * 2] >> 7; int Y2 = buf0[i * 2 + 1] >> 7; int U = ubuf1[i] >> 7; int V = vbuf1[i] >> 7; int A1, A2; const void *r = c->tablerV[V], *g = (c->tablegU[U] + c->tablegV[V]), *b = c->tablebU[U]; if (hasAlpha) { A1 = abuf0[i * 2 ] >> 7; A2 = abuf0[i * 2 + 1] >> 7; } yuv2rgbwrite(dest, i, Y1, Y2, U, V, hasAlpha ? A1 : 0, hasAlpha ? A2 : 0, r, g, b, y, target, hasAlpha); } } else { for (i = 0; i < (dstW >> 1); i++) { int Y1 = buf0[i * 2] >> 7; int Y2 = buf0[i * 2 + 1] >> 7; int U = (ubuf0[i] + ubuf1[i]) >> 8; int V = (vbuf0[i] + vbuf1[i]) >> 8; int A1, A2; const void *r = c->tablerV[V], *g = (c->tablegU[U] + c->tablegV[V]), *b = c->tablebU[U]; if (hasAlpha) { A1 = abuf0[i * 2 ] >> 7; A2 = abuf0[i * 2 + 1] >> 7; } yuv2rgbwrite(dest, i, Y1, Y2, U, V, hasAlpha ? A1 : 0, hasAlpha ? A2 : 0, r, g, b, y, target, hasAlpha); } } } ", "target": 0}
{"func": "static inline int onenandprogmain(OneNANDState *s, int sec, int secn, void *src) { int result = 0; if (secn > 0) { uint32t size = (uint32t)secn * 512; const uint8t *sp = (const uint8t *)src; uint8t *dp = 0; if (s->bdrvcur) { dp = gmalloc(size); if (!dp || bdrvread(s->bdrvcur, sec, dp, secn) < 0) { result = 1; } } else { if (sec + secn > s->secscur) { result = 1; } else { dp = (uint8t *)s->current + (sec << 9); } } if (!result) { uint32t i; for (i = 0; i < size; i++) { dp[i] &= sp[i]; } if (s->bdrvcur) { result = bdrvwrite(s->bdrvcur, sec, dp, secn) < 0; } } if (dp && s->bdrvcur) { gfree(dp); } } return result; } ", "target": 0}
{"func": "static int nbdreceivelist(QIOChannel *ioc, char **name, Error **errp) { uint64t magic; uint32t opt; uint32t type; uint32t len; uint32t namelen; int error; *name = NULL; if (readsync(ioc, &magic, sizeof(magic)) != sizeof(magic)) { errorsetg(errp, \"failed to read list option magic\"); return -1; } magic = be64tocpu(magic); if (magic != NBDREPMAGIC) { errorsetg(errp, \"Unexpected option list magic\"); return -1; } if (readsync(ioc, &opt, sizeof(opt)) != sizeof(opt)) { errorsetg(errp, \"failed to read list option\"); return -1; } opt = be32tocpu(opt); if (opt != NBDOPTLIST) { errorsetg(errp, \"Unexpected option type %\" PRIx32 \" expected %x\", opt, NBDOPTLIST); return -1; } if (readsync(ioc, &type, sizeof(type)) != sizeof(type)) { errorsetg(errp, \"failed to read list option type\"); return -1; } type = be32tocpu(type); error = nbdhandlereplyerr(ioc, opt, type, errp); if (error <= 0) { return error; } if (readsync(ioc, &len, sizeof(len)) != sizeof(len)) { errorsetg(errp, \"failed to read option length\"); return -1; } len = be32tocpu(len); if (type == NBDREPACK) { if (len != 0) { errorsetg(errp, \"length too long for option end\"); return -1; } } else if (type == NBDREPSERVER) { if (len < sizeof(namelen) || len > NBDMAXBUFFERSIZE) { errorsetg(errp, \"incorrect option length\"); return -1; } if (readsync(ioc, &namelen, sizeof(namelen)) != sizeof(namelen)) { errorsetg(errp, \"failed to read option name length\"); return -1; } namelen = be32tocpu(namelen); len -= sizeof(namelen); if (len < namelen) { errorsetg(errp, \"incorrect option name length\"); return -1; } if (namelen > 255) { errorsetg(errp, \"export name length too long %\" PRIu32, namelen); return -1; } *name = gnew0(char, namelen + 1); if (readsync(ioc, *name, namelen) != namelen) { errorsetg(errp, \"failed to read export name\"); gfree(*name); *name = NULL; return -1; } (*name)[namelen] = '\\0'; len -= namelen; if (len) { char *buf = gmalloc(len + 1); if (readsync(ioc, buf, len) != len) { errorsetg(errp, \"failed to read export description\"); gfree(*name); gfree(buf); *name = NULL; return -1; } buf[len] = '\\0'; TRACE(\"Ignoring export description: %s\", buf); gfree(buf); } } else { errorsetg(errp, \"Unexpected reply type %\" PRIx32 \" expected %x\", type, NBDREPSERVER); return -1; } return 1; } ", "target": 0}
{"func": "static int hwuploadqueryformats(AVFilterContext *avctx) { HWUploadContext *ctx = avctx->priv; AVHWFramesConstraints *constraints = NULL; const enum AVPixelFormat *inputpixfmts, *outputpixfmts; AVFilterFormats *inputformats = NULL; int err, i; if (!avctx->hwdevicectx) { avlog(ctx, AVLOGERROR, \"A hardware device reference is required \" \"to upload frames to.\\n\"); return AVERROR(EINVAL); } ctx->hwdeviceref = avbufferref(avctx->hwdevicectx); if (!ctx->hwdeviceref) return AVERROR(ENOMEM); ctx->hwdevice = (AVHWDeviceContext*)ctx->hwdeviceref->data; constraints = avhwdevicegethwframeconstraints(ctx->hwdeviceref, NULL); if (!constraints) { err = AVERROR(EINVAL); goto fail; } inputpixfmts = constraints->validswformats; outputpixfmts = constraints->validhwformats; inputformats = ffmakeformatlist(outputpixfmts); if (!inputformats) { err = AVERROR(ENOMEM); goto fail; } if (inputpixfmts) { for (i = 0; inputpixfmts[i] != AVPIXFMTNONE; i++) { err = ffaddformat(&inputformats, inputpixfmts[i]); if (err < 0) { ffformatsunref(&inputformats); goto fail; } } } ffformatsref(inputformats, &avctx->inputs[0]->outformats); ffformatsref(ffmakeformatlist(outputpixfmts), &avctx->outputs[0]->informats); avhwframeconstraintsfree(&constraints); return 0; fail: avbufferunref(&ctx->hwdeviceref); avhwframeconstraintsfree(&constraints); return err; } ", "target": 1}
{"func": "void errorsetgwin32(Error **errp, int win32err, const char *fmt, ...) { valist ap; char *msg1, *msg2; if (errp == NULL) { return; } vastart(ap, fmt); errorsetv(errp, ERRORCLASSGENERICERROR, fmt, ap); vaend(ap); if (win32err != 0) { msg1 = (*errp)->msg; msg2 = gwin32errormessage(win32err); (*errp)->msg = gstrdupprintf(\"%s: %s (error: %x)\", msg1, msg2, (unsigned)win32err); gfree(msg2); gfree(msg1); } } ", "target": 1}
{"func": "void ffMPVframeend(MpegEncContext *s) { int i; /* redraw edges for the frame if decoding didn't complete */ // just to make sure that all data is rendered. if (CONFIGMPEGXVMCDECODER && s->avctx->xvmcacceleration) { ffxvmcfieldend(s); } else if((s->errorcount || s->encoding || !(s->avctx->codec->capabilities&CODECCAPDRAWHORIZBAND)) && !s->avctx->hwaccel && !(s->avctx->codec->capabilities & CODECCAPHWACCELVDPAU) && s->unrestrictedmv && s->currentpicture.f.reference && !s->intraonly && !(s->flags & CODECFLAGEMUEDGE)) { int hshift = avpixfmtdescriptors[s->avctx->pixfmt].log2chromaw; int vshift = avpixfmtdescriptors[s->avctx->pixfmt].log2chromah; s->dsp.drawedges(s->currentpicture.f.data[0], s->currentpicture.f.linesize[0], s->hedgepos, s->vedgepos, EDGEWIDTH, EDGEWIDTH, EDGETOP | EDGEBOTTOM); s->dsp.drawedges(s->currentpicture.f.data[1], s->currentpicture.f.linesize[1], s->hedgepos >> hshift, s->vedgepos >> vshift, EDGEWIDTH >> hshift, EDGEWIDTH >> vshift, EDGETOP | EDGEBOTTOM); s->dsp.drawedges(s->currentpicture.f.data[2], s->currentpicture.f.linesize[2], s->hedgepos >> hshift, s->vedgepos >> vshift, EDGEWIDTH >> hshift, EDGEWIDTH >> vshift, EDGETOP | EDGEBOTTOM); } emmsc(); s->lastpicttype = s->picttype; s->lastlambdafor [s->picttype] = s->currentpictureptr->f.quality; if (s->picttype!= AVPICTURETYPEB) { s->lastnonbpicttype = s->picttype; } #if 0 /* copy back currentpicture variables */ for (i = 0; i < MAXPICTURECOUNT; i++) { if (s->picture[i].f.data[0] == s->currentpicture.f.data[0]) { s->picture[i] = s->currentpicture; break; } } assert(i < MAXPICTURECOUNT); #endif if (s->encoding) { /* release non-reference frames */ for (i = 0; i < s->picturecount; i++) { if (s->picture[i].f.data[0] && !s->picture[i].f.reference /* && s->picture[i].type != FFBUFFERTYPESHARED */) { freeframebuffer(s, &s->picture[i]); } } } // clear copies, to avoid confusion #if 0 memset(&s->lastpicture, 0, sizeof(Picture)); memset(&s->nextpicture, 0, sizeof(Picture)); memset(&s->currentpicture, 0, sizeof(Picture)); #endif s->avctx->codedframe = &s->currentpictureptr->f; if (s->codecid != AVCODECIDH264 && s->currentpicture.f.reference) { ffthreadreportprogress(&s->currentpictureptr->f, INTMAX, 0); } } ", "target": 1}
{"func": "int qemugetbuffer(QEMUFile *f, uint8t *buf, int size1) { int size, l; if (f->iswrite) abort(); size = size1; while (size > 0) { l = f->bufsize - f->bufindex; if (l == 0) { qemufillbuffer(f); l = f->bufsize - f->bufindex; if (l == 0) break; } if (l > size) l = size; memcpy(buf, f->buf + f->bufindex, l); f->bufindex += l; buf += l; size -= l; } return size1 - size; } ", "target": 0}
{"func": "void *romptr(targetphysaddrt addr) { Rom *rom; rom = findrom(addr); if (!rom || !rom->data) return NULL; return rom->data + (addr - rom->addr); } ", "target": 0}
{"func": "static void *dodatadecompress(void *opaque) { DecompressParam *param = opaque; unsigned long pagesize; while (!quitdecompthread) { qemumutexlock(&param->mutex); while (!param->start && !quitdecompthread) { qemucondwait(&param->cond, &param->mutex); } if (!quitdecompthread) { pagesize = TARGETPAGESIZE; /* uncompress() will return failed in some case, especially * when the page is dirted when doing the compression, it's * not a problem because the dirty page will be retransferred * and uncompress() won't break the data in other pages. */ uncompress((Bytef *)param->des, &pagesize, (const Bytef *)param->compbuf, param->len); } param->start = false; qemumutexunlock(&param->mutex); qemumutexlock(&decompdonelock); param->done = true; qemucondsignal(&decompdonecond); qemumutexunlock(&decompdonelock); } return NULL; } ", "target": 0}
{"func": "long dosigreturn(CPUSH4State *regs) { struct targetsigframe *frame; abiulong frameaddr; sigsett blocked; targetsigsett targetset; targetulong r0; int i; int err = 0; #if defined(DEBUGSIGNAL) fprintf(stderr, \"dosigreturn\\n\"); #endif frameaddr = regs->gregs[15]; if (!lockuserstruct(VERIFYREAD, frame, frameaddr, 1)) \tgoto badframe; getuser(targetset.sig[0], &frame->sc.oldmask); for(i = 1; i < TARGETNSIGWORDS; i++) { getuser(targetset.sig[i], &frame->extramask[i - 1]); } if (err) goto badframe; targettohostsigsetinternal(&blocked, &targetset); dosigprocmask(SIGSETMASK, &blocked, NULL); if (restoresigcontext(regs, &frame->sc, &r0)) goto badframe; unlockuserstruct(frame, frameaddr, 0); return r0; badframe: unlockuserstruct(frame, frameaddr, 0); forcesig(TARGETSIGSEGV); return 0; } ", "target": 1}
{"func": "static void apicresetcommon(DeviceState *dev) { APICCommonState *s = APICCOMMON(dev); APICCommonClass *info = APICCOMMONGETCLASS(s); bool bsp; bsp = cpuisbsp(s->cpu); s->apicbase = APICDEFAULTADDRESS | (bsp ? MSRIA32APICBASEBSP : 0) | MSRIA32APICBASEENABLE; s->vapicpaddr = 0; info->vapicbaseupdate(s); apicinitreset(dev); if (bsp) { /* * LINT0 delivery mode on CPU #0 is set to ExtInt at initialization * time typically by BIOS, so PIC interrupt can be delivered to the * processor when local APIC is enabled. */ s->lvt[APICLVTLINT0] = 0x700; } } ", "target": 0}
{"func": "static void omappwtinit(targetphysaddrt base, struct omapmpustates *s, omapclk clk) { int iomemtype; s->pwt.base = base; s->pwt.clk = clk; omappwtreset(s); iomemtype = cpuregisteriomemory(0, omappwtreadfn, omappwtwritefn, s); cpuregisterphysicalmemory(s->pwt.base, 0x800, iomemtype); } ", "target": 0}
{"func": "int vnchextilesendframebufferupdate(VncState *vs, int x, int y, int w, int h) { int i, j; int hasfg, hasbg; uint8t *lastfg, *lastbg; VncDisplay *vd = vs->vd; lastfg = (uint8t *) qemumalloc(vd->server->pf.bytesperpixel); lastbg = (uint8t *) qemumalloc(vd->server->pf.bytesperpixel); hasfg = hasbg = 0; for (j = y; j < (y + h); j += 16) { for (i = x; i < (x + w); i += 16) { vs->sendhextiletile(vs, i, j, MIN(16, x + w - i), MIN(16, y + h - j), lastbg, lastfg, &hasbg, &hasfg); } } free(lastfg); free(lastbg); return 1; } ", "target": 0}
{"func": "static int bdrvreadem(BlockDriverState *bs, int64t sectornum, uint8t *buf, int nbsectors) { int asyncret; BlockDriverAIOCB *acb; struct iovec iov; QEMUIOVector qiov; asyncret = NOTDONE; iov.iovbase = (void *)buf; iov.iovlen = nbsectors * BDRVSECTORSIZE; qemuiovecinitexternal(&qiov, &iov, 1); acb = bs->drv->bdrvaioreadv(bs, sectornum, &qiov, nbsectors, bdrvrwemcb, &asyncret); if (acb == NULL) { asyncret = -1; goto fail; } while (asyncret == NOTDONE) { qemuaiowait(); } fail: return asyncret; } ", "target": 0}
{"func": "static int kvmppcgetbookssregs(PowerPCCPU *cpu) { CPUPPCState *env = &cpu->env; struct kvmsregs sregs; int ret; int i; ret = kvmvcpuioctl(CPU(cpu), KVMGETSREGS, &sregs); if (ret < 0) { return ret; } if (!env->externalhtab) { ppcstoresdr1(env, sregs.u.s.sdr1); } /* Sync SLB */ #ifdef TARGETPPC64 /* * The packed SLB array we get from KVMGETSREGS only contains * information about valid entries. So we flush our internal copy * to get rid of stale ones, then put all valid SLB entries back * in. */ memset(env->slb, 0, sizeof(env->slb)); for (i = 0; i < ARRAYSIZE(env->slb); i++) { targetulong rb = sregs.u.s.ppc64.slb[i].slbe; targetulong rs = sregs.u.s.ppc64.slb[i].slbv; /* * Only restore valid entries */ if (rb & SLBESIDV) { ppcstoreslb(cpu, rb & 0xfff, rb & ~0xfffULL, rs); } } #endif /* Sync SRs */ for (i = 0; i < 16; i++) { env->sr[i] = sregs.u.s.ppc32.sr[i]; } /* Sync BATs */ for (i = 0; i < 8; i++) { env->DBAT[0][i] = sregs.u.s.ppc32.dbat[i] & 0xffffffff; env->DBAT[1][i] = sregs.u.s.ppc32.dbat[i] >> 32; env->IBAT[0][i] = sregs.u.s.ppc32.ibat[i] & 0xffffffff; env->IBAT[1][i] = sregs.u.s.ppc32.ibat[i] >> 32; } return 0; } ", "target": 0}
{"func": "static void integratorcpinit(ramaddrt ramsize, int vgaramsize, const char *bootdevice, DisplayState *ds, const char *kernelfilename, const char *kernelcmdline, const char *initrdfilename, const char *cpumodel) { CPUState *env; uint32t ramoffset; qemuirq *pic; qemuirq *cpupic; int sd; if (!cpumodel) cpumodel = \"arm926\"; env = cpuinit(cpumodel); if (!env) { fprintf(stderr, \"Unable to find CPU definition\\n\"); exit(1); } ramoffset = qemuramalloc(ramsize); /* ??? On a real system the first 1Mb is mapped as SSRAM or boot flash. */ /* ??? RAM should repeat to fill physical memory space. */ /* SDRAM at address zero*/ cpuregisterphysicalmemory(0, ramsize, ramoffset | IOMEMRAM); /* And again at address 0x80000000 */ cpuregisterphysicalmemory(0x80000000, ramsize, ramoffset | IOMEMRAM); integratorcminit(ramsize >> 20); cpupic = armpicinitcpu(env); pic = icppicinit(0x14000000, cpupic[ARMPICCPUIRQ], cpupic[ARMPICCPUFIQ]); icppicinit(0xca000000, pic[26], NULL); icppitinit(0x13000000, pic, 5); pl031init(0x15000000, pic[8]); pl011init(0x16000000, pic[1], serialhds[0], PL011ARM); pl011init(0x17000000, pic[2], serialhds[1], PL011ARM); icpcontrolinit(0xcb000000); pl050init(0x18000000, pic[3], 0); pl050init(0x19000000, pic[4], 1); sd = drivegetindex(IFSD, 0, 0); if (sd == -1) { fprintf(stderr, \"qemu: missing SecureDigital card\\n\"); exit(1); } pl181init(0x1c000000, drivestable[sd].bdrv, pic[23], pic[24]); if (ndtable[0].vlan) { if (ndtable[0].model == NULL || strcmp(ndtable[0].model, \"smc91c111\") == 0) { smc91c111init(&ndtable[0], 0xc8000000, pic[27]); } else if (strcmp(ndtable[0].model, \"?\") == 0) { fprintf(stderr, \"qemu: Supported NICs: smc91c111\\n\"); exit (1); } else { fprintf(stderr, \"qemu: Unsupported NIC: %s\\n\", ndtable[0].model); exit (1); } } pl110init(ds, 0xc0000000, pic[22], 0); integratorbinfo.ramsize = ramsize; integratorbinfo.kernelfilename = kernelfilename; integratorbinfo.kernelcmdline = kernelcmdline; integratorbinfo.initrdfilename = initrdfilename; armloadkernel(env, &integratorbinfo); } ", "target": 0}
{"func": "void hmpcont(Monitor *mon, const QDict *qdict) { BlockInfoList *bdevlist, *bdev; Error *err = NULL; bdevlist = qmpqueryblock(NULL); for (bdev = bdevlist; bdev; bdev = bdev->next) { if (keyismissing(bdev->value)) { monitorreadblockdevicekey(mon, bdev->value->device, hmpcontcb, NULL); goto out; } } qmpcont(&err); hmphandleerror(mon, &err); out: qapifreeBlockInfoList(bdevlist); } ", "target": 1}
{"func": "static int decode5(SANMVideoContext *ctx) { #if HAVEBIGENDIAN uint16t *frm; int npixels; #endif uint8t *dst = (uint8t*)ctx->frm0; if (rledecode(ctx, dst, ctx->bufsize)) return AVERRORINVALIDDATA; #if HAVEBIGENDIAN npixels = ctx->npixels; frm = ctx->frm0; while (npixels--) *frm++ = avbswap16(*frm); #endif return 0; } ", "target": 1}
{"func": "static void auxbridgeinit(Object *obj) { AUXTOI2CState *s = AUXTOI2C(obj); s->i2cbus = i2cinitbus(DEVICE(obj), \"aux-i2c\"); } ", "target": 1}
{"func": "static void bdrvcodrainbhcb(void *opaque) { BdrvCoDrainData *data = opaque; Coroutine *co = data->co; qemubhdelete(data->bh); bdrvdrainpoll(data->bs); data->done = true; qemucoroutineenter(co, NULL); } ", "target": 1}
{"func": "static int addgraphicsclient(Monitor *mon, const QDict *qdict, QObject **retdata) { const char *protocol = qdictgetstr(qdict, \"protocol\"); const char *fdname = qdictgetstr(qdict, \"fdname\"); CharDriverState *s; if (strcmp(protocol, \"spice\") == 0) { int fd = monitorgetfd(mon, fdname, NULL); int skipauth = qdictgettrybool(qdict, \"skipauth\", 0); int tls = qdictgettrybool(qdict, \"tls\", 0); if (!usingspice) { /* correct one? spice isn't a device ,,, */ qerrorreport(QERRDEVICENOTACTIVE, \"spice\"); return -1; } if (qemuspicedisplayaddclient(fd, skipauth, tls) < 0) { close(fd); } return 0; #ifdef CONFIGVNC } else if (strcmp(protocol, \"vnc\") == 0) { \tint fd = monitorgetfd(mon, fdname, NULL); int skipauth = qdictgettrybool(qdict, \"skipauth\", 0); \tvncdisplayaddclient(NULL, fd, skipauth); \treturn 0; #endif } else if ((s = qemuchrfind(protocol)) != NULL) { \tint fd = monitorgetfd(mon, fdname, NULL); \tif (qemuchraddclient(s, fd) < 0) { \t qerrorreport(QERRADDCLIENTFAILED); \t return -1; \t} \treturn 0; } qerrorreport(QERRINVALIDPARAMETER, \"protocol\"); return -1; } ", "target": 1}
{"func": "static gboolean qiochanneltlshandshakeio(QIOChannel *ioc, GIOCondition condition, gpointer userdata) { QIOTask *task = userdata; QIOChannelTLS *tioc = QIOCHANNELTLS( qiotaskgetsource(task)); qiochanneltlshandshaketask( tioc, task); objectunref(OBJECT(tioc)); return FALSE; } ", "target": 1}
{"func": "static void pmupdatesci(VT686PMState *s) { int scilevel, pmsts; pmsts = acpipm1evtgetsts(&s->ar, s->ar.tmr.overflowtime); scilevel = (((pmsts & s->ar.pm1.evt.en) & (ACPIBITMASKRTCLOCKENABLE | ACPIBITMASKPOWERBUTTONENABLE | ACPIBITMASKGLOBALLOCKENABLE | ACPIBITMASKTIMERENABLE)) != 0); qemusetirq(s->dev.irq[0], scilevel); /* schedule a timer interruption if needed */ acpipmtmrupdate(&s->ar, (s->ar.pm1.evt.en & ACPIBITMASKTIMERENABLE) && !(pmsts & ACPIBITMASKTIMERSTATUS)); } ", "target": 1}
{"func": "static void flatprintkeyprefix(WriterContext *wctx) { FlatContext *flat = wctx->priv; const struct section *parentsection = wctx->section[wctx->level-1]; printf(\"%s\", flat->sectionheader[wctx->level].str); if (parentsection->flags & SECTIONFLAGISARRAY) { int n = parentsection->id == SECTIONIDPACKETSANDFRAMES ? wctx->nbsectionpacketframe : wctx->nbitem[wctx->level-1]; printf(\"%d%s\", n, flat->sepstr); } } ", "target": 0}
{"func": "static int sdpparsefmtpconfigh264(AVStream *stream, PayloadContext *h264data, char *attr, char *value) { AVCodecContext *codec = stream->codec; assert(codec->codecid == CODECIDH264); assert(h264data != NULL); if (!strcmp(attr, \"packetization-mode\")) { avlog(codec, AVLOGDEBUG, \"RTP Packetization Mode: %d\\n\", atoi(value)); h264data->packetizationmode = atoi(value); /* * Packetization Mode: * 0 or not present: Single NAL mode (Only nals from 1-23 are allowed) * 1: Non-interleaved Mode: 1-23, 24 (STAP-A), 28 (FU-A) are allowed. * 2: Interleaved Mode: 25 (STAP-B), 26 (MTAP16), 27 (MTAP24), 28 (FU-A), * and 29 (FU-B) are allowed. */ if (h264data->packetizationmode > 1) avlog(codec, AVLOGERROR, \"Interleaved RTP mode is not supported yet.\"); } else if (!strcmp(attr, \"profile-level-id\")) { if (strlen(value) == 6) { char buffer[3]; // 6 characters=3 bytes, in hex. uint8t profileidc; uint8t profileiop; uint8t levelidc; buffer[0] = value[0]; buffer[1] = value[1]; buffer[2] = '\\0'; profileidc = strtol(buffer, NULL, 16); buffer[0] = value[2]; buffer[1] = value[3]; profileiop = strtol(buffer, NULL, 16); buffer[0] = value[4]; buffer[1] = value[5]; levelidc = strtol(buffer, NULL, 16); avlog(codec, AVLOGDEBUG, \"RTP Profile IDC: %x Profile IOP: %x Level: %x\\n\", profileidc, profileiop, levelidc); h264data->profileidc = profileidc; h264data->profileiop = profileiop; h264data->levelidc = levelidc; } } else if (!strcmp(attr, \"sprop-parameter-sets\")) { codec->extradatasize = 0; codec->extradata = NULL; while (*value) { char base64packet[1024]; uint8t decodedpacket[1024]; int packetsize; char *dst = base64packet; while (*value && *value != ',' && (dst - base64packet) < sizeof(base64packet) - 1) { *dst++ = *value++; } *dst++ = '\\0'; if (*value == ',') value++; packetsize = avbase64decode(decodedpacket, base64packet, sizeof(decodedpacket)); if (packetsize > 0) { uint8t *dest = avmalloc(packetsize + sizeof(startsequence) + codec->extradatasize + FFINPUTBUFFERPADDINGSIZE); if (!dest) { avlog(codec, AVLOGERROR, \"Unable to allocate memory for extradata!\"); return AVERROR(ENOMEM); } if (codec->extradatasize) { memcpy(dest, codec->extradata, codec->extradatasize); avfree(codec->extradata); } memcpy(dest + codec->extradatasize, startsequence, sizeof(startsequence)); memcpy(dest + codec->extradatasize + sizeof(startsequence), decodedpacket, packetsize); memset(dest + codec->extradatasize + sizeof(startsequence) + packetsize, 0, FFINPUTBUFFERPADDINGSIZE); codec->extradata = dest; codec->extradatasize += sizeof(startsequence) + packetsize; } } avlog(codec, AVLOGDEBUG, \"Extradata set to %p (size: %d)!\", codec->extradata, codec->extradatasize); } return 0; } ", "target": 1}
{"func": "static int qcow2create2(const char *filename, int64t totalsize, const char *backingfile, const char *backingformat, int flags, sizet clustersize, int prealloc, QEMUOptionParameter *options, int version, Error **errp) { /* Calculate clusterbits */ int clusterbits; clusterbits = ffs(clustersize) - 1; if (clusterbits < MINCLUSTERBITS || clusterbits > MAXCLUSTERBITS || (1 << clusterbits) != clustersize) { errorsetg(errp, \"Cluster size must be a power of two between %d and \" \"%dk\", 1 << MINCLUSTERBITS, 1 << (MAXCLUSTERBITS - 10)); return -EINVAL; /* * Open the image file and write a minimal qcow2 header. * * We keep things simple and start with a zero-sized image. We also * do without refcount blocks or a L1 table for now. We'll fix the * inconsistency later. * * We do need a refcount table because growing the refcount table means * allocating two new refcount blocks - the seconds of which would be at * 2 GB for 64k clusters, and we don't want to have a 2 GB initial file * size for any qcow2 image. */ BlockDriverState* bs; QCowHeader header; uint8t* refcounttable; Error *localerr = NULL; int ret; ret = bdrvcreatefile(filename, options, &localerr); if (ret < 0) { return ret; ret = bdrvfileopen(&bs, filename, NULL, BDRVORDWR, &localerr); if (ret < 0) { return ret; /* Write the header */ memset(&header, 0, sizeof(header)); header.magic = cputobe32(QCOWMAGIC); header.version = cputobe32(version); header.clusterbits = cputobe32(clusterbits); header.size = cputobe64(0); header.l1tableoffset = cputobe64(0); header.l1size = cputobe32(0); header.refcounttableoffset = cputobe64(clustersize); header.refcounttableclusters = cputobe32(1); header.refcountorder = cputobe32(3 + REFCOUNTSHIFT); header.headerlength = cputobe32(sizeof(header)); if (flags & BLOCKFLAGENCRYPT) { header.cryptmethod = cputobe32(QCOWCRYPTAES); } else { header.cryptmethod = cputobe32(QCOWCRYPTNONE); if (flags & BLOCKFLAGLAZYREFCOUNTS) { header.compatiblefeatures |= cputobe64(QCOW2COMPATLAZYREFCOUNTS); ret = bdrvpwrite(bs, 0, &header, sizeof(header)); if (ret < 0) { errorsetgerrno(errp, -ret, \"Could not write qcow2 header\"); /* Write an empty refcount table */ refcounttable = gmalloc0(clustersize); ret = bdrvpwrite(bs, clustersize, refcounttable, clustersize); gfree(refcounttable); if (ret < 0) { errorsetgerrno(errp, -ret, \"Could not write refcount table\"); /* * And now open the image and make it consistent first (i.e. increase the * refcount of the cluster that is occupied by the header and the refcount * table) */ BlockDriver* drv = bdrvfindformat(\"qcow2\"); assert(drv != NULL); BDRVORDWR | BDRVOCACHEWB | BDRVONOFLUSH, drv, &localerr); if (ret < 0) { ret = qcow2allocclusters(bs, 2 * clustersize); if (ret < 0) { errorsetgerrno(errp, -ret, \"Could not allocate clusters for qcow2 \" \"header and refcount table\"); } else if (ret != 0) { errorreport(\"Huh, first cluster in empty image is already in use?\"); abort(); /* Okay, now that we have a valid image, let's give it the right size */ ret = bdrvtruncate(bs, totalsize * BDRVSECTORSIZE); if (ret < 0) { errorsetgerrno(errp, -ret, \"Could not resize image\"); /* Want a backing file? There you go.*/ if (backingfile) { ret = bdrvchangebackingfile(bs, backingfile, backingformat); if (ret < 0) { errorsetgerrno(errp, -ret, \"Could not assign backing file '%s' \" \"with format '%s'\", backingfile, backingformat); /* And if we're supposed to preallocate metadata, do that now */ if (prealloc) { BDRVQcowState *s = bs->opaque; qemucomutexlock(&s->lock); ret = preallocate(bs); qemucomutexunlock(&s->lock); if (ret < 0) { errorsetgerrno(errp, -ret, \"Could not preallocate metadata\"); ret = 0; out: bdrvunref(bs); return ret;", "target": 1}
{"func": "static void idr(H264Context *h){ int i; ffh264removeallrefs(h); h->prevframenum= -1; h->prevframenumoffset= 0; h->prevpocmsb= 1<<16; h->prevpoclsb= 0; for (i = 0; i < MAXDELAYEDPICCOUNT; i++) h->lastpocs[i] = INTMIN; } ", "target": 0}
{"func": "static void intelhdammiowritel(void *opaque, targetphysaddrt addr, uint32t val) { IntelHDAState *d = opaque; const IntelHDAReg *reg = intelhdaregfind(d, addr); intelhdaregwrite(d, reg, val, 0xffffffff); } ", "target": 0}
{"func": "static void abortcodecexperimental(AVCodec *c, int encoder) { const char *codecstring = encoder ? \"encoder\" : \"decoder\"; AVCodec *codec; avlog(NULL, AVLOGFATAL, \"%s '%s' is experimental and might produce bad \" \"results.\\nAdd '-strict experimental' if you want to use it.\\n\", codecstring, c->name); codec = encoder ? avcodecfindencoder(c->id) : avcodecfinddecoder(c->id); if (!(codec->capabilities & CODECCAPEXPERIMENTAL)) avlog(NULL, AVLOGFATAL, \"Or use the non experimental %s '%s'.\\n\", codecstring, codec->name); exit(1); } ", "target": 1}
{"func": "static inline void hyscalefastc(SwsContext *c, int16t *dst, int dstWidth, const uint8t *src, int srcW, int xInc) { int i; unsigned int xpos=0; for (i=0;i<dstWidth;i++) { register unsigned int xx=xpos>>16; register unsigned int xalpha=(xpos&0xFFFF)>>9; dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha; xpos+=xInc; } }", "target": 1}
{"func": "static int standarddecodeimbs(VC9Context *v) { GetBitContext *gb = &v->s.gb; MpegEncContext *s = &v->s; int currentmb = 0; /* MB/Block Position info */ uint8t cbpcy[4], previouscbpcy[4], predictedcbpcy, *pcbpcy /* Pointer to skip some math */; /* Reset CBPCY predictors */ memset(v->previouslinecbpcy, 0, s->mbstride<<2); /* Select ttmb table depending on pq */ if (v->pq < 5) v->ttmbvlc = &vc9ttmbvlc[0]; else if (v->pq < 13) v->ttmbvlc = &vc9ttmbvlc[1]; else v->ttmbvlc = &vc9ttmbvlc[2]; for (s->mby=0; s->mby<s->mbheight; s->mby++) { /* Init CBPCY for line */ *((uint32t*)previouscbpcy) = 0x00000000; pcbpcy = v->previouslinecbpcy+4; for (s->mbx=0; s->mbx<s->mbwidth; s->mbx++, pcbpcy += 4) { /* Get CBPCY */ GETCBPCY(ffmsmp4mbivlc.table, MBINTRAVLCBITS); s->acpred = getbits(gb, 1); /* TODO: Decode blocks from that mb wrt cbpcy */ /* Update for next block */ #if TRACE > 2 avlog(s->avctx, AVLOGDEBUG, \"Block %4i: pcbpcy=%i%i%i%i, previouscbpcy=%i%i%i%i,\" \" cbpcy=%i%i%i%i\\n\", currentmb, pcbpcy[0], pcbpcy[1], pcbpcy[2], pcbpcy[3], previouscbpcy[0], previouscbpcy[1], previouscbpcy[2], previouscbpcy[3], cbpcy[0], cbpcy[1], cbpcy[2], cbpcy[3]); #endif *((uint32t*)pcbpcy) = *((uint32t*)previouscbpcy); *((uint32t*)previouscbpcy) = *((uint32t*)cbpcy); currentmb++; } } return 0; } ", "target": 1}
{"func": "static int jazzledinit(SysBusDevice *dev) { LedState *s = FROMSYSBUS(LedState, dev); memoryregioninitio(&s->iomem, &ledops, s, \"led\", 1); sysbusinitmmio(dev, &s->iomem); s->ds = graphicconsoleinit(jazzledupdatedisplay, jazzledinvalidatedisplay, jazzledscreendump, jazzledtextupdate, s); return 0; } ", "target": 1}
{"func": "dmaread(void *opaque, targetphysaddrt addr, unsigned int size) { struct fsdmactrl *ctrl = opaque; \tint c; \tuint32t r = 0; \tif (size != 4) { \t\tdmarinvalid(opaque, addr); \t} \t/* Make addr relative to this channel and bounded to nr regs. */ \tc = fschannel(addr); \taddr &= 0xff; \taddr >>= 2; \tswitch (addr) \t{ \t\tcase RWSTAT: \t\t\tr = ctrl->channels[c].state & 7; \t\t\tr |= ctrl->channels[c].eol << 5; \t\t\tr |= ctrl->channels[c].streamcmdsrc << 8; \t\t\tbreak; \t\tdefault: \t\t\tr = ctrl->channels[c].regs[addr]; \t\t\tD(printf (\"%s c=%d addr=\" TARGETFMTplx \"\\n\", \t\t\t\t func, c, addr)); \t\t\tbreak; \t} \treturn r; } ", "target": 0}
{"func": "static void pxa2xxdescriptorload(struct pxa2xxlcdcs *s) { struct pxaframedescriptors desc; targetphysaddrt descptr; int i; for (i = 0; i < PXALCDDMACHANS; i ++) { s->dmach[i].source = 0; if (!s->dmach[i].up) continue; if (s->dmach[i].branch & FBRBRA) { descptr = s->dmach[i].branch & FBRSRCADDR; if (s->dmach[i].branch & FBRBINT) pxa2xxdmabsset(s, i); s->dmach[i].branch &= ~FBRBRA; } else descptr = s->dmach[i].descriptor; if (!(descptr >= PXA2XXSDRAMBASE && descptr + sizeof(desc) <= PXA2XXSDRAMBASE + physramsize)) continue; cpuphysicalmemoryread(descptr, (void *)&desc, sizeof(desc)); s->dmach[i].descriptor = tswap32(desc.fdaddr); s->dmach[i].source = tswap32(desc.fsaddr); s->dmach[i].id = tswap32(desc.fidr); s->dmach[i].command = tswap32(desc.ldcmd); } } ", "target": 0}
{"func": "int spaprpopulatevdevice(VIOsPAPRBus *bus, void *fdt) { DeviceState *qdev, **qdevs; BusChild *kid; int i, num, ret = 0; /* Count qdevs on the bus list */ num = 0; QTAILQFOREACH(kid, &bus->bus.children, sibling) { num++; } /* Copy out into an array of pointers */ qdevs = gmalloc(sizeof(qdev) * num); num = 0; QTAILQFOREACH(kid, &bus->bus.children, sibling) { qdevs[num++] = kid->child; } /* Sort the array */ qsort(qdevs, num, sizeof(qdev), comparereg); /* Hack alert. Give the devices to libfdt in reverse order, we happen * to know that will mean they are in forward order in the tree. */ for (i = num - 1; i >= 0; i--) { VIOsPAPRDevice *dev = (VIOsPAPRDevice *)(qdevs[i]); ret = viomakedevnode(dev, fdt); if (ret < 0) { goto out; } } ret = 0; out: free(qdevs); return ret; } ", "target": 0}
{"func": "void ppctlbinvalidateall(CPUPPCState *env) { switch (env->mmumodel) { case POWERPCMMUSOFT6xx: case POWERPCMMUSOFT74xx: ppc6xxtlbinvalidateall(env); break; case POWERPCMMUSOFT4xx: case POWERPCMMUSOFT4xxZ: ppc4xxtlbinvalidateall(env); break; case POWERPCMMUREAL: cpuabort(env, \"No TLB for PowerPC 4xx in real mode\\n\"); break; case POWERPCMMUMPC8xx: /* XXX: TODO */ cpuabort(env, \"MPC8xx MMU model is not implemented\\n\"); break; case POWERPCMMUBOOKE: tlbflush(env, 1); break; case POWERPCMMUBOOKE206: booke206flushtlb(env, -1, 0); break; case POWERPCMMU32B: case POWERPCMMU601: #if defined(TARGETPPC64) case POWERPCMMU620: case POWERPCMMU64B: case POWERPCMMU206: #endif /* defined(TARGETPPC64) */ tlbflush(env, 1); break; default: /* XXX: TODO */ cpuabort(env, \"Unknown MMU model\\n\"); break; } }", "target": 1}
{"func": "uint32t HELPER(lcebr)(CPUS390XState *env, uint32t f1, uint32t f2) { env->fregs[f1].l.upper = float32chs(env->fregs[f2].l.upper); return setccnzf32(env->fregs[f1].l.upper); } ", "target": 0}
{"func": "static int openurl(AVFormatContext *s, AVIOContext **pb, const char *url, AVDictionary *opts, AVDictionary *opts2, int *ishttp) { HLSContext *c = s->privdata; AVDictionary *tmp = NULL; const char *protoname = NULL; int ret; avdictcopy(&tmp, opts, 0); avdictcopy(&tmp, opts2, 0); if (avstrstart(url, \"crypto\", NULL)) { if (url[6] == '+' || url[6] == ':') protoname = aviofindprotocolname(url + 7); } if (!protoname) protoname = aviofindprotocolname(url); if (!protoname) return AVERRORINVALIDDATA; // only http(s) & file are allowed if (avstrstart(protoname, \"file\", NULL)) { if (strcmp(c->allowedextensions, \"ALL\") && !avmatchext(url, c->allowedextensions)) { avlog(s, AVLOGERROR, \"Filename extension of \\'%s\\' is not a common multimedia extension, blocked for security reasons.\\n\" \"If you wish to override this adjust allowedextensions, you can set it to \\'ALL\\' to allow all\\n\", url); return AVERRORINVALIDDATA; } } else if (avstrstart(protoname, \"http\", NULL)) { ; } else return AVERRORINVALIDDATA; if (!strncmp(protoname, url, strlen(protoname)) && url[strlen(protoname)] == ':') ; else if (avstrstart(url, \"crypto\", NULL) && !strncmp(protoname, url + 7, strlen(protoname)) && url[7 + strlen(protoname)] == ':') ; else if (strcmp(protoname, \"file\") || !strncmp(url, \"file,\", 5)) return AVERRORINVALIDDATA; if (c->httppersistent && *pb && avstrstart(protoname, \"http\", NULL)) { ret = openurlkeepalive(c->ctx, pb, url); if (ret == AVERROREXIT) { return ret; } else if (ret < 0) { if (ret != AVERROREOF) avlog(s, AVLOGWARNING, \"keepalive request failed for '%s', retrying with new connection: %s\\n\", url, averr2str(ret)); ret = s->ioopen(s, pb, url, AVIOFLAGREAD, &tmp); } } else { ret = s->ioopen(s, pb, url, AVIOFLAGREAD, &tmp); } if (ret >= 0) { // update cookies on http response with setcookies. char *newcookies = NULL; if (!(s->flags & AVFMTFLAGCUSTOMIO)) avoptget(*pb, \"cookies\", AVOPTSEARCHCHILDREN, (uint8t**)&newcookies); if (newcookies) { avfree(c->cookies); c->cookies = newcookies; } avdictset(&opts, \"cookies\", c->cookies, 0); } avdictfree(&tmp); if (ishttp) *ishttp = avstrstart(protoname, \"http\", NULL); return ret; } ", "target": 0}
{"func": "static int qemurdmadestinit(RDMAContext *rdma, Error **errp) { int ret = -EINVAL, idx; struct rdmacmid *listenid; char ip[40] = \"unknown\"; struct rdmaaddrinfo *res; char portstr[16]; for (idx = 0; idx < RDMAWRIDMAX; idx++) { rdma->wrdata[idx].controllen = 0; rdma->wrdata[idx].controlcurr = NULL; } if (rdma->host == NULL) { ERROR(errp, \"RDMA host is not set!\"); rdma->errorstate = -EINVAL; return -1; } /* create CM channel */ rdma->channel = rdmacreateeventchannel(); if (!rdma->channel) { ERROR(errp, \"could not create rdma event channel\"); rdma->errorstate = -EINVAL; return -1; } /* create CM id */ ret = rdmacreateid(rdma->channel, &listenid, NULL, RDMAPSTCP); if (ret) { ERROR(errp, \"could not create cmid!\"); goto errdestinitcreatelistenid; } snprintf(portstr, 16, \"%d\", rdma->port); portstr[15] = '\\0'; if (rdma->host && strcmp(\"\", rdma->host)) { struct rdmaaddrinfo *e; ret = rdmagetaddrinfo(rdma->host, portstr, NULL, &res); if (ret < 0) { ERROR(errp, \"could not rdmagetaddrinfo address %s\", rdma->host); goto errdestinitbindaddr; } for (e = res; e != NULL; e = e->ainext) { inetntop(e->aifamily, &((struct sockaddrin *) e->aidstaddr)->sinaddr, ip, sizeof ip); traceqemurdmadestinittrying(rdma->host, ip); ret = rdmabindaddr(listenid, e->aidstaddr); if (!ret) { if (e->aifamily == AFINET6) { ret = qemurdmabrokenipv6kernel(errp, listenid->verbs); if (ret) { continue; } } goto listen; } } ERROR(errp, \"Error: could not rdmabindaddr!\"); goto errdestinitbindaddr; } else { ERROR(errp, \"migration host and port not specified!\"); ret = -EINVAL; goto errdestinitbindaddr; } listen: rdma->listenid = listenid; qemurdmadumpgid(\"destinit\", listenid); return 0; errdestinitbindaddr: rdmadestroyid(listenid); errdestinitcreatelistenid: rdmadestroyeventchannel(rdma->channel); rdma->channel = NULL; rdma->errorstate = ret; return ret; } ", "target": 0}
{"func": "int cksum(struct mbuf *m, int len) { \tregister uint16t *w; \tregister int sum = 0; \tregister int mlen = 0; \tint byteswapped = 0; \tunion { \t\tuint8t c[2]; \t\tuint16t s; \t} sutil; \tunion { \t\tuint16t s[2]; \t\tuint32t l; \t} lutil; \tif (m->mlen == 0) \t goto cont; \tw = mtod(m, uint16t *); \tmlen = m->mlen; \tif (len < mlen) \t mlen = len; #ifdef DEBUG \tlen -= mlen; #endif \t/* \t * Force to even boundary. \t */ \tif ((1 & (long) w) && (mlen > 0)) { \t\tREDUCE; \t\tsum <<= 8; \t\tsutil.c[0] = *(uint8t *)w; \t\tw = (uint16t *)((int8t *)w + 1); \t\tmlen--; \t\tbyteswapped = 1; \t} \t/* \t * Unroll the loop to make overhead from \t * branches &c small. \t */ \twhile ((mlen -= 32) >= 0) { \t\tsum += w[0]; sum += w[1]; sum += w[2]; sum += w[3]; \t\tsum += w[4]; sum += w[5]; sum += w[6]; sum += w[7]; \t\tsum += w[8]; sum += w[9]; sum += w[10]; sum += w[11]; \t\tsum += w[12]; sum += w[13]; sum += w[14]; sum += w[15]; \t\tw += 16; \t} \tmlen += 32; \twhile ((mlen -= 8) >= 0) { \t\tsum += w[0]; sum += w[1]; sum += w[2]; sum += w[3]; \t\tw += 4; \t} \tmlen += 8; \tif (mlen == 0 && byteswapped == 0) \t goto cont; \tREDUCE; \twhile ((mlen -= 2) >= 0) { \t\tsum += *w++; \t} \tif (byteswapped) { \t\tREDUCE; \t\tsum <<= 8; \t\tif (mlen == -1) { \t\t\tsutil.c[1] = *(uint8t *)w; \t\t\tsum += sutil.s; \t\t\tmlen = 0; \t\t} else \t\t mlen = -1; \t} else if (mlen == -1) \t sutil.c[0] = *(uint8t *)w; cont: #ifdef DEBUG \tif (len) { \t\tDEBUGERROR((dfd, \"cksum: out of data\\n\")); \t\tDEBUGERROR((dfd, \" len = %d\\n\", len)); \t} #endif \tif (mlen == -1) { \t\t/* The last mbuf has odd # of bytes. Follow the \t\t standard (the odd byte may be shifted left by 8 bits \t\t\t or not as determined by endian-ness of the machine) */ \t\tsutil.c[1] = 0; \t\tsum += sutil.s; \t} \tREDUCE; \treturn (~sum & 0xffff); } ", "target": 0}
{"func": "void addressspaceunmap(AddressSpace *as, void *buffer, targetphysaddrt len, int iswrite, targetphysaddrt accesslen) { if (buffer != bounce.buffer) { if (iswrite) { ramaddrt addr1 = qemuramaddrfromhostnofail(buffer); while (accesslen) { unsigned l; l = TARGETPAGESIZE; if (l > accesslen) l = accesslen; invalidateandsetdirty(addr1, l); addr1 += l; accesslen -= l; } } if (xenenabled()) { xeninvalidatemapcacheentry(buffer); } return; } if (iswrite) { addressspacewrite(as, bounce.addr, bounce.buffer, accesslen); } qemuvfree(bounce.buffer); bounce.buffer = NULL; cpunotifymapclients(); } ", "target": 0}
{"func": "static avcold int atrac3decodeinit(AVCodecContext *avctx) { int i, ret; int version, delay, samplesperframe, framefactor; const uint8t *edataptr = avctx->extradata; ATRAC3Context *q = avctx->privdata; if (avctx->channels <= 0 || avctx->channels > 2) { avlog(avctx, AVLOGERROR, \"Channel configuration error!\\n\"); } /* Take care of the codec-specific extradata. */ if (avctx->extradatasize == 14) { /* Parse the extradata, WAV format */ avlog(avctx, AVLOGDEBUG, \"[0-1] %d\\n\", bytestreamgetle16(&edataptr)); // Unknown value always 1 edataptr += 4; // samples per channel q->codingmode = bytestreamgetle16(&edataptr); avlog(avctx, AVLOGDEBUG,\"[8-9] %d\\n\", bytestreamgetle16(&edataptr)); //Dupe of coding mode framefactor = bytestreamgetle16(&edataptr); // Unknown always 1 avlog(avctx, AVLOGDEBUG,\"[12-13] %d\\n\", bytestreamgetle16(&edataptr)); // Unknown always 0 /* setup */ samplesperframe = SAMPLESPERFRAME * avctx->channels; version = 4; delay = 0x88E; q->codingmode = q->codingmode ? JOINTSTEREO : STEREO; q->scrambledstream = 0; if (avctx->blockalign != 96 * avctx->channels * framefactor && avctx->blockalign != 152 * avctx->channels * framefactor && avctx->blockalign != 192 * avctx->channels * framefactor) { avlog(avctx, AVLOGERROR, \"Unknown frame/channel/framefactor \" \"configuration %d/%d/%d\\n\", avctx->blockalign, avctx->channels, framefactor); return AVERRORINVALIDDATA; } } else if (avctx->extradatasize == 10) { /* Parse the extradata, RM format. */ version = bytestreamgetbe32(&edataptr); samplesperframe = bytestreamgetbe16(&edataptr); delay = bytestreamgetbe16(&edataptr); q->codingmode = bytestreamgetbe16(&edataptr); q->scrambledstream = 1; } else { avlog(NULL, AVLOGERROR, \"Unknown extradata size %d.\\n\", avctx->extradatasize); } /* Check the extradata */ if (version != 4) { avlog(avctx, AVLOGERROR, \"Version %d != 4.\\n\", version); return AVERRORINVALIDDATA; } if (samplesperframe != SAMPLESPERFRAME && samplesperframe != SAMPLESPERFRAME * 2) { avlog(avctx, AVLOGERROR, \"Unknown amount of samples per frame %d.\\n\", samplesperframe); return AVERRORINVALIDDATA; } if (delay != 0x88E) { avlog(avctx, AVLOGERROR, \"Unknown amount of delay %x != 0x88E.\\n\", delay); return AVERRORINVALIDDATA; } if (q->codingmode == STEREO) avlog(avctx, AVLOGDEBUG, \"Normal stereo detected.\\n\"); else if (q->codingmode == JOINTSTEREO) avlog(avctx, AVLOGDEBUG, \"Joint stereo detected.\\n\"); else { avlog(avctx, AVLOGERROR, \"Unknown channel coding mode %x!\\n\", q->codingmode); return AVERRORINVALIDDATA; } if (avctx->blockalign >= UINTMAX / 2) q->decodedbytesbuffer = avmallocz(FFALIGN(avctx->blockalign, 4) + FFINPUTBUFFERPADDINGSIZE); if (q->decodedbytesbuffer == NULL) return AVERROR(ENOMEM); avctx->samplefmt = AVSAMPLEFMTFLTP; /* initialize the MDCT transform */ if ((ret = ffmdctinit(&q->mdctctx, 9, 1, 1.0 / 32768)) < 0) { avlog(avctx, AVLOGERROR, \"Error initializing MDCT\\n\"); avfreep(&q->decodedbytesbuffer); return ret; } /* init the joint-stereo decoding data */ q->weightingdelay[0] = 0; q->weightingdelay[1] = 7; q->weightingdelay[2] = 0; q->weightingdelay[3] = 7; q->weightingdelay[4] = 0; q->weightingdelay[5] = 7; for (i = 0; i < 4; i++) { q->matrixcoeffindexprev[i] = 3; q->matrixcoeffindexnow[i] = 3; q->matrixcoeffindexnext[i] = 3; } avprivfloatdspinit(&q->fdsp, avctx->flags & CODECFLAGBITEXACT); fffmtconvertinit(&q->fmtconv, avctx); q->units = avmallocz(sizeof(*q->units) * avctx->channels); if (!q->units) { atrac3decodeclose(avctx); return AVERROR(ENOMEM); } avcodecgetframedefaults(&q->frame); avctx->codedframe = &q->frame; return 0; }", "target": 1}
{"func": "static uint32t unassignedmemreadl(void *opaque, targetphysaddrt addr) { #ifdef DEBUGUNASSIGNED printf(\"Unassigned mem read \" TARGETFMTplx \"\\n\", addr); #endif #if defined(TARGETALPHA) || defined(TARGETSPARC) || defined(TARGETMICROBLAZE) dounassignedaccess(addr, 0, 0, 0, 4); #endif return 0; } ", "target": 1}
{"func": "static TCGvi64 genaddqmsw(TCGvi64 a, TCGv b) { TCGvi64 tmp64 = tcgtempnewi64(); tcggenextui32i64(tmp64, b); deadtmp(b); tcggenshlii64(tmp64, tmp64, 32); tcggenaddi64(a, tmp64, a); tcgtempfreei64(tmp64); return a; } ", "target": 1}
{"func": "static void qvirtioscsipcifree(QVirtIOSCSI *vs) { int i; for (i = 0; i < vs->numqueues + 2; i++) { qvirtqueuecleanup(vs->dev->bus, vs->vq[i], vs->alloc); } pcallocuninit(vs->alloc); qvirtiopcidevicedisable(containerof(vs->dev, QVirtioPCIDevice, vdev)); gfree(vs->dev); qpcifreepc(vs->bus); gfree(vs); } ", "target": 0}
{"func": "void spaprclearpendingevents(sPAPRMachineState *spapr) { sPAPREventLogEntry *entry = NULL; QTAILQFOREACH(entry, &spapr->pendingevents, next) { QTAILQREMOVE(&spapr->pendingevents, entry, next); gfree(entry->extendedlog); gfree(entry); } } ", "target": 0}
{"func": "static void sclpsetwritemask(void) { WriteEventMask *sccb = (void*)sccb; sccb->h.length = sizeof(WriteEventMask); sccb->masklength = sizeof(unsigned int); sccb->receivemask = SCLPEVENTMASKMSGASCII; sccb->cpreceivemask = SCLPEVENTMASKMSGASCII; sccb->sendmask = SCLPEVENTMASKMSGASCII; sccb->cpsendmask = SCLPEVENTMASKMSGASCII; sclpservicecall(SCLPCMDWRITEEVENTMASK, sccb); } ", "target": 0}
{"func": "void jsonpropint(QJSON *json, const char *name, int64t val) { jsonemitelement(json, name); qstringappendint(json->str, val); } ", "target": 0}
{"func": "static void pmupdatesci(PIIX4PMState *s) { int scilevel, pmsts; pmsts = acpipm1evtgetsts(&s->ar); scilevel = (((pmsts & s->ar.pm1.evt.en) & (ACPIBITMASKRTCLOCKENABLE | ACPIBITMASKPOWERBUTTONENABLE | ACPIBITMASKGLOBALLOCKENABLE | ACPIBITMASKTIMERENABLE)) != 0) || (((s->ar.gpe.sts[0] & s->ar.gpe.en[0]) & (PIIX4PCIHOTPLUGSTATUS | PIIX4CPUHOTPLUGSTATUS)) != 0); qemusetirq(s->irq, scilevel); /* schedule a timer interruption if needed */ acpipmtmrupdate(&s->ar, (s->ar.pm1.evt.en & ACPIBITMASKTIMERENABLE) && !(pmsts & ACPIBITMASKTIMERSTATUS)); } ", "target": 0}
{"func": "static inline int wvgetvalueinteger(WavpackFrameContext *s, uint32t *crc, int S) { int bit; if(s->extrabits){ S <<= s->extrabits; if(s->gotextrabits){ S |= getbits(&s->gbextrabits, s->extrabits); *crc = *crc * 9 + (S&0xffff) * 3 + ((unsigned)S>>16); } } bit = (S & s->and) | s->or; return (((S + bit) << s->shift) - bit) << s->postshift; } ", "target": 1}
{"func": "static int mxfreadseek(AVFormatContext *s, int streamindex, int64t sampletime, int flags) { AVStream *st = s->streams[streamindex]; int64t seconds; MXFContext* mxf = s->privdata; int64t seekpos; int ret; MXFIndexTable *t; if (mxf->nbindextables <= 0) { if (!s->bitrate) return AVERRORINVALIDDATA; if (sampletime < 0) sampletime = 0; seconds = avrescale(sampletime, st->timebase.num, st->timebase.den); if ((ret = avioseek(s->pb, (s->bitrate * seconds) >> 3, SEEKSET)) < 0) return ret; ffupdatecurdts(s, st, sampletime); mxf->currenteditunit = sampletime; } else { t = &mxf->indextables[0]; /* clamp above zero, else ffindexsearchtimestamp() returns negative * this also means we allow seeking before the start */ sampletime = FFMAX(sampletime, 0); if (t->fakeindex) { /* behave as if we have a proper index */ if ((sampletime = ffindexsearchtimestamp(t->fakeindex, t->nbptses, sampletime, flags)) < 0) return sampletime; } else { /* no IndexEntryArray (one or more CBR segments) * make sure we don't seek past the end */ sampletime = FFMIN(sampletime, st->duration - 1); } if ((ret = mxfeditunitabsoluteoffset(mxf, t, sampletime, &sampletime, &seekpos, 1)) << 0) return ret; ffupdatecurdts(s, st, sampletime); mxf->currenteditunit = sampletime; avioseek(s->pb, seekpos, SEEKSET); } return 0; } ", "target": 0}
{"func": "ifstart(Slirp *slirp) { uint64t now = qemugetclockns(rtclock); int requeued = 0; \tstruct mbuf *ifm, *ifqt; \tDEBUGCALL(\"ifstart\"); \tif (slirp->ifqueued == 0) \t return; /* Nothing to do */ again: /* check if we can really output */ if (!slirpcanoutput(slirp->opaque)) return; \t/* \t * See which queue to get next packet from \t * If there's something in the fastq, select it immediately \t */ \tif (slirp->iffastq.ifqnext != &slirp->iffastq) { \t\tifm = slirp->iffastq.ifqnext; \t} else { \t\t/* Nothing on fastq, see if nextm is valid */ \t\tif (slirp->nextm != &slirp->ifbatchq) \t\t ifm = slirp->nextm; \t\telse \t\t ifm = slirp->ifbatchq.ifqnext; \t\t/* Set which packet to send on next iteration */ \t\tslirp->nextm = ifm->ifqnext; \t} \t/* Remove it from the queue */ \tifqt = ifm->ifqprev; \tremque(ifm); \tslirp->ifqueued--; \t/* If there are more packets for this session, re-queue them */ \tif (ifm->ifsnext != /* ifm->ifsprev != */ ifm) { \t\tinsque(ifm->ifsnext, ifqt); \t\tifsremque(ifm); \t} \t/* Update soqueued */ \tif (ifm->ifqso) { \t\tif (--ifm->ifqso->soqueued == 0) \t\t /* If there's no more queued, reset nqueued */ \t\t ifm->ifqso->sonqueued = 0; \t} if (ifm->expirationdate < now) { /* Expired */ mfree(ifm); } else { /* Encapsulate the packet for sending */ if (ifencap(slirp, ifm)) { mfree(ifm); } else { /* re-queue */ insque(ifm, ifqt); requeued++; } } \tif (slirp->ifqueued) \t goto again; slirp->ifqueued = requeued; } ", "target": 1}
{"func": "static void dumphumanimagecheck(ImageCheck *check) { if (!(check->corruptions || check->leaks || check->checkerrors)) { printf(\"No errors were found on the image.\\n\"); } else { if (check->corruptions) { printf(\"\\n%\" PRId64 \" errors were found on the image.\\n\" \"Data may be corrupted, or further writes to the image \" \"may corrupt it.\\n\", check->corruptions); } if (check->leaks) { printf(\"\\n%\" PRId64 \" leaked clusters were found on the image.\\n\" \"This means waste of disk space, but no harm to data.\\n\", check->leaks); } if (check->checkerrors) { printf(\"\\n%\" PRId64 \" internal errors have occurred during the check.\\n\", check->checkerrors); } } if (check->totalclusters != 0 && check->allocatedclusters != 0) { printf(\"%\" PRId64 \"/%\" PRId64 \"= %0.2f%% allocated, %0.2f%% fragmented\\n\", check->allocatedclusters, check->totalclusters, check->allocatedclusters * 100.0 / check->totalclusters, check->fragmentedclusters * 100.0 / check->allocatedclusters); } if (check->imageendoffset) { printf(\"Image end offset: %\" PRId64 \"\\n\", check->imageendoffset); } } ", "target": 0}
{"func": "float32 int32tofloat32( int32 a STATUSPARAM ) { flag zSign; if ( a == 0 ) return 0; if ( a == (sbits32) 0x80000000 ) return packFloat32( 1, 0x9E, 0 ); zSign = ( a < 0 ); return normalizeRoundAndPackFloat32( zSign, 0x9C, zSign ? - a : a STATUSVAR ); } ", "target": 0}
{"func": "static int vfiostarteventfdinjection(VFIOINTp *intp) { int ret; ret = vfiosettriggereventfd(intp, vfiointpinterrupt); if (ret) { errorreport(\"vfio: Error: Failed to pass IRQ fd to the driver: %m\"); } return ret; } ", "target": 1}
{"func": "static int bthidin(struct bthiddevices *s) { USBPacket p; p.pid = USBTOKENIN; p.devep = 1; p.data = s->datain.buffer; p.len = sizeof(s->datain.buffer); s->datain.len = s->usbdev->info->handledata(s->usbdev, &p); return s->datain.len; } ", "target": 1}
{"func": "void qmpinjectnmi(Error **errp) { #if defined(TARGETI386) CPUState *cs; CPUFOREACH(cs) { X86CPU *cpu = X86CPU(cs); if (!cpu->apicstate) { cpuinterrupt(cs, CPUINTERRUPTNMI); } else { apicdelivernmi(cpu->apicstate); } } #else nmimonitorhandle(monitorgetcpuindex(), errp); #endif } ", "target": 0}
{"func": "ethsetupip4fragmentation(const void *l2hdr, sizet l2hdrlen, void *l3hdr, sizet l3hdrlen, sizet l3payloadlen, sizet fragoffset, bool morefrags) { if (ethgetl3proto(l2hdr, l2hdrlen) == ETHPIP) { uint16t origflags; struct ipheader *iphdr = (struct ipheader *) l3hdr; uint16t fragoffunits = fragoffset / IPFRAGUNITSIZE; uint16t newipoff; assert(fragoffset % IPFRAGUNITSIZE == 0); assert((fragoffunits & ~IPOFFMASK) == 0); origflags = be16tocpu(iphdr->ipoff) & ~(IPOFFMASK|IPMF); newipoff = fragoffunits | origflags | (morefrags ? IPMF : 0); iphdr->ipoff = cputobe16(newipoff); iphdr->iplen = cputobe16(l3payloadlen + l3hdrlen); } } ", "target": 0}
{"func": "float32 HELPER(ucf64subs)(float32 a, float32 b, CPUUniCore32State *env) { return float32sub(a, b, &env->ucf64.fpstatus); } ", "target": 0}
{"func": "docksum(uint8t *dp, uint8t *de) { unsigned int bsum[2] = {0, 0}, i, sum; for (i = 1; dp < de; bsum[i^=1] += *dp++) ; sum = (bsum[0] << 8) + bsum[1]; sum = (sum >> 16) + (sum & 0xffff); return ~(sum + (sum >> 16)); } ", "target": 0}
{"func": "static void icssimplerealize(DeviceState *dev, Error **errp) { ICSState *ics = ICSSIMPLE(dev); if (!ics->nrirqs) { errorsetg(errp, \"Number of interrupts needs to be greater 0\"); return; } ics->irqs = gmalloc0(ics->nrirqs * sizeof(ICSIRQState)); ics->qirqs = qemuallocateirqs(icssimplesetirq, ics, ics->nrirqs); qemuregisterreset(icssimplereset, dev); } ", "target": 0}
{"func": "static void vncflush(VncState *vs) { if (vs->output.offset) \tvncclientwrite(vs); } ", "target": 0}
{"func": "static void dosubchannelwork(SubchDev *sch, ORB *orb) { SCSW *s = &sch->currstatus.scsw; if (s->ctrl & SCSWFCTLCLEARFUNC) { schhandleclearfunc(sch); } else if (s->ctrl & SCSWFCTLHALTFUNC) { schhandlehaltfunc(sch); } else if (s->ctrl & SCSWFCTLSTARTFUNC) { /* Triggered by both ssch and rsch. */ schhandlestartfunc(sch, orb); } else { /* Cannot happen. */ return; } cssinjectiointerrupt(sch); } ", "target": 0}
{"func": "static int sdsnapshotdelete(BlockDriverState *bs, const char *snapshotid, const char *name, Error **errp) { unsigned long snapid = 0; char snaptag[SDMAXVDITAGLEN]; Error *localerr = NULL; int fd, ret; char buf[SDMAXVDILEN + SDMAXVDITAGLEN]; BDRVSheepdogState *s = bs->opaque; unsigned int wlen = SDMAXVDILEN + SDMAXVDITAGLEN, rlen = 0; uint32t vid; SheepdogVdiReq hdr = { .opcode = SDOPDELVDI, .datalength = wlen, .flags = SDFLAGCMDWRITE, }; SheepdogVdiRsp *rsp = (SheepdogVdiRsp *)&hdr; if (!removeobjects(s)) { return -1; } memset(buf, 0, sizeof(buf)); memset(snaptag, 0, sizeof(snaptag)); pstrcpy(buf, SDMAXVDILEN, s->name); ret = qemustrtoul(snapshotid, NULL, 10, &snapid); if (ret || snapid > UINT32MAX) { errorsetg(errp, \"Invalid snapshot ID: %s\", snapshotid ? snapshotid : \"<null>\"); return -EINVAL; } if (snapid) { hdr.snapid = (uint32t) snapid; } else { pstrcpy(snaptag, sizeof(snaptag), snapshotid); pstrcpy(buf + SDMAXVDILEN, SDMAXVDITAGLEN, snaptag); } ret = findvdiname(s, s->name, snapid, snaptag, &vid, true, &localerr); if (ret) { return ret; } fd = connecttosdog(s, &localerr); if (fd < 0) { errorreporterr(localerr); return -1; } ret = doreq(fd, s->bs, (SheepdogReq *)&hdr, buf, &wlen, &rlen); closesocket(fd); if (ret) { return ret; } switch (rsp->result) { case SDRESNOVDI: errorreport(\"%s was already deleted\", s->name); case SDRESSUCCESS: break; default: errorreport(\"%s, %s\", sdstrerror(rsp->result), s->name); return -1; } return ret; } ", "target": 1}
{"func": "static int blocksaveiterate(QEMUFile *f, void *opaque) { int ret; int64t lastftell = qemuftell(f); DPRINTF(\"Enter save live iterate submitted %d transferred %d\\n\", blockmigstate.submitted, blockmigstate.transferred); ret = flushblks(f); if (ret) { return ret; } blkmigresetdirtycursor(); /* control the rate of transfer */ blkmiglock(); while ((blockmigstate.submitted + blockmigstate.readdone) * BLOCKSIZE < qemufilegetratelimit(f)) { blkmigunlock(); if (blockmigstate.bulkcompleted == 0) { /* first finish the bulk phase */ if (blkmigsavebulkedblock(f) == 0) { /* finished saving bulk on all devices */ blockmigstate.bulkcompleted = 1; } ret = 0; } else { /* Always called with iothread lock taken for * simplicity, blocksavecomplete also calls it. */ qemumutexlockiothread(); ret = blkmigsavedirtyblock(f, 1); qemumutexunlockiothread(); } if (ret < 0) { return ret; } blkmiglock(); if (ret != 0) { /* no more dirty blocks */ break; } } blkmigunlock(); ret = flushblks(f); if (ret) { return ret; } qemuputbe64(f, BLKMIGFLAGEOS); return qemuftell(f) - lastftell; } ", "target": 1}
{"func": "static avcold int fftinit(AVCodecContext *avctx, AC3MDCTContext *mdct, int ln) { int i, n, n2; float alpha; n = 1 << ln; n2 = n >> 1; FFALLOCORGOTO(avctx, mdct->costab, n2 * sizeof(*mdct->costab), fftallocfail); FFALLOCORGOTO(avctx, mdct->sintab, n2 * sizeof(*mdct->sintab), fftallocfail); for (i = 0; i < n2; i++) { alpha = 2.0 * MPI * i / n; mdct->costab[i] = FIX15(cos(alpha)); mdct->sintab[i] = FIX15(sin(alpha)); } return 0; fftallocfail: mdctend(mdct); return AVERROR(ENOMEM); } ", "target": 0}
{"func": "static alwaysinline void genintermediatecodeinternal (CPUState *env, TranslationBlock *tb, int searchpc) { #if defined ALPHADEBUGDISAS static int insncount; #endif DisasContext ctx, *ctxp = &ctx; targetulong pcstart; uint32t insn; uint16t *genopcend; CPUBreakpoint *bp; int j, lj = -1; int ret; int numinsns; int maxinsns; pcstart = tb->pc; genopcend = genopcbuf + OPCMAXSIZE; ctx.pc = pcstart; ctx.amask = env->amask; #if defined (CONFIGUSERONLY) ctx.memidx = 0; #else ctx.memidx = ((env->ps >> 3) & 3); ctx.palmode = env->ipr[IPREXCADDR] & 1; #endif numinsns = 0; maxinsns = tb->cflags & CFCOUNTMASK; if (maxinsns == 0) maxinsns = CFCOUNTMASK; genicountstart(); for (ret = 0; ret == 0;) { if (unlikely(!TAILQEMPTY(&env->breakpoints))) { TAILQFOREACH(bp, &env->breakpoints, entry) { if (bp->pc == ctx.pc) { genexcp(&ctx, EXCPDEBUG, 0); break; } } } if (searchpc) { j = genopcptr - genopcbuf; if (lj < j) { lj++; while (lj < j) genopcinstrstart[lj++] = 0; genopcpc[lj] = ctx.pc; genopcinstrstart[lj] = 1; genopcicount[lj] = numinsns; } } if (numinsns + 1 == maxinsns && (tb->cflags & CFLASTIO)) geniostart(); #if defined ALPHADEBUGDISAS insncount++; LOGDISAS(\"pc \" TARGETFMTlx \" memidx %d\\n\", ctx.pc, ctx.memidx); #endif insn = ldlcode(ctx.pc); #if defined ALPHADEBUGDISAS insncount++; LOGDISAS(\"opcode %08x %d\\n\", insn, insncount); #endif numinsns++; ctx.pc += 4; ret = translateone(ctxp, insn); if (ret != 0) break; /* if we reach a page boundary or are single stepping, stop * generation */ if (((ctx.pc & (TARGETPAGESIZE - 1)) == 0) || numinsns >= maxinsns) { break; } if (env->singlestepenabled) { genexcp(&ctx, EXCPDEBUG, 0); break; \t} #if defined (DOSINGLESTEP) break; #endif } if (ret != 1 && ret != 3) { tcggenmovii64(cpupc, ctx.pc); } #if defined (DOTBFLUSH) genhelpertbflush(); #endif if (tb->cflags & CFLASTIO) genioend(); /* Generate the return instruction */ tcggenexittb(0); genicountend(tb, numinsns); *genopcptr = INDEXopend; if (searchpc) { j = genopcptr - genopcbuf; lj++; while (lj <= j) genopcinstrstart[lj++] = 0; } else { tb->size = ctx.pc - pcstart; tb->icount = numinsns; } #if defined ALPHADEBUGDISAS logcpustatemask(CPULOGTBCPU, env, 0); if (qemuloglevelmask(CPULOGTBINASM)) { qemulog(\"IN: %s\\n\", lookupsymbol(pcstart)); logtargetdisas(pcstart, ctx.pc - pcstart, 1); qemulog(\"\\n\"); } #endif } ", "target": 1}
{"func": "VncJob *vncjobnew(VncState *vs) { VncJob *job = gmalloc0(sizeof(VncJob)); job->vs = vs; vnclockqueue(queue); QLISTINIT(&job->rectangles); vncunlockqueue(queue); return job; } ", "target": 1}
{"func": "static void nbdclientclosed(NBDClient *client) { nbfds--; if (nbfds == 0 && !persistent && state == RUNNING) { state = TERMINATE; } nbdupdateserverwatch(); nbdclientput(client); } ", "target": 1}
{"func": "static uint16t nvmecreatesq(NvmeCtrl *n, NvmeCmd *cmd) { NvmeSQueue *sq; NvmeCreateSq *c = (NvmeCreateSq *)cmd; uint16t cqid = le16tocpu(c->cqid); uint16t sqid = le16tocpu(c->sqid); uint16t qsize = le16tocpu(c->qsize); uint16t qflags = le16tocpu(c->sqflags); uint64t prp1 = le64tocpu(c->prp1); if (!cqid || nvmecheckcqid(n, cqid)) { return NVMEINVALIDCQID | NVMEDNR; } if (!sqid || !nvmechecksqid(n, sqid)) { return NVMEINVALIDQID | NVMEDNR; } if (!qsize || qsize > NVMECAPMQES(n->bar.cap)) { return NVMEMAXQSIZEEXCEEDED | NVMEDNR; } if (!prp1 || prp1 & (n->pagesize - 1)) { return NVMEINVALIDFIELD | NVMEDNR; } if (!(NVMESQFLAGSPC(qflags))) { return NVMEINVALIDFIELD | NVMEDNR; } sq = gmalloc0(sizeof(*sq)); nvmeinitsq(sq, n, prp1, sqid, cqid, qsize + 1); return NVMESUCCESS; } ", "target": 1}
{"func": "void ffac3bitalloccalcmask(AC3BitAllocParameters *s, int16t *bandpsd, int start, int end, int fastgain, int islfe, int dbamode, int dbansegs, uint8t *dbaoffsets, uint8t *dbalengths, uint8t *dbavalues, int16t *mask) { int16t excite[50]; /* excitation */ int bin, k; int bndstrt, bndend, begin, end1, tmp; int lowcomp, fastleak, slowleak; /* excitation function */ bndstrt = bintobandtab[start]; bndend = bintobandtab[end-1] + 1; if (bndstrt == 0) { lowcomp = 0; lowcomp = calclowcomp1(lowcomp, bandpsd[0], bandpsd[1], 384); excite[0] = bandpsd[0] - fastgain - lowcomp; lowcomp = calclowcomp1(lowcomp, bandpsd[1], bandpsd[2], 384); excite[1] = bandpsd[1] - fastgain - lowcomp; begin = 7; for (bin = 2; bin < 7; bin++) { if (!(islfe && bin == 6)) lowcomp = calclowcomp1(lowcomp, bandpsd[bin], bandpsd[bin+1], 384); fastleak = bandpsd[bin] - fastgain; slowleak = bandpsd[bin] - s->slowgain; excite[bin] = fastleak - lowcomp; if (!(islfe && bin == 6)) { if (bandpsd[bin] <= bandpsd[bin+1]) { begin = bin + 1; break; } } } end1=bndend; if (end1 > 22) end1=22; for (bin = begin; bin < end1; bin++) { if (!(islfe && bin == 6)) lowcomp = calclowcomp(lowcomp, bandpsd[bin], bandpsd[bin+1], bin); fastleak = FFMAX(fastleak - s->fastdecay, bandpsd[bin] - fastgain); slowleak = FFMAX(slowleak - s->slowdecay, bandpsd[bin] - s->slowgain); excite[bin] = FFMAX(fastleak - lowcomp, slowleak); } begin = 22; } else { /* coupling channel */ begin = bndstrt; fastleak = (s->cplfastleak << 8) + 768; slowleak = (s->cplslowleak << 8) + 768; } for (bin = begin; bin < bndend; bin++) { fastleak = FFMAX(fastleak - s->fastdecay, bandpsd[bin] - fastgain); slowleak = FFMAX(slowleak - s->slowdecay, bandpsd[bin] - s->slowgain); excite[bin] = FFMAX(fastleak, slowleak); } /* compute masking curve */ for (bin = bndstrt; bin < bndend; bin++) { tmp = s->dbperbit - bandpsd[bin]; if (tmp > 0) { excite[bin] += tmp >> 2; } mask[bin] = FFMAX(ffac3hearingthresholdtab[bin >> s->srshift][s->srcode], excite[bin]); } /* delta bit allocation */ if (dbamode == DBAREUSE || dbamode == DBANEW) { int band, seg, delta; band = 0; for (seg = 0; seg < FFMIN(8, dbansegs); seg++) { band = FFMIN(49, band + dbaoffsets[seg]); if (dbavalues[seg] >= 4) { delta = (dbavalues[seg] - 3) << 7; } else { delta = (dbavalues[seg] - 4) << 7; } for (k = 0; k < dbalengths[seg]; k++) { mask[band] += delta; band++; } } } } ", "target": 0}
{"func": "static inline void vmsvgaupdaterectdelayed(struct vmsvgastates *s, int x, int y, int w, int h) { struct vmsvgarects *rect = &s->redrawfifo[s->redrawfifolast ++]; s->redrawfifolast &= REDRAWFIFOLEN - 1; rect->x = x; rect->y = y; rect->w = w; rect->h = h; } ", "target": 0}
{"func": "static inline void tgenaddxcarry(DisasContext *dc, TCGv d) { \tif (dc->flagxknown) { \t\tif (dc->flagsx) { \t\t\tTCGv c; \t\t\tc = tcgtempnew(TCGTYPETL); \t\t\ttgenmovTNpreg(c, PRCCS); \t\t\t/* C flag is already at bit 0. */ \t\t\ttcggenanditl(c, c, CFLAG); \t\t\ttcggenaddtl(d, d, c); \t\t\ttcgtempfree(c); \t\t} \t} else { \t\tTCGv x, c; \t\tx = tcgtempnew(TCGTYPETL); \t\tc = tcgtempnew(TCGTYPETL); \t\ttgenmovTNpreg(x, PRCCS); \t\ttcggenmovtl(c, x); \t\t/* Propagate carry into d if X is set. Branch free. */ \t\ttcggenanditl(c, c, CFLAG); \t\ttcggenanditl(x, x, XFLAG); \t\ttcggenshritl(x, x, 4); \t\ttcggenandtl(x, x, c); \t\ttcggenaddtl(d, d, x); \t\ttcgtempfree(x); \t\ttcgtempfree(c); \t} } ", "target": 0}
{"func": "static void rtasstartcpu(sPAPREnvironment *spapr, uint32t token, uint32t nargs, targetulong args, uint32t nret, targetulong rets) { targetulong id, start, r3; CPUState *cs; if (nargs != 3 || nret != 1) { rtasst(rets, 0, -3); return; } id = rtasld(args, 0); start = rtasld(args, 1); r3 = rtasld(args, 2); cs = qemugetcpu(id); if (cs != NULL) { PowerPCCPU *cpu = POWERPCCPU(cs); CPUPPCState *env = &cpu->env; if (!cs->halted) { rtasst(rets, 0, -1); return; } /* This will make sure qemu state is up to date with kvm, and * mark it dirty so our changes get flushed back before the * new cpu enters */ kvmcpusynchronizestate(cs); env->msr = (1ULL << MSRSF) | (1ULL << MSRME); env->nip = start; env->gpr[3] = r3; cs->halted = 0; qemucpukick(cs); rtasst(rets, 0, 0); return; } /* Didn't find a matching cpu */ rtasst(rets, 0, -3); } ", "target": 0}
{"func": "int i2cstarttransfer(i2cbus *bus, int address, int recv) { DeviceState *qdev; i2cslave *slave = NULL; LISTFOREACH(qdev, &bus->qbus.children, sibling) { slave = I2CSLAVEFROMQDEV(qdev); if (slave->address == address) break; } if (!slave) return 1; /* If the bus is already busy, assume this is a repeated start condition. */ bus->currentdev = slave; slave->info->event(slave, recv ? I2CSTARTRECV : I2CSTARTSEND); return 0; } ", "target": 0}
{"func": "static int aascdecodeframe(AVCodecContext *avctx, void *data, int *datasize, AVPacket *avpkt) { const uint8t *buf = avpkt->data; int bufsize = avpkt->size; AascContext *s = avctx->privdata; int compr, i, stride; s->frame.reference = 3; s->frame.bufferhints = FFBUFFERHINTSVALID | FFBUFFERHINTSPRESERVE | FFBUFFERHINTSREUSABLE; if (avctx->regetbuffer(avctx, &s->frame)) { avlog(avctx, AVLOGERROR, \"regetbuffer() failed\\n\"); return -1; } compr = AVRL32(buf); buf += 4; bufsize -= 4; switch (avctx->codectag) { case MKTAG('A', 'A', 'S', '4'): bytestream2init(&s->gb, buf - 4, bufsize + 4); ffmsrledecode(avctx, (AVPicture*)&s->frame, 8, &s->gb); break; case MKTAG('A', 'A', 'S', 'C'): switch(compr){ case 0: stride = (avctx->width * 3 + 3) & ~3; for(i = avctx->height - 1; i >= 0; i--){ if(avctx->width*3 > bufsize){ avlog(avctx, AVLOGERROR, \"Next line is beyond buffer bounds\\n\"); break; } memcpy(s->frame.data[0] + i*s->frame.linesize[0], buf, avctx->width*3); buf += stride; bufsize -= stride; } break; case 1: bytestream2init(&s->gb, buf, bufsize); ffmsrledecode(avctx, (AVPicture*)&s->frame, 8, &s->gb); break; default: avlog(avctx, AVLOGERROR, \"Unknown compression type %d\\n\", compr); return -1; } break; default: avlog(avctx, AVLOGERROR, \"Unknown FourCC: %X\\n\", avctx->codectag); return -1; } *datasize = sizeof(AVFrame); *(AVFrame*)data = s->frame; /* report that the buffer was completely consumed */ return bufsize; } ", "target": 0}
{"func": "int ffh264fieldend(H264Context *h, int insetup) { AVCodecContext *const avctx = h->avctx; int err = 0; h->mby = 0; if (CONFIGH264VDPAUDECODER && h->avctx->codec->capabilities & CODECCAPHWACCELVDPAU) ffvdpauh264setreferenceframes(h); if (insetup || !(avctx->activethreadtype & FFTHREADFRAME)) { if (!h->droppable) { err = ffh264executerefpicmarking(h, h->mmco, h->mmcoindex); h->prevpocmsb = h->pocmsb; h->prevpoclsb = h->poclsb; } h->prevframenumoffset = h->framenumoffset; h->prevframenum = h->framenum; h->outputedpoc = h->nextoutputedpoc; } if (avctx->hwaccel) { if (avctx->hwaccel->endframe(avctx) < 0) avlog(avctx, AVLOGERROR, \"hardware accelerator failed to decode picture\\n\"); } if (CONFIGH264VDPAUDECODER && h->avctx->codec->capabilities & CODECCAPHWACCELVDPAU) ffvdpauh264picturecomplete(h); #if CONFIGERRORRESILIENCE /* * FIXME: Error handling code does not seem to support interlaced * when slices span multiple rows * The fferaddslice calls don't work right for bottom * fields; they cause massive erroneous error concealing * Error marking covers both fields (top and bottom). * This causes a mismatched s->errorcount * and a bad error table. Further, the error count goes to * INTMAX when called for bottom field, because mby is * past end by one (callers fault) and resyncmby != 0 * causes problems for the first MB line, too. */ if (!FIELDPICTURE(h) && h->currentslice && !h->sps.new) { ffh264seterpic(&h->er.curpic, h->curpicptr); fferframeend(&h->er); } #endif /* CONFIGERRORRESILIENCE */ if (!insetup && !h->droppable) ffthreadreportprogress(&h->curpicptr->tf, INTMAX, h->picturestructure == PICTBOTTOMFIELD); emmsc(); h->currentslice = 0; return err; }", "target": 1}
{"func": "static void sdhciwritedataport(SDHCIState *s, uint32t value, unsigned size) { unsigned i; /* Check that there is free space left in a buffer */ if (!(s->prnsts & SDHCSPACEAVAILABLE)) { ERRPRINT(\"Can't write to data buffer: buffer full\\n\"); return; } for (i = 0; i < size; i++) { s->fifobuffer[s->datacount] = value & 0xFF; s->datacount++; value >>= 8; if (s->datacount >= (s->blksize & 0x0fff)) { DPRINTL2(\"write buffer filled with %u bytes of data\\n\", s->datacount); s->datacount = 0; s->prnsts &= ~SDHCSPACEAVAILABLE; if (s->prnsts & SDHCDOINGWRITE) { sdhciwriteblocktocard(s); } } } } ", "target": 1}
{"func": "static CharDriverState *qemuchropenpipe(ChardevHostdev *opts) { const char *filename = opts->device; CharDriverState *chr; WinCharState *s; chr = qemuchralloc(); s = gmalloc0(sizeof(WinCharState)); chr->opaque = s; chr->chrwrite = winchrwrite; chr->chrclose = winchrclose; if (winchrpipeinit(chr, filename) < 0) { gfree(s); gfree(chr); return NULL; } return chr; } ", "target": 1}
{"func": "static int sbrhfcalcnpatches(AACContext *ac, SpectralBandReplication *sbr) { int i, k, sb = 0; int msb = sbr->k[0]; int usb = sbr->kx[1]; int goalsb = ((1000 << 11) + (sbr->samplerate >> 1)) / sbr->samplerate; sbr->numpatches = 0; if (goalsb < sbr->kx[1] + sbr->m[1]) { for (k = 0; sbr->fmaster[k] < goalsb; k++) ; } else k = sbr->nmaster; do { int odd = 0; for (i = k; i == k || sb > (sbr->k[0] - 1 + msb - odd); i--) { sb = sbr->fmaster[i]; odd = (sb + sbr->k[0]) & 1; } sbr->patchnumsubbands[sbr->numpatches] = FFMAX(sb - usb, 0); sbr->patchstartsubband[sbr->numpatches] = sbr->k[0] - odd - sbr->patchnumsubbands[sbr->numpatches]; if (sbr->patchnumsubbands[sbr->numpatches] > 0) { usb = sb; msb = sb; sbr->numpatches++; } else msb = sbr->kx[1]; if (sbr->fmaster[k] - sb < 3) k = sbr->nmaster; } while (sb != sbr->kx[1] + sbr->m[1]); if (sbr->patchnumsubbands[sbr->numpatches-1] < 3 && sbr->numpatches > 1) sbr->numpatches--; // Requirements (14496-3 sp04 p205) sets the maximum number of patches to 5 // However the Coding Technologies decoder check uses 6 patches if (sbr->numpatches > 6) { avlog(ac->avccontext, AVLOGERROR, \"Too many patches: %d\\n\", sbr->numpatches); return -1; } return 0; } ", "target": 1}
{"func": "static void *threadfunc(void *p) { struct threadinfo *info = p; rcuregisterthread(); atomicinc(&nreadythreads); while (!atomicmbread(&teststart)) { cpurelax(); } rcureadlock(); while (!atomicread(&teststop)) { info->r = xorshift64star(info->r); info->func(info); } rcureadunlock(); rcuunregisterthread(); return NULL; } ", "target": 0}
{"func": "static int httpstartreceivedata(HTTPContext *c) { int fd; if (c->stream->feedopened) return -1; /* Don't permit writing to this one */ if (c->stream->readonly) return -1; /* open feed */ fd = open(c->stream->feedfilename, ORDWR); if (fd < 0) { httplog(\"Error opening feeder file: %s\\n\", strerror(errno)); return -1; } c->feedfd = fd; if (c->stream->truncate) { /* truncate feed file */ ffmwritewriteindex(c->feedfd, FFMPACKETSIZE); ftruncate(c->feedfd, FFMPACKETSIZE); httplog(\"Truncating feed file '%s'\\n\", c->stream->feedfilename); } else { if ((c->stream->feedwriteindex = ffmreadwriteindex(fd)) < 0) { httplog(\"Error reading write index from feed file: %s\\n\", strerror(errno)); return -1; } } c->stream->feedwriteindex = FFMAX(ffmreadwriteindex(fd), FFMPACKETSIZE); c->stream->feedsize = lseek(fd, 0, SEEKEND); lseek(fd, 0, SEEKSET); /* init buffer input */ c->bufferptr = c->buffer; c->bufferend = c->buffer + FFMPACKETSIZE; c->stream->feedopened = 1; c->chunkedencoding = !!avstristr(c->buffer, \"Transfer-Encoding: chunked\"); return 0; } ", "target": 0}
{"func": "static int usbhostscandev(void *opaque, USBScanFunc *func) { FILE *f = NULL; char line[1024]; char buf[1024]; int busnum, addr, speed, devicecount, classid, productid, vendorid; char productname[512]; int ret = 0; if (!usbhostdevicepath) { perror(\"husb: USB Host Device Path not set\"); goto theend; } snprintf(line, sizeof(line), \"%s/devices\", usbhostdevicepath); f = fopen(line, \"r\"); if (!f) { perror(\"husb: cannot open devices file\"); goto theend; } devicecount = 0; busnum = addr = classid = productid = vendorid = 0; speed = -1; /* Can't get the speed from /[proc|dev]/bus/usb/devices */ for(;;) { if (fgets(line, sizeof(line), f) == NULL) { break; } if (strlen(line) > 0) { line[strlen(line) - 1] = '\\0'; } if (line[0] == 'T' && line[1] == ':') { if (devicecount && (vendorid || productid)) { /* New device. Add the previously discovered device. */ ret = func(opaque, busnum, addr, 0, classid, vendorid, productid, productname, speed); if (ret) { goto theend; } } if (gettagvalue(buf, sizeof(buf), line, \"Bus=\", \" \") < 0) { goto fail; } busnum = atoi(buf); if (gettagvalue(buf, sizeof(buf), line, \"Dev#=\", \" \") < 0) { goto fail; } addr = atoi(buf); if (gettagvalue(buf, sizeof(buf), line, \"Spd=\", \" \") < 0) { goto fail; } if (!strcmp(buf, \"5000\")) { speed = USBSPEEDSUPER; } else if (!strcmp(buf, \"480\")) { speed = USBSPEEDHIGH; } else if (!strcmp(buf, \"1.5\")) { speed = USBSPEEDLOW; } else { speed = USBSPEEDFULL; } productname[0] = '\\0'; classid = 0xff; devicecount++; productid = 0; vendorid = 0; } else if (line[0] == 'P' && line[1] == ':') { if (gettagvalue(buf, sizeof(buf), line, \"Vendor=\", \" \") < 0) { goto fail; } vendorid = strtoul(buf, NULL, 16); if (gettagvalue(buf, sizeof(buf), line, \"ProdID=\", \" \") < 0) { goto fail; } productid = strtoul(buf, NULL, 16); } else if (line[0] == 'S' && line[1] == ':') { if (gettagvalue(buf, sizeof(buf), line, \"Product=\", \"\") < 0) { goto fail; } pstrcpy(productname, sizeof(productname), buf); } else if (line[0] == 'D' && line[1] == ':') { if (gettagvalue(buf, sizeof(buf), line, \"Cls=\", \" (\") < 0) { goto fail; } classid = strtoul(buf, NULL, 16); } fail: ; } if (devicecount && (vendorid || productid)) { /* Add the last device. */ ret = func(opaque, busnum, addr, 0, classid, vendorid, productid, productname, speed); } theend: if (f) { fclose(f); } return ret; } ", "target": 0}
{"func": "static void ppccpuclassinit(ObjectClass *oc, void *data) { PowerPCCPUClass *pcc = POWERPCCPUCLASS(oc); CPUClass *cc = CPUCLASS(oc); DeviceClass *dc = DEVICECLASS(oc); pcc->parentrealize = dc->realize; pcc->pvr = CPUPOWERPCDEFAULTMASK; pcc->pvrmask = CPUPOWERPCDEFAULTMASK; pcc->interruptsbigendian = ppccpuinterruptsbigendianalways; dc->realize = ppccpurealizefn; dc->unrealize = ppccpuunrealizefn; pcc->parentreset = cc->reset; cc->reset = ppccpureset; cc->classbyname = ppccpuclassbyname; cc->haswork = ppccpuhaswork; cc->dointerrupt = ppccpudointerrupt; cc->dumpstate = ppccpudumpstate; cc->dumpstatistics = ppccpudumpstatistics; cc->setpc = ppccpusetpc; cc->gdbreadregister = ppccpugdbreadregister; cc->gdbwriteregister = ppccpugdbwriteregister; #ifdef CONFIGUSERONLY cc->handlemmufault = ppccpuhandlemmufault; #else cc->getphyspagedebug = ppccpugetphyspagedebug; cc->vmsd = &vmstateppccpu; #if defined(TARGETPPC64) cc->writeelf64note = ppc64cpuwriteelf64note; cc->writeelf64qemunote = ppc64cpuwriteelf64qemunote; #endif #endif cc->gdbnumcoreregs = 71; #ifdef USEAPPLEGDB cc->gdbreadregister = ppccpugdbreadregisterapple; cc->gdbwriteregister = ppccpugdbwriteregisterapple; cc->gdbnumcoreregs = 71 + 32; #endif #if defined(TARGETPPC64) cc->gdbcorexmlfile = \"power64-core.xml\"; #else cc->gdbcorexmlfile = \"power-core.xml\"; #endif #ifndef CONFIGUSERONLY cc->virtioisbigendian = ppccpuisbigendian; #endif dc->fwname = \"PowerPC,UNKNOWN\"; } ", "target": 0}
{"func": "qemudeliverpacket(VLANClientState *sender, const uint8t *buf, int size) { VLANClientState *vc; for (vc = sender->vlan->firstclient; vc != NULL; vc = vc->next) { if (vc != sender && !vc->linkdown) { vc->receive(vc->opaque, buf, size); } } } ", "target": 0}
{"func": "void ppc970irqinit (CPUState *env) { env->irqinputs = (void **)qemuallocateirqs(&ppc970setirq, env, 7); } ", "target": 1}
{"func": "static void dointerruptprotected(CPUX86State *env, int intno, int isint, int errorcode, unsigned int nexteip, int ishw) { SegmentCache *dt; targetulong ptr, ssp; int type, dpl, selector, ssdpl, cpl; int haserrorcode, newstack, shift; uint32t e1, e2, offset, ss = 0, esp, sse1 = 0, sse2 = 0; uint32t oldeip, spmask; int vm86 = env->eflags & VMMASK; haserrorcode = 0; if (!isint && !ishw) { haserrorcode = exceptionhaserrorcode(intno); } if (isint) { oldeip = nexteip; } else { oldeip = env->eip; } dt = &env->idt; if (intno * 8 + 7 > dt->limit) { raiseexceptionerr(env, EXCP0DGPF, intno * 8 + 2); } ptr = dt->base + intno * 8; e1 = cpuldlkernel(env, ptr); e2 = cpuldlkernel(env, ptr + 4); /* check gate type */ type = (e2 >> DESCTYPESHIFT) & 0x1f; switch (type) { case 5: /* task gate */ /* must do that check here to return the correct error code */ if (!(e2 & DESCPMASK)) { raiseexceptionerr(env, EXCP0BNOSEG, intno * 8 + 2); } switchtss(env, intno * 8, e1, e2, SWITCHTSSCALL, oldeip); if (haserrorcode) { int type; uint32t mask; /* push the error code */ type = (env->tr.flags >> DESCTYPESHIFT) & 0xf; shift = type >> 3; if (env->segs[RSS].flags & DESCBMASK) { mask = 0xffffffff; } else { mask = 0xffff; } esp = (env->regs[RESP] - (2 << shift)) & mask; ssp = env->segs[RSS].base + esp; if (shift) { cpustlkernel(env, ssp, errorcode); } else { cpustwkernel(env, ssp, errorcode); } SETESP(esp, mask); } return; case 6: /* 286 interrupt gate */ case 7: /* 286 trap gate */ case 14: /* 386 interrupt gate */ case 15: /* 386 trap gate */ break; default: raiseexceptionerr(env, EXCP0DGPF, intno * 8 + 2); break; } dpl = (e2 >> DESCDPLSHIFT) & 3; cpl = env->hflags & HFCPLMASK; /* check privilege if software int */ if (isint && dpl < cpl) { raiseexceptionerr(env, EXCP0DGPF, intno * 8 + 2); } /* check valid bit */ if (!(e2 & DESCPMASK)) { raiseexceptionerr(env, EXCP0BNOSEG, intno * 8 + 2); } selector = e1 >> 16; offset = (e2 & 0xffff0000) | (e1 & 0x0000ffff); if ((selector & 0xfffc) == 0) { raiseexceptionerr(env, EXCP0DGPF, 0); } if (loadsegment(env, &e1, &e2, selector) != 0) { raiseexceptionerr(env, EXCP0DGPF, selector & 0xfffc); } if (!(e2 & DESCSMASK) || !(e2 & (DESCCSMASK))) { raiseexceptionerr(env, EXCP0DGPF, selector & 0xfffc); } dpl = (e2 >> DESCDPLSHIFT) & 3; if (dpl > cpl) { raiseexceptionerr(env, EXCP0DGPF, selector & 0xfffc); } if (!(e2 & DESCPMASK)) { raiseexceptionerr(env, EXCP0BNOSEG, selector & 0xfffc); } if (!(e2 & DESCCMASK) && dpl < cpl) { /* to inner privilege */ getssespfromtss(env, &ss, &esp, dpl, 0); if ((ss & 0xfffc) == 0) { raiseexceptionerr(env, EXCP0ATSS, ss & 0xfffc); } if ((ss & 3) != dpl) { raiseexceptionerr(env, EXCP0ATSS, ss & 0xfffc); } if (loadsegment(env, &sse1, &sse2, ss) != 0) { raiseexceptionerr(env, EXCP0ATSS, ss & 0xfffc); } ssdpl = (sse2 >> DESCDPLSHIFT) & 3; if (ssdpl != dpl) { raiseexceptionerr(env, EXCP0ATSS, ss & 0xfffc); } if (!(sse2 & DESCSMASK) || (sse2 & DESCCSMASK) || !(sse2 & DESCWMASK)) { raiseexceptionerr(env, EXCP0ATSS, ss & 0xfffc); } if (!(sse2 & DESCPMASK)) { raiseexceptionerr(env, EXCP0ATSS, ss & 0xfffc); } newstack = 1; spmask = getspmask(sse2); ssp = getsegbase(sse1, sse2); } else if ((e2 & DESCCMASK) || dpl == cpl) { /* to same privilege */ if (vm86) { raiseexceptionerr(env, EXCP0DGPF, selector & 0xfffc); } newstack = 0; spmask = getspmask(env->segs[RSS].flags); ssp = env->segs[RSS].base; esp = env->regs[RESP]; dpl = cpl; } else { raiseexceptionerr(env, EXCP0DGPF, selector & 0xfffc); newstack = 0; /* avoid warning */ spmask = 0; /* avoid warning */ ssp = 0; /* avoid warning */ esp = 0; /* avoid warning */ } shift = type >> 3; #if 0 /* XXX: check that enough room is available */ pushsize = 6 + (newstack << 2) + (haserrorcode << 1); if (vm86) { pushsize += 8; } pushsize <<= shift; #endif if (shift == 1) { if (newstack) { if (vm86) { PUSHL(ssp, esp, spmask, env->segs[RGS].selector); PUSHL(ssp, esp, spmask, env->segs[RFS].selector); PUSHL(ssp, esp, spmask, env->segs[RDS].selector); PUSHL(ssp, esp, spmask, env->segs[RES].selector); } PUSHL(ssp, esp, spmask, env->segs[RSS].selector); PUSHL(ssp, esp, spmask, env->regs[RESP]); } PUSHL(ssp, esp, spmask, cpucomputeeflags(env)); PUSHL(ssp, esp, spmask, env->segs[RCS].selector); PUSHL(ssp, esp, spmask, oldeip); if (haserrorcode) { PUSHL(ssp, esp, spmask, errorcode); } } else { if (newstack) { if (vm86) { PUSHW(ssp, esp, spmask, env->segs[RGS].selector); PUSHW(ssp, esp, spmask, env->segs[RFS].selector); PUSHW(ssp, esp, spmask, env->segs[RDS].selector); PUSHW(ssp, esp, spmask, env->segs[RES].selector); } PUSHW(ssp, esp, spmask, env->segs[RSS].selector); PUSHW(ssp, esp, spmask, env->regs[RESP]); } PUSHW(ssp, esp, spmask, cpucomputeeflags(env)); PUSHW(ssp, esp, spmask, env->segs[RCS].selector); PUSHW(ssp, esp, spmask, oldeip); if (haserrorcode) { PUSHW(ssp, esp, spmask, errorcode); } } /* interrupt gate clear IF mask */ if ((type & 1) == 0) { env->eflags &= ~IFMASK; } env->eflags &= ~(TFMASK | VMMASK | RFMASK | NTMASK); if (newstack) { if (vm86) { cpux86loadsegcache(env, RES, 0, 0, 0, 0); cpux86loadsegcache(env, RDS, 0, 0, 0, 0); cpux86loadsegcache(env, RFS, 0, 0, 0, 0); cpux86loadsegcache(env, RGS, 0, 0, 0, 0); } ss = (ss & ~3) | dpl; cpux86loadsegcache(env, RSS, ss, ssp, getseglimit(sse1, sse2), sse2); } SETESP(esp, spmask); selector = (selector & ~3) | dpl; cpux86loadsegcache(env, RCS, selector, getsegbase(e1, e2), getseglimit(e1, e2), e2); env->eip = offset; } ", "target": 0}
{"func": "static void kvmstartvcpu(CPUState *env) { env->thread = qemumallocz(sizeof(QemuThread)); env->haltcond = qemumallocz(sizeof(QemuCond)); qemucondinit(env->haltcond); qemuthreadcreate(env->thread, kvmcputhreadfn, env); while (env->created == 0) qemucondtimedwait(&qemucpucond, &qemuglobalmutex, 100); } ", "target": 0}
{"func": "static hwaddr ppchash64ptegsearch(PowerPCCPU *cpu, hwaddr hash, bool secondary, targetulong ptem, ppchashpte64t *pte) { CPUPPCState *env = &cpu->env; int i; uint64t token; targetulong pte0, pte1; targetulong pteindex; pteindex = (hash & env->htabmask) * HPTESPERGROUP; token = ppchash64startaccess(cpu, pteindex); if (!token) { return -1; } for (i = 0; i < HPTESPERGROUP; i++) { pte0 = ppchash64loadhpte0(cpu, token, i); pte1 = ppchash64loadhpte1(cpu, token, i); if ((pte0 & HPTE64VVALID) && (secondary == !!(pte0 & HPTE64VSECONDARY)) && HPTE64VCOMPARE(pte0, ptem)) { pte->pte0 = pte0; pte->pte1 = pte1; ppchash64stopaccess(token); return (pteindex + i) * HASHPTESIZE64; } } ppchash64stopaccess(token); /* * We didn't find a valid entry. */ return -1; } ", "target": 0}
{"func": "static avcold int dcadecinit(AVCodecContext *avctx) { DCAContext *s = avctx->privdata; s->avctx = avctx; s->core.avctx = avctx; s->exss.avctx = avctx; s->xll.avctx = avctx; s->lbr.avctx = avctx; ffdcainitvlcs(); if (ffdcacoreinit(&s->core) < 0) return AVERROR(ENOMEM); if (ffdcalbrinit(&s->lbr) < 0) return AVERROR(ENOMEM); ffdcadspinit(&s->dcadsp); s->core.dcadsp = &s->dcadsp; s->xll.dcadsp = &s->dcadsp; s->lbr.dcadsp = &s->dcadsp; s->crctab = avcrcgettable(AVCRC16CCITT); switch (avctx->requestchannellayout & ~AVCHLAYOUTNATIVE) { case 0: s->requestchannellayout = 0; break; case AVCHLAYOUTSTEREO: case AVCHLAYOUTSTEREODOWNMIX: s->requestchannellayout = DCASPEAKERLAYOUTSTEREO; break; case AVCHLAYOUT5POINT0: s->requestchannellayout = DCASPEAKERLAYOUT5POINT0; break; case AVCHLAYOUT5POINT1: s->requestchannellayout = DCASPEAKERLAYOUT5POINT1; break; default: avlog(avctx, AVLOGWARNING, \"Invalid requestchannellayout\\n\"); break; } avctx->samplefmt = AVSAMPLEFMTS32P; avctx->bitsperrawsample = 24; return 0; } ", "target": 0}
{"func": "static int vorbisparsesetuphdrmappings(vorbiscontext *vc) { GetBitContext *gb=&vc->gb; uintfast8t i, j; vc->mappingcount=getbits(gb, 6)+1; vc->mappings=(vorbismapping *)avmallocz(vc->mappingcount * sizeof(vorbismapping)); AVDEBUG(\" There are %d mappings. \\n\", vc->mappingcount); for(i=0;i<vc->mappingcount;++i) { vorbismapping *mappingsetup=&vc->mappings[i]; if (getbits(gb, 16)) { avlog(vc->avccontext, AVLOGERROR, \"Other mappings than type 0 are not compliant with the Vorbis I specification. \\n\"); return 1; } if (getbits1(gb)) { mappingsetup->submaps=getbits(gb, 4)+1; } else { mappingsetup->submaps=1; } if (getbits1(gb)) { mappingsetup->couplingsteps=getbits(gb, 8)+1; mappingsetup->magnitude=(uintfast8t *)avmallocz(mappingsetup->couplingsteps * sizeof(uintfast8t)); mappingsetup->angle=(uintfast8t *)avmallocz(mappingsetup->couplingsteps * sizeof(uintfast8t)); for(j=0;j<mappingsetup->couplingsteps;++j) { mappingsetup->magnitude[j]=getbits(gb, ilog(vc->audiochannels-1)); mappingsetup->angle[j]=getbits(gb, ilog(vc->audiochannels-1)); // FIXME: sanity checks } } else { mappingsetup->couplingsteps=0; } AVDEBUG(\" %d mapping coupling steps: %d \\n\", i, mappingsetup->couplingsteps); if(getbits(gb, 2)) { avlog(vc->avccontext, AVLOGERROR, \"%d. mapping setup data invalid. \\n\", i); return 1; // following spec. } if (mappingsetup->submaps>1) { mappingsetup->mux=(uintfast8t *)avmallocz(vc->audiochannels * sizeof(uintfast8t)); for(j=0;j<vc->audiochannels;++j) { mappingsetup->mux[j]=getbits(gb, 4); } } for(j=0;j<mappingsetup->submaps;++j) { skipbits(gb, 8); // FIXME check? mappingsetup->submapfloor[j]=getbits(gb, 8); mappingsetup->submapresidue[j]=getbits(gb, 8); AVDEBUG(\" %d mapping %d submap : floor %d, residue %d \\n\", i, j, mappingsetup->submapfloor[j], mappingsetup->submapresidue[j]); } } return 0; } ", "target": 0}
{"func": "void stqtce(VIOsPAPRDevice *dev, uint64t taddr, uint64t val) { val = tswap64(val); spaprtcedmawrite(dev, taddr, &val, sizeof(val)); } ", "target": 1}
{"func": "static void vp6parsecoeffmodels(VP56Context *s) { VP56RangeCoder *c = &s->c; VP56Model *model = s->modelp; int defprob[11]; int node, cg, ctx, pos; int ct; /* code type */ int pt; /* plane type (0 for Y, 1 for U or V) */ memset(defprob, 0x80, sizeof(defprob)); for (pt=0; pt<2; pt++) for (node=0; node<11; node++) if (vp56racgetprob(c, vp6dccvpct[pt][node])) { defprob[node] = vp56racgetsnn(c, 7); model->coeffdccv[pt][node] = defprob[node]; } else if (s->framep[VP56FRAMECURRENT]->keyframe) { model->coeffdccv[pt][node] = defprob[node]; } if (vp56racget(c)) { for (pos=1; pos<64; pos++) if (vp56racgetprob(c, vp6coeffreorderpct[pos])) model->coeffreorder[pos] = vp56racgets(c, 4); vp6coeffordertableinit(s); } for (cg=0; cg<2; cg++) for (node=0; node<14; node++) if (vp56racgetprob(c, vp6runvpct[cg][node])) model->coeffrunv[cg][node] = vp56racgetsnn(c, 7); for (ct=0; ct<3; ct++) for (pt=0; pt<2; pt++) for (cg=0; cg<6; cg++) for (node=0; node<11; node++) if (vp56racgetprob(c, vp6ractpct[ct][pt][cg][node])) { defprob[node] = vp56racgetsnn(c, 7); model->coeffract[pt][ct][cg][node] = defprob[node]; } else if (s->framep[VP56FRAMECURRENT]->keyframe) { model->coeffract[pt][ct][cg][node] = defprob[node]; } if (s->usehuffman) { for (pt=0; pt<2; pt++) { vp6buildhufftree(s, model->coeffdccv[pt], vp6huffcoeffmap, 12, &s->dccvvlc[pt]); vp6buildhufftree(s, model->coeffrunv[pt], vp6huffrunmap, 9, &s->runvvlc[pt]); for (ct=0; ct<3; ct++) for (cg = 0; cg < 6; cg++) vp6buildhufftree(s, model->coeffract[pt][ct][cg], vp6huffcoeffmap, 12, &s->ractvlc[pt][ct][cg]); } memset(s->nbnull, 0, sizeof(s->nbnull)); } else { /* coeffdcct is a linear combination of coeffdccv */ for (pt=0; pt<2; pt++) for (ctx=0; ctx<3; ctx++) for (node=0; node<5; node++) model->coeffdcct[pt][ctx][node] = avclip(((model->coeffdccv[pt][node] * vp6dccvlc[ctx][node][0] + 128) >> 8) + vp6dccvlc[ctx][node][1], 1, 255); } } ", "target": 0}
{"func": "testoptsdictunvisited(void) { QemuOpts *opts; Visitor *v; UserDefOptions *userdef; opts = qemuoptsparse(qemufindopts(\"userdef\"), \"i64x=0,bogus=1\", false, &errorabort); v = optsvisitornew(opts); /* BUG: bogus should be diagnosed */ visittypeUserDefOptions(v, NULL, &userdef, &errorabort); visitfree(v); qemuoptsdel(opts); qapifreeUserDefOptions(userdef); } ", "target": 1}
{"func": "static int64t coroutinefn parallelscogetblockstatus(BlockDriverState *bs, int64t sectornum, int nbsectors, int *pnum) { BDRVParallelsState *s = bs->opaque; int64t offset; qemucomutexlock(&s->lock); offset = blockstatus(s, sectornum, nbsectors, pnum); qemucomutexunlock(&s->lock); if (offset < 0) { return 0; } return (offset << BDRVSECTORBITS) | BDRVBLOCKDATA | BDRVBLOCKOFFSETVALID; } ", "target": 0}
{"func": "void helper4xxtlbwehi (targetulong entry, targetulong val) { ppcembtlbt *tlb; targetulong page, end; LOGSWTLB(\"%s entry %d val \" TARGETFMTlx \"\\n\", func, (int)entry, val); entry &= 0x3F; tlb = &env->tlb[entry].tlbe; /* Invalidate previous TLB (if it's valid) */ if (tlb->prot & PAGEVALID) { end = tlb->EPN + tlb->size; LOGSWTLB(\"%s: invalidate old TLB %d start \" TARGETFMTlx \" end \" TARGETFMTlx \"\\n\", func, (int)entry, tlb->EPN, end); for (page = tlb->EPN; page < end; page += TARGETPAGESIZE) tlbflushpage(env, page); } tlb->size = booketlbtopagesize((val >> 7) & 0x7); /* We cannot handle TLB size < TARGETPAGESIZE. * If this ever occurs, one should use the ppcemb target instead * of the ppc or ppc64 one */ if ((val & 0x40) && tlb->size < TARGETPAGESIZE) { cpuabort(env, \"TLB size \" TARGETFMTlu \" < %u \" \"are not supported (%d)\\n\", tlb->size, TARGETPAGESIZE, (int)((val >> 7) & 0x7)); } tlb->EPN = val & ~(tlb->size - 1); if (val & 0x40) tlb->prot |= PAGEVALID; else tlb->prot &= ~PAGEVALID; if (val & 0x20) { /* XXX: TO BE FIXED */ cpuabort(env, \"Little-endian TLB entries are not supported by now\\n\"); } tlb->PID = env->spr[SPR40xPID]; /* PID */ LOGSWTLB(\"%s: set up TLB %d RPN \" TARGETFMTplx \" EPN \" TARGETFMTlx \" size \" TARGETFMTlx \" prot %c%c%c%c PID %d\\n\", func, (int)entry, tlb->RPN, tlb->EPN, tlb->size, tlb->prot & PAGEREAD ? 'r' : '-', tlb->prot & PAGEWRITE ? 'w' : '-', tlb->prot & PAGEEXEC ? 'x' : '-', tlb->prot & PAGEVALID ? 'v' : '-', (int)tlb->PID); /* Invalidate new TLB (if valid) */ if (tlb->prot & PAGEVALID) { end = tlb->EPN + tlb->size; LOGSWTLB(\"%s: invalidate TLB %d start \" TARGETFMTlx \" end \" TARGETFMTlx \"\\n\", func, (int)entry, tlb->EPN, end); for (page = tlb->EPN; page < end; page += TARGETPAGESIZE) tlbflushpage(env, page); } } ", "target": 0}
{"func": "static void kvmupdatemsiroutesall(void *private, bool global, uint32t index, uint32t mask) { int cnt = 0; MSIRouteEntry *entry; MSIMessage msg; /* TODO: explicit route update */ QLISTFOREACH(entry, &msiroutelist, list) { cnt++; msg = pcigetmsimessage(entry->dev, entry->vector); kvmirqchipupdatemsiroute(kvmstate, entry->virq, msg, entry->dev); } kvmirqchipcommitroutes(kvmstate); tracekvmx86updatemsiroutes(cnt); } ", "target": 1}
{"func": "static void sprwrite601ubatu (void *opaque, int sprn) { DisasContext *ctx = opaque; genopstore601batu((sprn - SPRIBAT0U) / 2); RETSTOP(ctx); } ", "target": 0}
{"func": "static void idesectorwrite(IDEState *s) { int64t sectornum; int ret, n, n1; s->status = READYSTAT | SEEKSTAT; sectornum = idegetsector(s); #if defined(DEBUGIDE) printf(\"write sector=%Ld\\n\", sectornum); #endif n = s->nsector; if (n > s->reqnbsectors) n = s->reqnbsectors; ret = bdrvwrite(s->bs, sectornum, s->iobuffer, n); s->nsector -= n; if (s->nsector == 0) { /* no more sector to write */ idetransferstop(s); } else { n1 = s->nsector; if (n1 > s->reqnbsectors) n1 = s->reqnbsectors; idetransferstart(s, s->iobuffer, 512 * n1, idesectorwrite); } idesetsector(s, sectornum + n); #ifdef TARGETI386 if (win2kinstallhack) { /* It seems there is a bug in the Windows 2000 installer HDD IDE driver which fills the disk with empty logs when the IDE write IRQ comes too early. This hack tries to correct that at the expense of slower write performances. Use this option only to install Windows 2000. You must disable it for normal use. */ qemumodtimer(s->sectorwritetimer, qemugetclock(vmclock) + (tickspersec / 1000)); } else #endif { idesetirq(s); } } ", "target": 0}
{"func": "AioContext *iohandlergetaiocontext(void) { iohandlerinit(); return iohandlerctx; } ", "target": 0}
{"func": "abilong dosyscall(void *cpuenv, int num, abilong arg1, abilong arg2, abilong arg3, abilong arg4, abilong arg5, abilong arg6) { abilong ret; struct stat st; struct statfs stfs; void *p; #ifdef DEBUG gemulog(\"syscall %d\", num); #endif if(dostrace) printsyscall(num, arg1, arg2, arg3, arg4, arg5, arg6); switch(num) { case TARGETNRexit: #ifdef CONFIGUSENPTL /* In old applications this may be used to implement exit(2). However in threaded applictions it is used for thread termination, and exitgroup is used for application termination. Do thread termination if we have more then one thread. */ /* FIXME: This probably breaks if a signal arrives. We should probably be disabling signals. */ if (firstcpu->nextcpu) { TaskState *ts; CPUState **lastp; CPUState *p; cpulistlock(); lastp = &firstcpu; p = firstcpu; while (p && p != (CPUState *)cpuenv) { lastp = &p->nextcpu; p = p->nextcpu; } /* If we didn't find the CPU for this thread then something is horribly wrong. */ if (!p) abort(); /* Remove the CPU from the list. */ *lastp = p->nextcpu; cpulistunlock(); ts = ((CPUState *)cpuenv)->opaque; if (ts->childtidptr) { putuseru32(0, ts->childtidptr); sysfutex(g2h(ts->childtidptr), FUTEXWAKE, INTMAX, NULL, NULL, 0); } /* TODO: Free CPU state. */ pthreadexit(NULL); } #endif #ifdef TARGETGPROF mcleanup(); #endif gdbexit(cpuenv, arg1); exit(arg1); ret = 0; /* avoid warning */ break; case TARGETNRread: if (arg3 == 0) ret = 0; else { if (!(p = lockuser(VERIFYWRITE, arg2, arg3, 0))) goto efault; ret = geterrno(read(arg1, p, arg3)); unlockuser(p, arg2, ret); } break; case TARGETNRwrite: if (!(p = lockuser(VERIFYREAD, arg2, arg3, 1))) goto efault; ret = geterrno(write(arg1, p, arg3)); unlockuser(p, arg2, 0); break; case TARGETNRopen: if (!(p = lockuserstring(arg1))) goto efault; ret = geterrno(open(path(p), targettohostbitmask(arg2, fcntlflagstbl), arg3)); unlockuser(p, arg1, 0); break; #if defined(TARGETNRopenat) && defined(NRopenat) case TARGETNRopenat: if (!(p = lockuserstring(arg2))) goto efault; ret = geterrno(sysopenat(arg1, path(p), targettohostbitmask(arg3, fcntlflagstbl), arg4)); unlockuser(p, arg2, 0); break; #endif case TARGETNRclose: ret = geterrno(close(arg1)); break; case TARGETNRbrk: ret = dobrk(arg1); break; case TARGETNRfork: ret = geterrno(dofork(cpuenv, SIGCHLD, 0, 0, 0, 0)); break; #ifdef TARGETNRwaitpid case TARGETNRwaitpid: { int status; ret = geterrno(waitpid(arg1, &status, arg3)); if (!iserror(ret) && arg2 && putusers32(hosttotargetwaitstatus(status), arg2)) goto efault; } break; #endif #ifdef TARGETNRwaitid case TARGETNRwaitid: { siginfot info; info.sipid = 0; ret = geterrno(waitid(arg1, arg2, &info, arg4)); if (!iserror(ret) && arg3 && info.sipid != 0) { if (!(p = lockuser(VERIFYWRITE, arg3, sizeof(targetsiginfot), 0))) goto efault; hosttotargetsiginfo(p, &info); unlockuser(p, arg3, sizeof(targetsiginfot)); } } break; #endif #ifdef TARGETNRcreat /* not on alpha */ case TARGETNRcreat: if (!(p = lockuserstring(arg1))) goto efault; ret = geterrno(creat(p, arg2)); unlockuser(p, arg1, 0); break; #endif case TARGETNRlink: { void * p2; p = lockuserstring(arg1); p2 = lockuserstring(arg2); if (!p || !p2) ret = -TARGETEFAULT; else ret = geterrno(link(p, p2)); unlockuser(p2, arg2, 0); unlockuser(p, arg1, 0); } break; #if defined(TARGETNRlinkat) && defined(NRlinkat) case TARGETNRlinkat: { void * p2 = NULL; if (!arg2 || !arg4) goto efault; p = lockuserstring(arg2); p2 = lockuserstring(arg4); if (!p || !p2) ret = -TARGETEFAULT; else ret = geterrno(syslinkat(arg1, p, arg3, p2, arg5)); unlockuser(p, arg2, 0); unlockuser(p2, arg4, 0); } break; #endif case TARGETNRunlink: if (!(p = lockuserstring(arg1))) goto efault; ret = geterrno(unlink(p)); unlockuser(p, arg1, 0); break; #if defined(TARGETNRunlinkat) && defined(NRunlinkat) case TARGETNRunlinkat: if (!(p = lockuserstring(arg2))) goto efault; ret = geterrno(sysunlinkat(arg1, p, arg3)); unlockuser(p, arg2, 0); break; #endif case TARGETNRexecve: { char **argp, **envp; int argc, envc; abiulong gp; abiulong guestargp; abiulong guestenvp; abiulong addr; char **q; argc = 0; guestargp = arg2; for (gp = guestargp; gp; gp += sizeof(abiulong)) { if (getuserual(addr, gp)) goto efault; if (!addr) break; argc++; } envc = 0; guestenvp = arg3; for (gp = guestenvp; gp; gp += sizeof(abiulong)) { if (getuserual(addr, gp)) goto efault; if (!addr) break; envc++; } argp = alloca((argc + 1) * sizeof(void *)); envp = alloca((envc + 1) * sizeof(void *)); for (gp = guestargp, q = argp; gp; gp += sizeof(abiulong), q++) { if (getuserual(addr, gp)) goto execveefault; if (!addr) break; if (!(*q = lockuserstring(addr))) goto execveefault; } *q = NULL; for (gp = guestenvp, q = envp; gp; gp += sizeof(abiulong), q++) { if (getuserual(addr, gp)) goto execveefault; if (!addr) break; if (!(*q = lockuserstring(addr))) goto execveefault; } *q = NULL; if (!(p = lockuserstring(arg1))) goto execveefault; ret = geterrno(execve(p, argp, envp)); unlockuser(p, arg1, 0); goto execveend; execveefault: ret = -TARGETEFAULT; execveend: for (gp = guestargp, q = argp; *q; gp += sizeof(abiulong), q++) { if (getuserual(addr, gp) || !addr) break; unlockuser(*q, addr, 0); } for (gp = guestenvp, q = envp; *q; gp += sizeof(abiulong), q++) { if (getuserual(addr, gp) || !addr) break; unlockuser(*q, addr, 0); } } break; case TARGETNRchdir: if (!(p = lockuserstring(arg1))) goto efault; ret = geterrno(chdir(p)); unlockuser(p, arg1, 0); break; #ifdef TARGETNRtime case TARGETNRtime: { timet hosttime; ret = geterrno(time(&hosttime)); if (!iserror(ret) && arg1 && putusersal(hosttime, arg1)) goto efault; } break; #endif case TARGETNRmknod: if (!(p = lockuserstring(arg1))) goto efault; ret = geterrno(mknod(p, arg2, arg3)); unlockuser(p, arg1, 0); break; #if defined(TARGETNRmknodat) && defined(NRmknodat) case TARGETNRmknodat: if (!(p = lockuserstring(arg2))) goto efault; ret = geterrno(sysmknodat(arg1, p, arg3, arg4)); unlockuser(p, arg2, 0); break; #endif case TARGETNRchmod: if (!(p = lockuserstring(arg1))) goto efault; ret = geterrno(chmod(p, arg2)); unlockuser(p, arg1, 0); break; #ifdef TARGETNRbreak case TARGETNRbreak: goto unimplemented; #endif #ifdef TARGETNRoldstat case TARGETNRoldstat: goto unimplemented; #endif case TARGETNRlseek: ret = geterrno(lseek(arg1, arg2, arg3)); break; #ifdef TARGETNRgetxpid case TARGETNRgetxpid: #else case TARGETNRgetpid: #endif ret = geterrno(getpid()); break; case TARGETNRmount: \t\t{ \t\t\t/* need to look at the data field */ \t\t\tvoid *p2, *p3; \t\t\tp = lockuserstring(arg1); \t\t\tp2 = lockuserstring(arg2); \t\t\tp3 = lockuserstring(arg3); if (!p || !p2 || !p3) ret = -TARGETEFAULT; else { /* FIXME - arg5 should be locked, but it isn't clear how to * do that since it's not guaranteed to be a NULL-terminated * string. */ if ( ! arg5 ) ret = geterrno(mount(p, p2, p3, (unsigned long)arg4, NULL)); else ret = geterrno(mount(p, p2, p3, (unsigned long)arg4, g2h(arg5))); } unlockuser(p, arg1, 0); unlockuser(p2, arg2, 0); unlockuser(p3, arg3, 0); \t\t\tbreak; \t\t} #ifdef TARGETNRumount case TARGETNRumount: if (!(p = lockuserstring(arg1))) goto efault; ret = geterrno(umount(p)); unlockuser(p, arg1, 0); break; #endif #ifdef TARGETNRstime /* not on alpha */ case TARGETNRstime: { timet hosttime; if (getusersal(hosttime, arg1)) goto efault; ret = geterrno(stime(&hosttime)); } break; #endif case TARGETNRptrace: goto unimplemented; #ifdef TARGETNRalarm /* not on alpha */ case TARGETNRalarm: ret = alarm(arg1); break; #endif #ifdef TARGETNRoldfstat case TARGETNRoldfstat: goto unimplemented; #endif #ifdef TARGETNRpause /* not on alpha */ case TARGETNRpause: ret = geterrno(pause()); break; #endif #ifdef TARGETNRutime case TARGETNRutime: { struct utimbuf tbuf, *hosttbuf; struct targetutimbuf *targettbuf; if (arg2) { if (!lockuserstruct(VERIFYREAD, targettbuf, arg2, 1)) goto efault; tbuf.actime = tswapl(targettbuf->actime); tbuf.modtime = tswapl(targettbuf->modtime); unlockuserstruct(targettbuf, arg2, 0); hosttbuf = &tbuf; } else { hosttbuf = NULL; } if (!(p = lockuserstring(arg1))) goto efault; ret = geterrno(utime(p, hosttbuf)); unlockuser(p, arg1, 0); } break; #endif case TARGETNRutimes: { struct timeval *tvp, tv[2]; if (arg2) { if (copyfromusertimeval(&tv[0], arg2) || copyfromusertimeval(&tv[1], arg2 + sizeof(struct targettimeval))) goto efault; tvp = tv; } else { tvp = NULL; } if (!(p = lockuserstring(arg1))) goto efault; ret = geterrno(utimes(p, tvp)); unlockuser(p, arg1, 0); } break; #if defined(TARGETNRfutimesat) && defined(NRfutimesat) case TARGETNRfutimesat: { struct timeval *tvp, tv[2]; if (arg3) { if (copyfromusertimeval(&tv[0], arg3) || copyfromusertimeval(&tv[1], arg3 + sizeof(struct targettimeval))) goto efault; tvp = tv; } else { tvp = NULL; } if (!(p = lockuserstring(arg2))) goto efault; ret = geterrno(sysfutimesat(arg1, path(p), tvp)); unlockuser(p, arg2, 0); } break; #endif #ifdef TARGETNRstty case TARGETNRstty: goto unimplemented; #endif #ifdef TARGETNRgtty case TARGETNRgtty: goto unimplemented; #endif case TARGETNRaccess: if (!(p = lockuserstring(arg1))) goto efault; ret = geterrno(access(path(p), arg2)); unlockuser(p, arg1, 0); break; #if defined(TARGETNRfaccessat) && defined(NRfaccessat) case TARGETNRfaccessat: if (!(p = lockuserstring(arg2))) goto efault; ret = geterrno(sysfaccessat(arg1, p, arg3)); unlockuser(p, arg2, 0); break; #endif #ifdef TARGETNRnice /* not on alpha */ case TARGETNRnice: ret = geterrno(nice(arg1)); break; #endif #ifdef TARGETNRftime case TARGETNRftime: goto unimplemented; #endif case TARGETNRsync: sync(); ret = 0; break; case TARGETNRkill: ret = geterrno(kill(arg1, targettohostsignal(arg2))); break; case TARGETNRrename: { void *p2; p = lockuserstring(arg1); p2 = lockuserstring(arg2); if (!p || !p2) ret = -TARGETEFAULT; else ret = geterrno(rename(p, p2)); unlockuser(p2, arg2, 0); unlockuser(p, arg1, 0); } break; #if defined(TARGETNRrenameat) && defined(NRrenameat) case TARGETNRrenameat: { void *p2; p = lockuserstring(arg2); p2 = lockuserstring(arg4); if (!p || !p2) ret = -TARGETEFAULT; else ret = geterrno(sysrenameat(arg1, p, arg3, p2)); unlockuser(p2, arg4, 0); unlockuser(p, arg2, 0); } break; #endif case TARGETNRmkdir: if (!(p = lockuserstring(arg1))) goto efault; ret = geterrno(mkdir(p, arg2)); unlockuser(p, arg1, 0); break; #if defined(TARGETNRmkdirat) && defined(NRmkdirat) case TARGETNRmkdirat: if (!(p = lockuserstring(arg2))) goto efault; ret = geterrno(sysmkdirat(arg1, p, arg3)); unlockuser(p, arg2, 0); break; #endif case TARGETNRrmdir: if (!(p = lockuserstring(arg1))) goto efault; ret = geterrno(rmdir(p)); unlockuser(p, arg1, 0); break; case TARGETNRdup: ret = geterrno(dup(arg1)); break; case TARGETNRpipe: ret = dopipe(cpuenv, arg1, 0); break; #ifdef TARGETNRpipe2 case TARGETNRpipe2: ret = dopipe(cpuenv, arg1, arg2); break; #endif case TARGETNRtimes: { struct targettms *tmsp; struct tms tms; ret = geterrno(times(&tms)); if (arg1) { tmsp = lockuser(VERIFYWRITE, arg1, sizeof(struct targettms), 0); if (!tmsp) goto efault; tmsp->tmsutime = tswapl(hosttotargetclockt(tms.tmsutime)); tmsp->tmsstime = tswapl(hosttotargetclockt(tms.tmsstime)); tmsp->tmscutime = tswapl(hosttotargetclockt(tms.tmscutime)); tmsp->tmscstime = tswapl(hosttotargetclockt(tms.tmscstime)); } if (!iserror(ret)) ret = hosttotargetclockt(ret); } break; #ifdef TARGETNRprof case TARGETNRprof: goto unimplemented; #endif #ifdef TARGETNRsignal case TARGETNRsignal: goto unimplemented; #endif case TARGETNRacct: if (arg1 == 0) { ret = geterrno(acct(NULL)); } else { if (!(p = lockuserstring(arg1))) goto efault; ret = geterrno(acct(path(p))); unlockuser(p, arg1, 0); } break; #ifdef TARGETNRumount2 /* not on alpha */ case TARGETNRumount2: if (!(p = lockuserstring(arg1))) goto efault; ret = geterrno(umount2(p, arg2)); unlockuser(p, arg1, 0); break; #endif #ifdef TARGETNRlock case TARGETNRlock: goto unimplemented; #endif case TARGETNRioctl: ret = doioctl(arg1, arg2, arg3); break; case TARGETNRfcntl: ret = dofcntl(arg1, arg2, arg3); break; #ifdef TARGETNRmpx case TARGETNRmpx: goto unimplemented; #endif case TARGETNRsetpgid: ret = geterrno(setpgid(arg1, arg2)); break; #ifdef TARGETNRulimit case TARGETNRulimit: goto unimplemented; #endif #ifdef TARGETNRoldolduname case TARGETNRoldolduname: goto unimplemented; #endif case TARGETNRumask: ret = geterrno(umask(arg1)); break; case TARGETNRchroot: if (!(p = lockuserstring(arg1))) goto efault; ret = geterrno(chroot(p)); unlockuser(p, arg1, 0); break; case TARGETNRustat: goto unimplemented; case TARGETNRdup2: ret = geterrno(dup2(arg1, arg2)); break; #if defined(CONFIGDUP3) && defined(TARGETNRdup3) case TARGETNRdup3: ret = geterrno(dup3(arg1, arg2, arg3)); break; #endif #ifdef TARGETNRgetppid /* not on alpha */ case TARGETNRgetppid: ret = geterrno(getppid()); break; #endif case TARGETNRgetpgrp: ret = geterrno(getpgrp()); break; case TARGETNRsetsid: ret = geterrno(setsid()); break; #ifdef TARGETNRsigaction case TARGETNRsigaction: { #if !defined(TARGETMIPS) struct targetoldsigaction *oldact; struct targetsigaction act, oact, *pact; if (arg2) { if (!lockuserstruct(VERIFYREAD, oldact, arg2, 1)) goto efault; act.sahandler = oldact->sahandler; targetsiginitset(&act.samask, oldact->samask); act.saflags = oldact->saflags; act.sarestorer = oldact->sarestorer; unlockuserstruct(oldact, arg2, 0); pact = &act; } else { pact = NULL; } ret = geterrno(dosigaction(arg1, pact, &oact)); if (!iserror(ret) && arg3) { if (!lockuserstruct(VERIFYWRITE, oldact, arg3, 0)) goto efault; oldact->sahandler = oact.sahandler; oldact->samask = oact.samask.sig[0]; oldact->saflags = oact.saflags; oldact->sarestorer = oact.sarestorer; unlockuserstruct(oldact, arg3, 1); } #else \t struct targetsigaction act, oact, *pact, *oldact; \t if (arg2) { if (!lockuserstruct(VERIFYREAD, oldact, arg2, 1)) goto efault; \t\tact.sahandler = oldact->sahandler; \t\ttargetsiginitset(&act.samask, oldact->samask.sig[0]); \t\tact.saflags = oldact->saflags; \t\tunlockuserstruct(oldact, arg2, 0); \t\tpact = &act; \t } else { \t\tpact = NULL; \t } \t ret = geterrno(dosigaction(arg1, pact, &oact)); \t if (!iserror(ret) && arg3) { if (!lockuserstruct(VERIFYWRITE, oldact, arg3, 0)) goto efault; \t\toldact->sahandler = oact.sahandler; \t\toldact->saflags = oact.saflags; \t\toldact->samask.sig[0] = oact.samask.sig[0]; \t\toldact->samask.sig[1] = 0; \t\toldact->samask.sig[2] = 0; \t\toldact->samask.sig[3] = 0; \t\tunlockuserstruct(oldact, arg3, 1); \t } #endif } break; #endif case TARGETNRrtsigaction: { struct targetsigaction *act; struct targetsigaction *oact; if (arg2) { if (!lockuserstruct(VERIFYREAD, act, arg2, 1)) goto efault; } else act = NULL; if (arg3) { if (!lockuserstruct(VERIFYWRITE, oact, arg3, 0)) { ret = -TARGETEFAULT; goto rtsigactionfail; } } else oact = NULL; ret = geterrno(dosigaction(arg1, act, oact)); \trtsigactionfail: if (act) unlockuserstruct(act, arg2, 0); if (oact) unlockuserstruct(oact, arg3, 1); } break; #ifdef TARGETNRsgetmask /* not on alpha */ case TARGETNRsgetmask: { sigsett curset; abiulong targetset; sigprocmask(0, NULL, &curset); hosttotargetoldsigset(&targetset, &curset); ret = targetset; } break; #endif #ifdef TARGETNRssetmask /* not on alpha */ case TARGETNRssetmask: { sigsett set, oset, curset; abiulong targetset = arg1; sigprocmask(0, NULL, &curset); targettohostoldsigset(&set, &targetset); sigorset(&set, &set, &curset); sigprocmask(SIGSETMASK, &set, &oset); hosttotargetoldsigset(&targetset, &oset); ret = targetset; } break; #endif #ifdef TARGETNRsigprocmask case TARGETNRsigprocmask: { int how = arg1; sigsett set, oldset, *setptr; if (arg2) { switch(how) { case TARGETSIGBLOCK: how = SIGBLOCK; break; case TARGETSIGUNBLOCK: how = SIGUNBLOCK; break; case TARGETSIGSETMASK: how = SIGSETMASK; break; default: ret = -TARGETEINVAL; goto fail; } if (!(p = lockuser(VERIFYREAD, arg2, sizeof(targetsigsett), 1))) goto efault; targettohostoldsigset(&set, p); unlockuser(p, arg2, 0); setptr = &set; } else { how = 0; setptr = NULL; } ret = geterrno(sigprocmask(arg1, setptr, &oldset)); if (!iserror(ret) && arg3) { if (!(p = lockuser(VERIFYWRITE, arg3, sizeof(targetsigsett), 0))) goto efault; hosttotargetoldsigset(p, &oldset); unlockuser(p, arg3, sizeof(targetsigsett)); } } break; #endif case TARGETNRrtsigprocmask: { int how = arg1; sigsett set, oldset, *setptr; if (arg2) { switch(how) { case TARGETSIGBLOCK: how = SIGBLOCK; break; case TARGETSIGUNBLOCK: how = SIGUNBLOCK; break; case TARGETSIGSETMASK: how = SIGSETMASK; break; default: ret = -TARGETEINVAL; goto fail; } if (!(p = lockuser(VERIFYREAD, arg2, sizeof(targetsigsett), 1))) goto efault; targettohostsigset(&set, p); unlockuser(p, arg2, 0); setptr = &set; } else { how = 0; setptr = NULL; } ret = geterrno(sigprocmask(how, setptr, &oldset)); if (!iserror(ret) && arg3) { if (!(p = lockuser(VERIFYWRITE, arg3, sizeof(targetsigsett), 0))) goto efault; hosttotargetsigset(p, &oldset); unlockuser(p, arg3, sizeof(targetsigsett)); } } break; #ifdef TARGETNRsigpending case TARGETNRsigpending: { sigsett set; ret = geterrno(sigpending(&set)); if (!iserror(ret)) { if (!(p = lockuser(VERIFYWRITE, arg1, sizeof(targetsigsett), 0))) goto efault; hosttotargetoldsigset(p, &set); unlockuser(p, arg1, sizeof(targetsigsett)); } } break; #endif case TARGETNRrtsigpending: { sigsett set; ret = geterrno(sigpending(&set)); if (!iserror(ret)) { if (!(p = lockuser(VERIFYWRITE, arg1, sizeof(targetsigsett), 0))) goto efault; hosttotargetsigset(p, &set); unlockuser(p, arg1, sizeof(targetsigsett)); } } break; #ifdef TARGETNRsigsuspend case TARGETNRsigsuspend: { sigsett set; if (!(p = lockuser(VERIFYREAD, arg1, sizeof(targetsigsett), 1))) goto efault; targettohostoldsigset(&set, p); unlockuser(p, arg1, 0); ret = geterrno(sigsuspend(&set)); } break; #endif case TARGETNRrtsigsuspend: { sigsett set; if (!(p = lockuser(VERIFYREAD, arg1, sizeof(targetsigsett), 1))) goto efault; targettohostsigset(&set, p); unlockuser(p, arg1, 0); ret = geterrno(sigsuspend(&set)); } break; case TARGETNRrtsigtimedwait: { sigsett set; struct timespec uts, *puts; siginfot uinfo; if (!(p = lockuser(VERIFYREAD, arg1, sizeof(targetsigsett), 1))) goto efault; targettohostsigset(&set, p); unlockuser(p, arg1, 0); if (arg3) { puts = &uts; targettohosttimespec(puts, arg3); } else { puts = NULL; } ret = geterrno(sigtimedwait(&set, &uinfo, puts)); if (!iserror(ret) && arg2) { if (!(p = lockuser(VERIFYWRITE, arg2, sizeof(targetsiginfot), 0))) goto efault; hosttotargetsiginfo(p, &uinfo); unlockuser(p, arg2, sizeof(targetsiginfot)); } } break; case TARGETNRrtsigqueueinfo: { siginfot uinfo; if (!(p = lockuser(VERIFYREAD, arg3, sizeof(targetsigsett), 1))) goto efault; targettohostsiginfo(&uinfo, p); unlockuser(p, arg1, 0); ret = geterrno(sysrtsigqueueinfo(arg1, arg2, &uinfo)); } break; #ifdef TARGETNRsigreturn case TARGETNRsigreturn: /* NOTE: ret is eax, so not transcoding must be done */ ret = dosigreturn(cpuenv); break; #endif case TARGETNRrtsigreturn: /* NOTE: ret is eax, so not transcoding must be done */ ret = dortsigreturn(cpuenv); break; case TARGETNRsethostname: if (!(p = lockuserstring(arg1))) goto efault; ret = geterrno(sethostname(p, arg2)); unlockuser(p, arg1, 0); break; case TARGETNRsetrlimit: { /* XXX: convert resource ? */ int resource = arg1; struct targetrlimit *targetrlim; struct rlimit rlim; if (!lockuserstruct(VERIFYREAD, targetrlim, arg2, 1)) goto efault; rlim.rlimcur = tswapl(targetrlim->rlimcur); rlim.rlimmax = tswapl(targetrlim->rlimmax); unlockuserstruct(targetrlim, arg2, 0); ret = geterrno(setrlimit(resource, &rlim)); } break; case TARGETNRgetrlimit: { /* XXX: convert resource ? */ int resource = arg1; struct targetrlimit *targetrlim; struct rlimit rlim; ret = geterrno(getrlimit(resource, &rlim)); if (!iserror(ret)) { if (!lockuserstruct(VERIFYWRITE, targetrlim, arg2, 0)) goto efault; targetrlim->rlimcur = tswapl(rlim.rlimcur); targetrlim->rlimmax = tswapl(rlim.rlimmax); unlockuserstruct(targetrlim, arg2, 1); } } break; case TARGETNRgetrusage: { struct rusage rusage; ret = geterrno(getrusage(arg1, &rusage)); if (!iserror(ret)) { hosttotargetrusage(arg2, &rusage); } } break; case TARGETNRgettimeofday: { struct timeval tv; ret = geterrno(gettimeofday(&tv, NULL)); if (!iserror(ret)) { if (copytousertimeval(arg1, &tv)) goto efault; } } break; case TARGETNRsettimeofday: { struct timeval tv; if (copyfromusertimeval(&tv, arg1)) goto efault; ret = geterrno(settimeofday(&tv, NULL)); } break; #ifdef TARGETNRselect case TARGETNRselect: { struct targetselargstruct *sel; abiulong inp, outp, exp, tvp; long nsel; if (!lockuserstruct(VERIFYREAD, sel, arg1, 1)) goto efault; nsel = tswapl(sel->n); inp = tswapl(sel->inp); outp = tswapl(sel->outp); exp = tswapl(sel->exp); tvp = tswapl(sel->tvp); unlockuserstruct(sel, arg1, 0); ret = doselect(nsel, inp, outp, exp, tvp); } break; #endif case TARGETNRsymlink: { void *p2; p = lockuserstring(arg1); p2 = lockuserstring(arg2); if (!p || !p2) ret = -TARGETEFAULT; else ret = geterrno(symlink(p, p2)); unlockuser(p2, arg2, 0); unlockuser(p, arg1, 0); } break; #if defined(TARGETNRsymlinkat) && defined(NRsymlinkat) case TARGETNRsymlinkat: { void *p2; p = lockuserstring(arg1); p2 = lockuserstring(arg3); if (!p || !p2) ret = -TARGETEFAULT; else ret = geterrno(syssymlinkat(p, arg2, p2)); unlockuser(p2, arg3, 0); unlockuser(p, arg1, 0); } break; #endif #ifdef TARGETNRoldlstat case TARGETNRoldlstat: goto unimplemented; #endif case TARGETNRreadlink: { void *p2, *temp; p = lockuserstring(arg1); p2 = lockuser(VERIFYWRITE, arg2, arg3, 0); if (!p || !p2) ret = -TARGETEFAULT; else { if (strncmp((const char *)p, \"/proc/self/exe\", 14) == 0) { char real[PATHMAX]; temp = realpath(execpath,real); ret = (temp==NULL) ? geterrno(-1) : strlen(real) ; snprintf((char *)p2, arg3, \"%s\", real); } else ret = geterrno(readlink(path(p), p2, arg3)); } unlockuser(p2, arg2, ret); unlockuser(p, arg1, 0); } break; #if defined(TARGETNRreadlinkat) && defined(NRreadlinkat) case TARGETNRreadlinkat: { void *p2; p = lockuserstring(arg2); p2 = lockuser(VERIFYWRITE, arg3, arg4, 0); if (!p || !p2) \tret = -TARGETEFAULT; else ret = geterrno(sysreadlinkat(arg1, path(p), p2, arg4)); unlockuser(p2, arg3, ret); unlockuser(p, arg2, 0); } break; #endif #ifdef TARGETNRuselib case TARGETNRuselib: goto unimplemented; #endif #ifdef TARGETNRswapon case TARGETNRswapon: if (!(p = lockuserstring(arg1))) goto efault; ret = geterrno(swapon(p, arg2)); unlockuser(p, arg1, 0); break; #endif case TARGETNRreboot: goto unimplemented; #ifdef TARGETNRreaddir case TARGETNRreaddir: goto unimplemented; #endif #ifdef TARGETNRmmap case TARGETNRmmap: #if (defined(TARGETI386) && defined(TARGETABI32)) || defined(TARGETARM) || defined(TARGETM68K) || defined(TARGETCRIS) || defined(TARGETMICROBLAZE) { abiulong *v; abiulong v1, v2, v3, v4, v5, v6; if (!(v = lockuser(VERIFYREAD, arg1, 6 * sizeof(abiulong), 1))) goto efault; v1 = tswapl(v[0]); v2 = tswapl(v[1]); v3 = tswapl(v[2]); v4 = tswapl(v[3]); v5 = tswapl(v[4]); v6 = tswapl(v[5]); unlockuser(v, arg1, 0); ret = geterrno(targetmmap(v1, v2, v3, targettohostbitmask(v4, mmapflagstbl), v5, v6)); } #else ret = geterrno(targetmmap(arg1, arg2, arg3, targettohostbitmask(arg4, mmapflagstbl), arg5, arg6)); #endif break; #endif #ifdef TARGETNRmmap2 case TARGETNRmmap2: #ifndef MMAPSHIFT #define MMAPSHIFT 12 #endif ret = geterrno(targetmmap(arg1, arg2, arg3, targettohostbitmask(arg4, mmapflagstbl), arg5, arg6 << MMAPSHIFT)); break; #endif case TARGETNRmunmap: ret = geterrno(targetmunmap(arg1, arg2)); break; case TARGETNRmprotect: ret = geterrno(targetmprotect(arg1, arg2, arg3)); break; #ifdef TARGETNRmremap case TARGETNRmremap: ret = geterrno(targetmremap(arg1, arg2, arg3, arg4, arg5)); break; #endif /* ??? msync/mlock/munlock are broken for softmmu. */ #ifdef TARGETNRmsync case TARGETNRmsync: ret = geterrno(msync(g2h(arg1), arg2, arg3)); break; #endif #ifdef TARGETNRmlock case TARGETNRmlock: ret = geterrno(mlock(g2h(arg1), arg2)); break; #endif #ifdef TARGETNRmunlock case TARGETNRmunlock: ret = geterrno(munlock(g2h(arg1), arg2)); break; #endif #ifdef TARGETNRmlockall case TARGETNRmlockall: ret = geterrno(mlockall(arg1)); break; #endif #ifdef TARGETNRmunlockall case TARGETNRmunlockall: ret = geterrno(munlockall()); break; #endif case TARGETNRtruncate: if (!(p = lockuserstring(arg1))) goto efault; ret = geterrno(truncate(p, arg2)); unlockuser(p, arg1, 0); break; case TARGETNRftruncate: ret = geterrno(ftruncate(arg1, arg2)); break; case TARGETNRfchmod: ret = geterrno(fchmod(arg1, arg2)); break; #if defined(TARGETNRfchmodat) && defined(NRfchmodat) case TARGETNRfchmodat: if (!(p = lockuserstring(arg2))) goto efault; ret = geterrno(sysfchmodat(arg1, p, arg3)); unlockuser(p, arg2, 0); break; #endif case TARGETNRgetpriority: /* libc does special remapping of the return value of * sysgetpriority() so it's just easiest to call * sysgetpriority() directly rather than through libc. */ ret = geterrno(sysgetpriority(arg1, arg2)); break; case TARGETNRsetpriority: ret = geterrno(setpriority(arg1, arg2, arg3)); break; #ifdef TARGETNRprofil case TARGETNRprofil: goto unimplemented; #endif case TARGETNRstatfs: if (!(p = lockuserstring(arg1))) goto efault; ret = geterrno(statfs(path(p), &stfs)); unlockuser(p, arg1, 0); convertstatfs: if (!iserror(ret)) { struct targetstatfs *targetstfs; if (!lockuserstruct(VERIFYWRITE, targetstfs, arg2, 0)) goto efault; putuser(stfs.ftype, &targetstfs->ftype); putuser(stfs.fbsize, &targetstfs->fbsize); putuser(stfs.fblocks, &targetstfs->fblocks); putuser(stfs.fbfree, &targetstfs->fbfree); putuser(stfs.fbavail, &targetstfs->fbavail); putuser(stfs.ffiles, &targetstfs->ffiles); putuser(stfs.fffree, &targetstfs->fffree); putuser(stfs.ffsid.val[0], &targetstfs->ffsid.val[0]); putuser(stfs.ffsid.val[1], &targetstfs->ffsid.val[1]); putuser(stfs.fnamelen, &targetstfs->fnamelen); unlockuserstruct(targetstfs, arg2, 1); } break; case TARGETNRfstatfs: ret = geterrno(fstatfs(arg1, &stfs)); goto convertstatfs; #ifdef TARGETNRstatfs64 case TARGETNRstatfs64: if (!(p = lockuserstring(arg1))) goto efault; ret = geterrno(statfs(path(p), &stfs)); unlockuser(p, arg1, 0); convertstatfs64: if (!iserror(ret)) { struct targetstatfs64 *targetstfs; if (!lockuserstruct(VERIFYWRITE, targetstfs, arg3, 0)) goto efault; putuser(stfs.ftype, &targetstfs->ftype); putuser(stfs.fbsize, &targetstfs->fbsize); putuser(stfs.fblocks, &targetstfs->fblocks); putuser(stfs.fbfree, &targetstfs->fbfree); putuser(stfs.fbavail, &targetstfs->fbavail); putuser(stfs.ffiles, &targetstfs->ffiles); putuser(stfs.fffree, &targetstfs->fffree); putuser(stfs.ffsid.val[0], &targetstfs->ffsid.val[0]); putuser(stfs.ffsid.val[1], &targetstfs->ffsid.val[1]); putuser(stfs.fnamelen, &targetstfs->fnamelen); unlockuserstruct(targetstfs, arg3, 1); } break; case TARGETNRfstatfs64: ret = geterrno(fstatfs(arg1, &stfs)); goto convertstatfs64; #endif #ifdef TARGETNRioperm case TARGETNRioperm: goto unimplemented; #endif #ifdef TARGETNRsocketcall case TARGETNRsocketcall: ret = dosocketcall(arg1, arg2); break; #endif #ifdef TARGETNRaccept case TARGETNRaccept: ret = doaccept(arg1, arg2, arg3); break; #endif #ifdef TARGETNRbind case TARGETNRbind: ret = dobind(arg1, arg2, arg3); break; #endif #ifdef TARGETNRconnect case TARGETNRconnect: ret = doconnect(arg1, arg2, arg3); break; #endif #ifdef TARGETNRgetpeername case TARGETNRgetpeername: ret = dogetpeername(arg1, arg2, arg3); break; #endif #ifdef TARGETNRgetsockname case TARGETNRgetsockname: ret = dogetsockname(arg1, arg2, arg3); break; #endif #ifdef TARGETNRgetsockopt case TARGETNRgetsockopt: ret = dogetsockopt(arg1, arg2, arg3, arg4, arg5); break; #endif #ifdef TARGETNRlisten case TARGETNRlisten: ret = geterrno(listen(arg1, arg2)); break; #endif #ifdef TARGETNRrecv case TARGETNRrecv: ret = dorecvfrom(arg1, arg2, arg3, arg4, 0, 0); break; #endif #ifdef TARGETNRrecvfrom case TARGETNRrecvfrom: ret = dorecvfrom(arg1, arg2, arg3, arg4, arg5, arg6); break; #endif #ifdef TARGETNRrecvmsg case TARGETNRrecvmsg: ret = dosendrecvmsg(arg1, arg2, arg3, 0); break; #endif #ifdef TARGETNRsend case TARGETNRsend: ret = dosendto(arg1, arg2, arg3, arg4, 0, 0); break; #endif #ifdef TARGETNRsendmsg case TARGETNRsendmsg: ret = dosendrecvmsg(arg1, arg2, arg3, 1); break; #endif #ifdef TARGETNRsendto case TARGETNRsendto: ret = dosendto(arg1, arg2, arg3, arg4, arg5, arg6); break; #endif #ifdef TARGETNRshutdown case TARGETNRshutdown: ret = geterrno(shutdown(arg1, arg2)); break; #endif #ifdef TARGETNRsocket case TARGETNRsocket: ret = dosocket(arg1, arg2, arg3); break; #endif #ifdef TARGETNRsocketpair case TARGETNRsocketpair: ret = dosocketpair(arg1, arg2, arg3, arg4); break; #endif #ifdef TARGETNRsetsockopt case TARGETNRsetsockopt: ret = dosetsockopt(arg1, arg2, arg3, arg4, (socklent) arg5); break; #endif case TARGETNRsyslog: if (!(p = lockuserstring(arg2))) goto efault; ret = geterrno(syssyslog((int)arg1, p, (int)arg3)); unlockuser(p, arg2, 0); break; case TARGETNRsetitimer: { struct itimerval value, ovalue, *pvalue; if (arg2) { pvalue = &value; if (copyfromusertimeval(&pvalue->itinterval, arg2) || copyfromusertimeval(&pvalue->itvalue, arg2 + sizeof(struct targettimeval))) goto efault; } else { pvalue = NULL; } ret = geterrno(setitimer(arg1, pvalue, &ovalue)); if (!iserror(ret) && arg3) { if (copytousertimeval(arg3, &ovalue.itinterval) || copytousertimeval(arg3 + sizeof(struct targettimeval), &ovalue.itvalue)) goto efault; } } break; case TARGETNRgetitimer: { struct itimerval value; ret = geterrno(getitimer(arg1, &value)); if (!iserror(ret) && arg2) { if (copytousertimeval(arg2, &value.itinterval) || copytousertimeval(arg2 + sizeof(struct targettimeval), &value.itvalue)) goto efault; } } break; case TARGETNRstat: if (!(p = lockuserstring(arg1))) goto efault; ret = geterrno(stat(path(p), &st)); unlockuser(p, arg1, 0); goto dostat; case TARGETNRlstat: if (!(p = lockuserstring(arg1))) goto efault; ret = geterrno(lstat(path(p), &st)); unlockuser(p, arg1, 0); goto dostat; case TARGETNRfstat: { ret = geterrno(fstat(arg1, &st)); dostat: if (!iserror(ret)) { struct targetstat *targetst; if (!lockuserstruct(VERIFYWRITE, targetst, arg2, 0)) goto efault; memset(targetst, 0, sizeof(*targetst)); putuser(st.stdev, &targetst->stdev); putuser(st.stino, &targetst->stino); putuser(st.stmode, &targetst->stmode); putuser(st.stuid, &targetst->stuid); putuser(st.stgid, &targetst->stgid); putuser(st.stnlink, &targetst->stnlink); putuser(st.strdev, &targetst->strdev); putuser(st.stsize, &targetst->stsize); putuser(st.stblksize, &targetst->stblksize); putuser(st.stblocks, &targetst->stblocks); putuser(st.statime, &targetst->targetstatime); putuser(st.stmtime, &targetst->targetstmtime); putuser(st.stctime, &targetst->targetstctime); unlockuserstruct(targetst, arg2, 1); } } break; #ifdef TARGETNRolduname case TARGETNRolduname: goto unimplemented; #endif #ifdef TARGETNRiopl case TARGETNRiopl: goto unimplemented; #endif case TARGETNRvhangup: ret = geterrno(vhangup()); break; #ifdef TARGETNRidle case TARGETNRidle: goto unimplemented; #endif #ifdef TARGETNRsyscall case TARGETNRsyscall: \tret = dosyscall(cpuenv,arg1 & 0xffff,arg2,arg3,arg4,arg5,arg6,0); \tbreak; #endif case TARGETNRwait4: { int status; abilong statusptr = arg2; struct rusage rusage, *rusageptr; abiulong targetrusage = arg4; if (targetrusage) rusageptr = &rusage; else rusageptr = NULL; ret = geterrno(wait4(arg1, &status, arg3, rusageptr)); if (!iserror(ret)) { if (statusptr) { status = hosttotargetwaitstatus(status); if (putusers32(status, statusptr)) goto efault; } if (targetrusage) hosttotargetrusage(targetrusage, &rusage); } } break; #ifdef TARGETNRswapoff case TARGETNRswapoff: if (!(p = lockuserstring(arg1))) goto efault; ret = geterrno(swapoff(p)); unlockuser(p, arg1, 0); break; #endif case TARGETNRsysinfo: { struct targetsysinfo *targetvalue; struct sysinfo value; ret = geterrno(sysinfo(&value)); if (!iserror(ret) && arg1) { if (!lockuserstruct(VERIFYWRITE, targetvalue, arg1, 0)) goto efault; putuser(value.uptime, &targetvalue->uptime); putuser(value.loads[0], &targetvalue->loads[0]); putuser(value.loads[1], &targetvalue->loads[1]); putuser(value.loads[2], &targetvalue->loads[2]); putuser(value.totalram, &targetvalue->totalram); putuser(value.freeram, &targetvalue->freeram); putuser(value.sharedram, &targetvalue->sharedram); putuser(value.bufferram, &targetvalue->bufferram); putuser(value.totalswap, &targetvalue->totalswap); putuser(value.freeswap, &targetvalue->freeswap); putuser(value.procs, &targetvalue->procs); putuser(value.totalhigh, &targetvalue->totalhigh); putuser(value.freehigh, &targetvalue->freehigh); putuser(value.memunit, &targetvalue->memunit); unlockuserstruct(targetvalue, arg1, 1); } } break; #ifdef TARGETNRipc case TARGETNRipc: \tret = doipc(arg1, arg2, arg3, arg4, arg5, arg6); \tbreak; #endif #ifdef TARGETNRsemget case TARGETNRsemget: ret = geterrno(semget(arg1, arg2, arg3)); break; #endif #ifdef TARGETNRsemop case TARGETNRsemop: ret = geterrno(dosemop(arg1, arg2, arg3)); break; #endif #ifdef TARGETNRsemctl case TARGETNRsemctl: ret = dosemctl(arg1, arg2, arg3, (union targetsemun)(abiulong)arg4); break; #endif #ifdef TARGETNRmsgctl case TARGETNRmsgctl: ret = domsgctl(arg1, arg2, arg3); break; #endif #ifdef TARGETNRmsgget case TARGETNRmsgget: ret = geterrno(msgget(arg1, arg2)); break; #endif #ifdef TARGETNRmsgrcv case TARGETNRmsgrcv: ret = domsgrcv(arg1, arg2, arg3, arg4, arg5); break; #endif #ifdef TARGETNRmsgsnd case TARGETNRmsgsnd: ret = domsgsnd(arg1, arg2, arg3, arg4); break; #endif #ifdef TARGETNRshmget case TARGETNRshmget: ret = geterrno(shmget(arg1, arg2, arg3)); break; #endif #ifdef TARGETNRshmctl case TARGETNRshmctl: ret = doshmctl(arg1, arg2, arg3); break; #endif #ifdef TARGETNRshmat case TARGETNRshmat: ret = doshmat(arg1, arg2, arg3); break; #endif #ifdef TARGETNRshmdt case TARGETNRshmdt: ret = doshmdt(arg1); break; #endif case TARGETNRfsync: ret = geterrno(fsync(arg1)); break; case TARGETNRclone: #if defined(TARGETSH4) ret = geterrno(dofork(cpuenv, arg1, arg2, arg3, arg5, arg4)); #elif defined(TARGETCRIS) ret = geterrno(dofork(cpuenv, arg2, arg1, arg3, arg4, arg5)); #else ret = geterrno(dofork(cpuenv, arg1, arg2, arg3, arg4, arg5)); #endif break; #ifdef NRexitgroup /* new thread calls */ case TARGETNRexitgroup: #ifdef TARGETGPROF mcleanup(); #endif gdbexit(cpuenv, arg1); ret = geterrno(exitgroup(arg1)); break; #endif case TARGETNRsetdomainname: if (!(p = lockuserstring(arg1))) goto efault; ret = geterrno(setdomainname(p, arg2)); unlockuser(p, arg1, 0); break; case TARGETNRuname: /* no need to transcode because we use the linux syscall */ { struct newutsname * buf; if (!lockuserstruct(VERIFYWRITE, buf, arg1, 0)) goto efault; ret = geterrno(sysuname(buf)); if (!iserror(ret)) { /* Overrite the native machine name with whatever is being emulated. */ strcpy (buf->machine, cputounamemachine(cpuenv)); /* Allow the user to override the reported release. */ if (qemuunamerelease && *qemuunamerelease) strcpy (buf->release, qemuunamerelease); } unlockuserstruct(buf, arg1, 1); } break; #ifdef TARGETI386 case TARGETNRmodifyldt: ret = domodifyldt(cpuenv, arg1, arg2, arg3); break; #if !defined(TARGETX8664) case TARGETNRvm86old: goto unimplemented; case TARGETNRvm86: ret = dovm86(cpuenv, arg1, arg2); break; #endif #endif case TARGETNRadjtimex: goto unimplemented; #ifdef TARGETNRcreatemodule case TARGETNRcreatemodule: #endif case TARGETNRinitmodule: case TARGETNRdeletemodule: #ifdef TARGETNRgetkernelsyms case TARGETNRgetkernelsyms: #endif goto unimplemented; case TARGETNRquotactl: goto unimplemented; case TARGETNRgetpgid: ret = geterrno(getpgid(arg1)); break; case TARGETNRfchdir: ret = geterrno(fchdir(arg1)); break; #ifdef TARGETNRbdflush /* not on x8664 */ case TARGETNRbdflush: goto unimplemented; #endif #ifdef TARGETNRsysfs case TARGETNRsysfs: goto unimplemented; #endif case TARGETNRpersonality: ret = geterrno(personality(arg1)); break; #ifdef TARGETNRafssyscall case TARGETNRafssyscall: goto unimplemented; #endif #ifdef TARGETNRllseek /* Not on alpha */ case TARGETNRllseek: { #if defined (x8664) ret = geterrno(lseek(arg1, ((uint64t )arg2 << 32) | arg3, arg5)); if (putusers64(ret, arg4)) goto efault; #else int64t res; ret = geterrno(llseek(arg1, arg2, arg3, &res, arg5)); if (putusers64(res, arg4)) goto efault; #endif } break; #endif case TARGETNRgetdents: #if TARGETABIBITS == 32 && HOSTLONGBITS == 64 { struct targetdirent *targetdirp; struct linuxdirent *dirp; abilong count = arg3; \t dirp = malloc(count); \t if (!dirp) { ret = -TARGETENOMEM; goto fail; } ret = geterrno(sysgetdents(arg1, dirp, count)); if (!iserror(ret)) { struct linuxdirent *de; \t\tstruct targetdirent *tde; int len = ret; int reclen, treclen; \t\tint count1, tnamelen; \t\tcount1 = 0; de = dirp; if (!(targetdirp = lockuser(VERIFYWRITE, arg2, count, 0))) goto efault; \t\ttde = targetdirp; while (len > 0) { reclen = de->dreclen; \t\t treclen = reclen - (2 * (sizeof(long) - sizeof(abilong))); tde->dreclen = tswap16(treclen); tde->dino = tswapl(de->dino); tde->doff = tswapl(de->doff); \t\t tnamelen = treclen - (2 * sizeof(abilong) + 2); \t\t if (tnamelen > 256) tnamelen = 256; /* XXX: may not be correct */ pstrcpy(tde->dname, tnamelen, de->dname); de = (struct linuxdirent *)((char *)de + reclen); len -= reclen; tde = (struct targetdirent *)((char *)tde + treclen); \t\t count1 += treclen; } \t\tret = count1; unlockuser(targetdirp, arg2, ret); } \t free(dirp); } #else { struct linuxdirent *dirp; abilong count = arg3; if (!(dirp = lockuser(VERIFYWRITE, arg2, count, 0))) goto efault; ret = geterrno(sysgetdents(arg1, dirp, count)); if (!iserror(ret)) { struct linuxdirent *de; int len = ret; int reclen; de = dirp; while (len > 0) { reclen = de->dreclen; if (reclen > len) break; de->dreclen = tswap16(reclen); tswapls(&de->dino); tswapls(&de->doff); de = (struct linuxdirent *)((char *)de + reclen); len -= reclen; } } unlockuser(dirp, arg2, ret); } #endif break; #if defined(TARGETNRgetdents64) && defined(NRgetdents64) case TARGETNRgetdents64: { struct linuxdirent64 *dirp; abilong count = arg3; if (!(dirp = lockuser(VERIFYWRITE, arg2, count, 0))) goto efault; ret = geterrno(sysgetdents64(arg1, dirp, count)); if (!iserror(ret)) { struct linuxdirent64 *de; int len = ret; int reclen; de = dirp; while (len > 0) { reclen = de->dreclen; if (reclen > len) break; de->dreclen = tswap16(reclen); tswap64s((uint64t *)&de->dino); tswap64s((uint64t *)&de->doff); de = (struct linuxdirent64 *)((char *)de + reclen); len -= reclen; } } unlockuser(dirp, arg2, ret); } break; #endif /* TARGETNRgetdents64 */ #ifdef TARGETNRnewselect case TARGETNRnewselect: ret = doselect(arg1, arg2, arg3, arg4, arg5); break; #endif #ifdef TARGETNRpoll case TARGETNRpoll: { struct targetpollfd *targetpfd; unsigned int nfds = arg2; int timeout = arg3; struct pollfd *pfd; unsigned int i; targetpfd = lockuser(VERIFYWRITE, arg1, sizeof(struct targetpollfd) * nfds, 1); if (!targetpfd) goto efault; pfd = alloca(sizeof(struct pollfd) * nfds); for(i = 0; i < nfds; i++) { pfd[i].fd = tswap32(targetpfd[i].fd); pfd[i].events = tswap16(targetpfd[i].events); } ret = geterrno(poll(pfd, nfds, timeout)); if (!iserror(ret)) { for(i = 0; i < nfds; i++) { targetpfd[i].revents = tswap16(pfd[i].revents); } ret += nfds * (sizeof(struct targetpollfd) - sizeof(struct pollfd)); } unlockuser(targetpfd, arg1, ret); } break; #endif case TARGETNRflock: /* NOTE: the flock constant seems to be the same for every Linux platform */ ret = geterrno(flock(arg1, arg2)); break; case TARGETNRreadv: { int count = arg3; struct iovec *vec; vec = alloca(count * sizeof(struct iovec)); if (lockiovec(VERIFYWRITE, vec, arg2, count, 0) < 0) goto efault; ret = geterrno(readv(arg1, vec, count)); unlockiovec(vec, arg2, count, 1); } break; case TARGETNRwritev: { int count = arg3; struct iovec *vec; vec = alloca(count * sizeof(struct iovec)); if (lockiovec(VERIFYREAD, vec, arg2, count, 1) < 0) goto efault; ret = geterrno(writev(arg1, vec, count)); unlockiovec(vec, arg2, count, 0); } break; case TARGETNRgetsid: ret = geterrno(getsid(arg1)); break; #if defined(TARGETNRfdatasync) /* Not on alpha (osfdatasync ?) */ case TARGETNRfdatasync: ret = geterrno(fdatasync(arg1)); break; #endif case TARGETNRsysctl: /* We don't implement this, but ENOTDIR is always a safe return value. */ ret = -TARGETENOTDIR; break; case TARGETNRschedsetparam: { struct schedparam *targetschp; struct schedparam schp; if (!lockuserstruct(VERIFYREAD, targetschp, arg2, 1)) goto efault; schp.schedpriority = tswap32(targetschp->schedpriority); unlockuserstruct(targetschp, arg2, 0); ret = geterrno(schedsetparam(arg1, &schp)); } break; case TARGETNRschedgetparam: { struct schedparam *targetschp; struct schedparam schp; ret = geterrno(schedgetparam(arg1, &schp)); if (!iserror(ret)) { if (!lockuserstruct(VERIFYWRITE, targetschp, arg2, 0)) goto efault; targetschp->schedpriority = tswap32(schp.schedpriority); unlockuserstruct(targetschp, arg2, 1); } } break; case TARGETNRschedsetscheduler: { struct schedparam *targetschp; struct schedparam schp; if (!lockuserstruct(VERIFYREAD, targetschp, arg3, 1)) goto efault; schp.schedpriority = tswap32(targetschp->schedpriority); unlockuserstruct(targetschp, arg3, 0); ret = geterrno(schedsetscheduler(arg1, arg2, &schp)); } break; case TARGETNRschedgetscheduler: ret = geterrno(schedgetscheduler(arg1)); break; case TARGETNRschedyield: ret = geterrno(schedyield()); break; case TARGETNRschedgetprioritymax: ret = geterrno(schedgetprioritymax(arg1)); break; case TARGETNRschedgetprioritymin: ret = geterrno(schedgetprioritymin(arg1)); break; case TARGETNRschedrrgetinterval: { struct timespec ts; ret = geterrno(schedrrgetinterval(arg1, &ts)); if (!iserror(ret)) { hosttotargettimespec(arg2, &ts); } } break; case TARGETNRnanosleep: { struct timespec req, rem; targettohosttimespec(&req, arg1); ret = geterrno(nanosleep(&req, &rem)); if (iserror(ret) && arg2) { hosttotargettimespec(arg2, &rem); } } break; #ifdef TARGETNRquerymodule case TARGETNRquerymodule: goto unimplemented; #endif #ifdef TARGETNRnfsservctl case TARGETNRnfsservctl: goto unimplemented; #endif case TARGETNRprctl: switch (arg1) { case PRGETPDEATHSIG: { int deathsig; ret = geterrno(prctl(arg1, &deathsig, arg3, arg4, arg5)); if (!iserror(ret) && arg2 && putuserual(deathsig, arg2)) goto efault; } break; default: ret = geterrno(prctl(arg1, arg2, arg3, arg4, arg5)); break; } break; #ifdef TARGETNRarchprctl case TARGETNRarchprctl: #if defined(TARGETI386) && !defined(TARGETABI32) ret = doarchprctl(cpuenv, arg1, arg2); break; #else goto unimplemented; #endif #endif #ifdef TARGETNRpread case TARGETNRpread: #ifdef TARGETARM if (((CPUARMState *)cpuenv)->eabi) arg4 = arg5; #endif if (!(p = lockuser(VERIFYWRITE, arg2, arg3, 0))) goto efault; ret = geterrno(pread(arg1, p, arg3, arg4)); unlockuser(p, arg2, ret); break; case TARGETNRpwrite: #ifdef TARGETARM if (((CPUARMState *)cpuenv)->eabi) arg4 = arg5; #endif if (!(p = lockuser(VERIFYREAD, arg2, arg3, 1))) goto efault; ret = geterrno(pwrite(arg1, p, arg3, arg4)); unlockuser(p, arg2, 0); break; #endif #ifdef TARGETNRpread64 case TARGETNRpread64: if (!(p = lockuser(VERIFYWRITE, arg2, arg3, 0))) goto efault; ret = geterrno(pread64(arg1, p, arg3, targetoffset64(arg4, arg5))); unlockuser(p, arg2, ret); break; case TARGETNRpwrite64: if (!(p = lockuser(VERIFYREAD, arg2, arg3, 1))) goto efault; ret = geterrno(pwrite64(arg1, p, arg3, targetoffset64(arg4, arg5))); unlockuser(p, arg2, 0); break; #endif case TARGETNRgetcwd: if (!(p = lockuser(VERIFYWRITE, arg1, arg2, 0))) goto efault; ret = geterrno(sysgetcwd1(p, arg2)); unlockuser(p, arg1, ret); break; case TARGETNRcapget: goto unimplemented; case TARGETNRcapset: goto unimplemented; case TARGETNRsigaltstack: #if defined(TARGETI386) || defined(TARGETARM) || defined(TARGETMIPS) || \\ defined(TARGETSPARC) || defined(TARGETPPC) || defined(TARGETALPHA) || \\ defined(TARGETM68K) ret = dosigaltstack(arg1, arg2, getspfromcpustate((CPUState *)cpuenv)); break; #else goto unimplemented; #endif case TARGETNRsendfile: goto unimplemented; #ifdef TARGETNRgetpmsg case TARGETNRgetpmsg: goto unimplemented; #endif #ifdef TARGETNRputpmsg case TARGETNRputpmsg: goto unimplemented; #endif #ifdef TARGETNRvfork case TARGETNRvfork: ret = geterrno(dofork(cpuenv, CLONEVFORK | CLONEVM | SIGCHLD, 0, 0, 0, 0)); break; #endif #ifdef TARGETNRugetrlimit case TARGETNRugetrlimit: { \tstruct rlimit rlim; \tret = geterrno(getrlimit(arg1, &rlim)); \tif (!iserror(ret)) { \t struct targetrlimit *targetrlim; if (!lockuserstruct(VERIFYWRITE, targetrlim, arg2, 0)) goto efault; \t targetrlim->rlimcur = tswapl(rlim.rlimcur); \t targetrlim->rlimmax = tswapl(rlim.rlimmax); unlockuserstruct(targetrlim, arg2, 1); \t} \tbreak; } #endif #ifdef TARGETNRtruncate64 case TARGETNRtruncate64: if (!(p = lockuserstring(arg1))) goto efault; \tret = targettruncate64(cpuenv, p, arg2, arg3, arg4); unlockuser(p, arg1, 0); \tbreak; #endif #ifdef TARGETNRftruncate64 case TARGETNRftruncate64: \tret = targetftruncate64(cpuenv, arg1, arg2, arg3, arg4); \tbreak; #endif #ifdef TARGETNRstat64 case TARGETNRstat64: if (!(p = lockuserstring(arg1))) goto efault; ret = geterrno(stat(path(p), &st)); unlockuser(p, arg1, 0); if (!iserror(ret)) ret = hosttotargetstat64(cpuenv, arg2, &st); break; #endif #ifdef TARGETNRlstat64 case TARGETNRlstat64: if (!(p = lockuserstring(arg1))) goto efault; ret = geterrno(lstat(path(p), &st)); unlockuser(p, arg1, 0); if (!iserror(ret)) ret = hosttotargetstat64(cpuenv, arg2, &st); break; #endif #ifdef TARGETNRfstat64 case TARGETNRfstat64: ret = geterrno(fstat(arg1, &st)); if (!iserror(ret)) ret = hosttotargetstat64(cpuenv, arg2, &st); break; #endif #if (defined(TARGETNRfstatat64) || defined(TARGETNRnewfstatat)) && \\ (defined(NRfstatat64) || defined(NRnewfstatat)) #ifdef TARGETNRfstatat64 case TARGETNRfstatat64: #endif #ifdef TARGETNRnewfstatat case TARGETNRnewfstatat: #endif if (!(p = lockuserstring(arg2))) goto efault; #ifdef NRfstatat64 ret = geterrno(sysfstatat64(arg1, path(p), &st, arg4)); #else ret = geterrno(sysnewfstatat(arg1, path(p), &st, arg4)); #endif if (!iserror(ret)) ret = hosttotargetstat64(cpuenv, arg3, &st); break; #endif #ifdef USEUID16 case TARGETNRlchown: if (!(p = lockuserstring(arg1))) goto efault; ret = geterrno(lchown(p, low2highuid(arg2), low2highgid(arg3))); unlockuser(p, arg1, 0); break; case TARGETNRgetuid: ret = geterrno(high2lowuid(getuid())); break; case TARGETNRgetgid: ret = geterrno(high2lowgid(getgid())); break; case TARGETNRgeteuid: ret = geterrno(high2lowuid(geteuid())); break; case TARGETNRgetegid: ret = geterrno(high2lowgid(getegid())); break; case TARGETNRsetreuid: ret = geterrno(setreuid(low2highuid(arg1), low2highuid(arg2))); break; case TARGETNRsetregid: ret = geterrno(setregid(low2highgid(arg1), low2highgid(arg2))); break; case TARGETNRgetgroups: { int gidsetsize = arg1; uint16t *targetgrouplist; gidt *grouplist; int i; grouplist = alloca(gidsetsize * sizeof(gidt)); ret = geterrno(getgroups(gidsetsize, grouplist)); if (gidsetsize == 0) break; if (!iserror(ret)) { targetgrouplist = lockuser(VERIFYWRITE, arg2, gidsetsize * 2, 0); if (!targetgrouplist) goto efault; for(i = 0;i < ret; i++) targetgrouplist[i] = tswap16(grouplist[i]); unlockuser(targetgrouplist, arg2, gidsetsize * 2); } } break; case TARGETNRsetgroups: { int gidsetsize = arg1; uint16t *targetgrouplist; gidt *grouplist; int i; grouplist = alloca(gidsetsize * sizeof(gidt)); targetgrouplist = lockuser(VERIFYREAD, arg2, gidsetsize * 2, 1); if (!targetgrouplist) { ret = -TARGETEFAULT; goto fail; } for(i = 0;i < gidsetsize; i++) grouplist[i] = tswap16(targetgrouplist[i]); unlockuser(targetgrouplist, arg2, 0); ret = geterrno(setgroups(gidsetsize, grouplist)); } break; case TARGETNRfchown: ret = geterrno(fchown(arg1, low2highuid(arg2), low2highgid(arg3))); break; #if defined(TARGETNRfchownat) && defined(NRfchownat) case TARGETNRfchownat: if (!(p = lockuserstring(arg2))) goto efault; ret = geterrno(sysfchownat(arg1, p, low2highuid(arg3), low2highgid(arg4), arg5)); unlockuser(p, arg2, 0); break; #endif #ifdef TARGETNRsetresuid case TARGETNRsetresuid: ret = geterrno(setresuid(low2highuid(arg1), low2highuid(arg2), low2highuid(arg3))); break; #endif #ifdef TARGETNRgetresuid case TARGETNRgetresuid: { uidt ruid, euid, suid; ret = geterrno(getresuid(&ruid, &euid, &suid)); if (!iserror(ret)) { if (putuseru16(high2lowuid(ruid), arg1) || putuseru16(high2lowuid(euid), arg2) || putuseru16(high2lowuid(suid), arg3)) goto efault; } } break; #endif #ifdef TARGETNRgetresgid case TARGETNRsetresgid: ret = geterrno(setresgid(low2highgid(arg1), low2highgid(arg2), low2highgid(arg3))); break; #endif #ifdef TARGETNRgetresgid case TARGETNRgetresgid: { gidt rgid, egid, sgid; ret = geterrno(getresgid(&rgid, &egid, &sgid)); if (!iserror(ret)) { if (putuseru16(high2lowgid(rgid), arg1) || putuseru16(high2lowgid(egid), arg2) || putuseru16(high2lowgid(sgid), arg3)) goto efault; } } break; #endif case TARGETNRchown: if (!(p = lockuserstring(arg1))) goto efault; ret = geterrno(chown(p, low2highuid(arg2), low2highgid(arg3))); unlockuser(p, arg1, 0); break; case TARGETNRsetuid: ret = geterrno(setuid(low2highuid(arg1))); break; case TARGETNRsetgid: ret = geterrno(setgid(low2highgid(arg1))); break; case TARGETNRsetfsuid: ret = geterrno(setfsuid(arg1)); break; case TARGETNRsetfsgid: ret = geterrno(setfsgid(arg1)); break; #endif /* USEUID16 */ #ifdef TARGETNRlchown32 case TARGETNRlchown32: if (!(p = lockuserstring(arg1))) goto efault; ret = geterrno(lchown(p, arg2, arg3)); unlockuser(p, arg1, 0); break; #endif #ifdef TARGETNRgetuid32 case TARGETNRgetuid32: ret = geterrno(getuid()); break; #endif #if defined(TARGETNRgetxuid) && defined(TARGETALPHA) /* Alpha specific */ case TARGETNRgetxuid: { uidt euid; euid=geteuid(); ((CPUAlphaState *)cpuenv)->ir[IRA4]=euid; } ret = geterrno(getuid()); break; #endif #if defined(TARGETNRgetxgid) && defined(TARGETALPHA) /* Alpha specific */ case TARGETNRgetxgid: { uidt egid; egid=getegid(); ((CPUAlphaState *)cpuenv)->ir[IRA4]=egid; } ret = geterrno(getgid()); break; #endif #if defined(TARGETNRosfgetsysinfo) && defined(TARGETALPHA) /* Alpha specific */ case TARGETNRosfgetsysinfo: ret = -TARGETEOPNOTSUPP; switch (arg1) { case TARGETGSIIEEEFPCONTROL: { uint64t swcr, fpcr = cpualphaloadfpcr (cpuenv); /* Copied from linux ieeefpcrtoswcr. */ swcr = (fpcr >> 35) & SWCRSTATUSMASK; swcr |= (fpcr >> 36) & SWCRMAPDMZ; swcr |= (~fpcr >> 48) & (SWCRTRAPENABLEINV | SWCRTRAPENABLEDZE | SWCRTRAPENABLEOVF); swcr |= (~fpcr >> 57) & (SWCRTRAPENABLEUNF | SWCRTRAPENABLEINE); swcr |= (fpcr >> 47) & SWCRMAPUMZ; swcr |= (~fpcr >> 41) & SWCRTRAPENABLEDNO; if (putuseru64 (swcr, arg2)) goto efault; ret = 0; } break; /* case GSIIEEESTATEATSIGNAL: -- Not implemented in linux kernel. case GSIUACPROC: -- Retrieves current unaligned access state; not much used. case GSIPROCTYPE: -- Retrieves implver information; surely not used. case GSIGETHWRPB: -- Grabs a copy of the HWRPB; surely not used. */ } break; #endif #if defined(TARGETNRosfsetsysinfo) && defined(TARGETALPHA) /* Alpha specific */ case TARGETNRosfsetsysinfo: ret = -TARGETEOPNOTSUPP; switch (arg1) { case TARGETSSIIEEEFPCONTROL: case TARGETSSIIEEERAISEEXCEPTION: { uint64t swcr, fpcr, origfpcr; if (getuseru64 (swcr, arg2)) goto efault; origfpcr = cpualphaloadfpcr (cpuenv); fpcr = origfpcr & FPCRDYNMASK; /* Copied from linux ieeeswcrtofpcr. */ fpcr |= (swcr & SWCRSTATUSMASK) << 35; fpcr |= (swcr & SWCRMAPDMZ) << 36; fpcr |= (~swcr & (SWCRTRAPENABLEINV | SWCRTRAPENABLEDZE | SWCRTRAPENABLEOVF)) << 48; fpcr |= (~swcr & (SWCRTRAPENABLEUNF | SWCRTRAPENABLEINE)) << 57; fpcr |= (swcr & SWCRMAPUMZ ? FPCRUNDZ | FPCRUNFD : 0); fpcr |= (~swcr & SWCRTRAPENABLEDNO) << 41; cpualphastorefpcr (cpuenv, fpcr); ret = 0; if (arg1 == TARGETSSIIEEERAISEEXCEPTION) { /* Old exceptions are not signaled. */ fpcr &= ~(origfpcr & FPCRSTATUSMASK); /* If any exceptions set by this call, and are unmasked, send a signal. */ /* ??? FIXME */ } } break; /* case SSINVPAIRS: -- Used with SSINUACPROC to enable unaligned accesses. case SSIIEEESTATEATSIGNAL: case SSIIEEEIGNORESTATEATSIGNAL: -- Not implemented in linux kernel */ } break; #endif #ifdef TARGETNRosfsigprocmask /* Alpha specific. */ case TARGETNRosfsigprocmask: { abiulong mask; int how = arg1; sigsett set, oldset; switch(arg1) { case TARGETSIGBLOCK: how = SIGBLOCK; break; case TARGETSIGUNBLOCK: how = SIGUNBLOCK; break; case TARGETSIGSETMASK: how = SIGSETMASK; break; default: ret = -TARGETEINVAL; goto fail; } mask = arg2; targettohostoldsigset(&set, &mask); sigprocmask(arg1, &set, &oldset); hosttotargetoldsigset(&mask, &oldset); ret = mask; } break; #endif #ifdef TARGETNRgetgid32 case TARGETNRgetgid32: ret = geterrno(getgid()); break; #endif #ifdef TARGETNRgeteuid32 case TARGETNRgeteuid32: ret = geterrno(geteuid()); break; #endif #ifdef TARGETNRgetegid32 case TARGETNRgetegid32: ret = geterrno(getegid()); break; #endif #ifdef TARGETNRsetreuid32 case TARGETNRsetreuid32: ret = geterrno(setreuid(arg1, arg2)); break; #endif #ifdef TARGETNRsetregid32 case TARGETNRsetregid32: ret = geterrno(setregid(arg1, arg2)); break; #endif #ifdef TARGETNRgetgroups32 case TARGETNRgetgroups32: { int gidsetsize = arg1; uint32t *targetgrouplist; gidt *grouplist; int i; grouplist = alloca(gidsetsize * sizeof(gidt)); ret = geterrno(getgroups(gidsetsize, grouplist)); if (gidsetsize == 0) break; if (!iserror(ret)) { targetgrouplist = lockuser(VERIFYWRITE, arg2, gidsetsize * 4, 0); if (!targetgrouplist) { ret = -TARGETEFAULT; goto fail; } for(i = 0;i < ret; i++) targetgrouplist[i] = tswap32(grouplist[i]); unlockuser(targetgrouplist, arg2, gidsetsize * 4); } } break; #endif #ifdef TARGETNRsetgroups32 case TARGETNRsetgroups32: { int gidsetsize = arg1; uint32t *targetgrouplist; gidt *grouplist; int i; grouplist = alloca(gidsetsize * sizeof(gidt)); targetgrouplist = lockuser(VERIFYREAD, arg2, gidsetsize * 4, 1); if (!targetgrouplist) { ret = -TARGETEFAULT; goto fail; } for(i = 0;i < gidsetsize; i++) grouplist[i] = tswap32(targetgrouplist[i]); unlockuser(targetgrouplist, arg2, 0); ret = geterrno(setgroups(gidsetsize, grouplist)); } break; #endif #ifdef TARGETNRfchown32 case TARGETNRfchown32: ret = geterrno(fchown(arg1, arg2, arg3)); break; #endif #ifdef TARGETNRsetresuid32 case TARGETNRsetresuid32: ret = geterrno(setresuid(arg1, arg2, arg3)); break; #endif #ifdef TARGETNRgetresuid32 case TARGETNRgetresuid32: { uidt ruid, euid, suid; ret = geterrno(getresuid(&ruid, &euid, &suid)); if (!iserror(ret)) { if (putuseru32(ruid, arg1) || putuseru32(euid, arg2) || putuseru32(suid, arg3)) goto efault; } } break; #endif #ifdef TARGETNRsetresgid32 case TARGETNRsetresgid32: ret = geterrno(setresgid(arg1, arg2, arg3)); break; #endif #ifdef TARGETNRgetresgid32 case TARGETNRgetresgid32: { gidt rgid, egid, sgid; ret = geterrno(getresgid(&rgid, &egid, &sgid)); if (!iserror(ret)) { if (putuseru32(rgid, arg1) || putuseru32(egid, arg2) || putuseru32(sgid, arg3)) goto efault; } } break; #endif #ifdef TARGETNRchown32 case TARGETNRchown32: if (!(p = lockuserstring(arg1))) goto efault; ret = geterrno(chown(p, arg2, arg3)); unlockuser(p, arg1, 0); break; #endif #ifdef TARGETNRsetuid32 case TARGETNRsetuid32: ret = geterrno(setuid(arg1)); break; #endif #ifdef TARGETNRsetgid32 case TARGETNRsetgid32: ret = geterrno(setgid(arg1)); break; #endif #ifdef TARGETNRsetfsuid32 case TARGETNRsetfsuid32: ret = geterrno(setfsuid(arg1)); break; #endif #ifdef TARGETNRsetfsgid32 case TARGETNRsetfsgid32: ret = geterrno(setfsgid(arg1)); break; #endif case TARGETNRpivotroot: goto unimplemented; #ifdef TARGETNRmincore case TARGETNRmincore: { void *a; ret = -TARGETEFAULT; if (!(a = lockuser(VERIFYREAD, arg1,arg2, 0))) goto efault; if (!(p = lockuserstring(arg3))) goto mincorefail; ret = geterrno(mincore(a, arg2, p)); unlockuser(p, arg3, ret); mincorefail: unlockuser(a, arg1, 0); } break; #endif #ifdef TARGETNRarmfadvise6464 case TARGETNRarmfadvise6464: \t{ \t\t/* \t\t * armfadvise6464 looks like fadvise6464 but \t\t * with different argument order \t\t */ \t\tabilong temp; \t\ttemp = arg3; \t\targ3 = arg4; \t\targ4 = temp; \t} #endif #if defined(TARGETNRfadvise6464) || defined(TARGETNRarmfadvise6464) || defined(TARGETNRfadvise64) #ifdef TARGETNRfadvise6464 case TARGETNRfadvise6464: #endif #ifdef TARGETNRfadvise64 case TARGETNRfadvise64: #endif #ifdef TARGETS390X switch (arg4) { case 4: arg4 = POSIXFADVNOREUSE + 1; break; /* make sure it's an invalid value */ case 5: arg4 = POSIXFADVNOREUSE + 2; break; /* ditto */ case 6: arg4 = POSIXFADVDONTNEED; break; case 7: arg4 = POSIXFADVNOREUSE; break; default: break; } #endif ret = -posixfadvise(arg1, arg2, arg3, arg4); \tbreak; #endif #ifdef TARGETNRmadvise case TARGETNRmadvise: /* A straight passthrough may not be safe because qemu sometimes turns private flie-backed mappings into anonymous mappings. This will break MADVDONTNEED. This is a hint, so ignoring and returning success is ok. */ ret = geterrno(0); break; #endif #if TARGETABIBITS == 32 case TARGETNRfcntl64: { \tint cmd; \tstruct flock64 fl; \tstruct targetflock64 *targetfl; #ifdef TARGETARM \tstruct targeteabiflock64 *targetefl; #endif \tcmd = targettohostfcntlcmd(arg2); \tif (cmd == -TARGETEINVAL) \t\treturn cmd; switch(arg2) { case TARGETFGETLK64: #ifdef TARGETARM if (((CPUARMState *)cpuenv)->eabi) { if (!lockuserstruct(VERIFYREAD, targetefl, arg3, 1)) goto efault; fl.ltype = tswap16(targetefl->ltype); fl.lwhence = tswap16(targetefl->lwhence); fl.lstart = tswap64(targetefl->lstart); fl.llen = tswap64(targetefl->llen); fl.lpid = tswap32(targetefl->lpid); unlockuserstruct(targetefl, arg3, 0); } else #endif { if (!lockuserstruct(VERIFYREAD, targetfl, arg3, 1)) goto efault; fl.ltype = tswap16(targetfl->ltype); fl.lwhence = tswap16(targetfl->lwhence); fl.lstart = tswap64(targetfl->lstart); fl.llen = tswap64(targetfl->llen); fl.lpid = tswap32(targetfl->lpid); unlockuserstruct(targetfl, arg3, 0); } ret = geterrno(fcntl(arg1, cmd, &fl)); \t if (ret == 0) { #ifdef TARGETARM if (((CPUARMState *)cpuenv)->eabi) { if (!lockuserstruct(VERIFYWRITE, targetefl, arg3, 0)) goto efault; targetefl->ltype = tswap16(fl.ltype); targetefl->lwhence = tswap16(fl.lwhence); targetefl->lstart = tswap64(fl.lstart); targetefl->llen = tswap64(fl.llen); targetefl->lpid = tswap32(fl.lpid); unlockuserstruct(targetefl, arg3, 1); } else #endif { if (!lockuserstruct(VERIFYWRITE, targetfl, arg3, 0)) goto efault; targetfl->ltype = tswap16(fl.ltype); targetfl->lwhence = tswap16(fl.lwhence); targetfl->lstart = tswap64(fl.lstart); targetfl->llen = tswap64(fl.llen); targetfl->lpid = tswap32(fl.lpid); unlockuserstruct(targetfl, arg3, 1); } \t } \t break; case TARGETFSETLK64: case TARGETFSETLKW64: #ifdef TARGETARM if (((CPUARMState *)cpuenv)->eabi) { if (!lockuserstruct(VERIFYREAD, targetefl, arg3, 1)) goto efault; fl.ltype = tswap16(targetefl->ltype); fl.lwhence = tswap16(targetefl->lwhence); fl.lstart = tswap64(targetefl->lstart); fl.llen = tswap64(targetefl->llen); fl.lpid = tswap32(targetefl->lpid); unlockuserstruct(targetefl, arg3, 0); } else #endif { if (!lockuserstruct(VERIFYREAD, targetfl, arg3, 1)) goto efault; fl.ltype = tswap16(targetfl->ltype); fl.lwhence = tswap16(targetfl->lwhence); fl.lstart = tswap64(targetfl->lstart); fl.llen = tswap64(targetfl->llen); fl.lpid = tswap32(targetfl->lpid); unlockuserstruct(targetfl, arg3, 0); } ret = geterrno(fcntl(arg1, cmd, &fl)); \t break; default: ret = dofcntl(arg1, arg2, arg3); break; } \tbreak; } #endif #ifdef TARGETNRcacheflush case TARGETNRcacheflush: /* self-modifying code is handled automatically, so nothing needed */ ret = 0; break; #endif #ifdef TARGETNRsecurity case TARGETNRsecurity: goto unimplemented; #endif #ifdef TARGETNRgetpagesize case TARGETNRgetpagesize: ret = TARGETPAGESIZE; break; #endif case TARGETNRgettid: ret = geterrno(gettid()); break; #ifdef TARGETNRreadahead case TARGETNRreadahead: #if TARGETABIBITS == 32 #ifdef TARGETARM if (((CPUARMState *)cpuenv)->eabi) { arg2 = arg3; arg3 = arg4; arg4 = arg5; } #endif ret = geterrno(readahead(arg1, ((off64t)arg3 << 32) | arg2, arg4)); #else ret = geterrno(readahead(arg1, arg2, arg3)); #endif break; #endif #ifdef TARGETNRsetxattr case TARGETNRsetxattr: case TARGETNRlsetxattr: case TARGETNRfsetxattr: case TARGETNRgetxattr: case TARGETNRlgetxattr: case TARGETNRfgetxattr: case TARGETNRlistxattr: case TARGETNRllistxattr: case TARGETNRflistxattr: case TARGETNRremovexattr: case TARGETNRlremovexattr: case TARGETNRfremovexattr: ret = -TARGETEOPNOTSUPP; break; #endif #ifdef TARGETNRsetthreadarea case TARGETNRsetthreadarea: #if defined(TARGETMIPS) ((CPUMIPSState *) cpuenv)->tlsvalue = arg1; ret = 0; break; #elif defined(TARGETCRIS) if (arg1 & 0xff) ret = -TARGETEINVAL; else { ((CPUCRISState *) cpuenv)->pregs[PRPID] = arg1; ret = 0; } break; #elif defined(TARGETI386) && defined(TARGETABI32) ret = dosetthreadarea(cpuenv, arg1); break; #else goto unimplementednowarn; #endif #endif #ifdef TARGETNRgetthreadarea case TARGETNRgetthreadarea: #if defined(TARGETI386) && defined(TARGETABI32) ret = dogetthreadarea(cpuenv, arg1); #else goto unimplementednowarn; #endif #endif #ifdef TARGETNRgetdomainname case TARGETNRgetdomainname: goto unimplementednowarn; #endif #ifdef TARGETNRclockgettime case TARGETNRclockgettime: { struct timespec ts; ret = geterrno(clockgettime(arg1, &ts)); if (!iserror(ret)) { hosttotargettimespec(arg2, &ts); } break; } #endif #ifdef TARGETNRclockgetres case TARGETNRclockgetres: { struct timespec ts; ret = geterrno(clockgetres(arg1, &ts)); if (!iserror(ret)) { hosttotargettimespec(arg2, &ts); } break; } #endif #ifdef TARGETNRclocknanosleep case TARGETNRclocknanosleep: { struct timespec ts; targettohosttimespec(&ts, arg3); ret = geterrno(clocknanosleep(arg1, arg2, &ts, arg4 ? &ts : NULL)); if (arg4) hosttotargettimespec(arg4, &ts); break; } #endif #if defined(TARGETNRsettidaddress) && defined(NRsettidaddress) case TARGETNRsettidaddress: ret = geterrno(settidaddress((int *)g2h(arg1))); break; #endif #if defined(TARGETNRtkill) && defined(NRtkill) case TARGETNRtkill: ret = geterrno(systkill((int)arg1, targettohostsignal(arg2))); break; #endif #if defined(TARGETNRtgkill) && defined(NRtgkill) case TARGETNRtgkill: \tret = geterrno(systgkill((int)arg1, (int)arg2, targettohostsignal(arg3))); \tbreak; #endif #ifdef TARGETNRsetrobustlist case TARGETNRsetrobustlist: \tgoto unimplementednowarn; #endif #if defined(TARGETNRutimensat) && defined(NRutimensat) case TARGETNRutimensat: { struct timespec *tsp, ts[2]; if (!arg3) { tsp = NULL; } else { targettohosttimespec(ts, arg3); targettohosttimespec(ts+1, arg3+sizeof(struct targettimespec)); tsp = ts; } if (!arg2) ret = geterrno(sysutimensat(arg1, NULL, tsp, arg4)); else { if (!(p = lockuserstring(arg2))) { ret = -TARGETEFAULT; goto fail; } ret = geterrno(sysutimensat(arg1, path(p), tsp, arg4)); unlockuser(p, arg2, 0); } } \tbreak; #endif #if defined(CONFIGUSENPTL) case TARGETNRfutex: ret = dofutex(arg1, arg2, arg3, arg4, arg5, arg6); break; #endif #if defined(TARGETNRinotifyinit) && defined(NRinotifyinit) case TARGETNRinotifyinit: ret = geterrno(sysinotifyinit()); break; #endif #if defined(TARGETNRinotifyaddwatch) && defined(NRinotifyaddwatch) case TARGETNRinotifyaddwatch: p = lockuserstring(arg2); ret = geterrno(sysinotifyaddwatch(arg1, path(p), arg3)); unlockuser(p, arg2, 0); break; #endif #if defined(TARGETNRinotifyrmwatch) && defined(NRinotifyrmwatch) case TARGETNRinotifyrmwatch: ret = geterrno(sysinotifyrmwatch(arg1, arg2)); break; #endif #if defined(TARGETNRmqopen) && defined(NRmqopen) case TARGETNRmqopen: { struct mqattr posixmqattr; p = lockuserstring(arg1 - 1); if (arg4 != 0) copyfromusermqattr (&posixmqattr, arg4); ret = geterrno(mqopen(p, arg2, arg3, &posixmqattr)); unlockuser (p, arg1, 0); } break; case TARGETNRmqunlink: p = lockuserstring(arg1 - 1); ret = geterrno(mqunlink(p)); unlockuser (p, arg1, 0); break; case TARGETNRmqtimedsend: { struct timespec ts; p = lockuser (VERIFYREAD, arg2, arg3, 1); if (arg5 != 0) { targettohosttimespec(&ts, arg5); ret = geterrno(mqtimedsend(arg1, p, arg3, arg4, &ts)); hosttotargettimespec(arg5, &ts); } else ret = geterrno(mqsend(arg1, p, arg3, arg4)); unlockuser (p, arg2, arg3); } break; case TARGETNRmqtimedreceive: { struct timespec ts; unsigned int prio; p = lockuser (VERIFYREAD, arg2, arg3, 1); if (arg5 != 0) { targettohosttimespec(&ts, arg5); ret = geterrno(mqtimedreceive(arg1, p, arg3, &prio, &ts)); hosttotargettimespec(arg5, &ts); } else ret = geterrno(mqreceive(arg1, p, arg3, &prio)); unlockuser (p, arg2, arg3); if (arg4 != 0) putuseru32(prio, arg4); } break; /* Not implemented for now... */ /* case TARGETNRmqnotify: */ /* break; */ case TARGETNRmqgetsetattr: { struct mqattr posixmqattrin, posixmqattrout; ret = 0; if (arg3 != 0) { ret = mqgetattr(arg1, &posixmqattrout); copytousermqattr(arg3, &posixmqattrout); } if (arg2 != 0) { copyfromusermqattr(&posixmqattrin, arg2); ret |= mqsetattr(arg1, &posixmqattrin, &posixmqattrout); } } break; #endif #ifdef CONFIGSPLICE #ifdef TARGETNRtee case TARGETNRtee: { ret = geterrno(tee(arg1,arg2,arg3,arg4)); } break; #endif #ifdef TARGETNRsplice case TARGETNRsplice: { lofft loffin, loffout; lofft *ploffin = NULL, *ploffout = NULL; if(arg2) { getuseru64(loffin, arg2); ploffin = &loffin; } if(arg4) { getuseru64(loffout, arg2); ploffout = &loffout; } ret = geterrno(splice(arg1, ploffin, arg3, ploffout, arg5, arg6)); } break; #endif #ifdef TARGETNRvmsplice \tcase TARGETNRvmsplice: { int count = arg3; struct iovec *vec; vec = alloca(count * sizeof(struct iovec)); if (lockiovec(VERIFYREAD, vec, arg2, count, 1) < 0) goto efault; ret = geterrno(vmsplice(arg1, vec, count, arg4)); unlockiovec(vec, arg2, count, 0); } break; #endif #endif /* CONFIGSPLICE */ #ifdef CONFIGEVENTFD #if defined(TARGETNReventfd) case TARGETNReventfd: ret = geterrno(eventfd(arg1, 0)); break; #endif #if defined(TARGETNReventfd2) case TARGETNReventfd2: ret = geterrno(eventfd(arg1, arg2)); break; #endif #endif /* CONFIGEVENTFD */ #if defined(CONFIGFALLOCATE) && defined(TARGETNRfallocate) case TARGETNRfallocate: ret = geterrno(fallocate(arg1, arg2, arg3, arg4)); break; #endif default: unimplemented: gemulog(\"qemu: Unsupported syscall: %d\\n\", num); #if defined(TARGETNRsetxattr) || defined(TARGETNRgetthreadarea) || defined(TARGETNRgetdomainname) || defined(TARGETNRsetrobustlist) unimplementednowarn: #endif ret = -TARGETENOSYS; break; } fail: #ifdef DEBUG gemulog(\" = \" TARGETABIFMTld \"\\n\", ret); #endif if(dostrace) printsyscallret(num, ret); return ret; efault: ret = -TARGETEFAULT; goto fail; } ", "target": 0}
{"func": "cpux86dumpsegcache(CPUState *env, FILE *f, fprintffunction cpufprintf, const char *name, struct SegmentCache *sc) { #ifdef TARGETX8664 if (env->hflags & HFCS64MASK) { cpufprintf(f, \"%-3s=%04x %016\" PRIx64 \" %08x %08x\", name, sc->selector, sc->base, sc->limit, sc->flags); } else #endif { cpufprintf(f, \"%-3s=%04x %08x %08x %08x\", name, sc->selector, (uint32t)sc->base, sc->limit, sc->flags); } if (!(env->hflags & HFPEMASK) || !(sc->flags & DESCPMASK)) goto done; cpufprintf(f, \" DPL=%d \", (sc->flags & DESCDPLMASK) >> DESCDPLSHIFT); if (sc->flags & DESCSMASK) { if (sc->flags & DESCCSMASK) { cpufprintf(f, (sc->flags & DESCLMASK) ? \"CS64\" : ((sc->flags & DESCBMASK) ? \"CS32\" : \"CS16\")); cpufprintf(f, \" [%c%c\", (sc->flags & DESCCMASK) ? 'C' : '-', (sc->flags & DESCRMASK) ? 'R' : '-'); } else { cpufprintf(f, (sc->flags & DESCBMASK) ? \"DS \" : \"DS16\"); cpufprintf(f, \" [%c%c\", (sc->flags & DESCEMASK) ? 'E' : '-', (sc->flags & DESCWMASK) ? 'W' : '-'); } cpufprintf(f, \"%c]\", (sc->flags & DESCAMASK) ? 'A' : '-'); } else { static const char *systypename[2][16] = { { /* 32 bit mode */ \"Reserved\", \"TSS16-avl\", \"LDT\", \"TSS16-busy\", \"CallGate16\", \"TaskGate\", \"IntGate16\", \"TrapGate16\", \"Reserved\", \"TSS32-avl\", \"Reserved\", \"TSS32-busy\", \"CallGate32\", \"Reserved\", \"IntGate32\", \"TrapGate32\" }, { /* 64 bit mode */ \"<hiword>\", \"Reserved\", \"LDT\", \"Reserved\", \"Reserved\", \"Reserved\", \"Reserved\", \"Reserved\", \"Reserved\", \"TSS64-avl\", \"Reserved\", \"TSS64-busy\", \"CallGate64\", \"Reserved\", \"IntGate64\", \"TrapGate64\" } }; cpufprintf(f, \"%s\", systypename[(env->hflags & HFLMAMASK) ? 1 : 0] [(sc->flags & DESCTYPEMASK) >> DESCTYPESHIFT]); } done: cpufprintf(f, \"\\n\"); } ", "target": 0}
{"func": "void FUNCC(ffh264idctadd)(uint8t *dst, DCTELEM *block, int stride) { int i; INITCLIP pixel *dst = (pixel*)dst; dctcoef *block = (dctcoef*)block; stride /= sizeof(pixel); block[0] += 1 << 5; for(i=0; i<4; i++){ const int z0= block[i + 4*0] + block[i + 4*2]; const int z1= block[i + 4*0] - block[i + 4*2]; const int z2= (block[i + 4*1]>>1) - block[i + 4*3]; const int z3= block[i + 4*1] + (block[i + 4*3]>>1); block[i + 4*0]= z0 + z3; block[i + 4*1]= z1 + z2; block[i + 4*2]= z1 - z2; block[i + 4*3]= z0 - z3; } for(i=0; i<4; i++){ const int z0= block[0 + 4*i] + block[2 + 4*i]; const int z1= block[0 + 4*i] - block[2 + 4*i]; const int z2= (block[1 + 4*i]>>1) - block[3 + 4*i]; const int z3= block[1 + 4*i] + (block[3 + 4*i]>>1); dst[i + 0*stride]= CLIP(dst[i + 0*stride] + ((z0 + z3) >> 6)); dst[i + 1*stride]= CLIP(dst[i + 1*stride] + ((z1 + z2) >> 6)); dst[i + 2*stride]= CLIP(dst[i + 2*stride] + ((z1 - z2) >> 6)); dst[i + 3*stride]= CLIP(dst[i + 3*stride] + ((z0 - z3) >> 6)); } } ", "target": 1}
{"func": "static void disasfpccomp(DisasContext *s, uint32t insn) { unsigned int mos, type, rm, cond, rn, op, nzcv; TCGvi64 tcgflags; int labelcontinue = -1; mos = extract32(insn, 29, 3); type = extract32(insn, 22, 2); /* 0 = single, 1 = double */ rm = extract32(insn, 16, 5); cond = extract32(insn, 12, 4); rn = extract32(insn, 5, 5); op = extract32(insn, 4, 1); nzcv = extract32(insn, 0, 4); if (mos || type > 1) { unallocatedencoding(s); return; } if (!fpaccesscheck(s)) { return; } if (cond < 0x0e) { /* not always */ int labelmatch = gennewlabel(); labelcontinue = gennewlabel(); armgentestcc(cond, labelmatch); /* nomatch: */ tcgflags = tcgconsti64(nzcv << 28); gensetnzcv(tcgflags); tcgtempfreei64(tcgflags); tcggenbr(labelcontinue); gensetlabel(labelmatch); } handlefpcompare(s, type, rn, rm, false, op); if (cond < 0x0e) { gensetlabel(labelcontinue); } } ", "target": 0}
{"func": "static inline int testbit(unsigned int bit, const unsigned long *map) { return !!((map)[(bit) / BITSPERLONG] & (1UL << ((bit) % BITSPERLONG))); } ", "target": 0}
{"func": "static bool trypollmode(AioContext *ctx, bool blocking) { if (blocking && ctx->pollmaxns && ctx->polldisablecnt == 0) { /* See qemusoonesttimeout() uint64t hack */ int64t maxns = MIN((uint64t)aiocomputetimeout(ctx), (uint64t)ctx->pollns); if (maxns) { pollsetstarted(ctx, true); if (runpollhandlers(ctx, maxns)) { return true; } } } pollsetstarted(ctx, false); /* Even if we don't run busy polling, try polling once in case it can make * progress and the caller will be able to avoid ppoll(2)/epollwait(2). */ return runpollhandlersonce(ctx); } ", "target": 0}
{"func": "static int qmptmp105gettemperature(const char *id) { QDict *response; int ret; response = qmp(\"{ 'execute': 'qom-get', 'arguments': { 'path': '%s', \" \"'property': 'temperature' } }\", id); gassert(qdicthaskey(response, \"return\")); ret = qdictgetint(response, \"return\"); QDECREF(response); return ret; } ", "target": 1}
{"func": "static void decodesysinterrupts(CPUTriCoreState *env, DisasContext *ctx) { uint32t op2; uint32t r1; TCGLabel *l1; TCGv tmp; op2 = MASKOPSYSOP2(ctx->opcode); r1 = MASKOPSYSS1D(ctx->opcode); switch (op2) { case OPC232SYSDEBUG: /* raise EXCPDEBUG */ break; case OPC232SYSDISABLE: tcggenanditl(cpuICR, cpuICR, ~MASKICRIE); break; case OPC232SYSDSYNC: break; case OPC232SYSENABLE: tcggenoritl(cpuICR, cpuICR, MASKICRIE); break; case OPC232SYSISYNC: break; case OPC232SYSNOP: break; case OPC232SYSRET: gencomputebranch(ctx, op2, 0, 0, 0, 0); break; case OPC232SYSFRET: genfret(ctx); break; case OPC232SYSRFE: genhelperrfe(cpuenv); tcggenexittb(0); ctx->bstate = BSBRANCH; break; case OPC232SYSRFM: if ((ctx->hflags & TRICOREHFLAGKUU) == TRICOREHFLAGSM) { tmp = tcgtempnew(); l1 = gennewlabel(); tcggenld32utl(tmp, cpuenv, offsetof(CPUTriCoreState, DBGSR)); tcggenanditl(tmp, tmp, MASKDBGSRDE); tcggenbrconditl(TCGCONDNE, tmp, 1, l1); genhelperrfm(cpuenv); gensetlabel(l1); tcggenexittb(0); ctx->bstate = BSBRANCH; tcgtempfree(tmp); } else { /* generate privilege trap */ } break; case OPC232SYSRSLCX: genhelperrslcx(cpuenv); break; case OPC232SYSSVLCX: genhelpersvlcx(cpuenv); break; case OPC232SYSRESTORE: if (tricorefeature(env, TRICOREFEATURE16)) { if ((ctx->hflags & TRICOREHFLAGKUU) == TRICOREHFLAGSM || (ctx->hflags & TRICOREHFLAGKUU) == TRICOREHFLAGUM1) { tcggendeposittl(cpuICR, cpuICR, cpugprd[r1], 8, 1); } /* else raise privilege trap */ } /* else raise illegal opcode trap */ break; case OPC232SYSTRAPSV: l1 = gennewlabel(); tcggenbrconditl(TCGCONDGE, cpuPSWSV, 0, l1); generatetrap(ctx, TRAPCASSERT, TIN5SOVF); gensetlabel(l1); break; case OPC232SYSTRAPV: l1 = gennewlabel(); tcggenbrconditl(TCGCONDGE, cpuPSWV, 0, l1); generatetrap(ctx, TRAPCASSERT, TIN5OVF); gensetlabel(l1); break; } } ", "target": 1}
{"func": "static void pcihotplug(void) { QVirtioPCIDevice *dev; QOSState *qs; const char *arch = qtestgetarch(); qs = pciteststart(); /* plug secondary disk */ qpciplugdevicetest(\"virtio-blk-pci\", \"drv1\", PCISLOTHP, \"'drive': 'drive1'\"); dev = virtioblkpciinit(qs->pcibus, PCISLOTHP); gassert(dev); qvirtiopcidevicedisable(dev); gfree(dev); /* unplug secondary disk */ if (strcmp(arch, \"i386\") == 0 || strcmp(arch, \"x8664\") == 0) { qpciunplugacpidevicetest(\"drv1\", PCISLOTHP); } qtestshutdown(qs); } ", "target": 1}
{"func": "static unsigned long ivdecodeframe(Indeo3DecodeContext *s, unsigned char *buf, int bufsize) { unsigned int hdrwidth, hdrheight, chromawidth, chromaheight; unsigned long fflags1, fflags2, fflags3, offs1, offs2, offs3, offs; unsigned char *hdrpos, *bufpos; bufpos = buf; bufpos += 18; fflags1 = le2me16(*(uint16t *)bufpos); bufpos += 2; fflags3 = le2me32(*(uint32t *)bufpos); bufpos += 4; fflags2 = *bufpos++; bufpos += 3; hdrheight = le2me16(*(uint16t *)bufpos); bufpos += 2; hdrwidth = le2me16(*(uint16t *)bufpos); bufpos += 2; chromaheight = ((hdrheight >> 2) + 3) & 0x7ffc; chromawidth = ((hdrwidth >> 2) + 3) & 0x7ffc; offs1 = le2me32(*(uint32t *)bufpos); bufpos += 4; offs2 = le2me32(*(uint32t *)bufpos); bufpos += 4; offs3 = le2me32(*(uint32t *)bufpos); bufpos += 8; hdrpos = bufpos; if(fflags3 == 0x80) return 4; if(fflags1 & 0x200) { s->curframe = s->ivframe + 1; s->refframe = s->ivframe; } else { s->curframe = s->ivframe; s->refframe = s->ivframe + 1; } bufpos = buf + 16 + offs1; offs = le2me32(*(uint32t *)bufpos); bufpos += 4; ivDecodeChunk(s, s->curframe->Ybuf, s->refframe->Ybuf, hdrwidth, hdrheight, bufpos + offs * 2, fflags2, hdrpos, bufpos, min(hdrwidth, 160)); if (!(s->avctx->flags & CODECFLAGGRAY)) { bufpos = buf + 16 + offs2; offs = le2me32(*(uint32t *)bufpos); bufpos += 4; ivDecodeChunk(s, s->curframe->Vbuf, s->refframe->Vbuf, chromawidth, chromaheight, bufpos + offs * 2, fflags2, hdrpos, bufpos, min(chromawidth, 40)); bufpos = buf + 16 + offs3; offs = le2me32(*(uint32t *)bufpos); bufpos += 4; ivDecodeChunk(s, s->curframe->Ubuf, s->refframe->Ubuf, chromawidth, chromaheight, bufpos + offs * 2, fflags2, hdrpos, bufpos, min(chromawidth, 40)); } return 8; }", "target": 1}
{"func": "int genintermediatecodeinternal (CPUState *env, TranslationBlock *tb, int searchpc) { DisasContext ctx, *ctxp = &ctx; opchandlert **table, *handler; targetulong pcstart; uint16t *genopcend; int j, lj = -1; pcstart = tb->pc; genopcptr = genopcbuf; genopcend = genopcbuf + OPCMAXSIZE; genopparamptr = genopparambuf; nbgenlabels = 0; ctx.nip = pcstart; ctx.tb = tb; ctx.exception = EXCPNONE; ctx.sprcb = env->sprcb; #if defined(CONFIGUSERONLY) ctx.memidx = msrle; #else ctx.supervisor = 1 - msrpr; ctx.memidx = ((1 - msrpr) << 1) | msrle; #endif ctx.fpuenabled = msrfp; ctx.singlestepenabled = env->singlestepenabled; #if defined (DOSINGLESTEP) && 0 /* Single step trace mode */ msrse = 1; #endif /* Set env in case of segfault during code fetch */ while (ctx.exception == EXCPNONE && genopcptr < genopcend) { if (unlikely(env->nbbreakpoints > 0)) { for (j = 0; j < env->nbbreakpoints; j++) { if (env->breakpoints[j] == ctx.nip) { genopupdatenip(ctx.nip); genopdebug(); break; } } } if (unlikely(searchpc)) { j = genopcptr - genopcbuf; if (lj < j) { lj++; while (lj < j) genopcinstrstart[lj++] = 0; genopcpc[lj] = ctx.nip; genopcinstrstart[lj] = 1; } } #if defined PPCDEBUGDISAS if (loglevel & CPULOGTBINASM) { fprintf(logfile, \"----------------\\n\"); fprintf(logfile, \"nip=%08x super=%d ir=%d\\n\", ctx.nip, 1 - msrpr, msrir); } #endif ctx.opcode = ldlcode(ctx.nip); if (msrle) { ctx.opcode = ((ctx.opcode & 0xFF000000) >> 24) | ((ctx.opcode & 0x00FF0000) >> 8) | ((ctx.opcode & 0x0000FF00) << 8) | ((ctx.opcode & 0x000000FF) << 24); } #if defined PPCDEBUGDISAS if (loglevel & CPULOGTBINASM) { fprintf(logfile, \"translate opcode %08x (%02x %02x %02x) (%s)\\n\", ctx.opcode, opc1(ctx.opcode), opc2(ctx.opcode), opc3(ctx.opcode), msrle ? \"little\" : \"big\"); } #endif ctx.nip += 4; table = env->opcodes; handler = table[opc1(ctx.opcode)]; if (isindirectopcode(handler)) { table = indtable(handler); handler = table[opc2(ctx.opcode)]; if (isindirectopcode(handler)) { table = indtable(handler); handler = table[opc3(ctx.opcode)]; } } /* Is opcode *REALLY* valid ? */ if (unlikely(handler->handler == &geninvalid)) { if (loglevel > 0) { fprintf(logfile, \"invalid/unsupported opcode: \" \"%02x - %02x - %02x (%08x) 0x%08x %d\\n\", opc1(ctx.opcode), opc2(ctx.opcode), opc3(ctx.opcode), ctx.opcode, ctx.nip - 4, msrir); } else { printf(\"invalid/unsupported opcode: \" \"%02x - %02x - %02x (%08x) 0x%08x %d\\n\", opc1(ctx.opcode), opc2(ctx.opcode), opc3(ctx.opcode), ctx.opcode, ctx.nip - 4, msrir); } } else { if (unlikely((ctx.opcode & handler->inval) != 0)) { if (loglevel > 0) { fprintf(logfile, \"invalid bits: %08x for opcode: \" \"%02x -%02x - %02x (0x%08x) (0x%08x)\\n\", ctx.opcode & handler->inval, opc1(ctx.opcode), opc2(ctx.opcode), opc3(ctx.opcode), ctx.opcode, ctx.nip - 4); } else { printf(\"invalid bits: %08x for opcode: \" \"%02x -%02x - %02x (0x%08x) (0x%08x)\\n\", ctx.opcode & handler->inval, opc1(ctx.opcode), opc2(ctx.opcode), opc3(ctx.opcode), ctx.opcode, ctx.nip - 4); } RETINVAL(ctxp); break; } } (*(handler->handler))(&ctx); #if defined(DOPPCSTATISTICS) handler->count++; #endif /* Check trace mode exceptions */ if (unlikely((msrbe && ctx.exception == EXCPBRANCH) || /* Check in single step trace mode * we need to stop except if: * - rfi, trap or syscall * - first instruction of an exception handler */ (msrse && (ctx.nip < 0x100 || ctx.nip > 0xF00 || (ctx.nip & 0xFC) != 0x04) && ctx.exception != EXCPSYSCALL && ctx.exception != EXCPSYSCALLUSER && ctx.exception != EXCPTRAP))) { RETEXCP(ctxp, EXCPTRACE, 0); } /* if we reach a page boundary or are single stepping, stop * generation */ if (unlikely(((ctx.nip & (TARGETPAGESIZE - 1)) == 0) || (env->singlestepenabled))) { break; } #if defined (DOSINGLESTEP) break; #endif } if (ctx.exception == EXCPNONE) { gengototb(&ctx, 0, ctx.nip); } else if (ctx.exception != EXCPBRANCH) { genopresetT0(); /* Generate the return instruction */ genopexittb(); } *genopcptr = INDEXopend; if (unlikely(searchpc)) { j = genopcptr - genopcbuf; lj++; while (lj <= j) genopcinstrstart[lj++] = 0; tb->size = 0; } else { tb->size = ctx.nip - pcstart; } #ifdef DEBUGDISAS if (loglevel & CPULOGTBCPU) { fprintf(logfile, \"---------------- excp: %04x\\n\", ctx.exception); cpudumpstate(env, logfile, fprintf, 0); } if (loglevel & CPULOGTBINASM) { int flags; flags = msrle; fprintf(logfile, \"IN: %s\\n\", lookupsymbol(pcstart)); targetdisas(logfile, pcstart, ctx.nip - pcstart, flags); fprintf(logfile, \"\\n\"); } if (loglevel & CPULOGTBOP) { fprintf(logfile, \"OP:\\n\"); dumpops(genopcbuf, genopparambuf); fprintf(logfile, \"\\n\"); } #endif return 0; } ", "target": 1}
{"func": "static void testidedrivecd0(void) { char *argv[256]; int argc, ideidx; Backend i; argc = setupcommon(argv, ARRAYSIZE(argv)); for (i = 0; i <= backendempty; i++) { ideidx = backendempty - i; curide[ideidx] = &hdchst[i][mbrblank]; argc = setupide(argc, argv, ARRAYSIZE(argv), ideidx, NULL, i, mbrblank, \"\"); } qteststart(gstrjoinv(\" \", argv)); testcmos(); qtestend(); } ", "target": 1}
{"func": "static int decodevolheader(MpegEncContext *s, GetBitContext *gb){ int width, height, voverid; /* vol header */ skipbits(gb, 1); /* random access */ s->votype= getbits(gb, 8); if (getbits1(gb) != 0) { /* isolid */ voverid = getbits(gb, 4); /* voverid */ skipbits(gb, 3); /* vopriority */ } else { voverid = 1; } //printf(\"vo type:%d\\n\",s->votype); s->aspectratioinfo= getbits(gb, 4); if(s->aspectratioinfo == FFASPECTEXTENDED){\t s->aspectedwidth = getbits(gb, 8); // parwidth s->aspectedheight = getbits(gb, 8); // parheight }else{ s->aspectedwidth = pixelaspect[s->aspectratioinfo][0]; s->aspectedheight= pixelaspect[s->aspectratioinfo][1]; } if ((s->volcontrolparameters=getbits1(gb))) { /* vol control parameter */ int chromaformat= getbits(gb, 2); if(chromaformat!=1){ printf(\"illegal chroma format\\n\"); } s->lowdelay= getbits1(gb); if(getbits1(gb)){ /* vbv parameters */ getbits(gb, 15);\t/* firsthalfbitrate */ skipbits1(gb);\t/* marker */ getbits(gb, 15);\t/* latterhalfbitrate */ skipbits1(gb);\t/* marker */ getbits(gb, 15);\t/* firsthalfvbvbuffersize */ skipbits1(gb);\t/* marker */ getbits(gb, 3);\t/* latterhalfvbvbuffersize */ getbits(gb, 11);\t/* firsthalfvbvoccupancy */ skipbits1(gb);\t/* marker */ getbits(gb, 15);\t/* latterhalfvbvoccupancy */ skipbits1(gb);\t/* marker */ } }else{ // set low delay flag only once so the smart? low delay detection wont be overriden if(s->picturenumber==0) s->lowdelay=0; } s->shape = getbits(gb, 2); /* vol shape */ if(s->shape != RECTSHAPE) printf(\"only rectangular vol supported\\n\"); if(s->shape == GRAYSHAPE && voverid != 1){ printf(\"Gray shape not supported\\n\"); skipbits(gb, 4); //videoobjectlayershapeextension } skipbits1(gb); /* marker */ s->timeincrementresolution = getbits(gb, 16); s->timeincrementbits = avlog2(s->timeincrementresolution - 1) + 1; if (s->timeincrementbits < 1) s->timeincrementbits = 1; skipbits1(gb); /* marker */ if (getbits1(gb) != 0) { /* fixedvoprate */ skipbits(gb, s->timeincrementbits); } if (s->shape != BINONLYSHAPE) { if (s->shape == RECTSHAPE) { skipbits1(gb); /* marker */ width = getbits(gb, 13); skipbits1(gb); /* marker */ height = getbits(gb, 13); skipbits1(gb); /* marker */ if(width && height){ /* they should be non zero but who knows ... */ s->width = width; s->height = height; // printf(\"width/height: %d %d\\n\", width, height); } } s->progressivesequence= getbits1(gb)^1; if(!getbits1(gb)) printf(\"OBMC not supported (very likely buggy encoder)\\n\"); /* OBMC Disable */ if (voverid == 1) { s->volspriteusage = getbits1(gb); /* volspriteusage */ } else { s->volspriteusage = getbits(gb, 2); /* volspriteusage */ } if(s->volspriteusage==STATICSPRITE) printf(\"Static Sprites not supported\\n\"); if(s->volspriteusage==STATICSPRITE || s->volspriteusage==GMCSPRITE){ if(s->volspriteusage==STATICSPRITE){ s->spritewidth = getbits(gb, 13); skipbits1(gb); /* marker */ s->spriteheight= getbits(gb, 13); skipbits1(gb); /* marker */ s->spriteleft = getbits(gb, 13); skipbits1(gb); /* marker */ s->spritetop = getbits(gb, 13); skipbits1(gb); /* marker */ } s->numspritewarpingpoints= getbits(gb, 6); s->spritewarpingaccuracy = getbits(gb, 2); s->spritebrightnesschange= getbits1(gb); if(s->volspriteusage==STATICSPRITE) s->lowlatencysprite= getbits1(gb); } // FIXME sadct disable bit if verid!=1 && shape not rect if (getbits1(gb) == 1) { /* not8bit */ s->quantprecision = getbits(gb, 4); /* quantprecision */ if(getbits(gb, 4)!=8) printf(\"N-bit not supported\\n\"); /* bitsperpixel */ if(s->quantprecision!=5) printf(\"quant precission %d\\n\", s->quantprecision); } else { s->quantprecision = 5; } // FIXME a bunch of grayscale shape things if((s->mpegquant=getbits1(gb))){ /* volquanttype */ int i, v; /* load default matrixes */ for(i=0; i<64; i++){ int j= s->dsp.idctpermutation[i]; v= ffmpeg4defaultintramatrix[i]; s->intramatrix[j]= v; s->chromaintramatrix[j]= v; v= ffmpeg4defaultnonintramatrix[i]; s->intermatrix[j]= v; s->chromaintermatrix[j]= v; } /* load custom intra matrix */ if(getbits1(gb)){ int last=0; \t\tfor(i=0; i<64; i++){ int j; v= getbits(gb, 8); if(v==0) break; last= v; j= s->dsp.idctpermutation[ ffzigzagdirect[i] ]; s->intramatrix[j]= v; s->chromaintramatrix[j]= v; } /* replicate last value */ for(; i<64; i++){ \t\t int j= s->dsp.idctpermutation[ ffzigzagdirect[i] ]; s->intramatrix[j]= v; s->chromaintramatrix[j]= v; } } /* load custom non intra matrix */ if(getbits1(gb)){ int last=0; \t\tfor(i=0; i<64; i++){ int j; v= getbits(gb, 8); if(v==0) break; last= v; j= s->dsp.idctpermutation[ ffzigzagdirect[i] ]; s->intermatrix[j]= v; s->chromaintermatrix[j]= v; } /* replicate last value */ for(; i<64; i++){ \t\t int j= s->dsp.idctpermutation[ ffzigzagdirect[i] ]; s->intermatrix[j]= last; s->chromaintermatrix[j]= last; } } // FIXME a bunch of grayscale shape things } if(voverid != 1) s->quartersample= getbits1(gb); else s->quartersample=0; if(!getbits1(gb)) printf(\"Complexity estimation not supported\\n\"); s->resyncmarker= !getbits1(gb); /* resyncmarkerdisabled */ s->datapartitioning= getbits1(gb); if(s->datapartitioning){ s->rvlc= getbits1(gb); if(s->rvlc){ printf(\"reversible vlc not supported\\n\"); } } if(voverid != 1) { s->newpred= getbits1(gb); if(s->newpred){ printf(\"new pred not supported\\n\"); skipbits(gb, 2); /* requested upstream message type */ skipbits1(gb); /* newpred segment type */ } s->reducedresvop= getbits1(gb); if(s->reducedresvop) printf(\"reduced resolution VOP not supported\\n\"); } else{ s->newpred=0; s->reducedresvop= 0; } s->scalability= getbits1(gb); if (s->scalability) { GetBitContext bak= *gb; int reflayerid; int reflayersamplingdir; int hsamplingfactorn; int hsamplingfactorm; int vsamplingfactorn; int vsamplingfactorm; s->hierachytype= getbits1(gb); reflayerid= getbits(gb, 4); reflayersamplingdir= getbits1(gb); hsamplingfactorn= getbits(gb, 5); hsamplingfactorm= getbits(gb, 5); vsamplingfactorn= getbits(gb, 5); vsamplingfactorm= getbits(gb, 5); s->enhancementtype= getbits1(gb); if( hsamplingfactorn==0 || hsamplingfactorm==0 || vsamplingfactorn==0 || vsamplingfactorm==0){ // fprintf(stderr, \"illegal scalability header (VERY broken encoder), trying to workaround\\n\"); s->scalability=0; *gb= bak; }else printf(\"scalability not supported\\n\"); // bin shape stuff FIXME } } return 0; } ", "target": 0}
{"func": "void ffinitme(MpegEncContext *s){ MotionEstContext * const c= &s->me; c->avctx= s->avctx; ffsetcmp(&s->dsp, s->dsp.meprecmp, c->avctx->meprecmp); ffsetcmp(&s->dsp, s->dsp.mecmp, c->avctx->mecmp); ffsetcmp(&s->dsp, s->dsp.mesubcmp, c->avctx->mesubcmp); ffsetcmp(&s->dsp, s->dsp.mbcmp, c->avctx->mbcmp); c->flags = getflags(c, 0, c->avctx->mecmp &FFCMPCHROMA); c->subflags= getflags(c, 0, c->avctx->mesubcmp&FFCMPCHROMA); c->mbflags = getflags(c, 0, c->avctx->mbcmp &FFCMPCHROMA); /*FIXME s->norounding btype*/ if(s->flags&CODECFLAGQPEL){ c->submotionsearch= qpelmotionsearch; c->qpelavg= s->dsp.avgqpelpixelstab; if(s->norounding) c->qpelput= s->dsp.putnorndqpelpixelstab; else c->qpelput= s->dsp.putqpelpixelstab; }else{ if(c->avctx->mesubcmp&FFCMPCHROMA) c->submotionsearch= hpelmotionsearch; else if( c->avctx->mesubcmp == FFCMPSAD && c->avctx-> mecmp == FFCMPSAD && c->avctx-> mbcmp == FFCMPSAD) c->submotionsearch= sadhpelmotionsearch; // 2050 vs. 2450 cycles else c->submotionsearch= hpelmotionsearch; } c->hpelavg= s->dsp.avgpixelstab; if(s->norounding) c->hpelput= s->dsp.putnorndpixelstab; else c->hpelput= s->dsp.putpixelstab; if(s->linesize){ c->stride = s->linesize; c->uvstride= s->uvlinesize; }else{ c->stride = 16*s->mbwidth + 32; c->uvstride= 8*s->mbwidth + 16; } // 8x8 fullpel search would need a 4x4 chroma compare, which we dont have yet, and even if we had the motion estimation code doesnt expect it if((c->avctx->mecmp&FFCMPCHROMA) && !s->dsp.mecmp[2]){ s->dsp.mecmp[2]= zerocmp; } if((c->avctx->mesubcmp&FFCMPCHROMA) && !s->dsp.mesubcmp[2]){ s->dsp.mesubcmp[2]= zerocmp; } c->hpelput[2][0]= c->hpelput[2][1]= c->hpelput[2][2]= c->hpelput[2][3]= zerohpel; c->temp= c->scratchpad; } ", "target": 0}
{"func": "static void filter(MpegAudioContext *s, int ch, short *samples, int incr) { short *p, *q; int sum, offset, i, j, norm, n; short tmp[64]; int tmp1[32]; int *out; // printpow1(samples, 1152); offset = s->samplesoffset[ch]; out = &s->sbsamples[ch][0][0][0]; for(j=0;j<36;j++) { /* 32 samples at once */ for(i=0;i<32;i++) { s->samplesbuf[ch][offset + (31 - i)] = samples[0]; samples += incr; } /* filter */ p = s->samplesbuf[ch] + offset; q = filterbank; /* maxsum = 23169 */ for(i=0;i<64;i++) { sum = p[0*64] * q[0*64]; sum += p[1*64] * q[1*64]; sum += p[2*64] * q[2*64]; sum += p[3*64] * q[3*64]; sum += p[4*64] * q[4*64]; sum += p[5*64] * q[5*64]; sum += p[6*64] * q[6*64]; sum += p[7*64] * q[7*64]; tmp[i] = sum >> 14; p++; q++; } tmp1[0] = tmp[16]; for( i=1; i<=16; i++ ) tmp1[i] = tmp[i+16]+tmp[16-i]; for( i=17; i<=31; i++ ) tmp1[i] = tmp[i+16]-tmp[80-i]; /* integer IDCT 32 with normalization. XXX: There may be some overflow left */ norm = 0; for(i=0;i<32;i++) { norm |= abs(tmp1[i]); } n = avlog2(norm) - 12; if (n > 0) { for(i=0;i<32;i++) tmp1[i] >>= n; } else { n = 0; } idct32(out, tmp1, s->sblimit, n); /* advance of 32 samples */ offset -= 32; out += 32; /* handle the wrap around */ if (offset < 0) { memmove(s->samplesbuf[ch] + SAMPLESBUFSIZE - (512 - 32), s->samplesbuf[ch], (512 - 32) * 2); offset = SAMPLESBUFSIZE - 512; } } s->samplesoffset[ch] = offset; // printpow(s->sbsamples, 1152); } ", "target": 1}
{"func": "int kvmarchhandleexit(CPUState *cs, struct kvmrun *run) { S390CPU *cpu = S390CPU(cs); int ret = 0; switch (run->exitreason) { case KVMEXITS390SIEIC: ret = handleintercept(cpu); break; case KVMEXITS390RESET: qemusystemresetrequest(); break; case KVMEXITS390TSCH: ret = handletsch(cpu); break; case KVMEXITDEBUG: ret = kvmarchhandledebugexit(cpu); break; default: fprintf(stderr, \"Unknown KVM exit: %d\\n\", run->exitreason); break; } if (ret == 0) { ret = EXCPINTERRUPT; } return ret; } ", "target": 0}
{"func": "AddressSpace *pcideviceiommuaddressspace(PCIDevice *dev) { PCIBus *bus = PCIBUS(dev->bus); PCIBus *iommubus = bus; while(iommubus && !iommubus->iommufn && iommubus->parentdev) { iommubus = PCIBUS(iommubus->parentdev->bus); } if (iommubus && iommubus->iommufn) { return iommubus->iommufn(bus, iommubus->iommuopaque, dev->devfn); } return &addressspacememory; } ", "target": 0}
{"func": "static inline void genopevalfbo(TCGv dst, TCGv src, unsigned int fccoffset) { genmovregFCC0(dst, src, fccoffset); genmovregFCC1(cputmp0, src, fccoffset); tcggenandtl(dst, dst, cputmp0); tcggenxoritl(dst, dst, 0x1); } ", "target": 0}
{"func": "static int dvbsubdecode(AVCodecContext *avctx, void *data, int *datasize, AVPacket *avpkt) { const uint8t *buf = avpkt->data; int bufsize = avpkt->size; DVBSubContext *ctx = avctx->privdata; AVSubtitle *sub = data; const uint8t *p, *pend; int segmenttype; int pageid; int segmentlength; int i; avdlog(avctx, \"DVB sub packet:\\n\"); for (i=0; i < bufsize; i++) { avdlog(avctx, \"%02x \", buf[i]); if (i % 16 == 15) avdlog(avctx, \"\\n\"); } if (i % 16) avdlog(avctx, \"\\n\"); if (bufsize <= 6 || *buf != 0x0f) { avdlog(avctx, \"incomplete or broken packet\"); return -1; } p = buf; pend = buf + bufsize; while (pend - p >= 6 && *p == 0x0f) { p += 1; segmenttype = *p++; pageid = AVRB16(p); p += 2; segmentlength = AVRB16(p); p += 2; if (pend - p < segmentlength) { avdlog(avctx, \"incomplete or broken packet\"); return -1; } if (pageid == ctx->compositionid || pageid == ctx->ancillaryid || ctx->compositionid == -1 || ctx->ancillaryid == -1) { switch (segmenttype) { case DVBSUBPAGESEGMENT: dvbsubparsepagesegment(avctx, p, segmentlength); break; case DVBSUBREGIONSEGMENT: dvbsubparseregionsegment(avctx, p, segmentlength); break; case DVBSUBCLUTSEGMENT: dvbsubparseclutsegment(avctx, p, segmentlength); break; case DVBSUBOBJECTSEGMENT: dvbsubparseobjectsegment(avctx, p, segmentlength); break; case DVBSUBDISPLAYDEFINITIONSEGMENT: dvbsubparsedisplaydefinitionsegment(avctx, p, segmentlength); break; case DVBSUBDISPLAYSEGMENT: *datasize = dvbsubdisplayendsegment(avctx, p, segmentlength, sub); break; default: avdlog(avctx, \"Subtitling segment type 0x%x, page id %d, length %d\\n\", segmenttype, pageid, segmentlength); break; } } p += segmentlength; } return p - buf; } ", "target": 0}
{"func": "static void *mpc8544loaddevicetree(targetphysaddrt addr, uint32t ramsize, targetphysaddrt initrdbase, targetphysaddrt initrdsize, const char *kernelcmdline) { void *fdt = NULL; #ifdef CONFIGFDT uint32t memregproperty[] = {0, ramsize}; char *filename; int fdtsize; int ret; filename = qemufindfile(QEMUFILETYPEBIOS, BINARYDEVICETREEFILE); if (!filename) { goto out; } fdt = loaddevicetree(filename, &fdtsize); qemufree(filename); if (fdt == NULL) { goto out; } /* Manipulate device tree in memory. */ ret = qemudevtreesetprop(fdt, \"/memory\", \"reg\", memregproperty, sizeof(memregproperty)); if (ret < 0) fprintf(stderr, \"couldn't set /memory/reg\\n\"); ret = qemudevtreesetpropcell(fdt, \"/chosen\", \"linux,initrd-start\", initrdbase); if (ret < 0) fprintf(stderr, \"couldn't set /chosen/linux,initrd-start\\n\"); ret = qemudevtreesetpropcell(fdt, \"/chosen\", \"linux,initrd-end\", (initrdbase + initrdsize)); if (ret < 0) fprintf(stderr, \"couldn't set /chosen/linux,initrd-end\\n\"); ret = qemudevtreesetpropstring(fdt, \"/chosen\", \"bootargs\", kernelcmdline); if (ret < 0) fprintf(stderr, \"couldn't set /chosen/bootargs\\n\"); if (kvmenabled()) { struct dirent *dirp; DIR *dp; char buf[128]; if ((dp = opendir(\"/proc/device-tree/cpus/\")) == NULL) { printf(\"Can't open directory /proc/device-tree/cpus/\\n\"); goto out; } buf[0] = '\\0'; while ((dirp = readdir(dp)) != NULL) { if (strncmp(dirp->dname, \"PowerPC\", 7) == 0) { snprintf(buf, 128, \"/cpus/%s\", dirp->dname); break; } } closedir(dp); if (buf[0] == '\\0') { printf(\"Unknow host!\\n\"); goto out; } mpc8544copysoccell(fdt, buf, \"clock-frequency\"); mpc8544copysoccell(fdt, buf, \"timebase-frequency\"); } cpuphysicalmemorywrite (addr, (void *)fdt, fdtsize); out: #endif return fdt; } ", "target": 0}
{"func": "static int movreadtrak(MOVContext *c, ByteIOContext *pb, MOVatomt atom) { AVStream *st; MOVStreamContext *sc; int ret; st = avnewstream(c->fc, c->fc->nbstreams); if (!st) return AVERROR(ENOMEM); sc = avmallocz(sizeof(MOVStreamContext)); if (!sc) return AVERROR(ENOMEM); st->privdata = sc; st->codec->codectype = CODECTYPEDATA; st->starttime = 0; /* XXX: check */ if ((ret = movreaddefault(c, pb, atom)) < 0) return ret; /* sanity checks */ if(sc->chunkcount && (!sc->sttscount || !sc->sampletochunksz || (!sc->samplesize && !sc->samplecount))){ avlog(c->fc, AVLOGERROR, \"stream %d, missing mandatory atoms, broken header\\n\", st->index); sc->samplecount = 0; //ignore track return 0; } if(!sc->timerate) sc->timerate=1; if(!sc->timescale) sc->timescale= c->timescale; avsetptsinfo(st, 64, sc->timerate, sc->timescale); if (st->codec->codectype == CODECTYPEAUDIO && !st->codec->framesize && sc->sttscount == 1) st->codec->framesize = avrescale(sc->timerate, st->codec->samplerate, sc->timescale); if(st->duration != AVNOPTSVALUE){ assert(st->duration % sc->timerate == 0); st->duration /= sc->timerate; } sc->ffindex = st->index; movbuildindex(c, st); if (sc->drefid-1 < sc->drefscount && sc->drefs[sc->drefid-1].path) { if (urlfopen(&sc->pb, sc->drefs[sc->drefid-1].path, URLRDONLY) < 0) avlog(c->fc, AVLOGERROR, \"stream %d, error opening file %s: %s\\n\", st->index, sc->drefs[sc->drefid-1].path, strerror(errno)); } else sc->pb = c->fc->pb; switch (st->codec->codecid) { #ifdef CONFIGH261DECODER case CODECIDH261: #endif #ifdef CONFIGH263DECODER case CODECIDH263: #endif #ifdef CONFIGMPEG4DECODER case CODECIDMPEG4: #endif st->codec->width= 0; /* let decoder init width/height */ st->codec->height= 0; break; #ifdef CONFIGVORBISDECODER case CODECIDVORBIS: #endif st->codec->samplerate= 0; /* let decoder init parameters properly */ break; } /* Do not need those anymore. */ avfreep(&sc->chunkoffsets); avfreep(&sc->sampletochunk); avfreep(&sc->samplesizes); avfreep(&sc->keyframes); avfreep(&sc->sttsdata); return 0; } ", "target": 0}
{"func": "static avcold int libschroedingerencodeinit(AVCodecContext *avctx) { SchroEncoderParams *pschroparams = avctx->privdata; SchroVideoFormatEnum preset; /* Initialize the libraries that libschroedinger depends on. */ schroinit(); /* Create an encoder object. */ pschroparams->encoder = schroencodernew(); if (!pschroparams->encoder) { avlog(avctx, AVLOGERROR, \"Unrecoverable Error: schroencodernew failed. \"); return -1; } /* Initialize the format. */ preset = ffgetschrovideoformatpreset(avctx); pschroparams->format = schroencodergetvideoformat(pschroparams->encoder); schrovideoformatsetstdvideoformat(pschroparams->format, preset); pschroparams->format->width = avctx->width; pschroparams->format->height = avctx->height; if (setchromaformat(avctx) == -1) return -1; if (avctx->colorprimaries == AVCOLPRIBT709) { pschroparams->format->colourprimaries = SCHROCOLOURPRIMARYHDTV; } else if (avctx->colorprimaries == AVCOLPRIBT470BG) { pschroparams->format->colourprimaries = SCHROCOLOURPRIMARYSDTV625; } else if (avctx->colorprimaries == AVCOLPRISMPTE170M) { pschroparams->format->colourprimaries = SCHROCOLOURPRIMARYSDTV525; } if (avctx->colorspace == AVCOLSPCBT709) { pschroparams->format->colourmatrix = SCHROCOLOURMATRIXHDTV; } else if (avctx->colorspace == AVCOLSPCBT470BG) { pschroparams->format->colourmatrix = SCHROCOLOURMATRIXSDTV; } if (avctx->colortrc == AVCOLTRCBT709) { pschroparams->format->transferfunction = SCHROTRANSFERCHARTVGAMMA; } if (ffgetschroframeformat(pschroparams->format->chromaformat, &pschroparams->frameformat) == -1) { avlog(avctx, AVLOGERROR, \"This codec currently supports only planar YUV 4:2:0, 4:2:2\" \" and 4:4:4 formats.\\n\"); return -1; } pschroparams->format->frameratenumerator = avctx->timebase.den; pschroparams->format->frameratedenominator = avctx->timebase.num; pschroparams->framesize = avpicturegetsize(avctx->pixfmt, avctx->width, avctx->height); avctx->codedframe = avframealloc(); if (!avctx->codedframe) return AVERROR(ENOMEM); if (!avctx->gopsize) { schroencodersettingsetdouble(pschroparams->encoder, \"gopstructure\", SCHROENCODERGOPINTRAONLY); if (avctx->codertype == FFCODERTYPEVLC) schroencodersettingsetdouble(pschroparams->encoder, \"enablenoarith\", 1); } else { schroencodersettingsetdouble(pschroparams->encoder, \"audistance\", avctx->gopsize); avctx->hasbframes = 1; pschroparams->dts = -1; } /* FIXME - Need to handle SCHROENCODERRATECONTROLLOWDELAY. */ if (avctx->flags & CODECFLAGQSCALE) { if (!avctx->globalquality) { /* lossless coding */ schroencodersettingsetdouble(pschroparams->encoder, \"ratecontrol\", SCHROENCODERRATECONTROLLOSSLESS); } else { int quality; schroencodersettingsetdouble(pschroparams->encoder, \"ratecontrol\", SCHROENCODERRATECONTROLCONSTANTQUALITY); quality = avctx->globalquality / FFQP2LAMBDA; if (quality > 10) quality = 10; schroencodersettingsetdouble(pschroparams->encoder, \"quality\", quality); } } else { schroencodersettingsetdouble(pschroparams->encoder, \"ratecontrol\", SCHROENCODERRATECONTROLCONSTANTBITRATE); schroencodersettingsetdouble(pschroparams->encoder, \"bitrate\", avctx->bitrate); } if (avctx->flags & CODECFLAGINTERLACEDME) /* All material can be coded as interlaced or progressive irrespective of the type of source material. */ schroencodersettingsetdouble(pschroparams->encoder, \"interlacedcoding\", 1); schroencodersettingsetdouble(pschroparams->encoder, \"opengop\", !(avctx->flags & CODECFLAGCLOSEDGOP)); /* FIXME: Signal range hardcoded to 8-bit data until both libschroedinger * and libdirac support other bit-depth data. */ schrovideoformatsetstdsignalrange(pschroparams->format, SCHROSIGNALRANGE8BITVIDEO); /* Set the encoder format. */ schroencodersetvideoformat(pschroparams->encoder, pschroparams->format); /* Set the debug level. */ schrodebugsetlevel(avctx->debug); schroencoderstart(pschroparams->encoder); /* Initialize the encoded frame queue. */ ffschroqueueinit(&pschroparams->encframequeue); return 0; } ", "target": 0}
{"func": "static struct omapmcbsps *omapmcbspinit(MemoryRegion *systemmemory, targetphysaddrt base, qemuirq txirq, qemuirq rxirq, qemuirq *dma, omapclk clk) { struct omapmcbsps *s = (struct omapmcbsps *) gmalloc0(sizeof(struct omapmcbsps)); s->txirq = txirq; s->rxirq = rxirq; s->txdrq = dma[0]; s->rxdrq = dma[1]; s->sinktimer = qemunewtimerns(vmclock, omapmcbspsinktick, s); s->sourcetimer = qemunewtimerns(vmclock, omapmcbspsourcetick, s); omapmcbspreset(s); memoryregioninitio(&s->iomem, &omapmcbspops, s, \"omap-mcbsp\", 0x800); memoryregionaddsubregion(systemmemory, base, &s->iomem); return s; } ", "target": 0}
{"func": "static void rv34predmv(RV34DecContext *r, int blocktype, int subblockno, int dmvno) { MpegEncContext *s = &r->s; int mvpos = s->mbx * 2 + s->mby * 2 * s->b8stride; int A[2] = {0}, B[2], C[2]; int i, j; int mx, my; int availindex = availindexes[subblockno]; int coff = partsizesw[blocktype]; mvpos += (subblockno & 1) + (subblockno >> 1)*s->b8stride; if(subblockno == 3) coff = -1; if(r->availcache[availindex - 1]){ A[0] = s->currentpictureptr->f.motionval[0][mvpos-1][0]; A[1] = s->currentpictureptr->f.motionval[0][mvpos-1][1]; } if(r->availcache[availindex - 4]){ B[0] = s->currentpictureptr->f.motionval[0][mvpos-s->b8stride][0]; B[1] = s->currentpictureptr->f.motionval[0][mvpos-s->b8stride][1]; }else{ B[0] = A[0]; B[1] = A[1]; } if(!r->availcache[availindex - 4 + coff]){ if(r->availcache[availindex - 4] && (r->availcache[availindex - 1] || r->rv30)){ C[0] = s->currentpictureptr->f.motionval[0][mvpos-s->b8stride-1][0]; C[1] = s->currentpictureptr->f.motionval[0][mvpos-s->b8stride-1][1]; }else{ C[0] = A[0]; C[1] = A[1]; } }else{ C[0] = s->currentpictureptr->f.motionval[0][mvpos-s->b8stride+coff][0]; C[1] = s->currentpictureptr->f.motionval[0][mvpos-s->b8stride+coff][1]; } mx = midpred(A[0], B[0], C[0]); my = midpred(A[1], B[1], C[1]); mx += r->dmv[dmvno][0]; my += r->dmv[dmvno][1]; for(j = 0; j < partsizesh[blocktype]; j++){ for(i = 0; i < partsizesw[blocktype]; i++){ s->currentpictureptr->f.motionval[0][mvpos + i + j*s->b8stride][0] = mx; s->currentpictureptr->f.motionval[0][mvpos + i + j*s->b8stride][1] = my; } } } ", "target": 0}
